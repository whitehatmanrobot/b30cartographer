)
    {
        RegisterInterface(IID_IDirectSound8, m_pImpDirectSound, (IDirectSound8*)m_pImpDirectSound);
        RegisterInterface(IID_IDirectSoundPrivate, m_pImpDirectSound, (IDirectSoundPrivate*)m_pImpDirectSound);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CreateSoundBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: description of the buffer to be
 *                                   created.
 *      CDirectSoundBuffer ** [out]: receives a pointer to the
 *                                   new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundBuffer"

HRESULT CDirectSound::CreateSoundBuffer(LPCDSBUFFERDESC pDesc, CDirectSoundBuffer **ppBuffer)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // COMPATCOMPAT: even though the spec says that you must call
    // SetCooperativeLevel before calling CreateSoundBuffer, previous
    // versions did not actually enforce this.

    // Cooperative level must be set before creating buffers
    if(!m_dsclCooperativeLevel.dwThreadId || DSSCL_NONE == m_dsclCooperativeLevel.dwPriority)
    {
        RPF(DPFLVL_INFO, "Called CreateSoundBuffer before SetCooperativeLevel");
    }

    // Create the buffer
    if(SUCCEEDED(hr))
    {
        if(pDesc->dwFlags & DSBCAPS_PRIMARYBUFFER)
        {
            hr = CreatePrimaryBuffer(pDesc, ppBuffer);
        }
        else
        {
            hr = CreateSecondaryBuffer(pDesc, ppBuffer);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateSinkBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: description of the buffer to be created.
 *      CDirectSoundBuffer ** [out]: receives a pointer to the new buffer.
 *      CDirectSoundSink * [in]: pointer to the owning sink object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSinkBuffer"

HRESULT CDirectSound::CreateSinkBuffer(LPDSBUFFERDESC pDesc, REFGUID guidBufferID, CDirectSoundSecondaryBuffer **ppBuffer, CDirectSoundSink *pOwningSink)
{
    DPF_ENTER();

    CHECK_READ_PTR(pDesc);
    CHECK_WRITE_PTR(ppBuffer);
    CHECK_WRITE_PTR(pOwningSink);

    // Add the flag which tags this buffer as owned by a sink
    pDesc->dwFlags |= DSBCAPS_SINKIN;

    // Create the buffer object
    CDirectSoundSecondaryBuffer *pBuffer = NEW(CDirectSoundSecondaryBuffer(this));
    HRESULT hr = HRFROMP(pBuffer);

    // FIXME: CDirectSoundSecondaryBuffer is begging to be refactored into a base class (traditional
    // buffer functionality) and a derived CDirectSoundSinkBuffer class with the extra functionality/
    // data relevant only to the sink (SetOwningSink, SetGUID).

    if(SUCCEEDED(hr))
    {
        pBuffer->SetDsVersion(GetDsVersion());  // Always succeeds
        hr = pBuffer->Initialize(pDesc, NULL);
    }
    if(SUCCEEDED(hr))
    {
        pBuffer->SetGUID(guidBufferID);         // Always succeeds
        pBuffer->SetOwningSink(pOwningSink);    // Always succeeds
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePrimaryBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: description of the buffer to be created.
 *      CDirectSoundBuffer ** [out]: receives a pointer to the
 *                                   new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreatePrimaryBuffer"

HRESULT CDirectSound::CreatePrimaryBuffer(LPCDSBUFFERDESC pDesc, CDirectSoundBuffer **ppBuffer)
{
    HRESULT                 hr;

    DPF_ENTER();

    // The primary buffer has already been created.  All we can do
    // here is change its flags.  The buffer will create and free
    // owned objects and interfaces based on the new flags.
    hr = m_pPrimaryBuffer->OnCreateSoundBuffer(pDesc->dwFlags);

    if(SUCCEEDED(hr))
    {
        *ppBuffer = m_pPrimaryBuffer;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateSecondaryBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: description of the buffer to be created.
 *      CDirectSoundBuffer ** [out]: receives a pointer to the
 *                                   new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSecondaryBuffer"

HRESULT CDirectSound::CreateSecondaryBuffer(LPCDSBUFFERDESC pDesc, CDirectSoundBuffer **ppBuffer)
{
    CDirectSoundSecondaryBuffer *   pBuffer;
    HRESULT                         hr;

    DPF_ENTER();

    // Create the buffer object
    pBuffer = NEW(CDirectSoundSecondaryBuffer(this));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        pBuffer->SetDsVersion(GetDsVersion());  // Always succeeds
        hr = pBuffer->Initialize(pDesc, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    // Handle any apphacked failures
    if(FAILED(hr) && FAILED(m_ahAppHacks.hrModifyCsbFailure))
    {
        hr = m_ahAppHacks.hrModifyCsbFailure;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  DuplicateSoundBuffer
 *
 *  Description:
 *      Duplicates an existing sound buffer object.
 *
 *  Arguments:
 *      CDirectSoundBuffer * [in]: source object.
 *      CDirectSoundBuffer ** [out]: receives new object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::DuplicateSoundBuffer"

HRESULT CDirectSound::DuplicateSoundBuffer(CDirectSoundBuffer *pSource, CDirectSoundBuffer **ppDest)
{
    CDirectSoundSecondaryBuffer *   pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    // Can't duplicate primary buffers
    if(pSource->m_dsbd.dwFlags & DSBCAPS_PRIMARYBUFFER)
    {
        RPF(DPFLVL_ERROR, "Can't duplicate primary buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Both the source and destination must be owned by this object
    if(SUCCEEDED(hr) && this != pSource->m_pDirectSound)
    {
        RPF(DPFLVL_ERROR, "Can't duplicate buffers from another DirectSound object");
        hr = DSERR_INVALIDCALL;
    }

    // Can't duplicate buffers that use new DX8 features
    if(SUCCEEDED(hr) && (pSource->m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN | DSBCAPS_CTRLFX)))
    {
        RPF(DPFLVL_ERROR, "Can't duplicate MIXIN/sink/effects buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        pBuffer = NEW(CDirectSoundSecondaryBuffer(this));
        hr = HRFROMP(pBuffer);
    }

    // Initialize the buffer
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(NULL, (CDirectSoundSecondaryBuffer *)pSource);
    }

    if(SUCCEEDED(hr))
    {
        *ppDest = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCAPS structure with capabilities of the object.
 *
 *  Arguments:
 *      LPDSCAPS pdscCaps [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetCaps"

HRESULT CDirectSound::GetCaps(LPDSCAPS pCaps)
{
    const DWORD             dwValidFlags    = DSCAPS_VALIDFLAGS & ~DSCAPS_CERTIFIED;
    DWORD                   dwCertification;
    HRESULT                 hr;

    DPF_ENTER();

    // Get device caps
    hr = m_pDevice->GetCaps(pCaps);

    // Make sure the caps conform to the DirectSound API
    if(SUCCEEDED(hr))
    {
        ASSERT(IS_VALID_FLAGS(pCaps->dwFlags, dwValidFlags));

        pCaps->dwFlags &= dwValidFlags;

#if 0 // NT bug 252552

        if(pCaps->dwMinSecondarySampleRate)
        {
            pCaps->dwMinSecondarySampleRate = BETWEEN(pCaps->dwMinSecondarySampleRate, DSBFREQUENCY_MIN, DSBFREQUENCY_MAX);
        }

        if(pCaps->dwMaxSecondarySampleRate)
        {
            pCaps->dwMaxSecondarySampleRate = BETWEEN(pCaps->dwMaxSecondarySampleRate, DSBFREQUENCY_MIN, DSBFREQUENCY_MAX);
        }

#endif // 0

        if(!(pCaps->dwFlags & DSCAPS_EMULDRIVER))
        {
            pCaps->dwPrimaryBuffers = 1;
        }
    }

    // Get certification
    if(SUCCEEDED(hr))
    {
        hr = g_pVadMgr->GetDriverCertificationStatus(m_pDevice, &dwCertification);
    }

    if(SUCCEEDED(hr) && VERIFY_CERTIFIED == dwCertification)
    {
        pCaps->dwFlags |= DSCAPS_CERTIFIED;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCooperativeLevel
 *
 *  Description:
 *      Sets the object's cooperative level.
 *
 *  Arguments:
 *      HWND [in]: window handle to associate sounds with.
 *      DWORD [in]: cooperative level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetCooperativeLevel"

HRESULT CDirectSound::SetCooperativeLevel(DWORD dwThreadId, DWORD dwPriority)
{
    HRESULT                 hr      = DS_OK;
    DSCOOPERATIVELEVEL      dsclOld;

    DPF_ENTER();
    RPF(DPFLVL_INFO, "Setting DirectSound cooperative level to %s",
        dwPriority == DSSCL_NORMAL ? TEXT("DSSCL_NORMAL") :
        dwPriority == DSSCL_PRIORITY ? TEXT("DSSCL_PRIORITY") :
        dwPriority == DSSCL_EXCLUSIVE ? TEXT("DSSCL_EXCLUSIVE (treated as DSSCL_PRIORITY)") :
        dwPriority == DSSCL_WRITEPRIMARY ? TEXT("DSSCL_WRITEPRIMARY") :
        TEXT("an impossible level"));

#if 0

    // COMPATCOMPAT: In previous versions of DirectSound, any number of
    // DirectSound objects could have cooperative level set on the same
    // thread, producing unknown results.  In this version, we fail the
    // call if any other app already has cooperative level set on the given
    // thread.

    // Make sure no other DirectSound object has cooperative level set on
    // this thread
    for(CNode<CDirectSound *> *pObjectNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pObjectNode && SUCCEEDED(hr); pObjectNode = pObjectNode->m_pNext)
    {
        if(this != pObjectNode->m_data && dwThreadId == pObjectNode->m_data->m_dsclCooperativeLevel.dwThreadId)
        {
            RPF(DPFLVL_ERROR, "Another DirectSound object already has coperative level set on the specified thread");
            hr = DSERR_OTHERAPPHASPRIO;
        }
    }

#endif

    // Save the current settings
    if(SUCCEEDED(hr))
    {
        CopyMemory(&dsclOld, &m_dsclCooperativeLevel, sizeof(dsclOld));
    }

    if(SUCCEEDED(hr) && (m_dsclCooperativeLevel.dwThreadId != dwThreadId || m_dsclCooperativeLevel.dwPriority != dwPriority))
    {
        // Update local copies of the cooperative level.  The primary buffer
        // and Administrator expect these to be updated right away.
        m_dsclCooperativeLevel.dwThreadId = dwThreadId;
        m_dsclCooperativeLevel.dwPriority = dwPriority;

        // Update the focus state.  It's important that this happens before
        // we update the primary buffer.  If we're going WRITEPRIMARY, we
        // need the Administrator to stop all our playing secondary buffers
        // before we allow the primary buffer to do its thing.

#ifdef SHARED_THREAD_LIST
        g_pDsAdmin->UpdateSharedThreadList();
#endif // SHARED_THREAD_LIST

        g_pDsAdmin->UpdateGlobalFocusState(TRUE);

        // Allow the primary buffer to handle the change
        hr = m_pPrimaryBuffer->SetPriority(dwPriority);

        // If we failed, put things back the way they were
        if(FAILED(hr))
        {
            CopyMemory(&m_dsclCooperativeLevel, &dsclOld, sizeof(dsclOld));

#ifdef SHARED_THREAD_LIST
            g_pDsAdmin->UpdateSharedThreadList();
#endif // SHARED_THREAD_LIST

        }

        // Update the focus state one more time
        g_pDsAdmin->UpdateGlobalFocusState(TRUE);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetSpeakerConfig
 *
 *  Description:
 *      Gets device speaker configuration.
 *
 *  Arguments:
 *      LPDWORD [out]: receives speaker configuration.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetSpeakerConfig"

HRESULT CDirectSound::GetSpeakerConfig(LPDWORD pdwSpeakerConfig)
{
    DPF_ENTER();

    RhRegGetSpeakerConfig(m_hkeyParent, pdwSpeakerConfig);
    // We don't care about the return code

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Sets device speaker configuration.
 *
 *  Arguments:
 *      DWORD [in]: speaker configuration.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetSpeakerConfig"

HRESULT CDirectSound::SetSpeakerConfig(DWORD dwSpeakerConfig)
{
    DPF_ENTER();

    ASSERT(m_pDevice);

    // If the speaker config is STEREO and lacks a geometry, give it one:
    if (dwSpeakerConfig == DSSPEAKER_STEREO)
    {
        dwSpeakerConfig |= (DSSPEAKER_GEOMETRY_WIDE << 16);
    }

    // First we try to set the speaker configuration on the audio device.
    // This may well fail, since the device is already open and possibly
    // playing, and may not be able to reconfigure itself on the fly.
    HRESULT hr = m_pDevice->SetSpeakerConfig(dwSpeakerConfig);

    // If that succeeded, pass the speaker config to our 3D listener too
    if (SUCCEEDED(hr) && m_pPrimaryBuffer && m_pPrimaryBuffer->m_p3dListener)
    {
        m_pPrimaryBuffer->m_p3dListener->SetSpeakerConfig(dwSpeakerConfig);
    }

    // Regardless of the success or failure of the above, we must set the
    // new configuration in the registry
    RhRegSetSpeakerConfig(m_hkeyParent, dwSpeakerConfig);

    // Ignore any errors (for backwards compatibility)
    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  Compact
 *
 *  Description:
 *      Compacts memory used by the audio device to allocate buffers.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::Compact"

HRESULT CDirectSound::Compact(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(m_dsclCooperativeLevel.dwPriority < DSSCL_PRIORITY)
    {
        RPF(DPFLVL_ERROR, "Must set cooperative level to at least PRIORITY to compact memory");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // This function is not implemented in the device

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDeviceFormat
 *
 *  Description:
 *      Sets the device output format.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in/out]: device format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDeviceFormat"

HRESULT CDirectSound::SetDeviceFormat(LPWAVEFORMATEX pwfx)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = EnumStandardFormats(pwfx, pwfx) ? DS_OK : DSERR_ALLOCATED;

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDeviceFormatExact
 *
 *  Description:
 *      Sets the device output format.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDeviceFormatExact"

HRESULT CDirectSound::SetDeviceFormatExact(LPCWAVEFORMATEX pwfx)
{
    LPWAVEFORMATEX          pwfxCurrent = NULL;
    DWORD                   dwSize;
    HRESULT                 hr;

    DPF_ENTER();

    // Only change the format if it's different
    hr = m_pDevice->GetGlobalFormat(NULL, &dwSize);

    if(SUCCEEDED(hr))
    {
        pwfxCurrent = (LPWAVEFORMATEX)MEMALLOC_A(BYTE, dwSize);
        hr = HRFROMP(pwfxCurrent);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pDevice->GetGlobalFormat(pwfxCurrent, &dwSize);
    }

    if(SUCCEEDED(hr) && !CmpWfx(pwfxCurrent, pwfx))
    {
        hr = m_pDevice->SetGlobalFormat(pwfx);

        if(SUCCEEDED(hr))
        {
            DPF(DPFLVL_INFO, "Device output format set to %lu Hz, %u-bit, %s...", pwfx->nSamplesPerSec, pwfx->wBitsPerSample, (1 == pwfx->nChannels) ? TEXT("mono") : TEXT("stereo"));
        }
    }

    MEMFREE(pwfxCurrent);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EnumStandardFormatsCallback
 *
 *  Description:
 *      Callback function for EnumStandardFormats used when calling
 *      CDirectSoundPrimaryBuffer::SetFormat.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *
 *  Returns:
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::EnumStandardFormatsCallback"

BOOL CDirectSound::EnumStandardFormatsCallback(LPCWAVEFORMATEX pwfx)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = SetDeviceFormatExact(pwfx);

    DPF_LEAVE(FAILED(hr));

    return FAILED(hr);
}


/***************************************************************************
 *
 *  SetDeviceVolume
 *
 *  Description:
 *      Sets the device output volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDeviceVolume"

HRESULT CDirectSound::SetDeviceVolume(LONG lVolume)
{
    DSVOLUMEPAN             dsvp;
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice->GetGlobalAttenuation(&dsvp);

    if(SUCCEEDED(hr))
    {
        FillDsVolumePan(lVolume, dsvp.lPan, &dsvp);

        hr = m_pDevice->SetGlobalAttenuation(&dsvp);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDevicePan
 *
 *  Description:
 *      Sets the device output pan.
 *
 *  Arguments:
 *      LONG [in]: pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDevicePan"

HRESULT CDirectSound::SetDevicePan(LONG lPan)
{
    DSVOLUMEPAN             dsvp;
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice->GetGlobalAttenuation(&dsvp);

    if(SUCCEEDED(hr))
    {
        FillDsVolumePan(dsvp.lVolume, lPan, &dsvp);

        hr = m_pDevice->SetGlobalAttenuation(&dsvp);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AllocSink
 *
 *  Description:
 *      Allocates a sink
 *
 *  Arguments:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::AllocSink"

HRESULT CDirectSound::AllocSink(LPWAVEFORMATEX pwfex, CDirectSoundSink **ppSink)
{
    HRESULT                 hr = DS_OK;
    DPF_ENTER();

    CDirectSoundSink *pSink = NEW(CDirectSoundSink(this));

    hr = HRFROMP(pSink);

    if (SUCCEEDED(hr))
    {
        hr = pSink->Initialize(pwfex, m_pDevice->m_vdtDeviceType);
    }

    if (SUCCEEDED(hr))
    {
        *ppSink = pSink;
    }

    if (FAILED(hr))
    {
        MEMFREE(pSink);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  VerifyCertification
 *
 *  Description:
 *      Checks the certification status of the driver
 *
 *  Arguments:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::VerifyCertification"

HRESULT CDirectSound::VerifyCertification(LPDWORD lpdwCertified)
{
    HRESULT                 hr = DS_OK;
    DWORD                   dwCertified;
    DPF_ENTER();

    hr = m_pDevice->GetCertification(&dwCertified, FALSE);

    if(SUCCEEDED(hr))
    {
        *lpdwCertified = ((VERIFY_CERTIFIED == dwCertified)?DS_CERTIFIED:DS_UNCERTIFIED);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#ifdef FUTURE_WAVE_SUPPORT
/***************************************************************************
 *
 *  CreateSoundBufferFromWave
 *
 *  Description:
 *      Checks the certification status of the driver
 *
 *  Arguments:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundBufferFromWave"

HRESULT CDirectSound::CreateSoundBufferFromWave(IDirectSoundWave *pWave, DWORD dwFlags, CDirectSoundBuffer **ppDsBuffer)
{
    DPF_ENTER();
    HRESULT hr = DS_OK;

    // FIXME - to do

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // FUTURE_WAVE_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsprvobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.h
 *  Content:    DirectSound Private Object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/05/97    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSPRVOBJ_H__
#define __DSPRVOBJ_H__

#ifdef __cplusplus

// The DirectSound Private object
class CDirectSoundPrivate
    : public CUnknown, public CPropertySetHandler
{
protected:
    // Property handlers
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundMixer);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundDevice);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundBasicAcceleration);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundDebug);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundPersistentData);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundBuffer);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSound);

    // Property sets
    DECLARE_PROPERTY_SET_DATA_MEMBER(m_aPropertySets);

private:
    // Interfaces
    CImpKsPropertySet<CDirectSoundPrivate> *m_pImpKsPropertySet;

public:
    CDirectSoundPrivate(void);
    virtual ~CDirectSoundPrivate(void);

public:
    // Property handlers
    static HRESULT WINAPI GetMixerSrcQuality(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA, PULONG);
    static HRESULT WINAPI SetMixerSrcQuality(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA, ULONG);

    static HRESULT WINAPI GetMixerAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA, PULONG);
    static HRESULT WINAPI SetMixerAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA, ULONG);

    static HRESULT WINAPI GetDevicePresence(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA, PULONG);
    static HRESULT WINAPI GetDevicePresence1(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA, PULONG);
    static HRESULT WINAPI SetDevicePresence(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA, ULONG);
    static HRESULT WINAPI SetDevicePresence1(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA, ULONG);

    static HRESULT WINAPI GetWaveDeviceMappingA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA, PULONG);
    static HRESULT WINAPI GetWaveDeviceMappingW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA, PULONG);
    
    static HRESULT WINAPI GetDeviceDescriptionA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, PULONG);
    static HRESULT WINAPI GetDeviceDescriptionW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, PULONG);
    static HRESULT WINAPI GetDeviceDescription1(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, PULONG);

    static HRESULT WINAPI EnumerateDevicesA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA, PULONG);
    static HRESULT WINAPI EnumerateDevicesW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA, PULONG);
    static HRESULT WINAPI EnumerateDevices1(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA, PULONG);

    static HRESULT WINAPI GetDebugDpfInfoA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA, PULONG);
    static HRESULT WINAPI GetDebugDpfInfoW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA, PULONG);
    static HRESULT WINAPI SetDebugDpfInfoA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA, ULONG);
    static HRESULT WINAPI SetDebugDpfInfoW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA, ULONG);

    static HRESULT WINAPI TranslateResultCodeA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA, PULONG);
    static HRESULT WINAPI TranslateResultCodeW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA, PULONG);

    static HRESULT WINAPI GetBasicAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA, PULONG);
    static HRESULT WINAPI SetBasicAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA, ULONG);
    static HRESULT WINAPI GetDefaultAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT_DATA, PULONG);

    static HRESULT WINAPI GetDefaultDataA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA, PULONG);
    static HRESULT WINAPI GetDefaultDataW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA, PULONG);

    static HRESULT WINAPI GetPersistentDataA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA, PULONG);
    static HRESULT WINAPI GetPersistentDataW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA, PULONG);
    static HRESULT WINAPI SetPersistentDataA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA, ULONG);
    static HRESULT WINAPI SetPersistentDataW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA, ULONG);

    static HRESULT WINAPI GetBufferDeviceId(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA, PULONG);

    static HRESULT WINAPI GetDirectSoundObjects(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUND_OBJECTS_DATA, PULONG);
    static HRESULT WINAPI GetDirectSoundCaptureObjects(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA, PULONG);

private:
    static HRESULT WINAPI GetWaveDeviceMapping(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA, PULONG);
    static HRESULT WINAPI GetPersistentData(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA, PULONG);
    static HRESULT WINAPI GetDefaultData(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA, PULONG);
    static HRESULT WINAPI SetPersistentData(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA, ULONG);
    static HRESULT OpenPersistentDataKey(REFGUID, PHKEY);
    static HRESULT CvtDriverDescA(CDeviceDescription *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, PULONG);
    static HRESULT CvtDriverDescW(CDeviceDescription *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, PULONG);
    static HRESULT CvtDriverDesc1(CDeviceDescription *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA);
};

inline HRESULT WINAPI CDirectSoundPrivate::GetPersistentData(CDirectSoundPrivate *pThis, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA pData, PULONG pcbData)
{
#ifdef UNICODE
    return GetPersistentDataW(pThis, pData, pcbData);
#else // UNICODE
    return GetPersistentDataA(pThis, pData, pcbData);
#endif // UNICODE
}

inline HRESULT WINAPI CDirectSoundPrivate::SetPersistentData(CDirectSoundPrivate *pThis, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA pData, ULONG cbData)
{
#ifdef UNICODE
    return SetPersistentDataW(pThis, pData, cbData);
#else // UNICODE
    return SetPersistentDataA(pThis, pData, cbData);
#endif // UNICODE
}

inline HRESULT WINAPI CDirectSoundPrivate::GetDefaultData(CDirectSoundPrivate *pThis, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA pData, PULONG pcbData)
{
#ifdef UNICODE
    return GetDefaultDataW(pThis, pData, pcbData);
#else // UNICODE
    return GetDefaultDataA(pThis, pData, pcbData);
#endif // UNICODE
}


#endif // __cplusplus

#endif // __DSPRVOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dssink.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dssink.cpp
 *  Content:    Implementation of CDirectSoundSink and CImpSinkKsControl
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/23/99    jimge   Created
 *  09/27/99    petchey Continued implementation
 *  04/15/00    duganp  Completed implementation
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <math.h>  // For log10()

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::CDirectSoundSink"


/***************************************************************************
 *
 * CDirectSoundSink methods
 *
 ***************************************************************************/


CDirectSoundSink::CDirectSoundSink(CDirectSound *pDirectSound)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundSink);

    m_pDirectSound = pDirectSound;

    // DirectSound sink objects are inherently DX8 objects
    SetDsVersion(DSVERSION_DX8);

    // Initialize list of internal arrays
    m_InternalArrayList[i_m_pdwBusIDs]          = NEW(DSSinkArray(&m_pdwBusIDs, sizeof(DWORD)));
    m_InternalArrayList[i_m_pdwFuncIDs]         = NEW(DSSinkArray(&m_pdwFuncIDs, sizeof(DWORD)));
    m_InternalArrayList[i_m_plPitchBends]       = NEW(DSSinkArray(&m_plPitchBends, sizeof(long)));
    m_InternalArrayList[i_m_pdwActiveBusIDs]    = NEW(DSSinkArray(&m_pdwActiveBusIDs, sizeof(DWORD)));
    m_InternalArrayList[i_m_pdwActiveFuncIDs]   = NEW(DSSinkArray(&m_pdwActiveFuncIDs, sizeof(DWORD)));
    m_InternalArrayList[i_m_pdwActiveBusIDsMap] = NEW(DSSinkArray(&m_pdwActiveBusIDsMap, sizeof(DWORD)));
    m_InternalArrayList[i_m_ppvStart]           = NEW(DSSinkArray(&m_ppvStart, sizeof(LPVOID)));
    m_InternalArrayList[i_m_ppvEnd]             = NEW(DSSinkArray(&m_ppvEnd, sizeof(LPVOID)));
    m_InternalArrayList[i_m_ppDSSBuffers]       = (DSSinkArray*)NEW(DSSinkBuffersArray(&m_ppDSSBuffers, sizeof(DSSinkBuffers)));
    m_InternalArrayList[i_m_pDSSources]         = (DSSinkArray*)NEW(DSSinkSourceArray(&m_pDSSources, sizeof(DSSinkSources)));

    // Everything else gets initialized to 0 by our memory allocator

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::~CDirectSoundSink"

CDirectSoundSink::~CDirectSoundSink()
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundSink);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    // Make sure we're inactive (i.e. unregistered with the streaming thread)
    Activate(FALSE);

    RELEASE(m_pIMasterClock);

    MEMFREE(m_pdwBusIDs);
    MEMFREE(m_pdwFuncIDs);
    MEMFREE(m_plPitchBends);
    MEMFREE(m_pdwActiveBusIDs);
    MEMFREE(m_pdwActiveFuncIDs);
    MEMFREE(m_pdwActiveBusIDsMap);
    MEMFREE(m_ppvStart);
    MEMFREE(m_ppvEnd);

    DELETE(m_ppDSSBuffers);
    DELETE(m_pDSSources);

    DELETE(m_pImpDirectSoundSink);
    DELETE(m_pImpKsControl);

    for (int i = 0; i < NUM_INTERNAL_ARRAYS; i++)
        DELETE(m_InternalArrayList[i]);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::Initialize"

HRESULT CDirectSoundSink::Initialize(LPWAVEFORMATEX pwfex, VADDEVICETYPE vdtDeviceType)
{
    DPF_ENTER();

    // Get our owning streaming thread
    m_pStreamingThread = GetStreamingThread();
    HRESULT hr = HRFROMP(m_pStreamingThread);

    if (SUCCEEDED(hr))
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundConnect, this, &m_pImpDirectSoundSink);

    if (SUCCEEDED(hr))
        hr = RegisterInterface(IID_IDirectSoundSynthSink, m_pImpDirectSoundSink, (IDirectSoundSynthSink*)m_pImpDirectSoundSink);

    if (SUCCEEDED(hr))
        hr = CreateAndRegisterInterface(this, IID_IKsControl, this, &m_pImpKsControl);

    if (SUCCEEDED(hr))
    {
        // Future version: Make this work with wave format extensible.
        m_wfx = *pwfex;

        m_dwBusSize = INTERNAL_BUFFER_LENGTH;
        m_dwLatency = SINK_INITIAL_LATENCY;  // Will automatically drop to a better level if possible

        #ifdef DEBUG_TIMING  // Read some timing parameters from the registry
        HKEY hkey;
        if (SUCCEEDED(RhRegOpenPath(HKEY_CURRENT_USER, &hkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, TEXT("Streaming thread settings"))))
        {
            if (SUCCEEDED(RhRegGetBinaryValue(hkey, TEXT("Sink buffer size"), &m_dwBusSize, sizeof m_dwBusSize)))
                DPF(DPFLVL_INFO, "Read initial sink buffer size %lu from registry", m_dwBusSize);
            if (SUCCEEDED(RhRegGetBinaryValue(hkey, TEXT("Sink latency"), &m_dwLatency, sizeof m_dwLatency)))
                DPF(DPFLVL_INFO, "Read initial sink latency %lu from registry", m_dwLatency);
            RhRegCloseKey(&hkey);
        }
        #endif

        // Hack to support our strangely broken emulation mixer (bug 42145)
        if (IS_EMULATED_VAD(vdtDeviceType))
            m_dwLatency += EMULATION_LATENCY_BOOST;

        // Can't have a latency of more than half our buffer size
        if (m_dwLatency > m_dwBusSize/2)
            m_dwLatency = m_dwBusSize/2;

        m_dwBusSize = MsToBytes(m_dwBusSize, &m_wfx);

        m_LatencyClock.Init(this);

        DPF(DPFLVL_MOREINFO, "Initializing DirectSound sink object:");
        DPF(DPFLVL_MOREINFO, "\tChannels     = %d", m_wfx.nChannels);
        DPF(DPFLVL_MOREINFO, "\tSample Rate  = %d", m_wfx.nSamplesPerSec);
        DPF(DPFLVL_MOREINFO, "\tBytes/Second = %d", m_wfx.nAvgBytesPerSec);
        DPF(DPFLVL_MOREINFO, "\tBlock Align  = %d", m_wfx.nBlockAlign);
        DPF(DPFLVL_MOREINFO, "\tBits/Sample  = %d", m_wfx.wBitsPerSample);
        DPF(DPFLVL_MOREINFO, "\tBus Size     = %d", m_dwBusSize);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

LPVOID CDirectSoundSink::DSSinkArray::Grow(DWORD dwgrowby)
{
    void *ptr;
    DWORD dwnumitems = m_numitems + dwgrowby;
    DWORD dwallocsize = m_itemsize*dwnumitems;

    ptr = MEMALLOC_A(char, dwallocsize);
    if (!ptr)
    {
        return NULL;
    }

    if (m_pvarray)
    {
        if (*((void**)m_pvarray))
        {
            ZeroMemory(ptr, dwallocsize);
            CopyMemory(ptr, *((void**)m_pvarray), m_itemsize*m_numitems);
            MEMFREE(*((void**)m_pvarray));
        }
    }

    *((void**)m_pvarray) = ptr;
    m_numitems = dwnumitems;

    return ptr;
}

LPVOID CDirectSoundSink::DSSinkBuffersArray::Grow(DWORD dwgrowby)
{
    void *ptr;
    DWORD dwnumitems = m_numitems + dwgrowby;

    ptr = NEW(DSSinkBuffers[dwnumitems]);
    if (!ptr)
    {
        return NULL;
    }

    if (m_pvarray)
    {
        if (*((void**)m_pvarray))
        {
            for (DWORD i = 0; i < m_numitems; i++)
            {
                ((DSSinkBuffers*)ptr)[i] = (*((DSSinkBuffers**)m_pvarray))[i];
            }
        }
        DELETE(*((void**)m_pvarray));
    }


    *((void**)m_pvarray) = ptr;
    m_numitems = dwnumitems;

    return ptr;
}

LPVOID CDirectSoundSink::DSSinkSourceArray::Grow(DWORD dwgrowby)
{
    void *ptr;
    DWORD dwnumitems = m_numitems + dwgrowby;

    ptr = NEW(DSSinkSources[dwnumitems]);
    if (!ptr)
    {
        return NULL;
    }

    if (m_pvarray)
    {
        if (*((void**)m_pvarray))
        {
            for (DWORD i = 0; i < m_numitems; i++)
            {
                ((DSSinkSources*)ptr)[i] = (*((DSSinkSources**)m_pvarray))[i];
            }
        }
        DELETE(*((void**)m_pvarray));
    }


    *((void**)m_pvarray) = ptr;
    m_numitems = dwnumitems;

    return ptr;
}

HRESULT CDirectSoundSink::DSSinkBuffers::Initialize(DWORD dwBusBufferSize)
{
    HRESULT hr = DS_OK;

    for (DWORD i = 0; i < m_dwBusCount; i++)
    {
        // These are all initialized to NULL in the constructor
        m_pvBussStart[i] = MEMALLOC_A(char, dwBusBufferSize);
        m_pvBussEnd[i]   = MEMALLOC_A(char, dwBusBufferSize);

        if (m_pvBussStart[i] == NULL || m_pvBussEnd[i] == NULL)
        {
            hr = DSERR_OUTOFMEMORY;

            // ERROR: Let's delete all of the memory we allocated
            for (i = 0; i < MAX_BUSIDS_PER_BUFFER; i++)
            {
                MEMFREE(m_pvBussStart[i]);
                MEMFREE(m_pvBussEnd[i]);
            }

            break;
        }

        ZeroMemory(m_pvBussStart[i], dwBusBufferSize);
        ZeroMemory(m_pvBussEnd[i], dwBusBufferSize);
    }

    if (SUCCEEDED(hr))
    {
        for (; i < MAX_BUSIDS_PER_BUFFER; i++)
        {
            m_pvBussStart[i] = NULL;
            m_pvBussEnd[i]   = NULL;
        }

        // Clear the remaining part of the arrays
        for (i = m_dwBusCount; i < MAX_BUSIDS_PER_BUFFER; i++) // Fill the reset up with null IDs
        {
            m_pdwBusIndex[i]  = -1;
            m_pdwBusIds[i]    = DSSINK_NULLBUSID;
            m_pdwFuncIds[i]   = DSSINK_NULLBUSID;
        }
        m_lPitchBend = 0;
    }
    return hr;
}

HRESULT CDirectSoundSink::GrowBusArrays(DWORD dwgrowby)
{
    DWORD dwnumitems = m_dwBusIDsAlloc + dwgrowby;

    if (dwgrowby == 0)
        return S_FALSE;

    dwnumitems = (dwnumitems + BUSID_BLOCK_SIZE - 1) & ~(BUSID_BLOCK_SIZE-1);

    for (DWORD i = i_m_pdwBusIDs; i <= i_m_ppvEnd; i++)
    {
        m_InternalArrayList[i]->Grow(dwnumitems);
    }

    if (m_pdwBusIDs        == NULL ||
         m_pdwFuncIDs       == NULL ||
         m_plPitchBends     == NULL ||
         m_pdwActiveBusIDs  == NULL ||
         m_pdwActiveFuncIDs == NULL ||
         m_ppDSSBuffers     == NULL ||
         m_ppvStart         == NULL ||
         m_ppvEnd           == NULL)
    {
        return DSERR_OUTOFMEMORY;
    }

    m_dwBusIDsAlloc += dwnumitems;

    return DS_OK;
}

HRESULT CDirectSoundSink::GrowSourcesArrays(DWORD dwgrowby)
{
    DWORD dwnumitems = m_dwDSSourcesAlloc + dwgrowby;

    if (dwgrowby == 0)
        return S_FALSE;

    dwnumitems = (dwnumitems + SOURCES_BLOCK_SIZE - 1) & ~(SOURCES_BLOCK_SIZE-1);

    m_InternalArrayList[i_m_pDSSources]->Grow(dwnumitems);

    if (m_pDSSources == NULL)
    {
        return DSERR_OUTOFMEMORY;
    }

    m_dwDSSourcesAlloc += dwnumitems;

    return DS_OK;
}

HRESULT CDirectSoundSink::SetBufferFrequency(CSecondaryRenderWaveBuffer *pBuffer, DWORD dwFrequency)
{
    // Find the buffer, then set its m_lPitchBend to a relative offset.
    // The relative offset is calculated by converting the difference in the buffer sample rate
    // to dwFrequency into a ratio of pitches and converting that ratio into pitch cents.
    for (DWORD dwBuffer = 0; dwBuffer < m_dwDSSBufCount; dwBuffer++)
    {
        if (pBuffer == m_ppDSSBuffers[dwBuffer].m_pDSBuffer->m_pDeviceBuffer)
        {
            double fTemp = (double) dwFrequency / (double) m_wfx.nSamplesPerSec;
            fTemp = log10(fTemp);
            fTemp *= 1200 * 3.3219280948873623478703194294894;    // Convert from Log10 to Log2 and multiply by cents per octave.
            m_ppDSSBuffers[dwBuffer].m_lPitchBend = (long) fTemp;
            UpdatePitchArray();
            return S_OK;
        }
    }
    return DSERR_INVALIDPARAM;
}

void CDirectSoundSink::UpdatePitchArray()
{
    // For each buffer:
    DWORD dwBuffer;
    for (dwBuffer = 0; dwBuffer < m_dwDSSBufCount; dwBuffer++)
    {
        // For each bus in each buffer:
        DWORD dwBusIndex;
        for (dwBusIndex = 0; dwBusIndex < m_ppDSSBuffers[dwBuffer].m_dwBusCount; dwBusIndex++)
        {
            DWORD dwGlobalBusIndex = m_ppDSSBuffers[dwBuffer].m_pdwBusIndex[dwBusIndex];
            m_plPitchBends[dwGlobalBusIndex] = m_ppDSSBuffers[dwBuffer].m_lPitchBend;
        }
    }
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::AddBuffer"

HRESULT CDirectSoundSink::AddBuffer(CDirectSoundBuffer *pDSBuffer, LPDWORD pdwNewFuncIDs, DWORD dwNewFuncIDsCount, DWORD dwNewBusIDsCount)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

#ifdef DEBUG
    // This function is only called internally.  It must be passed
    // a secondary buffer to make the cast below correct.
    DSBCAPS caps = {sizeof caps};
    HRESULT hrTemp = pDSBuffer->GetCaps(&caps);
    ASSERT(SUCCEEDED(hrTemp));
    ASSERT(!(caps.dwFlags & DSBCAPS_PRIMARYBUFFER));
#endif

    //
    // Check and set the range on the new bussid count
    //
    if (dwNewBusIDsCount < 1)
        dwNewBusIDsCount = 1;

    if (dwNewBusIDsCount > MAX_BUSIDS_PER_BUFFER)
        dwNewBusIDsCount = MAX_BUSIDS_PER_BUFFER;

    if (dwNewFuncIDsCount > dwNewBusIDsCount)
        dwNewFuncIDsCount = dwNewBusIDsCount;   // Can't have more functional IDs than bus IDs

    //
    // Reallocate buffers
    //
    if (m_dwBusIDs + dwNewBusIDsCount >= m_dwBusIDsAlloc)
    {
        hr = GrowBusArrays(dwNewBusIDsCount);  // More than we need, but what the heck
    }

    if (SUCCEEDED(hr))
    {
        DWORD i,j,l;
        DWORD dwNewBusIDIndex = m_dwBusIDs;

        // Add new ID's to master sink array's of id's
        for (i = 0; i < dwNewBusIDsCount; i++)
        {
            m_pdwBusIDs[dwNewBusIDIndex + i]  = m_dwNextBusID;
            if (i < dwNewFuncIDsCount)
            {
                m_pdwFuncIDs[dwNewBusIDIndex + i] = pdwNewFuncIDs[i];
            }
            else
            {
                m_pdwFuncIDs[dwNewBusIDIndex + i] = DSSINK_NULLBUSID;
            }

            m_dwNextBusID++;
            // we have rolled over, this case is very hard to get too, so we just bail
            // it would take 136years to get to if one created a new sound buffer every second
            if (m_dwNextBusID == DSSINK_NULLBUSID)
            {
                return E_FAIL;
            }
        }

        if (dwNewFuncIDsCount > 1)
        {
            // !!!!!!!!! Important asumption read !!!!!!!!!!!
            //
            // This is very important since, this is a built in assumption
            // By ordering the function ids, the coresponding bus id's are
            // also order in increasing value. Thus buses are appropriatly
            // mapped to their repective functionality in a interleaved buffer
            // For example if one passes in function ids right and left
            // in that order there will be swapped thus mapping correctly
            // to the appropriate interleaved channel. The DLS2 spec
            // states that channels are interleaved in their increasing
            // value of their functional ids.
            //
            // Ahh.. the old stand by, the bubble sort, an N^2 alogrithim
            // with a hopelessly wasteful use of cpu time moving and then
            // re-moving elements around. However in this case it is efficient,
            // since generally there will only be two elements in the array.
            // And when the day comes when we may handle N levels of interleaving
            // it should be converted to the straight insertion method instead.
            // If only as an exercise to remind one self that there are other
            // simple efficient sorts out there. The reason that their is a
            // sort at all is to handle any crazy person who passes in more
            // than 2 function IDs.

            for (i = dwNewBusIDIndex; i < dwNewBusIDIndex + dwNewFuncIDsCount; i++)
            {
                // Null busids are considered an undefined channel
                if (m_pdwFuncIDs[i] == DSSINK_NULLBUSID)
                {
                    continue;
                }

                for (j = i + 1; j < dwNewBusIDIndex + dwNewFuncIDsCount; j++)
                {
                    if (m_pdwFuncIDs[j] == DSSINK_NULLBUSID)
                    {
                        continue;
                    }

                    if (m_pdwFuncIDs[i] > m_pdwFuncIDs[j])
                    {
                        DWORD temp = m_pdwFuncIDs[i];
                        m_pdwFuncIDs[i] = m_pdwFuncIDs[j];
                        m_pdwFuncIDs[j] = temp;
                    }
                }
            }
        }

        //
        // Initialize new sound buffer wrapper object
        //
        DSSinkBuffers &pDSSBuffer = m_ppDSSBuffers[m_dwDSSBufCount];

        pDSSBuffer.m_pDSBuffer  = (CDirectSoundSecondaryBuffer*)pDSBuffer;
        pDSSBuffer.m_dwBusCount = dwNewBusIDsCount;

        for (i = 0; i < dwNewBusIDsCount; i++)
        {
            pDSSBuffer.m_pdwBusIds[i]   = m_pdwBusIDs[dwNewBusIDIndex+i];
            pDSSBuffer.m_pdwBusIndex[i] = dwNewBusIDIndex+i;

            if (i < dwNewFuncIDsCount)
            {
                pDSSBuffer.m_pdwFuncIds[i] = m_pdwFuncIDs[dwNewBusIDIndex+i];
            }
            else
            {
                pDSSBuffer.m_pdwFuncIds[i] = DSSINK_NULLBUSID;
            }
        }

        hr = pDSSBuffer.Initialize(m_dwBusSize);  // Allocate all internal arrays


        if (SUCCEEDED(hr))
        {
            m_ppDSSBuffers[m_dwDSSBufCount].m_pDSBuffer->ClearWriteBuffer();  // Fill the buffer with silence

            m_dwDSSBufCount++;
            m_dwBusIDs += dwNewBusIDsCount;

            // Remap all busid indexes
            for (i = 0; i < m_dwDSSBufCount; i++)
            {
                // Find the bus id in the buffer object
                for (j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
                {
                    for (l = 0; l < m_dwBusIDs; l++)
                    {
                        if (m_ppDSSBuffers[i].m_pdwBusIds[j] == m_pdwBusIDs[l])
                        {
                            m_ppDSSBuffers[i].m_pdwBusIndex[j] = l;
                            break;
                        }
                    }
                }
            }

            for (i = 0; i < m_dwDSSources; i++)
            {
                for (j = 0; j < m_dwBusIDs; j++)
                {
                    if (m_pdwBusIDs[j] == m_pDSSources[i].m_dwBusID)
                    {
                        m_pDSSources[i].m_dwBusIndex = j;
                        break;
                    }
                }
            }

            DPF(DPFLVL_INFO, "Adding Bus [%d]", m_dwDSSBufCount-1);
            DPF(DPFLVL_INFO, "Number Buses = %d", dwNewBusIDsCount);
            for (i = 0; i < dwNewBusIDsCount; i++)
                DPF(DPFLVL_INFO, "Bus ID=%d  Function ID=%d", m_pdwBusIDs[dwNewBusIDIndex + i], m_pdwFuncIDs[dwNewBusIDIndex + i]);

            UpdatePitchArray();
        }
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::RemoveBuffer"

HRESULT CDirectSoundSink::RemoveBuffer(CDirectSoundBuffer *pDSBuffer)
{
    DWORD i,j,k,l;
    DPF_ENTER();

    for (i = 0; i < m_dwDSSBufCount; i++)
    {
        if (pDSBuffer == m_ppDSSBuffers[i].m_pDSBuffer)
        {
#ifdef DEBUG_SINK
            DPF(DPFLVL_INFO, "Removing Buffer %ld", i);
#endif
            // Find the bus id in the buffer objects
            for (j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
            {
                for (k = 0; k < m_dwBusIDs; k++)
                {
                    if (m_ppDSSBuffers[i].m_pdwBusIds[j] == m_pdwBusIDs[k])
                    {
                        // contract the main array
                        for (l = k; l < m_dwBusIDs-1; l++)
                        {
                            m_pdwBusIDs[l]  = m_pdwBusIDs[l+1];
                            m_pdwFuncIDs[l] = m_pdwFuncIDs[l+1];
                        }
                        m_pdwBusIDs[l]  = DSSINK_NULLBUSID;
                        m_pdwFuncIDs[l] = DSSINK_NULLBUSID;


                        m_dwBusIDs--;
                    }
                }
            }

            // Delete allocated memory
            for (l = 0; l < m_ppDSSBuffers[i].m_dwBusCount; l++)
            {
                if (m_ppDSSBuffers[i].m_pvBussStart[l])
                {
                    MEMFREE(m_ppDSSBuffers[i].m_pvBussStart[l]);
                    m_ppDSSBuffers[i].m_pvBussStart[l] = NULL;
                }

                if (m_ppDSSBuffers[i].m_pvBussEnd[l])
                {
                    MEMFREE(m_ppDSSBuffers[i].m_pvBussEnd[l]);
                    m_ppDSSBuffers[i].m_pvBussEnd[l] = NULL;
                }
            }

            // Contract array
            for (k = i; k < m_dwDSSBufCount-1; k++)
            {
                // Shift the whole thang over. (There was a bug before where only some fields were being copied down.)
                m_ppDSSBuffers[k] = m_ppDSSBuffers[k+1];
            }

            // Clear last structure
            m_ppDSSBuffers[k].m_pDSBuffer    = NULL;
            m_ppDSSBuffers[k].m_dwBusCount   = 0;
            m_ppDSSBuffers[k].m_pvDSBufStart = NULL;
            m_ppDSSBuffers[k].m_pvDSBufEnd   = NULL;
            m_ppDSSBuffers[k].dwStart        = 0;
            m_ppDSSBuffers[k].dwEnd          = 0;
            for (l = 0; l < MAX_BUSIDS_PER_BUFFER; l++)
            {
                m_ppDSSBuffers[k].m_pdwBusIndex[l] = DSSINK_NULLBUSID;
                m_ppDSSBuffers[k].m_pdwBusIds[l]   = DSSINK_NULLBUSID;
                m_ppDSSBuffers[k].m_pdwFuncIds[l]  = DSSINK_NULLBUSID;
                m_ppDSSBuffers[k].m_pvBussStart[l] = NULL;
                m_ppDSSBuffers[k].m_pvBussEnd[l]   = NULL;
            }

            m_dwDSSBufCount--;
            break;
        }
    }

    // Remap all busid indexes
    for (i = 0; i < m_dwDSSBufCount; i++)
    {
        // Find the bus id in the buffer object
        for (j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
        {
            for (l = 0; l < m_dwBusIDs; l++)
            {
                if (m_ppDSSBuffers[i].m_pdwBusIds[j] == m_pdwBusIDs[l])
                {
                    m_ppDSSBuffers[i].m_pdwBusIndex[j] = l;
                    break;
                }
            }
        }
    }

    for (i = 0; i < m_dwDSSources; i++)
    {
        for (j = 0; j < m_dwBusIDs; j++)
        {
            if (m_pdwBusIDs[j] == m_pDSSources[i].m_dwBusID)
            {
                m_pDSSources[i].m_dwBusIndex = j;
                break;
            }
        }
    }
    UpdatePitchArray();
    // BUGBUG WI 33785 goes here
    //
    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::AddSource"

HRESULT CDirectSoundSink::AddSource(IDirectSoundSource *pSource)
{
    DPF_ENTER();
    HRESULT hr = DS_OK;

    //
    // Check if source already exsists
    //
    for (DWORD i = 0; i < m_dwDSSources; i++)
    {
        if (pSource == m_pDSSources[i].m_pDSSource)
        {
            hr = S_FALSE;
        }
    }

    if (hr == DS_OK)
    {
        //
        // Reallocate buffers
        //
        if (m_dwDSSources + 1 >= m_dwDSSourcesAlloc)
        {
            hr = GrowSourcesArrays(1);
        }

        if (SUCCEEDED(hr))
        {
            if (pSource)
            {
                m_pDSSources[m_dwDSSources].m_pDSSource    = pSource;
#ifdef FUTURE_WAVE_SUPPORT
                m_pDSSources[m_dwDSSources].m_pWave        = NULL;
#endif
                m_pDSSources[m_dwDSSources].m_stStartTime  = 0;
                m_pDSSources[m_dwDSSources].m_dwBusID      = DSSINK_NULLBUSID;
                m_pDSSources[m_dwDSSources].m_dwBusCount   = 0;
                m_pDSSources[m_dwDSSources].m_dwBusIndex   = DSSINK_NULLBUSID;
                m_pDSSources[m_dwDSSources].m_bStreamEnd   = FALSE;
                m_pDSSources[m_dwDSSources].m_pDSSource->AddRef();
                m_dwDSSources++;
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::RemoveSource"

HRESULT CDirectSoundSink::RemoveSource(IDirectSoundSource *pSource)
{
    DPF_ENTER();

    HRESULT hr = DS_OK;
    DWORD i;

    //
    // Check if source exists
    //
    for (i = 0; i < m_dwDSSources; i++)
    {
        if (pSource == m_pDSSources[i].m_pDSSource)
        {
            break;
        }
    }

    if (i >= m_dwDSSources)
    {
        // Source not in this sink
        hr = DSERR_INVALIDPARAM;
    }

    if (SUCCEEDED(hr))
    {
#ifdef FUTURE_WAVE_SUPPORT
        // If this is a wave source, then remove associated sound buffer
        if (m_pDSSources[i].m_dwBusID != DSSINK_NULLBUSID)
        {
            for (DWORD j = 0; j < m_dwDSSBufCount; j++)
            {
                for (DWORD k = 0; k < m_ppDSSBuffers[j].m_dwBusCount; k++)
                {
                    if (m_ppDSSBuffers[j].m_pdwBusIds[k] == m_pDSSources[i].m_dwBusID)
                    {
//>>>>>>>>>>> look into this, possible critical section problem.
                        RELEASE(m_ppDSSBuffers[j].m_pDSBuffer);
//>>>> Should be:
//                        RemoveBuffer(m_ppDSSBuffers[j].m_pDSBuffer)
                        goto done;
                    }
                }
            }
        }
        done:
#endif

        // Remove source
        if (m_pDSSources[i].m_pDSSource)
        {
            m_pDSSources[i].m_pDSSource->Release();
        }
        m_pDSSources[i].m_pDSSource = NULL;

        // Contract arrays
        for (; i < m_dwDSSources-1; i++)
        {
            m_pDSSources[i] = m_pDSSources[i+1];
        }

        // Clear last element
        m_pDSSources[i].m_pDSSource    = NULL;
#ifdef FUTURE_WAVE_SUPPORT
        m_pDSSources[i].m_pWave        = NULL;
#endif
        m_pDSSources[i].m_stStartTime  = 0;
        m_pDSSources[i].m_dwBusID      = DSSINK_NULLBUSID;
        m_pDSSources[i].m_dwBusCount   = 0;
        m_pDSSources[i].m_dwBusIndex   = DSSINK_NULLBUSID;
        m_pDSSources[i].m_bStreamEnd   = FALSE;

        m_dwDSSources--;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetLatencyClock"

HRESULT CDirectSoundSink::GetLatencyClock(IReferenceClock **ppClock)
{
    DPF_ENTER();

    HRESULT hr = m_LatencyClock.QueryInterface(IID_IReferenceClock,(void **)ppClock);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::Activate"

HRESULT CDirectSoundSink::Activate(BOOL fEnable)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_fActive != fEnable)
    {
        if (fEnable)
            hr = m_pStreamingThread->RegisterSink(this);
        else
            m_pStreamingThread->UnregisterSink(this);

        if (SUCCEEDED(hr))
            m_fActive = fEnable;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::SampleToRefTime"

HRESULT CDirectSoundSink::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prt)
{
    DPF_ENTER();

    m_SampleClock.SampleToRefTime(llSampleTime, prt);

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::RefToSampleTime"

HRESULT CDirectSoundSink::RefToSampleTime(REFERENCE_TIME rt, LONGLONG *pllSampleTime)
{
    DPF_ENTER();

    *pllSampleTime = m_SampleClock.RefToSampleTime(rt);

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetFormat"

HRESULT CDirectSoundSink::GetFormat(LPWAVEFORMATEX pwfx, LPDWORD pdwsize)
{
   DPF_ENTER();

   HRESULT hr = CopyWfxApi(&m_wfx, pwfx, pdwsize);

   DPF_LEAVE_HRESULT(hr);
   return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::CreateSoundBuffer"

HRESULT CDirectSoundSink::CreateSoundBuffer(LPCDSBUFFERDESC pDSBufferDesc, LPDWORD pdwFuncIDs, DWORD dwFuncIDsCount, REFGUID guidBufferID, CDirectSoundBuffer **ppDsBuffer)
{
    CDirectSoundSecondaryBuffer* pDsSecondaryBuffer;

    DPF_ENTER();

    HRESULT hr = DS_OK;
    DSBUFFERDESC DSBufferDesc;
    WAVEFORMATEX wfx;

    if (SUCCEEDED(hr))
    {
        //
        // Initialize buffer description
        //
        DSBufferDesc = *pDSBufferDesc;

        //
        // Retrieve number of channels from format struct and recalculate
        //

        // Future release: Make it work with wave format extensible.
        //
        wfx = m_wfx;
        if (pDSBufferDesc->lpwfxFormat)
        {
            wfx.nChannels = pDSBufferDesc->lpwfxFormat->nChannels;
            wfx.nBlockAlign = wfx.nChannels * (wfx.wBitsPerSample/8);
            wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        }
        DSBufferDesc.lpwfxFormat = &wfx;
        DSBufferDesc.dwBufferBytes = m_dwBusSize * wfx.nChannels;

        //
        // Create the DirectSound buffer
        //
        hr = m_pDirectSound->CreateSinkBuffer(&DSBufferDesc, guidBufferID, &pDsSecondaryBuffer, this);
        if (SUCCEEDED(hr))
        {
            *ppDsBuffer = pDsSecondaryBuffer;
            //
            // Add the bus. Note that this really shouldn't be happening for MIXIN buffers, but we seem to need it...
            //
            hr = AddBuffer(pDsSecondaryBuffer, pdwFuncIDs, dwFuncIDsCount, wfx.nChannels);
            if (SUCCEEDED(hr))
            {
                // Initialize clock buffer
                //
                // BUGBUG WI 33785
                // Note that the audiopath code creates a mono buffer the very first time a buffer is requested and hangs
                // on to it until close down. This buffer ends up being the one set up as the clock reference.
                // Once the clock hopping bug is fixed, we can remove this.
                //
                if (m_dwDSSBufCount == 1)
                {
                    m_dwMasterBuffChannels = wfx.nChannels;
                    m_dwMasterBuffSize     = DSBufferDesc.dwBufferBytes;

                    // Flag m_dwWriteTo that m_dwLatency has changed for reset down in the render thread
                    m_dwWriteTo = 0;
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::CreateSoundBufferFromConfig"

HRESULT CDirectSoundSink::CreateSoundBufferFromConfig(IUnknown *pIUnkDSBufferConfig, CDirectSoundBuffer **ppDsBuffer)
{
    CDirectSoundSecondaryBuffer* pDsSecondaryBuffer;
    CDirectSoundBufferConfig* pDSBConfigObj = NULL;

    HRESULT hr = DS_OK;
    DPF_ENTER();

    CHECK_READ_PTR(pIUnkDSBufferConfig);
    CHECK_WRITE_PTR(ppDsBuffer);

    //
    // Retrieve the DSBufferConfig Class object
    //
    if (pIUnkDSBufferConfig)
    {
        //
        // Identify the object as the correct class so it's safe to cast.
        // This breaks COM rules, and what is actually returned is a this pointer to the class.
        pDSBConfigObj = NULL;
        hr = pIUnkDSBufferConfig->QueryInterface(CLSID_PRIVATE_CDirectSoundBufferConfig, (void**)&pDSBConfigObj);
    }

    if (pDSBConfigObj == NULL)
    {
        hr = DSERR_INVALIDPARAM;
    }
    else if (!(pDSBConfigObj->m_fLoadFlags & DSBCFG_DSBD))
    {
        //
        // We are failing to create the buffers here because
        // we must have at least a loaded sound buffer description
        //
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Retrieve number of channels from format struct and recalculate the waveformat structure
        //
        // Future release: make it work with wave format extensible.
        WAVEFORMATEX wfx = m_wfx;
        if (pDSBConfigObj->m_DSBufferDesc.nChannels > 0)  // Check for the presence of a channel value
        {
            wfx.nChannels = pDSBConfigObj->m_DSBufferDesc.nChannels;
            wfx.nBlockAlign = wfx.nChannels * (wfx.wBitsPerSample/8);
            wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        }

        //
        // Set up a buffer description structure
        //
        DSBUFFERDESC DSBufferDesc = {sizeof DSBufferDesc,
                                     pDSBConfigObj->m_DSBufferDesc.dwFlags,
                                     m_dwBusSize * wfx.nChannels,
                                     pDSBConfigObj->m_DSBufferDesc.dwReserved,
                                     &wfx};

        if (DSBufferDesc.dwFlags & DSBCAPS_CTRL3D)
            DSBufferDesc.guid3DAlgorithm = pDSBConfigObj->m_DS3DDesc.guid3DAlgorithm;

        //
        // Create the DirectSound buffer
        //
        hr = m_pDirectSound->CreateSinkBuffer(&DSBufferDesc, pDSBConfigObj->m_DMUSObjectDesc.guidObject, &pDsSecondaryBuffer, this);
        if (SUCCEEDED(hr))
        {
            *ppDsBuffer = pDsSecondaryBuffer;

            if (DSBufferDesc.dwFlags & DSBCAPS_CTRLVOLUME)
            {
                hr = pDsSecondaryBuffer->SetVolume(pDSBConfigObj->m_DSBufferDesc.lVolume);
            }

            if (SUCCEEDED(hr) && (DSBufferDesc.dwFlags & DSBCAPS_CTRLPAN))
            {
                hr = pDsSecondaryBuffer->SetPan(pDSBConfigObj->m_DSBufferDesc.lPan);
            }

            if (SUCCEEDED(hr) && (DSBufferDesc.dwFlags & DSBCAPS_CTRL3D) && (pDSBConfigObj->m_fLoadFlags & DSBCFG_DS3D))
            {
                IDirectSound3DBuffer8 *p3D = NULL;
                hr = pDsSecondaryBuffer->QueryInterface(IID_IDirectSound3DBuffer8, FALSE, (void**)&p3D);
                if (SUCCEEDED(hr))
                {
                    hr = p3D->SetAllParameters(&pDSBConfigObj->m_DS3DDesc.ds3d, DS3D_IMMEDIATE);
                }
                RELEASE(p3D);
            }

            //
            // Pass the buffer config object so FX can be cloned from it
            //
            if (SUCCEEDED(hr) && (DSBufferDesc.dwFlags & DSBCAPS_CTRLFX) && (pDSBConfigObj->m_fLoadFlags & DSBCFG_DSFX))
            {
                hr = pDsSecondaryBuffer->SetFXBufferConfig(pDSBConfigObj);
            }

            if (SUCCEEDED(hr))
            {
                //
                // Add the bus.
                //
                hr = AddBuffer(pDsSecondaryBuffer, pDSBConfigObj->m_pdwFuncIDs, pDSBConfigObj->m_dwFuncIDsCount, wfx.nChannels);
                if (SUCCEEDED(hr))
                {
                    //
                    // Initialize master buffer paramters
                    //
                    if (m_dwDSSBufCount == 1)
                    {
                        m_dwMasterBuffChannels = wfx.nChannels;
                        m_dwMasterBuffSize = DSBufferDesc.dwBufferBytes;

                        // Flag m_dwWriteTo that m_dwLatency has changed for reset down in the render thread
                        m_dwWriteTo = 0;
                    }
                }
            }
            else
            {
                RELEASE(pDsSecondaryBuffer);
                *ppDsBuffer = NULL;
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#ifdef FUTURE_WAVE_SUPPORT
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::CreateSoundBufferFromWave"

HRESULT CDirectSoundSink::CreateSoundBufferFromWave(IDirectSoundWave *pWave, DWORD dwFlags, CDirectSoundBuffer **ppDsBuffer)
{
    DPF_ENTER();

    HRESULT hr = DS_OK;
    DSBUFFERDESC DSBufferDesc;
    WAVEFORMATEX wfx;
    IDirectSoundSource *pSrc = NULL;
    DWORD dwSize = sizeof(wfx);
    DWORD dwBusID = DSSINK_NULLBUSID;
    DWORD dwBusIndex = DSSINK_NULLBUSID;
    DWORD dwBusCount = 1;

    ZeroMemory(&wfx, sizeof wfx);
    ZeroMemory(&DSBufferDesc, sizeof(DSBufferDesc));
    DSBufferDesc.dwSize = sizeof(DSBufferDesc);
    DSBufferDesc.dwFlags = dwFlags | DSBCAPS_FROMWAVEOBJECT;

    // Future release: Make it to work with wave format extensible.
    hr = pWave->GetFormat(&wfx, dwSize, NULL);
    if (SUCCEEDED(hr))
    {
        WORD nChannels = wfx.nChannels;  // Save off channels
        wfx = m_wfx;
        wfx.nChannels = nChannels;
        wfx.nBlockAlign = wfx.nChannels * (wfx.wBitsPerSample/8);
        wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

        hr = pWave->CreateSource(&pSrc, &wfx, 0);
        if (SUCCEEDED(hr) && pSrc != NULL)
        {
            DSBufferDesc.lpwfxFormat = &wfx;
            DSBufferDesc.dwBufferBytes = MsToBytes(m_dwBusSize, &wfx);
            hr = CreateSoundBuffer(&DSBufferDesc, NULL, 0, ppDsBuffer);
            if (SUCCEEDED(hr) && *ppDsBuffer)
            {
                hr = GetSoundBufferBusIDs(*ppDsBuffer, &dwBusID, NULL, &dwBusCount);
                if (SUCCEEDED(hr))
                {
                    // Flag newly created buffer a wavesource buffer
                    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
                    {
                        for (DWORD j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
                        {
                            if (m_ppDSSBuffers[i].m_pdwBusIds[j] == dwBusID)
                            {
                                dwBusCount = m_ppDSSBuffers[i].m_dwBusCount;
                                goto done;
                            }
                        }
                    }
                    done:

                    // Retrieve the index of the bus id
                    for (i = 0; i < m_dwBusIDs; i++)
                    {
                        if (m_pdwBusIDs[i] == dwBusID)
                        {
                            dwBusIndex = i;
                            break;
                        }
                    }

                    if (m_dwDSSources + 1 >= m_dwDSSourcesAlloc)
                    {
                        hr = GrowSourcesArrays(1);
                    }

                    if (SUCCEEDED(hr))
                    {
                        m_pDSSources[m_dwDSSources].m_pDSSource    = pSrc;
#ifdef FUTURE_WAVE_SUPPORT
                        m_pDSSources[m_dwDSSources].m_pWave        = pWave;
#endif
                        m_pDSSources[m_dwDSSources].m_stStartTime  = 0;
                        m_pDSSources[m_dwDSSources].m_dwBusID      = dwBusID;
                        m_pDSSources[m_dwDSSources].m_dwBusCount   = dwBusCount;
                        m_pDSSources[m_dwDSSources].m_dwBusIndex   = dwBusIndex;
                        m_pDSSources[m_dwDSSources].m_bStreamEnd   = FALSE;
                        m_dwDSSources++;
                    }
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // FUTURE_WAVE_SUPPORT


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::FindBufferFromGUID"

CDirectSoundSecondaryBuffer* CDirectSoundSink::FindBufferFromGUID(REFGUID guidBufferID)
{
    CDirectSoundSecondaryBuffer* pBufferFound = NULL;
    DPF_ENTER();

    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
        if (m_ppDSSBuffers[i].m_pDSBuffer->GetGUID() == guidBufferID)
            pBufferFound = m_ppDSSBuffers[i].m_pDSBuffer;

    // We intentionally loop through all buffers in order to return the
    // last matching buffer (i.e., the most recently created one).

    DPF_LEAVE(pBufferFound);
    return pBufferFound;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetSoundBuffer"

HRESULT CDirectSoundSink::GetSoundBuffer(DWORD dwBusId, CDirectSoundBuffer **ppCdsb)
{
    DPF_ENTER();
    HRESULT hr = DSERR_INVALIDPARAM;

    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
    {
        for (DWORD j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
        {
            if (m_ppDSSBuffers[i].m_pdwBusIds[j] == DSSINK_NULLBUSID)
                break;

            if (m_ppDSSBuffers[i].m_pdwBusIds[j] == dwBusId)
            {
                *ppCdsb = m_ppDSSBuffers[i].m_pDSBuffer;
                m_ppDSSBuffers[i].m_pDSBuffer->AddRef();
                hr = DS_OK;
                goto done;
            }
        }
    }
done:

    DPF_LEAVE_HRESULT(hr);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetBusCount"

HRESULT CDirectSoundSink::GetBusCount(DWORD *pdwCount)
{
    DPF_ENTER();

    *pdwCount = m_dwBusIDs;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetBusIDs"

HRESULT CDirectSoundSink::GetBusIDs(LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount)
{
    DPF_ENTER();

    DWORD count;

    if (dwBusCount > m_dwBusIDs)
    {
        count = m_dwBusIDs;
    }
    else
    {
        count = dwBusCount;
    }

    FillMemory(pdwBusIDs, dwBusCount * sizeof *pdwBusIDs, 0xFF);  // Clear array
    CopyMemory(pdwBusIDs, m_pdwBusIDs, count * sizeof *m_pdwBusIDs);
    CopyMemory(pdwFuncIDs, m_pdwFuncIDs, count * sizeof *m_pdwFuncIDs);

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetSoundBufferBusIDs"

HRESULT CDirectSoundSink::GetSoundBufferBusIDs(CDirectSoundBuffer *pCDirectSoundBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount)
{
    HRESULT hr = DSERR_INVALIDPARAM;
    DPF_ENTER();

    ASSERT(pCDirectSoundBuffer);
    ASSERT(pdwBusIDs);
    ASSERT(pdwBusCount);

    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
    {
        if (pCDirectSoundBuffer == m_ppDSSBuffers[i].m_pDSBuffer)
        {
            DWORD dwmaxbusscount = *pdwBusCount;
            if (dwmaxbusscount > m_ppDSSBuffers[i].m_dwBusCount)
            {
                dwmaxbusscount = m_ppDSSBuffers[i].m_dwBusCount;
            }
            *pdwBusCount = 0;

            for (DWORD j = 0; j < dwmaxbusscount; j++)
            {
                if (m_ppDSSBuffers[i].m_pdwBusIds[j] == DSSINK_NULLBUSID)
                    break;

                pdwBusIDs[j] = m_ppDSSBuffers[i].m_pdwBusIds[j];
                if (pdwFuncIDs)
                {
                    pdwFuncIDs[j] = m_ppDSSBuffers[i].m_pdwFuncIds[j];
                }
                (*pdwBusCount)++;
            }
            hr = DS_OK;
            break;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetFunctionalID"

HRESULT CDirectSoundSink::GetFunctionalID(DWORD dwBusIDs, LPDWORD pdwFuncID)
{
    HRESULT hr = DSERR_INVALIDPARAM;
    DPF_ENTER();

    for (DWORD i = 0; i < m_dwBusIDs; i++)
    {
        if (m_pdwBusIDs[i] == dwBusIDs)
        {
            *pdwFuncID = m_pdwFuncIDs[i];
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::SetMasterClock"

HRESULT CDirectSoundSink::SetMasterClock(IReferenceClock *pClock)
{
    DPF_ENTER();

    RELEASE(m_pDSSSinkSync);
    m_pDSSSinkSync = NULL;
    RELEASE(m_pIMasterClock);

    m_pIMasterClock = pClock;
    if (m_pIMasterClock)
    {
        m_pIMasterClock->AddRef();
        m_pIMasterClock->QueryInterface(IID_IDirectSoundSinkSync, (void**)&m_pDSSSinkSync);
    }

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::Render"

HRESULT CDirectSoundSink::Render(STIME stStartTime, DWORD dwLastWrite, DWORD dwBytesToFill, LPDWORD pdwBytesRendered)
{
    HRESULT hr = S_FALSE;
    ULONGLONG BytesToRead;
    CDirectSoundSecondaryBuffer* pDSBuffer;
    IDirectSoundSource *pSource;
    DWORD BusCount;
    DWORD dwChannels;
    DWORD BusIndex;
    DWORD CurrentBusIndex = 0;
    DWORD dwStart  = 0;
    DWORD dwEnd    = 0;
    DWORD dwMasterStart = 0;
    DWORD dwMasterEnd   = 0;
    DWORD dwBussStartBytes = 0;
    DWORD dwBussEndBytes   = 0;
    DWORD dwBytes;
    DWORD dwWriteCursor;
    LONGLONG llStartPosition;
    DWORD i, j;

    *pdwBytesRendered = 0;  // We haven't rendered anything yet...

    //
    // Make sure there are buffers, and at least one sound buffer
    //
    if (!m_ppDSSBuffers)
        return S_FALSE;

    if (m_ppDSSBuffers[0].m_pDSBuffer == NULL && m_ppDSSBuffers[0].m_bPlaying)
        return S_FALSE;

#ifdef DEBUG_SINK
    wsprintfA(m_szDbgDump, "DSOUND SINK: ");
#endif

    //
    // Fill an array of locked buffer pointers
    //
    for (i = 0; i < m_dwDSSBufCount; i++)
    {
        // Ignore this buffer; it's either inactive, or
        // hasn't retrieved its offset off the master buffer yet
        if (m_ppDSSBuffers[i].m_bPlaying == FALSE || m_ppDSSBuffers[i].m_bActive == FALSE)
        {
            DPF(DPFLVL_MOREINFO, "Skipping buffer %ld at %p", i, m_ppDSSBuffers[i]);
            continue;
        }
#ifdef DEBUG_SINK
        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "%ld[", i);
#endif

        dwChannels = m_ppDSSBuffers[i].m_dwBusCount;
        BusCount   = m_ppDSSBuffers[i].m_dwBusCount;
        pDSBuffer  = m_ppDSSBuffers[i].m_pDSBuffer;

        if (pDSBuffer == NULL || BusCount == 0)
            continue;   // This is effectively an error condition

        dwBytes       = (dwBytesToFill*dwChannels)/m_dwMasterBuffChannels;
        dwWriteCursor = (dwLastWrite*dwChannels)/m_dwMasterBuffChannels;

        if (dwLastWrite % (m_dwMasterBuffChannels*2))
            DPF(DPFLVL_WARNING, "Master buffer last write cursor not sample aligned [%d]", dwLastWrite);

        if (dwBytesToFill % (m_dwMasterBuffChannels*2))
            DPF(DPFLVL_WARNING, "Master buffer dwBytesToFill not sample aligned [%d]", dwBytesToFill);

        if (dwWriteCursor % (dwChannels*2))
            DPF(DPFLVL_WARNING, "Master buffer write cursor not sample aligned [%d]", dwWriteCursor);

        if (dwBytes % (dwChannels*2))
            DPF(DPFLVL_WARNING, "Master buffer bytes not sample aligned [%d]", dwBytes);

        if (i != 0)
            dwWriteCursor = (dwWriteCursor + m_ppDSSBuffers[i].m_dwWriteOffset) % (m_dwBusSize*dwChannels);

        // BUGBUG
        // These traces assume 16-bit format.
        //
        if (dwWriteCursor % (dwChannels*2)) DPF(DPFLVL_WARNING, "Slave buffer write cursor not sample aligned");
        if (dwBytes % (dwChannels*2)) DPF(DPFLVL_WARNING, "Slave buffer bytes not sample aligned");

        // Mark the part of the buffer which will have fresh data for FX processing
        pDSBuffer->SetCurrentSlice(dwWriteCursor, dwBytes);

        hr = pDSBuffer->DirectLock(dwWriteCursor, dwBytes,
                                   &m_ppDSSBuffers[i].m_pvDSBufStart, &m_ppDSSBuffers[i].dwStart,
                                   &m_ppDSSBuffers[i].m_pvDSBufEnd,   &m_ppDSSBuffers[i].dwEnd);
        if (FAILED(hr))
        {
            BREAK();    // Break into the debugger
            continue;   // This is effectively an error condition
        }

        dwStart = m_ppDSSBuffers[i].dwStart;
        dwEnd   = m_ppDSSBuffers[i].dwEnd;

        // First buffer is the clock buffer, kick it aside just in case
        //
        // BUGBUG WI 33785
        //
        if (i == 0)
        {
            dwMasterStart    = dwStart;
            dwMasterEnd      = dwEnd;
            dwBussStartBytes = dwMasterStart/m_dwMasterBuffChannels;
            dwBussEndBytes   = dwMasterEnd/m_dwMasterBuffChannels;
        }
        else
        {
            if (dwBussStartBytes + dwBussEndBytes != (dwStart + dwEnd)/dwChannels)
            {
                DPF(DPFLVL_WARNING, "Play cursors out of sync: Master start[%d] end[%d] Slave start[%d] end[%d]", dwMasterStart, dwMasterEnd, dwStart, dwEnd);
                continue;
            }
        }

        if (SUCCEEDED(hr))
        {
            for (j = 0; j < BusCount; j++)
            {
                BusIndex = m_ppDSSBuffers[i].m_pdwBusIndex[j];
                if (BusIndex == DSSINK_NULLBUSID)
                {
                    continue;
                }
#ifdef DEBUG_SINK
                wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "%ld,", BusIndex);
#endif

                m_pdwActiveBusIDs[CurrentBusIndex]  = m_pdwBusIDs[BusIndex];
                m_pdwActiveFuncIDs[CurrentBusIndex] = m_pdwFuncIDs[BusIndex];
                m_pdwActiveBusIDsMap[BusIndex]      = CurrentBusIndex;

                if (dwBussStartBytes == dwStart && dwBussEndBytes == dwEnd && dwChannels == 1)
                {
                    // If mono bus write directly into the sound buffer
                    m_ppvStart[CurrentBusIndex] = m_ppDSSBuffers[i].m_pvDSBufStart;
                    m_ppvEnd[CurrentBusIndex]   = m_ppDSSBuffers[i].m_pvDSBufEnd;
                    m_ppDSSBuffers[i].m_bUsingLocalMemory = FALSE;
                    if (dwStart)
                    {
                        ZeroMemory(m_ppvStart[CurrentBusIndex], dwStart);
                    }
                    if (dwEnd)
                    {
                        ZeroMemory(m_ppvEnd[CurrentBusIndex], dwEnd);
                    }
                }
                else
                {
                    // If a stereo buss write directly into local sink buffer memory
                    m_ppvStart[CurrentBusIndex] = m_ppDSSBuffers[i].m_pvBussStart[j];
                    m_ppvEnd[CurrentBusIndex]   = m_ppDSSBuffers[i].m_pvBussEnd[j];
                    m_ppDSSBuffers[i].m_bUsingLocalMemory = TRUE;
                    if (dwBussStartBytes)
                    {
                        ZeroMemory(m_ppvStart[CurrentBusIndex], dwBussStartBytes);
                    }
                    if (dwBussEndBytes)
                    {
                        ZeroMemory(m_ppvEnd[CurrentBusIndex], dwBussEndBytes);
                    }
                }

                CurrentBusIndex++;
            }
        }
#ifdef DEBUG_SINK
        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "]");
#endif
    }
    if (SUCCEEDED(hr) || dwMasterStart)
    {
        //
        // Read the data from the source
        //
        for (i = 0; i < m_dwDSSources; i++)
        {
            //
            // Check to see if source is ready to play
            //
            if (m_pDSSources[i].m_bStreamEnd)
            {
                continue;
            }

            //
            // Set start position in bytes to where to read from
            //
            llStartPosition = (stStartTime-m_pDSSources[i].m_stStartTime) * 2;  // Samples to Byte, not including channels!!!
            pSource  = m_pDSSources[i].m_pDSSource;
            BusIndex = m_pDSSources[i].m_dwBusIndex;
            BusCount = m_pDSSources[i].m_dwBusCount;

            if (pSource)
            {
                if (dwBussStartBytes)
                {
                    BytesToRead = dwBussStartBytes;

                    pSource->Seek(llStartPosition);

                    if (BusIndex != DSSINK_NULLBUSID)
                    {
                        BusIndex = m_pdwActiveBusIDsMap[BusIndex];  // Remap to current active buss
                        hr = pSource->Read((void**)&m_ppvStart[BusIndex], &m_pdwBusIDs[BusIndex], &m_pdwFuncIDs[BusIndex], &m_plPitchBends[BusIndex], BusCount, &BytesToRead);
#ifdef DEBUG_SINK
                        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "Remap:");
#endif
                    }
                    else
                    {
                        hr = pSource->Read((void**)m_ppvStart, m_pdwActiveBusIDs, m_pdwActiveFuncIDs, m_plPitchBends, CurrentBusIndex, &BytesToRead);
                    }
#ifdef DEBUG_SINK
                    wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "Start:");
                    DWORD dwX;
                    for (dwX = 0;dwX < CurrentBusIndex;dwX++)
                    {
                        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "(%ld:%ld,%ld),", dwX, m_pdwActiveBusIDs[dwX], m_pdwActiveFuncIDs[dwX]);
                    }
#endif
                    // It's ok to read silence before the synth gets going
                    if ((FAILED(hr) &&
                          hr != DMUS_E_SYNTHINACTIVE &&
                          hr != DMUS_E_SYNTHNOTCONFIGURED) || BytesToRead == 0)
                    {
                        m_pDSSources[i].m_bStreamEnd = TRUE; // end of buffer reached
                    }

                    hr = S_OK;
                }
                if (dwBussEndBytes)
                {
                    llStartPosition += dwBussStartBytes;
                    BytesToRead      = dwBussEndBytes;

                    if (BusIndex != DSSINK_NULLBUSID)
                    {
#ifdef DEBUG_SINK
                        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "Remap:");
#endif
                        hr = pSource->Read((void**)&m_ppvEnd[BusIndex], &m_pdwBusIDs[BusIndex], &m_pdwFuncIDs[BusIndex], &m_plPitchBends[BusIndex], BusCount, &BytesToRead);
                    }
                    else
                    {
                        pSource->Seek(llStartPosition);
                        hr = pSource->Read((void**)m_ppvEnd, m_pdwActiveBusIDs, m_pdwActiveFuncIDs, m_plPitchBends, CurrentBusIndex, &BytesToRead);
#ifdef DEBUG_SINK
                        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "End:");
                        for (DWORD dwX=0; dwX < CurrentBusIndex; dwX++)
                            wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "(%ld:%ld,%ld),", dwX, m_pdwActiveBusIDs[dwX], m_pdwActiveFuncIDs[dwX]);
#endif
                    }
                    if ((FAILED(hr) &&
                          hr != DMUS_E_SYNTHINACTIVE &&
                          hr != DMUS_E_SYNTHNOTCONFIGURED) || BytesToRead == 0)
                    {
                        m_pDSSources[i].m_bStreamEnd = TRUE; // end of buffer reached
                        hr = DS_OK;
                    }
                }
            }
        }

        #ifdef DEBUG_SINK
        if (!m_dwPrintNow--)
        {
            OutputDebugStringA(m_szDbgDump);
            OutputDebugStringA("\n");
            m_dwPrintNow = 100;  // Print info every X times we go through this code
        }
        #endif

        //
        // Unlock all the buffer pointers
        //
        for (i = 0; i < m_dwDSSBufCount; i++)
        {
            if (!m_ppDSSBuffers[i].m_bPlaying)
            {
                continue;
            }

            dwChannels = m_ppDSSBuffers[i].m_dwBusCount;
            dwStart = m_ppDSSBuffers[i].dwStart;
            dwEnd = m_ppDSSBuffers[i].dwEnd;
            //
            // Interleave mono bus back into a 2 channel dsound buffer
            //
            if (m_ppDSSBuffers[i].m_bUsingLocalMemory)
            {
                DWORD  dwStartChannelBytes = dwStart/dwChannels;
                DWORD  dwBussStartIndex   = 0;
                DWORD  dwBussEndIndex     = 0;
                DWORD  dwBussSamples  = 0;

                if (dwStartChannelBytes > dwBussStartBytes)
                {
                    dwBussSamples = dwBussStartBytes/sizeof(WORD);   //Byte to samples, busses are always mono
                }
                else
                {
                    dwBussSamples = dwStartChannelBytes/sizeof(WORD);//Byte to samples
                }

                if (dwChannels == 2)
                {
                    short *pStartBuffer = (short *) m_ppDSSBuffers[i].m_pvDSBufStart;
                    short *pEndBuffer = (short *) m_ppDSSBuffers[i].m_pvDSBufEnd;
                    if (m_ppDSSBuffers[i].m_pdwFuncIds[0] == DSSINK_NULLBUSID)
                    {
                        // This should never happen, but just testing...
                        DPF(DPFLVL_INFO, "Mixin buffer receiving input from the synth!");
                        // FIXME: this happens constantly.  is it ok?
                    }
                    // Is the second bus empty? If so, we copy just from the first bus.
                    else if (m_ppDSSBuffers[i].m_pdwFuncIds[1] == DSSINK_NULLBUSID)
                    {
                        short *pBusStart = (short *) m_ppDSSBuffers[i].m_pvBussStart[0];
                        short *pBusEnd = (short *) m_ppDSSBuffers[i].m_pvBussEnd[0];
                        for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                        {
                            *pStartBuffer++ = pBusStart[dwBussStartIndex];
                            *pStartBuffer++ = pBusStart[dwBussStartIndex];
                        }

                        // The start buffer is not full, consume some of the end buffer
                        if (dwStartChannelBytes > dwBussStartBytes)
                        {
                            dwBussSamples = (dwStartChannelBytes-dwBussStartBytes)/sizeof(WORD);

                            for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                            {
                                *pStartBuffer++ = pBusEnd[dwBussEndIndex];
                                *pStartBuffer++ = pBusEnd[dwBussEndIndex];
                            }
                        }

                        // Consume what remains of the local mem start buffer and put it in the end buffer
                        dwBussSamples = dwBussStartBytes/sizeof(WORD);

                        for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                        {
                            *pEndBuffer++ = pBusStart[dwBussStartIndex];
                            *pEndBuffer++ = pBusStart[dwBussStartIndex];
                        }

                        // Consume what remains of the local mem end buffer and put it in the end buffer
                        dwBussSamples = dwBussEndBytes/sizeof(WORD);
                        for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                        {
                            *pEndBuffer++ = pBusEnd[dwBussEndIndex];
                            *pEndBuffer++ = pBusEnd[dwBussEndIndex];
                        }
                    }
                    else
                    {
                        short *pBusStart0 = (short *) m_ppDSSBuffers[i].m_pvBussStart[0];
                        short *pBusEnd0 = (short *) m_ppDSSBuffers[i].m_pvBussEnd[0];
                        short *pBusStart1 = (short *) m_ppDSSBuffers[i].m_pvBussStart[1];
                        short *pBusEnd1 = (short *) m_ppDSSBuffers[i].m_pvBussEnd[1];
                        for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                        {
                            *pStartBuffer++ = pBusStart0[dwBussStartIndex];
                            *pStartBuffer++ = pBusStart1[dwBussStartIndex];
                        }

                        // The start buffer is not full, consume some of the end buffer
                        if (dwStartChannelBytes > dwBussStartBytes)
                        {
                            dwBussSamples = (dwStartChannelBytes-dwBussStartBytes)/sizeof(WORD);

                            for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                            {
                                *pStartBuffer++ = pBusEnd0[dwBussEndIndex];
                                *pStartBuffer++ = pBusEnd1[dwBussEndIndex];
                            }
                        }

                        // Consume what remains of the local mem start buffer and put it in the end buffer
                        dwBussSamples = dwBussStartBytes/sizeof(WORD);

                        for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                        {
                            *pEndBuffer++ = pBusStart0[dwBussStartIndex];
                            *pEndBuffer++ = pBusStart1[dwBussStartIndex];
                        }

                        // Consume what remains of the local mem end buffer and put it in the end buffer
                        dwBussSamples = dwBussEndBytes/sizeof(WORD);
                        for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                        {
                            *pEndBuffer++ = pBusEnd0[dwBussEndIndex];
                            *pEndBuffer++ = pBusEnd1[dwBussEndIndex];
                        }
                    }
                }
                else if (dwChannels == 1)
                {
                    short *pStartBuffer = (short *) m_ppDSSBuffers[i].m_pvDSBufStart;
                    short *pEndBuffer = (short *) m_ppDSSBuffers[i].m_pvDSBufEnd;
                    if (m_ppDSSBuffers[i].m_pdwFuncIds[0] == DSSINK_NULLBUSID)
                    {
                        // This should never happen, but just testing...
                        DPF(DPFLVL_ERROR, "Mixin buffer receiving input from the synth!");
                    }
                    short *pBusStart = (short *) m_ppDSSBuffers[i].m_pvBussStart[0];
                    short *pBusEnd = (short *) m_ppDSSBuffers[i].m_pvBussEnd[0];
                    for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                    {
                        *pStartBuffer++ = pBusStart[dwBussStartIndex];
                    }

                    // The start buffer is not full, consume some of the end buffer
                    if (dwStartChannelBytes > dwBussStartBytes)
                    {
                        dwBussSamples = (dwStartChannelBytes-dwBussStartBytes)/sizeof(WORD);

                        for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                        {
                            *pStartBuffer++ = pBusEnd[dwBussEndIndex];
                        }
                    }

                    // Consume what remains of the local mem start buffer and put it in the end buffer
                    dwBussSamples = dwBussStartBytes/sizeof(WORD);

                    for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                    {
                        *pEndBuffer++ = pBusStart[dwBussStartIndex];
                    }

                    // Consume what remains of the local mem end buffer and put it in the end buffer
                    dwBussSamples = dwBussEndBytes/sizeof(WORD);
                    for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                    {
                        *pEndBuffer++ = pBusEnd[dwBussEndIndex];
                    }
                }
                else
                {
                    DPF(DPFLVL_ERROR, "DSSink does not handle %ld channels per buffer", dwChannels);
                }
            }

            m_ppDSSBuffers[i].m_pDSBuffer->DirectUnlock(m_ppDSSBuffers[i].m_pvDSBufStart, dwStart,
                                                        m_ppDSSBuffers[i].m_pvDSBufEnd, dwEnd);
        }
    }

    //
    // Set the amount written return values
    //
    *pdwBytesRendered = dwMasterStart + dwMasterEnd;

    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::RenderSilence"

HRESULT CDirectSoundSink::RenderSilence(DWORD dwLastWrite, DWORD dwBytesToFill)
{
    HRESULT hr = DS_OK;

    CDirectSoundSecondaryBuffer* m_pDSBuffer;
    DWORD dwChannels;
    LPVOID pStart, pEnd;
    DWORD dwStart, dwEnd;

    for (DWORD i = 0; i < m_dwDSSBufCount && SUCCEEDED(hr); i++)
    {
        if (m_ppDSSBuffers[i].m_pDSBuffer == NULL)
            continue;

        m_pDSBuffer = m_ppDSSBuffers[i].m_pDSBuffer;
        dwChannels  = m_ppDSSBuffers[i].m_dwBusCount;

        hr = m_pDSBuffer->DirectLock(dwChannels * dwLastWrite   / m_dwMasterBuffChannels,
                                     dwChannels * dwBytesToFill / m_dwMasterBuffChannels,
                                     &pStart, &dwStart, &pEnd, &dwEnd);

        if (SUCCEEDED(hr))
        {
            if (dwStart)
                ZeroMemory(pStart, dwStart);
            if (dwEnd)
                ZeroMemory(pEnd, dwEnd);

            m_pDSBuffer->DirectUnlock(pStart, dwStart, pEnd, dwEnd);
        }
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::SyncSink"

HRESULT CDirectSoundSink::SyncSink(LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor, LPDWORD pdwCursorDelta)
{
    HRESULT hr = S_FALSE;

    if (!m_ppDSSBuffers || m_ppDSSBuffers[0].m_pDSBuffer == NULL)
    {
        //
        // remove all sources
        //
        for (DWORD i = 0; i < m_dwDSSources; i++)
        {
            if (m_pDSSources[i].m_bStreamEnd == TRUE)
            {
                RemoveSource(m_pDSSources[i].m_pDSSource);
            }
        }

        //
        // If there are no buffers, keep the master clock working anyway
        // even if there are no buffers, this will keep things clean
        // during audiopath changes that pull the whole path.
        //
        REFERENCE_TIME rtMaster;
        LONGLONG llMasterSampleTime;
        LONGLONG llMasterBytes;

        m_pIMasterClock->GetTime(&rtMaster);
        RefToSampleTime(rtMaster, &llMasterSampleTime);
        llMasterBytes = SampleToByte(llMasterSampleTime);

        DWORD dwDelta = (DWORD)(llMasterBytes - m_llAbsPlay);
        m_llAbsPlay   += dwDelta;
        m_llAbsWrite  += dwDelta;
        m_dwLastPlay  += dwDelta;
        m_dwLastWrite += dwDelta;
        m_dwLastCursorDelta = dwDelta;

        m_SampleClock.SyncToMaster(ByteToSample(m_llAbsPlay), m_pIMasterClock, TRUE);

        if (pdwPlayCursor)
            *pdwPlayCursor = 0;

        if (pdwWriteCursor)
            *pdwWriteCursor = 0;

        if (pdwCursorDelta)
            *pdwCursorDelta = 0;

        hr = S_FALSE;  // Not playing anything to take a position on.
    }
    else
    {
        if (m_ppDSSBuffers[0].m_pDSBuffer)
        {
//>>>> to be removed
/*            if (m_dwLatencyCount < 100)
            {
                DWORD dwMasterCursor = 0;
                DWORD dwLatency     = 0;

                hr = m_ppDSSBuffers[0].m_pDSBuffer->GetCursorPosition(&dwMasterCursor, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = m_ppDSSBuffers[0].m_pDSBuffer->GetCursorPosition(&dwLatency, NULL);
                    if (SUCCEEDED(hr))
                    {
                        if (dwMasterCursor <= dwLatency)
                            dwLatency = dwLatency - dwMasterCursor;
                        else
                            dwLatency = (dwLatency + m_dwMasterBuffSize) - dwMasterCursor;

                        if (dwLatency < 100)
                        {
                            m_dwLatencyTotal += dwLatency;
                            m_dwLatencyCount++;
                            m_dwLatencyAverage = m_dwLatencyTotal / m_dwLatencyCount;
                            DPF(0, "MasterCursor[%d] Latency[%d] AvgLatency[%d]", dwMasterCursor, dwLatency, m_dwLatencyAverage);
                        }
                    }
                }
            }*/
//>>>> end to be removed

            //
            // Attempt to synchronize play buffers
            //
            hr = S_FALSE;
            for (DWORD i = 1; i < m_dwDSSBufCount; i++)
            {
                DWORD dwPlayCursor   = 0;
                DWORD dwMasterCursor = 0;
                DWORD dwOffset;

                if (m_ppDSSBuffers[i].m_bPlaying == FALSE && m_ppDSSBuffers[i].m_bActive == TRUE)
                {
                    hr = m_ppDSSBuffers[0].m_pDSBuffer->GetInternalCursors(&dwMasterCursor, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_ppDSSBuffers[i].m_pDSBuffer->GetInternalCursors(&dwPlayCursor, NULL);
                        if (SUCCEEDED(hr))
                        {
                            // Adjust master cursor to current buffer cursor
                            dwMasterCursor = (dwMasterCursor*m_ppDSSBuffers[i].m_dwBusCount)/m_dwMasterBuffChannels;

                            if (dwPlayCursor >= dwMasterCursor)
                            {
                                dwOffset = dwPlayCursor - dwMasterCursor;
                            }
                            else
                            {
                                dwOffset = (dwPlayCursor + (m_dwBusSize*m_ppDSSBuffers[i].m_dwBusCount)) - dwMasterCursor;
                            }
                            if (dwOffset <= m_dwLatencyAverage)
                            {
                                dwOffset = 0;
                            }
                            dwOffset = (dwOffset >> m_ppDSSBuffers[i].m_dwBusCount) << m_ppDSSBuffers[i].m_dwBusCount;

                            m_ppDSSBuffers[i].m_dwWriteOffset = dwOffset; // FIXME make sure we go through this code for the master buffer (write offset should be 0)
                            m_ppDSSBuffers[i].m_bPlaying = TRUE;
#ifdef DEBUG_SINK
                            DPF(DPFLVL_INFO, "Turned on buffer %ld at %p", i, m_ppDSSBuffers[i]);
                            m_dwPrintNow = 0;
#endif
                            DPF(DPFLVL_MOREINFO, "MasterCursor[%d] PlayCursor-AvgLatency[%d] Offset[%d] WriteOffset[%d] AvgLatency[%d]",
                                dwMasterCursor, dwPlayCursor-m_dwLatencyAverage, dwOffset, m_ppDSSBuffers[i].m_dwWriteOffset, m_dwLatencyAverage);
                        }
                    }
                }
            }

            DWORD dwPlayCursor;         // Play position in the master buffer
            DWORD dwWriteCursor;        // Write position in the master buffer
            DWORD dwCursorDelta = 0;    // How far apart are the cursors

            hr =  m_ppDSSBuffers[0].m_pDSBuffer->GetInternalCursors(&dwPlayCursor, &dwWriteCursor);
            if (SUCCEEDED(hr))
            {
                if (dwWriteCursor >= dwPlayCursor)
                {
                    // write cursor is normally ahead on the play cursor
                    dwCursorDelta = dwWriteCursor - dwPlayCursor;
                }
                else
                {
                    // write cursor is at the begining of the buffer behind the play cursor
                    dwCursorDelta = (dwWriteCursor + m_dwMasterBuffSize) - dwPlayCursor;
                }

                // Logic Note: The actual play-to-write distance reported from the device
                // is not necessarily the one that is used; in the event that the distance
                // is shrinking off a maximum peak, the following code will decrease the
                // write cursor by a 1/100th the distance on each subsequent execution of
                // this loop. This brings up the issue that the calling thread must execute
                // this code on a very consistent interval.

                if (dwCursorDelta > m_dwLastCursorDelta)
                {
                    if (dwCursorDelta >= (m_dwMasterBuffSize >> 1))
                    {
                        // If the delta is greater than half the buffer, this is probably
                        // an error. Discard and come back later.
                        DPF(DPFLVL_WARNING, "Play to Write cursor delta value %lu rejected", dwCursorDelta);
                        return S_FALSE;
                    }
                    // use the maximimum reported delta, and save the peak value
                    m_dwLastCursorDelta = dwCursorDelta;
                }
                else
                {
                    // Decrease the distance by a hundredth of itself,
                    // creating a damping effect.
                    m_dwLastCursorDelta -= ((m_dwLastCursorDelta - dwCursorDelta) / 100);
                    m_dwLastCursorDelta = SampleAlign(m_dwLastCursorDelta);
                    dwCursorDelta = m_dwLastCursorDelta;
                }

                // Adjust the actual reported write cursor position.
                *pdwWriteCursor = (dwPlayCursor + dwCursorDelta) % m_dwMasterBuffSize;
                *pdwPlayCursor      = dwPlayCursor;
                *pdwCursorDelta     = dwCursorDelta;
            }
        }

        //
        // The only calls here that modify hr are GetPosition calls; if they fail
        // they may be stalled in some init function.  Return S_FALSE so the thread
        // calls again, but doesn't render.
        //
        if (hr != DS_OK)
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::ProcessSink"

HRESULT CDirectSoundSink::ProcessSink()
{
    DWORD dwPlayCursor, dwWriteCursor, dwCursorDelta;

    if (m_pIMasterClock == NULL)  // Happens on closedown sometimes
    {
        DPF(DPFLVL_WARNING, "NULL m_pIMasterClock - FIXME?");
        return DS_OK;
    }

    // First save our current notion of the latency clock for use during this
    // processing pass by any effect chains attached to this sink's buffers:
    m_rtSavedTime = 0;
    m_LatencyClock.GetTime(&m_rtSavedTime);

    HRESULT hr = SyncSink(&dwPlayCursor, &dwWriteCursor, &dwCursorDelta);

    if (hr != DS_OK)
    {
        DPF(DPFLVL_INFO, "SyncSink() returned %s", HRESULTtoSTRING(hr));
    }
    else // ...do everything else
    {
        REFERENCE_TIME rtMaster;
        LONGLONG llMasterSampleTime;
        LONGLONG llMasterBytes;
        LONGLONG llMasterAhead;     // How far master clock is ahead of last known play time
        LONGLONG llAbsWriteFrom;
        LONGLONG llAbsWriteTo;
        DWORD dwBytesToFill;
        DWORD dwBytesRendered;
        STIME stStartTime;
        DWORD dwPlayed;             // How much was played between execution of this code

        DWORD dwMaxDelta = m_dwMasterBuffSize / 2;  // Max play to write distance allowed

        //
        // Buffer starting off
        //
        if (m_llAbsWrite == 0)
        {
            // we just started
            m_llAbsWrite  = dwCursorDelta;
            m_llAbsPlay   = 0;
            m_dwLastWrite = dwWriteCursor;
            m_dwLastPlay  = dwPlayCursor;

            m_SampleClock.Start(m_pIMasterClock, m_wfx.nSamplesPerSec, 0);
        }

        //
        // Check to see if the master clock is ahead of the master buffer
        //
        m_pIMasterClock->GetTime(&rtMaster);
        RefToSampleTime(rtMaster, &llMasterSampleTime);
        llMasterBytes = SampleToByte(llMasterSampleTime);
        llMasterAhead = (llMasterBytes > m_llAbsPlay) ? llMasterBytes - m_llAbsPlay : 0;

        //
        // check for half-buffer underruns,
        // so backward-moving play cursors can be detected
        // >>>>>>>>>> document more backward moving cursors are the primary function of this code
        if (llMasterAhead > dwMaxDelta)
        {
            // Make this DPFLVL_WARNING level again when 33786 is fixed
            DPF(DPFLVL_INFO, "Buffer underrun by %lu", (long) llMasterAhead - dwMaxDelta);

            m_llAbsPlay   = llMasterBytes;
            m_llAbsWrite  = llAbsWriteFrom = m_llAbsPlay + dwCursorDelta;
            m_dwLastWrite = dwWriteCursor;
        }
        else
        {
            //
            // Track and cache the play cursor positions
            //
            // dwPlayCursor = current play cursor position
            // m_dwLastPlay = the last play cursor position
            // m_llAbsPlay  = the accumulated play cursor position
            // dwMaxDelta   = half the buffer size
            //
            if (dwPlayCursor >= m_dwLastPlay)
                dwPlayed = dwPlayCursor - m_dwLastPlay;
            else
                dwPlayed = (dwPlayCursor + m_dwMasterBuffSize) - m_dwLastPlay;

            if (dwPlayed > dwMaxDelta)
            {
                DPF(DPFLVL_INFO, "Play Cursor %lu looks invalid, rejecting it", dwPlayed);
                return DS_OK;
            }

            m_llAbsPlay += dwPlayed; // Accumulate the absolute play position

            //
            //  Track and cache the write cursor position
            //
            // dwWriteCursor  = the current write cursor position
            // dwCursorDelta  = the distance between the current cursor position
            // m_llAbsPlay    = the accumulated play cursor position
            // m_llAbsWrite   =
            // llAbsWriteFrom =
            //
            llAbsWriteFrom = m_llAbsPlay + dwCursorDelta;

            if (llAbsWriteFrom > m_llAbsWrite) // how far ahead of the write head are we?
            {
                // We are behind-- let's catch up
                DWORD dwWriteMissed;

                dwWriteMissed = DWORD(llAbsWriteFrom - m_llAbsWrite);
                m_dwLastWrite = dwWriteCursor;
                m_llAbsWrite += dwWriteMissed;

                // This should be DPFLVL_WARNING - but it happens too often.
                DPF(DPFLVL_INFO, "Write underrun: missed %lu bytes (latency=%lu)", dwWriteMissed, m_dwLatency);
            }
        }

        m_dwLastPlay = dwPlayCursor;  // Save the last play cursor

        // Now, sync the audio to the master clock.
        // If we are in the first two seconds, just let the sample clock sync to the master clock.
        // This allows it to overcome jitter and get a tight starting position.
        // Then, after that first two seconds, switch to letting the sample
        // clock drive the master clock.
        // Also, if there is no way of adjusting the master clock (no m_pDSSSinkSync),
        // then always adjust the sample clock instead.
        BOOL fLockToMaster = (!m_pDSSSinkSync) || (m_llAbsPlay < m_dwMasterBuffSize * 2);
        m_SampleClock.SyncToMaster(ByteToSample(m_llAbsPlay),m_pIMasterClock,fLockToMaster);
        // Then, take the same offset that was generated by the sync code
        // and use it to adjust the timing of the master clock.
        if (!fLockToMaster)
        {
            // First, get the new offset that was generated by SyncToMaster.
            REFERENCE_TIME rtOffset;
            m_SampleClock.GetClockOffset(&rtOffset);
            m_pDSSSinkSync->SetClockOffset(-rtOffset);
        }

        //
        // The m_dwWriteTo value is set to zero when either
        //  1) the sink is initialized
        //  2) the Latency property has been changed.
        //  3) the master buffer has been changed
        //
        if (m_dwWriteTo == 0)
        {
            m_dwWriteTo = SampleAlign((500 + (m_dwMasterBuffSize * m_dwLatency)) / 1000);
        }

        // how much to write?
        llAbsWriteTo = llAbsWriteFrom + m_dwWriteTo;
        if (llAbsWriteTo > m_llAbsWrite)
        {
            dwBytesToFill = DWORD(llAbsWriteTo - m_llAbsWrite);
        }
        else
        {
            dwBytesToFill = 0;
        }

//>>>>>>>>> check for small overlaps and ignore them

        if (dwBytesToFill)
        {
            stStartTime = ByteToSample(m_llAbsWrite);   // >>>>>>>> COMMENT

            hr = Render(stStartTime, m_dwLastWrite, dwBytesToFill, &dwBytesRendered);
            if (SUCCEEDED(hr))
            {
                m_dwLastWrite  = (m_dwLastWrite + dwBytesRendered) % m_dwMasterBuffSize;  // Set the how much we have written cursor
                m_llAbsWrite  += dwBytesRendered;  // Accumulate that actual number of bytes written
            }
            else
            {
                DPF(DPFLVL_WARNING, "Failed to render DS buffer (%s)", HRESULTtoSTRING(hr));
            }

//>>>>>>>>>> look closely into this render silence code
#if DEAD_CODE
            // write silence into unplayed buffer
            if (m_dwLastWrite >= dwPlayCursor)
                dwBytesToFill = m_dwMasterBuffSize - m_dwLastWrite + dwPlayCursor;
            else
                dwBytesToFill = dwPlayCursor - m_dwLastWrite;

            hr = RenderSilence(m_dwLastWrite, dwBytesToFill);
            if (FAILED(hr))
            {
                DPF(DPFLVL_WARNING, "Failed to render DS buffer (%s)", HRESULTtoSTRING(hr));
            }
#endif
        }
        else
        {
            DPF(DPFLVL_MOREINFO, "Skipped Render() call because dwBytesToFill was 0");
        }

        //
        // Remove any sources reporting end of stream
        // do it after the mix, so if it does take a
        // bit of time
        // at least the data is already in the buffer.
        //
        for (DWORD i = 0; i < m_dwDSSources; i++)
        {
            if (m_pDSSources[i].m_bStreamEnd == TRUE)
            {
                RemoveSource(m_pDSSources[i].m_pDSSource);
            }
        }
    }

    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::SetBufferState"

HRESULT CDirectSoundSink::SetBufferState(CDirectSoundBuffer *pCDirectSoundBuffer, DWORD dwNewState, DWORD dwOldState)
{
    HRESULT hr = DSERR_INVALIDPARAM;
    DPF_ENTER();

    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
    {
        if (pCDirectSoundBuffer == m_ppDSSBuffers[i].m_pDSBuffer)
        {
            // Stopping buffer
            if (!(~VAD_BUFFERSTATE_STARTED & dwNewState) && (VAD_BUFFERSTATE_STARTED & dwOldState))
            {
#ifdef DEBUG_SINK
                DPF(DPFLVL_INFO, "Deactivating buffer %ld", i);
                m_dwPrintNow = 0;
#endif
                m_ppDSSBuffers[i].m_bActive  = FALSE;
                m_ppDSSBuffers[i].m_bPlaying = FALSE;

//>>>>>>>>>>>>>> make sure if we are stopping the master we jump to the next available master.
            }
            else if ((VAD_BUFFERSTATE_STARTED & dwNewState) && !(~VAD_BUFFERSTATE_STARTED & dwOldState))
            {
#ifdef DEBUG_SINK
                DPF(DPFLVL_INFO, "Activating buffer %ld", i);
                m_dwPrintNow = 0;
#endif
                m_ppDSSBuffers[i].m_bActive  = TRUE;    // Activate the buffer
                m_ppDSSBuffers[i].m_bPlaying = FALSE;   // The render thread will turn this on once it has a cursor offset

                // Hey this is the master buffer, kick it off imediately
                if (i == 0)
                {
                    m_ppDSSBuffers[i].m_bActive  = TRUE;    // Activate the buffer
                    m_ppDSSBuffers[i].m_bPlaying = TRUE;    // The render thread will turn this on once it has a cursor offset
                    m_ppDSSBuffers[i].m_dwWriteOffset = 0;
                }
            }

            hr = DS_OK;
            break;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::HandleLatency"

HRESULT CDirectSoundSink::HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    if (*pcbBuffer != sizeof(DWORD))
        return DSERR_INVALIDPARAM;

    if (fSet)
    {
        m_dwLatency = BETWEEN(*(DWORD*)pbBuffer, SINK_MIN_LATENCY, SINK_MAX_LATENCY);
        m_dwWriteTo = 0;  // Flag that latency has changed for reset down in render thread
    }
    else
        *(DWORD*)pbBuffer = m_dwLatency;

    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::HandlePeriod"

HRESULT CDirectSoundSink::HandlePeriod(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    if (*pcbBuffer != sizeof(DWORD))
        return DSERR_INVALIDPARAM;

    if (fSet)
        m_pStreamingThread->SetWakePeriod(BETWEEN(*(DWORD*)pbBuffer, STREAMING_MIN_PERIOD, STREAMING_MAX_PERIOD));
    else
        *(DWORD*)pbBuffer = m_pStreamingThread->GetWakePeriod();

    return DS_OK;
}


/***************************************************************************
 *
 * CImpSinkKsControl methods
 *
 ***************************************************************************/


#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::CImpSinkKsControl"

CImpSinkKsControl::CImpSinkKsControl(CUnknown *pUnknown, CDirectSoundSink* pObject) : CImpUnknown(pUnknown, pObject)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpSinkKsControl);

    m_pDSSink = (CDirectSoundSink*)pUnknown;

    // This can't be static to avoid problems with the linker since
    // the data segment is shared.

    m_aProperty[0].pguidPropertySet = &GUID_DMUS_PROP_WriteLatency;
    m_aProperty[0].ulId = 0;
    m_aProperty[0].ulSupported = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
    m_aProperty[0].ulFlags = SINKPROP_F_FNHANDLER;
    m_aProperty[0].pPropertyData = NULL;
    m_aProperty[0].cbPropertyData = 0;
    m_aProperty[0].pfnHandler = HandleLatency;

    m_aProperty[1].pguidPropertySet = &GUID_DMUS_PROP_WritePeriod;
    m_aProperty[1].ulId = 0;
    m_aProperty[1].ulSupported = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
    m_aProperty[1].ulFlags = SINKPROP_F_FNHANDLER;
    m_aProperty[1].pPropertyData = NULL;
    m_aProperty[1].cbPropertyData = 0;
    m_aProperty[1].pfnHandler = HandlePeriod;

    m_nProperty = 2;

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::HandleLatency"

HRESULT CImpSinkKsControl::HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    DPF_ENTER();

    HRESULT hr = m_pDSSink->HandleLatency(ulId, fSet, pbBuffer, pcbBuffer);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::HandlePeriod"

HRESULT CImpSinkKsControl::HandlePeriod(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    DPF_ENTER();

    HRESULT hr = m_pDSSink->HandlePeriod(ulId, fSet, pbBuffer, pcbBuffer);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

// CImpSinkKsControl::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTYs.
//
// Returns a pointer to the entry or NULL if the item was not found.

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::FindPropertyItem"

SINKPROPERTY *CImpSinkKsControl::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    DPF_ENTER();

    SINKPROPERTY *pPropertyItem = &m_aProperty[0];
    SINKPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid &&
             pPropertyItem->ulId == ulId)
        {
            DPF_LEAVE(pPropertyItem);
            return pPropertyItem;
        }
    }

    DPF_LEAVE(NULL);
    return NULL;
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::KsProperty"

STDMETHODIMP CImpSinkKsControl::KsProperty(PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
                                           LPVOID pvPropertyData, ULONG ulDataLength, PULONG pulBytesReturned)
{
    DWORD dwFlags;
    SINKPROPERTY *pProperty;
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (!IS_VALID_WRITE_PTR(pPropertyIn, ulPropertyLength))
    {
        DPF(DPFLVL_ERROR, "Invalid property pointer");
        hr = DSERR_INVALIDPARAM;
    }
    else if (pvPropertyData && !IS_VALID_WRITE_PTR(pvPropertyData, ulDataLength))
    {
        DPF(DPFLVL_ERROR, "Invalid property data");
        hr = DSERR_INVALIDPARAM;
    }
    else if (!IS_VALID_TYPED_WRITE_PTR(pulBytesReturned))
    {
        DPF(DPFLVL_ERROR, "Invalid pulBytesReturned");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        dwFlags = pPropertyIn->Flags & (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT);
        pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);
        if (pProperty == NULL)
            hr = DMUS_E_UNKNOWN_PROPERTY;
        else if (pvPropertyData == NULL)
            hr = DSERR_INVALIDPARAM;
    }

    if (SUCCEEDED(hr))
        switch (dwFlags)
        {
            case KSPROPERTY_TYPE_GET:
                if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
                {
                    hr = DMUS_E_GET_UNSUPPORTED;
                    break;
                }
                if (pProperty->ulFlags & SINKPROP_F_FNHANDLER)
                {
                    *pulBytesReturned = ulDataLength;
                    SINKPROPHANDLER pfn = pProperty->pfnHandler;
                    hr = (this->*pfn)(pPropertyIn->Id, FALSE, pvPropertyData, pulBytesReturned);
                    break;
                }
                if (ulDataLength > pProperty->cbPropertyData)
                    ulDataLength = pProperty->cbPropertyData;

                CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
                *pulBytesReturned = ulDataLength;
                break;

            case KSPROPERTY_TYPE_SET:
                if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
                {
                    hr = DMUS_E_SET_UNSUPPORTED;
                }
                else if (pProperty->ulFlags & SINKPROP_F_FNHANDLER)
                {
                    SINKPROPHANDLER pfn = pProperty->pfnHandler;
                    hr = (this->*pfn)(pPropertyIn->Id, TRUE, pvPropertyData, &ulDataLength);
                }
                else
                {
                    if (ulDataLength > pProperty->cbPropertyData)
                        ulDataLength = pProperty->cbPropertyData;
                    CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);
                }
                break;

            case KSPROPERTY_TYPE_BASICSUPPORT:
                if (ulDataLength < sizeof(DWORD) || pvPropertyData == NULL)
                {
                    hr = DSERR_INVALIDPARAM;
                }
                else
                {
                    *(LPDWORD)pvPropertyData = pProperty->ulSupported;
                    *pulBytesReturned = sizeof(DWORD);
                }
                break;

            default:
                DPF(DPFLVL_WARNING, "KSProperty failed; flags must contain one of KSPROPERTY_TYPE_SET, "
                                    "KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT");
                hr = DSERR_INVALIDPARAM;
        }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::KsMethod"

STDMETHODIMP CImpSinkKsControl::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    DPF_ENTER();
    DPF_LEAVE(DMUS_E_UNKNOWN_PROPERTY);
    return DMUS_E_UNKNOWN_PROPERTY;
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::KsEvent"

STDMETHODIMP CImpSinkKsControl::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    DPF_ENTER();
    DPF_LEAVE(DMUS_E_UNKNOWN_PROPERTY);
    return DMUS_E_UNKNOWN_PROPERTY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsvxdhlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsvxdhlp.h
 *  Content:    DSOUND.VXD wrappers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/7/95      John Miles (Miles Design, Incorporated)
 *  2/3/97      dereks  Ported to DX5
 *
 ***************************************************************************/

#ifndef __DSVXDHLP_H__
#define __DSVXDHLP_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern HANDLE g_hDsVxd;

extern HRESULT __stdcall VxdOpen(void);
extern HRESULT __stdcall VxdInitialize(void);
extern HRESULT __stdcall VxdShutdown(void);
extern HRESULT __stdcall VxdClose(void);

extern HRESULT __stdcall VxdDrvGetNextDriverDesc(LPGUID, LPGUID, PDSDRIVERDESC);
extern HRESULT __stdcall VxdDrvGetDesc(REFGUID, PDSDRIVERDESC);
extern HRESULT __stdcall VxdDrvOpen(REFGUID, LPHANDLE);
extern HRESULT __stdcall VxdDrvClose(HANDLE);
extern HRESULT __stdcall VxdDrvQueryInterface(HANDLE, REFIID, LPVOID *);
extern HRESULT __stdcall VxdDrvGetCaps(HANDLE, PDSDRIVERCAPS);
extern HRESULT __stdcall VxdDrvCreateSoundBuffer(HANDLE, LPWAVEFORMATEX, DWORD, DWORD, LPDWORD, LPBYTE *, LPVOID *);
extern HRESULT __stdcall VxdDrvDuplicateSoundBuffer(HANDLE, HANDLE, LPVOID *);

extern HRESULT __stdcall VxdBufferRelease(HANDLE);
extern HRESULT __stdcall VxdBufferLock(HANDLE, LPVOID *,LPDWORD, LPVOID *, LPDWORD, DWORD, DWORD, DWORD);
extern HRESULT __stdcall VxdBufferUnlock(HANDLE, LPVOID, DWORD, LPVOID, DWORD);
extern HRESULT __stdcall VxdBufferSetFormat(HANDLE, LPWAVEFORMATEX);
extern HRESULT __stdcall VxdBufferSetFrequency(HANDLE, DWORD);
extern HRESULT __stdcall VxdBufferSetVolumePan(HANDLE, PDSVOLUMEPAN);
extern HRESULT __stdcall VxdBufferSetPosition(HANDLE, DWORD);
extern HRESULT __stdcall VxdBufferGetPosition(HANDLE, LPDWORD, LPDWORD);
extern HRESULT __stdcall VxdBufferPlay(HANDLE, DWORD, DWORD, DWORD);
extern HRESULT __stdcall VxdBufferStop(HANDLE);

extern BOOL __stdcall VxdEventScheduleWin32Event(DWORD, DWORD);
extern BOOL __stdcall VxdEventCloseVxdHandle(DWORD);

extern LPVOID __stdcall VxdMemReserveAlias(LPVOID, DWORD);
extern BOOL __stdcall VxdMemCommitAlias(LPVOID, LPVOID, DWORD);
extern BOOL __stdcall VxdMemRedirectAlias(LPVOID, DWORD);
extern BOOL __stdcall VxdMemDecommitAlias(LPVOID, DWORD);
extern BOOL __stdcall VxdMemFreeAlias(LPVOID, DWORD);

extern BOOL __stdcall VxdTestDebugInstalled(void);
extern void __stdcall VxdGetPagefileVersion(LPDWORD, LPDWORD, LPDWORD);
extern void __stdcall VxdGetVmcpdVersion(LPLONG, LPLONG, LPLONG);
extern LPLONG __stdcall VxdGetMixerMutexPtr(void);

extern HRESULT __stdcall VxdIUnknown_QueryInterface(HANDLE, REFIID, LPVOID *);
extern ULONG __stdcall VxdIUnknown_Release(HANDLE);

HRESULT __stdcall VxdIDsDriverPropertySet_GetProperty(HANDLE, PDSPROPERTY, PVOID, ULONG, PVOID, ULONG, PULONG);
HRESULT __stdcall VxdIDsDriverPropertySet_SetProperty(HANDLE, PDSPROPERTY, PVOID, ULONG, PVOID, ULONG);
HRESULT __stdcall VxdIDsDriverPropertySet_QuerySupport(HANDLE, REFGUID, ULONG, PULONG);

extern DWORD __stdcall VxdGetInternalVersionNumber(void);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSVXDHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsvalid.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsvalid.c
 *  Content:    DirectSound parameter validation.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/20/97     dereks  Created
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <mmddk.h>


/***************************************************************************
 *
 *  IsValidDsBufferDesc
 *
 *  Description:
 *      Determines if a DSBUFFERDESC structure is valid.
 *
 *  Arguments:
 *      DSVERSION [in]: structure version.
 *      LPDSBUFFERDESC [in]: structure to examime.
 *
 *  Returns:
 *      HRESULT: DS_OK if the structure is valid, otherwise the appropriate
 *               error code to be returned to the app/caller.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidDsBufferDesc"

HRESULT IsValidDsBufferDesc(DSVERSION nVersion, LPCDSBUFFERDESC pdsbd, BOOL fSinkBuffer)
{
    HRESULT                 hr              = DSERR_INVALIDPARAM;
    BOOL                    fValid          = TRUE;
    DWORD                   dwValidFlags    = DSBCAPS_VALIDFLAGS;

    DPF_ENTER();

    // Restrict the set of valid flags according to various bizarre rules
    if ((pdsbd->dwFlags & DSBCAPS_MIXIN) || fSinkBuffer)
        dwValidFlags &= DSBCAPS_STREAMINGVALIDFLAGS;

    if (fSinkBuffer)
    {
        dwValidFlags |= DSBCAPS_CTRLFREQUENCY;
        if (!(pdsbd->dwFlags & DSBCAPS_MIXIN))
            dwValidFlags |= DSBCAPS_LOCDEFER;
    }
    
#ifdef FUTURE_MULTIPAN_SUPPORT
    if (pdsbd->dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
        dwValidFlags &= DSBCAPS_CHANVOLVALIDFLAGS;
#endif

    if (sizeof(DSBUFFERDESC) != pdsbd->dwSize)
    {
        RPF(DPFLVL_ERROR, "Invalid DSBUFFERDESC structure size");
        fValid = FALSE;
    }
    else if (pdsbd->dwReserved)
    {
        RPF(DPFLVL_ERROR, "Reserved field in the DSBUFFERDESC structure must be 0");
        fValid = FALSE;
    }
    else if (!fSinkBuffer && (pdsbd->dwFlags & DSBCAPS_CTRLFX) && (pdsbd->dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        RPF(DPFLVL_ERROR, "DSBCAPS_CTRLFREQUENCY is invalid with DSBCAPS_CTRLFX");
        fValid = FALSE;
    }
    else fValid = IsValidDsBufferFlags(pdsbd->dwFlags, dwValidFlags);

    if (fValid && (nVersion < DSVERSION_DX7) && (pdsbd->dwFlags & (DSBCAPS_LOCDEFER)))
    {
        RPF(DPFLVL_ERROR, "DSBCAPS_LOCDEFER is only valid on DirectSound 7 or higher");
        fValid = FALSE;
    }

    if (fValid && (nVersion < DSVERSION_DX8))
    {
#ifdef FUTURE_MULTIPAN_SUPPORT
        if (pdsbd->dwFlags & (DSBCAPS_CTRLFX | DSBCAPS_MIXIN | DSBCAPS_CTRLCHANNELVOLUME))
#else
        if (pdsbd->dwFlags & (DSBCAPS_CTRLFX | DSBCAPS_MIXIN))
#endif
        {
            #ifdef RDEBUG
                if (pdsbd->dwFlags & DSBCAPS_CTRLFX)
                    RPF(DPFLVL_ERROR, "DSBCAPS_CTRLFX is only valid on DirectSound8 objects");
                if (pdsbd->dwFlags & DSBCAPS_MIXIN)
                    RPF(DPFLVL_ERROR, "DSBCAPS_MIXIN is only valid on DirectSound8 objects");
#ifdef FUTURE_MULTIPAN_SUPPORT
                if (pdsbd->dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
                    RPF(DPFLVL_ERROR, "DSBCAPS_CTRLCHANNELVOLUME is only valid on DirectSound8 objects");
#endif
            #endif
            hr = DSERR_DS8_REQUIRED;
            fValid = FALSE;
        }
    }

    if (fValid && (pdsbd->dwFlags & DSBCAPS_PRIMARYBUFFER))
    {
        if (pdsbd->dwBufferBytes)
        {
            RPF(DPFLVL_ERROR, "Primary buffers must be created with dwBufferBytes set to 0");
            fValid = FALSE;
        }
        else if (pdsbd->lpwfxFormat)
        {
            RPF(DPFLVL_ERROR, "Primary buffers must be created with NULL format");
            fValid = FALSE;
        }
        else if (!IS_NULL_GUID(&pdsbd->guid3DAlgorithm))
        {
            RPF(DPFLVL_ERROR, "No 3D algorithm may be specified for the listener");
            fValid = FALSE;
        }
    }
    else if (fValid)  // Secondary buffer
    {
        if (!IS_VALID_READ_WAVEFORMATEX(pdsbd->lpwfxFormat))
        {
            RPF(DPFLVL_ERROR, "Invalid format pointer");
            fValid = FALSE;
        }
        else if (!IsValidWfx(pdsbd->lpwfxFormat))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer format");
            fValid = FALSE;
        }
        else if (fSinkBuffer || (pdsbd->dwFlags & DSBCAPS_MIXIN))
        {
            if (pdsbd->dwBufferBytes != 0)
            {
                RPF(DPFLVL_ERROR, "Buffer size must be 0 for MIXIN/sink buffers");
                fValid = FALSE;
            }
        }
        else  // Not a MIXIN or sink buffer
        {
            if (pdsbd->dwBufferBytes < DSBSIZE_MIN || pdsbd->dwBufferBytes > DSBSIZE_MAX)
            {
                RPF(DPFLVL_ERROR, "Buffer size out of bounds");
                fValid = FALSE;
            }
            else if ((pdsbd->dwFlags & DSBCAPS_CTRLFX) && (pdsbd->dwBufferBytes < MsToBytes(DSBSIZE_FX_MIN, pdsbd->lpwfxFormat)))
            {
                RPF(DPFLVL_ERROR, "Buffer too small for effect processing;\nmust hold at least %u ms of audio, "
                    "or %lu bytes in this format", DSBSIZE_FX_MIN, MsToBytes(DSBSIZE_FX_MIN, pdsbd->lpwfxFormat));
                hr = DSERR_BUFFERTOOSMALL;
                fValid = FALSE;
            }
        }

#ifdef FUTURE_MULTIPAN_SUPPORT
        if (fValid && (pdsbd->dwFlags & DSBCAPS_CTRLCHANNELVOLUME) && pdsbd->lpwfxFormat->nChannels != 1)
        {
            RPF(DPFLVL_ERROR, "DSBCAPS_CTRLCHANNELVOLUME is only valid for mono buffers");
            fValid = FALSE;
        }
#endif

        // Extra restrictions for sink buffers, MIXIN buffers and buffers with effects
        if (fValid && (fSinkBuffer || (pdsbd->dwFlags & (DSBCAPS_MIXIN | DSBCAPS_CTRLFX))))
        {
            // Only PCM, mono or stereo, 8- or 16-bit formats are currently supported
            if (pdsbd->lpwfxFormat->wFormatTag != WAVE_FORMAT_PCM)
            {
                RPF(DPFLVL_ERROR, "Wave format must be PCM for MIXIN/sink/effect buffers");
                fValid = FALSE;
            }
            else if (pdsbd->lpwfxFormat->nChannels != 1 && pdsbd->lpwfxFormat->nChannels != 2)
            {
                RPF(DPFLVL_ERROR, "MIXIN/sink/effect buffers must be mono or stereo");
                fValid = FALSE;
            }
            else if (pdsbd->lpwfxFormat->wBitsPerSample != 8 && pdsbd->lpwfxFormat->wBitsPerSample != 16)
            {
                RPF(DPFLVL_ERROR, "MIXIN/sink/effect buffers must be 8- or 16-bit");
                fValid = FALSE;
            }
        }

        if (fValid && !IS_NULL_GUID(&pdsbd->guid3DAlgorithm) && !(pdsbd->dwFlags & DSBCAPS_CTRL3D))
        {
            RPF(DPFLVL_ERROR, "Specified a 3D algorithm without DSBCAPS_CTRL3D");
            fValid = FALSE;
        }

        if (fValid && (pdsbd->dwFlags & DSBCAPS_CTRL3D))
        {
            if (pdsbd->lpwfxFormat->nChannels > 2)
            {
                RPF(DPFLVL_ERROR, "Specified DSBCAPS_CTRL3D with a multichannel wave format");
                fValid = FALSE;
            }
            else if (nVersion >= DSVERSION_DX8 &&
                     (pdsbd->lpwfxFormat->nChannels != 1 || (pdsbd->dwFlags & DSBCAPS_CTRLPAN)))
            {
                // For DirectX 8 and later, we forbid 3D buffers to have two
                // channels or pan control (as we always should have done).
                RPF(DPFLVL_ERROR, "Cannot use DSBCAPS_CTRLPAN or stereo buffers with DSBCAPS_CTRL3D");
                fValid = FALSE;
            }
        }
    }

    if (fValid)
    {
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  IsValidDsBufferFlags
 *
 *  Description:
 *      Determines if a set of buffer creation flags is valid.
 *
 *  Arguments:
 *      DWORD [in]: buffer flag set.
 *      DWORD [in]: mask of valid flags.
 *
 *  Returns:
 *      BOOL: TRUE if the flags are valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidDsBufferFlags"

BOOL IsValidDsBufferFlags(DWORD dwFlags, DWORD dwValidFlags)
{
    BOOL fValid = TRUE;

    DPF_ENTER();

    if (!IS_VALID_FLAGS(dwFlags, dwValidFlags))
    {
        RPF(DPFLVL_ERROR, "Invalid flags: 0x%8.8lX", dwFlags & ~dwValidFlags);
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_LOCSOFTWARE) && (dwFlags & DSBCAPS_LOCHARDWARE))
    {
        RPF(DPFLVL_ERROR, "Specified both LOCSOFTWARE and LOCHARDWARE");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_LOCDEFER) && (dwFlags & DSBCAPS_LOCMASK))
    {
        RPF(DPFLVL_ERROR, "Specified LOCDEFER with either LOCHARDWARE or LOCSOFTWARE");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE) && !(dwFlags & DSBCAPS_CTRL3D))
    {
        RPF(DPFLVL_ERROR, "Specified MUTE3DATMAXDISTANCE without CTRL3D");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_STATIC) && (dwFlags & DSBCAPS_CTRLFX))
    {
        RPF(DPFLVL_ERROR, "Specified both STATIC and CTRLFX");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_STATIC) && (dwFlags & DSBCAPS_MIXIN))
    {
        RPF(DPFLVL_ERROR, "Specified both STATIC and MIXIN");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_STATIC) && (dwFlags & DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "Specified both STATIC and SINKIN");
        fValid = FALSE;
    }
    else if (dwFlags & DSBCAPS_PRIMARYBUFFER)
    {
        if (dwFlags & (DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_GLOBALFOCUS |
                       DSBCAPS_STATIC | DSBCAPS_CTRLFX | DSBCAPS_MIXIN
#ifdef FUTURE_MULTIPAN_SUPPORT
             | DSBCAPS_CTRLCHANNELVOLUME 
#endif
           ))
        {
            #ifdef RDEBUG
                if (dwFlags & DSBCAPS_CTRLFREQUENCY)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLFREQUENCY");
                if (dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLPOSITIONNOTIFY");
                if (dwFlags & DSBCAPS_GLOBALFOCUS)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support GLOBAL focus");
                if (dwFlags & DSBCAPS_STATIC)
                    RPF(DPFLVL_ERROR, "Primary buffers can't be STATIC");
#ifdef FUTURE_MULTIPAN_SUPPORT
                if (dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLCHANNELVOLUME");
#endif
                if (dwFlags & DSBCAPS_CTRLFX)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLFX");
                if (dwFlags & DSBCAPS_MIXIN)
                    RPF(DPFLVL_ERROR, "Primary buffers can't be MIXIN");
            #endif
            fValid = FALSE;
        }
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidWfxPtr
 *
 *  Description:
 *      Determines if an LPWAVEFORMATEX pointer is valid.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: pointer to examime.
 *
 *  Returns:
 *      BOOL: TRUE if the structure is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidWfxPtr"

BOOL IsValidWfxPtr(LPCWAVEFORMATEX pwfx)
{
    BOOL                    fValid;

    DPF_ENTER();

    fValid = IS_VALID_READ_PTR(pwfx, sizeof(PCMWAVEFORMAT));

    if (fValid && WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        fValid = IS_VALID_READ_PTR(pwfx, sizeof(WAVEFORMATEX));
    }

    if (fValid && WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        fValid = IS_VALID_READ_PTR(pwfx, sizeof(WAVEFORMATEX) + pwfx->cbSize);
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidWfx
 *
 *  Description:
 *      Determines if a WAVEFORMATEX structure is valid.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: structure to examime.
 *
 *  Returns:
 *      BOOL: TRUE if the structure is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidWfx"

BOOL IsValidWfx(LPCWAVEFORMATEX pwfx)
{
    BOOL fValid;

    DPF_ENTER();

    switch (pwfx->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            fValid = IsValidPcmWfx(pwfx);
            break;

        case WAVE_FORMAT_EXTENSIBLE:
            fValid = IsValidExtensibleWfx((PWAVEFORMATEXTENSIBLE)pwfx);
            break;

        default:
            fValid = TRUE;
            break;
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidPcmWfx
 *
 *  Description:
 *      Determines if a WAVEFORMATEX structure is valid for PCM audio.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: structure to examime.
 *
 *  Returns:
 *      BOOL: TRUE if the structure is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidPcmWfx"

BOOL IsValidPcmWfx(LPCWAVEFORMATEX pwfx)
{
    BOOL                    fValid    = TRUE;
    DWORD                   dwAvgBytes;

    DPF_ENTER();

    if (pwfx->wFormatTag != WAVE_FORMAT_PCM)
    {
        RPF(DPFLVL_ERROR, "Format not PCM");
        fValid = FALSE;
    }

    if (fValid && pwfx->nChannels != 1 && pwfx->nChannels != 2)
    {
        RPF(DPFLVL_ERROR, "Not mono or stereo");
        fValid = FALSE;
    }

    if (fValid && pwfx->wBitsPerSample != 8 && pwfx->wBitsPerSample != 16)
    {
        RPF(DPFLVL_ERROR, "Not 8 or 16 bit");
        fValid = FALSE;
    }

    if (fValid && (pwfx->nSamplesPerSec < DSBFREQUENCY_MIN || pwfx->nSamplesPerSec > DSBFREQUENCY_MAX))
    {
        RPF(DPFLVL_ERROR, "Frequency out of bounds");
        fValid = FALSE;
    }

    if (fValid && pwfx->nBlockAlign != (pwfx->wBitsPerSample / 8) * pwfx->nChannels)
    {
        RPF(DPFLVL_ERROR, "Bad block alignment");
        fValid = FALSE;
    }

    if (fValid)
    {
        dwAvgBytes = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

        if (pwfx->nAvgBytesPerSec > dwAvgBytes + (dwAvgBytes / 20) || pwfx->nAvgBytesPerSec < dwAvgBytes - (dwAvgBytes / 20))
        {
            RPF(DPFLVL_ERROR, "Bad average bytes per second");
            fValid = FALSE;
        }
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidExtensibleWfx
 *
 *  Description:
 *      Determines if a WAVEFORMATEXTENSIBLE structure is wellformed.
 *
 *  Arguments:
 *      PWAVEFORMATEXTENSIBLE [in]: structure to examime.
 *
 *  Returns:  
 *      BOOL: TRUE if the structure is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidExtensibleWfx"

BOOL IsValidExtensibleWfx(PWAVEFORMATEXTENSIBLE pwfx)
{
    BOOL fValid = TRUE;
    DPF_ENTER();
    
    if (pwfx->Format.wFormatTag != WAVE_FORMAT_EXTENSIBLE)
    {
        RPF(DPFLVL_ERROR, "Format tag not WAVE_FORMAT_EXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.cbSize < (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)))
    {
        RPF(DPFLVL_ERROR, "Field cbSize too small for WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.nChannels == 0)
    {
        RPF(DPFLVL_ERROR, "Zero channels is invalid for WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.wBitsPerSample != 8  && pwfx->Format.wBitsPerSample != 16 &&
             pwfx->Format.wBitsPerSample != 24 && pwfx->Format.wBitsPerSample != 32)
    {
        RPF(DPFLVL_ERROR, "Only 8, 16, 24 or 32 bit formats allowed for WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.nSamplesPerSec < DSBFREQUENCY_MIN || pwfx->Format.nSamplesPerSec > DSBFREQUENCY_MAX)
    {
        RPF(DPFLVL_ERROR, "Frequency out of bounds in WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.nBlockAlign != (pwfx->Format.wBitsPerSample / 8) * pwfx->Format.nChannels)
    {
        RPF(DPFLVL_ERROR, "Bad block alignment in WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Samples.wValidBitsPerSample > pwfx->Format.wBitsPerSample)
    {
        RPF(DPFLVL_ERROR, "WAVEFORMATEXTENSIBLE has higher wValidBitsPerSample than wBitsPerSample");
        fValid = FALSE;
    }

    // Check the average bytes per second (within 5%)
    if (fValid)
    {
        DWORD dwAvgBytes = pwfx->Format.nSamplesPerSec * pwfx->Format.nBlockAlign;
        if (pwfx->Format.nAvgBytesPerSec > dwAvgBytes + (dwAvgBytes / 20) || pwfx->Format.nAvgBytesPerSec < dwAvgBytes - (dwAvgBytes / 20))
        {
            RPF(DPFLVL_ERROR, "Bad average bytes per second in WAVEFORMATEXTENSIBLE");
            fValid = FALSE;
        }
    }

    // Check the number of bits set in the channel mask against nChannels
    if (fValid && CountBits(pwfx->dwChannelMask) > pwfx->Format.nChannels)
    {
        RPF(DPFLVL_INFO, "Number of bits set in dwChannelMask exceeds nChannels in WAVEFORMATEXTENSIBLE");
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidHandle
 *
 *  Description:
 *      Validates an object handle.
 *
 *  Arguments:
 *      HANDLE [in]: handle to validate.
 *
 *  Returns:
 *      BOOL: TRUE if the handle is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidHandle"

BOOL IsValidHandle(HANDLE hHandle)
{
    const HANDLE        hProcess    = GetCurrentProcess();
    HANDLE              hDuplicate;
    BOOL                fSuccess;

    DPF_ENTER();

    fSuccess = DuplicateHandle(hProcess, hHandle, hProcess, &hDuplicate, 0, FALSE, DUPLICATE_SAME_ACCESS);

    CLOSE_HANDLE(hDuplicate);

    DPF_LEAVE(fSuccess);
    return fSuccess;
}


/***************************************************************************
 *
 *  IsValidPropertySetId
 *
 *  Description:
 *      Validates a property set id.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *
 *  Returns:
 *      BOOL: TRUE if the property set ID is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidPropertySetId"

BOOL IsValidPropertySetId(REFGUID guidPropertySetId)
{
    LPCGUID const           apguidInvalid[] = { &DSPROPSETID_DirectSound3DListener, &DSPROPSETID_DirectSound3DBuffer, &DSPROPSETID_DirectSoundSpeakerConfig };
    BOOL                    fValid;
    UINT                    i;

    DPF_ENTER();

    ASSERT(!IS_NULL_GUID(guidPropertySetId));

    for (i=0, fValid=TRUE; i < NUMELMS(apguidInvalid) && fValid; i++)
    {
        fValid = !IsEqualGUID(guidPropertySetId, apguidInvalid[i]);
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidDscBufferDesc
 *
 *  Description:
 *      Determines if a DSCBUFFERDESC structure is valid.
 *
 *  Arguments:
 *      DSVERSION [in]: structure version.
 *      LPCDSCBUFFERDESC [in]: structure to examime.
 *
 *  Returns:
 *      HRESULT: DS_OK if the structure is valid, otherwise the appropriate
 *               error code to be returned to the app/caller.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidDscBufferDesc"

HRESULT IsValidDscBufferDesc(DSVERSION nVersion, LPCDSCBUFFERDESC pdscbd)
{
    HRESULT                 hr      = DSERR_INVALIDPARAM;
    BOOL                    fValid  = TRUE;
    DWORD                   i;

    DPF_ENTER();

    if (pdscbd->dwSize != sizeof(DSCBUFFERDESC))
    {
        RPF(DPFLVL_ERROR, "Invalid size");
        fValid = FALSE;
    }

    if (fValid && !IS_VALID_FLAGS(pdscbd->dwFlags, DSCBCAPS_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        fValid = FALSE;
    }

    if (fValid)
    {
        if (pdscbd->dwFlags & DSCBCAPS_CTRLFX)
        {
            if (nVersion < DSVERSION_DX8)
            {
                RPF(DPFLVL_ERROR, "DSCBCAPS_CTRLFX is only valid on DirectSoundCapture8 objects");
                hr = DSERR_DS8_REQUIRED;
                fValid = FALSE;
            }
            else if (!pdscbd->dwFXCount != !pdscbd->lpDSCFXDesc)
            {
                RPF(DPFLVL_ERROR, "If either of dwFXCount or lpDSCFXDesc are 0, both must be 0");
                fValid = FALSE;
            }
        }
        else // !DSCBCAPS_CTRLFX
        {
            if (pdscbd->dwFXCount || pdscbd->lpDSCFXDesc)
            {
                RPF(DPFLVL_ERROR, "If DSCBCAPS_CTRLFX is not set, dwFXCount and lpDSCFXDesc must be 0");
                fValid = FALSE;
            }
        }
    }

    if (fValid && pdscbd->dwReserved)
    {
        RPF(DPFLVL_ERROR, "Reserved field in the DSCBUFFERDESC structure must be 0");
        fValid = FALSE;
    }

    if (fValid && (pdscbd->dwBufferBytes < DSBSIZE_MIN || pdscbd->dwBufferBytes > DSBSIZE_MAX))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer size");
        fValid = FALSE;
    }

    if (fValid && !IS_VALID_READ_WAVEFORMATEX(pdscbd->lpwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Unreadable WAVEFORMATEX");
        fValid = FALSE;
    }

    if (fValid && !IsValidWfx(pdscbd->lpwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format");
        fValid = FALSE;
    }

    if (fValid && (pdscbd->dwFXCount != 0))
    {
        for (i=0; i<pdscbd->dwFXCount; i++)
        {
            fValid = IsValidCaptureEffectDesc(&pdscbd->lpDSCFXDesc[i]);
            if (!fValid)
                break;
        }
    }

    if (fValid)
    {
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  IsValidCaptureFxFlags
 *
 *  Description:
 *      Determines if a combination of DSCFX_* flags is valid.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      BOOL: TRUE if the flags are valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidCaptureFxFlags"

BOOL IsValidCaptureFxFlags(DWORD dwFlags)
{
    BOOL fValid;
    DPF_ENTER();

    fValid = IS_VALID_FLAGS(dwFlags, DSCFX_VALIDFLAGS) &&
             !((dwFlags & DSCFX_LOCHARDWARE) && (dwFlags & DSCFX_LOCSOFTWARE)) &&
             ((dwFlags & DSCFX_LOCHARDWARE) || (dwFlags & DSCFX_LOCSOFTWARE));

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidCaptureEffectDesc
 *
 *  Description:
 *      Determines if a capture effect descriptor structure is valid.
 *
 *  Arguments:
 *      LPGUID [in]: effect identifier.
 *
 *  Returns:
 *      BOOL: TRUE if the ID is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidCaptureEffectDesc"

BOOL IsValidCaptureEffectDesc(LPCDSCEFFECTDESC pCaptureEffectDesc)
{
    BOOL fValid = TRUE;

    DPF_ENTER();

    if (sizeof(DSCEFFECTDESC) != pCaptureEffectDesc->dwSize)
    {
        RPF(DPFLVL_ERROR, "Invalid size");
        fValid = FALSE;
    }

    if (fValid)
    {
        fValid = IsValidCaptureFxFlags(pCaptureEffectDesc->dwFlags);
    }

    // FIXME: Check that the GUID corresponds to a registered DMO?

    if (pCaptureEffectDesc->dwReserved1 || pCaptureEffectDesc->dwReserved2)
    {
        RPF(DPFLVL_ERROR, "Reserved fields in the DSCEFFECTDESC structure must be 0");
        fValid = FALSE;
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  ValidateNotificationPositions
 *
 *  Description:
 *      Validates array of notification positions and returns an allocated
 *      array of position.notifications sorted by increasing offset on success.
 *
 *  Arguments:
 *      DWORD [in]: size of buffer
 *      DWORD [in]: count of position.notifies
 *      LPCDSBPOSITIONNOTIFY [in]: array of position.notifies
 *      UINT [in]: size of samples in bytes
 *      LPDSBPOSITIONNOTIFY * [out]: receives array of sorted position.notifies
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ValidateNotificationPositions"

HRESULT ValidateNotificationPositions(DWORD cbBuffer, DWORD cNotes, LPCDSBPOSITIONNOTIFY paNotes, UINT cbSample, LPDSBPOSITIONNOTIFY *ppaNotesOrdered)
{
    HRESULT                 hr              = DS_OK;
    LPDSBPOSITIONNOTIFY     paNotesOrdered  = NULL;
    DSBPOSITIONNOTIFY       dspnTemp;
    UINT                    i;

    DPF_ENTER();

    ASSERT(IS_VALID_WRITE_PTR(ppaNotesOrdered, sizeof(LPDSBPOSITIONNOTIFY)));

    if (paNotes && !IS_VALID_READ_PTR(paNotes, cNotes * sizeof(paNotes[0])))
    {
        RPF(DPFLVL_ERROR, "Invalid LPDSBPOSITIONNOTIFY pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Make a sample-aligned copy of the list
    if (SUCCEEDED(hr) && cNotes)
    {
        paNotesOrdered = MEMALLOC_A_COPY(DSBPOSITIONNOTIFY, cNotes, paNotes);
        hr = HRFROMP(paNotesOrdered);
    }

    for (i = 0; i < cNotes && SUCCEEDED(hr); i++)
    {
        if (DSBPN_OFFSETSTOP != paNotesOrdered[i].dwOffset)
        {
            paNotesOrdered[i].dwOffset = BLOCKALIGN(paNotesOrdered[i].dwOffset, cbSample);
        }
    }

    // Put the list into ascending order
    for (i = 0; i + 1 < cNotes && SUCCEEDED(hr); i++)
    {
        if (paNotesOrdered[i].dwOffset > paNotesOrdered[i + 1].dwOffset)
        {
            dspnTemp = paNotesOrdered[i];
            paNotesOrdered[i] = paNotesOrdered[i + 1];
            paNotesOrdered[i + 1] = dspnTemp;
            i = -1;
        }
    }

    // Validate the list
    for (i = 0; i < cNotes && SUCCEEDED(hr); i++)
    {
        // Buffer offset must be valid
        if ((DSBPN_OFFSETSTOP != paNotesOrdered[i].dwOffset) && (paNotesOrdered[i].dwOffset >= cbBuffer))
        {
            RPF(DPFLVL_ERROR, "dwOffset (%lu) of notify index %lu is invalid", paNotesOrdered[i].dwOffset, i);
            hr = DSERR_INVALIDPARAM;
            break;
        }

        // Event handle must be valid
        if (!IS_VALID_HANDLE(paNotesOrdered[i].hEventNotify))
        {
            RPF(DPFLVL_ERROR, "hEventNotify (0x%p) of notify index %lu is invalid", paNotesOrdered[i].hEventNotify, i);
            hr = DSERR_INVALIDPARAM;
            break;
        }

        // Only one event allowed per sample offset
        if ((i + 1) < cNotes)
        {
            if (DSBPN_OFFSETSTOP == paNotesOrdered[i].dwOffset)
            {
                RPF(DPFLVL_ERROR, "Additional stop event at notify index %lu", i);
                hr = DSERR_INVALIDPARAM;
                break;
            }
            else if (paNotesOrdered[i].dwOffset == paNotesOrdered[i + 1].dwOffset)
            {
                RPF(DPFLVL_ERROR, "Duplicate sample position at notify index %lu", paNotesOrdered[i].dwOffset, paNotesOrdered[i + 1].dwOffset, i + 1);
                hr = DSERR_INVALIDPARAM;
                break;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppaNotesOrdered = paNotesOrdered;
    }
    else
    {
        MEMFREE(paNotesOrdered);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  IsValidDs3dBufferConeAngles
 *
 *  Description:
 *      Validates DirectSound3D Buffer Cone Angles.
 *
 *  Arguments:
 *      DWORD [in]: inside cone angle.
 *      DWORD [in]: outside cone angle.
 *
 *  Returns:
 *      BOOL: TRUE if the cone anlges are valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidDs3dBufferConeAngles"

BOOL IsValidDs3dBufferConeAngles(DWORD dwInside, DWORD dwOutside)
{
    BOOL fValid = TRUE;

    if (dwOutside < dwInside)
    {
        RPF(DPFLVL_ERROR, "Outside cone angle can't be less than inside");
        fValid = FALSE;
    }
    else if (dwInside > 360 || dwOutside > 360)
    {
        RPF(DPFLVL_ERROR, "There are only 360 degrees in a circle");
        fValid = FALSE;
    }

    return fValid;
}


/***************************************************************************
 *
 *  IsValidWaveDevice
 *
 *  Description:
 *      Determines if a waveOut device is useable.
 *
 *  Arguments:
 *      UINT [in]: device id.
 *      BOOL [in]: TRUE if capture.
 *      LPVOID [in]: device caps.  This parameter may be NULL.
 *
 *  Returns:
 *      BOOL: TRUE if the device is useable.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidWaveDevice"

BOOL IsValidWaveDevice(UINT uDeviceId, BOOL fCapture, LPCVOID pvCaps)
{
    const UINT              cDevices    = WaveGetNumDevs(fCapture);
    BOOL                    fOk         = TRUE;
    WAVEOUTCAPS             woc;
    WAVEINCAPS              wic;
    MMRESULT                mmr;

    DPF_ENTER();

    // Make sure this is a real device
    if (uDeviceId >= cDevices)
    {
        DPF(DPFLVL_ERROR, "Invalid waveOut device id");
        fOk = FALSE;
    }

    // Get device caps, if they weren't supplied to us
    if (fOk && !pvCaps)
    {
        if (fCapture)
        {
            pvCaps = &wic;
            mmr = waveInGetDevCaps(uDeviceId, &wic, sizeof(wic));
        }
        else
        {
            pvCaps = &woc;
            mmr = waveOutGetDevCaps(uDeviceId, &woc, sizeof(woc));
        }

        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(DPFLVL_ERROR, "Can't get device %lu caps", uDeviceId);
            fOk = FALSE;
        }
    }

    // Check for compatible caps
    if (fOk && !fCapture)
    {
        if (!(((LPWAVEOUTCAPS)pvCaps)->dwSupport & WAVECAPS_LRVOLUME))
        {
            RPF(DPFLVL_WARNING, "Device %lu does not support separate left and right volume control", uDeviceId);
        }

        if (!(((LPWAVEOUTCAPS)pvCaps)->dwSupport & WAVECAPS_VOLUME))
        {
            RPF(DPFLVL_WARNING, "Device %lu does not support volume control", uDeviceId);
        }

        if (!(((LPWAVEOUTCAPS)pvCaps)->dwSupport & WAVECAPS_SAMPLEACCURATE))
        {
            RPF(DPFLVL_WARNING, "Device %lu does not return sample-accurate position information", uDeviceId);
        }

        if (((LPWAVEOUTCAPS)pvCaps)->dwSupport & WAVECAPS_SYNC)
        {
            RPF(DPFLVL_ERROR, "Device %lu is synchronous and will block while playing a buffer", uDeviceId);
            fOk = FALSE;
        }
    }

    DPF_LEAVE(fOk);
    return fOk;
}


/***************************************************************************
 *
 *  IsValid3dAlgorithm
 *
 *  Description:
 *      Determines if a 3D algorithm GUID is valid.
 *
 *  Arguments:
 *      LPGUID [in]: 3D algorithm identifier.
 *
 *  Returns:
 *      BOOL: TRUE if the ID is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValid3dAlgorithm"

BOOL IsValid3dAlgorithm(REFGUID guid3dAlgorithm)
{
    LPCGUID                 apguidValid[]   = { &DS3DALG_ITD, &DS3DALG_NO_VIRTUALIZATION, &DS3DALG_HRTF_LIGHT, &DS3DALG_HRTF_FULL };
    BOOL                    fValid;
    UINT                    i;

    DPF_ENTER();

    if (IS_NULL_GUID(guid3dAlgorithm))
    {
        fValid = TRUE;
    }
    else
    {
        for (i = 0, fValid = FALSE; i < NUMELMS(apguidValid) && !fValid; i++)
        {
            fValid = IsEqualGUID(guid3dAlgorithm, apguidValid[i]);
        }
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidFxFlags
 *
 *  Description:
 *      Determines if a combination of DSFX_* flags is valid.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      BOOL: TRUE if the flags are valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidFxFlags"

BOOL IsValidFxFlags(DWORD dwFlags)
{
    BOOL fValid;
    DPF_ENTER();

    fValid = IS_VALID_FLAGS(dwFlags, DSFX_VALIDFLAGS) &&
             !((dwFlags & DSFX_LOCHARDWARE) && (dwFlags & DSFX_LOCSOFTWARE));

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  BuildValidDsBufferDesc
 *
 *  Description:
 *      Builds a DSBUFFERDESC structure based on a potentially invalid
 *      external version.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: structure to examime.
 *      LPDSBUFFERDESC [out]: receives validated structure.
 *      DSVERSION [in]: version information from our caller.
 *      BOOL [in]: TRUE if this buffer is being created on a DS sink.
 *
 *  Returns:
 *      HRESULT: DS_OK if the structure is valid, otherwise the appropriate
 *               error code to be returned to the app/caller.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "BuildValidDsBufferDesc"

HRESULT BuildValidDsBufferDesc(LPCDSBUFFERDESC pOld, LPDSBUFFERDESC pNew, DSVERSION nVersion, BOOL fSinkBuffer)
{
    BOOL        fValid      = TRUE;
    HRESULT     hr          = DSERR_INVALIDPARAM;

    DPF_ENTER();

    // Determine the structure version from its size.
    // This is complementary to the nVersion argument, which is derived from
    // the COM interfaces requested so far on this object.  If the structure
    // size is smaller than the current size, we believe it.  Otherwise, we
    // go with the COM interface version.
    switch (pOld->dwSize)
    {
        case sizeof(DSBUFFERDESC1):
            nVersion = DSVERSION_INITIAL;
            break;

        case sizeof(DSBUFFERDESC):
            // Was nVersion = DSVERSION_CURRENT; but see comment above
            break;

        default:
            RPF(DPFLVL_ERROR, "Invalid size");
            fValid = FALSE;
            break;
    }

    if (fValid)
    {
        // Fill in the structure size.  We're always using the most current
        // version of the structure, so this should reflect the current
        // DSBUFFERDESC size.
        pNew->dwSize = sizeof(DSBUFFERDESC);

        // Fill in the rest of the structure
        CopyMemoryOffset(pNew, pOld, pOld->dwSize, sizeof(pOld->dwSize));
        ZeroMemoryOffset(pNew, pNew->dwSize, pOld->dwSize);
            
        // Fix the 3D algorithm GUID if invalid
        if (!IsValid3dAlgorithm(&pNew->guid3DAlgorithm))
        {
            DPF(DPFLVL_WARNING, "Invalid 3D algorithm GUID");
            pNew->guid3DAlgorithm = GUID_NULL;  // This means "use default algorithm"
        }

        // Validate the new structure
        hr = IsValidDsBufferDesc(nVersion, pNew, fSinkBuffer);
    }

    // Check and set up the buffer size for special buffer types
    if (SUCCEEDED(hr) && ((pNew->dwFlags & DSBCAPS_MIXIN) || fSinkBuffer))
    {
        // The size requested for internal buffers must be 0 - we always use
        // a size corresponding to INTERNAL_BUFFER_LENGTH milliseconds.
        // (FIXME - is the size of sinkin buffers determined here or in dssink.cpp?)
            
        pNew->dwBufferBytes = (INTERNAL_BUFFER_LENGTH * pNew->lpwfxFormat->nAvgBytesPerSec) / 1000;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  BuildValidDscBufferDesc
 *
 *  Description:
 *      Builds a DSCBUFFERDESC structure based on a potentially invalid
 *      external version.
 *
 *  Arguments:
 *      LPDSCBUFFERDESC [in]: structure to examime.
 *      LPDSCBUFFERDESC [out]: receives validated structure.
 *
 *  Returns:
 *      HRESULT: DS_OK if the structure is valid, otherwise the appropriate
 *               error code to be returned to the app/caller.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "BuildValidDscBufferDesc"

HRESULT BuildValidDscBufferDesc(LPCDSCBUFFERDESC pOld, LPDSCBUFFERDESC pNew, DSVERSION nVersion)
{
    BOOL        fValid      = TRUE;
    HRESULT     hr          = DSERR_INVALIDPARAM;

    DPF_ENTER();

    // Determine the structure version
    switch (pOld->dwSize)
    {
        case sizeof(DSCBUFFERDESC1):
            nVersion = DSVERSION_INITIAL;
            break;

        case sizeof(DSCBUFFERDESC):
            // nVersion = DSVERSION_CURRENT; - See comment in BuildValidDsBufferDesc
            break;

        default:
            RPF(DPFLVL_ERROR, "Invalid size");
            fValid = FALSE;
            break;
    }

    // Fill in the structure size.  We're always using the most current
    // version of the structure, so this should reflect the current
    // DSBUFFERDESC size.
    if (fValid)
    {
        pNew->dwSize = sizeof(DSCBUFFERDESC);

        // Fill in the rest of the structure
        CopyMemoryOffset(pNew, pOld, pOld->dwSize, sizeof(pOld->dwSize));
        ZeroMemoryOffset(pNew, pNew->dwSize, pOld->dwSize);

        // Validate the new structure
        hr = IsValidDscBufferDesc(nVersion, pNew);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  BuildValidGuid
 *
 *  Description:
 *      Builds a GUID based on a potentially invalid external version.
 *
 *  Arguments:
 *      REFGUID [in]: source GUID.
 *      LPGUID [out]: receives new GUID.
 *
 *  Returns:
 *      LPGUID: pointer to new GUID.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "BuildValidGuid"

LPCGUID BuildValidGuid(LPCGUID pguidSource, LPGUID pguidDest)
{
    DPF_ENTER();

    if (IS_NULL_GUID(pguidSource))
    {
        pguidSource = &GUID_NULL;
    }

    if (pguidDest)
    {
        CopyMemory(pguidDest, pguidSource, sizeof(GUID));
    }

    DPF_LEAVE(pguidSource);
    return pguidSource;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsvxdhlp.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsvxdhlp.c
 *  Content:    DSOUND.VXD wrappers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/7/95      John Miles (Miles Design, Incorporated)
 *  2/3/97      dereks  Ported to DX5
 *
 ***************************************************************************/

//
// Dear reader, please pay heed to the following warning:
//
// Because dsound.vxd reads directly from the stack, arguments passed
// to any of the following wrapper functions may not be modified.  The VxD
// will NOT see the changes.
//

#ifdef NOVXD
#error dsvxdhlp.c being built with NOVXD defined
#endif // NOVXD

#include "dsoundi.h"
#include "dsvxd.h"

// The VC compiler likes to try to pass arguments in registers
#pragma optimize("", off)

#ifndef FILE_FLAG_GLOBAL_HANDLE
#define FILE_FLAG_GLOBAL_HANDLE 0x00800000
#endif // FILE_FLAG_GLOBAL_HANDLE

int g_cReservedAliases;
int g_cCommittedAliases;


LPVOID __stdcall VxdMemReserveAlias(LPVOID pBuffer, DWORD cbBuffer)
{
    LPVOID pAlias;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pBuffer && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMRESERVEALIAS,
			  &pBuffer,
			  2*4,
			  &pAlias,
			  sizeof(pAlias),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(pAlias));

    if (NULL != pAlias) g_cReservedAliases++;
    return pAlias;
}

BOOL __stdcall VxdMemCommitAlias(LPVOID pAlias, LPVOID pBuffer, DWORD cbBuffer)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pAlias && pBuffer && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMCOMMITALIAS,
			  &pAlias,
			  3*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));

    if (fReturn) g_cCommittedAliases++;
    return fReturn;
}

BOOL __stdcall VxdMemRedirectAlias(LPVOID pAlias, DWORD cbBuffer)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pAlias && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMREDIRECTALIAS,
			  &pAlias,
			  2*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));
    return fReturn;
}

BOOL __stdcall VxdMemDecommitAlias(LPVOID pAlias, DWORD cbBuffer)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pAlias && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMDECOMMITALIAS,
			  &pAlias,
			  2*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));

    if (fReturn) g_cCommittedAliases--;
    return fReturn;
}

BOOL __stdcall VxdMemFreeAlias(LPVOID pAlias, DWORD cbBuffer)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pAlias && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMFREEALIAS,
			  &pAlias,
			  2*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));

    if (fReturn) g_cReservedAliases--;
    return fReturn;
}


//===========================================================================
//
// Event APIs
//
//===========================================================================
BOOL __stdcall VxdEventScheduleWin32Event(DWORD VxdhEvent, DWORD dwDelay)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdhEvent);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_EVENTSCHEDULEWIN32EVENT,
			  &VxdhEvent,
			  2*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));
    return fReturn;
}

BOOL __stdcall VxdEventCloseVxdHandle(DWORD VxdhEvent)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdhEvent);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_EVENTCLOSEVXDHANDLE,
			  &VxdhEvent,
			  1*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));
    return fReturn;
}


//****************************************************************************
//**                                                                        **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvGetNextDriverDesc(LPGUID pGuidPrev, LPGUID pGuid, PDSDRIVERDESC pDrvDesc)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(pGuid && pDrvDesc);

    // If we don't have DSVXD around...
    if (NULL == g_hDsVxd) return DSERR_NODRIVER;
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVGETNEXTDRIVERDESC,
			  &pGuidPrev,
			  3*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

HRESULT __stdcall VxdDrvGetDesc(REFGUID rguid, PDSDRIVERDESC pDrvDesc)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(rguid && pDrvDesc);
    
    // If we don't have DSVXD around...
    if (NULL == g_hDsVxd) return DSERR_NODRIVER;
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVGETDESC,
			  (LPVOID)&rguid,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Open HAL VxD, writing VxD handle to user-supplied HANDLE               **
//**                                                                        **
//** Failure results in a return value of HAL_CANT_OPEN_VXD                 **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvOpen
(
    REFGUID rguid,
    LPHANDLE pHandle
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(rguid && pHandle);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVOPEN,
			  (LPVOID)&rguid,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Close HAL VxD                                                          **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvClose
(
    HANDLE hDriver
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hDriver);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVCLOSE,
			  &hDriver,
			  1*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Fill user-supplied HALCAPS structure with capability and mode list     **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvGetCaps
(
 HANDLE hDriver,
 PDSDRIVERCAPS pDrvCaps
)
{
    HRESULT	    dsv;
    DWORD	    cbReturned;
    BOOL	    fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hDriver && pDrvCaps);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVGETCAPS,
			  &hDriver,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Allocate stream buffer from HAL                                        **
//**                                                                        **
//** Fills a user-supplied stream buffer structure with buffer parameters;  **
//** returns HAL_ALLOC_FAILED if hardware cannot support any more buffers   **
//** or the requested format is unavailable                                 **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvCreateSoundBuffer
(
 HANDLE hDriver,
 LPWAVEFORMATEX pwfx,
 DWORD dwFlags,
 DWORD dwCardAddress,
 LPDWORD pdwcbBufferSize,
 LPBYTE *ppBuffer,
 LPVOID *ppv
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hDriver && pwfx && pdwcbBufferSize && ppBuffer && ppv);

    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
 			  DSVXD_IOCTL_DRVCREATESOUNDBUFFER,
			  &hDriver,
			  7*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

HRESULT __stdcall VxdDrvDuplicateSoundBuffer
(
 HANDLE hDriver,
 HANDLE hBuffer,
 LPVOID *ppv
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hDriver && hBuffer && ppv);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
 			  DSVXD_IOCTL_DRVDUPLICATESOUNDBUFFER,
			  &hDriver,
			  3*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Free stream buffer allocated from HAL                                  **
//**                                                                        **
//** Returns Success or fail                                                **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferRelease
(    
 HANDLE hBuffer
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERRELEASE,
			  &hBuffer,
			  1*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Lock the data                                                          **
//**                                                                        **
//** Returns Success or fail                                                **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferLock
(
 HANDLE hBuffer,
 LPVOID *ppvAudio1,
 LPDWORD pdwLen1,
 LPVOID *ppvAudio2,
 LPDWORD pdwLen2,
 DWORD dwWritePosition,
 DWORD dwWriteLen,
 DWORD dwFlags
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && ppvAudio1);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERLOCK,
			  &hBuffer,
			  8*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Unlock the data                                                        **
//**                                                                        **
//** Returns Success or fail                                                **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferUnlock
(
 HANDLE hBuffer,  
 LPVOID pvAudio1,
 DWORD dwLen1,
 LPVOID pvAudio2,
 DWORD dwLen2
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && pvAudio1);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERUNLOCK,
			  &hBuffer,
			  5*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Set buffer format							    **
//**                                                                        **
//** Returns HAL_ERROR on failure, either because the rate/mode combination **
//** is not valid on this card						    **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferSetFormat
(
    HANDLE hBuffer,
    LPWAVEFORMATEX pwfxToSet
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && pwfxToSet);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSETFORMAT,
			  &hBuffer,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Set buffer rate							    **
//**                                                                        **
//** Returns HAL_ERROR on failure, because the frequency		    **
//** is not valid on this card						    **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferSetFrequency
(
 HANDLE hBuffer,
 DWORD dwFrequency
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSETRATE,
			  &hBuffer,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Set new Buffer volume effect					    **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferSetVolumePan
(
 HANDLE hBuffer,
 PDSVOLUMEPAN pDsVolPan
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && pDsVolPan);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSETVOLUMEPAN,
			  &hBuffer,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Set new Buffer Position value					    **
//**                                                                        **
//** Returns HAL_ERROR if the device does not support Position changes	    **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferSetPosition
(
 HANDLE hBuffer,
 DWORD dwPosition
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSETPOSITION,
			  &hBuffer,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Get stream buffer cursors and play/stop status                         **
//**                                                                        **
//** Returns HAL_ERROR if status cannot be determined for any reason        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferGetPosition
(
 HANDLE hBuffer,
 LPDWORD lpdwCurrentPlayCursor,
 LPDWORD lpdwCurrentWriteCursor
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && lpdwCurrentPlayCursor && lpdwCurrentWriteCursor);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERGETPOSITION,
			  &hBuffer,
			  3*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Start buffer playing						    **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferPlay
(
 HANDLE hBuffer,
 DWORD dwReserved1,
 DWORD dwReserved2,
 DWORD dwFlags
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERPLAY,
			  &hBuffer,
			  4*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Stop buffer playing						    **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferStop
(
 HANDLE hBuffer
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSTOP,
			  &hBuffer,
			  1*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}


HRESULT __stdcall VxdOpen(void)
{
    ASSERT(!g_hDsVxd);

    g_hDsVxd = CreateFile("\\\\.\\DSOUND.VXD", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE, NULL);

    if(INVALID_HANDLE_VALUE == g_hDsVxd)
    {
        DPF(0, "HEL create file failed");
        g_hDsVxd = NULL;
    }

    return g_hDsVxd ? DS_OK : DSERR_NODRIVER;
}


HRESULT __stdcall VxdClose(void)
{
    ASSERT(g_hDsVxd);

    if(CloseHandle(g_hDsVxd))
    {
        g_hDsVxd = NULL;
    }

    return g_hDsVxd ? DSERR_GENERIC : DS_OK;
}


HRESULT __stdcall VxdInitialize(void)
{
   DWORD	returned;
   BOOL		fOK;
   HRESULT	dsv;

   ASSERT(g_hDsVxd);

   fOK = DeviceIoControl(g_hDsVxd,
			 DSVXD_IOCTL_INITIALIZE,
			 NULL,
			 0,
			 &dsv,
			 sizeof( dsv ),
			 &returned,
			 NULL);
   
   // If DeviceIOControl failed
   if (!fOK) {
      DPF(0, "!DSVXD Initialize DevIOCTL failed " );
      return DSERR_GENERIC;
   }
   if (returned != sizeof(dsv)) {
      DPF(0, "!DSVXD Init returned %X", returned );
      return DSERR_GENERIC;
   }

   return dsv;
}


HRESULT __stdcall VxdShutdown(void)
{
   DWORD	returned;
   BOOL		fOK;
   HRESULT	dsv;

   ASSERT(g_hDsVxd);

   // This is a check to confirm we did not leave any
   // memory pages reserved or committed
   if (0 != g_cCommittedAliases) {
       DPF(0, "Detected committed page leak %d pages!", g_cCommittedAliases);
   }
   if (0 != g_cReservedAliases) {
       DPF(0, "Detected reserved page leak %d pages!", g_cReservedAliases);
   }

   fOK = DeviceIoControl(g_hDsVxd,
			 DSVXD_IOCTL_SHUTDOWN,
			 NULL,
			 0,
			 &dsv,
			 sizeof( dsv ),
			 &returned,
			 NULL);
   
   // If DeviceIOControl failed
   if (!fOK) {
      DPF(0, "!DSVXD Shutdown DevIOCTL failed " );
      return DSERR_GENERIC;
   }
   if (returned != sizeof(dsv)) {
      DPF(0, "!DSVXD Shutdown returned %X", returned );
      return DSERR_GENERIC;
   }
   

   return dsv;
}


void __stdcall VxdGetPagefileVersion(PDWORD pVersion, PDWORD pMaxSize, PDWORD pPagerType)
{
    BOOL fOK;
    DWORD returned = 0;

    if (g_hDsVxd) {
	fOK = DeviceIoControl(g_hDsVxd,
			      DSVXD_IOCTL_PageFile_Get_Version,
			      &pVersion,
			      3*4,
			      NULL,
			      0,
			      &returned,
			      NULL);
    } else {
	fOK = FALSE;
    }

    // If DeviceIOControl failed
    if (!fOK) {
	DPF(0, "DSVXD_IOCTL_PageFile_Get_Version failed" );
	*pVersion = 0;
	*pMaxSize = 0;
	*pPagerType = 0;
    } else {
	ASSERT(returned == 0);
    }

    return;
}


BOOL __stdcall VxdTestDebugInstalled(void)
{
    BOOL fOK;
    DWORD returned = 0;
    BOOL fInstalled;

    if (g_hDsVxd) {
	fOK = DeviceIoControl(g_hDsVxd,
			      DSVXD_IOCTL_VMM_Test_Debug_Installed,
			      NULL,
			      0*4,
			      &fInstalled,
			      sizeof(fInstalled),
			      &returned,
			      NULL);
    } else {
	fOK = FALSE;
    }

    // If DeviceIOControl failed
    if (!fOK) {
	DPF(0, "DSVXD_IOCTL_VMM_Test_Debug_Installed failed " );
	fInstalled = FALSE;
    } else {
	ASSERT(returned == sizeof(fInstalled));
    }

    return fInstalled;
}

//****************************************************************************
//**                                                                        **
//** DSVXD_VMCPD_Get_Version						    **
//**                                                                        **
//****************************************************************************

void __stdcall VxdGetVmcpdVersion(PLONG pMajorVersion, PLONG pMinorVersion, PLONG pLevel)
{
    BOOL fOK;
    DWORD returned = 0;

    if (g_hDsVxd) {
	fOK = DeviceIoControl(g_hDsVxd,
			      DSVXD_IOCTL_VMCPD_Get_Version,
			      &pMajorVersion,
			      3*4,
			      NULL,
			      0,
			      &returned,
			      NULL);
    } else {
	fOK = FALSE;
    }

    // If DeviceIOControl failed
    if (!fOK) {
	DPF(0, "DSVXD_IOCTL_VMCPD_Get_Version failed" );
	*pMajorVersion = 0;
	*pMinorVersion = 0;
	*pLevel = 0;
    } else {
	ASSERT(returned == 0);
    }

    return;
}

//****************************************************************************
//**                                                                        **
//** DSVXD_GetMixerMutexPtr						    **
//**                                                                        **
//****************************************************************************

PLONG __stdcall VxdGetMixerMutexPtr(void)
{
    BOOL fOK;
    PLONG plMixerMutex;
    DWORD returned = 0;

    ASSERT(g_hDsVxd);

    fOK = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_GetMixerMutexPtr,
			  NULL,
			  0*4,
			  &plMixerMutex,
			  sizeof(plMixerMutex),
			  &returned,
			  NULL);

    // If DeviceIOControl failed
    if (!fOK) {
	DPF(0, "!DSVXD_IOCTL_SetMixerMutex failed " );
	plMixerMutex = NULL;
    } else {
	ASSERT(returned == sizeof(plMixerMutex));
    }

    return plMixerMutex;
}





HRESULT __stdcall VxdIUnknown_QueryInterface(HANDLE VxdIUnknown, REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdIUnknown && riid && ppv);
    
    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IUnknown_QueryInterface,
			  &VxdIUnknown,
			  3*4,
			  &hr,
			  sizeof(hr),
			  &cbReturned,
			  NULL);
    
    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(hr));
    return hr;
}

ULONG __stdcall VxdIUnknown_AddRef(HANDLE VxdIUnknown)
{
    ULONG result;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdIUnknown);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IUnknown_AddRef,
			  &VxdIUnknown,
			  1*4,
			  &result,
			  sizeof(result),
			  &cbReturned,
			  NULL);

    if (!fOk) return 0;
    ASSERT(cbReturned == sizeof(result));
    return result;
}

ULONG __stdcall VxdIUnknown_Release(HANDLE VxdIUnknown)
{
    ULONG result;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdIUnknown);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IUnknown_Release,
			  &VxdIUnknown,
			  1*4,
			  &result,
			  sizeof(result),
			  &cbReturned,
			  NULL);

    if (!fOk) return 0;
    ASSERT(cbReturned == sizeof(result));
    return result;
}

HRESULT __stdcall VxdIDsDriverPropertySet_GetProperty(HANDLE hIDsDriverPropertySet, PDSPROPERTY pProperty, PVOID pPropertyParams, ULONG cbPropertyParams, PVOID pPropertyData, ULONG cbPropertyData, PULONG pcbReturnedData)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hIDsDriverPropertySet);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IDirectSoundPropertySet_GetProperty,
			  &hIDsDriverPropertySet,
			  7*4,
			  &hr,
			  sizeof(hr),
			  &cbReturned,
			  NULL);

    if (!fOk) return E_NOTIMPL;
    ASSERT(cbReturned == sizeof(hr));
    return hr;
}

HRESULT __stdcall VxdIDsDriverPropertySet_SetProperty(HANDLE hIDsDriverPropertySet, PDSPROPERTY pProperty, PVOID pPropertyParams, ULONG cbPropertyParams, PVOID pPropertyData, ULONG cbPropertyData)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hIDsDriverPropertySet);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IDirectSoundPropertySet_SetProperty,
			  &hIDsDriverPropertySet,
			  6*4,
			  &hr,
			  sizeof(hr),
			  &cbReturned,
			  NULL);

    if (!fOk) return E_NOTIMPL;
    ASSERT(cbReturned == sizeof(hr));
    return hr;
}

HRESULT __stdcall VxdIDsDriverPropertySet_QuerySupport(HANDLE hIDsDriverPropertySet, REFGUID PropertySet, ULONG PropertyId, PULONG pSupport)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hIDsDriverPropertySet);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IDirectSoundPropertySet_QuerySupport,
			  &hIDsDriverPropertySet,
			  4*4,
			  &hr,
			  sizeof(hr),
			  &cbReturned,
			  NULL);

    if (!fOk) return E_NOTIMPL;
    ASSERT(cbReturned == sizeof(hr));
    return hr;
}

DWORD __stdcall VxdGetInternalVersionNumber(void)
{
    DWORD cbReturned;
    BOOL fOk;
    DWORD dwVersion;

    ASSERT(g_hDsVxd);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_GetInternalVersionNumber,
                          NULL,
                          0*4,
                          &dwVersion,
                          sizeof(dwVersion),
                          &cbReturned,
                          NULL);
    
    if(!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(dwVersion));
    return dwVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dxcrt.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxcrt.c
 *  Content:    Miscelaneous floating point calls
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/31/96    jstokes  Created
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <math.h>

#define LOGE_2_INV 1.44269504088896  // 1/log_e(2)

double _stdcall pow2(double x)
{
    double dvalue;
    
#ifdef USE_INLINE_ASM_UNUSED // Can only use if |x| <= 1!
    _asm
    {
        fld    x
        f2xm1
        fstp   dvalue
    }
#else
    dvalue = pow(2.0, x);
#endif

    return dvalue;
}

// fylog2x(y, x) = y * log2(x)

double _stdcall fylog2x(double y, double x)
{
    double dvalue;

#ifdef USE_INLINE_ASM
    _asm
    {
        fld    y
        fld    x
        fyl2x
        fstp   dvalue
    }
#else
    dvalue = LOGE_2_INV * y * log(x);
#endif

    return dvalue;
}

#ifdef DEAD_CODE

// fylog2xp1(y, x) = y * log2(x + 1)

double _stdcall fylog2xp1(double y, double x)
{
    double dvalue;

#ifdef USE_INLINE_ASM
    _asm
    {
        fld    y
        fld    x
        fyl2xp1
        fstp   dvalue
    }
#else
    dvalue = LOGE_2_INV * y * log(x+1.0);
#endif

    return dvalue;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsvalid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsvalid.h
 *  Content:    DirectSound parameter validation.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/20/97     dereks  Created
 *
 ***************************************************************************/

#ifndef __DSVALID_H__
#define __DSVALID_H__

// Validation macros
#define IsValidHandleValue(h)           ((h) && ((h) != INVALID_HANDLE_VALUE))

#if defined(DEBUG) || defined(RDEBUG)

#define IS_VALID_READ_PTR(a, b)         !IsBadReadPtr(a, b)
#define IS_VALID_WRITE_PTR(a, b)        !IsBadWritePtr(a, b)
#define IS_VALID_TYPED_READ_PTR(a)      IS_VALID_READ_PTR((a), sizeof *(a))
#define IS_VALID_TYPED_WRITE_PTR(a)     IS_VALID_WRITE_PTR((a), sizeof *(a))
#define IS_VALID_CODE_PTR(a)            !IsBadCodePtr((FARPROC)(a))
#define IS_VALID_HWND(a)                IsWindow(a)
#define IS_VALID_HANDLE(a)              IsValidHandle(a)
#define IS_VALID_READ_WAVEFORMATEX(a)   IsValidWfxPtr(a)

#ifdef __cplusplus

template <class type> BOOL IS_VALID_INTERFACE(type *pthis, DWORD sig)
{
    if(!IS_VALID_TYPED_WRITE_PTR(pthis))
    {
        DPF(DPFLVL_ERROR, "Can't write to interface pointer");
        return FALSE;
    }

    if(sig != (DWORD)pthis->m_signature)
    {
        DPF(DPFLVL_ERROR, "Interface signature mismatch.  %c%c%c%c != %c%c%c%c", (BYTE)(pthis->m_signature), (BYTE)(pthis->m_signature >> 8), (BYTE)(pthis->m_signature >> 16), (BYTE)(pthis->m_signature >> 24), (BYTE)(sig), (BYTE)(sig >> 8), (BYTE)(sig >> 16), (BYTE)(sig >> 24));
        return FALSE;
    }

    if(pthis->m_ulRefCount <= 0)
    {
        DPF(DPFLVL_ERROR, "Interface reference count <= 0");
        return FALSE;
    }

    if(pthis->m_ulRefCount >= MAX_ULONG)
    {
        DPF(DPFLVL_ERROR, "Interface reference count >= MAX_ULONG");
        return FALSE;
    }

    return TRUE;
}

#endif // __cplusplus

#else // defined(DEBUG) || defined(RDEBUG)

#define IS_VALID_READ_PTR(a, b)         ((a) || (!(b)))
#define IS_VALID_WRITE_PTR(a, b)        ((a) || (!(b)))
#define IS_VALID_TYPED_READ_PTR(a)      (a)
#define IS_VALID_TYPED_WRITE_PTR(a)     (a)
#define IS_VALID_CODE_PTR(a)            (a)
#define IS_VALID_HWND(a)                (a)
#define IS_VALID_HANDLE(a)              (a)
#define IS_VALID_READ_WAVEFORMATEX(a)   (a)

#ifdef __cplusplus
#define IS_VALID_INTERFACE(a, b)        ((a) && (b == (a)->m_signature))
#endif // __cplusplus

#endif // defined(DEBUG) || defined(RDEBUG)

// Validation (of sorts) for external COM interfaces
#ifdef __cplusplus
struct _GENERIC_COM_INTERFACE {FARPROC *(vptr[1]);};
#define IS_VALID_EXTERNAL_INTERFACE(ptr) \
    (IS_VALID_READ_PTR(ptr, sizeof(_GENERIC_COM_INTERFACE)) && \
     IS_VALID_READ_PTR(*reinterpret_cast<_GENERIC_COM_INTERFACE*>(ptr)->vptr, sizeof(FARPROC)) && \
     IS_VALID_CODE_PTR(*(reinterpret_cast<_GENERIC_COM_INTERFACE*>(ptr)->vptr)[0]))
#endif // __cplusplus

#define CHECK_READ_PTR(p)       ASSERT(IS_VALID_TYPED_READ_PTR(p))
#define CHECK_WRITE_PTR(p)      ASSERT(IS_VALID_TYPED_WRITE_PTR(p))
#define CHECK_COM_INTERFACE(p)  ASSERT(IS_VALID_EXTERNAL_INTERFACE(p))

#define IS_VALID_WRITE_WAVEFORMATEX(a) \
            IS_VALID_WRITE_PTR(a, sizeof(WAVEFORMATEX))

#define IS_VALID_READ_DSBUFFERDESC(a) \
            ((IS_VALID_READ_PTR(a, sizeof(((LPCDSBUFFERDESC)(a))->dwSize))) && \
            (IS_VALID_READ_PTR(a, ((LPCDSBUFFERDESC)(a))->dwSize)))

#define IS_VALID_WRITE_DSBUFFERDESC(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSBUFFERDESC)) && \
            sizeof(DSBUFFERDESC) == ((LPDSBUFFERDESC)(a))->dwSize)

#define IS_VALID_READ_DSCAPS(a) \
            (IS_VALID_READ_PTR(a, sizeof(DSCAPS)) && \
            sizeof(DSCAPS) == ((LPDSCAPS)(a))->dwSize)

#define IS_VALID_WRITE_DSCAPS(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSCAPS)) && \
            sizeof(DSCAPS) == ((LPDSCAPS)(a))->dwSize)

#define IS_VALID_READ_DSBCAPS(a) \
            (IS_VALID_READ_PTR(a, sizeof(DSBCAPS)) && \
            sizeof(DSBCAPS) == ((LPDSBCAPS)(a))->dwSize)

#define IS_VALID_WRITE_DSBCAPS(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSBCAPS)) && \
            sizeof(DSBCAPS) == ((LPDSBCAPS)(a))->dwSize)

#define IS_VALID_READ_DS3DBUFFER(a) \
            (IS_VALID_READ_PTR(a, sizeof(DS3DBUFFER)) && \
            sizeof(DS3DBUFFER) == ((LPDS3DBUFFER)(a))->dwSize)

#define IS_VALID_WRITE_DS3DBUFFER(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DS3DBUFFER)) && \
            sizeof(DS3DBUFFER) == ((LPDS3DBUFFER)(a))->dwSize)

#define IS_VALID_READ_DS3DLISTENER(a) \
            (IS_VALID_READ_PTR(a, sizeof(DS3DLISTENER)) && \
            sizeof(DS3DLISTENER) == ((LPDS3DLISTENER)(a))->dwSize)

#define IS_VALID_WRITE_DS3DLISTENER(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DS3DLISTENER)) && \
            sizeof(DS3DLISTENER) == ((LPDS3DLISTENER)(a))->dwSize)

#define IS_VALID_READ_GUID(a) \
            IS_VALID_READ_PTR(a, sizeof(GUID))

#define IS_VALID_WRITE_GUID(a) \
            IS_VALID_WRITE_PTR(a, sizeof(GUID))

#define IS_VALID_READ_DSCBUFFERDESC(a) \
            ((IS_VALID_READ_PTR(a, sizeof(((LPCDSCBUFFERDESC)(a))->dwSize))) && \
            (IS_VALID_READ_PTR(a, ((LPCDSCBUFFERDESC)(a))->dwSize)))

#define IS_VALID_WRITE_DSCBUFFERDESC(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSCBUFFERDESC)) && \
            sizeof(DSCBUFFERDESC) == ((LPDSCBUFFERDESC)(a))->dwSize)

#define IS_VALID_READ_DSCCAPS(a) \
            (IS_VALID_READ_PTR(a, sizeof(DSCCAPS)) && \
            sizeof(DSCCAPS) == ((LPDSCCAPS)(a))->dwSize)

#define IS_VALID_WRITE_DSCCAPS(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSCCAPS)) && \
            sizeof(DSCCAPS) == ((LPDSCCAPS)(a))->dwSize)

#define IS_VALID_READ_DSCBCAPS(a) \
            (IS_VALID_READ_PTR(a, sizeof(DSCBCAPS)) && \
            sizeof(DSCBCAPS) == ((LPDSCBCAPS)(a))->dwSize)

#define IS_VALID_WRITE_DSCBCAPS(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSCBCAPS)) && \
            sizeof(DSCBCAPS) == ((LPDSCBCAPS)(a))->dwSize)

#define IS_VALID_FLAGS(a, b) \
            (!((a) & ~(b)))

#define IS_NULL_GUID(a) \
            (!(a) || CompareMemory(a, &GUID_NULL, sizeof(GUID)))

#define IS_VALID_DS3DLISTENER_DISTANCE_FACTOR(a) \
            (!((a) < DS3D_MINDISTANCEFACTOR || (a) > DS3D_MAXDISTANCEFACTOR))

#define IS_VALID_DS3DLISTENER_DOPPLER_FACTOR(a) \
            (!((a) < DS3D_MINDOPPLERFACTOR || (a) > DS3D_MAXDOPPLERFACTOR))

#define IS_VALID_DS3DLISTENER_ROLLOFF_FACTOR(a) \
            (!((a) < DS3D_MINROLLOFFFACTOR || (a) > DS3D_MAXROLLOFFFACTOR))

#define IS_VALID_DS3DBUFFER_CONE_OUTSIDE_VOLUME(a) \
            (!((a) < DSBVOLUME_MIN || (a) > DSBVOLUME_MAX))

#define IS_VALID_DS3DBUFFER_MAX_DISTANCE(a) \
            ((a) > 0.0f)

#define IS_VALID_DS3DBUFFER_MIN_DISTANCE(a) \
            ((a) > 0.0f)

#define IS_VALID_DS3DBUFFER_MODE(a) \
            (!((a) < DS3DMODE_FIRST || (a) > DS3DMODE_LAST))

#define IS_VALID_DSFULLDUPLEX_MODE(a) \
            (!((a) < DSFULLDUPLEXMODE_FIRST || (a) > DSFULLDUPLEXMODE_LAST))

#ifdef __cplusplus

#define IS_VALID_IUNKNOWN(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IUNKNOWN)

#define IS_VALID_IDIRECTSOUND(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUND)

#define IS_VALID_IDIRECTSOUNDBUFFER(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDBUFFER)

#define IS_VALID_IDIRECTSOUND3DBUFFER(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUND3DBUFFER)

#define IS_VALID_IDIRECTSOUND3DLISTENER(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUND3DLISTENER)

#define IS_VALID_ICLASSFACTORY(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_ICLASSFACTORY)

#define IS_VALID_IDIRECTSOUNDNOTIFY(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDNOTIFY)

#define IS_VALID_IKSPROPERTYSET(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IKSPROPERTYSET)

#define IS_VALID_IDIRECTSOUNDCAPTURE(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDCAPTURE)

#define IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDCAPTUREBUFFER)

#define IS_VALID_IDIRECTSOUNDSINK(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDSINK)

#define IS_VALID_IPERSIST(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IPERSIST)

#define IS_VALID_IPERSISTSTREAM(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IPERSISTSTREAM)

#define IS_VALID_IDIRECTMUSICOBJECT(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTMUSICOBJECT)

#define IS_VALID_IDIRECTSOUNDFULLDUPLEX(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDFULLDUPLEX)

#endif // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// DSBUFFERDESC versions
typedef enum
{
    DSVERSION_INITIAL = 0x0000,
    DSVERSION_DX7     = 0x0700,
    DSVERSION_DX7_1   = 0x0701,
    DSVERSION_DX8     = 0x0800,
} DSVERSION, *LPDSVERSION;

#define DSVERSION_CURRENT DIRECTSOUND_VERSION  // From dsound.h

extern HRESULT IsValidDsBufferDesc(DSVERSION, LPCDSBUFFERDESC, BOOL);
extern HRESULT IsValidDscBufferDesc(DSVERSION, LPCDSCBUFFERDESC);
extern BOOL IsValidDsBufferFlags(DWORD, DWORD);
extern BOOL IsValidWfxPtr(LPCWAVEFORMATEX);
extern BOOL IsValidWfx(LPCWAVEFORMATEX);
extern BOOL IsValidPcmWfx(LPCWAVEFORMATEX);
extern BOOL IsValidExtensibleWfx(PWAVEFORMATEXTENSIBLE);
extern BOOL IsValidHandle(HANDLE);
extern BOOL IsValidPropertySetId(REFGUID);
extern HRESULT ValidateNotificationPositions(DWORD, DWORD, LPCDSBPOSITIONNOTIFY, UINT, LPDSBPOSITIONNOTIFY *);
extern BOOL IsValidDs3dBufferConeAngles(DWORD, DWORD);
extern BOOL IsValidWaveDevice(UINT, BOOL, LPCVOID);
extern BOOL IsValid3dAlgorithm(REFGUID);
extern BOOL IsValidFxFlags(DWORD);
extern BOOL IsValidCaptureFxFlags(DWORD);
extern BOOL IsValidCaptureEffectDesc(LPCDSCEFFECTDESC pCaptureEffectDesc);
extern HRESULT BuildValidDsBufferDesc(LPCDSBUFFERDESC, LPDSBUFFERDESC, DSVERSION, BOOL);
extern HRESULT BuildValidDscBufferDesc(LPCDSCBUFFERDESC, LPDSCBUFFERDESC, DSVERSION);
extern LPCGUID BuildValidGuid(LPCGUID, LPGUID);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSVALID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dssink.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dssink.h
 *  Content:    DirectSoundSink object declaration.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/17/99    jimge   Created
 *  09/27/99    petchey Continued implementation
 *  04/15/00    duganp  Completed implementation
 *
 ***************************************************************************/

#ifndef __DSSINK_H__
#define __DSSINK_H__

#ifdef DEBUG
// #define DEBUG_SINK
// DEBUG_SINK turns on a series of trace statements that are useful
// for figuring out nasty bugs with multiple buffers and buses.
// CAUTION - this code may need some fixing to work right.
#endif

#define DSSINK_NULLBUSID        0xFFFFFFFF  // [MISSING]
#define BUSID_BLOCK_SIZE        16          // Must be power of 2
#define SOURCES_BLOCK_SIZE      8           // Must be power of 2
#define MAX_BUSIDS_PER_BUFFER   32          // [MISSING]

// Note: these "configuration values" should probably all be in one file.
#define STREAMING_MIN_PERIOD    3
#define STREAMING_MAX_PERIOD    50
#define SINK_MIN_LATENCY        5
#define SINK_MAX_LATENCY        500
#define SINK_INITIAL_LATENCY    80          // Initial writeahead for the sink in ms
#define EMULATION_LATENCY_BOOST 100         // How many ms to add if under emulation. FIXME: should fix our internal GetPosition instead

// Note: when the timing algorithms for effects and the sink are integrated,
// SINK_INITIAL_LATENCY and INITIAL_WRITEAHEAD should be integrated too.

typedef LONGLONG STIME;  // Time value, in samples

#ifdef __cplusplus

//
// CDirectSoundSink
//

class CDirectSoundSink : public CUnknown
{
    friend class CDirectSoundAdministrator;
    friend class CDirectSoundClock;
    friend class CImpSinkKsControl;  // Our property handler object

    class DSSinkBuffers
    {
    public:
        CDirectSoundSecondaryBuffer *m_pDSBuffer;
        BOOL    m_bActive;
        BOOL    m_bPlaying;
        BOOL    m_bUsingLocalMemory;
        DWORD   m_dwBusCount;
        DWORD   m_dwWriteOffset;
        DWORD   m_pdwBusIndex[MAX_BUSIDS_PER_BUFFER];
        DWORD   m_pdwBusIds[MAX_BUSIDS_PER_BUFFER];
        DWORD   m_pdwFuncIds[MAX_BUSIDS_PER_BUFFER];
        LONG    m_lPitchBend;  // Used to keep track of pitch shift to send to synth
        LPVOID  m_pvBussStart[MAX_BUSIDS_PER_BUFFER];
        LPVOID  m_pvBussEnd[MAX_BUSIDS_PER_BUFFER];
        LPVOID  m_pvDSBufStart;
        LPVOID  m_pvDSBufEnd;
        DWORD   dwStart;
        DWORD   dwEnd;
        DSSinkBuffers()
        {
            for (DWORD l = 0; l < MAX_BUSIDS_PER_BUFFER; l++)
            {
                m_pdwBusIndex[l] = DSSINK_NULLBUSID;
                m_pdwBusIds[l]   = DSSINK_NULLBUSID;
                m_pdwFuncIds[l]  = DSSINK_NULLBUSID;
                m_pvBussStart[l] = NULL;
                m_pvBussEnd[l]   = NULL;
            }
        };
        HRESULT Initialize(DWORD dwBusBufferSize);
    };

    class DSSinkSources
    {
    public:
        DWORD               m_bStreamEnd;   // The end of the stream has been rearched on this stream
        IDirectSoundSource *m_pDSSource;    // External source
#ifdef FUTURE_WAVE_SUPPORT
        IDirectSoundWave   *m_pWave;        // Wave object associated with this source, note: this is only used to id the wave
#endif
        STIME               m_stStartTime;  // Sample time to play source, this is used to offset a wave source into the current synth time
        DWORD               m_dwBusID;      // BusID associated with this source
        DWORD               m_dwBusCount;   // how many buses are associated with this source
        DWORD               m_dwBusIndex;   // Index in to the BusID's array associated with this source
        DSSinkSources() {m_dwBusID = m_dwBusIndex = DSSINK_NULLBUSID;}  // The rest is initialized to 0 by our MemAlloc
    };

    // "Growable array" helper classes: DSSinkArray, DSSinkBuffersArray, DSSinkSourceArray
    
    struct DSSinkArray
    {
        DSSinkArray(LPVOID pvarray, DWORD itemsize)
        {
            m_pvarray  = pvarray;
            m_itemsize = itemsize;
        };
        virtual LPVOID Grow(DWORD newsize);

    protected:
        LPVOID m_pvarray;
        DWORD  m_numitems;
        DWORD  m_itemsize;
    };

    struct DSSinkBuffersArray : DSSinkArray
    {
        DSSinkBuffersArray(LPVOID pvarray, DWORD itemsize) : DSSinkArray(pvarray, itemsize)
        {
            m_pvarray  = pvarray;
            m_itemsize = itemsize;
        };
        virtual PVOID Grow(DWORD newsize);
    };

    struct DSSinkSourceArray : DSSinkArray
    {
        DSSinkSourceArray(LPVOID pvarray, DWORD itemsize) : DSSinkArray(pvarray, itemsize)
        {
            m_pvarray  = pvarray;
            m_itemsize = itemsize;
        };
        virtual PVOID Grow(DWORD newsize);
    };

    enum
    {
        i_m_pdwBusIDs,
        i_m_pdwFuncIDs,
        i_m_plPitchBends,
        i_m_pdwActiveBusIDs,
        i_m_pdwActiveFuncIDs,
        i_m_pdwActiveBusIDsMap,
        i_m_ppDSSBuffers,
        i_m_ppvStart,
        i_m_ppvEnd,
        i_m_pDSSources,
        NUM_INTERNAL_ARRAYS
    };

    DSSinkArray* m_InternalArrayList[NUM_INTERNAL_ARRAYS];
    HRESULT GrowBusArrays(DWORD dwnewsize);
    HRESULT GrowSourcesArrays(DWORD dwnewsize);
    HRESULT AddBuffer(CDirectSoundBuffer *pIDirectSoundBuffer, LPDWORD pdwnewFuncIDs, DWORD dwnewFuncCount, DWORD dwnewBusIDsCount);
public:
    HRESULT RemoveBuffer(CDirectSoundBuffer *pIDirectSoundBuffer);  // Exposed for CDirectSoundSecondaryBuffer
private:
    HRESULT HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandlePeriod(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    void UpdatePitchArray();

    WAVEFORMATEX            m_wfx;              // Wave format of all our buffers
    DWORD                   m_dwBusSize;        // Size in ms of all our buffers
    IReferenceClock        *m_pIMasterClock;    // Master clock set by our user
    CDirectSoundClock       m_LatencyClock;     // Latency clock we provide to our user
    IDirectSoundSinkSync   *m_pDSSSinkSync;     // Interface we obtain from m_pIMasterClock and use to set clock offsets
    CSampleClock            m_SampleClock;      // Used to synchronize timing with master clock
    DWORD                   m_dwLatency;        // Current latency setting
    BOOL                    m_fActive;          // Whether sink is active
    REFERENCE_TIME          m_rtSavedTime;      // Reftime for current processing pass
    DWORD                   m_dwNextBusID;      // What is the current bus id value
    DWORD                   m_dwBusIDsAlloc;    // Number of allocated bus slots
    DWORD                   m_dwBusIDs;         // Number of active buses
    LPDWORD                 m_pdwBusIDs;        // Bus IDs
    LPDWORD                 m_pdwFuncIDs;       // Function IDs
    LPLONG                  m_plPitchBends;     // Pitch offsets
    LPVOID                 *m_ppvStart;         // Locked region[0] during render
    LPVOID                 *m_ppvEnd;           // Locked region[1] during render
    LPDWORD                 m_pdwActiveBusIDs;  // [MISSING]
    LPDWORD                 m_pdwActiveFuncIDs; // [MISSING]
    LPDWORD                 m_pdwActiveBusIDsMap;// [MISSING]
    DWORD                   m_dwLatencyTotal;   // [MISSING]
    DWORD                   m_dwLatencyCount;   // [MISSING]
    DWORD                   m_dwLatencyAverage; // [MISSING]
    DWORD                   m_dwDSSBufCount;    // Number of dsound buffers managed by the sink
    DSSinkBuffers          *m_ppDSSBuffers;     // Dsound buffers managed by the sink
    DWORD                   m_dwDSSourcesAlloc; // Number of allocated source slots
    DWORD                   m_dwDSSources;      // Number of active sources
    DSSinkSources          *m_pDSSources;       // External source

#ifdef DEBUG_SINK
    DWORD m_dwPrintNow;
    char m_szDbgDump[300];
#endif

    CStreamingThread       *m_pStreamingThread; // Our managing streaming thread
    CDirectSound           *m_pDirectSound;     // Parent DirectSound object
    CImpSinkKsControl      *m_pImpKsControl;    // IKsControl interface handler
    CImpDirectSoundSink<CDirectSoundSink> *m_pImpDirectSoundSink;  // Other COM interfaces handler

    LONGLONG                m_llAbsWrite;       // Absolute point we've written up to
    LONGLONG                m_llAbsPlay;        // Absolute point where play head is
    DWORD                   m_dwLastPlay;       // Point in buffer where play head is
    DWORD                   m_dwLastWrite;      // Last position we wrote to in buffer
    DWORD                   m_dwWriteTo;        // Distance between write head and where we are writing.
    DWORD                   m_dwLastCursorDelta;// The last used distance between the play and write cursors
    DWORD                   m_dwMasterBuffChannels; // Number of channels of the Master Buffer
    DWORD                   m_dwMasterBuffSize; // Size of the Master buffer

    // Conversion helpers - ALL THESE ASSUME A 16-BIT WAVE FORMAT
    LONGLONG SampleToByte(LONGLONG llSamples) {return llSamples << m_dwMasterBuffChannels;}
    DWORD SampleToByte(DWORD dwSamples)       {return dwSamples << m_dwMasterBuffChannels;}
    LONGLONG ByteToSample(LONGLONG llBytes)   {return llBytes   >> m_dwMasterBuffChannels;}
    DWORD ByteToSample(DWORD dwBytes)         {return dwBytes   >> m_dwMasterBuffChannels;}
    LONGLONG SampleAlign(LONGLONG llBytes)    {return SampleToByte(ByteToSample(llBytes));}
    DWORD SampleAlign(DWORD dwBytes)          {return SampleToByte(ByteToSample(dwBytes));}

public:
    CDirectSoundSink(CDirectSound *);
    ~CDirectSoundSink();

    HRESULT Render(STIME stStartTime, DWORD dwLastWrite, DWORD dwBytesToFill, LPDWORD pdwBytesRendered);
    HRESULT RenderSilence(DWORD dwLastWrite, DWORD dwBytesToFill);
    HRESULT SyncSink(LPDWORD pdwPlayCursor, LPDWORD pdwWriteFromCursor, LPDWORD pdwCursorDelta);
    HRESULT ProcessSink();
    HRESULT SetBufferState(CDirectSoundBuffer *pCdsb, DWORD dwNewState, DWORD dwOldState);
    HRESULT Initialize(LPWAVEFORMATEX pwfex, VADDEVICETYPE vdtDeviceType);
    HRESULT AddSource(IDirectSoundSource *pSource);
    HRESULT RemoveSource(IDirectSoundSource *pSource);
    HRESULT SetMasterClock(IReferenceClock *pClock);
    HRESULT GetLatencyClock(IReferenceClock **ppClock);
    HRESULT Activate(BOOL fEnable);
    HRESULT SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prt);
    HRESULT RefToSampleTime(REFERENCE_TIME rt, LONGLONG *pllSampleTime);
    HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD);
    HRESULT CreateSoundBuffer(LPCDSBUFFERDESC pDSBufferDesc, LPDWORD pdwBusIDs, DWORD dwBusCount, REFGUID guidBufferID, CDirectSoundBuffer **ppIDirectSoundBuffer);
    HRESULT CreateSoundBufferFromConfig(IUnknown *pIUnkDSBufferDesc, CDirectSoundBuffer **ppIDirectSoundBuffer);
    HRESULT GetBusCount(LPDWORD pdwCount);
    HRESULT GetSoundBuffer(DWORD dwBusId, CDirectSoundBuffer **ppCdsb);
    HRESULT GetBusIDs(LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount);
    HRESULT GetSoundBufferBusIDs(CDirectSoundBuffer *ppIDirectSoundBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount);
    HRESULT GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID);
    HRESULT SetBufferFrequency(CSecondaryRenderWaveBuffer *pBuffer, DWORD dwFrequency);
#ifdef FUTURE_WAVE_SUPPORT
    HRESULT CreateSoundBufferFromWave(IDirectSoundWave *pWave, DWORD dwFlags, CDirectSoundBuffer **ppIdsb);
#endif
    CDirectSoundSecondaryBuffer* FindBufferFromGUID(REFGUID guidBufferID);
    REFERENCE_TIME GetSavedTime() {ASSERT(m_rtSavedTime); return m_rtSavedTime;}
};

//
// CImpSinkKsControl: CDirectSoundSink's property handler object
//

#define SINKPROP_F_STATIC       0x00000001
#define SINKPROP_F_FNHANDLER    0x00000002

typedef HRESULT (CImpSinkKsControl::*SINKPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pvPropertyData, PULONG pcbPropertyData);

struct SINKPROPERTY
{
    const GUID *pguidPropertySet;       // Which property set?
    ULONG       ulId;                   // Which property?
    ULONG       ulSupported;            // Get/Set flags for QuerySupported
    ULONG       ulFlags;                // SINKPROP_F_xxx
    LPVOID      pPropertyData;          // The property data buffer...
    ULONG       cbPropertyData;         // ...and its size
    SINKPROPHANDLER pfnHandler;         // Handler function if SINKPROP_F_FNHANDLER
};

class CImpSinkKsControl : public IKsControl, public CImpUnknown
{
public:
    CImpSinkKsControl(CUnknown *, CDirectSoundSink*);

private:
    HRESULT HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandlePeriod(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    CDirectSoundSink *m_pDSSink;

    SINKPROPERTY m_aProperty[2];
    int m_nProperty;
    SINKPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);

public:
    IMPLEMENT_IUNKNOWN();

// IKsControl methods
public:
    virtual STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
};

#endif // __cplusplus

#endif // __DSSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dynaload.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dynaload.c
 *  Content:    Dynaload DLL helper functions
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/16/97    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  InitDynaLoadTable
 *
 *  Description:
 *      Dynamically loads a DLL and initializes it's function table.
 *
 *  Arguments:
 *      LPTSTR [in]: library path.
 *      LPTSTR * [in]: function name array.
 *      DWORD [in]: number of elements in function name array.
 *      LPDYNALOAD [out]: receives initialized dynaload structure.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "InitDynaLoadTable"

BOOL InitDynaLoadTable(LPCTSTR pszLibrary, const LPCSTR *apszFunctions, DWORD cFunctions, LPDYNALOAD pDynaLoad)
{
    BOOL                    fSuccess    = TRUE;
    DWORD                   dwFunction;
    FARPROC *               apfn;
    
    DPF_ENTER();

    ASSERT(sizeof(*pDynaLoad) + (cFunctions * sizeof(FARPROC)) == pDynaLoad->dwSize);
    
    // Initialize the structure
    ZeroMemoryOffset(pDynaLoad, pDynaLoad->dwSize, sizeof(pDynaLoad->dwSize));
 
    // Load the library
    pDynaLoad->hInstance = LoadLibrary(pszLibrary);

    if(!pDynaLoad->hInstance)
    {
        DPF(DPFLVL_ERROR, "Unable to load %s", pszLibrary);
        fSuccess = FALSE;
    }

    // Start loading functions
    for(apfn = (FARPROC *)(pDynaLoad + 1), dwFunction = 0; fSuccess && dwFunction < cFunctions; dwFunction++)
    {
        apfn[dwFunction] = GetProcAddress(pDynaLoad->hInstance, apszFunctions[dwFunction]);

        if(!apfn[dwFunction])
        {
            DPF(DPFLVL_ERROR, "Unable to find %s", apszFunctions[dwFunction]);
            fSuccess = FALSE;
        }
    }

    // Clean up
    if(!fSuccess)
    {
        FreeDynaLoadTable(pDynaLoad);
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/***************************************************************************
 *
 *  IsDynaLoadTableInit
 *
 *  Description:
 *      Determines if a dyna-load table is initialized.
 *
 *  Arguments:
 *      LPDYNALOAD [out]: receives initialized dynaload structure.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsDynaLoadTableInit"

BOOL IsDynaLoadTableInit(LPDYNALOAD pDynaLoad)
{
    BOOL                    fSuccess    = TRUE;
    LPDWORD                 pdw;

    DPF_ENTER();

    for(pdw = (LPDWORD)pDynaLoad + 1; pdw < (LPDWORD)pDynaLoad + (pDynaLoad->dwSize / sizeof(DWORD)); pdw++)
    {
        if(!*pdw)
        {
            fSuccess = FALSE;
        }
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/***************************************************************************
 *
 *  FreeDynaLoadTable
 *
 *  Description:
 *      Frees resources associated with a dynaload table.
 *
 *  Arguments:
 *      LPDYNALOAD [in]: initialized dynaload structure.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FreeDynaLoadTable"

void FreeDynaLoadTable(LPDYNALOAD pDynaLoad)
{
    DPF_ENTER();

    // Free the library
    if(pDynaLoad->hInstance)
    {
        FreeLibrary(pDynaLoad->hInstance);
    }

    // Uninitialize the structure
    ZeroMemoryOffset(pDynaLoad, pDynaLoad->dwSize, sizeof(pDynaLoad->dwSize));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetProcAddressEx
 *
 *  Description:
 *      Gets a pointer to a function within a given library.
 *
 *  Arguments:
 *      HINSTANCE [in]: library instance handle.
 *      LPTSTR [in]: function name.
 *      FARPROC * [out]: receives function pointer.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetProcAddressEx"

BOOL GetProcAddressEx(HINSTANCE hInstance, LPCSTR pszFunction, FARPROC *ppfnFunction)
{
    DPF_ENTER();

    *ppfnFunction = GetProcAddress(hInstance, pszFunction);
    
    DPF_LEAVE(MAKEBOOL(*ppfnFunction));

    return MAKEBOOL(*ppfnFunction);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dynaload.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dynaload.h
 *  Content:    Dynaload DLL helper functions
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/16/97    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DYNALOAD_H__
#define __DYNALOAD_H__

#ifdef UNICODE
#define UNICODE_FUNCTION_NAME(str) str##"W"
#else // UNICODE
#define UNICODE_FUNCTION_NAME(str) str##"A"
#endif // UNICODE

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Generic DYNALOAD data
typedef struct tagDYNALOAD
{
    DWORD           dwSize;
    HINSTANCE       hInstance;
} DYNALOAD, *LPDYNALOAD;

// DYNALOAD helper functions
extern BOOL InitDynaLoadTable(LPCTSTR, const LPCSTR *, DWORD, LPDYNALOAD);
extern BOOL IsDynaLoadTableInit(LPDYNALOAD);
extern void FreeDynaLoadTable(LPDYNALOAD);
extern BOOL GetProcAddressEx(HINSTANCE, LPCSTR, FARPROC *);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DYNALOAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\effects.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        effects.cpp
 *
 *  Content:     Implementation of the CEffectChain class and the CEffect
 *               class hierarchy (CEffect, CDmoEffect and CSendEffect).
 *
 *  Description: These classes support audio effects and effect sends, a new
 *               feature in DX8.  The CDirectSoundSecondaryBuffer object is
 *               extended with a pointer to an associated CEffectChain,
 *               which in turn manages a list of CEffect-derived objects.
 *
 *               Almost everything here would fit more logically into the
 *               existing CDirectSoundSecondaryBuffer class, but has been
 *               segregated for ease of maintenance (and because dsbuf.cpp
 *               is complex enough as it is).  So the CEffectChain object
 *               should be understood as a sort of helper object belonging to
 *               CDirectSoundSecondaryBuffer.  In particular, a CEffectChain
 *               object's lifetime is contained by the lifetime of its owning
 *               CDirectSoundSecondaryBuffer, so we can safely fiddle with
 *               this buffer's innards at any time in CEffectChain code.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 08/10/99  duganp   Created
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <uuids.h>   // For MEDIATYPE_Audio, MEDIASUBTYPE_PCM and FORMAT_WaveFormatEx


/***************************************************************************
 *
 *  CEffectChain::CEffectChain
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Pointer to our associated buffer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::CEffectChain"

CEffectChain::CEffectChain(CDirectSoundSecondaryBuffer* pBuffer)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEffectChain);

    // Set up initial values
    m_hrInit        = DSERR_UNINITIALIZED;
    m_pDsBuffer     = pBuffer;
    m_pPreFxBuffer  = pBuffer->GetPreFxBuffer();
    m_pPostFxBuffer = pBuffer->GetPostFxBuffer();
    m_dwBufSize     = pBuffer->GetBufferSize();

    // Keep a pointer to the audio format for convenience
    m_pFormat = pBuffer->Format();

    // Some sanity checking
    ASSERT(m_dwBufSize % m_pFormat->nBlockAlign == 0);
    ASSERT(IS_VALID_WRITE_PTR(m_pPreFxBuffer, m_dwBufSize));
    ASSERT(IS_VALID_WRITE_PTR(m_pPostFxBuffer, m_dwBufSize));

    m_fHasSend = FALSE;

    DPF(DPFLVL_INFO, "Created effect chain with PreFxBuffer=0x%p, PostFxBuffer=0x%p, BufSize=%lu",
        m_pPreFxBuffer, m_pPostFxBuffer, m_dwBufSize);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffectChain::~CEffectChain
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::~CEffectChain"

CEffectChain::~CEffectChain(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CEffectChain);

    if (SUCCEEDED(m_hrInit))
        m_pStreamingThread->UnregisterFxChain(this);

    // m_fxList's destructor takes care of releasing our CEffect objects

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffectChain::Initialize
 *
 *  Description:
 *      Initializes the chain with the effects requested.
 *
 *  Arguments:
 *      DWORD [in]: Number of effects requested
 *      LPDSEFFECTDESC [in]: Pointer to effect description structures
 *      DWORD* [out]: Receives the effect creation status codes
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::Initialize"

HRESULT CEffectChain::Initialize(DWORD dwFxCount, LPDSEFFECTDESC pFxDesc, LPDWORD pdwResultCodes)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();
    HRESULT hrFirstFailure = DS_OK; // HR for the first FX creation failure

    ASSERT(dwFxCount > 0);
    CHECK_READ_PTR(pFxDesc);

    DMO_MEDIA_TYPE dmt;
    ZeroMemory(&dmt, sizeof dmt);
    dmt.majortype               = MEDIATYPE_Audio;
    dmt.subtype                 = MEDIASUBTYPE_PCM;
    dmt.bFixedSizeSamples       = TRUE;
    dmt.bTemporalCompression    = FALSE;
    dmt.lSampleSize             = m_pFormat->wBitsPerSample == 16 ? 2 : 1;
    dmt.formattype              = FORMAT_WaveFormatEx;
    dmt.cbFormat                = sizeof(WAVEFORMATEX);
    dmt.pbFormat                = PBYTE(m_pFormat);

    for (DWORD i=0; i<dwFxCount; ++i)
    {
        CEffect* pEffect;
        BOOL fIsSend;

        if (pFxDesc[i].guidDSFXClass == GUID_DSFX_SEND /*|| pFxDesc[i].guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE*/)
        {
            fIsSend = TRUE;
#ifdef ENABLE_SENDS
            pEffect = NEW(CSendEffect(pFxDesc[i], m_pDsBuffer));
#endif
        }
        else
        {
            fIsSend = FALSE;
            pEffect = NEW(CDmoEffect(pFxDesc[i]));
        }

#ifndef ENABLE_SENDS
        if (fIsSend)
            hr = DSERR_INVALIDPARAM;
        else
#endif
        hr = HRFROMP(pEffect);

        if (SUCCEEDED(hr))
            hr = pEffect->Initialize(&dmt);

        if (SUCCEEDED(hr))
            hr = HRFROMP(m_fxList.AddNodeToList(pEffect));

        if (SUCCEEDED(hr))
        {
            m_fHasSend = m_fHasSend || fIsSend;
            if (pdwResultCodes)
                pdwResultCodes[i] = DSFXR_PRESENT;
        }
        else // We didn't get the effect for some reason.
        {
            if (pdwResultCodes)
                pdwResultCodes[i] = (hr == DSERR_SENDLOOP) ? DSFXR_SENDLOOP : DSFXR_UNKNOWN;
            if (SUCCEEDED(hrFirstFailure))
                hrFirstFailure = hr;
        }

        RELEASE(pEffect);  // It's managed by m_fxList now
    }

    hr = hrFirstFailure;

    if (SUCCEEDED(hr))
        hr = HRFROMP(m_pStreamingThread = GetStreamingThread());

    if (SUCCEEDED(hr))
    {
        m_dwWriteAheadFixme = m_pStreamingThread->GetWriteAhead();
        if (m_pDsBuffer->IsEmulated())
            m_dwWriteAheadFixme += EMULATION_LATENCY_BOOST;
    }

    if (SUCCEEDED(hr))
        hr = PreRollFx();

    if (SUCCEEDED(hr))
        hr = m_pStreamingThread->RegisterFxChain(this);

    // Temporary hack until DX8.1 - FIXME:
    //
    // Get the sink's current WriteAhead value and boost it if we're
    // running in emulation.  This should be handled in the emulator's
    // GetPosition method itself rather than in dssink.cpp/effects.cpp
    //
    // This only works now because the sink doesn't ever change the
    // value returned by GetWriteAhead() - this too will change.

    m_hrInit = hr;
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::Clone
 *
 *  Description:
 *      Creates a replica of this effect chain object (or should do!).
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::Clone"

HRESULT CEffectChain::Clone(CDirectSoundBufferConfig* pDSBConfigObj)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    CHECK_WRITE_PTR(pDSBConfigObj);

    DMO_MEDIA_TYPE dmt;
    ZeroMemory(&dmt, sizeof dmt);
    dmt.majortype               = MEDIATYPE_Audio;
    dmt.subtype                 = MEDIASUBTYPE_PCM;
    dmt.bFixedSizeSamples       = TRUE;
    dmt.bTemporalCompression    = FALSE;
    dmt.lSampleSize             = m_pFormat->wBitsPerSample == 16 ? 2 : 1;
    dmt.formattype              = FORMAT_WaveFormatEx;
    dmt.cbFormat                = sizeof(WAVEFORMATEX);
    dmt.pbFormat                = PBYTE(m_pFormat);

    CDirectSoundBufferConfig::CDXDMODesc *pDXDMOMap = pDSBConfigObj->m_pDXDMOMapList;
    for (; pDXDMOMap && SUCCEEDED(hr); pDXDMOMap = pDXDMOMap->pNext)
    {
        DSEFFECTDESC effectDesc;
        effectDesc.dwSize = sizeof effectDesc;
        effectDesc.dwFlags = pDXDMOMap->m_dwEffectFlags;
        effectDesc.guidDSFXClass = pDXDMOMap->m_guidDSFXClass;
        effectDesc.dwReserved2 = pDXDMOMap->m_dwReserved;
        effectDesc.dwReserved1 = NULL;

        CEffect* pEffect = NULL;

        // If this is a send effect, map the send buffer GUID to an actual buffer interface pointer
        if (pDXDMOMap->m_guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
            || pDXDMOMap->m_guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
            )
        {
            CDirectSoundSecondaryBuffer* pSendBuffer = m_pDsBuffer->m_pOwningSink->FindBufferFromGUID(pDXDMOMap->m_guidSendBuffer);
            if (pSendBuffer)
            {
                effectDesc.dwReserved1 = DWORD_PTR(pSendBuffer->m_pImpDirectSoundBuffer);
                if(IsValidEffectDesc(&effectDesc, m_pDsBuffer))
                {
                    CSendEffect* pSendEffect;
                    pSendEffect = NEW(CSendEffect(effectDesc, m_pDsBuffer));
                    pEffect = pSendEffect;
                    hr = HRFROMP(pEffect);
                    if (SUCCEEDED(hr))
                        hr = pEffect->Initialize(&dmt);
                    if (SUCCEEDED(hr))
                    {
                        DSFXSend SendParam;
                        SendParam.lSendLevel = pDXDMOMap->m_lSendLevel;
                        hr = pSendEffect->SetAllParameters(&SendParam);
                    }
                }
                else
                {
                    hr = DSERR_INVALIDPARAM;
                }
            }
            else
            {
                hr = DSERR_BADSENDBUFFERGUID;
            }
        }
        else
        {
            pEffect = NEW(CDmoEffect(effectDesc));
            hr = HRFROMP(pEffect);
            // FIXME: Do we need to validate pEffect as well?
            if (SUCCEEDED(hr))
                hr = pEffect->Clone(pDXDMOMap->m_pMediaObject, &dmt);
        }

        if (SUCCEEDED(hr))
            hr = HRFROMP(m_fxList.AddNodeToList(pEffect));

        if (SUCCEEDED(hr))
        {
            if (pDXDMOMap->m_guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
                || pDXDMOMap->m_guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
                )
                m_fHasSend = TRUE;
        }

        RELEASE(pEffect);  // It's managed by m_fxList now
    }

    if (SUCCEEDED(hr))
        hr = HRFROMP(m_pStreamingThread = GetStreamingThread());

    // Temp hack - see comment above
    if (SUCCEEDED(hr))
        m_dwWriteAheadFixme = m_pStreamingThread->GetWriteAhead();

    if (SUCCEEDED(hr))
        hr = PreRollFx();

    if (SUCCEEDED(hr))
        hr = m_pStreamingThread->RegisterFxChain(this);

    m_hrInit = hr;
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::AcquireFxResources
 *
 *  Description:
 *      Allocates each effect to software (host processing) or hardware
 *      (processed by the audio device), according to its creation flags.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *               Will return the partial success code DS_INCOMPLETE if any
 *               effects that didn't obtain resources were marked OPTIONAL.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::AcquireFxResources"

HRESULT CEffectChain::AcquireFxResources(void)
{
    HRESULT hr = DS_OK;
    HRESULT hrTemp;
    DPF_ENTER();

    // FIXME: Don't reacquire resources unnecessarily; only if (we have none / they're suboptimal?)

    // We loop through all the effects, even if some of them fail,
    // in order to return more complete information to the app

    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
    {
        hrTemp = pFxNode->m_data->AcquireFxResources();
        if (FAILED(hrTemp))
            hr = hrTemp;
        else if (hrTemp == DS_INCOMPLETE && SUCCEEDED(hr))
            hr = DS_INCOMPLETE;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::GetFxStatus
 *
 *  Description:
 *      Obtains the current effects' resource allocation status codes.
 *
 *  Arguments:
 *      DWORD* [out]: Receives the resource acquisition status codes
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::GetFxStatus"

HRESULT CEffectChain::GetFxStatus(LPDWORD pdwResultCodes)
{
    DPF_ENTER();
    ASSERT(IS_VALID_WRITE_PTR(pdwResultCodes, GetFxCount() * sizeof(DWORD)));

    DWORD n = 0;
    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        pdwResultCodes[n++] = pFxNode->m_data->m_fxStatus;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  CEffectChain::GetEffectInterface
 *
 *  Description:
 *      Searches the effect chain for an effect with a given COM CLSID and
 *      interface IID at a given index; returns a pointer to the interface.
 *
 *  Arguments:
 *      REFGUID [in]: CLSID required, or GUID_All_Objects for any CLSID.
 *      DWORD [in]: Index N of effect desired.  If the first argument was
 *                  GUID_All_Objects, we will return the Nth effect in the
 *                  chain; and if it was a specific CLSID, we return the
 *                  Nth effect with that CLSID.
 *      REFGUID [in]: Interface to query for from the selected effect.
 *      VOID** [out]: Receives a pointer to the requested COM interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::GetEffectInterface"

HRESULT CEffectChain::GetEffectInterface(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr = DSERR_OBJECTNOTFOUND;
    DPF_ENTER();

    BOOL fAllObjects = (guidObject == GUID_All_Objects);

    DWORD count = 0;
    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        if (fAllObjects || pFxNode->m_data->m_fxDescriptor.guidDSFXClass == guidObject)
            if (count++ == dwIndex)
                break;

    if (pFxNode)
        hr = pFxNode->m_data->GetInterface(iidInterface, ppObject);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::NotifyState
 *
 *  Description:
 *      Informs this effect chain of a state change in its owning buffer
 *      (from stopped to playing, or vice versa).
 *
 *  Arguments:
 *      DWORD [in]: new buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::NotifyState"

HRESULT CEffectChain::NotifyState(DWORD dwBufferState)
{
    HRESULT hr;
    DPF_ENTER();

    if (dwBufferState & VAD_BUFFERSTATE_STARTED)
        // The buffer has started; schedule FX processing to happen
        // as soon as we return from the current API call
        hr = m_pStreamingThread->WakeUpNow();
    else
        // The buffer has stopped; pre-roll FX at current position
        hr = PreRollFx();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::NotifyRelease
 *
 *  Description:
 *      Informs this effect chain of the release of a MIXIN buffer.  We in
 *      turn traverse our list of effects informing them, so that if one of
 *      them was a send to the MIXIN buffer it can react appropriately.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Departing MIXIN buffer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::NotifyRelease"

void CEffectChain::NotifyRelease(CDirectSoundSecondaryBuffer* pDsBuffer)
{
    DPF_ENTER();

    // Call NotifyRelease() on each effect
    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        pFxNode->m_data->NotifyRelease(pDsBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffectChain::SetInitialSlice
 *
 *  Description:
 *      Auxiliary function used by the streaming thread to establish an
 *      initial processing slice for this effects chain when it starts up.
 *      We try to synchronize with an active buffer we are sending to,
 *      and if none are available we start at our current write cursor.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: Size of processing slice to be established.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::SetInitialSlice"

void CEffectChain::SetInitialSlice(REFERENCE_TIME rtSliceSize)
{
    DPF_ENTER();

    if (m_pDsBuffer->GetPlayState() == Starting && !m_pDsBuffer->GetBufferType() && m_fHasSend)
    {
        CDirectSoundSecondaryBuffer* pDestBuf;
        CNode<CEffect*>* pFxNode;

        for (pFxNode = m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
            if ((pDestBuf = pFxNode->m_data->GetDestBuffer()) && pDestBuf->IsPlaying())
            {
                // Found an active destination buffer
                DPF_TIMING(DPFLVL_INFO, "Synchronizing send buffer at 0x%p with destination at 0x%p", m_pDsBuffer, pDestBuf);
                m_pDsBuffer->SynchronizeToBuffer(pDestBuf);
                break;
            }

        if (pFxNode == NULL)
        {
            DPF_TIMING(DPFLVL_INFO, "No active destination buffers found for send buffer at 0x%p", m_pDsBuffer);
            m_pDsBuffer->MoveCurrentSlice(RefTimeToBytes(rtSliceSize, m_pFormat));
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffectChain::PreRollFx
 *
 *  Description:
 *      Prepare a buffer for future playback by processing effects on
 *      a piece of the buffer starting at a given cursor position.
 *
 *  Arguments:
 *      DWORD [in]: Position at which to begin processing effects
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::PreRollFx"

HRESULT CEffectChain::PreRollFx(DWORD dwPosition)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    DPF_TIMING(DPFLVL_INFO, "dwPosition=%ld (%s%s%sbuffer w/effects at 0x%p)", dwPosition,
               m_pDsBuffer->GetBufferType() & DSBCAPS_MIXIN ? TEXT("MIXIN ") : TEXT(""),
               m_pDsBuffer->GetBufferType() & DSBCAPS_SINKIN ? TEXT("SINKIN ") : TEXT(""),
               !(m_pDsBuffer->GetBufferType() & (DSBCAPS_MIXIN|DSBCAPS_SINKIN)) ? TEXT("regular ") : TEXT(""),
               m_pDsBuffer);

    // First we flush any obsolete FX-processed audio
    m_pDsBuffer->ClearPlayBuffer();

    // It doesn't make sense to preroll effects for MIXIN or SINKIN buffers,
    // because they don't yet have valid data
    if (!m_pDsBuffer->GetBufferType())
    {
        // If called with no arguments (i.e. with the default argument of
        // CURRENT_PLAY_POS), we preroll FX at our current play position
        if (dwPosition == CURRENT_PLAY_POS)
            hr = m_pDsBuffer->GetInternalCursors(&dwPosition, NULL);

        if (SUCCEEDED(hr))
        {
            // Set these up to avoid spurious asserts later
            m_dwLastPlayCursor = m_dwLastWriteCursor = dwPosition;

            // We want to process data up to WriteAhead ms ahead of the cursor
            DWORD dwSliceSize = MsToBytes(m_dwWriteAheadFixme, m_pFormat);
            DWORD dwNewPos = (dwPosition + dwSliceSize) % m_dwBufSize;

            // Set the current processing slice so the streaming thread can take over
            m_pDsBuffer->SetCurrentSlice(dwPosition, dwSliceSize);

            // We don't actually process the FX on buffers with sends, as it would
            // cause a discontinuity when the streaming thread synchronizes them
            // with their destinations; instead, we just copy the dry audio data
            // into the play buffer.  This is what will be heard when we we start
            // playing, until the effects kicks in - there may be be an audible
            // discontinuity if the effects change the sound a lot, but hopefully
            // it'll sound smoother than the .........

// ARGH - perhaps best to go ahead process just the non-send effects here - it
// will probably sound smoother that way.

            if (m_fHasSend)
                CopyMemory(m_pPostFxBuffer, m_pPreFxBuffer, m_dwBufSize);
            else
                hr = ReallyProcessFx(dwPosition, dwNewPos);

            // Schedule FX processing to happen as soon as we return from
            // this API call (if it was a SetPosition() call, we want to
            // start processing as soon as possible)
            m_pStreamingThread->WakeUpNow();
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::UpdateFx
 *
 *  Description:
 *      Informs this effect chain of a change in the audio data in our
 *      associated buffer, so we can update the post-FX data if necessary.
 *
 *  Arguments:
 *      VOID* [in]: Pointer to beginning of modified audio data
 *      DWORD [in]: Number of bytes modified
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::UpdateFx"

HRESULT CEffectChain::UpdateFx(LPVOID pChangedPos, DWORD dwChangedSize)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // FIXME: check whether play/write cursors have overtaken
    // our last write pos here before running

    // Convert the buffer position pointer into an offset
    DWORD dwChangedPos = (DWORD)(PBYTE(pChangedPos) - m_pPreFxBuffer);

    DPF_TIMING(DPFLVL_INFO, "dwChangedPos=%lu dwChangedSize=%lu (%s%s%sbuffer w/effects at 0x%p)", dwChangedPos, dwChangedSize,
               m_pDsBuffer->GetBufferType() & DSBCAPS_MIXIN ? TEXT("MIXIN ") : TEXT(""),
               m_pDsBuffer->GetBufferType() & DSBCAPS_SINKIN ? TEXT("SINKIN ") : TEXT(""),
               !(m_pDsBuffer->GetBufferType() & (DSBCAPS_MIXIN|DSBCAPS_SINKIN)) ? TEXT("regular ") : TEXT(""),
               m_pDsBuffer);

    // Find the last buffer position we have processed effects on
    DWORD dwSliceBegin, dwSliceEnd;
    m_pDsBuffer->GetCurrentSlice(&dwSliceBegin, &dwSliceEnd);

    // Find the buffer's current play position
    DWORD dwPlayCursor;
    m_pDsBuffer->GetInternalCursors(&dwPlayCursor, NULL);

    // If the audio region updated by the application overlaps the region
    // from dwPlayCursor to dwSliceEnd, we re-process FX on the latter
    if (CircularBufferRegionsIntersect(m_dwBufSize, dwChangedPos, dwChangedSize, dwPlayCursor,
                                       DISTANCE(dwPlayCursor, dwSliceEnd, m_dwBufSize)))
    {
        if (!m_fHasSend)
        {
            hr = FxDiscontinuity();
            if (SUCCEEDED(hr))
                hr = ReallyProcessFx(dwPlayCursor, dwSliceEnd);
        }
        else // The effect chain contains at least one send
        {
            hr = FxDiscontinuity();
            if (SUCCEEDED(hr))
                hr = ReallyProcessFx(dwSliceBegin, dwSliceEnd);
        }
            // Here things get a little tricky.  If our buffer isn't playing,
            // we can't preroll FX, because
            // NB: Send buffers need to send to a fixed 'slot', so they
            // can only reprocess the most-recently processed slice:
            // FIXME - unfinished
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::ProcessFx
 *
 *  Description:
 *      Handle FX processing for a specific buffer, dealing with timing,
 *      state changes, etc.  Called from CStreamingThread::ProcessAudio().
 *
 *  Arguments:
 *
 *      REFERENCE_TIME [in]: Size of the current processing slice
 *                           (ignored by regular FX-only buffers)
 *
 *      DWORD [in]: How many ms to stay ahead of the buffer's write cursor
 *                  (ignored by MIXIN/sink buffers and buffers with sends)
 *
 *      LPDWORD [out]: Lets this effect chain ask the streaming thread to
 *                     boost its latency by a few ms if we almost glitch.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::ProcessFx"

HRESULT CEffectChain::ProcessFx(DWORD dwWriteAhead, LPDWORD pdwLatencyBoost)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    ASSERT(dwWriteAhead > 0);
    CHECK_WRITE_PTR(pdwLatencyBoost);

    // Temp hack - FIXME in DX8.1
    if (m_pDsBuffer->IsEmulated())
        dwWriteAhead += EMULATION_LATENCY_BOOST;

    if (m_pDsBuffer->IsPlaying())
    {
        if (m_pDsBuffer->GetBufferType() || m_fHasSend)
        {
            DWORD dwStartPos, dwEndPos;
            m_pDsBuffer->GetCurrentSlice(&dwStartPos, &dwEndPos);

            if (dwStartPos != MAX_DWORD)  // Can happen with sink buffers
                hr = ReallyProcessFx(dwStartPos, dwEndPos);
        }
        else // Keep the old timing around for a while for experimenting:
        {
            // Get the buffer's play and write cursors (as byte offsets)
            DWORD dwPlayCursor, dwWriteCursor;
            hr = m_pDsBuffer->GetInternalCursors(&dwPlayCursor, &dwWriteCursor);

            if (SUCCEEDED(hr))
            {
                // State our assumptions about these cursors, just in case
                ASSERT(LONG(dwPlayCursor)  >= 0 && dwPlayCursor  < m_dwBufSize);
                ASSERT(LONG(dwWriteCursor) >= 0 && dwWriteCursor < m_dwBufSize);

                // Get our most-recently processed slice of audio
                DWORD dwLastPos;
                m_pDsBuffer->GetCurrentSlice(NULL, &dwLastPos);

                // Check whether the write or play cursors have overtaken us
                if (OVERTAKEN(m_dwLastPlayCursor, dwPlayCursor, dwLastPos))
                {
                    DPF(DPFLVL_WARNING, "Glitch detected (play cursor overtook FX cursor)");
                    if (*pdwLatencyBoost < 3) *pdwLatencyBoost = 3;  // FIXME - be cleverer
                }
                else if (OVERTAKEN(m_dwLastWriteCursor, dwWriteCursor, dwLastPos))
                {
                    DPF(DPFLVL_INFO, "Possible glitch detected (write cursor overtook FX cursor)");
                    if (*pdwLatencyBoost < 1) *pdwLatencyBoost = 1;  // FIXME - be cleverer
                }

                // Save the current play and write positions
                m_dwLastPlayCursor = dwPlayCursor;
                m_dwLastWriteCursor = dwWriteCursor;

                // We want to process data up to dwWriteAhead ms ahead of the write cursor
                DWORD dwNewPos = (dwWriteCursor + MsToBytes(dwWriteAhead, m_pFormat)) % m_dwBufSize;

                // Check that we're not writing through the play cursor
                // REMOVED: If we keep (writeahead < buffersize+wakeinterval+padding), this should
                // never happen - and it get false positives when we hit the glitch detection above.
                // if (STRICTLY_CONTAINED(dwLastPos, dwNewPos, dwPlayCursor))
                // {
                //     DPF(DPFLVL_WARNING, "FX processing thread caught up with play cursor at %lu", dwPlayCursor);
                //     dwNewPos = dwPlayCursor;
                // }

                // If we have less than 5 ms of data to process, don't bother
                DWORD dwProcessedBytes = DISTANCE(dwLastPos, dwNewPos, m_dwBufSize);
                if (dwProcessedBytes > MsToBytes(5, m_pFormat))
                {
                    // Do the actual processing
                    hr = ReallyProcessFx(dwLastPos, dwNewPos);

                    // Update the last-processed buffer slice
                    m_pDsBuffer->MoveCurrentSlice(dwProcessedBytes);
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::ReallyProcessFx
 *
 *  Description:
 *      Process effects on a buffer, given the start and end positions of
 *      the audio region to be processed.  Handles wraparounds.
 *
 *  Arguments:
 *      DWORD [in]: Start position, as a byte offset into the buffer.
 *      DWORD [in]: Out position, as a byte offset into the buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::ReallyProcessFx"

HRESULT CEffectChain::ReallyProcessFx(DWORD dwStartPos, DWORD dwEndPos)
{
    HRESULT hr;
    DPF_ENTER();

    ASSERT(LONG(dwStartPos) >= 0 && dwStartPos < m_dwBufSize);
    ASSERT(LONG(dwEndPos) >= 0 && dwEndPos < m_dwBufSize);

    #ifdef DEBUG
    DWORD dwMilliseconds = BytesToMs(DISTANCE(dwStartPos, dwEndPos, m_dwBufSize), m_pFormat);
    if (dwMilliseconds > 2 * m_dwWriteAheadFixme)
        DPF(DPFLVL_WARNING, "Processing %lu ms! (from %lu to %lu, buffersize=%lu, writeahead=%lu ms)",
            dwMilliseconds, dwStartPos, dwEndPos, m_dwBufSize, m_dwWriteAheadFixme);
    #endif

    // If the buffer is SINKIN, get the time from its owning sink's latency clock;
    // the DMOs use this information to implement IMediaParams parameter curves
    REFERENCE_TIME rtTime = 0;
    if (m_pDsBuffer->GetBufferType() & DSBCAPS_SINKIN)
        rtTime = m_pDsBuffer->m_pOwningSink->GetSavedTime();

    if (dwStartPos < dwEndPos)
    {
        hr = ReallyReallyProcessFx(dwStartPos, dwEndPos - dwStartPos, rtTime);
    }
    else // The wraparound case
    {
        DWORD dwFirstChunk = m_dwBufSize - dwStartPos;
        hr = ReallyReallyProcessFx(dwStartPos, dwFirstChunk, rtTime);

        if (SUCCEEDED(hr))
            // Check for end of non-looping buffer
            if (!m_pDsBuffer->GetBufferType() && !(m_pDsBuffer->m_dwStatus & DSBSTATUS_LOOPING))
                DPF_TIMING(DPFLVL_MOREINFO, "Reached end of non-looping buffer");
            else if (dwEndPos != 0)
                hr = ReallyReallyProcessFx(0, dwEndPos, rtTime + BytesToRefTime(dwFirstChunk, m_pFormat), dwFirstChunk);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::ReallyReallyProcessFx
 *
 *  Description:
 *      Directly process effects on a buffer, given the start position and
 *      size of a (non-wrapped) audio region.  This function finally loops
 *      through the DMOs calling Process() on each of them.
 *
 *  Arguments:
 *      DWORD [in]: Start position, as a byte offset into the buffer.
 *      DWORD [in]: Size of region to be processed, in bytes.
 *      REFERENCE_TIME [in]: "Sink latency" time corresponding to the
 *                           first sample in this region.
 *      DWORD [in]: If non-zero, this argument means that we are currently
 *                  handling the second part of a wrapped-around region of
 *                  the buffer, and gives the offset of this second part;
 *                  this information can be used by any send effects in
 *                  the chain to send to the same offset in their target
 *                  buffers.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::ReallyReallyProcessFx"

HRESULT CEffectChain::ReallyReallyProcessFx(DWORD dwOffset, DWORD dwBytes, REFERENCE_TIME rtTime, DWORD dwSendOffset)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    ASSERT(LONG(dwOffset) >= 0);
    ASSERT(LONG(dwBytes) >= 0);
    ASSERT(dwOffset + dwBytes <= m_dwBufSize);

    PBYTE pAudioIn = m_pPreFxBuffer + dwOffset;
    PBYTE pAudioOut = m_pPostFxBuffer + dwOffset;

    // Copy data to the output buffer to process it in-place there
    CopyMemory(pAudioOut, pAudioIn, dwBytes);

    // Call Process() on each effect
    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
    {
        hr = pFxNode->m_data->Process(dwBytes, pAudioOut, rtTime, dwSendOffset, m_pFormat);
        if (FAILED(hr))
        {
            DPF(DPFLVL_WARNING, "DMO "DPF_GUID_STRING" failed with %s", DPF_GUID_VAL(pFxNode->m_data->m_fxDescriptor.guidDSFXClass), HRESULTtoSTRING(hr));
            break;
        }
    }

    // Commit the fresh data to the device (only important for VxD devices)
    if (SUCCEEDED(hr))
        hr = m_pDsBuffer->CommitToDevice(dwOffset, dwBytes);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::FxDiscontinuity
 *
 *  Description:
 *      Calls Discontinuity() on each effect of the effect chain.
 *
 *  Arguments:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::FxDiscontinuity"

HRESULT CEffectChain::FxDiscontinuity(void)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    DPF_TIMING(DPFLVL_INFO, "Discontinuity on effects chain at 0x%08X", this);

    if (GetCurrentProcessId() != this->GetOwnerProcessId())
        DPF(DPFLVL_MOREINFO, "Bailing out because we're being called from a different process");
    else for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode && SUCCEEDED(hr); pFxNode = pFxNode->m_pNext)
        pFxNode->m_data->Discontinuity();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffect::CEffect
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      DSEFFECTDESC& [in]: Effect description structure.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffect::CEffect"

CEffect::CEffect(DSEFFECTDESC& fxDescriptor)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEffect);

    // Keep local copy of effect description structure
    m_fxDescriptor = fxDescriptor;

    // Initialize defaults
    m_fxStatus = DSFXR_UNALLOCATED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffect::AcquireFxResources
 *
 *  Description:
 *      Acquires the hardware or software resources necessary to perform
 *      this effect.  Currently a bit of a no-op, but will come into its
 *      own when we do hardware acceleration of effects.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffect::AcquireFxResources"

HRESULT CEffect::AcquireFxResources(void)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_fxStatus == DSFXR_FAILED || m_fxStatus == DSFXR_UNKNOWN)
    {
        hr = DSERR_INVALIDCALL;
    }
    else if (m_fxStatus == DSFXR_UNALLOCATED)
    {
        if (m_fxDescriptor.dwFlags & DSFX_LOCHARDWARE)
        {
            hr = DSERR_INVALIDPARAM;
            m_fxStatus = DSFXR_FAILED;
        }
        else
        {
            m_fxStatus = DSFXR_LOCSOFTWARE;
        }
    }

    // Note: this code is due for resurrection in DX8.1
    //    if (FAILED(hr) && (m_fxDescriptor.dwFlags & DSFX_OPTIONAL))
    //        hr = DS_INCOMPLETE;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CDmoEffect::CDmoEffect
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      DSEFFECTDESC& [in]: Effect description structure.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::CDmoEffect"

CDmoEffect::CDmoEffect(DSEFFECTDESC& fxDescriptor)
    : CEffect(fxDescriptor)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDmoEffect);

    // Check initial values
    ASSERT(m_pMediaObject == NULL);
    ASSERT(m_pMediaObjectInPlace == NULL);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDmoEffect::~CDmoEffect
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::~CDmoEffect"

CDmoEffect::~CDmoEffect(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDmoEffect);

    // During shutdown, if the buffer hasn't been freed, these calls can
    // cause an access violation because the DMO DLL has been unloaded.
    try
    {
        RELEASE(m_pMediaObject);
        RELEASE(m_pMediaObjectInPlace);
    }
    catch (...) {}

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDmoEffect::Initialize
 *
 *  Description:
 *      Create the DirectX Media Object corresponding to this effect.
 *
 *  Arguments:
 *      DMO_MEDIA_TYPE* [in]: Information (wave format, etc.) used to
 *                            initialize our contained DMO.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::Initialize"

HRESULT CDmoEffect::Initialize(DMO_MEDIA_TYPE* pDmoMediaType)
{
    DPF_ENTER();

    HRESULT hr = CoCreateInstance(m_fxDescriptor.guidDSFXClass, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&m_pMediaObject);

    if (SUCCEEDED(hr))
    {
        CHECK_COM_INTERFACE(m_pMediaObject);
        hr = m_pMediaObject->QueryInterface(IID_IMediaObjectInPlace, (void**)&m_pMediaObjectInPlace);
        if (SUCCEEDED(hr))
        {
            CHECK_COM_INTERFACE(m_pMediaObjectInPlace);
        }
        else
        {
            ASSERT(m_pMediaObjectInPlace == NULL);
            DPF(DPFLVL_INFO, "Failed to obtain the IMediaObjectInPlace interface on effect "
                DPF_GUID_STRING " (%s)", DPF_GUID_VAL(m_fxDescriptor.guidDSFXClass), HRESULTtoSTRING(hr));
        }

        // Throw away the previous return code - we can live without IMediaObjectInPlace
        hr = m_pMediaObject->SetInputType(0, pDmoMediaType, 0);
        if (SUCCEEDED(hr))
            hr = m_pMediaObject->SetOutputType(0, pDmoMediaType, 0);
    }

    if (FAILED(hr))
    {
        RELEASE(m_pMediaObject);
        RELEASE(m_pMediaObjectInPlace);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CDmoEffect::Clone
 *
 *  Description:
 *      Creates a replica of this DMO effect object (or should do!).
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::Clone"

HRESULT CDmoEffect::Clone(IMediaObject *pMediaObject, DMO_MEDIA_TYPE* pDmoMediaType)
{
    DPF_ENTER();

    IMediaObjectInPlace *pMediaObjectInPlace = NULL;

    HRESULT hr = pMediaObject->QueryInterface(IID_IMediaObjectInPlace, (void**)&pMediaObjectInPlace);
    if (SUCCEEDED(hr))
    {
        CHECK_COM_INTERFACE(pMediaObjectInPlace);
        hr = pMediaObjectInPlace->Clone(&m_pMediaObjectInPlace);
        pMediaObjectInPlace->Release();

        if (SUCCEEDED(hr))
        {
            CHECK_COM_INTERFACE(m_pMediaObjectInPlace);
            hr = m_pMediaObjectInPlace->QueryInterface(IID_IMediaObject, (void**)&m_pMediaObject);
        }
        if (SUCCEEDED(hr))
        {
            CHECK_COM_INTERFACE(m_pMediaObject);
            hr = m_pMediaObject->SetInputType(0, pDmoMediaType, 0);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pMediaObject->SetOutputType(0, pDmoMediaType, 0);
        }
    }

    if (FAILED(hr))
    {
        RELEASE(m_pMediaObject);
        RELEASE(m_pMediaObjectInPlace);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CDmoEffect::Process
 *
 *  Description:
 *      Actually invoke effect processing on our contained DMO.
 *
 *  Arguments:
 *      DWORD [in]: Number of audio bytes to process.
 *      BYTE* [in, out]: Pointer to start of audio buffer to process.
 *      REFERENCE_TIME [in]: Timestamp of first sample to be processed
 *      DWORD [ignored]: Offset of a wrapped audio region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::Process"

HRESULT CDmoEffect::Process(DWORD dwBytes, BYTE *pAudio, REFERENCE_TIME rtTime, DWORD /*ignored*/, LPWAVEFORMATEX pFormat)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // if (m_fxStatus == DSFXR_LOCSOFTWARE) ...
    // FIXME: We may need to handle hardware and software buffers differently here.

    if (m_pMediaObjectInPlace)  // If the DMO provides this interface, use it
    {
        static const int nPeriod = 3;

        // We divide the region to be processed into nPeriod-ms pieces so that the
        // DMO's parameter curve will have a nPeriod-ms update period (manbug 36228)

        DWORD dwStep = MsToBytes(nPeriod, pFormat);
        for (DWORD dwCur = 0; dwCur < dwBytes && SUCCEEDED(hr); dwCur += dwStep)
        {
            if (dwStep > dwBytes - dwCur)
                dwStep = dwBytes - dwCur;

            hr = m_pMediaObjectInPlace->Process(dwStep, pAudio + dwCur, rtTime, DMO_INPLACE_NORMAL);

            rtTime += MsToRefTime(nPeriod);
        }
    }
    else  // FIXME: Support for IMediaObject-only DMOs goes here
    {
        #ifdef DEAD_CODE
        CMediaBuffer mbInput, mbDirectOutput, mbSendOutput;
        DMO_OUTPUT_DATA_BUFFER pOutputBuffers[2] = {{&mbDirectOutput, 0, 0, 0}, {&mbSendOutput, 0, 0, 0}};

        DWORD dwReserved;  // For the ignored return status from ProcessOutput()
        hr = m_pMediaObject->ProcessInput(0, pInput, DMO_INPUT_DATA_BUFFERF_TIME, rtTime, 0);
        if (SUCCEEDED(hr))
            hr = m_pMediaObject->ProcessOutput(0, 2, pOutputBuffers, &dwReserved);
        #endif

        hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::CSendEffect
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      DSEFFECTDESC& [in]: Effect description structure.
 *      CDirectSoundSecondaryBuffer* [in]: Pointer to our source buffer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::CSendEffect"

CSendEffect::CSendEffect(DSEFFECTDESC& fxDescriptor, CDirectSoundSecondaryBuffer* pSrcBuffer)
    : CEffect(fxDescriptor)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CSendEffect);

    // Double check we really are a send effect
#ifdef ENABLE_I3DL2SOURCE
    ASSERT(fxDescriptor.guidDSFXClass == GUID_DSFX_SEND || fxDescriptor.guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE);
#else
    ASSERT(fxDescriptor.guidDSFXClass == GUID_DSFX_SEND);
#endif

    // Figure out our destination buffer
    CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>* pImpBuffer =
        (CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>*)(fxDescriptor.dwReserved1);
    ASSERT(IS_VALID_IDIRECTSOUNDBUFFER(pImpBuffer));

    CDirectSoundSecondaryBuffer* pDestBuffer = pImpBuffer->m_pObject;
    CHECK_WRITE_PTR(pDestBuffer);

    // Set up the initial send configuration
    m_impDSFXSend.m_pObject = this;
    m_pMixFunction = pSrcBuffer->Format()->wBitsPerSample == 16 ? Mix16bit : Mix8bit;
    m_mixMode = pSrcBuffer->Format()->nChannels == pDestBuffer->Format()->nChannels ? OneToOne : MonoToStereo;
    m_pSrcBuffer = pSrcBuffer;
    m_pDestBuffer = pDestBuffer;
    m_lSendLevel = DSBVOLUME_MAX;
    m_dwAmpFactor = 0xffff;

#ifdef ENABLE_I3DL2SOURCE
    ASSERT(m_pI3DL2SrcDMO == NULL);
    ASSERT(m_pI3DL2SrcDMOInPlace == NULL);
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CSendEffect::~CSendEffect
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::~CSendEffect"

CSendEffect::~CSendEffect()
{
    DPF_ENTER();
    DPF_DESTRUCT(CSendEffect);

    // Unregister in our destination buffer's list of senders
    // (as long as the buffer hasn't been released already)
    if (m_pDestBuffer)
        m_pDestBuffer->UnregisterSender(m_pSrcBuffer);

#ifdef ENABLE_I3DL2SOURCE
    // During shutdown, if the buffer hasn't been freed, these calls can
    // cause an access violation because the DMO DLL has been unloaded.
    try
    {
        RELEASE(m_pI3DL2SrcDMO);
        RELEASE(m_pI3DL2SrcDMOInPlace);
    }
    catch (...) {}
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CSendEffect::Initialize
 *
 *  Description:
 *      Initializes the send effect object.
 *
 *  Arguments:
 *      DMO_MEDIA_TYPE* [in]: Wave format etc. information used to initialize
 *                            our contained I3DL2 source DMO, if we have one.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::Initialize"

HRESULT CSendEffect::Initialize(DMO_MEDIA_TYPE* pDmoMediaType)
{
    DPF_ENTER();

    // First we need to detect any send loops
    HRESULT hr = m_pSrcBuffer->FindSendLoop(m_pDestBuffer);

#ifdef ENABLE_I3DL2SOURCE
    if (SUCCEEDED(hr) && m_fxDescriptor.guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE)
    {
        hr = CoCreateInstance(GUID_DSFX_STANDARD_I3DL2SOURCE, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&m_pI3DL2SrcDMO);
        if (SUCCEEDED(hr))
        {
            CHECK_COM_INTERFACE(m_pI3DL2SrcDMO);
            hr = m_pI3DL2SrcDMO->QueryInterface(IID_IMediaObjectInPlace, (void**)&m_pI3DL2SrcDMOInPlace);
            if (SUCCEEDED(hr))
                CHECK_COM_INTERFACE(m_pI3DL2SrcDMOInPlace);
            else
                DPF(DPFLVL_WARNING, "Failed to obtain the IMediaObjectInPlace interface on the STANDARD_I3DL2SOURCE effect");

            // Throw away the return code - we can live without IMediaObjectInPlace

            // FIXME: maybe this will change when we restrict I3DL2 to mono buffers
            // and/or change the way the I3DL2 DMO returns two output streams.

            // If we have a mono buffer, special-case the I3DL2 DMO to use stereo
            BOOL fTweakedMediaType = FALSE;
            LPWAVEFORMATEX pFormat = LPWAVEFORMATEX(pDmoMediaType->pbFormat);
            if (pFormat->nChannels == 1)
            {
                fTweakedMediaType = TRUE;
                pFormat->nChannels = 2;
                pFormat->nBlockAlign *= 2;
                pFormat->nAvgBytesPerSec *= 2;
            }

            // Finally set up the (possibly tweaked) media type on the DMO
            hr = m_pI3DL2SrcDMO->SetInputType(0, pDmoMediaType, 0);
            if (SUCCEEDED(hr))
                hr = m_pI3DL2SrcDMO->SetOutputType(0, pDmoMediaType, 0);

            // Undo changes to the wave format if necessary
            if (fTweakedMediaType)
            {
                pFormat->nChannels = 1;
                pFormat->nBlockAlign /= 2;
                pFormat->nAvgBytesPerSec /= 2;
            }

            if (SUCCEEDED(hr))
            {
                // OK, we now need to hook-up the reverb source to its environment.
                // There is a special interface on the I3DL2SourceDMO just for this.

                LPDIRECTSOUNDFXI3DL2SOURCEENV pSrcEnv = NULL;
                LPDIRECTSOUNDFXI3DL2REVERB pEnvReverb = NULL;

                HRESULT hrTemp = m_pI3DL2SrcDMO->QueryInterface(IID_IDirectSoundFXI3DL2SourceEnv, (void**)&pSrcEnv);
                if (SUCCEEDED(hrTemp))
                {
                    CHECK_COM_INTERFACE(pSrcEnv);
                    hrTemp = m_pDestBuffer->GetObjectInPath(GUID_DSFX_STANDARD_I3DL2REVERB, 0, IID_IDirectSoundFXI3DL2Reverb, (void**)&pEnvReverb);
                }

                if (SUCCEEDED(hrTemp))
                {
                    CHECK_COM_INTERFACE(pEnvReverb);
                    hrTemp = pSrcEnv->SetEnvironmentReverb(pEnvReverb);
                }

                if (SUCCEEDED(hrTemp))
                    DPF(DPFLVL_INFO, "Connected the I3DL2 source to its environment successfully");

                // We're done with these interfaces.  The lifetime of the two buffers is managed
                // by DirectSound.  It will handle releasing the destination buffer.  We do not
                // hold a reference to it, and neither does the I3DL2 Source DMO.
                RELEASE(pSrcEnv);
                RELEASE(pEnvReverb);
            }
        }

        if (FAILED(hr))
        {
            RELEASE(m_pI3DL2SrcDMO);
            RELEASE(m_pI3DL2SrcDMOInPlace);
        }
    }
#endif

    // Register in our destination buffer's list of senders
    if (SUCCEEDED(hr))
        m_pDestBuffer->RegisterSender(m_pSrcBuffer);

    // Save the effect creation status for future reference
    m_fxStatus = SUCCEEDED(hr)              ? DSFXR_UNALLOCATED :
                 hr == REGDB_E_CLASSNOTREG  ? DSFXR_UNKNOWN     :
                 DSFXR_FAILED;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::Clone
 *
 *  Description:
 *      Creates a replica of this send effect object (or should do!).
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::Clone"

HRESULT CSendEffect::Clone(IMediaObject*, DMO_MEDIA_TYPE*)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // FIXME: todo - some code currently in CEffectChain::Clone() should move here.

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::CImpDirectSoundFXSend::QueryInterface
 *
 *  Description:
 *      Helper QueryInterface() method for our IDirectSoundFXSend interface.
 *
 *  Arguments:
 *      REFIID [in]: IID of interface desired.
 *      VOID** [out]: Receives pointer to COM interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::CImpDirectSoundFXSend::QueryInterface"

HRESULT CSendEffect::CImpDirectSoundFXSend::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr = E_NOINTERFACE;
    DPF_ENTER();

    // This should really be handled by our glorious COM interface manager, but... ;-)

    if (!IS_VALID_TYPED_WRITE_PTR(ppvObj))
    {
        RPF(DPFLVL_ERROR, "Invalid interface ID pointer");
        hr = E_INVALIDARG;
    }
#ifdef ENABLE_I3DL2SOURCE
    else if (m_pObject->m_pI3DL2SrcDMO)  // We are an I3DL2 Source - pass call to the DMO
    {
        DPF(DPFLVL_INFO, "Forwarding QueryInterface() call to the I3DL2 Source DMO");
        hr = m_pObject->m_pI3DL2SrcDMO->QueryInterface(riid, ppvObj);
    }
#endif
    else if (riid == IID_IUnknown)
    {
        *ppvObj = (IUnknown*)this;
        m_pObject->AddRef();
        hr = S_OK;
    }
    else if (riid == IID_IDirectSoundFXSend)
    {
        *ppvObj = (IDirectSoundFXSend*)this;
        m_pObject->AddRef();
        hr = S_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::SetAllParameters
 *
 *  Description:
 *      Sets all our parameters - i.e., our send level.
 *
 *  Arguments:
 *      DSFXSend* [in]: Pointer to send parameter structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::SetAllParameters"

HRESULT CSendEffect::SetAllParameters(LPCDSFXSend pcDsFxSend)
{
    HRESULT hr;
    DPF_ENTER();

    if (!IS_VALID_TYPED_READ_PTR(pcDsFxSend))
    {
        RPF(DPFLVL_ERROR, "Invalid pcDsFxSend pointer");
        hr = DSERR_INVALIDPARAM;
    }
    else if (pcDsFxSend->lSendLevel < DSBVOLUME_MIN || pcDsFxSend->lSendLevel > DSBVOLUME_MAX)
    {
        RPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        m_lSendLevel = pcDsFxSend->lSendLevel;
        m_dwAmpFactor = DBToAmpFactor(m_lSendLevel);
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::GetAllParameters
 *
 *  Description:
 *      Gets all our parameters - i.e., our send level.
 *
 *  Arguments:
 *      DSFXSend* [out]: Receives send parameter structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::GetAllParameters"

HRESULT CSendEffect::GetAllParameters(LPDSFXSend pDsFxSend)
{
    HRESULT hr;
    DPF_ENTER();

    if (!IS_VALID_TYPED_WRITE_PTR(pDsFxSend))
    {
        RPF(DPFLVL_ERROR, "Invalid pDsFxSend pointer");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        pDsFxSend->lSendLevel = m_lSendLevel;
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::NotifyRelease
 *
 *  Description:
 *      Informs this send effect of the release of a MIXIN buffer.  If it
 *      happens to be our destination buffer, we record that it's gone.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Departing MIXIN buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::NotifyRelease"

void CSendEffect::NotifyRelease(CDirectSoundSecondaryBuffer* pDsBuffer)
{
    DPF_ENTER();

    // Check if it was our destination buffer that was released
    if (pDsBuffer == m_pDestBuffer)
    {
        m_pDestBuffer = NULL;
        m_fxStatus = DSFXR_FAILED;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CSendEffect::Process
 *
 *  Description:
 *      Handles mixing data from our source buffer into its destination,
 *      and invokes effect processing on the I3DL2 source DMO if necessary.
 *
 *  Arguments:
 *      DWORD [in]: Number of audio bytes to process.
 *      BYTE* [in, out]: Pointer to start of audio buffer to process.
 *      REFERENCE_TIME [in]: Timestamp of first sample to be processed
 *      DWORD [in]: Offset of a wrapped audio region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::Process"

HRESULT CSendEffect::Process(DWORD dwBytes, BYTE *pAudio, REFERENCE_TIME rtTime, DWORD dwSendOffset, LPWAVEFORMATEX /*ignored*/)
{
    DWORD dwDestSliceBegin, dwDestSliceEnd;
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Pointer to the audio data we'll actually send; this pointer
    // may be modified below if this is an I3DL2 send
    BYTE* pSendAudio = pAudio;

    // Check whether our source buffer is active.  If it isn't,
    // we must be pre-rolling FX, so we don't perform the send.
    BOOL fPlaying = m_pSrcBuffer->IsPlaying();

    // If the source buffer is active, check the destination too.
    // (Note: if it has been released, m_pDestBuffer will be NULL)
    BOOL fSending = fPlaying && m_pDestBuffer && m_pDestBuffer->IsPlaying();

    // If sending, figure out the region to mix to and check it's valid
    if (fSending)
    {
        m_pDestBuffer->GetCurrentSlice(&dwDestSliceBegin, &dwDestSliceEnd);
        if (dwDestSliceBegin == MAX_DWORD)  // Can happen with sink buffers
            fSending = FALSE;
    }

    // OPTIMIZE: replace the CopyMemorys below with BYTE, WORD or DWORD
    // assignments, since we only support nBlockSizes of 1, 2 or 4...
    // But hopefully this code can disappear altogether (see bug 40236).

#ifdef ENABLE_I3DL2SOURCE
    // First call the I3DL2 DMO if this is an I3DL2 Source effect
    if (m_pI3DL2SrcDMOInPlace)
    {
        // If we're processing a mono buffer, an ugly hack is required; copying
        // the data into the L and R channels of a temporary stereo buffer, so
        // we have room for the two output streams returned by the I3DL2 DMO.

        WORD nBlockSize = m_pSrcBuffer->Format()->nBlockAlign;

        if (m_pSrcBuffer->Format()->nChannels == 1)
        {
            hr = MEMALLOC_A_HR(pSendAudio, BYTE, 2*dwBytes);
            if (SUCCEEDED(hr))
            {
                for (DWORD i=0; i<dwBytes; i += nBlockSize)
                {
                    CopyMemory(pSendAudio + 2*i,              pAudio + i, nBlockSize); // L channel
                    CopyMemory(pSendAudio + 2*i + nBlockSize, pAudio + i, nBlockSize); // R channel
                }
                hr = m_pI3DL2SrcDMOInPlace->Process(dwBytes, pSendAudio, rtTime, DMO_INPLACE_NORMAL);
            }

            if (SUCCEEDED(hr))
            {
                // Now we extract the two output streams from the data returned;
                // the direct path goes back to pAudio, and the reflected path
                // goes to the first half of pSendAudio.
                for (DWORD i=0; i<dwBytes; i += nBlockSize)
                {
                    CopyMemory(pAudio + i, pSendAudio + 2*i, nBlockSize);
                    if (fSending)  // Needn't preserve the reflected audio if we aren't sending it anywhere
                        CopyMemory(pSendAudio + i, pSendAudio + 2*i + nBlockSize, nBlockSize);
                }
            }
        }
        else // Processing a stereo buffer
        {
            hr = m_pI3DL2SrcDMOInPlace->Process(dwBytes, pAudio, rtTime, DMO_INPLACE_NORMAL);

            if (SUCCEEDED(hr))
                hr = MEMALLOC_A_HR(pSendAudio, BYTE, dwBytes);

            if (SUCCEEDED(hr))
            {
                // Extract the output streams and stereoize them at the same time
                for (DWORD i=0; i<dwBytes; i += nBlockSize)
                {
                    if (fSending)  // Needn't preserve the reflected audio if we aren't sending it anywhere
                    {
                        // Copy the R channel from pAudio into both channels of pSendAudio
                        CopyMemory(pSendAudio + i,                pAudio + i + nBlockSize/2, nBlockSize/2);
                        CopyMemory(pSendAudio + i + nBlockSize/2, pAudio + i + nBlockSize/2, nBlockSize/2);
                    }
                    // Copy pAudio's L channel onto its R channel
                    CopyMemory(pAudio + i + nBlockSize/2, pAudio + i, nBlockSize/2);
                }
            }
        }
    }
#endif

    // Now we handle the actual send
    if (SUCCEEDED(hr) && fSending)
    {
        PBYTE pDestBuffer = m_pDestBuffer->GetWriteBuffer();
        DWORD dwDestBufferSize = m_pDestBuffer->GetBufferSize();

        // If the source of this send has wrapped around and is making a second Process
        // call to handle the wrapped audio chunk, we will have a nonzero dwSendOffset
        // representing how far into the destination slice we should mix.  We add this
        // offset to dwDestSliceBegin (after a sanity check).
        ASSERT(CONTAINED(dwDestSliceBegin, dwDestSliceEnd, dwDestSliceBegin + dwSendOffset * m_mixMode));
        dwDestSliceBegin = (dwDestSliceBegin + dwSendOffset * m_mixMode) % dwDestBufferSize;

        DPF_TIMING(DPFLVL_MOREINFO, "Sending %lu bytes from %08X to %08X (%s to %s)",
                   dwBytes, pSendAudio, pDestBuffer + dwDestSliceBegin,
                   m_pSrcBuffer->Format()->nChannels == 1 ? TEXT("mono") : TEXT("stereo"),
                   m_pDestBuffer->Format()->nChannels == 1 ? TEXT("mono") : TEXT("stereo"));

        // The source slice had better fit in the destination slice
        ASSERT(dwBytes*m_mixMode <= DISTANCE(dwDestSliceBegin, dwDestSliceEnd, dwDestBufferSize));

        // Perform actual mixing
        if (dwDestSliceBegin + dwBytes*m_mixMode < dwDestBufferSize)
        {
            m_pMixFunction(pSendAudio, pDestBuffer + dwDestSliceBegin, dwBytes, m_dwAmpFactor, m_mixMode);
        }
        else // Wraparound case
        {
            DWORD dwLastBytes = (dwDestBufferSize - dwDestSliceBegin) / m_mixMode;
            m_pMixFunction(pSendAudio, pDestBuffer + dwDestSliceBegin, dwLastBytes, m_dwAmpFactor, m_mixMode);
            m_pMixFunction(pSendAudio + dwLastBytes, pDestBuffer, dwBytes - dwLastBytes, m_dwAmpFactor, m_mixMode);
        }
    }

    if (pSendAudio != pAudio)
        MEMFREE(pSendAudio);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Mix8bit
 *
 *  Description:
 *      Primitive 8-bit mixing function.  Attenuates source audio by a
 *      given factor, adds it to the destination audio, and clips.
 *
 *  Arguments:
 *      VOID* [in]: Pointer to source audio buffer.
 *      VOID* [in, out]: Pointer to destination audio buffer.
 *      DWORD [in]: Number of bytes to mix.
 *      DWORD [in]: Amplification factor (in 1/65536 units).
 *      MIXMODE: Whether to double the channel data or not.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Mix8bit"

static void Mix8bit(PVOID pSrc, PVOID pDest, DWORD dwBytes, DWORD dwAmpFactor, MIXMODE mixMode)
{
    unsigned char* pSampSrc = (unsigned char*)pSrc;
    unsigned char* pSampDest = (unsigned char*)pDest;
    DPF_ENTER();

    while (dwBytes--)
    {
        INT sample = (INT(*pSampSrc++) - 0x80) * INT(dwAmpFactor) / 0xffff;
        INT mixedSample = sample + *pSampDest;
        if (mixedSample > 0xff) mixedSample = 0xff;
        else if (mixedSample < 0) mixedSample = 0;
        *pSampDest++ = unsigned char(mixedSample);
        if (mixMode == MonoToStereo)
        {
            mixedSample = sample + *pSampDest;
            if (mixedSample > 0xff) mixedSample = 0xff;
            else if (mixedSample < 0) mixedSample = 0;
            *pSampDest++ = unsigned char(mixedSample);
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Mix16bit
 *
 *  Description:
 *      Primitive 16-bit mixing function.  Attenuates source audio by a
 *      given factor, adds it to the destination audio, and clips.
 *
 *  Arguments:
 *      VOID* [in]: Pointer to source audio buffer.
 *      VOID* [in, out]: Pointer to destination audio buffer.
 *      DWORD [in]: Number of bytes to mix.
 *      DWORD [in]: Amplification factor (in 1/65536 units).
 *      MIXMODE: Whether to double the channel data or not.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Mix16bit"

static void Mix16bit(PVOID pSrc, PVOID pDest, DWORD dwBytes, DWORD dwAmpFactor, MIXMODE mixMode)
{
    DWORD dwSamples = dwBytes / 2;
    short* pSampSrc = (short*)pSrc;
    short* pSampDest = (short*)pDest;
    DPF_ENTER();

    while (dwSamples--)
    {
        INT sample = INT(*pSampSrc++) * INT(dwAmpFactor) / 0xffff;
        INT mixedSample = sample + *pSampDest;
        if (mixedSample > 32767) mixedSample = 32767;
        else if (mixedSample < -32768) mixedSample = -32768;
        *pSampDest++ = short(mixedSample);
        if (mixMode == MonoToStereo)
        {
            mixedSample = sample + *pSampDest;
            if (mixedSample > 32767) mixedSample = 32767;
            else if (mixedSample < -32768) mixedSample = -32768;
            *pSampDest++ = short(mixedSample);
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  IsValidEffectDesc
 *
 *  Description:
 *      Determines if the given effect descriptor structure is valid for
 *      the given secondary buffer.
 *
 *  Arguments:
 *      DSEFFECTDESC* [in]: Effect descriptor to be validated.
 *      CDirectSoundSecondaryBuffer* [in]: Host buffer for the effect.
 *
 *  Returns:
 *      BOOL: TRUE if the descriptor is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidEffectDesc"

BOOL IsValidEffectDesc(LPCDSEFFECTDESC pEffectDesc, CDirectSoundSecondaryBuffer* pDsBuffer)
{
    BOOL fValid = TRUE;
    DPF_ENTER();

    if (pEffectDesc->dwSize != sizeof(DSEFFECTDESC))
    {
        RPF(DPFLVL_ERROR, "Invalid DSEFFECTDESC structure size");
        fValid = FALSE;
    }
    else if (pEffectDesc->dwReserved2 != 0)
    {
        RPF(DPFLVL_ERROR, "Reserved fields in the DSEFFECTDESC structure must be 0");
        fValid = FALSE;
    }

#ifdef DEAD_CODE
    if (fValid && !IsStandardEffect(pEffectDesc->guidDSFXClass))
        DPF(DPFLVL_INFO, DPF_GUID_STRING " is a third-party effect GUID", DPF_GUID_VAL(pEffectDesc->guidDSFXClass));
#endif

    if (fValid)
    {
        fValid = IsValidFxFlags(pEffectDesc->dwFlags);
    }

    if (fValid)
    {
        BOOL fSendEffect = pEffectDesc->guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
                           || pEffectDesc->guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
                           ;
        if (!fSendEffect && pEffectDesc->dwReserved1)
        {
            RPF(DPFLVL_ERROR, "lpSendBuffer should only be specified with GUID_DSFX_SEND"
#ifdef ENABLE_I3DL2SOURCE
                              " or GUID_DSFX_STANDARD_I3DL2SOURCE"
#endif
            );
            fValid = FALSE;
        }
        else if (fSendEffect)
        {
            CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>* pImpBuffer =
                (CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>*) (pEffectDesc->dwReserved1);
            LPWAVEFORMATEX pSrcWfx, pDstWfx;

            if (!pImpBuffer)
            {
                RPF(DPFLVL_ERROR, "lpSendBuffer must be specified for GUID_DSFX_SEND"
#ifdef ENABLE_I3DL2SOURCE
                                  " and GUID_DSFX_STANDARD_I3DL2SOURCE"
#endif
                );
                fValid = FALSE;
            }
            else if (!IS_VALID_IDIRECTSOUNDBUFFER(pImpBuffer))
            {
                RPF(DPFLVL_ERROR, "lpSendBuffer points to an invalid DirectSound buffer");
                fValid = FALSE;
            }
            else if (!(pImpBuffer->m_pObject->GetBufferType() & DSBCAPS_MIXIN))
            {
                RPF(DPFLVL_ERROR, "lpSendBuffer must point to a DSBCAPS_MIXIN buffer");
                fValid = FALSE;
            }
            else if (pImpBuffer->m_pObject->GetDirectSound() != pDsBuffer->GetDirectSound())
            {
                RPF(DPFLVL_ERROR, "Can't send to a buffer on a different DirectSound object");
                fValid = FALSE;
            }
            else if ((pSrcWfx = pDsBuffer->Format())->nSamplesPerSec !=
                     (pDstWfx = pImpBuffer->m_pObject->Format())->nSamplesPerSec)
            {
                RPF(DPFLVL_ERROR, "The buffer sent to must have the same nSamplesPerSec as the sender");
                fValid = FALSE;
            }
            else if (pSrcWfx->wBitsPerSample != pDstWfx->wBitsPerSample)
            {
                RPF(DPFLVL_ERROR, "The buffer sent to must have the same wBitsPerSample as the sender");
                fValid = FALSE;
            }
            else if ((pSrcWfx->nChannels > 2 || pDstWfx->nChannels > 2) && (pSrcWfx->nChannels != pDstWfx->nChannels))
            {
                RPF(DPFLVL_ERROR, "If either the send buffer or the receive buffer has more than two channels, the number of channels must match");
                fValid = FALSE;
            }
            else if (pSrcWfx->nChannels == 2 && pDstWfx->nChannels == 1)
            {
                RPF(DPFLVL_ERROR, "You can't send from a stereo buffer to a mono buffer");
                fValid = FALSE;
            }
            else if (pEffectDesc->dwFlags & (DSFX_LOCSOFTWARE | DSFX_LOCHARDWARE))
            {
                RPF(DPFLVL_ERROR, "Location flags should not be specified for GUID_DSFX_SEND"
#ifdef ENABLE_I3DL2SOURCE
                                  " or GUID_DSFX_STANDARD_I3DL2SOURCE"
#endif
                );
                fValid = FALSE;
            }
        }
    }

    DPF_LEAVE(fValid);
    return fValid;
}


#ifdef DEAD_CODE
/***************************************************************************
 *
 *  IsStandardEffect
 *
 *  Description:
 *      Determines if an effect GUID refers to one of our internal effects.
 *
 *  Arguments:
 *      REFGUID [in]: effect identifier.
 *
 *  Returns:
 *      BOOL: TRUE if the ID refers to an internal effect.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsStandardEffect"

BOOL IsStandardEffect(REFGUID guidEffect)
{
    LPCGUID stdFx[] = {&GUID_DSFX_SEND, &GUID_DSFX_STANDARD_DISTORTION, &GUID_DSFX_STANDARD_COMPRESSOR,
                       &GUID_DSFX_STANDARD_ECHO, &GUID_DSFX_STANDARD_CHORUS, &GUID_DSFX_STANDARD_FLANGER,
                       &GUID_DSFX_STANDARD_I3DL2SOURCE, &GUID_DSFX_STANDARD_I3DL2REVERB};
    BOOL fStandard;
    UINT i;

    DPF_ENTER();

    for (i=0, fStandard=FALSE; i < NUMELMS(stdFx) && !fStandard; ++i)
        fStandard = (guidEffect == *stdFx[i]);

    DPF_LEAVE(fStandard);
    return fStandard;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\emvad.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       emvad.cpp
 *  Content:    Emulated Virtual Audio Device class
 *              "emvad.cpp" is a misnomer; it does contain CEmRenderDevice,
 *              the emulated (via the wave* API) audio device, but it also
 *              has the CEm*WaveBuffer classes, which represent software
 *              audio buffers that can be attached to *any* mixer device;
 *              that is, both to CEmRenderDevice and to CVxdRenderDevice.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/1/97      dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CEmRenderDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::CEmRenderDevice"

CEmRenderDevice::CEmRenderDevice(void)
    : CMxRenderDevice(VAD_DEVICETYPE_EMULATEDRENDER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmRenderDevice);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmRenderDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::~CEmRenderDevice"

CEmRenderDevice::~CEmRenderDevice(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmRenderDevice);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumDrivers
 *
 *  Description:
 *      Creates a list of driver GUIDs that can be used to initialize this
 *      device.
 *
 *  Arguments:
 *      CList& [in/out]: pointer to a CList object that will be filled with
 *                       CDeviceDescription objects.  The caller is
 *                       responsible for freeing these objects.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::EnumDrivers"

HRESULT CEmRenderDevice::EnumDrivers(CObjectList<CDeviceDescription> *plstDrivers)
{
    CDeviceDescription *    pDesc                   = NULL;
    LPTSTR                  pszInterface            = NULL;
    HRESULT                 hr                      = DS_OK;
    TCHAR                   szTemplate[0x100];
    TCHAR                   szEmulated[0x100];
    TCHAR                   szName[0x400];
    UINT                    cDevices;
    BYTE                    bDeviceId;
    WAVEOUTCAPS             woc;
    GUID                    guid;
    MMRESULT                mmr;

    DPF_ENTER();

    // LIMITATION: We can't support more than 0xFF emulated devices,
    // because we pack the device ID into a byte member of a GUID.
    cDevices = waveOutGetNumDevs();
    cDevices = NUMERIC_CAST(cDevices, BYTE);

    // Load string templates
    if(!LoadString(hModule, IDS_DS_DRIVERLD, szTemplate, NUMELMS(szTemplate)))
    {
        DPF(DPFLVL_ERROR, "Can't load driver template string");
        hr = DSERR_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr) && !LoadString(hModule, IDS_EMULATED, szEmulated, NUMELMS(szEmulated)))
    {
        DPF(DPFLVL_ERROR, "Can't load emulated template string");
        hr = DSERR_OUTOFMEMORY;
    }

    // Enumerate each waveOut device and add it to the list
    for(bDeviceId = 0; bDeviceId < cDevices && SUCCEEDED(hr); bDeviceId++)
    {
        // Get the driver GUID
        g_pVadMgr->GetDriverGuid(m_vdtDeviceType, bDeviceId, &guid);

        // Create the device description object
        pDesc = NEW(CDeviceDescription(m_vdtDeviceType, guid, bDeviceId));
        hr = HRFROMP(pDesc);

        // Get the device name
        if(SUCCEEDED(hr))
        {
            mmr = waveOutGetDevCaps(bDeviceId, &woc, sizeof(woc));
            hr = MMRESULTtoHRESULT(mmr);
        }

        if(SUCCEEDED(hr))
        {
            lstrcpy(szName, woc.szPname);
            lstrcat(szName, szEmulated);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strName = szName;
        }

        // Get the device path
        if(SUCCEEDED(hr))
        {
            wsprintf(szName, szTemplate, bDeviceId);
            pDesc->m_strPath = szName;
        }

        // Get the device interface
        if(SUCCEEDED(hr))
        {
            GetWaveDeviceInterface(bDeviceId, FALSE, &pszInterface);
            pDesc->m_strInterface = pszInterface;
        }

        // Get the device devnode
        if(SUCCEEDED(hr))
        {
            GetWaveDeviceDevnode(bDeviceId, FALSE, &pDesc->m_dwDevnode);
        }

        // Add the driver to the list
        if(SUCCEEDED(hr))
        {
            hr = HRFROMP(plstDrivers->AddNodeToList(pDesc));
        }

        // Clean up
        MEMFREE(pszInterface);
        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::Initialize"

HRESULT CEmRenderDevice::Initialize(CDeviceDescription *pDesc)
{
    LPWAVEFORMATEX              pwfxFormat  = NULL;
    HRESULT                     hr;

    DPF_ENTER();

    // Initialize the base class
    hr = CMxRenderDevice::Initialize(pDesc);

    // Allocate the default format
    if(SUCCEEDED(hr))
    {
        pwfxFormat = AllocDefWfx();
        hr = HRFROMP(pwfxFormat);
    }

    // Create the mixer
    if(SUCCEEDED(hr))
    {
        if(!EnumStandardFormats(pwfxFormat, pwfxFormat))
        {
            // If none of the formats worked, the device is probably allocated
            hr = DSERR_ALLOCATED;
        }
    }

    // Clean up
    MEMFREE(pwfxFormat);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCAPS structure with the capabilities of the device.
 *
 *  Arguments:
 *      LPDSCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::GetCaps"

HRESULT CEmRenderDevice::GetCaps(LPDSCAPS pCaps)
{
    HRESULT                     hr  = DS_OK;
    WAVEOUTCAPS                 woc;
    MMRESULT                    mmr;

    DPF_ENTER();

    ASSERT(sizeof(*pCaps) == pCaps->dwSize);

    // Query the waveOut device
    mmr = waveOutGetDevCaps(m_pDeviceDescription->m_uWaveDeviceId, &woc, sizeof(woc));
    hr = MMRESULTtoHRESULT(mmr);

    if(SUCCEEDED(hr))
    {
        ZeroMemoryOffset(pCaps, pCaps->dwSize, sizeof(pCaps->dwSize));

        if(woc.dwFormats & WAVE_FORMAT_1M08 || woc.dwFormats & WAVE_FORMAT_2M08 || woc.dwFormats & WAVE_FORMAT_4M08)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYMONO | DSCAPS_PRIMARY8BIT;
        }

        if(woc.dwFormats & WAVE_FORMAT_1S08 || woc.dwFormats & WAVE_FORMAT_2S08 || woc.dwFormats & WAVE_FORMAT_4S08)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYSTEREO | DSCAPS_PRIMARY8BIT;
        }

        if(woc.dwFormats & WAVE_FORMAT_1M16 || woc.dwFormats & WAVE_FORMAT_2M16 || woc.dwFormats & WAVE_FORMAT_4M16)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYMONO | DSCAPS_PRIMARY16BIT;
        }

        if(woc.dwFormats & WAVE_FORMAT_1S16 || woc.dwFormats & WAVE_FORMAT_2S16 || woc.dwFormats & WAVE_FORMAT_4S16)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYSTEREO | DSCAPS_PRIMARY16BIT;
        }

        pCaps->dwFlags |= DSCAPS_EMULDRIVER;
        pCaps->dwMinSecondarySampleRate = DSBFREQUENCY_MIN;
        pCaps->dwMaxSecondarySampleRate = DSBFREQUENCY_MAX;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePrimaryBuffer
 *
 *  Description:
 *      Creates a primary buffer object.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      LPVOID [in]: buffer instace identifier.
 *      CPrimaryRenderWaveBuffer ** [out]: receives pointer to primary buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::CreatePrimaryBuffer"

HRESULT CEmRenderDevice::CreatePrimaryBuffer(DWORD dwFlags, LPVOID pvInstance, CPrimaryRenderWaveBuffer **ppBuffer)
{
    CEmPrimaryRenderWaveBuffer *    pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    // Create a new primary buffer wrapper object
    pBuffer = NEW(CEmPrimaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  LockMixerDestination
 *
 *  Description:
 *      Locks the mixer destination for writes.
 *
 *  Arguments:
 *      DWORD [in]: starting position.
 *      DWORD [in]: amount to lock.
 *      LPVOID * [out]: receives first lock pointer.
 *      LPDWORD [out]: receives first lock size.
 *      LPVOID * [out]: receives second lock pointer.
 *      LPDWORD [out]: receives second lock size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::LockMixerDestination"

HRESULT CEmRenderDevice::LockMixerDestination(DWORD ibLock, DWORD cbLock, LPVOID *ppvLock1, LPDWORD pcbLock1, LPVOID *ppvLock2, LPDWORD pcbLock2)
{
    CWeGrDest *             pWeGrDest   = (CWeGrDest *)m_pMixDest;
    HRESULT                 hr;

    DPF_ENTER();

    hr = pWeGrDest->Lock(ppvLock1, (int *)pcbLock1, ppvLock2, (int *)pcbLock2, ibLock, min(cbLock, (DWORD)pWeGrDest->m_cbBuffer));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UnlockMixerDestination
 *
 *  Description:
 *      Unlocks the mixer destination for writes.
 *
 *  Arguments:
 *      LPVOID [in]: first lock pointer.
 *      DWORD [in]: first lock size.
 *      LPVOID [in]: second lock pointer.
 *      DWORD [in]: second lock size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::UnlockMixerDestination"

HRESULT CEmRenderDevice::UnlockMixerDestination(LPVOID pvLock1, DWORD cbLock1, LPVOID pvLock2, DWORD cbLock2)
{
    CWeGrDest *             pWeGrDest   = (CWeGrDest *)m_pMixDest;
    HRESULT                 hr;

    DPF_ENTER();

    hr = pWeGrDest->Unlock(pvLock1, cbLock1, pvLock2, cbLock2);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EnumStandardFormatsCallback
 *
 *  Description:
 *      Callback function for EnumStandardFormats called from Initialize.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *
 *  Returns:
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::EnumStandardFormatsCallback"

BOOL CEmRenderDevice::EnumStandardFormatsCallback(LPCWAVEFORMATEX pwfx)
{
    CWeGrDest *             pMixDest;
    HRESULT                 hr;

    DPF_ENTER();

    // Create the mixer destination
    pMixDest = NEW(CWeGrDest(m_pDeviceDescription->m_uWaveDeviceId));
    hr = HRFROMP(pMixDest);

    // Attempt to create the mixer
    if SUCCEEDED(hr)
    {
        hr = CreateMixer(pMixDest, pwfx);
    }

    // Clean up after failures
    if (FAILED(hr))
    {
        // If we failed to create the mixer, then clean up the pMixDest.
        // we don't have to free the mixer; if CreateMixer had succeeded
        // we wouldn't be in this if-block.

        // We don't have to free the pMixDest, because if CreateMixer fails
        // it frees pMixDest.  This is a bit messy.  The object that
        // allocates the resource should be the one to free it.
        if (pMixDest)
        {
            pMixDest = NULL;
        }
    }

    DPF_LEAVE(FAILED(hr));

    return FAILED(hr);
}


/***************************************************************************
 *
 *  CEmPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Emulated device primary wave buffer constructor.
 *
 *  Arguments:
 *      CEmRenderDevice * [in]: parent device.
 *      LPVOID [in]: instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::CEmPrimaryRenderWaveBuffer"

CEmPrimaryRenderWaveBuffer::CEmPrimaryRenderWaveBuffer(CEmRenderDevice *pEmDevice, LPVOID pvInstance)
    : CPrimaryRenderWaveBuffer(pEmDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmPrimaryRenderWaveBuffer);

    // Initialize defaults
    m_pEmDevice = pEmDevice;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Emulated device primary wave buffer destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::~CEmPrimaryRenderWaveBuffer"

CEmPrimaryRenderWaveBuffer::~CEmPrimaryRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmPrimaryRenderWaveBuffer);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::Initialize"

HRESULT CEmPrimaryRenderWaveBuffer::Initialize(DWORD dwFlags)
{
    VADRBUFFERDESC          vrbd;
    HRESULT                 hr;

    DPF_ENTER();

    ZeroMemory(&vrbd, sizeof(vrbd));

    vrbd.dwFlags = dwFlags | DSBCAPS_LOCSOFTWARE;

    hr = CPrimaryRenderWaveBuffer::Initialize(&vrbd, NULL);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Gets capabilities for the device.
 *
 *  Arguments:
 *      LPVADRBUFFERCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::GetCaps"

HRESULT CEmPrimaryRenderWaveBuffer::GetCaps(LPVADRBUFFERCAPS pCaps)
{
    CWeGrDest *             pWeGrDest   = (CWeGrDest *)m_pEmDevice->m_pMixDest;
    HRESULT                 hr;

    DPF_ENTER();

    hr = CRenderWaveBuffer::GetCaps(pCaps);

    if(SUCCEEDED(hr))
    {
        pCaps->dwBufferBytes = pWeGrDest->m_cbBuffer;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RequestWriteAccess
 *
 *  Description:
 *      Requests write access to the primary buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to request primary access, FALSE to relenquish it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::RequestWriteAccess"

HRESULT CEmPrimaryRenderWaveBuffer::RequestWriteAccess(BOOL)
{
    DPF_ENTER();

    // WRITEPRIMARY isn't good in the WeGrDest
    RPF(DPFLVL_ERROR, "The emulated device does not support WRITEPRIMARY");

    DPF_LEAVE_HRESULT(DSERR_UNSUPPORTED);

    return DSERR_UNSUPPORTED;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::CommitToDevice"

HRESULT CEmPrimaryRenderWaveBuffer::CommitToDevice(DWORD ibCommit, DWORD cbCommit)
{
    ASSERT(FALSE);
    return DSERR_UNSUPPORTED;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::GetState"

HRESULT CEmPrimaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();

    *pdwState = m_pEmDevice->m_dwMixerState;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::SetState"

HRESULT CEmPrimaryRenderWaveBuffer::SetState(DWORD dwState)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pEmDevice->SetMixerState(dwState);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::GetCursorPosition"

HRESULT CEmPrimaryRenderWaveBuffer::GetCursorPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    hr = m_pEmDevice->m_pMixDest->GetSamplePosition((int *)pdwPlay, (int *)pdwWrite);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Create3dListener
 *
 *  Description:
 *      Creates the 3D listener.
 *
 *  Arguments:
 *      C3dListener ** [out]: receives pointer to the 3D listener object.
 *                            The caller is responsible for freeing this
 *                            object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::Create3dListener"

HRESULT CEmPrimaryRenderWaveBuffer::Create3dListener(C3dListener **pp3dListener)
{
    C3dListener *           p3dListener;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_vrbd.dwFlags & DSBCAPS_CTRL3D);

    p3dListener = NEW(C3dListener);
    hr = HRFROMP(p3dListener);

    if(SUCCEEDED(hr))
    {
        *pp3dListener = p3dListener;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CEmSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CMxRenderDevice * [in]: parent device.
 *      LPVOID [in]: instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::CEmSecondaryRenderWaveBuffer"

CEmSecondaryRenderWaveBuffer::CEmSecondaryRenderWaveBuffer(CMxRenderDevice *pDevice, LPVOID pvInstance)
    : CSecondaryRenderWaveBuffer(pDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmSecondaryRenderWaveBuffer);

    // Initialize defaults
    m_pMxDevice = pDevice;
    m_pMixSource = NULL;
    m_pFirContextLeft = NULL;
    m_pFirContextRight = NULL;
    m_dwState = VAD_BUFFERSTATE_STOPPED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::~CEmSecondaryRenderWaveBuffer"

CEmSecondaryRenderWaveBuffer::~CEmSecondaryRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmSecondaryRenderWaveBuffer);

    // Free the mixer source
    DELETE(m_pMixSource);

    // Free memory
    MEMFREE(m_pFirContextLeft);
    MEMFREE(m_pFirContextRight);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPWAVEFORMATEX [in]: buffer format.
 *      CSecondaryRenderWaveBuffer * [in]: pointer to the buffer to
 *                                         duplicate from, or NULL to
 *                                         initialize as a new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::Initialize"

HRESULT CEmSecondaryRenderWaveBuffer::Initialize(LPCVADRBUFFERDESC pDesc, CEmSecondaryRenderWaveBuffer *pSource, CSysMemBuffer *pSysMemBuffer)
{
    HRESULT                         hr  = DS_OK;

    DPF_ENTER();

    ASSERT(LXOR(pDesc, pSource));

    // Validate the buffer description
    if(pDesc)
    {
        ASSERT(!(pDesc->dwFlags & DSBCAPS_PRIMARYBUFFER));

        if(pDesc->dwFlags & DSBCAPS_LOCHARDWARE)
        {
            RPF(DPFLVL_ERROR, "LOCHARDWARE specified for a software buffer");
            hr = DSERR_INVALIDCALL;
        }

        if(SUCCEEDED(hr) && !IsValidPcmWfx(pDesc->pwfxFormat))
        {
            hr = DSERR_BADFORMAT;
        }
    }

    // Initialize the base class
    if(SUCCEEDED(hr))
    {
        hr = CSecondaryRenderWaveBuffer::Initialize(pDesc, pSource, pSysMemBuffer);
    }

    // Set the software bit
    if(SUCCEEDED(hr))
    {
        m_vrbd.dwFlags |= DSBCAPS_LOCSOFTWARE;
    }

    // Fill in the default 3D algorithm
    if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_CTRL3D) && IS_NULL_GUID(&m_vrbd.guid3dAlgorithm))
    {
        m_vrbd.guid3dAlgorithm = *m_pMxDevice->GetDefault3dAlgorithm();
        DPF(DPFLVL_MOREINFO, "Using default 3D algorithm " DPF_GUID_STRING, DPF_GUID_VAL(m_vrbd.guid3dAlgorithm));
    }

    // Allocate FIR context for the mixer
    if(SUCCEEDED(hr))
    {
        m_pFirContextLeft = MEMALLOC(FIRCONTEXT);
        hr = HRFROMP(m_pFirContextLeft);
    }

    if(SUCCEEDED(hr))
    {
        m_pFirContextRight = MEMALLOC(FIRCONTEXT);
        hr = HRFROMP(m_pFirContextRight);
    }

    // Create the mixer source
    if(SUCCEEDED(hr))
    {
        m_pMixSource = NEW(CMixSource(m_pMxDevice->m_pMixer));
        hr = HRFROMP(m_pMixSource);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pMixSource->Initialize(m_pSysMemBuffer->GetPlayBuffer(), m_pSysMemBuffer->GetSize(), m_vrbd.pwfxFormat, &m_pFirContextLeft, &m_pFirContextRight);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Duplicate
 *
 *  Description:
 *      Duplicates the buffer.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer ** [out]: receives duplicate buffer.  Use
 *                                           Release to free this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::Duplicate"

HRESULT CEmSecondaryRenderWaveBuffer::Duplicate(CSecondaryRenderWaveBuffer **ppBuffer)
{
    CEmSecondaryRenderWaveBuffer *  pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    pBuffer = NEW(CEmSecondaryRenderWaveBuffer(m_pMxDevice, m_pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(NULL, this, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::CommitToDevice"

HRESULT CEmSecondaryRenderWaveBuffer::CommitToDevice(DWORD ibCommit, DWORD cbCommit)
{
    DWORD                   ib[2];
    DWORD                   cb[2];

    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    // Signal a remix of this buffer
    ib[0] = ibCommit;

    if(ibCommit + cbCommit > m_pSysMemBuffer->GetSize())
    {
        cb[0] = m_vrbd.dwBufferBytes - ibCommit;
    }
    else
    {
        cb[0] = cbCommit;
    }

    ib[1] = 0;
    cb[1] = cbCommit - cb[0];

    m_pMixSource->Update(ib[0], cb[0], ib[1], cb[1]);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::GetState"

HRESULT CEmSecondaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        if(!m_pMixSource->IsPlaying())
        {
            m_dwState = VAD_BUFFERSTATE_STOPPED;
        }
    }

    *pdwState = m_dwState;

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetState"

HRESULT CEmSecondaryRenderWaveBuffer::SetState(DWORD dwState)
{
    static const DWORD dwValidMask = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING | VAD_BUFFERSTATE_SUSPEND;
    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, dwValidMask));

    ENTER_MIXER_MUTEX();

    if(dwState & VAD_BUFFERSTATE_SUSPEND)
    {
        ASSERT((dwState & VAD_BUFFERSTATE_SUSPEND) == VAD_BUFFERSTATE_SUSPEND);
        dwState = m_dwState ^ VAD_BUFFERSTATE_SUSPEND;
    }

    if(dwState & VAD_BUFFERSTATE_STARTED && !(dwState & VAD_BUFFERSTATE_SUSPEND))
    {
        m_pMixSource->Play(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
    }
    else
    {
        m_pMixSource->Stop();

        if(!(dwState & VAD_BUFFERSTATE_SUSPEND) && m_pMixSource->HasNotifications())
        {
            m_pMixSource->NotifyStop();
        }
    }

    m_dwState = dwState;
    LEAVE_MIXER_MUTEX();

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Retrieves the current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the play position.
 *      LPDWORD [out]: receives the write position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::GetCursorPosition"

HRESULT CEmSecondaryRenderWaveBuffer::GetCursorPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    if(m_vrbd.dwFlags & (DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_MIXIN | DSBCAPS_SINKIN | DSBCAPS_CTRLFX))
    {
        m_pMixSource->GetBytePosition((int *)pdwPlay, (int *)pdwWrite, NULL);
    }
    else
    {
        m_pMixSource->GetBytePosition1((int *)pdwPlay, (int *)pdwWrite);
    }

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetCursorPosition
 *
 *  Description:
 *      Sets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetCursorPosition"

HRESULT CEmSecondaryRenderWaveBuffer::SetCursorPosition(DWORD dwPlay)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    ASSERT(dwPlay < m_vrbd.dwBufferBytes);

    m_pMixSource->SetBytePosition(dwPlay);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the buffer frequency.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *      BOOL [in]: whether to clamp to the driver's supported frequency
 *                 range if the call fails.  Ignored in this class.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetFrequency"

HRESULT CEmSecondaryRenderWaveBuffer::SetFrequency(DWORD dwFrequency, BOOL)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    m_pMixSource->SetFrequency(dwFrequency);
    m_vrbd.pwfxFormat->nSamplesPerSec = dwFrequency;

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Mutes or unmutes the buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to mute the buffer, FALSE to restore it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetMute"

HRESULT CEmSecondaryRenderWaveBuffer::SetMute(BOOL fMute)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    m_pMixSource->m_fMute = fMute;

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Sets the attenuation for each channel.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetAttenuation"

HRESULT CEmSecondaryRenderWaveBuffer::SetAttenuation(PDSVOLUMEPAN pdsvp)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    m_pMixSource->SetVolumePan(pdsvp);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


#ifdef FUTURE_MULTIPAN_SUPPORT
/***************************************************************************
 *
 *  SetChannelAttenuations
 *
 *  Description:
 *      Sets the multichannel attenuation for a given buffer.
 *
 *  Arguments:
 *      TBD.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetChannelAttenuations"

HRESULT CEmSecondaryRenderWaveBuffer::SetChannelAttenuations(LONG lVolume, DWORD dwChannelCount, const DWORD* pdwChannels, const LONG* plChannelVolumes)
{
    HRESULT                     hr   = DS_OK;
    LONG                        lPan;

    DPF_ENTER();

    if (dwChannelCount == 0)
    {
        // SetChannelVolume() has not been called yet; use center panning
        ASSERT(!pdwChannels && !plChannelVolumes);  // Sanity checking
        lPan = 0;
    }
    else
    {
        // Calculate a global LR pan value based on the channel volumes
        lPan = MultiChannelToStereoPan(dwChannelCount, pdwChannels, plChannelVolumes);
    }

    DSVOLUMEPAN dsvp;
    FillDsVolumePan(lVolume, lPan, &dsvp);
    m_pMixSource->SetVolumePan(&dsvp);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // FUTURE_MULTIPAN_SUPPORT


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetNotificationPositions"

HRESULT CEmSecondaryRenderWaveBuffer::SetNotificationPositions(DWORD dwCount, LPCDSBPOSITIONNOTIFY paNotes)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    m_pMixSource->SetNotificationPositions(dwCount, paNotes);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  Create3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      REFGUID [in]: 3D algorithm GUID.
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::Create3dObject"

HRESULT CEmSecondaryRenderWaveBuffer::Create3dObject(C3dListener *p3dListener, C3dObject **pp3dObject)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_vrbd.dwFlags & DSBCAPS_CTRL3D);
    ASSERT(IsValid3dAlgorithm(m_vrbd.guid3dAlgorithm));

    m_hrSuccessCode = DS_OK;

    if(DS3DALG_ITD == m_vrbd.guid3dAlgorithm)
    {
        hr = CreateItd3dObject(p3dListener, pp3dObject);
    }
    else
    {
        // No matter whether the 3D algorithm requested is No Virtualization (Pan3D)
        // or one of the unsupported HRTF algorithms, we just do Pan3D.  If HRTF had
        // been requested, we return DS_NO_VIRTUALIZATION (as per manbug 23196).
        if (DS3DALG_NO_VIRTUALIZATION != m_vrbd.guid3dAlgorithm)
        {
            m_hrSuccessCode = DS_NO_VIRTUALIZATION;
            DPF(DPFLVL_INFO, "Replaced unsupported 3D algorithm " DPF_GUID_STRING " with Pan3D", DPF_GUID_VAL(m_vrbd.guid3dAlgorithm));
        }
        hr = CreatePan3dObject(p3dListener, fMute3dAtMaxDistance, m_vrbd.pwfxFormat->nSamplesPerSec, pp3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateItd3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::CreateItd3dObject"

HRESULT CEmSecondaryRenderWaveBuffer::CreateItd3dObject(C3dListener *p3dListener, C3dObject **pp3dObject)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    CEmItd3dObject *        p3dObject;
    HRESULT                 hr;

    DPF_ENTER();

    p3dObject = NEW(CEmItd3dObject(p3dListener, fMute3dAtMaxDistance, fDopplerEnabled, m_vrbd.pwfxFormat->nSamplesPerSec, m_pMixSource, m_pMxDevice->m_pMixDest, m_pFirContextLeft, m_pFirContextRight));
    hr = HRFROMP(p3dObject);

    if(SUCCEEDED(hr))
    {
        hr = p3dObject->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }
    else
    {
        RELEASE(p3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CEmItd3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *      DWORD [in]: buffer frequency.
 *      CMixSource * [in]: mixer source used by the owning buffer.
 *      PFIRCONTEXT [in]: left channel FIR context.
 *      PFIRCONTEXT [in]: right channel FIR context.
 *      BOOL [in]: TRUE to mute at max distance.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::CEmItd3dObject"

CEmItd3dObject::CEmItd3dObject(C3dListener *pListener, BOOL fMuteAtMaxDistance, BOOL fDopplerEnabled,
                               DWORD dwFrequency, CMixSource *pMixSource, CMixDest *pMixDest,
                               PFIRCONTEXT pContextLeft, PFIRCONTEXT pContextRight)
    : CItd3dObject(pListener, fMuteAtMaxDistance, fDopplerEnabled, dwFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmItd3dObject);

    // Initialize defaults
    m_pMixSource = pMixSource;
    m_pMixDest = pMixDest;
    m_pContextLeft = pContextLeft;
    m_pContextRight = pContextRight;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmItd3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::~CEmItd3dObject"

CEmItd3dObject::~CEmItd3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CItd3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Commit3dChanges
 *
 *  Description:
 *      Writes updated 3D data to the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::Commit3dChanges"

HRESULT CEmItd3dObject::Commit3dChanges(void)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    // Apply changed FIR data
    m_pContextLeft->fLeft = TRUE;
    m_pContextRight->fLeft = FALSE;

    CvtContext(&m_ofcLeft, m_pContextLeft);
    CvtContext(&m_ofcRight, m_pContextRight);

    // Turn the filter on or off and set proper frequency
    if(DS3DMODE_DISABLE == m_opCurrent.dwMode)
    {
        m_pMixSource->FilterOff();
        if (m_fDopplerEnabled)
            m_pMixSource->SetFrequency(m_dwUserFrequency);
    }
    else
    {
        m_pMixSource->FilterOn();
        if (m_fDopplerEnabled)
            m_pMixSource->SetFrequency(m_dwDopplerFrequency);
    }

    // If 3D is enabled, and the user wants to mute at max distance AND
    // we're at max distance, mute.  Otherwise, unmute.
    m_pMixSource->m_fMute3d = IsAtMaxDistance();

    // Signal a remix
    m_pMixSource->SignalRemix();

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  CvtContext
 *
 *  Description:
 *      Converts an OBJECT_ITD_CONTEXT to a FIRCONTEXT.
 *
 *  Arguments:
 *      LPOBJECTFIRCONTEXT [in]: source.
 *      PFIRCONTEXT [out]: destination.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::CvtContext"

void CEmItd3dObject::CvtContext(LPOBJECT_ITD_CONTEXT pSource, PFIRCONTEXT pDest)
{
    DPF_ENTER();

    pDest->DistAttenuation = pSource->flDistanceAttenuation;
    pDest->ConeAttenuation = pSource->flConeAttenuation;
    pDest->ConeShadow = pSource->flConeShadow;
    pDest->PositionAttenuation = pSource->flPositionAttenuation;
    pDest->PositionShadow = pSource->flPositionShadow;
    pDest->VolSmoothScale = pSource->flVolSmoothScale;
    pDest->VolSmoothScaleRecip = pSource->flVolSmoothScaleRecip;
    pDest->VolSmoothScaleDry = pSource->flVolSmoothScaleDry;
    pDest->VolSmoothScaleWet = pSource->flVolSmoothScaleWet;
    pDest->iSmoothFreq = pSource->dwSmoothFreq;
    pDest->iDelay = pSource->dwDelay;

    pDest->TotalDryAttenuation = pSource->flPositionAttenuation * pSource->flConeAttenuation * pSource->flConeShadow * pSource->flPositionShadow;
    pDest->LastDryAttenuation = pDest->TotalDryAttenuation;

    pDest->TotalWetAttenuation = pSource->flPositionAttenuation * pSource->flConeAttenuation * (1.0f - pSource->flConeShadow * pSource->flPositionShadow);
    pDest->LastWetAttenuation = pDest->TotalWetAttenuation;

#ifdef SMOOTH_ITD

    pDest->iLastDelay = pDest->iDelay;

#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Get3dOutputSampleRate
 *
 *  Description:
 *      Gets the sample rate of the final output.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::Get3dOutputSampleRate"

DWORD CEmItd3dObject::Get3dOutputSampleRate(void)
{
    DWORD freq;

    DPF_ENTER();

    freq = m_pMixDest->GetFrequency();

    DPF_LEAVE(freq);

    return freq;
}


/***************************************************************************
 *
 *  CEmCaptureDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::CEmCaptureDevice"

CEmCaptureDevice::CEmCaptureDevice()
    : CCaptureDevice(VAD_DEVICETYPE_EMULATEDCAPTURE)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmCaptureDevice);

    // Initialize defaults
    m_pwfxFormat    = NULL;
    m_hwi           = NULL;

    m_fAllocated    = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmCaptureDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::~CEmCaptureDevice"

CEmCaptureDevice::~CEmCaptureDevice()
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmCaptureDevice);

    if (m_hwi)
        CloseWaveIn(&m_hwi);

    // Free memory
    MEMFREE(m_pwfxFormat);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumDrivers
 *
 *  Description:
 *      Creates a list of driver GUIDs that can be used to initialize this
 *      device.
 *
 *  Arguments:
 *      CList& [in/out]: pointer to a CList object that will be filled with
 *                       CDeviceDescription objects.  The caller is
 *                       responsible for freeing these objects.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::EnumDrivers"

HRESULT CEmCaptureDevice::EnumDrivers(CObjectList<CDeviceDescription> *plstDrivers)
{
    CDeviceDescription *    pDesc                   = NULL;
    LPTSTR                  pszInterface            = NULL;
    HRESULT                 hr                      = DS_OK;
    TCHAR                   szTemplate[0x100];
    TCHAR                   szEmulated[0x100];
    TCHAR                   szName[0x400];
    UINT                    cDevices;
    BYTE                    bDeviceId;
    WAVEINCAPS              wic;
    GUID                    guid;
    MMRESULT                mmr;

    DPF_ENTER();

    // LIMITATION: We can't support more than 0xFF emulated devices,
    // because we pack the device ID into a byte member of a GUID.
    cDevices = waveInGetNumDevs();
    cDevices = NUMERIC_CAST(cDevices, BYTE);

    // Load string templates
    if(!LoadString(hModule, IDS_DSC_DRIVERLD, szTemplate, NUMELMS(szTemplate)))
    {
        DPF(DPFLVL_ERROR, "Can't load driver template string");
        hr = DSERR_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr) && !LoadString(hModule, IDS_EMULATED, szEmulated, NUMELMS(szEmulated)))
    {
        DPF(DPFLVL_ERROR, "Can't load emulated template string");
        hr = DSERR_OUTOFMEMORY;
    }

    // Enumerate each waveOut device and add it to the list
    for(bDeviceId = 0; bDeviceId < cDevices && SUCCEEDED(hr); bDeviceId++)
    {
        // Get the driver GUID
        g_pVadMgr->GetDriverGuid(m_vdtDeviceType, bDeviceId, &guid);

        // Create the device description object
        pDesc = NEW(CDeviceDescription(m_vdtDeviceType, guid, bDeviceId));
        hr = HRFROMP(pDesc);

        // Get the device name
        if(SUCCEEDED(hr))
        {
            mmr = waveInGetDevCaps(bDeviceId, &wic, sizeof(wic));
            hr = MMRESULTtoHRESULT(mmr);
        }

        if(SUCCEEDED(hr))
        {
            lstrcpy(szName, wic.szPname);
            lstrcat(szName, szEmulated);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strName = szName;
        }

        // Get the device path
        if(SUCCEEDED(hr))
        {
            wsprintf(szName, szTemplate, bDeviceId);
            pDesc->m_strPath = szName;
        }

        // Get the device interface
        if(SUCCEEDED(hr))
        {
            GetWaveDeviceInterface(bDeviceId, FALSE, &pszInterface);
            pDesc->m_strInterface = pszInterface;
        }

        // Get the device devnode
        if(SUCCEEDED(hr))
        {
            GetWaveDeviceDevnode(bDeviceId, FALSE, &pDesc->m_dwDevnode);
        }

        // Add the driver to the list
        if(SUCCEEDED(hr))
        {
            hr = HRFROMP(plstDrivers->AddNodeToList(pDesc));
        }

        // Clean up
        MEMFREE(pszInterface);
        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::Initialize"

HRESULT CEmCaptureDevice::Initialize(CDeviceDescription *pDesc)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Initialize the base class
    hr = CCaptureDevice::Initialize(pDesc);

    // Get the default format
    if(SUCCEEDED(hr))
    {
        m_pwfxFormat = AllocDefWfx();
        hr = HRFROMP(m_pwfxFormat);
    }

    if(SUCCEEDED(hr))
    {
        if(!EnumStandardFormats(m_pwfxFormat, m_pwfxFormat))
        {
            // If none of the formats worked, assume the device is allocated
            hr = DSERR_ALLOCATED;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCCAPS structure with the capabilities of the device.
 *
 *  Arguments:
 *      LPDSCCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::GetCaps"

HRESULT CEmCaptureDevice::GetCaps(LPDSCCAPS pCaps)
{
    WAVEINCAPS                  wic;
    MMRESULT                    mmr;
    HRESULT                     hr;

    DPF_ENTER();

    // Query the waveIn device
    mmr = waveInGetDevCaps(m_pDeviceDescription->m_uWaveDeviceId, &wic, sizeof(wic));
    hr = MMRESULTtoHRESULT(mmr);

    if(SUCCEEDED(hr))
    {
        pCaps->dwFlags = DSCCAPS_EMULDRIVER;
        pCaps->dwFormats = wic.dwFormats;
        pCaps->dwChannels = wic.wChannels;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateBuffer
 *
 *  Description:
 *      Creates a capture wave buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      CCaptureWaveBuffer ** [out]: receives pointer to new wave buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::CreateBuffer"

HRESULT CEmCaptureDevice::CreateBuffer
(
    DWORD dwFlags,
    DWORD dwBufferBytes,
    LPCWAVEFORMATEX pwfxFormat,
    CCaptureEffectChain*,
    LPVOID pvInstance,
    CCaptureWaveBuffer** ppBuffer
)
{
    CEmCaptureWaveBuffer *  pBuffer = NULL;
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    if (m_lstBuffers.GetListHead())
    {
        hr = DSERR_ALLOCATED;
    }

    if (SUCCEEDED(hr))
    {
        #pragma warning(disable:4530)  // Disable the nag about compiling with -GX
        try
        {
            pBuffer = NEW(CEmCaptureWaveBuffer(this));
        }
        catch (...)
        {
            // This exception handler is silly, since it makes us leak the memory
            // allocated for CEmCaptureWaveBuffer above (which wasn't assigned to
            // pBuffer yet), and also possibly m_cs, which is something we really
            // don't want to do if we're low on memory in the first place.
            //
            // But InitializeCriticalSection is supposed to be fixed in Blackcomb
            // not to throw exceptions any more, so we can live with this for now.

            ASSERT(pBuffer == NULL);
            ASSERT(!"InitializeCriticalSection() threw an exception");
        }

        hr = HRFROMP(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(dwFlags, dwBufferBytes, pwfxFormat);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetGlobalFormat
 *
 *  Description:
 *      Makes the specified WFX, the format for the capture buffer
 *
 *  Arguments:
 *      LPVOID [in] : pointer to the owner of the format
 *      LPCWAVEFORMATEX [in] : pointer to the new WFX to use
 *      DWORD [in]: callback, if any.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::SetGlobalFormat"

HRESULT CEmCaptureDevice::SetGlobalFormat(LPVOID pOwner, LPCWAVEFORMATEX pwfx, LPVOID pvCallback, DWORD dwFlags)
{
    DPF_ENTER();

    DWORD       fdwOpen = 0;
    LPHWAVEIN   phw = &m_hwi;

    // Should we attempt to use the WAVE_MAPPER?
    if (DSCBCAPS_WAVEMAPPED & dwFlags)
    {
        fdwOpen |= WAVE_MAPPED;
    }

    // We don't allocate the device on focus aware buffers.
    if (DSCBCAPS_FOCUSAWARE & dwFlags)
    {
        fdwOpen |= WAVE_FORMAT_QUERY;
        phw = NULL;
    }
    else
    {
        fdwOpen |= (pvCallback ? CALLBACK_FUNCTION : CALLBACK_NULL);

        // The reason why we had to close the device if open, is that
        // EnumStandardFormatsCallback() used to allocate the device.
        // It no longer does so as of DX 7.1 and thus we can ax this
        // close.  If the device is allocated, it is REALLY in use.
    }

    HRESULT hr = OpenWaveIn(phw, m_pDeviceDescription->m_uWaveDeviceId, pwfx, (DWORD_PTR)pvCallback, (DWORD_PTR)pOwner, fdwOpen);

    if (FAILED(hr))
    {
        // Oops.  Try to get the device back with the old format.
        OpenWaveIn(phw, m_pDeviceDescription->m_uWaveDeviceId, m_pwfxFormat, (DWORD_PTR)pvCallback, (DWORD_PTR)pOwner, fdwOpen);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnumStandardFormatsCallback
 *
 *  Description:
 *      Callback function for EnumStandardFormats used when calling
 *      Initialize.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *
 *  Returns:
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::EnumStandardFormatsCallback"

BOOL CEmCaptureDevice::EnumStandardFormatsCallback(LPCWAVEFORMATEX pwfx)
{
    DPF_ENTER();

    HRESULT hr = OpenWaveIn(NULL, m_pDeviceDescription->m_uWaveDeviceId, pwfx, 0, 0, WAVE_FORMAT_QUERY);

    DPF_LEAVE(FAILED(hr));
    return FAILED(hr);
}


/***************************************************************************
 *
 *  CEmCaptureWaveBuffer
 *
 *  Description:
 *      Constructor for CEmCaptureWaveBuffer
 *
 *  Arguments:
 *      CCaptureVad [in]: parent object.
 *
 *  Returns:
 *      Nothing
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::CEmCaptureWaveBuffer"

CEmCaptureWaveBuffer::CEmCaptureWaveBuffer(CCaptureDevice *pDevice) : CCaptureWaveBuffer(pDevice)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmCaptureWaveBuffer);

    ASSERT(0 == m_dwState);
    ASSERT(0 == m_fdwSavedState);

    ASSERT(0 == m_cwhdr);
    ASSERT(NULL == m_rgpwhdr);
    ASSERT(0 == m_cwhdrDone);
    ASSERT(0 == m_iwhdrDone);

    ASSERT(NULL == m_pBuffer);
    ASSERT(0 == m_cbBuffer);
    ASSERT(0 == m_cbRecordChunk);
    ASSERT(NULL == m_pBufferMac);
    ASSERT(NULL == m_pBufferNext);
    ASSERT(0 == m_cLoops);
    ASSERT(NULL == m_pwfx);
    ASSERT(NULL == m_hwi);

    ASSERT(0 == m_cpn);
    ASSERT(NULL == m_rgpdsbpn);
    ASSERT(0 == m_ipn);
    ASSERT(0 == m_cpnAllocated);

    m_fCritSectsValid = FALSE;
    InitializeCriticalSection(&m_cs);
    InitializeCriticalSection(&m_csPN);
    m_fCritSectsValid = TRUE;

    ASSERT(0 == m_dwCaptureCur);
    ASSERT(0 == m_dwCaptureLast);
    ASSERT(NULL == m_hThread);
    ASSERT(NULL == m_rghEvent[0]);
    ASSERT(NULL == m_rghEvent[chEvents-1]);

    ASSERT(0 == m_cwhdrDropped);
    ASSERT(NULL == m_pBufferProcessed);

    #ifdef DEBUG_CAPTURE
    ASSERT(0 == m_iwhdrExpected);
    #endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmCaptureWaveBuffer
 *
 *  Description:
 *      Destructor for CEmCaptureWaveBuffer
 *
 *  Arguments:
 *      None
 *
 *  Returns:
 *      Nothing
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::~CEmCaptureWaveBuffer"

CEmCaptureWaveBuffer::~CEmCaptureWaveBuffer()
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmCaptureWaveBuffer);

    // If critical section(s) not intialized, nothing else did either
    if (!m_fCritSectsValid)
    {
        return;
    }

    // Set the Terminate Event so the capture thread will die
    if (m_rghEvent[ihEventTerminate])
    {
        SetEvent(m_rghEvent[ihEventTerminate]);
    }

    // Wait for the thread to die, then clean up
    if (m_hThread)
    {
        WaitObject(INFINITE, m_hThread);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    // Clean up our HEVENTs - set them to NULL in case
    // the waveInOpen callback retires some buffers.
    for (int ihEvent = chEvents-1; ihEvent >= 0; --ihEvent)
    {
        if (m_rghEvent[ihEvent])
        {
            HANDLE h = m_rghEvent[ihEvent];
            m_rghEvent[ihEvent] = NULL;
            CloseHandle(h);
        }
    }

    if (m_hwi)
    {
        // Ignore errors since it's too late to do anything
        waveInReset(m_hwi);

        // Stop recording from input device, if we got cutoff
        if (m_dwState & VAD_BUFFERSTATE_STARTED)
        {
            waveInStop(m_hwi);
        }

        // Need to unprepare all the headers
        if (m_rgpwhdr)
        {
            int iwhdr;
            LPWAVEHDR pwhdr;

            for (iwhdr = m_cwhdr, pwhdr = m_rgpwhdr;
                 iwhdr > 0; --iwhdr, ++pwhdr)
            {
                if (WHDR_PREPARED & pwhdr->dwFlags)
                {
                    waveInUnprepareHeader(m_hwi, pwhdr, sizeof(WAVEHDR));
                }
            }
        }

        // Close the input device
        CloseWaveIn(&m_hwi);

        // If this is not focus aware, mark device as unallocated.
        if (!(m_dwFlags & DSCBCAPS_FOCUSAWARE) && m_pDevice)
        {
            ((CEmCaptureDevice *)m_pDevice)->m_fAllocated = FALSE;
            ((CEmCaptureDevice *)m_pDevice)->m_hwi        = NULL;
        }
    }

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    EnterCriticalSection(&m_cs);

    MEMFREE(m_pwfx);
    MEMFREE(m_rgpwhdr);
    MEMFREE(m_rgpdsbpn);

    LeaveCriticalSection(&m_cs);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    m_fCritSectsValid = FALSE;
    DeleteCriticalSection(&m_csPN);
    DeleteCriticalSection(&m_cs);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes CEmCaptureWaveBuffer object
 *
 *  Arguments:
 *      DWORD [in] : flags
 *      DWORD [in] : size of buffer in bytes
 *      LPCWAVEFORMATEX [in] : format for buffer
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::Initialize"

HRESULT CEmCaptureWaveBuffer::Initialize(DWORD dwFlags, DWORD dwBufferBytes, LPCWAVEFORMATEX pwfxFormat)
{
    HRESULT hr;

    DPF_ENTER();

    // Validate params
    if (!IS_VALID_READ_PTR(pwfxFormat, sizeof(WAVEFORMATEX)))
    {
        RPF(DPFLVL_ERROR, "Invalid wave format pointer");
        goto InvalidParam;
    }

    if(!IsValidWfx(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid wave format");
        goto InvalidParam;
    }

    if (pwfxFormat->nBlockAlign == 0 ||
        dwBufferBytes < pwfxFormat->nBlockAlign ||
        dwBufferBytes % pwfxFormat->nBlockAlign != 0)
    {
        RPF(DPFLVL_ERROR, "Invalid buffer size (must be a multiple of nBlockAlign)");
        goto InvalidParam;
    }

    if (~DSCBCAPS_VALIDFLAGS & dwFlags)
    {
        RPF(DPFLVL_ERROR, "Invalid DSCBCAPS flags");
        goto InvalidParam;
    }

    if (DSCBCAPS_CTRLFX & dwFlags)
    {
        RPF(DPFLVL_ERROR, "DSBCAPS_CTRLFX not allowed on emulated capture device");
        goto InvalidParam;
    }

    m_dwFlags = dwFlags;

    // Make a copy of the wave format
    m_pwfx = CopyWfxAlloc(pwfxFormat);
    if (NULL == m_pwfx)
    {
        DPF(DPFLVL_ERROR, "Unable to allocate WFX");
        hr = DSERR_OUTOFMEMORY;
        goto Error;
    }

    hr = CCaptureWaveBuffer::Initialize(dwBufferBytes);
    if (FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Unable to initialize CCaptureWaveBuffer");
        goto Error;
    }

    // Make a copy of important info
    m_cbBuffer = m_pSysMemBuffer->GetSize();
    m_pBufferProcessed = m_pBufferNext = m_pBuffer = m_pSysMemBuffer->GetWriteBuffer();

    // Calculate the end of the buffer
    m_pBufferMac = m_pBuffer + m_cbBuffer;

    // Record Chunk should be 10 ms long to match the IRP sizes used by kmixer
    m_cbRecordChunk = m_pwfx->nAvgBytesPerSec / 32;

    // Round up to multiple of nBlockAlign (required for waveInAddBuffer recording)
    m_cbRecordChunk = BLOCKALIGNPAD(m_cbRecordChunk, m_pwfx->nBlockAlign);

    ASSERT(sizeof(m_rgszEvent[ihEventFocusChange]) >= 7+8+8+1);
    wsprintf(m_rgszEvent[ihEventFocusChange], TEXT("DSC-EFC%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_rgszEvent[ihEventWHDRDone]) >= 7+8+8+1);
    wsprintf(m_rgszEvent[ihEventWHDRDone], TEXT("DSC-EWD%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_rgszEvent[ihEventTerminate]) >= 6+8+8+1);
    wsprintf(m_rgszEvent[ihEventTerminate], TEXT("DSC-ET%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_rgszEvent[ihEventThreadStart]) >= 7+8+8+1);
    wsprintf(m_rgszEvent[ihEventThreadStart], TEXT("DSC-ETS%08lX%08lX"), GetCurrentProcessId(), this);

    // The first two events we want to be auto-reset
    // The third event, we want to stay signaled until reset
    static const BOOL rgfEvent[chEvents] = {FALSE, FALSE, FALSE, TRUE};

    for (int ihEvent = 0; ihEvent < chEvents; ++ihEvent)
    {
        m_rghEvent[ihEvent] = CreateEvent(NULL, rgfEvent[ihEvent], FALSE, m_rgszEvent[ihEvent]);
        if (NULL == m_rghEvent[ihEvent])
        {
            RPF(DPFLVL_ERROR, "Unable to create event");
            hr = WIN32ERRORtoHRESULT(GetLastError());
            goto Error;
        }
    }

    // Attempt to set the selected format
    CEmCaptureDevice *pDevice = (CEmCaptureDevice *)m_pDevice;
    hr = pDevice->SetGlobalFormat(this, m_pwfx, waveInCallback, dwFlags);
    m_hwi = pDevice->HWaveIn();

    if (FAILED(hr))
    {
        RPF(DPFLVL_ERROR, "Unable to set global device format");
        goto Error;
    }

    // Calculate number of blocks of size m_cbRecordChunk bytes
    m_cwhdr = m_cbBuffer / m_cbRecordChunk;

    // See if we have a partial-sized last block
    if (m_cbBuffer % m_cbRecordChunk)
        ++m_cwhdr;

    // Create at most cwhdrDefault WAVEHDRs
    if (m_cwhdr > cwhdrDefault)
        m_cwhdr = cwhdrDefault;

    ASSERT(m_cwhdr > 0);
    m_cwhdrDropped = m_cwhdr;

    // Allocate space for WAVEHDR arrays
    m_rgpwhdr = MEMALLOC_A(WAVEHDR, m_cwhdr);
    if (NULL == m_rgpwhdr)
    {
        DPF(DPFLVL_ERROR, "Unable to allocate WAVEHDRs");
        hr = DSERR_OUTOFMEMORY;
        goto Error;
    }

    // Create worker thread
    DWORD dwThreadID;
    m_hThread = CreateThread(NULL, 0, CEmCaptureWaveBuffer::CaptureThreadStatic, this, 0, &dwThreadID);
    if (NULL == m_hThread)
    {
        RPF(DPFLVL_ERROR, "Unable to create thread");
        hr = WIN32ERRORtoHRESULT(GetLastError());
        goto Error;
    }

    // If this is not focus aware, mark device as allocated.
    if (!(m_dwFlags & DSCBCAPS_FOCUSAWARE))
    {
        pDevice->m_fAllocated = TRUE;
    }

    hr = DS_OK;

Error:
    DPF_LEAVE_HRESULT(hr);
    return hr;

InvalidParam:
    hr = DSERR_INVALIDPARAM;
    goto Error;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Gets capabilities for the device.
 *
 *  Arguments:
 *      LPDSCBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::GetCaps"

HRESULT CEmCaptureWaveBuffer::GetCaps(LPDSCBCAPS pDsbcCaps)
{
    DPF_ENTER();

    ASSERT(sizeof(*pDsbcCaps) == pDsbcCaps->dwSize);

    pDsbcCaps->dwFlags = m_dwFlags;
    pDsbcCaps->dwBufferBytes = m_pSysMemBuffer->GetSize();
    pDsbcCaps->dwReserved = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::GetState"

HRESULT CEmCaptureWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();

    ASSERT(pdwState);

    *pdwState = m_dwState & VAD_SETSTATE_MASK;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Gets the current capture/read positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives capture cursor position.
 *      LPDWORD [out]: receives read cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::GetCursorPosition"

HRESULT CEmCaptureWaveBuffer::GetCursorPosition(LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition)
{
    HRESULT hr = DS_OK;
    DWORD dwRead;

    DPF_ENTER();

    if (!(DSCBCAPS_FOCUSAWARE & m_dwFlags))
    {
        // If we've successfully opened the waveIn device
        if (NULL == m_hwi)
        {
            hr = DSERR_INVALIDPARAM;
            goto Error;
        }
    }

    dwRead = ((m_dwCaptureCur + m_dwCaptureLast) % m_cbBuffer);

    // get the current positions
    if (pdwReadPosition)
    {
        *pdwReadPosition = dwRead;
    }

    if (pdwCapturePosition)
    {
        MMTIME      mmt;
        MMRESULT    mmr;

        //==========================================================//
        //                  Enter Critical section                  //
        //                                                          //
        EnterCriticalSection(&m_cs);

        if (m_hwi)
        {
            mmt.wType = TIME_BYTES;
            mmr = waveInGetPosition(m_hwi, &mmt, sizeof(mmt));
            if (MMSYSERR_NOERROR != mmr)
            {
                hr = MMRESULTtoHRESULT(mmr);
            }
            else
            {
                if ((TIME_BYTES == mmt.wType) && (m_dwState & VAD_BUFFERSTATE_STARTED))
                {
                    *pdwCapturePosition = ((mmt.u.cb + m_dwCaptureLast) % m_cbBuffer);
                }
                else
                {
                    // Don't know how to handle anything other than TIME_BYTES so
                    // we fall back to using the current valid recorded data offset
                    *pdwCapturePosition = dwRead;
                }
            }
        }
        else
        {
            // This is a focus aware buffer, and it is stopped.
            *pdwCapturePosition = dwRead;
        }

        LeaveCriticalSection(&m_cs);
        //                                                          //
        //                 Leave Critical Section                   //
        //==========================================================//
    }

Error:
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::SetNotificationPositions"

HRESULT CEmCaptureWaveBuffer::SetNotificationPositions(DWORD cpn, LPCDSBPOSITIONNOTIFY pdsbpn)
{
    HRESULT hr = DS_OK;

    DPF_ENTER();

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    if (cpn)
    {
        // need to grow array?
        if (m_cpnAllocated < cpn)
        {
            LPDSBPOSITIONNOTIFY ppnT;

            ppnT = MEMALLOC_A(DSBPOSITIONNOTIFY, cpn);
            if (NULL == ppnT)
            {
                hr = DSERR_OUTOFMEMORY;
                goto Done;
            }

            MEMFREE(m_rgpdsbpn);

            m_rgpdsbpn = ppnT;
            m_cpnAllocated = cpn;
        }

        CopyMemory(m_rgpdsbpn, pdsbpn, sizeof(DSBPOSITIONNOTIFY)*cpn);
    }

    m_cpn = cpn;
    m_ipn = 0;

Done:
    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::SetState"

HRESULT CEmCaptureWaveBuffer::SetState(DWORD dwState)
{
    HRESULT     hr = DS_OK;
    MMRESULT    mmr = MMSYSERR_NOERROR;
    DWORD       fdwOpen;

    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, VAD_SETSTATE_MASK));
    ASSERT(m_hwi || (m_dwFlags & DSCBCAPS_FOCUSAWARE));

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_cs);

    if (dwState != m_dwState)
    {
        if (dwState & VAD_BUFFERSTATE_STARTED) // Need to start capturing
        {
            BOOL fStarted = TRUE;

            // If we're focus aware, check if we have focus...
            if (DSCBCAPS_FOCUSAWARE & m_dwFlags)
            {
                if (m_dwState & VAD_BUFFERSTATE_INFOCUS)
                {
                    fdwOpen = CALLBACK_FUNCTION;
                    fdwOpen |= ((DSCBCAPS_WAVEMAPPED & m_dwFlags) ? WAVE_MAPPED : 0);

                    if (NULL == m_hwi)
                    {
                        hr = OpenWaveIn(&m_hwi, m_pDevice->m_pDeviceDescription->m_uWaveDeviceId, m_pwfx,
                                        (DWORD_PTR)CEmCaptureWaveBuffer::waveInCallback, (DWORD_PTR)this, fdwOpen);
                    }
                }
                else
                {
                    // Set these flags so that when the buffer DOES get
                    // focus, it will start properly
                    DPF(DPFLVL_MOREINFO, "Start called but buffer has no focus: 0x%08lx (%08lx)", m_dwState, this);
                    m_fdwSavedState |= (dwState & (VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING));
                    fStarted = FALSE;
                }
            }

            if (SUCCEEDED(hr) && fStarted)
            {
                // Make sure worker thread is running
                DWORD dwResult = WaitObject(INFINITE, m_rghEvent[ihEventThreadStart]);
                ASSERT(WAIT_OBJECT_0 == dwResult);

                // Are we not capturing yet?
                if (!(m_dwState & VAD_BUFFERSTATE_STARTED))
                {
                    LONG iwhdr = 0;
                    while ((m_cwhdrDropped > 0) &&
                           ((dwState & VAD_BUFFERSTATE_LOOPING) || (m_cLoops == 0)))
                    {
                        LPWAVEHDR pwhdr = m_rgpwhdr + iwhdr;

                        hr = QueueWaveHeader(pwhdr);
                        if (FAILED(hr))
                        {
                            DPF(DPFLVL_ERROR, "QueueWaveHeader failed");
                            goto Error;
                        }

                        ++iwhdr;
                        ASSERT(iwhdr <= m_cwhdr);
                        InterlockedDecrement(&m_cwhdrDropped);
                    }

#ifdef DEBUG
                    if (m_cwhdrDropped != 0)
                        ASSERT(!(VAD_BUFFERSTATE_LOOPING & dwState));
#endif

                    // Calling waveInStart more than once doesn't result in errors
                    mmr = waveInStart(m_hwi);

                    hr = MMRESULTtoHRESULT(mmr);
                    if (SUCCEEDED(hr))
                    {
                        // We're not stopped, we're in capture mode now
                        m_dwState &= ~(DSCBSTATUS_STOPPING | DSCBSTATUS_STOPPED);
                        m_dwState |= VAD_BUFFERSTATE_STARTED;
                        m_fdwSavedState |= VAD_BUFFERSTATE_STARTED;

                        // Are we looping?
                        if (VAD_BUFFERSTATE_LOOPING & dwState)
                        {
                            m_dwState |= VAD_BUFFERSTATE_LOOPING;
                            m_fdwSavedState |= VAD_BUFFERSTATE_LOOPING;
                        }
                        else
                        {
                            m_dwState &= ~VAD_BUFFERSTATE_LOOPING;
                            m_fdwSavedState &= ~VAD_BUFFERSTATE_LOOPING;
                        }

                        // Update to next WAVEHDR expected
                        m_iwhdrDone = 0;

                        // Remember last valid position
                        m_dwCaptureLast += m_dwCaptureCur;

                        m_dwCaptureCur = 0;
                    }
                }
            }
        }
        else if (dwState == VAD_BUFFERSTATE_INFOCUS)
        {
            // Focus-aware buffers start capturing when they gain focus
            if ((m_dwFlags & DSCBCAPS_FOCUSAWARE) &&
                !((CEmCaptureDevice*)m_pDevice)->m_fAllocated)
            {
                // Update m_dwState according to the dwState argument
                m_dwState &= ~VAD_FOCUSFLAGS;
                m_dwState |= VAD_BUFFERSTATE_INFOCUS;

                // Signal CaptureThread to handle the state change
                if (!(m_dwState & VAD_BUFFERSTATE_STARTED))
                {
                    HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_rgszEvent[ihEventFocusChange]);
                    ASSERT(hEvent);
                    SetEvent(hEvent);
                    CloseHandle(hEvent);
                }
            }
        }
        else if (dwState & (VAD_BUFFERSTATE_OUTOFFOCUS | VAD_BUFFERSTATE_LOSTCONSOLE))
        {
            // If we are focus-aware and the capture focus state is changing...
            if ((m_dwFlags & DSCBCAPS_FOCUSAWARE) &&
                (m_dwState & VAD_FOCUSFLAGS) != dwState)
            {
                // Update m_dwState according to the dwState argument
                m_dwState &= ~VAD_FOCUSFLAGS;
                m_dwState |= dwState;

                // Signal CaptureThread to handle the state change
                HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_rgszEvent[ihEventFocusChange]);
                ASSERT(hEvent);
                SetEvent(hEvent);
                CloseHandle(hEvent);
            }
        }
        else // VAD_BUFFERSTATE_STOPPED case; need to stop capturing
        {
            ASSERT(dwState == VAD_BUFFERSTATE_STOPPED);  // By elimination

            // Are we currently capturing?
            if (VAD_BUFFERSTATE_STARTED & m_dwState)
            {
                // We're stopping capturing data
                m_dwState |= DSCBSTATUS_STOPPING;

                // Stop recording from input device
                if (m_hwi)
                {
                    // Make sure buffers are flushed
                    mmr = waveInReset(m_hwi);
#ifdef DEBUG_CAPTURE
                    DPF(DPFLVL_INFO, "Called waveInReset(0x%08lx) = 0x%08lx", m_hwi, mmr);
#endif
                    mmr = waveInStop(m_hwi);
#ifdef DEBUG_CAPTURE
                    DPF(DPFLVL_INFO, "Called waveInStop(0x%08lx) = 0x%08lx", m_hwi, mmr);
#endif
                }
                hr = MMRESULTtoHRESULT(mmr);

                // We've stopped capturing data
                m_dwState |= DSCBSTATUS_STOPPED;
                m_dwState &= ~(VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING);

                // CaptureThread will handle STOP position notifications
                // when the last living WAVEHDR is processed
            }

            // Not looping; not capturing.
            m_fdwSavedState = 0L;
        }
    }

Error:
    LeaveCriticalSection(&m_cs);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  NotifyStop
 *
 *  Description:
 *      Sets any events that are supposed to set when capturing stops
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      None.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::NotifyStop"

void CEmCaptureWaveBuffer::NotifyStop(void)
{
    DPF_ENTER();

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    // Signal any STOP notifications - only one allowed
    //
    if ((m_cpn > 0) && (DSBPN_OFFSETSTOP == m_rgpdsbpn[m_cpn-1].dwOffset))
    {
        // SetEvent can fault if handle was cleaned up out from under us
        // on process termination. In this case we will try to do a stop
        // notification when the capture buffer is being destroyed.
        try
        {
            SetEvent(m_rgpdsbpn[m_cpn-1].hEventNotify);
        }
        catch (...) {}
    }

    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  QueueWaveHeader
 *
 *  Description:
 *      Queues wave header in the waveIn queue
 *
 *  Arguments:
 *      LPWAVEHDR [in] : WAVEHDR to queue
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::QueueWaveHeader"

HRESULT CEmCaptureWaveBuffer::QueueWaveHeader(LPWAVEHDR pwhdr)
{
    DPF_ENTER();

    pwhdr->lpData = (LPSTR)m_pBufferNext;

    // does capture buffer extend beyond end of buffer?
    if ((m_pBufferNext + m_cbRecordChunk) > m_pBufferMac)
    {
        // then use whatever is left
        // this should only happen on last WAVEHDR
        pwhdr->dwBufferLength = PtrDiffToUlong(m_pBufferMac - m_pBufferNext);
    }
    else
    {
        pwhdr->dwBufferLength = m_cbRecordChunk;
    }

    ASSERT((LPBYTE)pwhdr->lpData == m_pBufferNext);
    ASSERT((m_pBufferNext + pwhdr->dwBufferLength) <= m_pBufferMac);

#ifdef DEBUG_CAPTURE
    // OutputDbgWHDR("Queue: ", pwhdr - m_rgpwhdr, pwhdr);  // Vestiges of old debug traces
#endif

    ASSERT(m_hwi);
    ASSERT(!(pwhdr->dwFlags & WHDR_PREPARED));
    ASSERT(!(pwhdr->dwFlags & WHDR_DONE));

    MMRESULT mmr = waveInPrepareHeader(m_hwi, pwhdr, sizeof(WAVEHDR));
    if (MMSYSERR_NOERROR == mmr)
    {
        mmr = waveInAddBuffer(m_hwi, pwhdr, sizeof(WAVEHDR));

        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(DPFLVL_ERROR, "waveInAddBuffer failed: 0x%08lx", mmr);
            ASSERT(MMSYSERR_NOERROR == mmr);
        }

        // Mark header as queued
        pwhdr->dwUser = 0xdead0000;
    }
    else
    {
        DPF(DPFLVL_ERROR, "waveInPrepareHeader failed: 0x%08lx", mmr);
        ASSERT(MMSYSERR_NOERROR == mmr);
    }

    if (MMSYSERR_NOERROR != mmr)
    {
        waveInReset(m_hwi);
        DPF(DPFLVL_INFO, "Called waveInReset()");
    }
    else
    {
        m_pBufferNext += pwhdr->dwBufferLength;

        // Wraparound?
        if (m_pBufferNext >= m_pBufferMac)
        {
            m_pBufferNext = m_pBuffer;
            m_cLoops += 1;
        }
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  waveInCallback
 *
 *  Description:
 *      Called by system when a WAVEHDR has been processed
 *
 *  Arguments:
 *      HWAVEIN [in] :
 *      UINT [in] :
 *      DWORD [in] :
 *      DWORD [in] :
 *      DWORD [in] :
 *
 *  Returns:
 *      Nothing
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::waveInCallback"

void CALLBACK CEmCaptureWaveBuffer::waveInCallback(HWAVEIN hwi, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    CEmCaptureWaveBuffer *pThis = (CEmCaptureWaveBuffer *)dwInstance;
    if (WIM_DATA == uMsg && pThis->m_rghEvent[ihEventWHDRDone])
    {
        // Need this check for pThis->m_rghEvent[ihEventWHDRDone] != 0 here, because
        // during shutdown we may free up the event and still get some last callbacks

        InterlockedIncrement(&pThis->m_cwhdrDone);
        SetEvent(pThis->m_rghEvent[ihEventWHDRDone]);

        #ifdef DEBUG_CAPTURE
        DWORD iwhdr = (LPWAVEHDR)dwParam1 - pThis->m_rgpwhdr;
        if (iwhdr != pThis->m_iwhdrExpected)
            DPF(DPFLVL_ERROR, "Expected wave header #%u, and got #u instead!", pThis->m_iwhdrExpected, iwhdr);
        pThis->m_iwhdrExpected = (iwhdr + 1) % pThis->m_cwhdr;
        // OutputDbgWHDR("Callback: ", iwhdr, pwhdr);  // Vestiges of old debug traces
        #endif

        // Mark as done from the callback function
        ((LPWAVEHDR)dwParam1)->dwUser = 0xdead0001;
    }
}


/***************************************************************************
 *
 *  CaptureThreadStatic
 *
 *  Description:
 *      Static helper function used to launch CaptureThread.
 *
 *  Arguments:
 *      LPVOID [in] : pointer to instance data
 *
 *  Returns:
 *      DWORD: return code (ignored - always 0)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::CaptureThread"

DWORD WINAPI CEmCaptureWaveBuffer::CaptureThreadStatic(LPVOID pv)
{
    ((CEmCaptureWaveBuffer*)pv)->CaptureThread();
    return 0;
}


/***************************************************************************
 *
 *  CaptureThread
 *
 *  Description:
 *      Processes WAVEHDRs and requeues them if necessary.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::CaptureThread"

void CEmCaptureWaveBuffer::CaptureThread()
{
    HANDLE rghEvent[3] = { m_rghEvent[ihEventTerminate],
                           m_rghEvent[ihEventWHDRDone],
                           m_rghEvent[ihEventFocusChange] };
    HRESULT hr;

    ASSERT(m_rghEvent[ihEventThreadStart]);
    SetEvent(m_rghEvent[ihEventThreadStart]);

    // DSOUND does a similar thing for the waveOut thread
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    while (TRUE)
    {
        // Wait for a Terminate or Capture Begin Event
        DWORD dwResultWait = WaitObjectArray(NUMELMS(rghEvent), INFINITE, FALSE, rghEvent);

        // Terminate?
        if (WAIT_OBJECT_0 + ihEventTerminate == dwResultWait)
            break;

        EnterCriticalSection(&m_cs);

        // Is this a focus change?
        if (WAIT_OBJECT_0 + ihEventFocusChange == dwResultWait)
        {
            DPF(DPFLVL_MOREINFO, "Focus change notification: 0x%08lx", m_dwState);

            if (m_dwState & VAD_BUFFERSTATE_INFOCUS)
            {
                if (VAD_BUFFERSTATE_STARTED & m_fdwSavedState)
                {
                    m_dwState &= ~(DSCBSTATUS_STOPPED | DSCBSTATUS_STOPPING);
                    m_dwState |= DSCBSTATUS_CAPTURING;

                    if (VAD_BUFFERSTATE_LOOPING & m_fdwSavedState)
                    {
                        m_dwState |= VAD_BUFFERSTATE_LOOPING;
                    }
                }
                else
                {
                    // Buffer is already started, simply leave.
                    LeaveCriticalSection(&m_cs);
                    continue;
                }

                DPF(DPFLVL_MOREINFO, "Focus starting thread.");

                hr = DS_OK;
                if (m_hwi == NULL)
                {
                    DWORD fdwOpen = CALLBACK_FUNCTION;
                    fdwOpen |= ((DSCBCAPS_WAVEMAPPED & m_dwFlags) ? WAVE_MAPPED : 0);

                    for (UINT jj = 4; jj; jj--)
                    {
                        hr = OpenWaveIn(&m_hwi, m_pDevice->m_pDeviceDescription->m_uWaveDeviceId,
                                        m_pwfx, (DWORD_PTR)waveInCallback, (DWORD_PTR)this, fdwOpen);

                        if (SUCCEEDED(hr))
                            break;

                        DPF(DPFLVL_MOREINFO, "Focus change: waveInOpen failed with 0x%08lx; retrying after 20ms", hr);
                        Sleep(20);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    LONG ii = 0;
                    while ((m_cwhdrDropped > 0) &&
                           ((m_dwState & VAD_BUFFERSTATE_LOOPING) || (m_cLoops == 0)))
                    {
                        LPWAVEHDR pwhdr = m_rgpwhdr + ii;
                        hr = QueueWaveHeader(pwhdr);

                        if (FAILED(hr))
                        {
                            DPF(DPFLVL_ERROR, "QueueWaveHeader failed");
                            ASSERT(FALSE);
                        }

                        ++ii;
                        ASSERT(ii <= m_cwhdr);
                        InterlockedDecrement(&m_cwhdrDropped);
                    }

                    MMRESULT mmr = waveInStart(m_hwi);
                    ASSERT(MMSYSERR_NOERROR == mmr);

                    m_iwhdrDone = 0;
                }
            }
            else
            {
                if (m_dwState & VAD_BUFFERSTATE_STARTED)
                {
                    DPF(DPFLVL_MOREINFO, "Losing focus, stopping buffer");

                    m_dwState &= ~VAD_BUFFERSTATE_STOPPED;
                    m_dwState |= DSCBSTATUS_STOPPING;
                }
                else
                {
                    // Buffer is already stopped, simply leave.
                    LeaveCriticalSection(&m_cs);
                    continue;
                }

                if (m_hwi)
                {
                    DPF(DPFLVL_MOREINFO, "Focus stopping thread");
                    waveInReset(m_hwi);
                }
            }

            if (m_hEventFocus)
            {
                SetEvent(m_hEventFocus);
            }

            LeaveCriticalSection(&m_cs);
            continue;
        }

#ifdef DEBUG_CAPTURE
        DPF(DPFLVL_INFO, "Capture thread wakes");
#endif

        // If we get here, we must have been signaled on the only other
        // event we were listening for.  Let's make sure of that anyway.
        ASSERT(WAIT_OBJECT_0 + ihEventWHDRDone == dwResultWait);

        LONG l = InterlockedDecrement(&m_cwhdrDone);
        while (l >= 0)
        {
            // Quickly check if we should terminate
            dwResultWait = WaitObject(0, m_rghEvent[ihEventTerminate]);
            if (WAIT_OBJECT_0 == dwResultWait)
                break;

            WAVEHDR *pwhdr = m_rgpwhdr + m_iwhdrDone;

#ifdef DEBUG_CAPTURE
            DPF(DPFLVL_INFO, "Processing header #%u (pwhdr=0x%08lx)", m_iwhdrDone, pwhdr);
            // OutputDbgWHDR("Thread: ", m_iwhdrDone, pwhdr);  // Vestiges of old debug traces
#endif
            if (pwhdr->dwBytesRecorded)
            {
                BOOL fEndOfBuffer = FALSE;

                // Update number of recorded bytes
                m_dwCaptureCur += pwhdr->dwBytesRecorded;

                ASSERT(m_pBufferProcessed == (LPBYTE)pwhdr->lpData);
                m_pBufferProcessed += pwhdr->dwBytesRecorded;
                if (m_pBufferProcessed >= m_pBufferMac)
                {
                    m_pBufferProcessed = m_pBuffer;
                    fEndOfBuffer = TRUE;
                }

                // Grab critical section for position notify handling

                //==========================================================//
                //                  Enter Critical section                  //
                //                                                          //
                EnterCriticalSection(&m_csPN);

                // Scan for any position notifies that need to be signaled
                if (m_cpn)
                {
                    DWORD   ipnOld = m_ipn;
                    DWORD   dwBufferStart = PtrDiffToUlong((LPBYTE)pwhdr->lpData - m_pBuffer);
                    DWORD   dwBufferEnd = dwBufferStart + pwhdr->dwBytesRecorded;

                    // Is there a position.notify within the start.end of this
                    // captured data?
                    // Is the current position.notify to be signaled on Stop?

                    while (((m_rgpdsbpn[m_ipn].dwOffset >= dwBufferStart) &&
                            (m_rgpdsbpn[m_ipn].dwOffset < dwBufferEnd)) ||
                           (DSBPN_OFFSETSTOP == m_rgpdsbpn[m_ipn].dwOffset))
                    {
                        // Only signal if not for Stop pos.notify
                        if (DSBPN_OFFSETSTOP != m_rgpdsbpn[m_ipn].dwOffset)
                        {
                            SetEvent(m_rgpdsbpn[m_ipn].hEventNotify);
                        }

                        // go on to the next pos.notify
                        ++m_ipn;
                        // wraparound?
                        if (m_ipn >= m_cpn)
                        {
                            m_ipn = 0;
                        }

                        // Infinite loop?
                        if (m_ipn == ipnOld)
                        {
                            break;
                        }
                    }
                }

                LeaveCriticalSection(&m_csPN);
                //                                                          //
                //                 Leave Critical Section                   //
                //==========================================================//

                // Transition buffer to stop state:
                //   if the capture buffer end has been reached AND
                //   if the buffer is non-LOOPING AND
                //   if the buffer isn't in the middle of stopping
                //
                // Do this after the position notifications since STOP notification
                // is after any buffer-offset notification.

                if (fEndOfBuffer &&
                    !(m_dwState & VAD_BUFFERSTATE_LOOPING) &&
                    !(m_dwState & DSCBSTATUS_STOPPING))
                {
                    SetState(VAD_BUFFERSTATE_STOPPED);
                    ASSERT(m_dwState & DSCBSTATUS_STOPPING);
                    ASSERT((m_cwhdrDropped+1) == m_cwhdr);
                }
            }

            // Clear the WHDR_DONE flag
            pwhdr->dwFlags &= ~WHDR_DONE;

            // Reset to zero
            pwhdr->dwBytesRecorded = 0;

            MMRESULT mmr = waveInUnprepareHeader(m_hwi, pwhdr, sizeof(WAVEHDR));
            if (MMSYSERR_NOERROR != mmr)
            {
                DPF(DPFLVL_ERROR, "waveInUnprepareHeader returned %ld", mmr);
                if (WAVERR_STILLPLAYING == mmr)
                    DPF(DPFLVL_ERROR, "which is WAVERR_STILLPLAYING; reactivate bug 340919");
            }
            ASSERT(MMSYSERR_NOERROR == mmr);

            // We're stopping, let's drop everything
            if (m_dwState & DSCBSTATUS_STOPPING)
            {
Drop:
                InterlockedIncrement(&m_cwhdrDropped);

                // When all WAVEHDRs have been dropped
                if (m_cwhdrDropped == m_cwhdr)
                {
                    // Set the next point in the data buffer to capture to
                    m_pBufferNext = m_pBufferProcessed;
                    m_cLoops = 0;

                    // Notify user that we've stopped
                    NotifyStop();

                    // Focus aware buffers release the device on stop
                    if (DSCBCAPS_FOCUSAWARE & m_dwFlags)
                    {
                        if (m_hwi)
                        {
                            hr = CloseWaveIn(&m_hwi);
                            #ifdef DEBUG_CAPTURE
                                DPF(DPFLVL_INFO, "Closed waveIn and reset m_hwi = NULL");
                            #endif
                            ASSERT(SUCCEEDED(hr));
                        }
                        m_dwState &= ~(VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING);
                    }
                }
            }
            else
            {
                ASSERT(m_dwState & VAD_BUFFERSTATE_STARTED);

                // If we're LOOPING or we haven't reached the end of the buffer yet
                // then put the WAVEHDR back on to the queue with a new position
                // in the buffer, etc.
                BOOL fAddToQueue = (m_dwState & VAD_BUFFERSTATE_LOOPING) ||
                                   (m_pBufferNext > (LPBYTE)pwhdr->lpData);
                if (fAddToQueue)
                {
                    BOOL fDrop;
                    if (m_dwState & (DSCBSTATUS_STOPPED | DSCBSTATUS_STOPPING))
                    {
                        fDrop = TRUE;
                    }
                    else
                    {
                        hr = QueueWaveHeader(pwhdr);
                        ASSERT(SUCCEEDED(hr));
                        fDrop = FALSE;
                    }
                    if (fDrop)
                    {
                        goto Drop;
                    }
                }
                else
                {
                    InterlockedIncrement(&m_cwhdrDropped);

                    // If no WAVEHDRs are queued then if the user
                    // starts capturing again, we queue the WAVEHDRs from
                    // the beginning of our array
                    if (m_cwhdr == m_cwhdrDropped)
                    {
#ifdef DEBUG
                        if (!(m_dwState & VAD_BUFFERSTATE_LOOPING))
                            ASSERT(m_cLoops > 0);
#endif
                        // Notify user that we've stopped
                        NotifyStop();
                    }
                }
            }

            ++m_iwhdrDone;
            if (m_iwhdrDone >= m_cwhdr)
            {
                m_iwhdrDone = 0;
            }

            // On to the next one
            l = InterlockedDecrement(&m_cwhdrDone);
        }

        InterlockedIncrement(&m_cwhdrDone);
        if (WAIT_OBJECT_0 == dwResultWait)
        {
            LeaveCriticalSection(&m_cs);
            break;
        }
        LeaveCriticalSection(&m_cs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\emvad.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       emvad.h
 *  Content:    Emulated (via mmsystem APIs) Virtual Audio Device class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/1/97      dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifndef __EMVAD_H__
#define __EMVAD_H__

#ifdef DEBUG
// #define DEBUG_CAPTURE  // Uncomment this for some extra capture tracing
#endif

#ifdef __cplusplus

// The Emulated Audio Device class
class CEmRenderDevice : public CMxRenderDevice, private CUsesEnumStandardFormats
{
    friend class CEmPrimaryRenderWaveBuffer;

public:
    CEmRenderDevice(void);
    virtual ~CEmRenderDevice(void);

    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Creation
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCaps(LPDSCAPS);
    virtual HRESULT GetCertification(LPDWORD, BOOL) {return DSERR_UNSUPPORTED;}

    // Buffer management
    virtual HRESULT CreatePrimaryBuffer(DWORD, LPVOID, CPrimaryRenderWaveBuffer **);

protected:
    virtual HRESULT LockMixerDestination(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD);
    virtual HRESULT UnlockMixerDestination(LPVOID, DWORD, LPVOID, DWORD);

private:
    virtual BOOL EnumStandardFormatsCallback(LPCWAVEFORMATEX);
};

// The primary buffer
class CEmPrimaryRenderWaveBuffer : public CPrimaryRenderWaveBuffer
{
private:
    CEmRenderDevice* m_pEmDevice;   // Parent device

public:
    CEmPrimaryRenderWaveBuffer(CEmRenderDevice *, LPVOID);
    virtual ~CEmPrimaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(DWORD);

    // Buffer capabilities
    virtual HRESULT GetCaps(LPVADRBUFFERCAPS);

    // Access rights
    virtual HRESULT RequestWriteAccess(BOOL);

    // Buffer data
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dListener(C3dListener **);
};

inline HRESULT CEmPrimaryRenderWaveBuffer::CreatePropertySet(CPropertySet **)
{
    return DSERR_UNSUPPORTED;
}

// The emulated secondary buffer
class CEmSecondaryRenderWaveBuffer : public CSecondaryRenderWaveBuffer
{
private:
    CMxRenderDevice *       m_pMxDevice;                // Parent device
    CMixSource *            m_pMixSource;               // Mixer source
    PFIRCONTEXT             m_pFirContextLeft;          // FIR context used by the 3D filter
    PFIRCONTEXT             m_pFirContextRight;         // FIR context used by the 3D filter
    DWORD                   m_dwState;                  // Current buffer state

public:
    CEmSecondaryRenderWaveBuffer(CMxRenderDevice *, LPVOID);
    virtual ~CEmSecondaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(LPCVADRBUFFERDESC, CEmSecondaryRenderWaveBuffer *, CSysMemBuffer *);

    // Buffer creation
    virtual HRESULT Duplicate(CSecondaryRenderWaveBuffer **);

    // Buffer data
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCursorPosition(DWORD);

    // Buffer properties
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN);
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetChannelAttenuations(LONG, DWORD, const DWORD*, const LONG*);
#endif
    virtual HRESULT SetFrequency(DWORD, BOOL fClamp =FALSE);
    virtual HRESULT SetMute(BOOL);

    // Buffer position notifications
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dObject(C3dListener *, C3dObject **);

private:
    // Owned objects
    virtual HRESULT CreateItd3dObject(C3dListener *, C3dObject **);
};

inline HRESULT CEmSecondaryRenderWaveBuffer::CreatePropertySet(CPropertySet **)
{
    return DSERR_UNSUPPORTED;
}

// The emulated 3D object
class CEmItd3dObject : public CItd3dObject
{
private:
    CMixSource *            m_pMixSource;           // CMixSource used by the owning
    CMixDest *              m_pMixDest;             // CMixDest used by the owning
    PFIRCONTEXT             m_pContextLeft;         // Left channel FIR context
    PFIRCONTEXT             m_pContextRight;        // Right channel FIR context

public:
    CEmItd3dObject(C3dListener *, BOOL, BOOL, DWORD, CMixSource *, CMixDest *, PFIRCONTEXT, PFIRCONTEXT);
    virtual ~CEmItd3dObject(void);

protected:
    // Commiting 3D data to the device
    virtual HRESULT Commit3dChanges(void);
    virtual DWORD Get3dOutputSampleRate(void);

private:
    virtual void CvtContext(LPOBJECT_ITD_CONTEXT, PFIRCONTEXT);
};

class CEmCaptureDevice : public CCaptureDevice, private CUsesEnumStandardFormats
{
    friend class CEmCaptureWaveBuffer;

private:
    LPWAVEFORMATEX  m_pwfxFormat;   // Device format
    HWAVEIN         m_hwi;          // WaveIn device handle

protected:
    DWORD           m_fAllocated;   // Allocated

public:
    CEmCaptureDevice();
    virtual ~CEmCaptureDevice();

    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device caps
    virtual HRESULT GetCaps(LPDSCCAPS);
    virtual HRESULT GetCertification(LPDWORD, BOOL);

    // Buffer management
    virtual HRESULT CreateBuffer(DWORD, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *, LPVOID, CCaptureWaveBuffer **);

    HRESULT SetGlobalFormat(LPVOID, LPCWAVEFORMATEX, LPVOID, DWORD);
    HWAVEIN HWaveIn(void);

private:
    virtual BOOL EnumStandardFormatsCallback(LPCWAVEFORMATEX);
};

inline HRESULT CEmCaptureDevice::GetCertification(LPDWORD pdwCertification, BOOL fGetCaps)
{
    return DSERR_UNSUPPORTED;
}

inline HWAVEIN CEmCaptureDevice::HWaveIn(void)
{
    return m_hwi;
}

// Base class for wave capturing buffers
class CEmCaptureWaveBuffer : public CCaptureWaveBuffer
{
#ifndef NOKS
    friend class CKsCaptureWaveBuffer;
#endif

private:
    enum { cwhdrDefault = 8 };
    enum { IWHDR_INVALID = -1 };

    enum
    {
        ihEventTerminate = 0,
        ihEventWHDRDone,
        ihEventFocusChange,
        ihEventThreadStart,
        chEvents
    };

    DWORD           m_dwState;      // state of buffer, i.e. capturing or not
    DWORD           m_fdwSavedState;// last buffer state set (ignoring capture focus)

    LONG            m_cwhdr;        // number of capture buffers
    LPWAVEHDR       m_rgpwhdr;      // array of WAVEHDRs for capturing
    LONG            m_cwhdrDone;    // count of WHDRs captured
    LONG            m_iwhdrDone;

    LPBYTE          m_pBuffer;      // buffer for data
    DWORD           m_cbBuffer;     // size of buffer
    DWORD           m_cbRecordChunk;// capture chunk size used for waveInAddBuffer
    LPBYTE          m_pBufferMac;   // end of buffer for data
    LPBYTE          m_pBufferNext;  // next part of buffer to be queued
    DWORD           m_cLoops;       // how many times we've looped around
    LPWAVEFORMATEX  m_pwfx;         // WAVEFORMATEX to capture in
    HWAVEIN         m_hwi;          // HWAVEIN for opened wave device

    DWORD           m_cpn;          // count of position.notifies
    LPDSBPOSITIONNOTIFY m_rgpdsbpn; // array of position.notifies
    DWORD           m_ipn;          // index to current pn - previous ones have been processed
    DWORD           m_cpnAllocated; // max available slots in m_rgdwPosition and m_rghEvent arrays

    BOOL            m_fCritSectsValid;// Critical sections currently OK
    CRITICAL_SECTION    m_cs;       // critical section to protect multi-thread access
    CRITICAL_SECTION    m_csPN;     // critical section to protect multi-thread access
                                    // used for position notification processing

    DWORD           m_dwCaptureCur; // offset to last processed capture head position
                                    // i.e. data up to this point is valid
    DWORD           m_dwCaptureLast;// offset into buffer where capturing stopped last

    HANDLE          m_hThread;      // handle of worker thread

    LONG            m_cwhdrDropped;
    LPBYTE          m_pBufferProcessed;

    HANDLE          m_rghEvent[chEvents];   // array of HEVENTs
    TCHAR           m_rgszEvent[chEvents][32];  // array of names for HEVENTs

    void            NotifyStop(void);
    HRESULT         QueueWaveHeader(LPWAVEHDR);

    #ifdef DEBUG_CAPTURE
    DWORD           m_iwhdrExpected; // Used to verify callback order
    #endif

public:
    CEmCaptureWaveBuffer(CCaptureDevice *);
    virtual ~CEmCaptureWaveBuffer();

    // Initialization
    virtual HRESULT Initialize(DWORD, DWORD, LPCWAVEFORMATEX);

    // Buffer capabilities
    virtual HRESULT GetCaps(LPDSCBCAPS);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Callback function specified in waveInOpen
    //
    // From the SDK:
    // "Applications should not call any system-defined functions from inside a
    //  callback function, except for EnterCriticalSection, LeaveCriticalSection,
    //  midiOutLongMsg, midiOutShortMsg, OutputDebugString, PostMessage,
    //  PostThreadMessage, SetEvent, timeGetSystemTime, timeGetTime, timeKillEvent,
    //  and timeSetEvent. Calling other wave functions will cause deadlock."
    //
    static void CALLBACK waveInCallback(HWAVEIN hwi, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    static DWORD WINAPI CaptureThreadStatic(LPVOID pv);
    void CaptureThread();
};

#endif // __cplusplus

#endif // __EMVAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\filter.c ===
//--------------------------------------------------------------------------;
//
//  File: filter.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  3D filter functions called by the mixer.  This code is built in ring 3
//  and ring 0.
//
//  History:
//  07/09/96    DannyMi     Created 
//
//--------------------------------------------------------------------------;

#define NODSOUNDSERVICETABLE

#include "dsoundi.h"
#include "vector.h"

#ifndef Not_VxD

#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG

// don't ask
BYTE _fltused;

#endif /* Not_VxD */


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

// This is the 3D mixing code.  Grace gives us a sample that it was going to
// play, and we return a different number (that sample with 3D effects) which
// Grace will use instead.

// We cache a whole bunch of samples that she has sent us, because we are
// premixing some sound that may get thrown away, and we need be able to back
// up and find out what samples we were given BEFORE the point we rewind to.
// We also need to know some of the 3D parameters we were using at the point
// we rewind to, because if we don't revert to using the same parameters as
// we were the first time through, you will hear that as an audible glitch.

// But we are saving a sample cache of 10K samples or so, and to save the 3D
// state for each sample would take about 1Meg per 3D sound!  There's no way
// we can afford to do that.  So we save our state every 128 samples, and have
// a private agreement with Grace that she will always rewind us on 128 sample
// boundaries.

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

//
// Here is a simple float to long conversion that has unpredictable rounding
//
__inline LONG FloatToLongRX(float f)
{
    LONG l;

#ifdef USE_INLINE_ASM
    _asm fld f;
    _asm fistp l;
#else
    l = (long) f;
#endif

    return l;
}

// We will need to remember at least cSamples in our cache, because that is
// how much we may be asked to rewind.  The actual cache size we use must be
// a power of 2 for the math to work in FirNextSample
//
BOOL FilterPrepare(PFIRCONTEXT pfir, int cSamples)
{
#ifdef Not_VxD
    DPF(1, "FilterPrepare: this 3D channel needs a %d sample cache", cSamples);
#else
    DPF(("FilterPrepare: this 3D channel needs a %d sample cache", cSamples));
#endif

    //DPF(0, "~`FP ");

    // we already have a cache big enough
    if (pfir->cSampleCache && pfir->cSampleCache >= cSamples) {
#ifdef Not_VxD
        DPF(1, "Our current cache of %d is big enough", pfir->cSampleCache);
#else
        DPF(("Our current cache of %d is big enough", pfir->cSampleCache));
#endif
        return TRUE;
    }

    MEMFREE(pfir->pSampleCache);

    // !!! is this necessary?
    // find the next higher power of 2
    pfir->cSampleCache = 1;
    cSamples -= 1;
    while (cSamples >= 1) {
        cSamples >>= 1;
        pfir->cSampleCache <<= 1;
    }

    // if we're not at least this big, we can't do our left-right delay and low
    // pass filter
    if (pfir->cSampleCache < CACHE_MINSIZE)
        pfir->cSampleCache = CACHE_MINSIZE;

    pfir->pSampleCache = MEMALLOC_A(LONG, pfir->cSampleCache);
    if (pfir->pSampleCache == NULL) {
#ifdef Not_VxD
        DPF(0, "**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!");
#else
        DPF(("**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!"));
#endif
        pfir->cSampleCache = 0;
        return FALSE;
    }

    // We need 1/128th as many entries for saving our state
    pfir->cStateCache = pfir->cSampleCache / MIXER_REWINDGRANULARITY + 1;
    pfir->pStateCache = MEMALLOC_A(FIRSTATE, pfir->cStateCache);
    if (pfir->pStateCache == NULL) {
#ifdef Not_VxD
        DPF(0, "**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!");
#else
        DPF(("**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!"));
#endif
        MEMFREE(pfir->pSampleCache);
        pfir->cStateCache = 0;
        pfir->cSampleCache = 0;
        return FALSE;
    }

#ifdef Not_VxD
    DPF(1, "Using a %d sample and %d state cache", pfir->cSampleCache, pfir->cStateCache);
#else
    DPF(("Using a %d sample and %d state cache", pfir->cSampleCache, pfir->cStateCache));
#endif

    return TRUE;
}


// free our cache stuff
//
void FilterUnprepare(PFIRCONTEXT pfir)
{
#ifdef Not_VxD
    DPF(1, "FilterUnprepare:");
#else
    DPF(("FilterUnprepare:"));
#endif
    MEMFREE(pfir->pSampleCache);
    MEMFREE(pfir->pStateCache);
    pfir->pSampleCache = NULL;
    pfir->cSampleCache = 0;
    pfir->pStateCache = NULL;
    pfir->cStateCache = 0;
}

// clear our filter of cached samples - we're starting to play
//
void FilterClear(PFIRCONTEXT pfir)
{
#ifdef Not_VxD
    DPF(1, "FilterClear:");
#else
    DPF(("FilterClear:"));
#endif
    //DPF(0, "~`FC ");

    if (pfir->pSampleCache) {
        ZeroMemory(pfir->pSampleCache, pfir->cSampleCache * sizeof(LONG));
    }
    if (pfir->pStateCache) {
        ZeroMemory(pfir->pStateCache, pfir->cStateCache * sizeof(FIRSTATE));
        // clearing is a time to save our first state information.
        // !!! is this right?
        pfir->pStateCache[0].LastDryAttenuation = pfir->LastDryAttenuation;
        pfir->pStateCache[0].LastWetAttenuation = pfir->LastWetAttenuation;
#ifdef SMOOTH_ITD
        pfir->pStateCache[0].iLastDelay = pfir->iLastDelay;
#endif
    }
    pfir->iCurSample = 0;

    
    if (pfir->cStateCache > 1)
        pfir->iCurState = 1;    // next time we save it'll be at location 1
    pfir->iStateTick = 0;       // have seen no samples since saving

    return;
}

// Throw away the most recent cSamples we got - the filter is remixing them.
// Go back to our state cSamples ago, and do those samples over again.
// !!! Clear out the range being advanced over?
//
void FilterAdvance(PFIRCONTEXT pfir, int cSamples)
{
    pfir->iStateTick += cSamples;
    pfir->iStateTick %= MIXER_REWINDGRANULARITY;
    ASSERT(pfir->iStateTick < MIXER_REWINDGRANULARITY);
    //DPF(0, "~`FA%X %X ", cSamples, pfir->iStateTick);
}

void FilterRewind(PFIRCONTEXT pfir, int cSamples)
{
    int iRewind;

    ASSERT(pfir->iStateTick < MIXER_REWINDGRANULARITY);

    // !!! What if we back up to the beginning? we won't clear the cache!

    // we're only allowed to back up to a 128 sample boundary
    if (cSamples <=0 || cSamples > pfir->cSampleCache ||
        ((cSamples - pfir->iStateTick) & (MIXER_REWINDGRANULARITY - 1))) {
#ifdef Not_VxD
        DPF(0, "*** Error: Rewinding an invalid number %d (current remainder is %d)!", cSamples, pfir->iStateTick);
#else
        DPF(("*** Error: Rewinding an invalid number %d (current remainder is %d)!", cSamples, pfir->iStateTick));
#endif
        return;
    }
    //DPF(0, "~`FR%X %X ", cSamples, pfir->iStateTick);

    // how far back in our state cache do we go?  Each 128 samples we back up
    // means backing up 1 entry in our state cache, plus 1 because we're 
    // currently pointing one past the last one we saved.
    iRewind = (cSamples - pfir->iStateTick) / MIXER_REWINDGRANULARITY + 1;

    // rewind cSamples in our circular queue
    pfir->iCurSample = (pfir->iCurSample - cSamples) & (pfir->cSampleCache - 1);

#ifdef Not_VxD
    DPF(1, "FilterRewind: rewind %d samples, and %d states", cSamples, iRewind);
#else
    DPF(("FilterRewind: rewind %d samples, and %d states", cSamples, iRewind));
#endif

    // remember how we were doing 3D back then - restore our old state
    iRewind = pfir->iCurState - iRewind;
    if (iRewind < 0)
        iRewind += pfir->cStateCache;
    pfir->LastDryAttenuation = pfir->pStateCache[iRewind].LastDryAttenuation;
    pfir->LastWetAttenuation = pfir->pStateCache[iRewind].LastWetAttenuation;
#ifdef SMOOTH_ITD
    pfir->iLastDelay = pfir->pStateCache[iRewind].iLastDelay;
#endif
    pfir->iStateTick = 0;

    return;
}


// Before we mix 1000 (or so) 3D samples, we call this function to prepare
// to mix the next batch.  The only thing it has to worry about is our
// volume smoothing.
// We are currently using Last***Attenuation and want to get to
// Total***Attenuation. Instead of figuring out sample by sample how much
// closer to move each sample (too expensive) we figure out right now how
// much we will move closer and do that for every sample in this batch.  But
// the danger of extracting that test to this level is that maybe we will
// go too far and actually overshoot Total***Attenation, causing possible
// clipping, or oscillating if we later try to correct it, and over-correct.
// If we are going to overshoot, we will recalculate how much to move each    
// sample such that we will end up at our target at the end of this batch of
// samples. (Or you can compile it to be lazy and give up when it's close).
void FilterChunkUpdate(PFIRCONTEXT pfir, int cSamples)
{
    FLOAT attRatio, c, w, d;

    // Due to rounding error, we'll take forever to get exactly to where
    // we want to be, so close counts.  If we don't snap ourselves to where
    // we want to be, we could clip.
    d = pfir->TotalDryAttenuation - pfir->LastDryAttenuation;
    w = pfir->TotalWetAttenuation - pfir->LastWetAttenuation;
    if (d && d > -.0001f && d < .0001f) {
        //DPF(2, "~`x");
        pfir->LastDryAttenuation = pfir->TotalDryAttenuation;
    }
    if (w && w > -.0001f && w < .0001f) {
        //DPF(2, "~`X");
        pfir->LastWetAttenuation = pfir->TotalWetAttenuation;
    }

    // Dry attenuation wants to be higher than it is
    if (pfir->TotalDryAttenuation > pfir->LastDryAttenuation) {
        // or we may never get anywhere
        if (pfir->LastDryAttenuation == 0.f)
            pfir->LastDryAttenuation = .0001f; // small enough not to click
        // after gaining in volume throughout this entire range of samples
        // we will end up going too high!
         // VolSmoothScale is just 2^(8/f), so each sample goes up 
        // 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
        attRatio = pfir->TotalDryAttenuation / pfir->LastDryAttenuation;
        if (pow2(8. * cSamples / pfir->iSmoothFreq) > attRatio) {
#if 1
            // calculate what value besides 8 to use to end up at our
            // target after cSamples multiplies
            c = (FLOAT)fylog2x((double)pfir->iSmoothFreq / cSamples,
                attRatio);
            pfir->VolSmoothScaleDry = (FLOAT)pow2(c / pfir->iSmoothFreq);
            //DPF(2, "~`n");
#else
            // decide we're happy where we are.
            // we will never get to our real destination
            pfir->VolSmoothScaleDry = 1.f;
            pfir->TotalDryAttenuation = pfir->LastDryAttenuation;
            //DPF(2, "~`n");
#endif
        } else {
            // This is the value to multiply by every time
            pfir->VolSmoothScaleDry = pfir->VolSmoothScale;
            //DPF(2, "~`u");
        }

    // Dry attenuation wants to be less than it is
    } else if (pfir->TotalDryAttenuation < pfir->LastDryAttenuation) {

        // after lowering the volume throughout this entire range of samples
        // we will end up going too low!  going down from Last to Total is
        // the same as going up from Total to Last
         // VolSmoothScale is just 2^(8/f), so each sample goes up 
        // 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
        attRatio = pfir->TotalDryAttenuation ?
                   pfir->LastDryAttenuation / pfir->TotalDryAttenuation :
                   999999;
        if (pow2(8. * cSamples / pfir->iSmoothFreq) > attRatio) {
#if 1
            // calculate what value besides 8 to use to end up at our
            // target after cSamples multiplies
            c = (FLOAT)fylog2x((double)pfir->iSmoothFreq / cSamples,
                                                        attRatio);
            pfir->VolSmoothScaleDry = 1.f / (FLOAT)pow2(c / pfir->iSmoothFreq);
            //DPF(2, "~`p");
#else
            // decide we're happy where we are.
            // we will never get to our real destination
            pfir->VolSmoothScaleDry = 1.f;
            pfir->TotalDryAttenuation = pfir->LastDryAttenuation;
            //DPF(2, "~`p");
#endif
        } else {
            // This is the value to multiply by every time
            pfir->VolSmoothScaleDry = pfir->VolSmoothScaleRecip;
            //DPF(2, "~`d");
        }
    } else {
        // We're already where we want to be
        pfir->VolSmoothScaleDry = 1.f;
        //DPF(2, "~`.");
    }

    // Wet attenuation wants to be higher than it is
    if (pfir->TotalWetAttenuation > pfir->LastWetAttenuation) {
        // or we may never get anywhere
        if (pfir->LastWetAttenuation == 0.f)
            pfir->LastWetAttenuation = .0001f; // small enough not to click
        // after gaining in volume throughout this entire range of samples
        // we will end up going too high!
         // VolSmoothScale is just 2^(8/f), so each sample goes up 
        // 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
        attRatio = pfir->TotalWetAttenuation / pfir->LastWetAttenuation;
        if (pow2(8. * cSamples / pfir->iSmoothFreq) > attRatio) {
#if 1
            // calculate what value besides 8 to use to end up at our
            // target after cSamples multiplies
            c = (FLOAT)fylog2x((double)pfir->iSmoothFreq / cSamples, attRatio);
            pfir->VolSmoothScaleWet = (FLOAT)pow2(c / pfir->iSmoothFreq);
            //DPF(2, "~`N");
#else
            // decide we're happy where we are.
            // we will never get to our real destination
            pfir->VolSmoothScaleWet = 1.f;
            pfir->TotalWetAttenuation = pfir->LastWetAttenuation;
            //DPF(2, "~`N");
#endif
        } else {
            // This is the value to multiply by every time
            pfir->VolSmoothScaleWet = pfir->VolSmoothScale;
            //DPF(2, "~`U");
        }

    // Wet attenuation wants to be lower than it is
    } else if (pfir->TotalWetAttenuation < pfir->LastWetAttenuation) {

        // after lowering the volume throughout this entire range of samples
        // we will end up going too low!  going down from Last to Total is
        // the same as going up from Total to Last
         // VolSmoothScale is just 2^(8/f), so each sample goes up 
        // 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
        attRatio = pfir->TotalWetAttenuation ?
                   pfir->LastWetAttenuation / pfir->TotalWetAttenuation :
                   999999;
        if (pow2(8. * cSamples / pfir->iSmoothFreq) > attRatio) {
#if 1
            // calculate what value besides 8 to use to end up at our
            // target after cSamples multiplies
            c = (FLOAT)fylog2x((double)pfir->iSmoothFreq / cSamples, attRatio);
            pfir->VolSmoothScaleWet = 1.f / (FLOAT)pow2(c / pfir->iSmoothFreq);
            //DPF(2, "~`P");
#else
            // decide we're happy where we are.
            // we will never get to our real destination
            pfir->VolSmoothScaleWet = 1.f;
            pfir->TotalWetAttenuation = pfir->LastWetAttenuation;
            //DPF(2, "~`P");
#endif
        } else {
            // This is the value to multiply by every time
            pfir->VolSmoothScaleWet = pfir->VolSmoothScaleRecip;
            //DPF(2, "~`D");
        }
    } else {
        // We're already where we want to be
        pfir->VolSmoothScaleWet = 1.f;
        //DPF(2, "~`.");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\effects.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        effects.h
 *
 *  Content:     Declarations for the CEffectChain class and the CEffect
 *               class hierarchy (CEffect, CDmoEffect and CSendEffect).
 *
 *  Description: These classes implement DX8 audio effects and sends.
 *               More info in effects.cpp.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 08/10/99  duganp   Created
 *
 ***************************************************************************/

#ifndef __EFFECTS_H__
#define __EFFECTS_H__

// Various conversions between reftimes, milliseconds, samples and bytes.
// (Defining 'sample' as a sample *block*, with samples for all channels)
// REFERENCE_TIME is in 100-ns units (so 1 reftime tick == 1e-7 seconds).

__inline DWORD MsToBytes(DWORD ms, LPWAVEFORMATEX pwfx)
{
    return BLOCKALIGN(ms * pwfx->nAvgBytesPerSec / 1000, pwfx->nBlockAlign);
}
__inline DWORD BytesToMs(DWORD bytes, LPWAVEFORMATEX pwfx)
{
    return bytes * 1000 / pwfx->nAvgBytesPerSec;
}
__inline DWORD MsToSamples(DWORD ms, LPWAVEFORMATEX pwfx)
{
    return ms * pwfx->nSamplesPerSec / 1000;
}
__inline DWORD SamplesToMs(DWORD samples, LPWAVEFORMATEX pwfx)
{
    return samples * 1000 / pwfx->nSamplesPerSec;
}
__inline DWORD RefTimeToMs(REFERENCE_TIME rt)
{
    return (DWORD)(rt / 10000);
}
__inline REFERENCE_TIME MsToRefTime(DWORD ms)
{
    return (REFERENCE_TIME)ms * 10000;
}
__inline DWORD RefTimeToBytes(REFERENCE_TIME rt, LPWAVEFORMATEX pwfx)
{
    return (DWORD)(BLOCKALIGN(rt * pwfx->nAvgBytesPerSec / 10000000, pwfx->nBlockAlign));
}
__inline REFERENCE_TIME BytesToRefTime(DWORD bytes, LPWAVEFORMATEX pwfx)
{
    return (REFERENCE_TIME)bytes * 10000000 / pwfx->nAvgBytesPerSec;
}

// Figure out if position X is between A and B in a cyclic buffer
#define CONTAINED(A, B, X) ((A) < (B) ? (A) <= (X) && (X) <= (B) \
                                      : (A) <= (X) || (X) <= (B))

// As above, but excluding the boundary case
#define STRICTLY_CONTAINED(A, B, X) ((A) < (B) ? (A) < (X) && (X) < (B) \
                                               : (A) < (X) || (X) < (B))

// Figure out if a cursor has overtaken position X while moving from A to B
#define OVERTAKEN(A, B, X) !CONTAINED(A, X, B)

// Find the distance between positions A and B in a buffer of length L
#define DISTANCE(A, B, L) ((A) <= (B) ? (B) - (A) : (L) + (B) - (A))


#ifdef __cplusplus

#include "mediaobj.h"   // For DMO_MEDIA_TYPE

// Special argument used by CEffectChain::PreRollFx() below
#define CURRENT_PLAY_POS MAX_DWORD

// Forward declarations
class CDirectSoundSecondaryBuffer;
class CDirectSoundBufferConfig;
class CEffect;

// Utility functions for the simple mixer used by CSendEffect below
enum MIXMODE {OneToOne=1, MonoToStereo=2};
typedef void MIXFUNCTION(PVOID pSrc, PVOID pDest, DWORD dwSamples, DWORD dwAmpFactor, MIXMODE mixMode);
MIXFUNCTION Mix8bit;
MIXFUNCTION Mix16bit;

// Validator for effect descriptors (can't be in dsvalid.c because it uses C++)
BOOL IsValidEffectDesc(LPCDSEFFECTDESC, CDirectSoundSecondaryBuffer*);


//
// The DirectSound effects chain class
//

class CEffectChain : public CDsBasicRuntime
{
    friend class CStreamingThread;  // Note: should try to dissolve some of these friendships
    friend class CDirectSoundSecondaryBuffer;  // So FindSendLoop() can get at m_fxList

public:
    CEffectChain                 (CDirectSoundSecondaryBuffer* pBuffer);
    ~CEffectChain                (void);

    HRESULT Initialize           (DWORD dwFxCount, LPDSEFFECTDESC pFxDesc, LPDWORD pdwResultCodes);
    HRESULT Clone                (CDirectSoundBufferConfig* pDSBConfigObj);
    HRESULT AcquireFxResources   (void);
    HRESULT GetFxStatus          (LPDWORD pdwResultCodes);
    HRESULT GetEffectInterface   (REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID* ppObject);
    HRESULT NotifyState          (DWORD dwState);
    void    NotifyRelease        (CDirectSoundSecondaryBuffer*);
    void    SetInitialSlice      (REFERENCE_TIME rtSliceSize);
    DWORD   GetFxCount()         {return m_fxList.GetNodeCount();}

    // Effects processing methods
    HRESULT PreRollFx            (DWORD dwPosition =CURRENT_PLAY_POS);
    HRESULT UpdateFx             (LPVOID pChangedPos, DWORD dwChangedSize);
    HRESULT ProcessFx            (DWORD dwWriteAhead, LPDWORD pdwLatencyBoost);

private:
    HRESULT ReallyProcessFx      (DWORD dwStartPos, DWORD dwEndPos);
    HRESULT ReallyReallyProcessFx(DWORD dwOffset, DWORD dwBytes, REFERENCE_TIME rtTime, DWORD dwSendOffset =0);
    HRESULT FxDiscontinuity      (void);

    // Effects processing state
    CStreamingThread*            m_pStreamingThread;    // Pointer to our owning streaming thread
    CObjectList<CEffect>         m_fxList;              // Effect object list
    CDirectSoundSecondaryBuffer* m_pDsBuffer;           // Owning DirectSound buffer object
    LPWAVEFORMATEX               m_pFormat;             // Pointer to owning buffer's audio format
    PBYTE                        m_pPreFxBuffer;        // "Dry" audio buffer (before FX processing)
    PBYTE                        m_pPostFxBuffer;       // "Wet" audio buffer (after FX processing)
    DWORD                        m_dwBufSize;           // Size of above two buffers in bytes
    DWORD                        m_dwLastPos;           // Last byte position written to
    DWORD                        m_dwLastPlayCursor;    // Play cursor from previous run
    DWORD                        m_dwLastWriteCursor;   // Write cursor from previous run
    BOOL                         m_fHasSend;            // Whether this FX chain contains any sends
                                                        // FIXME: may not be necessary later
    HRESULT                      m_hrInit;              // Return code from initialization
    DWORD                        m_dwWriteAheadFixme;   // FIXME: temporary
};


//
// Base class for all DirectSound audio effects
//

class CEffect : public CDsBasicRuntime  // FIXME: to save some memory we could derive CEffect from CRefCount 
                                        // and implement the ": CRefCount(1)", "delete this" stuff etc here.
{
public:
    CEffect                         (DSEFFECTDESC& fxDescriptor);
    virtual ~CEffect                (void) {}
    virtual HRESULT Initialize      (DMO_MEDIA_TYPE*) =0;
    virtual HRESULT Clone           (IMediaObject*, DMO_MEDIA_TYPE*) =0;
    virtual HRESULT Process         (DWORD dwBytes, BYTE* pAudio, REFERENCE_TIME refTimeStart, DWORD dwSendOffset, LPWAVEFORMATEX pFormat) =0;
    virtual HRESULT Discontinuity   (void) = 0;
    virtual HRESULT GetInterface    (REFIID, LPVOID*) =0;

    // These two methods are only required by CSendEffect:
    virtual void NotifyRelease(CDirectSoundSecondaryBuffer*) {}
    virtual CDirectSoundSecondaryBuffer* GetDestBuffer(void) {return NULL;}

    HRESULT AcquireFxResources      (void);

    DSEFFECTDESC                    m_fxDescriptor;     // Creation parameters
    DWORD                           m_fxStatus;         // Current effect status
};


//
// Class representing DirectX Media Object effects
//

class CDmoEffect : public CEffect
{
public:
    CDmoEffect              (DSEFFECTDESC& fxDescriptor);
    ~CDmoEffect             (void);
    HRESULT Initialize      (DMO_MEDIA_TYPE*);
    HRESULT Clone           (IMediaObject*, DMO_MEDIA_TYPE*);
    HRESULT Process         (DWORD dwBytes, BYTE* pAudio, REFERENCE_TIME refTimeStart, DWORD dwSendOffset =0, LPWAVEFORMATEX pFormat =NULL);
    HRESULT Discontinuity   (void)                          {return m_pMediaObject->Discontinuity(0);}
    HRESULT GetInterface    (REFIID riid, LPVOID* ppvObj)   {return m_pMediaObject->QueryInterface(riid, ppvObj);}

    IMediaObject*           m_pMediaObject;         // The DMO's standard interface (required)
    IMediaObjectInPlace*    m_pMediaObjectInPlace;  // The DMO's special interface (optional)
};


//
// Class representing DirectSound audio sends
//

class CSendEffect : public CEffect
{
public:
    CSendEffect(DSEFFECTDESC& fxDescriptor, CDirectSoundSecondaryBuffer* pSrcBuffer);
    ~CSendEffect(void);

    HRESULT Initialize      (DMO_MEDIA_TYPE*);
    HRESULT Clone           (IMediaObject*, DMO_MEDIA_TYPE*);
    HRESULT Process         (DWORD dwBytes, BYTE* pAudio, REFERENCE_TIME refTimeStart, DWORD dwSendOffset =0, LPWAVEFORMATEX pFormat =NULL);
    void    NotifyRelease   (CDirectSoundSecondaryBuffer*);
#ifdef ENABLE_I3DL2SOURCE
    HRESULT Discontinuity   (void)                          {return m_pI3DL2SrcDMO ? m_pI3DL2SrcDMO->Discontinuity(0) : DS_OK;}
#else
    HRESULT Discontinuity   (void)                          {return DS_OK;}
#endif
    HRESULT GetInterface    (REFIID riid, LPVOID* ppvObj)   {return m_impDSFXSend.QueryInterface(riid, ppvObj);}
    CDirectSoundSecondaryBuffer* GetDestBuffer(void)        {return m_pDestBuffer;}

    // IDirectSoundFXSend methods
    HRESULT SetAllParameters(LPCDSFXSend);
    HRESULT GetAllParameters(LPDSFXSend);

private:
    // COM interface helper object
    struct CImpDirectSoundFXSend : public IDirectSoundFXSend
    {
        // INTERFACE_SIGNATURE m_signature;
        CSendEffect* m_pObject;

        // IUnknown methods (FIXME - missing the param validation layer)
        ULONG   STDMETHODCALLTYPE AddRef()  {return m_pObject->AddRef();}
        ULONG   STDMETHODCALLTYPE Release() {return m_pObject->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);

        // IDirectSoundFXSend methods (FIXME - missing the param validation layer)
        HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDSFXSend pcDsFxSend) {return m_pObject->SetAllParameters(pcDsFxSend);}
        HRESULT STDMETHODCALLTYPE GetAllParameters(LPDSFXSend pDsFxSend)  {return m_pObject->GetAllParameters(pDsFxSend);}
    };
    friend struct CImpDirectSoundFXSend;

    // Data members
    CImpDirectSoundFXSend        m_impDSFXSend;         // COM interface helper object
    MIXFUNCTION*                 m_pMixFunction;        // Current mixing routine
    MIXMODE                      m_mixMode;             // Current mixing mode
    CDirectSoundSecondaryBuffer* m_pSrcBuffer;          // Source buffer for the send - FIXME: may be able to lose this
    CDirectSoundSecondaryBuffer* m_pDestBuffer;         // Destination buffer for the send
    LONG                         m_lSendLevel;          // DSBVOLUME attenuation (millibels)
    DWORD                        m_dwAmpFactor;         // Corresponding amplification factor
#ifdef ENABLE_I3DL2SOURCE
    IMediaObject*                m_pI3DL2SrcDMO;        // Interfaces on our contained I3DL2 source DMO
    IMediaObjectInPlace*         m_pI3DL2SrcDMOInPlace; // (if this happends to be an I3DL2 send effect).
#endif
};


#if DEAD_CODE
// FIXME: Support for IMediaObject-only DMOs goes here

//
// Utility class used to wrap our audio buffers in an IMediaBuffer interface,
// so we can use a DMO's IMediaObject interface if it lacks IMediaObjectInPlace.
//

class CMediaBuffer : public CUnknown // (but this has dependencies on CImpUnknown...)
{
    // Blah.
};

#endif // DEAD_CODE
#endif // __cplusplus
#endif // __EFFECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\grace.cpp ===
//--------------------------------------------------------------------------;
//
// File: grace.cpp
//
// Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// Abstract:
//
// This file contains functions related to the mixing of secondary buffers
// into a primary buffer.  Collectively, this mixing is referred to as "grace"
// for no good reason other than hoping that it is a graceful solution to the
// mixing problem.  It could easily be called "mixer" but that would be
// ambiguous with the code that actually mixes the samples together.
//
// Contents:
//
// The contained functions include a thread function that wakes
// periodically to "refresh" the data in the primary buffer by mixing in data
// from secondary buffers.  The same thread can be signalled to immediately
// remix data into the primary buffer.
//
// This also contains functions to initialize and terminate the mixing
// thread, add/remove buffers to/from the list of buffers to be mixed, and
// query the position of secondary buffers that are being mixed.
//
// History:
//  06/15/95  FrankYe   Created
//  08/25/99  DuganP    Added effects processing for DirectX 8
//
//--------------------------------------------------------------------------;
#define NODSOUNDSERVICETABLE

#include "dsoundi.h"

#ifndef Not_VxD
#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG
#endif


//--------------------------------------------------------------------------;
//
// "C" wrappers around calls to CMixDest objects
//
//--------------------------------------------------------------------------;

void MixDest_Delete(PVOID pMixDest)
{
    CMixDest *p = (CMixDest *)pMixDest;
    DELETE(p);
}

HRESULT MixDest_Initialize(PVOID pMixDest)
{
    return ((CMixDest *)pMixDest)->Initialize();
}

void MixDest_Terminate(PVOID pMixDest)
{
    ((CMixDest *)pMixDest)->Terminate();
}

HRESULT MixDest_SetFormat(PVOID pMixDest, LPWAVEFORMATEX pwfx)
{
    return ((CMixDest *)pMixDest)->SetFormat(pwfx);
}

void MixDest_SetFormatInfo(PVOID pMixDest, LPWAVEFORMATEX pwfx)
{
    ((CMixDest *)pMixDest)->SetFormatInfo(pwfx);
}

HRESULT MixDest_AllocMixer(PVOID pMixDest, PVOID *ppMixer)
{
    return ((CMixDest *)pMixDest)->AllocMixer((CMixer**)ppMixer);
}

void MixDest_FreeMixer(PVOID pMixDest)
{
    ((CMixDest *)pMixDest)->FreeMixer();
}

void MixDest_Play(PVOID pMixDest)
{
    ((CMixDest *)pMixDest)->Play();
}

void MixDest_Stop(PVOID pMixDest)
{
    ((CMixDest *)pMixDest)->Stop();
}

ULONG MixDest_GetFrequency(PVOID pMixDest)
{
    return ((CMixDest *)pMixDest)->GetFrequency();
}

HRESULT MixDest_GetSamplePosition(PVOID pMixDest, int *pposPlay, int *pposWrite)
{
    return ((CMixDest *)pMixDest)->GetSamplePosition(pposPlay, pposWrite);
}


//--------------------------------------------------------------------------;
//
// CGrDest object
//
//--------------------------------------------------------------------------;

void CGrDest::SetFormatInfo(LPWAVEFORMATEX pwfx)
{
    ASSERT(pwfx->wFormatTag == WAVE_FORMAT_PCM);
    
    m_nFrequency = pwfx->nSamplesPerSec;

    m_hfFormat = H_LOOP;

    if(pwfx->wBitsPerSample == 8)
        m_hfFormat |= (H_8_BITS | H_UNSIGNED);
    else
        m_hfFormat |= (H_16_BITS | H_SIGNED);

    if(pwfx->nChannels == 2)
        m_hfFormat |= (H_STEREO | H_ORDER_LR);
    else
        m_hfFormat |= H_MONO;

    m_cSamples = m_cbBuffer / pwfx->nBlockAlign;

    switch (pwfx->nBlockAlign)
    {
        case 1:
            m_nBlockAlignShift = 0;
            break;
        case 2:
            m_nBlockAlignShift = 1;
            break;
        case 4:
            m_nBlockAlignShift = 2;
            break;
        default:
            ASSERT(FALSE);
    }

    CopyMemory(&m_wfx, pwfx, sizeof(m_wfx));
}

ULONG CGrDest::GetFrequency()
{
    return m_nFrequency;
}

HRESULT CGrDest::Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite)
{
    LPBYTE  pbBuffer;
    BOOL    fWrap;
    HRESULT hr = DSERR_GENERIC;
    
    if(m_pBuffer && cbWrite > 0)
    {
        pbBuffer = (LPBYTE)m_pBuffer;
        fWrap = (ibWrite + cbWrite) > m_cbBuffer;
                    
        *ppBuffer1 = pbBuffer + ibWrite;
        *pcbBuffer1 = fWrap ? m_cbBuffer - ibWrite : cbWrite;
    
        if (ppBuffer2) *ppBuffer2 = fWrap ? pbBuffer : NULL;
        if (pcbBuffer2) *pcbBuffer2 = fWrap ? ibWrite + cbWrite - m_cbBuffer : 0;

        hr = S_OK;
    }

    return hr;
}

HRESULT CGrDest::Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2)
{
    return S_OK;
}


//--------------------------------------------------------------------------;
//
// "C" wrappers around calls to CMixer objects
//
//--------------------------------------------------------------------------;

void Mixer_SignalRemix(PVOID pMixer)
{
    ((CMixer *)pMixer)->SignalRemix();
}

HRESULT Mixer_Run(PVOID pMixer)
{
    return ((CMixer *)pMixer)->Run();
}

BOOL Mixer_Stop(PVOID pMixer)
{
    return ((CMixer *)pMixer)->Stop();
}

void Mixer_PlayWhenIdle(PVOID pMixer)
{
    ((CMixer *)pMixer)->PlayWhenIdle();
}

void Mixer_StopWhenIdle(PVOID pMixer)
{
    ((CMixer *)pMixer)->StopWhenIdle();
}

//--------------------------------------------------------------------------;
//
// CGrace object
//
//--------------------------------------------------------------------------;

HRESULT CGrace::Initialize(CGrDest *pDest)
{
    HRESULT hr;
    
    ASSERT(!m_pSourceListZ);
    ASSERT(!m_pDest);
    
    // initialize the doubly linked list sentinel
    m_pSourceListZ = NEW(CMixSource(this));
    if (m_pSourceListZ) {
        m_pSourceListZ->m_pNextMix = m_pSourceListZ;
        m_pSourceListZ->m_pPrevMix = m_pSourceListZ;

        m_cbBuildBuffer = pDest->m_cbBuffer * 4;
        m_plBuildBuffer = (PLONG)MEMALLOC_A(BYTE, m_cbBuildBuffer);
        if (m_plBuildBuffer) {
            m_pDest = pDest;
            hr = S_OK;
        } else {
            DELETE(m_pSourceListZ);
            hr = DSERR_OUTOFMEMORY;
        }
    } else {
        hr = DSERR_OUTOFMEMORY;
    }

    m_pSecondaryBuffer    = NULL;
    m_fUseSecondaryBuffer = FALSE;
    
    return hr;
}

void CGrace::Terminate()
{
    ASSERT(m_pSourceListZ);
    ASSERT(m_plBuildBuffer);
    DELETE(m_pSourceListZ);
    MEMFREE(m_plBuildBuffer);
    MEMFREE(m_pSecondaryBuffer);
}

void CGrace::MixEndingBuffer(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    //DPF(3, "~`S4");
    //DPF(4, "uMixEndingBuffer");

    // REMIND This assert will fail when a setposition call comes in.
    // We should change the setposition stuff and put this assert back in.
    // ASSERT(0 == pSource->m_posNextMix);

    if ((posPPlay >= pSource->m_posPEnd) || (posPPlay < pSource->m_posPPlayLast)) {

        LONG dbNextNotify;
        BOOL fSwitchedLooping;
        
        //DPF(3, "~`X");
        
        fSwitchedLooping  = (0 != (pSource->m_hfFormat & H_LOOP));

        pSource->NotifyToPosition(0, &dbNextNotify);
        MixListRemove(pSource);
        pSource->m_kMixerState = MIXSOURCESTATE_STOPPED;
        pSource->m_posNextMix = 0;

        // Since this buffer still has status = playing, we need to honor a
        // looping change even though the play position may have reached the
        // end of this buffer.
        if (fSwitchedLooping) {
            MixListAdd(pSource);
            MixNewBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
        } else {
            // We really did stop
            pSource->NotifyStop();
        }
        return;
    }

    if (posPMix > posPPlay)
        ASSERT(posPMix + dposPRemix >= pSource->m_posPEnd);

    //
    // Haven't reached end yet so let's check for a few remix events...
    //

    // Check for SETPOSITION signal
    if (0 != (DSBMIXERSIGNAL_SETPOSITION & pSource->m_fdwMixerSignal)) {
        pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
        //DPF(3, "~`S42");
        MixNotLoopingBuffer(pSource, posPPlay, posPMix, 0, cPMix);
        return;
    }

    // Check for remix
    if (0 != dposPRemix) {

        // If the Mix position is outside of the range between the Play
        // and End positions, then we don't remix anything.
        if ((posPMix >= posPPlay) && (posPMix < pSource->m_posPEnd)) {
            if (dposPRemix < pSource->m_posPEnd - posPMix) {
                //DPF(3, "!dposPRemix=%04Xh, m_posPEnd=%04Xh, posPMIx=%04Xh", dposPRemix, pSource->m_posPEnd, posPMix);
            }
            
            dposPRemix = pSource->m_posPEnd - posPMix;

            pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
            //DPF(3, "~`S42");
            MixNotLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
            return;
        }
        //DPF(3, "~`S44");
    }

    // Handle substate transition
    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            ASSERT(FALSE);
            break;
        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
            ASSERT(posPPlay >= pSource->m_posPPlayLast);
            // A wrap would have been caught above and this buffer stopped
            break;
        case MIXSOURCESUBSTATE_STARTING:
            ASSERT(posPPlay >= pSource->m_posPPlayLast);
            // A wrap would have been caught above and this buffer stopped
            if (posPPlay >= pSource->m_posPStart)
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
            break;
        case MIXSOURCESUBSTATE_STARTED:
            break;
        default:
            ASSERT(FALSE);
    }

    pSource->m_posPPlayLast = posPPlay;
}

void CGrace::MixEndingBufferWaitingWrap(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    //DPF(4, "uMixEndingBufferWaitingWrap");

    if (posPPlay < pSource->m_posPPlayLast) {

        // handle substate transition
        switch (pSource->m_kMixerSubstate)
        {
            case MIXSOURCESUBSTATE_NEW:
                //DPF(3, "uMixEndingBufferWaitingWrap: error: encountered MIXSOURCESUBSTATE_NEW");
                // ASSERT(FALSE);
                break;
            case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING;
                break;
            case MIXSOURCESUBSTATE_STARTING:
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
                break;
            case MIXSOURCESUBSTATE_STARTED:
                break;
            default:
                ASSERT(FALSE);
        }

        pSource->m_posPPlayLast = posPPlay;
        pSource->m_kMixerState = MIXSOURCESTATE_ENDING;
        //DPF(3, "~`S34");
        MixEndingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
        return;
    }

    // Haven't wrapped yet.

    if (0 != (DSBMIXERSIGNAL_SETPOSITION & pSource->m_fdwMixerSignal)) {
        pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
        //DPF(3, "~`S32");
        MixNotLoopingBuffer(pSource, posPPlay, posPMix, 0, cPMix);
        return;
    }

    // Check for remix
    if (0 != dposPRemix) {

        // If the Mix position is outside of the range between the Play
        // and End positions, then we don't remix anything.
        if ((posPMix >= posPPlay) || (posPMix < pSource->m_posPEnd)) {
            dposPRemix = pSource->m_posPEnd - posPMix;

            if (dposPRemix < 0) dposPRemix += m_pDest->m_cSamples;
            ASSERT(dposPRemix >= 0);

            pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
            //DPF(3, "~`S32");
            MixNotLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
            return;
        }
    }

    // handle substate transition
    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            ASSERT(FALSE);
            break;
        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
            // A wrap would have been caught above and control sent to
            // uMixEndingBuffer.
            ASSERT(posPPlay >= pSource->m_posPPlayLast);
            break;
        case MIXSOURCESUBSTATE_STARTING:
            // A wrap would have been caught above and control sent to
            // uMixEndingBuffer.
            ASSERT(posPPlay >= pSource->m_posPPlayLast);
            if (posPPlay >= pSource->m_posPStart)
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
            break;
        case MIXSOURCESUBSTATE_STARTED:
            break;
        default:
            ASSERT(FALSE);
    }

    pSource->m_posPPlayLast = posPPlay;
}

void CGrace::MixNotLoopingBuffer(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    int     posMix;
    int     dposEnd;
    int     cPMixed;
    DWORD   dwPosition;

    //DPF(4, "uMixNotLoopingBuffer");

    if (0 != (H_LOOP & pSource->m_hfFormat)) {
        // We've switched from not looping to looping
        pSource->m_kMixerState = MIXSOURCESTATE_LOOPING;
        //DPF(3, "~`S21");
        MixLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
        return;
    }

    // On a SetPosition, we ignore the remix length and posNextMix will
    // contain the new position at which to start mixing the secondary buffer
    if (0 != (DSBMIXERSIGNAL_SETPOSITION & pSource->m_fdwMixerSignal)) {
        pSource->m_fdwMixerSignal  &= ~DSBMIXERSIGNAL_SETPOSITION;
        //DPF(3, "~`S20");
        MixNewBuffer(pSource, posPPlay, posPMix, 0, cPMix);
        return;
    }

    // Handle substate transition
    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            ASSERT(FALSE);
            break;
        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
            if (posPPlay < pSource->m_posPPlayLast)
                if (posPPlay >= pSource->m_posPStart)
                    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
                else
                    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING;
            break;
        case MIXSOURCESUBSTATE_STARTING:
            if ((posPPlay >= pSource->m_posPStart) || (posPPlay < pSource->m_posPPlayLast))
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
            break;
        case MIXSOURCESUBSTATE_STARTED:
            break;
        default:
            ASSERT(FALSE);
    }
            
    //
    if (0 == dposPRemix) {
        posMix = pSource->m_posNextMix;
    } else {
        LONG dposRemix;

        dposRemix = MulDivRN(dposPRemix, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
        posMix = pSource->m_posNextMix - dposRemix;
        while (posMix < 0) posMix += pSource->m_cSamples;

        // Rewind the filter
        pSource->FilterRewind(dposPRemix);

#ifdef PROFILEREMIXING
        pSource->CountSamplesRemixed(dposRemix);
#endif
    }

    ASSERT(0 == (H_LOOP & pSource->m_hfFormat));

    dposEnd = pSource->m_cSamples - posMix;

    if (pSource->GetMute()) {
        int cMixMuted;

        cMixMuted = MulDivRN(cPMix, pSource->m_nFrequency, m_pDest->m_nFrequency);
        cPMixed = cPMix;
        if (dposEnd < cMixMuted) {
            cMixMuted = dposEnd;
            cPMixed = MulDivRN(cMixMuted, m_pDest->m_nFrequency, pSource->m_nFrequency);
        }

        // Advance the filter
        pSource->FilterAdvance(cPMixed);
        
        dwPosition = (posMix + cMixMuted) << pSource->m_nBlockAlignShift;

    } else {
        dwPosition = posMix << pSource->m_nBlockAlignShift;
        cPMixed = mixMixSession(pSource, &dwPosition, dposEnd << pSource->m_nBlockAlignShift, 0);
    }

    // See if this non-looping buffer has reached the end
    // //DPF(3, "~`S2pos:%08X", dwPosition);
    if (dwPosition >= (DWORD)pSource->m_cbBuffer) {

        dwPosition = 0;

        // determine position in primary buffer that corresponds to the
        // end of this secondary buffer
        pSource->m_posPEnd = posPMix + cPMixed;
        while (pSource->m_posPEnd >= m_pDest->m_cSamples) pSource->m_posPEnd -= m_pDest->m_cSamples;

        if (pSource->m_posPEnd < posPPlay) {
            //DPF(3, "~`S23");
            pSource->m_kMixerState = MIXSOURCESTATE_ENDING_WAITINGPRIMARYWRAP;
        } else {
            //DPF(3, "~`S24");
            pSource->m_kMixerState = MIXSOURCESTATE_ENDING;
        }
    }
    
    pSource->m_posPPlayLast = posPPlay;
    pSource->m_posNextMix = dwPosition >> pSource->m_nBlockAlignShift;
    pSource->m_nLastFrequency = pSource->m_nFrequency;

    // Profile remixing
#ifdef PROFILEREMIXING
    {
        int cMixed = pSource->m_posNextMix - posMix;
        if (cMixed < 0) cMixed += pSource->m_cSamples;
        pSource->CountSamplesMixed(cMixed);
    }
#endif
}

void CGrace::MixLoopingBuffer(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    LONG    posMix;
    DWORD   dwPosition;

    //DPF(4, "uMixLoopingBuffer");

    if (0 == (H_LOOP & pSource->m_hfFormat)) {
        // We've switched from looping to non-looping
        pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
        //DPF(3, "~`S12");
        MixNotLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
        return;
    }
    
    // on a SetPosition, we ignore the remix length and posNextMix will
    // contain the new position at which to start mixing the secondary buffer
    if (0 != (DSBMIXERSIGNAL_SETPOSITION & pSource->m_fdwMixerSignal)) {
        pSource->m_fdwMixerSignal  &= ~DSBMIXERSIGNAL_SETPOSITION;
        //DPF(3, "~`S10");
        MixNewBuffer(pSource, posPPlay, posPMix, 0, cPMix);
        return;
    }

    // handle substate transition
    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            ASSERT(FALSE);
            break;
        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
            if (posPPlay < pSource->m_posPPlayLast) {
                if (posPPlay >= pSource->m_posPStart) {
                    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
                } else {
                    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING;
                }
            }
            break;
        case MIXSOURCESUBSTATE_STARTING:
            if ((posPPlay >= pSource->m_posPStart) || (posPPlay < pSource->m_posPPlayLast)) {
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
            }
            break;
        case MIXSOURCESUBSTATE_STARTED:
            break;
        default:
            ASSERT(FALSE);
    }
            
    if (0 == dposPRemix) {
        posMix = pSource->m_posNextMix;
    } else {
        LONG dposRemix = MulDivRN(dposPRemix, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
        posMix = pSource->m_posNextMix - dposRemix;
        while (posMix < 0)
            posMix += pSource->m_cSamples;

        // Rewind the filter
        pSource->FilterRewind(dposPRemix);
        
#ifdef PROFILEREMIXING
        pSource->CountSamplesRemixed(dposRemix);
#endif
    }

    ASSERT(H_LOOP & pSource->m_hfFormat);

    if (pSource->GetMute()) {
        int cMix = MulDivRN(cPMix, pSource->m_nFrequency, m_pDest->m_nFrequency);

        // Advance the filter
        pSource->FilterAdvance(cPMix);
        
        dwPosition = (posMix + cMix) << pSource->m_nBlockAlignShift;
        while (dwPosition >= (DWORD)pSource->m_cbBuffer)
            dwPosition -= (DWORD)pSource->m_cbBuffer;

    } else {
        dwPosition = posMix << pSource->m_nBlockAlignShift;
        mixMixSession(pSource, &dwPosition, 0, 0);
    }

    pSource->m_posPPlayLast = posPPlay;
    pSource->m_posNextMix = dwPosition >> pSource->m_nBlockAlignShift;
    pSource->m_nLastFrequency = pSource->m_nFrequency;

    // Profile remixing
#ifdef PROFILEREMIXING
    {
        int cMixed = pSource->m_posNextMix - posMix;
        if (cMixed < 0) cMixed += pSource->m_cSamples;
        pSource->CountSamplesMixed(cMixed);
    }
#endif
}

void CGrace::MixNewBuffer(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    BOOL fLooping;

    //DPF(4, "uMixNewBuffer");

    //
    // Determine position in primary buffer at which this buffer starts playing
    //
    pSource->m_posPStart = posPMix;
    if (posPPlay < pSource->m_posPStart) {
        pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING;
    } else {
        pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP;
    }

    pSource->m_posPPlayLast = posPPlay;

    pSource->FilterClear();

    fLooping = (0 != (H_LOOP & pSource->m_hfFormat));

    if (fLooping) {
        //DPF(3, "~`S01");
        pSource->m_kMixerState = MIXSOURCESTATE_LOOPING;
        MixLoopingBuffer(pSource, posPPlay, posPMix, 0, cPMix);
    } else {
        //DPF(3, "~`S02");
        pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
        MixNotLoopingBuffer(pSource, posPPlay, posPMix, 0, cPMix);
    }
}

void CGrace::Refresh(IN  BOOL fRemix,
                     IN  int cPremixMax,
                     OUT int *pcPremixed,
                     OUT PLONG pdtimeNextNotify)
{
    int         posPPlay;
    int         posPWrite;
    int         posPMix;
    int         dposPRemix;
    int         cMix;
    int         cMixThisLoop;
    int         dcMixThisLoop;
    CMixSource  *pSourceNext;
    CMixSource  *pSource;
    HRESULT     hr;

    // REMIND do we need to worry about ApmSuspended or will we always be stopped?
    // ASSERT(!gpdsinfo->fApmSuspended);
    // if (gpdsinfo->fApmSuspended) goto retClean;

    *pcPremixed = cPremixMax;
    *pdtimeNextNotify = MAXLONG;
    if (MIXERSTATE_IDLE == m_kMixerState) return;
    
    hr = m_pDest->GetSamplePositionNoWin16(&posPPlay, &posPWrite);
    if (FAILED(hr)) return;
    ASSERT(posPPlay != posPWrite);
    
    // Just make sure we have valid values.
    ASSERT(posPPlay  < m_pDest->m_cSamples);
    ASSERT(posPWrite < m_pDest->m_cSamples);

    switch (m_kMixerState)
    {
        case MIXERSTATE_LOOPING:
            // We can make this assertion because we never mix up to
            // the write cursor.
            ASSERT(m_posPWriteLast != m_posPNextMix);

            // Under normal conditions, the Write position should be between
            // the WriteLast position and the NextMix position.  We can check
            // for an invalid state (resulting most likely from a very late
            // wakeup) by checking whether the Write position is beyond our
            // NextMix position.  If we find ourselves in this shakey
            // situation, then we treat this similar to the START state.
            // Note that if our wakeup is so late that the Write position wraps
            // all the way around past the WriteLast position, we can't detect
            // the fact that we're in a bad situation.

            if ((m_posPWriteLast < m_posPNextMix &&
                 (posPWrite > m_posPNextMix || posPWrite < m_posPWriteLast)) ||
                (m_posPWriteLast > m_posPNextMix &&
                 (posPWrite > m_posPNextMix && posPWrite < m_posPWriteLast)))
            {
                // We're in trouble
                #ifdef Not_VxD
                    DPF(DPFLVL_ERROR, "Slept late");
                #else
                    DPF(("Slept late"));
                #endif
                posPMix = posPWrite;
                dposPRemix = 0;
                break;
            }

            if (fRemix) {
                dposPRemix = m_posPNextMix - posPWrite;
                if (dposPRemix < 0) dposPRemix += m_pDest->m_cSamples;
                ASSERT(dposPRemix >= 0);
                dposPRemix -= dposPRemix % MIXER_REWINDGRANULARITY;
                posPMix = m_posPNextMix - dposPRemix;
                if (posPMix < 0) posPMix += m_pDest->m_cSamples;
                ASSERT(posPMix >= 0);
            } else {
                posPMix = m_posPNextMix;
                dposPRemix = 0;
            }
            break;

        case MIXERSTATE_STARTING:
            m_posPPlayLast = posPPlay;
            m_posPWriteLast = posPWrite;
            posPMix = posPWrite;
            dposPRemix = 0;
            m_kMixerState = MIXERSTATE_LOOPING;
            break;

        default:
            ASSERT(FALSE);
    }

    //
    // Determine how much to mix.
    //
    // We don't want to mix more than dtimePremixMax beyond the Write cursor,
    // nor do we want to wrap past the Play cursor.
    //
    // The assertions (cMix >= 0) below are valid because:
    //            -cPremixMax is always growing
    //            -the Write cursor is always advancing (or hasn't moved yet)
    //            -posPMix is never beyond the previous write cursor plus
    //                the previous cPremixMax.
    //
    // The only time cPremixMax is not growing is on a remix in which case
    // the Mix position is equal to the Write cursor, so the assertions
    // are still okay.  The only time the write cursor would not appear to be
    // advancing is if we had a very late wakeup.  A very late wakeup would
    // be caught and adjusted for in the MIXERSTATE_LOOPING handling above.
    //
    if (posPWrite <= posPMix) {
        cMix = posPWrite + cPremixMax - posPMix;
        ASSERT(cMix >= 0);
    } else {
        cMix = posPWrite + cPremixMax - (posPMix + m_pDest->m_cSamples);
        ASSERT(cMix >= 0);
    }

    //
    // If posPPlay==posPMix, then we think we're executing a mix again before
    // the play or write cursors have advanced at all.  cMix==0, and we don't
    // mix no more!
    //
    if (posPPlay >= posPMix) {
        cMix = min(cMix, posPPlay - posPMix);
    } else {
        cMix = min(cMix, posPPlay + m_pDest->m_cSamples - posPMix);
    }
        
    ASSERT(cMix < m_pDest->m_cSamples);        // sanity check
    ASSERT(cMix >= 0);

    //
    // Always mix a multiple of the remix interval
    //
    cMix -= cMix % MIXER_REWINDGRANULARITY;

    // We break the mixing up into small chunks, increasing the size of the
    // chunk as we go.  By doing this, data gets written into the primary
    // buffer sooner.  Otherwise, if we have a buttload of data to mix, we'd
    // spend a lot of time mixing into the mix buffer before any data gets
    // written to the primary buffer and the play cursor might catch up
    // to us.  Here, we start mixing a ~8ms chunk of data and increase the
    // chunk size each iteration.
    
    cMixThisLoop = m_pDest->m_nFrequency / 128;
    dcMixThisLoop = cMixThisLoop;
    
    ASSERT(MixListIsValid());
    
    while (cMix > 0) {
        LONG cThisMix;
        
        cThisMix = min(cMix, cMixThisLoop);
        cMixThisLoop += dcMixThisLoop;
        
        mixBeginSession(cThisMix << m_pDest->m_nBlockAlignShift);
                
        // Get data for each buffer
        pSourceNext = MixListGetNext(m_pSourceListZ);
        while (pSourceNext) {

            // The uMixXxx buffer mix state handlers called below may cause
            // the pSource to be removed from the mix list.  So, we get the
            // pointer to the next pSource in the mix list now before any
            // of the uMixXxx functions are called.
            pSource = pSourceNext;
            pSourceNext = MixListGetNext(pSource);

            // Prepare for 3D processing (the actual work is done as part of mixing)
            pSource->FilterChunkUpdate(cThisMix);
            
            switch (pSource->m_kMixerState)
            {
                case MIXSOURCESTATE_NEW:
                    MixNewBuffer(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                case MIXSOURCESTATE_LOOPING:
                    MixLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                case MIXSOURCESTATE_NOTLOOPING:
                    MixNotLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                case MIXSOURCESTATE_ENDING_WAITINGPRIMARYWRAP:
                    MixEndingBufferWaitingWrap(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                case MIXSOURCESTATE_ENDING:
                    MixEndingBuffer(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                default:
                    ASSERT(FALSE);
                    break;
            }
        }

        //  Lock the output buffer, and if that is successful then write out
        //  the mix session.
        {
            PVOID pBuffer1;
            PVOID pBuffer2;
            int cbBuffer1;
            int cbBuffer2;
            int ibWrite;
            int cbWrite;
        
            ibWrite = posPMix << m_pDest->m_nBlockAlignShift;
            cbWrite = cThisMix << m_pDest->m_nBlockAlignShift;

            hr = m_pDest->Lock(&pBuffer1, &cbBuffer1, &pBuffer2, &cbBuffer2,
                               ibWrite, cbWrite);

            //DPF(5,"graceMix: lock primary buffer, bufptr=0x%8x, dwWriteOffset=%lu, dwSize=%lu, hr=%lu.",m_pDest->m_pBuffer,ibWrite,cbWrite,hr);

            // Validate that we really locked what we wanted or got an error.
            ASSERT(DS_OK != hr || pBuffer1 == (PBYTE)m_pDest->m_pBuffer + ibWrite);
            ASSERT(DS_OK != hr || pBuffer2 == m_pDest->m_pBuffer || 0 == cbBuffer2);
            ASSERT(DS_OK != hr || cbWrite == cbBuffer1+cbBuffer2);

            if(DS_OK == hr)
            {
                ASSERT(ibWrite < m_pDest->m_cbBuffer);
                mixWriteSession(ibWrite);

                // DPF(5, "Refresh: unlocking primary buffer");
                hr = m_pDest->Unlock(pBuffer1, cbBuffer1, pBuffer2, cbBuffer2);
            }
        }

        posPMix += cThisMix;
        if (posPMix >= m_pDest->m_cSamples) posPMix -= m_pDest->m_cSamples;
        ASSERT(posPMix < m_pDest->m_cSamples);

        dposPRemix = 0;
        cMix -= cThisMix;
    }

    m_posPNextMix = posPMix;
    
    // Calculate and return the amount of time from the current Write
    // cursor to the NextMix position.

    if (m_posPNextMix > posPWrite) {
        *pcPremixed = (m_posPNextMix - posPWrite);
    } else {
        *pcPremixed = (m_posPNextMix + m_pDest->m_cSamples - posPWrite);
    }

    // Remember the last Play and Write positions of the primary buffer.
    m_posPPlayLast  = posPPlay;
    m_posPWriteLast = posPWrite;
    
    // Process position events for each source
    for (pSource = MixListGetNext(m_pSourceListZ);
         pSource;
         pSource = MixListGetNext(pSource))
    {
        int ibPosition;
        LONG dtimeNextNotifyT;

        if (pSource->HasNotifications()) {
            GetBytePosition(pSource, &ibPosition, NULL);
            pSource->NotifyToPosition(ibPosition, &dtimeNextNotifyT);
            *pdtimeNextNotify = min(*pdtimeNextNotify, dtimeNextNotifyT);
        }
    }

    m_fdwMixerSignal &= ~DSMIXERSIGNAL_REMIX;
}

HRESULT CGrace::Run()
{
    if (MIXERSTATE_STOPPED != m_kMixerState) return S_OK;

    ASSERT(MixListIsEmpty());
    
    if (m_fPlayWhenIdle) ClearAndPlayDest();

    m_kMixerState = MIXERSTATE_IDLE;

    return S_OK;
}

BOOL CGrace::Stop()
{
    ASSERT(MixListIsEmpty());
    
    if (MIXERSTATE_STOPPED == m_kMixerState) return FALSE;

    m_kMixerState = MIXERSTATE_STOPPED;

    // if (m_fPlayWhenIdle || !MixListIsEmpty()) m_pDest->Stop();
    if (m_fPlayWhenIdle) m_pDest->Stop();

    return TRUE;
}

void CGrace::PlayWhenIdle()
{
    m_fPlayWhenIdle = TRUE;
    if (MixListIsEmpty()) ClearAndPlayDest();
}

void CGrace::StopWhenIdle()
{
    m_fPlayWhenIdle = FALSE;
    if (MixListIsEmpty()) m_pDest->Stop();
}

HRESULT CGrace::ClearAndPlayDest(void)
{
    PVOID   pvLockedBuffer;
    int     cbLockedBuffer;
    int     cbBuffer;
    HRESULT hr;

    //
    // 1) Lock the entire dest buffer
    // 2) Fill it with silence
    // 3) Unlock the dest buffer
    // 4) Play the darn thing
    //

    cbBuffer = m_pDest->m_cSamples << m_pDest->m_nBlockAlignShift;
    
    hr = m_pDest->Lock(&pvLockedBuffer, &cbLockedBuffer, NULL, NULL, 0, cbBuffer);

    if (S_OK == hr && pvLockedBuffer && cbLockedBuffer > 0)
    {
        //  Write the silence.
            FillMemory(pvLockedBuffer, cbLockedBuffer, (H_16_BITS & m_pDest->m_hfFormat) ? 0x00 : 0x80);
            m_pDest->Unlock(pvLockedBuffer, cbLockedBuffer, 0, 0);

            m_pDest->Play();
    }

    return hr;
}

void CGrace::MixListAdd(CMixSource *pSource)
{
    ASSERT(MixListIsValid());
    ASSERT(!pSource->m_pNextMix);
    ASSERT(!pSource->m_pPrevMix);
    ASSERT(MIXERSTATE_STOPPED != m_kMixerState);

    // if the mix list is empty, we may need to run the MixDest.  We may
    // also need to make a state transition from IDLE to STARTING.
    if (MixListIsEmpty()) {
        if (!m_fPlayWhenIdle) ClearAndPlayDest();
        if (MIXERSTATE_IDLE == m_kMixerState) m_kMixerState = MIXERSTATE_STARTING;
    } else {
        ASSERT(MIXERSTATE_IDLE != m_kMixerState);
    }

    // initialize source-specific mixer state
    pSource->m_kMixerState = MIXSOURCESTATE_NEW;
    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_NEW;
    pSource->m_nLastFrequency = pSource->m_nFrequency;

    // prepare the source's filter
    pSource->FilterPrepare(this->GetMaxRemix());

    // doubly linked list insertion
    pSource->m_pNextMix = m_pSourceListZ->m_pNextMix;
    m_pSourceListZ->m_pNextMix->m_pPrevMix = pSource;
    m_pSourceListZ->m_pNextMix = pSource;
    pSource->m_pPrevMix = m_pSourceListZ;
}

void CGrace::MixListRemove(CMixSource *pSource)
{
    ASSERT(MixListIsValid());
    ASSERT(pSource->m_pNextMix);
    ASSERT(pSource->m_pPrevMix);
    ASSERT(MIXERSTATE_STOPPED != m_kMixerState);
    ASSERT(MIXERSTATE_IDLE != m_kMixerState);

    // doubly linked list deletion
    pSource->m_pPrevMix->m_pNextMix = pSource->m_pNextMix;
    pSource->m_pNextMix->m_pPrevMix = pSource->m_pPrevMix;
    pSource->m_pNextMix = NULL;
    pSource->m_pPrevMix = NULL;

    // unpreprare the source's filter
    pSource->FilterUnprepare();
    //
    pSource->m_kMixerState = MIXSOURCESTATE_STOPPED;

    // if we should stop the MixDest when there's nothing to mix, then also
    // transition to the IDLE state.
    if (!m_fPlayWhenIdle && MixListIsEmpty()) {
        m_pDest->Stop();
        m_kMixerState = MIXERSTATE_IDLE;
    }
}

//--------------------------------------------------------------------------;
//
// CGrace::FilterOn
//
//        Instructs mixer to enable filtering of the MixSource
//
// If filtering is already on, then do nothing.  Otherwise, set the H_FILTER
// flag in the MixSource.  Also, if the MixSource is not stopped, then prepare
// and clear the filter.
//
//--------------------------------------------------------------------------;

void CGrace::FilterOn(CMixSource *pSource)
{
    if (0 == (H_FILTER & pSource->m_hfFormat)) {
        pSource->m_hfFormat |= H_FILTER;
        if (pSource->IsPlaying()) {
            pSource->FilterPrepare(this->GetMaxRemix());
            pSource->FilterClear();
        }
    }
}

//--------------------------------------------------------------------------;
//
// CGrace::FilterOff
//
//        Instructs mixer to disable filtering of the MixSource
//
// If filtering is already off, then do nothing.  Otherwise, clear the H_FILTER
// flag in the MixSource.  Also, if the MixSource is not stopped, then
// unprepare the filter.
//
//--------------------------------------------------------------------------;

void CGrace::FilterOff(CMixSource *pSource)
{
    if (H_FILTER & pSource->m_hfFormat) {
        if (pSource->IsPlaying()) {
            pSource->FilterUnprepare();
        }
        pSource->m_hfFormat &= ~H_FILTER;
    }
}

BOOL CGrace::MixListIsValid()
{
    CMixSource *pSourceT;

    for (pSourceT = MixListGetNext(m_pSourceListZ); pSourceT; pSourceT = MixListGetNext(pSourceT)) {
        // if (DSBUFFSIG != pSourceT->m_pdsb->dwSig) break;
        // if (DSB_INTERNALF_HARDWARE & pSourceT->m_pdsb->fdwDsbI) break;
        // if (0 == pSourceT->m_nFrequency) break;
        if (MIXSOURCE_SIGNATURE != pSourceT->m_dwSignature) break;
    }

    return (!pSourceT);
}

CMixSource* CGrace::MixListGetNext(CMixSource* pSource)
{
    if (pSource->m_pNextMix != m_pSourceListZ) {
        return pSource->m_pNextMix;
    } else {
        return NULL;
    }
}

BOOL CGrace::MixListIsEmpty(void)
{
    return (m_pSourceListZ->m_pNextMix == m_pSourceListZ);
}

//--------------------------------------------------------------------------;
//
// CGrace::GetBytePosition
//
// This function returns the play and write cursor positions of a secondary
// buffer that is being software mixed into a primary buffer.  The position is
// computed from the position of the primary buffer into which it is being
// mixed.  This function also returns the "mix cursor" which is the next
// position of the secondary buffer from which data will be mixed on a mixer
// refresh event.  The region from the write cursor to the mix cursor is the
// premixed region of the buffer.  Note that a remix event may cause the grace
// mixer to mix from a position before the mix cursor.
//
//--------------------------------------------------------------------------;

void CGrace::GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite)
{
    int     posPPlay;
    int     posPWrite;
    LONG    dposPPlay;
    LONG    dposPWrite;

    LONG    posSPlay;
    LONG    posSWrite;
    LONG    dposSPlay;
    LONG    dposSWrite;

    LONG    posP1;
    LONG    posP2;

    if (pibPlay) *pibPlay = 0;
    if (pibWrite) *pibWrite = 0;

    if (S_OK != m_pDest->GetSamplePosition(&posPPlay, &posPWrite)) {
#ifdef Not_VxD
        DPF(0, "Couldn't GetSamplePosition of primary");
#else
        DPF(("Couldn't GetSamplePosition of primary"));
#endif
        posPPlay = posPWrite = 0;
    }

    //
    // The logic below to compute source position is quite difficult
    // to understand and hard to explain without sufficient illustration.
    // I won't attempt to write paragraphs of comments here.  Instead I
    // hope to add a design document to this project describing this
    // logic.  I wonder if I'll ever really do it.
    //
    ASSERT(pSource->m_nLastFrequency);

    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            posP1 = m_posPNextMix;
            dposSWrite = 0;
            break;

        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
        case MIXSOURCESUBSTATE_STARTING:
            posP1 = pSource->m_posPStart;
            dposPWrite = m_posPNextMix - posPWrite;
            if (dposPWrite < 0) dposPWrite += m_pDest->m_cSamples;
            ASSERT(dposPWrite >= 0);
            dposSWrite = MulDivRD(dposPWrite, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
            break;
            
        case MIXSOURCESUBSTATE_STARTED:
            posP1 = posPPlay;
            dposPWrite = m_posPNextMix - posPWrite;
            if (dposPWrite < 0) dposPWrite += m_pDest->m_cSamples;
            ASSERT(dposPWrite >= 0);
            dposSWrite = MulDivRD(dposPWrite, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    switch (pSource->m_kMixerState)
    {
        case MIXSOURCESTATE_STOPPED:
            ASSERT(FALSE);
            break;

        case MIXSOURCESTATE_NEW:
        case MIXSOURCESTATE_LOOPING:
        case MIXSOURCESTATE_NOTLOOPING:
            posP2 = m_posPNextMix;
            break;

        case MIXSOURCESTATE_ENDING_WAITINGPRIMARYWRAP:
            if (posPPlay < pSource->m_posPPlayLast)
                if (posPPlay >= pSource->m_posPEnd)
                    posP2 = posP1 + 1;
                else
                    posP2 = pSource->m_posPEnd;
            else
                posP2 = pSource->m_posPEnd;
            break;

        case MIXSOURCESTATE_ENDING:
            if (posPPlay >= pSource->m_posPEnd || posPPlay < pSource->m_posPPlayLast)
                posP2 = posP1 + 1;
            else
                posP2 = pSource->m_posPEnd;
            break;
        
        default:
            ASSERT(FALSE);
            break;
    }

    if (pSource->m_kMixerSubstate == MIXSOURCESUBSTATE_NEW) {
        dposPPlay = 0;
        dposSPlay = 0;
    } else {
        dposPPlay = posP2 - posP1;
        if (dposPPlay <= 0) dposPPlay += m_pDest->m_cSamples;
        ASSERT(dposPPlay >= 0);
        dposPPlay = max(0, dposPPlay-1);
        dposSPlay  = MulDivRD(dposPPlay, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
    }

    posSPlay = pSource->m_posNextMix - dposSPlay;
    while (posSPlay < 0) posSPlay += pSource->m_cSamples;

    posSWrite = pSource->m_posNextMix - dposSWrite;
    posSWrite += pSource->m_nFrequency * HW_WRITE_CURSOR_MSEC_PAD / 1024;
    while (posSWrite >= pSource->m_cSamples) posSWrite -= pSource->m_cSamples;
    while (posSWrite < 0) posSWrite += pSource->m_cSamples;

    if (pibPlay)  *pibPlay  = posSPlay  << pSource->m_nBlockAlignShift;
    if (pibWrite) *pibWrite = posSWrite << pSource->m_nBlockAlignShift;
}

/***************************************************************************
 *
 *  LockCircularBuffer
 *
 *  Description:
 *      Locks a hardware or software sound buffer.
 *
 *  Arguments:
 *      PLOCKCIRCULARBUFFER [in/out]: lock parameters.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT LockCircularBuffer(PLOCKCIRCULARBUFFER pLock)
{
    const LPVOID pvInvalidLock = (LPVOID)-1;
    const DWORD  cbInvalidLock = (DWORD)-1;
    HRESULT      hr            = DS_OK;
    DWORD        dwMask;
    LPVOID       pvLock[2];
    DWORD        cbLock[2];
    
    // Calculate the valid lock pointers
    pvLock[0] = (LPBYTE)pLock->pvBuffer + pLock->ibRegion;

    if(pLock->ibRegion + pLock->cbRegion > pLock->cbBuffer)
    {
        cbLock[0] = pLock->cbBuffer - pLock->ibRegion;

        pvLock[1] = pLock->pvBuffer;
        cbLock[1] = pLock->cbRegion - cbLock[0];
    }
    else
    {
        cbLock[0] = pLock->cbRegion;

        pvLock[1] = NULL;
        cbLock[1] = 0;
    }

    // Do we really need to lock the hardware buffer?
    if(pLock->pHwBuffer)
    {
        if(pLock->fPrimary)
        {
            dwMask = DSDDESC_DONTNEEDPRIMARYLOCK;
        }
        else
        {
            dwMask = DSDDESC_DONTNEEDSECONDARYLOCK;
        }
        
        if(dwMask == (pLock->fdwDriverDesc & dwMask))
        {
            pLock->pHwBuffer = NULL;
        }
    }

    // Initialize the lock's out parameters
    if(pLock->pHwBuffer && pLock->fPrimary)
    {
        pLock->pvLock[0] = pLock->pvLock[1] = pvInvalidLock;
        pLock->cbLock[0] = pLock->cbLock[1] = cbInvalidLock;
    }
    else
    {
        pLock->pvLock[0] = pvLock[0];
        pLock->cbLock[0] = cbLock[0];
        
        pLock->pvLock[1] = pvLock[1];
        pLock->cbLock[1] = cbLock[1];
    }

    // Lock the hardware buffer
    if(pLock->pHwBuffer)
    {
        #ifndef NOVXD
            #ifdef Not_VxD
                hr = VxdBufferLock(pLock->pHwBuffer,
                                   &pLock->pvLock[0], &pLock->cbLock[0],
                                   &pLock->pvLock[1], &pLock->cbLock[1],
                                   pLock->ibRegion, pLock->cbRegion, 0);
            #else
                hr = pLock->pHwBuffer->Lock(&pLock->pvLock[0], &pLock->cbLock[0],
                                            &pLock->pvLock[1], &pLock->cbLock[1],
                                            pLock->ibRegion, pLock->cbRegion, 0);
            #endif
        #else // NOVXD
            ASSERT(!pLock->pHwBuffer);
        #endif // NOVXD
    }

    // If there's no driver present or the driver doesn't support locking, 
    // we'll just fill in the proper values ourselves
    if(DSERR_UNSUPPORTED == hr)
    {
        pLock->pvLock[0] = pvLock[0];
        pLock->cbLock[0] = cbLock[0];
        
        pLock->pvLock[1] = pvLock[1];
        pLock->cbLock[1] = cbLock[1];

        hr = DS_OK;
    }

    // Validate the returned pointers
    if(SUCCEEDED(hr) && pLock->pHwBuffer && pLock->fPrimary)
    {
        if(pvInvalidLock == pLock->pvLock[0] || pvInvalidLock == pLock->pvLock[1] ||
           cbInvalidLock == pLock->cbLock[0] || cbInvalidLock == pLock->cbLock[1])
        {
            #ifdef Not_VxD
                DPF(DPFLVL_ERROR, "This driver doesn't know how to lock a primary buffer!");
            #else // Not_VxD
                DPF(("This driver doesn't know how to lock a primary buffer!"));
            #endif // Not_VxD

            hr = DSERR_UNSUPPORTED;
        }
    }

    return hr;
}

/***************************************************************************
 *
 *  UnlockCircularBuffer
 *
 *  Description:
 *      Unlocks a hardware or software sound buffer.
 *
 *  Arguments:
 *      PLOCKCIRCULARBUFFER [in/out]: lock parameters.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT UnlockCircularBuffer(PLOCKCIRCULARBUFFER pLock)
{
    HRESULT hr = DS_OK;
    DWORD   dwMask;
    
    // Do we really need to unlock the hardware buffer?
    if(pLock->pHwBuffer)
    {
        if(pLock->fPrimary)
        {
            dwMask = DSDDESC_DONTNEEDPRIMARYLOCK;
        }
        else
        {
            dwMask = DSDDESC_DONTNEEDSECONDARYLOCK;
        }
        
        if(dwMask == (pLock->fdwDriverDesc & dwMask))
        {
            pLock->pHwBuffer = NULL;
        }
    }

    // Unlock the hardware buffer
    if(pLock->pHwBuffer)
    {
        #ifndef NOVXD
            #ifdef Not_VxD
                hr = VxdBufferUnlock(pLock->pHwBuffer,
                                     pLock->pvLock[0], pLock->cbLock[0],
                                     pLock->pvLock[1], pLock->cbLock[1]);
            #else
                hr = pLock->pHwBuffer->Unlock(pLock->pvLock[0], pLock->cbLock[0],
                                              pLock->pvLock[1], pLock->cbLock[1]);
            #endif
        #else // NOVXD
            ASSERT(!pLock->pHwBuffer);
        #endif // NOVXD
    }

    // If there's no driver present or the driver doesn't support unlocking, 
    // that's ok.
    if(DSERR_UNSUPPORTED == hr)
    {
        hr = DS_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\grace.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef __GRACE_INCLUDED__
#define __GRACE_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

#include "modeflag.h"
    
#define N_EMU_WAVE_HDRS_INQUEUE     3
#define HW_WRITE_CURSOR_MSEC_PAD    10

#ifdef Not_VxD

__inline DWORD PadHardwareWriteCursor(DWORD dwPosition, DWORD cbBuffer, LPCWAVEFORMATEX pwfx)
{
    return PadCursor(dwPosition, cbBuffer, pwfx, HW_WRITE_CURSOR_MSEC_PAD);
}

#endif // Not_VxD

#ifndef NUMELMS
#define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif // NUMELMS

#define CACHE_MINSIZE   64          // big enough for LOWPASS_SIZE + delay
#define LOWPASS_SIZE    32          // how many samples to average
#define FILTER_SHIFT    5           // log2(LOWPASS_SIZE)

typedef struct _FIRSTATE {
    FLOAT       LastDryAttenuation;
    FLOAT       LastWetAttenuation;
#ifdef SMOOTH_ITD
    int         iLastDelay;
#endif
} FIRSTATE, *PFIRSTATE;

typedef struct _FIRCONTEXT {
    LONG*       pSampleCache;           // cache of previous samples
    int         cSampleCache;           // num samples in the cache
    int         iCurSample;             // next sample goes at this offset
    FIRSTATE*   pStateCache;            // remember state once in a while
    int         cStateCache;            // num entries in cache
    int         iCurState;              // where in the state cache we are
    int         iStateTick;             // when it's time to remember state
    FLOAT       DistAttenuation;        // attenuation from distance
    FLOAT       ConeAttenuation;        // attenuation from cone effect
    FLOAT       ConeShadow;             // shadow from cone effect
    FLOAT       PositionAttenuation;    // attenuation from 3D position & dist
    FLOAT       PositionShadow;         // dry/wet ratio, basically
    FLOAT       TotalDryAttenuation;    // multiply dry amplitude by this
    FLOAT       LastDryAttenuation;     // what we did last time
    FLOAT       TotalWetAttenuation;    // multiply wet amplitude by this
    FLOAT       LastWetAttenuation;     // what we did last time
    FLOAT       VolSmoothScale;         // constant for volume smoothing
    FLOAT       VolSmoothScaleRecip;    // its reciprocal
    FLOAT       VolSmoothScaleDry;      // constants to use for volume smoothing
    FLOAT       VolSmoothScaleWet;      // in inner loop
    int         iSmoothFreq;            // freq used to compute VolSmooth
    BOOL        fLeft;                  // are we making left or right channel?
    int         iDelay;                 // want to delay by this many samples
#ifdef SMOOTH_ITD
    int         iLastDelay;             // last time we delayed by this much
#endif
} FIRCONTEXT, *PFIRCONTEXT;

//
// Possible mixer signals, per ds object
//
#define DSMIXERSIGNAL_REMIX             0x00000001

//
// Possible reasons for signaling the mixer to remix, per buffer
//
#define DSBMIXERSIGNAL_SETPOSITION      0x00000001

//
// The number of samples in a remix interval.  The remix interval specifies
// the sample points at which we might perform remixes (that is, rewind to).
// This is specified in samples.  Make it a power of 2 so that some of the
// arithmatic compiles to efficient code.
//
#define MIXER_REWINDGRANULARITY         128
    
//
// Possible states of a Direct Sound buffer being mixed
//
typedef enum {
    MIXSOURCESTATE_STOPPED = 0,
    MIXSOURCESTATE_NEW,
    MIXSOURCESTATE_LOOPING,
    MIXSOURCESTATE_NOTLOOPING,
    MIXSOURCESTATE_ENDING_WAITINGPRIMARYWRAP,
    MIXSOURCESTATE_ENDING
} MIXSOURCESTATE;

typedef enum {
    MIXSOURCESUBSTATE_NEW = 0,
    MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP,
    MIXSOURCESUBSTATE_STARTING,
    MIXSOURCESUBSTATE_STARTED
} MIXSOURCESUBSTATE;

//
// Possible states of a Mixer
//
typedef enum {
    MIXERSTATE_STOPPED = 0,
    MIXERSTATE_IDLE,
    MIXERSTATE_STARTING,
    MIXERSTATE_LOOPING
} MIXERSTATE;

__inline LONG MulDivRD(LONG a, LONG b, LONG c)
{
    return (LONG)(Int32x32To64(a,b) / c);
}

__inline LONG MulDivRN(LONG a, LONG b, LONG c)
{
    return (LONG)((Int32x32To64(a,b)+c/2) / c);
}

__inline LONG MulDivRU(LONG a, LONG b, LONG c)
{
    return (LONG)((Int32x32To64(a,b)+(c-1)) / c);
}

__inline DWORD UMulDivRD(DWORD a, DWORD b, DWORD c)
{
    return (DWORD)(UInt32x32To64(a,b) / c);
}

__inline DWORD UMulDivRN(DWORD a, DWORD b, DWORD c)
{
    return (DWORD)((UInt32x32To64(a,b)+c/2) / c);
}

__inline DWORD UMulDivRDClip(DWORD a, DWORD b, DWORD c)
{
    DWORDLONG t;
    DWORDLONG q;
    DWORD result;

    t = UInt32x32To64(a, b);
    q = t / c;
    result = (DWORD) q;
    if (q > result) result = (DWORD)(-1);
    return result;
}

#ifdef __cplusplus

class CMixer;

#define MIXSOURCE_SIGNATURE ((DWORD)'CRSM')

class CMixSource {
    public:
        CMixSource(CMixer *pMixer);
        ~CMixSource(void);
        HRESULT     Initialize(PVOID pBuffer, int cbBuffer, LPWAVEFORMATEX pwfx, PFIRCONTEXT *ppFirContextLeft, PFIRCONTEXT *ppFirContextRight);
        BOOL        IsPlaying(void);
        void        SignalRemix(void);
        BOOL        Stop(void);
        void        Play(BOOL fLooping);
        void        Update(int ibUpdate1, int cbUpdate1, int ibUpdate2, int cbUpdate2);
        void        SetFrequency(ULONG nFrequency);
        ULONG       GetFrequency();
        void        SetVolumePan(PDSVOLUMEPAN pdsVolPan);
        void        SetBytePosition(int ibPosition);
        void        GetBytePosition1(int *pibPlay, int *pibWrite);
        void        GetBytePosition(int *pibPlay, int *pibWrite, int *pibMix);
        BOOL        GetMute(void) {return m_fMute || m_fFilterError || m_fMute3d;}
        void        FilterOn(void);
        void        FilterOff(void);
        BOOL        HasFilter(void) {return (m_hfFormat & H_FILTER) != 0;}

        void        NotifyToPosition(IN int ibPositoin, OUT PLONG pdtimeToNextNotify);
        BOOL        HasNotifications(void);
        void        NotifyStop(void);
        HRESULT     SetNotificationPositions(int cNotes, LPCDSBPOSITIONNOTIFY paNotes);

        void        CountSamplesMixed(int cSamples);
        void        CountSamplesRemixed(int cSamples);

        void        FilterPrepare(int cMaxRewindSamples);
        void        FilterUnprepare(void);
        void        FilterClear(void);
        void        FilterChunkUpdate(int cSamples);
        void        FilterRewind(int cSamples);
        void        FilterAdvance(int cSamples);

        DWORD               m_dwSignature;
        int                 m_cSamplesInCache;
        int                 m_cSamples;
        int                 m_cbBuffer;
        PVOID               m_pBuffer;
        PFIRCONTEXT*        m_ppFirContextLeft;
        PFIRCONTEXT*        m_ppFirContextRight;

        CMixer*             m_pMixer;
        CMixSource*         m_pNextMix;
        CMixSource*         m_pPrevMix;
        
        MIXSOURCESTATE      m_kMixerState;
        MIXSOURCESUBSTATE   m_kMixerSubstate;

        DWORD               m_hfFormat;             // PCM format flag desc of stream buffer
        int                 m_nBlockAlignShift;
        ULONG               m_nFrequency;           // real sample rate including Doppler

        BOOL                m_fMute;
        BOOL                m_fMute3d;
        DWORD               m_dwLVolume;            // For mixer use - linear Left Voume
        DWORD               m_dwRVolume;            // For mixer use - linear Right Voume
        DWORD               m_dwMVolume;            // For mixer use - linear MONO Voume

        ULONG               m_nLastFrequency;
        int                 m_posPStart;
        int                 m_posPEnd;
        int                 m_posPPlayLast;
        int                 m_posNextMix;
        DWORD               m_fdwMixerSignal;

        // Mix session data
        DWORD               m_step_fract;
        DWORD               m_step_whole[2];

        PLONG               m_MapTable;
        DWORD               m_dwLastLVolume;
        DWORD               m_dwLastRVolume;

        DWORD               m_dwFraction;
        ULONG               m_nLastMergeFrequency;  // Can't use m_nLastFrequency (set to m_nFrequency before call to mixMixSession).
        BOOL                m_fUse_MMX;

    private:
        int                 GetNextMixBytePosition();
        void                LoopingOn(void);
        void                LoopingOff(void);

        class CDsbNotes *   m_pDsbNotes;

        BOOL                m_fFilterError;

        int                 m_cSamplesMixed;
        int                 m_cSamplesRemixed;
};

#ifdef PROFILEREMIXING
__inline void CMixSource::CountSamplesMixed(int cSamples) { m_cSamplesMixed += cSamples; }
__inline void CMixSource::CountSamplesRemixed(int cSamples) { m_cSamplesRemixed += cSamples; }
#else
__inline void CMixSource::CountSamplesMixed(int cSamples) { return; }
__inline void CMixSource::CountSamplesRemixed(int cSamples) { return; }
#endif

//--------------------------------------------------------------------------;
//
// Woefully uncommented mixer destination abstract base class.
//
//--------------------------------------------------------------------------;

class CMixDest {
    public:
        virtual HRESULT Initialize(void) =0;
        virtual void Terminate(void) =0;
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx) =0;
        virtual void SetFormatInfo(LPWAVEFORMATEX pwfx) =0;
        virtual HRESULT AllocMixer(CMixer **ppMixer) =0;
        virtual void FreeMixer(void) =0;
        virtual void Play(void) =0;
        virtual void Stop(void) =0;
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite) =0;
        virtual ULONG GetFrequency(void) =0;
};

//--------------------------------------------------------------------------;
//
// Woefully uncommented mixer abstract base class.
//
//--------------------------------------------------------------------------;

class CMixer {
    public:
        virtual void Terminate(void) =0;
        virtual HRESULT Run(void) =0;
        virtual BOOL Stop(void) =0;
        virtual void PlayWhenIdle(void) =0;
        virtual void StopWhenIdle(void) =0;
        virtual void MixListAdd(CMixSource *pSource) =0;
        virtual void MixListRemove(CMixSource *pSource) =0;
        virtual void FilterOn(CMixSource *pSource) =0;
        virtual void FilterOff(CMixSource *pSource) =0;
        virtual void GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite) =0;
        virtual void SignalRemix() =0;
};


//--------------------------------------------------------------------------;
//
// Mixer destination class for mixers in dsound.dll (CWeGrace and CNagrace).
//
//--------------------------------------------------------------------------;

class CGrDest : public CMixDest {
    public:
        virtual HRESULT Initialize(void)=0;
        virtual void Terminate(void)=0;
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx)=0;
        virtual void SetFormatInfo(LPWAVEFORMATEX pwfx);
        virtual HRESULT AllocMixer(CMixer **ppMixer)=0;
        virtual void FreeMixer(void)=0;
        virtual void Play(void)=0;
        virtual void Stop(void)=0;
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite)=0;
        virtual HRESULT GetSamplePositionNoWin16(int *pposPlay, int *pposWrite)=0;
        virtual ULONG GetFrequency(void);
        virtual HRESULT Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite);
        virtual HRESULT Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2);

        // REMIND try to get these outta here, or at least protected/private
        int             m_cSamples;
        int             m_cbBuffer;
        PVOID           m_pBuffer;

        DWORD           m_hfFormat;
        ULONG           m_nFrequency;
        int             m_nBlockAlignShift;

        WAVEFORMATEX    m_wfx;
};

//--------------------------------------------------------------------------;
//
// CGrace: base class for CMixer implementations in dsound.dll.
//
//--------------------------------------------------------------------------;

class CGrace : public CMixer {
    public:
        virtual HRESULT Initialize(CGrDest *pGrDest);
        virtual void Terminate(void);
        virtual HRESULT Run(void);
        virtual BOOL Stop(void);
        virtual void PlayWhenIdle(void);
        virtual void StopWhenIdle(void);
        virtual void MixListAdd(CMixSource *pSource);
        virtual void MixListRemove(CMixSource *pSource);
        virtual void FilterOn(CMixSource *pSource);
        virtual void FilterOff(CMixSource *pSource);
        virtual void GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite);

        virtual HRESULT ClearAndPlayDest(void);
        virtual void SignalRemix(void)=0;
        virtual int GetMaxRemix(void)=0;

        virtual void Refresh(BOOL fRemix, int cPremixMax, int *pcPremixed, PLONG pdtimeNextNotify);
        
    protected:
        CGrDest*    m_pDest;
        int         m_fdwMixerSignal;
        MIXERSTATE  m_kMixerState;
        
    private:
        void MixNewBuffer(               CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);
        void MixLoopingBuffer(           CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);
        void MixNotLoopingBuffer(        CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);
        void MixEndingBufferWaitingWrap( CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);
        void MixEndingBuffer(            CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);

        BOOL MixListIsValid();
        CMixSource* MixListGetNext(CMixSource *pSource);
        BOOL MixListIsEmpty();

        void mixBeginSession(int cbOutput);
        int mixMixSession(CMixSource *pSource, PDWORD pdwInputPos, DWORD dwInputBytes, DWORD OutputOffset);
        void mixWriteSession(DWORD dwWriteOffset);

        PLONG       m_plBuildBuffer;
        int         m_cbBuildBuffer;
        PLONG       m_plBuildBound;
        int         m_n_voices;


        int         m_fPlayWhenIdle;
        int         m_posPWriteLast;
        int         m_posPNextMix;
        int         m_posPPlayLast;
        ULONG       m_nLastFrequency;

        // Ptr to doubly-linked list sentinel
        CMixSource* m_pSourceListZ;

        // Handle secondary mixes
        BOOL        m_fUseSecondaryBuffer;
        PLONG       m_pSecondaryBuffer;
        LONG        m_dwSecondaryBufferFrequency;
        LONG        m_cbSecondaryBuffer;
};

//--------------------------------------------------------------------------;
//
// CWeGrace and CNaGrace class declarations;
// Respectively, the "waveOut-emulated" and "native" mixers.
//
//--------------------------------------------------------------------------;
class CWeGrace : public CGrace {
    public:
        virtual void    SignalRemix(void) {m_fdwMixerSignal |= DSMIXERSIGNAL_REMIX;}
        virtual int     GetMaxRemix(void) {return 0;} // No remixing in emulation mode
        virtual void    Refresh(int cPremixMax);
};

#ifndef NOVXD

class CNaGrace : public CGrace {
    public:
        virtual HRESULT Initialize(CGrDest *pGrDest);
        virtual void    Terminate(void);
        virtual void    SignalRemix(void);
        virtual int     GetMaxRemix(void);
        virtual void    MixThread(void);

    private:
        // Named events shared across client processes and the mixer
        // thread.  Note these are format strings
        static const char strFormatMixEventRemix[];
        static const char strFormatMixEventTerminate[];

        // Maximum amount of data we will premix, expressed in milliseconds
        static const int MIXER_MINPREMIX;
        static const int MIXER_MAXPREMIX;

        HANDLE          m_hMixThread;
        DWORD           m_vxdhMixEventRemix;
        DWORD           m_vxdhMixEventTerminate;
};

//--------------------------------------------------------------------------;
//
// CThMixer: "thunk" mixer - forwards methods to the mixer in dsound.vxd.
//
//--------------------------------------------------------------------------;
class CThMixer : public CMixer {
    public:
        virtual void Terminate(void);
        virtual HRESULT Run(void);
        virtual BOOL Stop(void);
        virtual void PlayWhenIdle(void);
        virtual void StopWhenIdle(void);
        virtual void MixListAdd(CMixSource *pSource);
        virtual void MixListRemove(CMixSource *pSource);
        virtual void FilterOn(CMixSource *pSource);
        virtual void FilterOff(CMixSource *pSource);
        virtual void GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite);
        virtual void SignalRemix(void);

        virtual HRESULT Initialize(PVOID pKeMixer);

    private:
        PVOID m_pKeMixer;
};

#endif // NOVXD

//--------------------------------------------------------------------------;
//
// CWeGrDest and CNaGrDest class declarations.
// The mixer destinations corresponding to CWeGrace and CNaGrace.
//
//--------------------------------------------------------------------------;
class CWeGrDest : public CGrDest {
    friend DWORD WINAPI WaveThreadC(PVOID pThreadParams);
    friend VOID CALLBACK WaveCallbackC(HWAVE hwo, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    friend class CEmRenderDevice;
            
    public:
        CWeGrDest(UINT uWaveDeviceId);
        virtual HRESULT Initialize(void);
        virtual void Terminate(void);
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx);
        virtual HRESULT AllocMixer(CMixer **ppMixer);
        virtual void FreeMixer(void);
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite);
        virtual HRESULT GetSamplePositionNoWin16(int *pposPlay, int *pposWrite);
        virtual void Play();
        virtual void Stop();
        
    private:
        MMRESULT InitializeEmulator(void);
        MMRESULT ShutdownEmulator(void);
        void WaveThreadLoop(HANDLE heventTerminate);
        DWORD WaveThread(void);
        VOID CALLBACK WaveCallback(HWAVE hwo, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

        
        UINT        m_uDeviceId;
        HWAVEOUT    m_hwo;
        WAVEHDR*    m_awhWaveHeaders;
        int         m_cWaveHeaders;
        int         m_iawhPlaying;
        LONG        m_cwhDone;
        int         m_cbDMASize;
        HANDLE      m_hWaveThread;
        MMRESULT    m_mmrWaveThreadInit;
        TCHAR       m_szEventWaveThreadInitDone[32];
        TCHAR       m_szEventWaveHeaderDone[32];
        TCHAR       m_szEventTerminateWaveThread[32];
        HANDLE      m_hEventWaveHeaderDone;
    
        CWeGrace*   m_pWeGrace;
};

#ifndef NOVXD

typedef struct _NAGRDESTDATA {
    LPBYTE          pBuffer;
    DWORD           cbBuffer;
    HANDLE          hBuffer;
    LPHWAVEOUT      phwo;
    UINT            uDeviceId;
    DWORD           fdwDriverDesc;
} NAGRDESTDATA, *LPNAGRDESTDATA;

class CNaGrDest : public CGrDest {
    public:
        CNaGrDest(LPNAGRDESTDATA);
        virtual HRESULT Initialize(void);
        virtual void Terminate(void);
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx);
        virtual HRESULT AllocMixer(CMixer **);
        virtual void FreeMixer(void);
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite);
        virtual HRESULT GetSamplePositionNoWin16(int *pposPlay, int *pposWrite);
        virtual HRESULT Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite);
        virtual HRESULT Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2);
        virtual void Play();
        virtual void Stop();

    private:
        HANDLE      m_hBuffer;
        LPBYTE      m_pHwBuffer;
        DWORD       m_fdwDriverDesc;
        LPHWAVEOUT  m_phwo;
        UINT        m_uDeviceId;
        CNaGrace*   m_pNaGrace;
};

inline HRESULT CNaGrDest::GetSamplePositionNoWin16(int *pposPlay, int *pposWrite)
{
    return GetSamplePosition(pposPlay, pposWrite);
}

//--------------------------------------------------------------------------;
//
// CThDest: "thunk" mixer destination - forwards methods to the dsound.vxd mixer
//
//--------------------------------------------------------------------------;
class CThDest : public CMixDest {
    public:
        CThDest(LPNAGRDESTDATA pData);
        virtual HRESULT New(void);
        virtual HRESULT Initialize(void);
        virtual void Terminate(void);
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx);
        virtual void SetFormatInfo(LPWAVEFORMATEX pwfx);
        virtual HRESULT AllocMixer(CMixer **ppMixer);
        virtual void FreeMixer(void);
        virtual void Play(void);
        virtual void Stop(void);
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite);
        virtual ULONG GetFrequency(void);

    private:
        PVOID           m_pKeDest;
        CThMixer*       m_pThMixer;
        NAGRDESTDATA    m_ngdd;
};

#endif // NOVXD

#endif // __cplusplus

extern BOOL FilterPrepare(PFIRCONTEXT pFilter, int cMaxRewindSamples);
extern void FilterUnprepare(PFIRCONTEXT pFilter);
extern void FilterClear(PFIRCONTEXT pFilter);
extern void FilterChunkUpdate(PFIRCONTEXT pFilter, int cSamples);
extern void FilterRewind(PFIRCONTEXT pFilter, int cSamples);
extern void FilterAdvance(PFIRCONTEXT pFilter, int cSamples);

//--------------------------------------------------------------------------;
//
// CircularBufferRegionsIntersect
//
//        Determines whether two regions of a circular buffer intersect.
//
// Note:  I'm sure there's some well known, nice, simple algorithm to
// do this.  But I don't know it.  Here's what I came up with.
//
//--------------------------------------------------------------------------;
__inline BOOL CircularBufferRegionsIntersect
(
    int cbBuffer,
    int iStart1,
    int iLen1,
    int iStart2,
    int iLen2
)
{
    int iEnd1;
    int iEnd2;

    ASSERT(iStart1 >= 0);
    ASSERT(iStart2 >= 0);
    ASSERT(iStart1 + iLen1 >= 0);
    ASSERT(iStart2 + iLen2 >= 0);

    iEnd1 = iStart1 + iLen1;
    iEnd2 = iStart2 + iLen2;

    if ((0 == iLen1) || (0 == iLen2)) return FALSE;
    if (iStart1 == iStart2) return TRUE;
    
    // Handle r1 does not wrap
    if ((iStart1 < iStart2) && (iEnd1 > iStart2)) return TRUE;

    // Handle r2 does not wrap
    if ((iStart2 < iStart1) && (iEnd2 > iStart1)) return TRUE;

    // Handle r1 wraps
    if (iEnd1 >= cbBuffer)
    {
        iEnd1 -= cbBuffer;
        ASSERT(iEnd1 < cbBuffer);
        if (iEnd1 > iStart2) return TRUE;
    }

    // Handle r2 wraps
    if (iEnd2 >= cbBuffer)
    {
        iEnd2 -= cbBuffer;
        ASSERT(iEnd2 < cbBuffer);
        if (iEnd2 > iStart1) return TRUE;
    }
    
    return FALSE;
}

typedef struct _LOCKCIRCULARBUFFER {
#ifdef Not_VxD
    HANDLE              pHwBuffer;      // Hardware buffer pointer
#else // Not_VxD
    PIDSDRIVERBUFFER    pHwBuffer;      // Hardware buffer pointer
#endif // Not_VxD
    LPVOID              pvBuffer;       // Memory buffer pointer
    DWORD               cbBuffer;       // Memory buffer size, in bytes
    BOOL                fPrimary;       // TRUE if this is a primary buffer
    DWORD               fdwDriverDesc;  // Driver description flags
    DWORD               ibRegion;       // Byte index of region to lock
    DWORD               cbRegion;       // Size, in bytes, of region to lock
    LPVOID              pvLock[2];      // Returned lock pointers
    DWORD               cbLock[2];      // Returned lock sizes
} LOCKCIRCULARBUFFER, *PLOCKCIRCULARBUFFER;

extern HRESULT LockCircularBuffer(PLOCKCIRCULARBUFFER);
extern HRESULT UnlockCircularBuffer(PLOCKCIRCULARBUFFER);

#ifdef Not_VxD
// kernel mixer synchronization macros
extern LONG lMixerMutexMutex;
extern PLONG gpMixerMutex;
extern DWORD tidMixerOwner;
extern int cMixerEntry;

__inline DWORD ENTER_MIXER_MUTEX_OR_EVENT(HANDLE hEvent)
{
    BOOL fWait = TRUE;
    DWORD tidThisThread = GetCurrentThreadId();
    DWORD dwWait = WAIT_TIMEOUT;

    while (fWait)
    {
        // Wait for access to the mutex
        while (InterlockedExchange(&lMixerMutexMutex, TRUE))
            Sleep(1);

        // Is the event signalled?
        if (hEvent)
        {
            dwWait = WaitObject(0, hEvent);
            if (WAIT_OBJECT_0 == dwWait)
                fWait = FALSE;
        }            

        if (fWait)
        {
            if (InterlockedExchange(gpMixerMutex, TRUE))
            {
                // Somebody's got the mixer, see if it is this thread
                if (tidMixerOwner == tidThisThread)
                {
                    ASSERT(cMixerEntry > 0);
                    cMixerEntry++;
                    fWait = FALSE;
                }
            }
            else
            {
                ASSERT(0 == cMixerEntry);
                tidMixerOwner = tidThisThread;
                cMixerEntry++;
                fWait = FALSE;
            }
        }

        // No longer accessing the mutex
        InterlockedExchange(&lMixerMutexMutex, FALSE);

        if (fWait)
            Sleep(1);
    }

    return dwWait;
}

__inline void ENTER_MIXER_MUTEX(void)
{
    ENTER_MIXER_MUTEX_OR_EVENT(NULL);
}

__inline void LEAVE_MIXER_MUTEX(void)
{
    DWORD tidThisThread = GetCurrentThreadId();
    
    // Wait for access to the mutex
    while (InterlockedExchange(&lMixerMutexMutex, TRUE)) Sleep(1);

    ASSERT(tidMixerOwner == tidThisThread);
    if (0 == --cMixerEntry) {
        tidMixerOwner = 0;
        InterlockedExchange(gpMixerMutex, FALSE);
    }

    InterlockedExchange(&lMixerMutexMutex, FALSE);
}
#else // Not_VxD
__inline void ENTER_MIXER_MUTEX(void) { ASSERT(FALSE); }
__inline void LEAVE_MIXER_MUTEX(void) { ASSERT(FALSE); }

#endif // Not_VxD

#ifdef __cplusplus
};
#endif

#endif // __GRACE_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\ists.cpp ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>

/**************************************************************************

          Terminal Server helper functions

 **************************************************************************/

#define WINMM_CONSOLE_AUDIO_EVENT L"Global\\WinMMConsoleAudioEvent"

//
// Check if the Windows XP+ Personal Terminal Services feature is present
// (this enables both Remote Desktop/Assistance and Fast User Switching).
//
BOOL IsPersonalTerminalServicesEnabled(void)
{
    static BOOL fRet;
    static BOOL fVerified = FALSE;

    if (!fVerified)
    {
        DWORDLONG dwlConditionMask = 0;
        OSVERSIONINFOEX osVersionInfo;

        RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osVersionInfo.wProductType = VER_NT_WORKSTATION;
        osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;

        VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        fRet = VerifyVersionInfo(&osVersionInfo, VER_PRODUCT_TYPE | VER_SUITENAME, dwlConditionMask);

        fVerified = TRUE;
    }

    return fRet;
}

//
// Check if we're in a remote session but playing audio directly to the console
// [Leave at remote machine set from the TS client in Local resources tab].
//
BOOL IsTsConsoleAudioEnabled(void)
{
    BOOL fRemoteConsoleAudio = FALSE;
    static HANDLE hConsoleAudioEvent = NULL;

    if (NtCurrentPeb()->SessionId == 0 || IsPersonalTerminalServicesEnabled())
    {
        if (hConsoleAudioEvent == NULL)
            hConsoleAudioEvent = OpenEvent(SYNCHRONIZE, FALSE, WINMM_CONSOLE_AUDIO_EVENT);

        if (hConsoleAudioEvent != NULL)
        {
            DWORD status = WaitForSingleObject(hConsoleAudioEvent, 0);
            if (status == WAIT_OBJECT_0)
                fRemoteConsoleAudio = TRUE;
        }
    }

    return fRemoteConsoleAudio;
}

//
// Returns TRUE if we are not on the console AND not playing audio on the console
//
BOOL IsRedirectedTSAudio(void)
{
    BOOL fOnConsole = (USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId);
    return !fOnConsole && !IsTsConsoleAudioEnabled();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\iirlut.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iirlut.cpp
 *  Content:    DirectSound3D IIR algorithm look up table
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/

// Project-specific INCLUDEs
#include "dsoundi.h"
#include "iirlut.h"
#include <limits.h>   
#include "rfcircvec.h"
#include <math.h>   

// ---------------------------------------------------------------------------
// Enumerations

enum EStateSpaceCoeffs {
    tagStateSpaceB0,
    tagStateSpaceB1,
    tagStateSpaceB2,
    tagStateSpaceA0,
    tagStateSpaceA1,
    tagStateSpaceA2,
    estatespacecoeffsCount
};

// ---------------------------------------------------------------------------
// Typedefs

typedef FLOAT TStateSpace[estatespacecoeffsCount];

// ---------------------------------------------------------------------------
// Defines

// Coefficient prologue code to obtain coefficient indices from parameters
#define COEFFICIENTPROLOGUECODE\
    ASSERT(Cd3dvalAzimuth >= Cd3dvalMinAzimuth && Cd3dvalAzimuth <= Cd3dvalMaxAzimuth);\
    ASSERT(Cd3dvalElevation >= Cd3dvalMinElevation && Cd3dvalElevation <= Cd3dvalMaxElevation);\
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);\
    int iAzimuthIndex;\
    UINT uiElevationIndex;\
    AnglesToIndices(Cd3dvalAzimuth, Cd3dvalElevation, iAzimuthIndex, uiElevationIndex);\
    ASSERT(uiElevationIndex >= 0 && uiElevationIndex < CuiNumElevationBins);\
    ASSERT(static_cast<UINT>(abs(iAzimuthIndex)) < CauiNumAzimuthBins[uiElevationIndex])

// ---------------------------------------------------------------------------
// Constants

#define CuiStateSpaceCoeffsHalf (estatespacecoeffsCount / 2)


/***************************************************************************
 *
 *  CIirLut
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIirLut::CIirLut"

CIirLut::CIirLut()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CIirLut);

    m_pfCoeffs = NULL;
    m_psCoeffs = NULL;

    m_hLutFile = NULL;
    m_hLutFileMapping = NULL;
    m_pfLut = NULL;

    InitData();

    DPF_LEAVE_VOID();
}

/***************************************************************************
 *
 *  FreeCoefficientMemory
 *
 *  Description:
 *      Frees memory holding the coefficient LUT.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIirLut:FreeCoefficientMemory"

VOID CIirLut::FreeCoefficientMemory()
{
    DPF_ENTER();

    MEMFREE(m_pfCoeffs);
    MEMFREE(m_psCoeffs);

    DPF_LEAVE_VOID();
}

// Initialize (build LUT)
HRESULT CIirLut::Initialize
(
    const KSDS3D_HRTF_COEFF_FORMAT CeCoeffFormat, 
    const KSDS3D_HRTF_FILTER_QUALITY CeCoeffQuality,
    DWORD dwSpeakerConfig
)
{
    HRESULT hr;

    size_t  CstTotalBiquadCoeffsAlloc;
    size_t  CstTotalCanonicalCoeffsAlloc;
    UINT    uiCoeffIndex = 0;
    TCHAR   szDllName[MAX_PATH];

    ASSERT(CeCoeffFormat >= 0 && CeCoeffFormat < KSDS3D_COEFF_COUNT);
    ASSERT(CeCoeffQuality >= 0 && CeCoeffQuality < KSDS3D_FILTER_QUALITY_COUNT);

    // Store speaker configuration and coefficient format
    hr = ConvertDsSpeakerConfig(dwSpeakerConfig, &m_eSpeakerConfig);
    ASSERT(m_eSpeakerConfig >= 0 && m_eSpeakerConfig < espeakerconfigCount);

    if(SUCCEEDED(hr))
    {
        // Store speaker configuration and coefficient format and quality level
        m_eCoeffFormat = CeCoeffFormat;
        m_eCoeffQuality = CeCoeffQuality;

        // Reallocate memory
        CstTotalBiquadCoeffsAlloc = m_aauiNumBiquadCoeffs[CeCoeffQuality][m_eSpeakerConfig];
        CstTotalCanonicalCoeffsAlloc = m_aauiNumCanonicalCoeffs[CeCoeffQuality][m_eSpeakerConfig];
        FreeCoefficientMemory();
        switch(CeCoeffFormat) 
        {
            case FLOAT_COEFF:
                // Reallocate memory for FLOAT coefficients
                m_pfCoeffs = MEMALLOC_A(FLOAT, CstTotalCanonicalCoeffsAlloc);
                hr = HRFROMP(m_pfCoeffs);
                break;
            
            case SHORT_COEFF:
                // Reallocate memory for SHORT coefficients
                m_psCoeffs = MEMALLOC_A(SHORT, CstTotalBiquadCoeffsAlloc);
                hr = HRFROMP(m_psCoeffs);
                break;

            default:
                hr = DSERR_INVALIDPARAM;
                break;
        }
    }

    // Map the HRTF LUT located in dsound3d.dll
    if(SUCCEEDED(hr))
    {
        if(0 == GetSystemDirectory(szDllName, MAX_PATH))
        {
            //  Couldn't get the Window system dir!
            DPF(DPFLVL_ERROR, "Can't get system directory");
            hr = DSERR_GENERIC;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(szDllName[lstrlen(szDllName)-1] != TEXT('\\'))
        {
            lstrcat(szDllName, TEXT("\\"));
        }
        lstrcat(szDllName, TEXT("dsound3d.dll"));

        m_hLutFile = LoadLibrary(szDllName);
        if(!m_hLutFile)
        {
            hr = DSERR_GENERIC;
            DPF(DPFLVL_ERROR, "Can't load dsound3d.dll");
        }
    }

    if(SUCCEEDED(hr))
    {
        m_pfLut = (PFLOAT)GetProcAddress(m_hLutFile, "CafBiquadCoeffs");
        hr = HRFROMP(m_pfLut);
    }
    
    if(SUCCEEDED(hr))
    { 

        // Go through complete coefficient LUT
        UINT uiTotalElevationFilters(0);
#ifdef DEBUG
        const DWORD CdwSpeakerConfigOffset(GetBiquadCoeffOffset(CeCoeffQuality, m_eSpeakerConfig, static_cast<ESampleRate>(0), 0, 0, TRUE));
        DWORD dwLastBiquadOffsetEnd(CdwSpeakerConfigOffset);
#endif
        for (UINT uiSampleRate(0); uiSampleRate<esamplerateCount && SUCCEEDED(hr); ++uiSampleRate)
            for (UINT uiElevation(0); uiElevation<CuiNumElevationBins && SUCCEEDED(hr); ++uiElevation) {
                // Store number of filters for up to one specific elevation
                m_aauiNumPreviousElevationFilters[uiSampleRate][uiElevation] = uiTotalElevationFilters;
                
                // Add up all elevation filters so far (subtract one for non-existent zero-degree delta filter)
                uiTotalElevationFilters += efilterCount * CauiNumAzimuthBins[uiElevation] - 1;
                
                // Go through all azimuth angles and filters (sigma and delta)
                for (UINT uiAzimuth(0); uiAzimuth<CauiNumAzimuthBins[uiElevation] && SUCCEEDED(hr); ++uiAzimuth)
                    for (UINT uiFilter(0); uiFilter<efilterCount && SUCCEEDED(hr); ++uiFilter) {
                        // Get number of biquad coefficients
                        const BYTE CbyNumBiquadCoeffs = CaaaaaabyNumBiquadCoeffs[CeCoeffQuality][m_eSpeakerConfig][uiSampleRate][uiFilter][uiElevation][uiAzimuth];

                        // Get biquad offset
                        DWORD dwBiquadOffset;
                        switch (uiFilter) {
                            case tagDelta:
                                dwBiquadOffset = GetBiquadCoeffOffset(CeCoeffQuality, m_eSpeakerConfig, static_cast<ESampleRate>(uiSampleRate), uiElevation, uiAzimuth, true);
                                break;
  
                            case tagSigma:
                                dwBiquadOffset = static_cast<DWORD>(GetBiquadCoeffOffset(CeCoeffQuality, m_eSpeakerConfig, static_cast<ESampleRate>(uiSampleRate), uiElevation, uiAzimuth, true) 
                                    + CaaaaaabyNumBiquadCoeffs[CeCoeffQuality][m_eSpeakerConfig][uiSampleRate][tagDelta][uiElevation][uiAzimuth]);
                                break;

                            default:
                                hr = DSERR_INVALIDPARAM;
                                break;
                        }
#ifdef DEBUG
                        ASSERT(dwBiquadOffset % ebiquadcoefftypeCount == 0);
                        ASSERT(dwLastBiquadOffsetEnd == dwBiquadOffset);
                        dwLastBiquadOffsetEnd = dwBiquadOffset + CbyNumBiquadCoeffs;
#endif // DEBUG

                        if (CbyNumBiquadCoeffs > 0)
                            // Convert coefficients
                            switch (CeCoeffFormat) {
                                case FLOAT_COEFF: {
                                    // Convert to FLOAT canonical representation
                                    ASSERT(m_pfCoeffs != NULL);
                                    const UINT CuiNumCanonicalCoeffs(NumBiquadCoeffsToNumCanonicalCoeffs(static_cast<UINT>(CbyNumBiquadCoeffs)));
#ifdef DEBUG
                                    UINT uiNumCanonicalCoeffs(0);
#endif // DEBUG
                                    TCanonicalCoeffs tCanonicalCoeffs;
                                    if (BiquadToCanonical(&m_pfLut[dwBiquadOffset], CbyNumBiquadCoeffs, tCanonicalCoeffs))
                                    {
                                        for (UINT uiCoeffType(0); uiCoeffType<ecanonicalcoefftypeCount; ++uiCoeffType)
                                            for (UINT ui(0); ui<NumCanonicalCoeffsToHalf(CuiNumCanonicalCoeffs); ++ui)
                                                // Skip a0 = 1
                                                if (uiCoeffType != tagCanonicalA || ui != 0) {
#ifdef DEBUG
                                                    uiNumCanonicalCoeffs++;
#endif // DEBUG
                                                    m_pfCoeffs[uiCoeffIndex++] = tCanonicalCoeffs[uiCoeffType][ui];
                                                }
                                    }
                                    else
                                    {
                                        //Let's assume that Biquad to Canonical only fails from memory constraints
                                        hr = DSERR_OUTOFMEMORY;
                                    }
#ifdef DEBUG
                                    ASSERT(uiNumCanonicalCoeffs == CuiNumCanonicalCoeffs);
#endif // DEBUG
                                }
                                break;

                                case SHORT_COEFF: {
                                    // Convert to SHORT biquad
                                    ASSERT(m_psCoeffs != NULL);
                                    for (DWORD dw(dwBiquadOffset); dw<dwBiquadOffset + CbyNumBiquadCoeffs; ++dw) {
                                        ASSERT(m_pfLut[dw] <= CfMaxBiquadCoeffMagnitude);
#ifdef DEBUG
                                        ASSERT(CdwSpeakerConfigOffset + uiCoeffIndex == dw);
#endif // DEBUG
                                        m_psCoeffs[uiCoeffIndex++] = FloatBiquadCoeffToShortBiquadCoeff(m_pfLut[dw]);
                                    }
                                }
                                break;

                                default:
                                    hr = DSERR_INVALIDPARAM;
                                    break;
                            }
                    }
            }
    }


#ifdef DEBUG
    if(SUCCEEDED(hr))
    {
        switch (CeCoeffFormat) {
            case FLOAT_COEFF:
                ASSERT(uiCoeffIndex == CstTotalCanonicalCoeffsAlloc);
            break;

            case SHORT_COEFF:
                ASSERT(uiCoeffIndex == CstTotalBiquadCoeffsAlloc);
            break;
        
            default:
                ASSERT(FALSE);
                break;
        }
    }
#endif //DEBUG

    return hr;
}

// Check if coefficients have changed since the last call to GetCoeffs
HRESULT CIirLut::ConvertDsSpeakerConfig
(
    DWORD dwSpeakerConfig,
    ESpeakerConfig* peSpeakerConfig
)
{
    HRESULT hr = DS_OK;

    switch(DSSPEAKER_CONFIG(dwSpeakerConfig))
    {
        case DSSPEAKER_HEADPHONE:
            *peSpeakerConfig = tagHeadphones;
            break;

        case DSSPEAKER_DIRECTOUT:
        case DSSPEAKER_STEREO:
        case DSSPEAKER_MONO:
        case DSSPEAKER_QUAD:
        case DSSPEAKER_SURROUND:
        case DSSPEAKER_5POINT1:
        case DSSPEAKER_7POINT1:
           
            switch(DSSPEAKER_GEOMETRY(dwSpeakerConfig))
            {
                case DSSPEAKER_GEOMETRY_NARROW:
                case DSSPEAKER_GEOMETRY_MIN:
                    *peSpeakerConfig = tagSpeakers10Degrees;
                    break;

                case DSSPEAKER_GEOMETRY_WIDE:
                case DSSPEAKER_GEOMETRY_MAX:
                case 0:
                    *peSpeakerConfig = tagSpeakers20Degrees;
                    break;

                // Anything else
                default:
                    hr = DSERR_INVALIDPARAM;
                    break;
            }

            break;

        default:
            hr = DSERR_INVALIDPARAM;
            break;
    }

    return hr;
}

// Check if coefficients have changed since the last call to GetCoeffs
BOOL CIirLut::HaveCoeffsChanged
(
    const D3DVALUE Cd3dvalAzimuth, 
    const D3DVALUE Cd3dvalElevation, 
    const ESampleRate CeSampleRate,
    const EFilter CeFilter
)
{
    // Coefficient prologue code to obtain coefficient indices from parameters
    COEFFICIENTPROLOGUECODE;
    
    // Check if coefficient index parameters have changed
    if (iAzimuthIndex == m_aiPreviousAzimuthIndex[CeFilter] && uiElevationIndex == m_auiPreviousElevationIndex[CeFilter] && CeSampleRate == m_aePreviousSampleRate[CeFilter]) {
        // Set this to be safe during debugging
        m_bZeroAzimuthTransition = false;
        m_bSymmetricalZeroAzimuthTransition = false;
        
        // Coefficient indices haven't changed
        return false;
    }
    else
        // Coefficient indices have changed
        return true;
}


// Get coefficients
const PVOID CIirLut::GetCoeffs
(
    const D3DVALUE Cd3dvalAzimuth, 
    const D3DVALUE Cd3dvalElevation, 
    const ESampleRate CeSampleRate, 
    const EFilter CeFilter, 
    PUINT ruiNumCoeffs
)
{
    PVOID  pvCoeffs;

    // Coefficient prologue code to obtain coefficient indices from parameters
    COEFFICIENTPROLOGUECODE;
    ASSERT(CeFilter >= 0 && CeFilter < efilterCount);

     // Check for zero azimuth transition
    if (((iAzimuthIndex >= 0 && m_aiPreviousAzimuthIndex[CeFilter] < 0) || (iAzimuthIndex < 0 && m_aiPreviousAzimuthIndex[CeFilter] == 0) ||(iAzimuthIndex < 0 && m_aiPreviousAzimuthIndex[CeFilter] > 0)) && m_aiPreviousAzimuthIndex[CeFilter] != INT_MAX)
        m_bZeroAzimuthTransition = true;
    else
        m_bZeroAzimuthTransition = false;

    // Check for symmetrical zero azimuth transition
    if (iAzimuthIndex == -m_aiPreviousAzimuthIndex[CeFilter])
        m_bSymmetricalZeroAzimuthTransition = true;
    else
        m_bSymmetricalZeroAzimuthTransition = false;
    
    // Set previous negative azimuth flag (for zero azimuth overlap calculation)
    if (m_aiPreviousAzimuthIndex[CeFilter] < 0)
        m_bPreviousNegativeAzimuth = true;
    else
        m_bPreviousNegativeAzimuth = false;

    // Set previous zero azimuth index flag (for zero azimuth overlap calculation)
    if (m_aiPreviousAzimuthIndex[CeFilter] == 0)
        m_bPreviousZeroAzimuthIndex = true;
    else
        m_bPreviousZeroAzimuthIndex = false;

#ifdef DEBUG
    // Sanity check
//    if (m_bSymmetricalZeroAzimuthTransition)
//        ASSERT(m_bZeroAzimuthTransition);
#endif

    // Cache away new coefficient index data
    m_aiPreviousAzimuthIndex[CeFilter] = iAzimuthIndex;
    m_auiPreviousElevationIndex[CeFilter] = uiElevationIndex;
    m_aePreviousSampleRate[CeFilter] = CeSampleRate;

    // Get number of biquad coefficients
    ASSERT(m_eSpeakerConfig >= 0 && m_eSpeakerConfig < espeakerconfigCount);
    const UINT CuiAzimuthIndex(abs(iAzimuthIndex));
    const BYTE CbyNumBiquadCoeffs(CaaaaaabyNumBiquadCoeffs[m_eCoeffQuality][m_eSpeakerConfig][CeSampleRate][CeFilter][uiElevationIndex][CuiAzimuthIndex]);
    
    // Get pointer to coefficients
    const DWORD CdwBiquadOffset(GetBiquadCoeffOffset(m_eCoeffQuality, m_eSpeakerConfig, CeSampleRate, uiElevationIndex, CuiAzimuthIndex, false));
    ASSERT(CdwBiquadOffset % ebiquadcoefftypeCount == 0);

    switch (m_eCoeffFormat) {
        case FLOAT_COEFF: {
            // Calculate offset
            UINT uiNumPreviousFilters(m_aauiNumPreviousElevationFilters[CeSampleRate][uiElevationIndex] + efilterCount * CuiAzimuthIndex);
            if (CuiAzimuthIndex > 0)
                // Subtract non-existent 0 degree delta filter
                uiNumPreviousFilters--;
            const DWORD CdwCanonicalOffset(4 * (CdwBiquadOffset / ebiquadcoefftypeCount) + uiNumPreviousFilters);
            
            // Get pointer
            ASSERT(m_pfCoeffs != NULL);
            switch (CeFilter) {
                case tagDelta:
                    pvCoeffs = &m_pfCoeffs[CdwCanonicalOffset];
                    break;

                case tagSigma:
                    pvCoeffs = &m_pfCoeffs[CdwCanonicalOffset + NumBiquadCoeffsToNumCanonicalCoeffs(CaaaaaabyNumBiquadCoeffs[m_eCoeffQuality][m_eSpeakerConfig][CeSampleRate][tagDelta][uiElevationIndex][CuiAzimuthIndex])];
                    break;

                default:
                    break;
            }
            
            // Get number of coefficients
            *ruiNumCoeffs = NumBiquadCoeffsToNumCanonicalCoeffs(CbyNumBiquadCoeffs);

/*  This optimization causes NT bug 266819
            PFLOAT pfCoeffs = (PFLOAT) pvCoeffs;
            if((LIGHT_FILTER == m_eCoeffQuality) && (0 != *ruiNumCoeffs) 
                && (0.0f == pfCoeffs[2]) && (0.0f == pfCoeffs[4]))
            {
                ASSERT(5 == *ruiNumCoeffs);    
                *ruiNumCoeffs = 3;

                pfCoeffs[2] = pfCoeffs[3];
                pfCoeffs[3] = 0.0f;
            }
*/

            break;
        }
        
        case SHORT_COEFF:
        {
            // Get pointer
            ASSERT(m_psCoeffs != NULL);
            switch (CeFilter) {
                case tagDelta:
                    pvCoeffs = &m_psCoeffs[CdwBiquadOffset];
                    break;

                case tagSigma:
                    pvCoeffs = &m_psCoeffs[CdwBiquadOffset + CaaaaaabyNumBiquadCoeffs[m_eCoeffQuality][m_eSpeakerConfig][CeSampleRate][tagDelta][uiElevationIndex][CuiAzimuthIndex]];
                    break;

                default:
                    break;
            }

            // Get number of coefficients
            *ruiNumCoeffs = CbyNumBiquadCoeffs;
            break;
        }

        default:
            break;
    }
    
    return pvCoeffs;

}

// Initialize data
VOID CIirLut::InitData()
{
    // Initialize variables
//    ASSERT(SIZE_OF_ARRAY(m_pfLut) == CuiTotalBiquadCoeffs);

    m_bNegativeAzimuth = false;
    m_bZeroAzimuthIndex = false;


    m_eSpeakerConfig = espeakerconfigCount;

    m_bNegativeAzimuth = false;
    m_bPreviousNegativeAzimuth = false;
    m_bZeroAzimuthIndex = false;
    m_bPreviousZeroAzimuthIndex = false;
    m_eCoeffFormat = KSDS3D_COEFF_COUNT;
    m_eCoeffQuality = KSDS3D_FILTER_QUALITY_COUNT;
    m_eSpeakerConfig = espeakerconfigCount;
    m_bZeroAzimuthTransition = false;
    m_bSymmetricalZeroAzimuthTransition = false;
    m_pfCoeffs = NULL;
    m_psCoeffs = NULL;
    
    // Initialize cache variables
    for (UINT ui(0); ui<efilterCount; ++ui) {
        m_auiPreviousElevationIndex[ui] = UINT_MAX;
        m_aiPreviousAzimuthIndex[ui] = INT_MAX;
        m_aePreviousSampleRate[ui] = esamplerateCount;
    }

    // Go through all coefficient quality levels and speaker configurations
#ifdef DEBUG
    const BYTE CbyMaxBiquadCoeffs(static_cast<BYTE>(NumBiquadsToNumBiquadCoeffs(CbyMaxBiquads)));
#endif
    m_byMaxBiquadCoeffs = 0;
    for (UINT uiCoeffQuality(0); uiCoeffQuality<KSDS3D_FILTER_QUALITY_COUNT; ++uiCoeffQuality)
        for (UINT uiSpeakerConfig(0); uiSpeakerConfig<espeakerconfigCount; ++uiSpeakerConfig) {
            // Calculate number of coefficients for each speaker configuration and coefficient quality level
            UINT uiNumBiquadCoeffs(0);
            UINT uiNumCanonicalCoeffs(0);
            
            // Go through all sample rates, filters, elevation and azimuth angles
            for (UINT uiSampleRate(0); uiSampleRate<esamplerateCount; ++uiSampleRate)
                for (UINT uiFilter(0); uiFilter<efilterCount; ++uiFilter)
                    for (UINT uiElevation(0); uiElevation<CuiNumElevationBins; ++uiElevation)
                        for (UINT uiAzimuth(0); uiAzimuth<CauiNumAzimuthBins[uiElevation]; ++uiAzimuth) {
                            // Add up number of biquad coefficients
                            const BYTE CbyNumBiquadCoeffs(CaaaaaabyNumBiquadCoeffs[uiCoeffQuality][uiSpeakerConfig][uiSampleRate][uiFilter][uiElevation][uiAzimuth]);
#ifdef DEBUG
                            ASSERT(CbyNumBiquadCoeffs <= CbyMaxBiquadCoeffs);
#endif // DEBUG
                            uiNumBiquadCoeffs += CbyNumBiquadCoeffs;
                            uiNumCanonicalCoeffs += NumBiquadCoeffsToNumCanonicalCoeffs(CbyNumBiquadCoeffs);

                            // Determine overall maximum number of coefficients
                            if (CbyNumBiquadCoeffs > m_byMaxBiquadCoeffs)
                                m_byMaxBiquadCoeffs = CbyNumBiquadCoeffs;
                        }
            
            // Store number of coefficients for each speaker configuration and quality level
            ASSERT(uiNumBiquadCoeffs < CuiTotalBiquadCoeffs);
#ifdef DEBUG
            ASSERT(uiNumBiquadCoeffs % ebiquadcoefftypeCount == 0);
#endif // DEBUG
            m_aauiNumBiquadCoeffs[uiCoeffQuality][uiSpeakerConfig] = uiNumBiquadCoeffs;
//            ASSERT((uiNumCanonicalCoeffs & 1) == 0);  // John Norris removed for final LUT drop
            m_aauiNumCanonicalCoeffs[uiCoeffQuality][uiSpeakerConfig] = uiNumCanonicalCoeffs;
        }

    
    ASSERT(m_byMaxBiquadCoeffs > 0);
    ASSERT(m_byMaxBiquadCoeffs <= CbyMaxBiquadCoeffs);
}

// Convert azimuth and elevation angles to indices into LUT
VOID CIirLut::AnglesToIndices
(
    D3DVALUE d3dvalAzimuth, 
    D3DVALUE d3dvalElevation, 
    int& riAzimuthIndex, 
    UINT& ruiElevationIndex
)
{
    ASSERT(d3dvalAzimuth >= Cd3dvalMinAzimuth && d3dvalAzimuth <= Cd3dvalMaxAzimuth);

    // Check for out of range elevations
    if (d3dvalElevation > Cd3dvalMaxElevationData)
        d3dvalElevation = Cd3dvalMaxElevationData;
    if (d3dvalElevation < Cd3dvalMinElevationData)
        d3dvalElevation = Cd3dvalMinElevationData;
    
    // Get elevation index by rounding floating-point elevation angle to the nearest integer elevation index
    ruiElevationIndex = static_cast<UINT>(((d3dvalElevation - Cd3dvalMinElevationData) / Cd3dvalElevationResolution) + 0.5f);
    
    // Check for out of range azimuthal angles
    if (d3dvalAzimuth > Cd3dvalMaxAzimuth)
        d3dvalAzimuth = Cd3dvalMaxAzimuth;
    if (d3dvalAzimuth < Cd3dvalMinAzimuth)
        d3dvalAzimuth = Cd3dvalMinAzimuth;
    
    // Get azimuth index by rounding floating-point azimuth angle to the nearest signed integer azimuth index (positive or negative)
    UINT uiAzimuthIndex(static_cast<int>((static_cast<FLOAT>(fabs(d3dvalAzimuth)) / (Cd3dvalAzimuthRange / (CauiNumAzimuthBins[ruiElevationIndex]))) + 0.5f));

    // Discard 180 degree azimuth data
    if (uiAzimuthIndex >= CauiNumAzimuthBins[ruiElevationIndex])
        uiAzimuthIndex = CauiNumAzimuthBins[ruiElevationIndex] - 1;

    // Take care of negative azimuth angles and set negative azimuth flag
    riAzimuthIndex = uiAzimuthIndex;
    if (d3dvalAzimuth < 0 && uiAzimuthIndex != 0) {
        m_bNegativeAzimuth = true;
        riAzimuthIndex = -riAzimuthIndex;
    }
    else
        m_bNegativeAzimuth = false;
}

// Convert coefficients into floating-point canonical form
BOOL CIirLut::BiquadToCanonical
(
    const FLOAT CpCfBiquadCoeffs[], 
    const UINT CuiNumBiquadCoeffs, 
    TCanonicalCoeffs &rtCanonicalCoeffs
)
{
    BOOL fRetVal = TRUE;
//    CHECK_POINTER(CpCfBiquadCoeffs);
    ASSERT(CuiNumBiquadCoeffs >= ebiquadcoefftypeCount);
    
    // Convert coefficients
    for (UINT uiCoeffType(0); uiCoeffType<ecanonicalcoefftypeCount; ++uiCoeffType) {
        // Allocate circular vectors
        const UINT CuiOffset(CuiStateSpaceCoeffsHalf * uiCoeffType);
        const UINT CuiNumBiquads(NumBiquadCoeffsToNumBiquads(CuiNumBiquadCoeffs));
        const size_t CstNumCoeffs(NumBiquadsToNumCanonicalCoeffsHalf(CuiNumBiquads));
        CRfCircVec circvecInput;
        if (!circvecInput.Init(CstNumCoeffs, 0.0f))
        {
            fRetVal = FALSE;
            break;
        }
        CRfCircVec circvecOutput;
        if (!circvecOutput.Init(CstNumCoeffs, 0.0f))
        {
            fRetVal = FALSE;
            break;
        }

        // Initialize input circular vector with unit impulse
        circvecInput.Write(1.0f);
        
        // Go through all biquads
        for (size_t stBiquad(0); stBiquad<CuiNumBiquads; ++stBiquad) {
            // Initialize state space vector
            TStateSpace tStateSpace;
            const UINT CuiBiquadIndex(ebiquadcoefftypeCount * stBiquad);
            const FLOAT CfScalingFactor(2.0f);
            tStateSpace[tagStateSpaceB0] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadB0];
            tStateSpace[tagStateSpaceB1] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadB1];
            tStateSpace[tagStateSpaceB2] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadB2];
            tStateSpace[tagStateSpaceA0] = 1.0f;
            tStateSpace[tagStateSpaceA1] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadA1];
            tStateSpace[tagStateSpaceA2] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadA2];
/*
#ifdef DEBUG
            if((0.0f ==tStateSpace[tagStateSpaceA2]) && 
                (tStateSpace[tagStateSpaceA1]<-1.0f) || (tStateSpace[tagStateSpaceA1]>1.0f))
            {
                ASSERT(0);
            } 
#endif // DEBUG
*/

            // Go through all coefficients
            for (size_t stCoeff(0); stCoeff<CstNumCoeffs; ++stCoeff) {
                // Calculate output of FIR filter
                FLOAT fW(0.0f);
                for (UINT ui(0); ui<CuiStateSpaceCoeffsHalf; ++ui)
                    fW += tStateSpace[CuiOffset + ui] * circvecInput.LIFORead();
                
                // Save output of FIR filter
                circvecOutput.Write(fW);
                
                // Adjust input index for FIR feedback
                circvecInput.SetIndex(circvecOutput.GetIndex());
                circvecInput.SkipForward();
            }

            // Feed output back into input
            circvecInput.FIFOFill(circvecOutput);
            
            // Forward circular buffers
            circvecInput.SkipForward();
            circvecOutput.SkipForward();
        }

        // Save canonical coefficients
        circvecOutput.SkipBack();
        for (size_t stCoeff(0); stCoeff<CstNumCoeffs; ++stCoeff)
            rtCanonicalCoeffs[uiCoeffType][stCoeff] = circvecOutput.FIFORead();
    }
    return fRetVal;
}

/***************************************************************************
 *
 *  DsFrequencyToIirSampleRate
 *
 *  Description:
 *      Converts DirectSound SampleRate to IIR LUT Sample Rate.
 *
 *  Arguments:
 *      DWORD [in]:  DirectSound 3D mode.
 *      DWORD [out]: KS 3D mode.
 *
 *  Returns:  
 *      HRESULT: KSDATAFORMAT_DSOUND control flags.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsFrequencyToIirSampleRate"

HRESULT 
CIirLut::DsFrequencyToIirSampleRate
(
    DWORD            dwDsFrequency,
    ESampleRate*    IirLutSampleRate
)
{
    HRESULT        hr = DS_OK;

    if(0<dwDsFrequency && 9512>=dwDsFrequency)
        *IirLutSampleRate = tag8000Hz;
    else if(9512<dwDsFrequency && 13512>=dwDsFrequency)
        *IirLutSampleRate = tag11025Hz;
    else if(13512<dwDsFrequency && 19025>=dwDsFrequency)
        *IirLutSampleRate = tag16000Hz;
    else if(19025<dwDsFrequency && 27025>=dwDsFrequency)
        *IirLutSampleRate = tag22050Hz;
    else if(27025<dwDsFrequency && 38050>=dwDsFrequency)
        *IirLutSampleRate = tag32000Hz;
    else if(38050<dwDsFrequency && 46050>=dwDsFrequency)
        *IirLutSampleRate = tag44100Hz;
    else
        *IirLutSampleRate = tag48000Hz;

    return hr;
}

// ---------------------------------------------------------------------------
// Undefines

#undef COEFFICIENTPROLOGUECODE

// ---------------------------------------------------------------------------
// Include inline definitions out-of-line in debug version

#ifdef DEBUG
#include "iirlut.inl"
#endif

// End of LUT.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\ks3d.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ks3d.cpp
 *  Content:    WDM/CSA 3D object class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/6/98      dereks  Created.
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifdef NOKS
#error ks3d.cpp being built with NOKS defined
#endif // NOKS

#include "dsoundi.h"


/***************************************************************************
 *
 *  CKs3dListener
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKs3dListener::CKs3dListener"

CKs3dListener::CKs3dListener(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKs3dListener);

    // Initialize defaults
    m_dwSpeakerConfig = DSSPEAKER_DEFAULT;
    m_fAllocated = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKs3dListener
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKs3dListener::~CKs3dListener"

CKs3dListener::~CKs3dListener(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKs3dListener);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateAllObjects
 *
 *  Description:
 *      Updates all objects.
 *
 *  Arguments:
 *      DWORD [in]: parameters flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKs3dListener::UpdateAllObjects"

HRESULT CKs3dListener::UpdateAllObjects
(
    DWORD                   dwListener
)
{
    BOOL                    fTrue   = TRUE;
    BOOL                    fFalse  = FALSE;
    HRESULT                 hr;

    DPF_ENTER();

    // Place the driver into batch mode
    SetProperty
    (
        KSPROPSETID_DirectSound3DListener,
        KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
        &fTrue,
        sizeof(fTrue)
    );

    // Update all objects
    hr =
        C3dListener::UpdateAllObjects
        (
            dwListener
        );

    // Remove the driver from batch mode
    SetProperty
    (
        KSPROPSETID_DirectSound3DListener,
        KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
        &fFalse,
        sizeof(fFalse)
    );

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets a property on the object's 3D node.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKs3dListener::SetProperty"

HRESULT
CKs3dListener::SetProperty
(
    REFGUID                     guidPropertySet,
    ULONG                       ulPropertyId,
    LPCVOID                     pvData,
    ULONG                       cbData
)
{
    CNode<CKsHw3dObject *> *    pNode   = m_lstHw3dObjects.GetListHead();
    HRESULT                     hr      = DS_OK;

    DPF_ENTER();

    if(pNode)
    {
        hr =
            pNode->m_data->SetProperty
            (
                guidPropertySet,
                ulPropertyId,
                pvData,
                cbData
            );
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CKsItd3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKs3dListener * [in]: listener pointer.
 *      CKsSecondaryRenderWaveBuffer * [in]: owning buffer object.
 *      DWORD [in]: buffer frequency.
 *      HANDLE [in]: pin handle.
 *      BOOL [in]: TRUE to mute at max distance.
 *      ULONG [in]: ITD 3D node id.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::CKsItd3dObject"

CKsItd3dObject::CKsItd3dObject
(
    CKs3dListener *                 pListener,
    BOOL                            fMuteAtMaxDistance,
    BOOL                            fDopplerEnabled,
    DWORD                           dwFrequency,
    CKsSecondaryRenderWaveBuffer *  pBuffer,
    HANDLE                          hPin,
    ULONG                           ulNodeId
)
    : CItd3dObject(pListener, fMuteAtMaxDistance, fDopplerEnabled, dwFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsItd3dObject);

    // Intialize defaults
    m_pBuffer = pBuffer;
    m_hPin = hPin;
    m_ulNodeId = ulNodeId;
    m_fMute = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsItd3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::~CKsItd3dObject"

CKsItd3dObject::~CKsItd3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsItd3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Commit3dChanges
 *
 *  Description:
 *      Commits 3D data to the device
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::Commit3dChanges"

HRESULT CKsItd3dObject::Commit3dChanges(void)
{
    KSDS3D_ITD_PARAMS_MSG     Params;
    HRESULT                   hr = DS_OK;

    DPF_ENTER();

    if(IsAtMaxDistance())
    {
        if(!m_fMute)
        {
            m_pBuffer->SetMute(TRUE);
        }
        m_fMute = TRUE;
    }
    else
    {
        if(m_fMute)
        {
            m_pBuffer->SetMute(FALSE);
            m_fMute = FALSE;
        }

        Params.Enabled = !(DS3DMODE_DISABLE == m_opCurrent.dwMode);
        Params.Reserved = 0;

        // Convert the OBJECT_ITD_CONTEXT structure to the KSDS3D_ITD3D_PARAMS
        // used by Kmixer.
        Params.LeftParams.Channel = 0;
        Params.RightParams.Channel = 1;

        CvtContext(&m_ofcLeft, &Params.LeftParams);
        CvtContext(&m_ofcRight, &Params.RightParams);

        // Apply the settings
        hr =
            KsSetNodeProperty
            (
                m_hPin,
                KSPROPSETID_Itd3d,
                KSPROPERTY_ITD3D_PARAMS,
                m_ulNodeId,
                &Params,
                sizeof(Params)
            );

        if(SUCCEEDED(hr) && m_fDopplerEnabled)
        {
            if(DS3DMODE_DISABLE == m_opCurrent.dwMode)
            {
                hr = m_pBuffer->SetFrequency(m_dwUserFrequency, FALSE);
            }
            else
            {
                hr = m_pBuffer->SetFrequency(m_dwDopplerFrequency, TRUE);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CvtContext
 *
 *  Description:
 *      Converts an OBJECT_ITD_CONTEXT to a KSDS3D_ITD3D_PARAMS.
 *
 *  Arguments:
 *      LPOBJECTFIRCONTEXT [in]: source.
 *      PITD_CONTEXT [out]: destination.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::CvtContext"

void CKsItd3dObject::CvtContext
(
    LPOBJECT_ITD_CONTEXT    pSource,
    PKSDS3D_ITD_PARAMS      pDest
)
{
    DPF_ENTER();

    pDest->VolSmoothScale = pSource->flVolSmoothScale;

    pDest->TotalDryAttenuation =
        pSource->flPositionAttenuation *
        pSource->flConeAttenuation *
        pSource->flConeShadow *
        pSource->flPositionShadow;

    pDest->TotalWetAttenuation =
        pSource->flPositionAttenuation *
        pSource->flConeAttenuation *
        (1.0f - pSource->flConeShadow * pSource->flPositionShadow);

    pDest->SmoothFrequency = pSource->dwSmoothFreq;
    pDest->Delay = pSource->dwDelay;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Get3dOutputSampleRate
 *
 *  Description:
 *      Gets the sample rate of the final output.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::Get3dOutputSampleRate"

DWORD CKsItd3dObject::Get3dOutputSampleRate(void)
{
    DWORD                   dwFrequency;

    DPF_ENTER();

    dwFrequency = m_pBuffer->m_vrbd.pwfxFormat->nSamplesPerSec;

    DPF_LEAVE(dwFrequency);

    return dwFrequency;
}


/***************************************************************************
 *
 *  CKsIir3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKs3dListener * [in]: listener pointer.
 *      CKsSecondaryRenderWaveBuffer * [in]: owning buffer object.
 *      DWORD [in]: buffer frequency.
 *      HANDLE [in]: pin handle.
 *      BOOL [in]: TRUE to mute at max distance.
 *      ULONG [in]: IIR 3D node id.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::CKsIir3dObject"

CKsIir3dObject::CKsIir3dObject
(
    CKs3dListener *                 pListener,
    REFGUID                         guidAlgorithm,
    BOOL                            fMuteAtMaxDistance,
    BOOL                            fDopplerEnabled,
    DWORD                           dwFrequency,
    CKsSecondaryRenderWaveBuffer *  pBuffer,
    HANDLE                          hPin,
    ULONG                           ulNodeId,
    ULONG                           ulNodeCpuResources
)
    : CIir3dObject(pListener, guidAlgorithm, fMuteAtMaxDistance, fDopplerEnabled, dwFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsIir3dObject);

    // Intialize defaults
    m_pBuffer = pBuffer;
    m_hPin = hPin;
    m_ulNodeId = ulNodeId;
    m_ulNodeCpuResources = ulNodeCpuResources;
    m_fMute = FALSE;
    m_flPrevAttenuation = FLT_MAX;
    m_flPrevAttDistance = FLT_MAX;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsIir3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::~CKsIir3dObject"

CKsIir3dObject::~CKsIir3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsIir3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::Initialize"

HRESULT
CKsIir3dObject::Initialize(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(IS_HARDWARE_NODE(m_ulNodeCpuResources))
    {
        hr =
            KsSetNodeProperty
            (
                m_hPin,
                KSPROPSETID_Audio,
                KSPROPERTY_AUDIO_3D_INTERFACE,
                m_ulNodeId,
                &m_guid3dAlgorithm,
                sizeof(m_guid3dAlgorithm)
            );
    }

    if(SUCCEEDED(hr))
    {
        hr = CIir3dObject::Initialize();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Commit3dChanges
 *
 *  Description:
 *      Commits 3D data to the device
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::Commit3dChanges"

HRESULT CKsIir3dObject::Commit3dChanges(void)
{
    PKSDS3D_HRTF_PARAMS_MSG pParams;
    HRESULT                 hr = DS_OK;
    UINT                    coeff;
    PULONG                  pNumCoeffs;
    ULONG                   StructSize;
    ULONG                   FilterSize;
    ULONG                   TotalSize;
    DWORD                   dwHalfNumCoeffs;

    DPF_ENTER();

    if(IsAtMaxDistance())
    {
        if(!m_fMute)
        {
            m_pBuffer->SetMute(TRUE);
        }
        m_fMute = TRUE;
    }
    else
    {
        if(m_fMute)
        {
            m_pBuffer->SetMute(FALSE);
            m_fMute = FALSE;
        }

        if( m_fUpdatedCoeffs
            || (m_flAttenuation != m_flPrevAttenuation)
            || (m_flAttDistance != m_flPrevAttDistance))
        {
            m_fUpdatedCoeffs = FALSE;
            m_flPrevAttenuation = m_flAttenuation;
            m_flPrevAttDistance = m_flAttDistance;

            StructSize = sizeof(KSDS3D_HRTF_PARAMS_MSG);

            FilterSize = 2*sizeof(ULONG) +
                   (m_ulNumSigmaCoeffs + m_ulNumDeltaCoeffs)*sizeof(FLOAT);

            TotalSize = StructSize + FilterSize;

            pParams = (PKSDS3D_HRTF_PARAMS_MSG)MEMALLOC_A(BYTE, TotalSize);

            hr = HRFROMP(pParams);
            if (SUCCEEDED(hr))
            {
            
    
                pParams->Size = StructSize;
                pParams->FilterSize = FilterSize;
                pParams->Enabled = !(DS3DMODE_DISABLE == m_opCurrent.dwMode);
                pParams->SwapChannels = m_fSwapChannels;
    
                if (m_pLut->GetZeroAzimuthTransition())
                {
                    pParams->CrossFadeOutput = TRUE;
                }
                else
                {
                    pParams->CrossFadeOutput = FALSE;
                }

                switch(m_pLut->GetCoeffFormat())
                {
                    case FLOAT_COEFF:
                    {
                        // Write Number of Sigma Coeffs
                        pNumCoeffs = (PULONG)(pParams + 1);
                        *pNumCoeffs = m_ulNumSigmaCoeffs;
    
                        // Write Sigma Coeffs
                        PFLOAT pCoeff = (PFLOAT)(pNumCoeffs + 1);
                        PFLOAT pSigmaCoeffs = (PFLOAT)m_pSigmaCoeffs;
        
                        ASSERT(m_ulNumSigmaCoeffs > 0);
                        ASSERT(m_ulNumSigmaCoeffs % 2);
    
                        dwHalfNumCoeffs = m_ulNumSigmaCoeffs / 2;
                        for(coeff=0; coeff<=dwHalfNumCoeffs; coeff++)
                        {
                            *pCoeff = m_flAttenuation * m_flAttDistance *(*pSigmaCoeffs);
                            pCoeff++;
                            pSigmaCoeffs++;
                        }
    
                        for(coeff=dwHalfNumCoeffs+1; coeff<m_ulNumSigmaCoeffs; coeff++)
                        {
                            *pCoeff = (*pSigmaCoeffs);
                            pCoeff++;
                            pSigmaCoeffs++;
                        }
    
                        // Write Number of Delta Coeffs
                        pNumCoeffs = (PULONG)(pCoeff);
                        *pNumCoeffs = m_ulNumDeltaCoeffs;
    
                        if(m_ulNumDeltaCoeffs > 0)
                        {
                            pParams->ZeroAzimuth = FALSE;
                        }
                        else
                        {
                            pParams->ZeroAzimuth = TRUE;
                        }
    
                        // Write Delta Coeffs
                        pCoeff = (PFLOAT)(pNumCoeffs + 1);
                        PFLOAT pDeltaCoeffs = (PFLOAT)m_pDeltaCoeffs;
    
                        if (m_ulNumDeltaCoeffs > 0)
                        {
                            ASSERT(m_ulNumDeltaCoeffs % 2);
                            dwHalfNumCoeffs = m_ulNumDeltaCoeffs / 2;
    
    
                            for(coeff=0; coeff<=dwHalfNumCoeffs; coeff++)
                            {
                               *pCoeff = m_flAttenuation * m_flAttDistance * (*pDeltaCoeffs);
                               pCoeff++;
                               pDeltaCoeffs++;
                            }
    
                            for(coeff=dwHalfNumCoeffs+1;coeff<m_ulNumDeltaCoeffs; coeff++)
                            {
                               *pCoeff = (*pDeltaCoeffs);
                               pCoeff++;
                           pDeltaCoeffs++;
                            }
                        }
    
                        break;
                    }

                    case SHORT_COEFF:
                    {
                        // Write Number of Sigma Coeffs
                        pNumCoeffs = (PULONG)(pParams + 1);
                        *pNumCoeffs = m_ulNumSigmaCoeffs;
    
                        // Write Sigma Coeffs
                        PSHORT pCoeff = (PSHORT)(pNumCoeffs + 1);
                        PSHORT pSigmaCoeffs = (PSHORT)m_pSigmaCoeffs;
    
                        for(coeff=0; coeff<m_ulNumSigmaCoeffs; coeff++)
                        {
                           *pCoeff = (*pSigmaCoeffs);
                           pCoeff++;
                           pSigmaCoeffs++;
                        }
    
                        // Write Sigma Gain
                        PSHORT pGain = (PSHORT)(pCoeff);
                        *pGain = (SHORT)(MAX_SHORT * m_flAttenuation * m_flAttDistance);
    
                        // Write Number of Delta Coeffs
                        pNumCoeffs = (PULONG)(pGain + 1);
                        *(UNALIGNED ULONG *)pNumCoeffs = m_ulNumDeltaCoeffs;
    
                        if(m_ulNumDeltaCoeffs > 0)
                        {
                            pParams->ZeroAzimuth = FALSE;
                        }
                        else
                        {
                            pParams->ZeroAzimuth = TRUE;
                        }

                        // Write Delta Coeffs
                        pCoeff = (PSHORT)(pNumCoeffs + 1);
                        PSHORT pDeltaCoeffs = (PSHORT)m_pDeltaCoeffs;
    
                        for(coeff=0; coeff<m_ulNumDeltaCoeffs; coeff++)
                        {
                           *pCoeff = (*pDeltaCoeffs);
                           pCoeff++;
                           pDeltaCoeffs++;
                        }   

                        // Write Delta Gain
                        pGain = (PSHORT)(pCoeff);
                        *pGain = (SHORT)(MAX_SHORT * m_flAttenuation * m_flAttDistance);
    
                        break;
                    }
    
                    default:
                    break;

                }

                // Apply the settings
                hr =
                    KsSetNodeProperty
                    (
                        m_hPin,
                        KSPROPSETID_Hrtf3d,
                        KSPROPERTY_HRTF3D_PARAMS,
                        m_ulNodeId,
                        pParams,
                        TotalSize
                    );


                MEMFREE(pParams);

            }
        }

        if(SUCCEEDED(hr) && m_fDopplerEnabled)
        {
            if(DS3DMODE_DISABLE == m_opCurrent.dwMode)
            {
                hr = m_pBuffer->SetFrequency(m_dwUserFrequency, FALSE);
            }
            else
            {
                hr = m_pBuffer->SetFrequency(m_dwDopplerFrequency, TRUE);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetFilterMethodAndCoeffFormat
 *
 *  Description:
 *      Gets the required filter coefficient format from either
 *      the device or kmixer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::GetFilterMethodAndCoeffFormat"

HRESULT CKsIir3dObject::GetFilterMethodAndCoeffFormat
(
    KSDS3D_HRTF_FILTER_METHOD *     pFilterMethod,
    KSDS3D_HRTF_COEFF_FORMAT *      pCoeffFormat
)
{

    KSDS3D_HRTF_FILTER_FORMAT_MSG   FilterFormat;
    HRESULT                         hr;

    DPF_ENTER();

    hr =
        KsGetNodeProperty
        (
            m_hPin,
            KSPROPSETID_Hrtf3d,
            KSPROPERTY_HRTF3D_FILTER_FORMAT,
            m_ulNodeId,
            &FilterFormat,
            sizeof(KSDS3D_HRTF_FILTER_FORMAT_MSG)
        );

    if(SUCCEEDED(hr))
    {
        *pFilterMethod = FilterFormat.FilterMethod;
        *pCoeffFormat = FilterFormat.CoeffFormat;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  InitializeFilters
 *
 *  Description:
 *      Sets the maximum IIR filter size.  If the filter is Direct Form,
 *      the max size is the order of the filter ( numerator and denominator
 *      have equal order).  If the filter is Cascade Form, the max size
 *      is the maximum number of biquads.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::InitializeFilters"

HRESULT CKsIir3dObject::InitializeFilters
(
    KSDS3D_HRTF_FILTER_QUALITY  Quality,
    FLOAT                       flSampleRate,
    ULONG                       ulMaxFilterSize,
    ULONG                       ulFilterTransientMuteLength,
    ULONG                       ulFilterOverlapBufferLength,
    ULONG                       ulOutputOverlapBufferLength
)
{
    KSDS3D_HRTF_INIT_MSG Msg;
    HRESULT hr;

    DPF_ENTER();

    // Apply the settings
    Msg.Quality = Quality;
    Msg.SampleRate = flSampleRate;
    Msg.MaxFilterSize = ulMaxFilterSize;
    Msg.FilterTransientMuteLength = ulFilterTransientMuteLength;
    Msg.FilterOverlapBufferLength = ulFilterOverlapBufferLength;
    Msg.OutputOverlapBufferLength = ulOutputOverlapBufferLength;
    Msg.Reserved = 0;

    hr =
        KsSetNodeProperty
        (
            m_hPin,
            KSPROPSETID_Hrtf3d,
            KSPROPERTY_HRTF3D_INITIALIZE,
            m_ulNodeId,
            &Msg,
            sizeof(KSDS3D_HRTF_INIT_MSG)
        );

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CKsHw3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKs3dListener * [in]: pointer to the owning listener.
 *      HANDLE [in]: pin handle.
 *      LPVOID [in]: instance identifier.
 *      ULONG [in]: device-specific 3D node id.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::CKsHw3dObject"

CKsHw3dObject::CKsHw3dObject
(
    CKs3dListener *         p3dListener,
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled,
    LPVOID                  pvInstance,
    ULONG                   ulNodeId,
    CKsSecondaryRenderWaveBuffer * pBuffer
)
    : CHw3dObject(p3dListener, fMuteAtMaxDistance, fDopplerEnabled)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsHw3dObject);

    m_pKsListener = p3dListener;
    m_pvInstance = pvInstance;
    m_ulNodeId = ulNodeId;
    m_pBuffer = pBuffer;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsHw3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::~CKsHw3dObject"

CKsHw3dObject::~CKsHw3dObject
(
    void
)
{
    BOOL                    fAlloc  = FALSE;
    HRESULT                 hr;

    DPF_ENTER();
    DPF_DESTRUCT(CKsHw3dObject);

    m_pKsListener->m_lstHw3dObjects.RemoveDataFromList(this);

    // If we're the last HW object to leave, we need to tell the
    // driver to free its listener data.
    if(m_pKsListener->m_fAllocated && !m_pKsListener->m_lstHw3dObjects.GetNodeCount())
    {
        hr =
            SetProperty
            (
                KSPROPSETID_DirectSound3DListener,
                KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION,
                &fAlloc,
                sizeof(fAlloc)
            );

        if(SUCCEEDED(hr))
        {
            m_pKsListener->m_fAllocated = FALSE;
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::Initialize"

HRESULT
CKsHw3dObject::Initialize
(
    void
)
{
    BOOL                    fAlloc  = TRUE;
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    // If we're the first object being added to the listener's world,
    // we need to tell the driver to allocate the listener.
    if(!m_pKsListener->m_fAllocated)
    {
        hr =
            SetProperty
            (
                KSPROPSETID_DirectSound3DListener,
                KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION,
                &fAlloc,
                sizeof(fAlloc)
            );

        if(SUCCEEDED(hr))
        {
            m_pKsListener->m_fAllocated = TRUE;
        }
    }

    // Join the listener's world
    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pKsListener->m_lstHw3dObjects.AddNodeToList(this));
    }

    // Initialize the base class
    if(SUCCEEDED(hr))
    {
        hr = C3dObject::Initialize();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Recalc
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed listener settings.
 *      DWORD [in]: changed object settings.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::Recalc"

HRESULT
CKsHw3dObject::Recalc
(
    DWORD                       dwListener,
    DWORD                       dwObject
)
{
    CNode<CKsHw3dObject *> *    pNode   = m_pKsListener->m_lstHw3dObjects.GetListHead();
    HRESULT                     hr      = DS_OK;

    DPF_ENTER();

    // Are we the 3D object that's responsible for setting listener parameters
    // and speaker config?  The first HW 3D object in the list is in charge of
    // that.
    if(dwListener && this == pNode->m_data)
    {
        hr = RecalcListener(dwListener);
    }

    if(SUCCEEDED(hr) && dwObject)
    {
        hr = RecalcObject(dwObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RecalcListener
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed listener settings.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::RecalcListener"

HRESULT
CKsHw3dObject::RecalcListener
(
    DWORD                   dwListener
)
{
    HRESULT                 hr                          = DS_OK;
    DS3DLISTENER            ds3dl;
    KSDS3D_LISTENER_ALL     Ks3dListener;

    DPF_ENTER();

    if(dwListener & DS3DPARAM_LISTENER_PARAMMASK)
    {
        InitStruct(&ds3dl, sizeof(ds3dl));

        hr = m_pListener->GetAllParameters(&ds3dl);

        if(SUCCEEDED(hr))
        {
            COPY_VECTOR(Ks3dListener.Position, ds3dl.vPosition);
            COPY_VECTOR(Ks3dListener.Velocity, ds3dl.vVelocity);
            COPY_VECTOR(Ks3dListener.OrientFront, ds3dl.vOrientFront);
            COPY_VECTOR(Ks3dListener.OrientTop, ds3dl.vOrientTop);

            Ks3dListener.DistanceFactor = ds3dl.flDistanceFactor;
            Ks3dListener.RolloffFactor = ds3dl.flRolloffFactor;
            Ks3dListener.DopplerFactor = ds3dl.flDopplerFactor;
        }

        if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_PARAMMASK) == DS3DPARAM_LISTENER_PARAMMASK)
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DListener,
                    KSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
                    &Ks3dListener,
                    sizeof(Ks3dListener)
                );
        }
        else
        {
            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_DISTANCEFACTOR))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
                        &Ks3dListener.DistanceFactor,
                        sizeof(Ks3dListener.DistanceFactor)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_DOPPLERFACTOR))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
                        &Ks3dListener.DopplerFactor,
                        sizeof(Ks3dListener.DopplerFactor)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_ROLLOFFFACTOR))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
                        &Ks3dListener.RolloffFactor,
                        sizeof(Ks3dListener.RolloffFactor)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_ORIENTATION))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
                        &Ks3dListener.OrientFront,
                        sizeof(Ks3dListener.OrientFront) + sizeof(Ks3dListener.OrientTop)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_POSITION))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
                        &Ks3dListener.Position,
                        sizeof(Ks3dListener.Position)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_VELOCITY))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
                        &Ks3dListener.Velocity,
                        sizeof(Ks3dListener.Velocity)
                    );
            }
        }
    }

    // Now we send the CHANNEL_CONFIG and SPEAKER_GEOMETRY properties to our
    // pin's 3D node.  This is the old, traditional, barely-specified way of
    // informing the driver of speaker config changes.  There is now a new,
    // well-defined way to do this (namely, sending these two properties to
    // the DAC node on the filter before any pins are instantiated), but the
    // code below lives on for the benefit of "legacy" WDM drivers.

    if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_SPEAKERCONFIG))
    {
        DWORD dwSpeakerConfig;
        hr = m_pListener->GetSpeakerConfig(&dwSpeakerConfig);

        if(SUCCEEDED(hr))
        {
            LONG KsSpeakerConfig;
            LONG KsStereoSpeakerGeometry;

            hr = DsSpeakerConfigToKsProperties(dwSpeakerConfig, &KsSpeakerConfig, &KsStereoSpeakerGeometry);

            if(SUCCEEDED(hr))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_Audio,
                        KSPROPERTY_AUDIO_CHANNEL_CONFIG,
                        &KsSpeakerConfig,
                        sizeof KsSpeakerConfig
                    );
            }

            if(SUCCEEDED(hr) && KsSpeakerConfig == KSAUDIO_SPEAKER_STEREO)
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_Audio,
                        KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
                        &KsStereoSpeakerGeometry,
                        sizeof KsStereoSpeakerGeometry
                    );
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RecalcObject
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed object settings.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::RecalcObject"

HRESULT
CKsHw3dObject::RecalcObject
(
    DWORD                   dwObject
)
{
    HRESULT                 hr          = DS_OK;
    KSDS3D_BUFFER_ALL       Ks3dBuffer;

    DPF_ENTER();

    COPY_VECTOR(Ks3dBuffer.Position, m_opCurrent.vPosition);
    COPY_VECTOR(Ks3dBuffer.Velocity, m_opCurrent.vVelocity);

    Ks3dBuffer.InsideConeAngle = m_opCurrent.dwInsideConeAngle;
    Ks3dBuffer.OutsideConeAngle = m_opCurrent.dwOutsideConeAngle;

    COPY_VECTOR(Ks3dBuffer.ConeOrientation, m_opCurrent.vConeOrientation);

    Ks3dBuffer.ConeOutsideVolume = m_opCurrent.lConeOutsideVolume;
    Ks3dBuffer.MinDistance = m_opCurrent.flMinDistance;
    Ks3dBuffer.MaxDistance = m_opCurrent.flMaxDistance;

    Ks3dBuffer.Mode = Ds3dModeToKs3dMode(m_opCurrent.dwMode);

    if((dwObject & DS3DPARAM_OBJECT_PARAMMASK) == DS3DPARAM_OBJECT_PARAMMASK)
    {
        hr =
            SetProperty
            (
                KSPROPSETID_DirectSound3DBuffer,
                KSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
                &Ks3dBuffer,
                sizeof(Ks3dBuffer)
            );
    }
    else
    {
        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_CONEANGLES))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
                    &Ks3dBuffer.InsideConeAngle,
                    sizeof(Ks3dBuffer.InsideConeAngle) + sizeof(Ks3dBuffer.OutsideConeAngle)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_CONEORIENTATION))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
                    &Ks3dBuffer.ConeOrientation,
                    sizeof(Ks3dBuffer.ConeOrientation)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
                    &Ks3dBuffer.ConeOutsideVolume,
                    sizeof(Ks3dBuffer.ConeOutsideVolume)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_MAXDISTANCE))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
                    &Ks3dBuffer.MaxDistance,
                    sizeof(Ks3dBuffer.MaxDistance)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_MINDISTANCE))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
                    &Ks3dBuffer.MinDistance,
                    sizeof(Ks3dBuffer.MinDistance)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_MODE))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_MODE,
                    &Ks3dBuffer.Mode,
                    sizeof(Ks3dBuffer.Mode)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_POSITION))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
                    &Ks3dBuffer.Position,
                    sizeof(Ks3dBuffer.Position)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_VELOCITY))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
                    &Ks3dBuffer.Velocity,
                    sizeof(Ks3dBuffer.Velocity)
                );
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets a property on the object's 3D node.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::SetProperty"

HRESULT
CKsHw3dObject::SetProperty
(
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPCVOID                 pvData,
    ULONG                   cbData
)
{
    HRESULT                 hr  = DSERR_GENERIC;

    DPF_ENTER();

    if (m_pBuffer->m_pPin)
    {
        hr =
            KsSet3dNodeProperty
            (
                m_pBuffer->m_pPin->m_hPin,
                guidPropertySet,
                ulPropertyId,
                m_ulNodeId,
                m_pvInstance,
                (LPVOID)pvData,
                cbData
            );
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\grsub.cpp ===
//--------------------------------------------------------------------------;
//
//  File: grsub.cpp
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/25/96    FrankYe     Created
//      02/02/97    DerekS      Added support for constant dest size
//      08/30/00    DuganP      Many fixes - better MMSYSERR handling
//
//--------------------------------------------------------------------------;

#include "dsoundi.h"
#include "grace.h"

#ifndef NOVXD

// Internal Kernel32 API
extern "C" DWORD WINAPI OpenVxDHandle(HANDLE hSource);

const char CNaGrace::strFormatMixEventRemix[] = "%08XDirectSound_MixEvent_Remix";
const char CNaGrace::strFormatMixEventTerminate[] = "%08XDirectSound_MixEvent_Terminate";
const int CNaGrace::MIXER_MINPREMIX = 45;
const int CNaGrace::MIXER_MAXPREMIX = 200;

#endif // NOVXD

#define TIMEOUT_PERIOD 5000


//---------------------------------------------------------------------------
//
// WaveAllocAndPrepareLoopingBuffers
//
// Allocate the array of wavehdr's to point at the primary buffer.
// Prepare them and start them looping.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "WaveAllocAndPrepareLoopingBuffers"

MMRESULT WaveAllocAndPrepareLoopingBuffers(HWAVEOUT hwo, LPWAVEFORMATEX pwfx,
                                           int cHeaders, int cHeadersToQueue,
                                           WAVEHDR **ppwh, int cbBuffer,
                                           PVOID *ppLoopingBuffer)
{
    int iawh;
    MMRESULT mmr;
    PBYTE pLoopingBuffer;
    PWAVEHDR pwh;

    enum WAVEHDR_STATUS {Allocated, Prepared, Successful};
    WAVEHDR_STATUS* pStatus;  // Used to track the state of the headers

    DPF_ENTER();

    pLoopingBuffer = MEMALLOC_A(BYTE, cHeaders * cbBuffer);
    if (!pLoopingBuffer)
    {
        DPF(DPFLVL_ERROR, "No memory for looping buffer!");
        return MMSYSERR_NOMEM;
    }

    pwh = MEMALLOC_A(WAVEHDR, cHeaders);
    if (!pwh)
    {
        DPF(DPFLVL_ERROR, "No memory for wave headers");
        MEMFREE(pLoopingBuffer);
        return MMSYSERR_NOMEM;
    }

    pStatus = MEMALLOC_A(WAVEHDR_STATUS, cHeaders);
    if (!pStatus)
    {
        DPF(DPFLVL_ERROR, "No memory for wave header status");
        MEMFREE(pLoopingBuffer);
        MEMFREE(pwh);
        return MMSYSERR_NOMEM;
    }

    // Initialize to 8 or 16-bit silence
    FillMemory(pLoopingBuffer, cHeaders * cbBuffer, (8 == pwfx->wBitsPerSample) ? 0x80 : 0x00);

    // Initialize the STATUS to all allocated
    for (iawh = 0; iawh < cHeaders; ++iawh)
    {
        pStatus[iawh] = Allocated;
    }

    // Build buffers and headers
    for (iawh = 0; iawh < cHeaders; ++iawh)
    {
        (pwh + iawh)->lpData = (char*)(pLoopingBuffer + (iawh * (cbBuffer)));
        (pwh + iawh)->dwBufferLength = cbBuffer;
        (pwh + iawh)->dwUser = iawh;
        (pwh + iawh)->dwFlags = 0;
    }

    DPF(DPFLVL_MOREINFO, "Note: first waveOutPrepareHeader and waveOutWrite");
    mmr = waveOutPrepareHeader(hwo, pwh, sizeof(WAVEHDR));

    ASSERT(MMSYSERR_NOERROR == mmr);
    if (MMSYSERR_NOERROR == mmr)
        pStatus[0] = Prepared;

    mmr = waveOutWrite(hwo, pwh, sizeof(WAVEHDR));

    // Note: on Whistler we've seen this call return MMSYSERR_INVALPARAM
    // (possibly due to low-mem conditions - see Manbug 44299).  So we'll
    // allow this error code in the ASSERT below for all WINNT builds.
    #ifdef WINNT
    ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr || MMSYSERR_INVALPARAM == mmr);
    #else
    ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
    #endif

    if (MMSYSERR_NOERROR == mmr)
    {
        pStatus[0] = Successful;
        mmr = waveOutPause(hwo);
        ASSERT(MMSYSERR_NOERROR == mmr);

        // Prepare the rest
        for (iawh = 1; iawh < cHeaders; ++iawh)
        {
            mmr = waveOutPrepareHeader(hwo, pwh + iawh, sizeof(WAVEHDR));
            ASSERT(MMSYSERR_NOERROR == mmr);
            if (MMSYSERR_NOERROR != mmr)
                break;
            pStatus[iawh] = Prepared;
        }

        if (MMSYSERR_NOERROR == mmr)
        {
            // Write the rest that we want queued to the wave device
            for (iawh = 1; iawh < cHeadersToQueue; ++iawh)
            {
                mmr = waveOutWrite(hwo, pwh + iawh, sizeof(WAVEHDR));
                ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
                if (MMSYSERR_NOERROR != mmr)
                    break;
                pStatus[iawh] = Successful;
            }
        }

        if (MMSYSERR_NOERROR == mmr)
        {
            // Start the device
            DPF(DPFLVL_MOREINFO, "Calling waveOutRestart()");
            mmr = waveOutRestart(hwo);
            ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
        }
    }

    if (MMSYSERR_NOERROR == mmr)
    {
        *ppLoopingBuffer = pLoopingBuffer;
        *ppwh = pwh;
    }
    else // Failure
    {
        // We're heading out of here - error condition. Let's call
        // waveOutReset() to get our headers back.
        if (waveOutReset(hwo) != MMSYSERR_NOERROR)
            ASSERT(!"waveOutReset() failed");
        
        // Cleanup: We have to unprepare the headers, but we may have to wait
        // until the "done" bit is set.  If the done bit gets set or 5 seconds
        // elapse, we go ahead and release the header if it was prepared.
        for (iawh = 0; iawh < cHeaders; ++iawh)
            if (pStatus[iawh] == Prepared)
                waveOutUnprepareHeader(hwo, pwh + iawh, sizeof(WAVEHDR));
        
        MEMFREE(pLoopingBuffer);
        MEMFREE(pwh);
    }

    // Free our header status array
    MEMFREE(pStatus);
    
    DPF_LEAVE(mmr);
    return mmr;
}

//---------------------------------------------------------------------------
//
// WaveUnprepareLoopingBuffers
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "WaveUnprepareLoopingBuffers"

MMRESULT WaveUnprepareLoopingBuffers(HWAVEOUT hwo, PWAVEHDR pwh, int cHeaders)
{
    for (int i=0; i<cHeaders; i++)
    {
        MMRESULT mmr = waveOutUnprepareHeader(hwo, pwh + i, sizeof(WAVEHDR));
        ASSERT(MMSYSERR_NOERROR == mmr);
    }
    return MMSYSERR_NOERROR;
}

//---------------------------------------------------------------------------
//
// WaveDetermineDMASize
//
// Determine DMA buffer size on the given emulated direct sound device and
// munge it to figure out the desired size for the emulator to allocate
// per wave header.
// 
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "WaveDetermineDMASize"

MMRESULT WaveDetermineDMASize(HWAVEOUT hwo, LPWAVEFORMATEX pwfx, int* pcbBigBuffer, int* pcDmaBuffers, int* pcbDmaBuffer)
{
    DWORD    dwTotalTime    = 0;
    UINT     mmResult       = MMSYSERR_NOERROR;

    DPF_ENTER();

    // If we're on a WinNT-based OS, we're either on WDM or NT4 drivers.
    // On WDM drivers, we can't discover the DMA size using the code below,
    // so we can skip it.  But what about NT4 drivers?
    
// #ifndef WINNT (Commented out until I get some info about NT4 drivers)

    // We'll send a packet of 4 bytes (that's at least 1 sample in every format)
    DWORD dwWaveData = (pwfx->wBitsPerSample == 16) ? 0x00000000 : 0x80808080;

    // Prepare wave header
    WAVEHDR whdr;
    whdr.lpData = (char*)&dwWaveData;
    whdr.dwBufferLength = sizeof(dwWaveData);
    whdr.dwFlags = 0;
    whdr.dwLoops = 0;
    whdr.dwUser =  0;
    mmResult = waveOutPrepareHeader(hwo, &whdr, sizeof(whdr));

    ASSERT(!mmResult);
    if (mmResult) return mmResult;

    DWORD dwBeginTime = timeGetTime();
    
    // Play our buffer
    mmResult = waveOutWrite(hwo, &whdr, sizeof(whdr));

    // Note: on Whistler we've seen this call return MMSYSERR_INVALPARAM
    // (possibly due to low-mem conditions - see Manbug 44299).  So we'll
    // allow this error code in the ASSERT below for all WINNT builds.
    #ifdef WINNT
    ASSERT(MMSYSERR_NOERROR == mmResult || MMSYSERR_NOMEM == mmResult || MMSYSERR_INVALPARAM == mmResult);
    #else
    ASSERT(MMSYSERR_NOERROR == mmResult || MMSYSERR_NOMEM == mmResult);
    #endif

    if (MMSYSERR_NOERROR != mmResult)
    {
        DPF(DPFLVL_WARNING, "waveOutWrite() failed with %lu", mmResult);
    }
    else
    {
        // Spin until the done bit is set, or 5 seconds
        while (!(whdr.dwFlags & WHDR_DONE))
        {
            if (dwTotalTime >= TIMEOUT_PERIOD)
            {
                DPF(DPFLVL_ERROR, "TIMEOUT getting DMA buffer size");
                mmResult = MMSYSERR_ERROR;
                break;
            }

            // This thread is THREAD_PRIORITY_TIME_CRITICAL so it would be
            // very dangerous to busy wait without explicitly giving up the
            // CPU for a while.
            Sleep(10);
            dwTotalTime = timeGetTime() - dwBeginTime;
        }
    }

    if (waveOutReset(hwo) != MMSYSERR_NOERROR)
        ASSERT(!"waveOutReset() failed");

    if (waveOutUnprepareHeader(hwo, &whdr, sizeof whdr) != MMSYSERR_NOERROR)
        ASSERT(!"waveOutUnprepareHeader() failed");

    DPF(DPFLVL_INFO, "Calculated dwTotalTime = %lu", dwTotalTime);

// #endif // WINNT

    if (MMSYSERR_NOERROR == mmResult)
    {
        // If it's smaller than 62ms, it probably isn't a DMA based card.
        dwTotalTime = max(dwTotalTime, 62);

        *pcbDmaBuffer = dwTotalTime * pwfx->nSamplesPerSec;
        *pcbDmaBuffer *= pwfx->nBlockAlign;
        *pcbDmaBuffer /= 1000;

        // Add in 10% for slop, and to account for drivers that deal with DMA wrapping
        *pcbDmaBuffer += (*pcbDmaBuffer * 10) / 100;

        // We have to recalculate the DMA buffer size based on the constant
        // size of the primary buffer.  Mathematically, this is a solvable
        // equation, but in the real world, it just doesn't fly.  We end
        // up with a situation where the total size of the buffer must be
        // evenly divisible by both the DMA buffer size and the count of
        // wave headers.  The easist way to fix this was to just create
        // a lookup table and find the closest match.

        // REMIND: we have to recalculate these numbers if MIXER_REWINDGRANULARITY
        // ever changes from 128 (the nSize values have to be multiples of it).

        *pcbBigBuffer = 81920;

        static const struct 
        {
            int nSize;
            int nCount;
        } aDmaTable[] = { { 1280, 64}, { 2560, 32 }, { 4096, 20 }, { 5120, 16 }, { 8192, 10 }, { 10240, 8 }, { 16384, 5 } };

        static const int cDmaTable = sizeof(aDmaTable) / sizeof(aDmaTable[0]);
        int i;

        if (*pcbDmaBuffer <= aDmaTable[0].nSize)
        {
            i = 0;
        }
        else if(*pcbDmaBuffer >= aDmaTable[cDmaTable - 1].nSize)
        {
            DPF(DPFLVL_INFO, "Processing took longer than expected");
            i = cDmaTable - 1;
        }
        else
        {
            for(i = 1; i < cDmaTable; i++)
            {
                if(*pcbDmaBuffer > aDmaTable[i-1].nSize && *pcbDmaBuffer <= aDmaTable[i].nSize)
                {
                    break;
                }
            }
        }

        *pcbDmaBuffer = aDmaTable[i].nSize;
        *pcDmaBuffers = aDmaTable[i].nCount;
    }

    DPF_LEAVE(mmResult);
    return mmResult;
}


//---------------------------------------------------------------------------
//
// CWeGrace implementation
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "CWeGrace::Refresh"

void CWeGrace::Refresh(int cPremixMax)
{
    LONG dtimeNextNotify;
    int cPremixed;
    BOOL fRemix;

    ENTER_MIXER_MUTEX();
    
    if (MIXERSTATE_STOPPED != m_kMixerState)
    {
        fRemix = DSMIXERSIGNAL_REMIX & m_fdwMixerSignal;
        CGrace::Refresh(fRemix, cPremixMax, &cPremixed, &dtimeNextNotify);
    }

    LEAVE_MIXER_MUTEX();
}


#ifndef NOVXD

#undef DPF_FNAME
#define DPF_FNAME "NaGrace_ThreadStartRoutine"

DWORD WINAPI NaGrace_ThreadStartRoutine(PVOID pNaGrace)
{
    ((CNaGrace *)pNaGrace)->MixThread();
    return 0;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::SignalRemix"

void CNaGrace::SignalRemix()
{
    if (!(DSMIXERSIGNAL_REMIX & m_fdwMixerSignal))
    {
        m_fdwMixerSignal |= DSMIXERSIGNAL_REMIX;
        VxdEventScheduleWin32Event(m_vxdhMixEventRemix, 0);
    }
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::MixThread"

void CNaGrace::MixThread()
{
    HANDLE  hEventTerminate;
    HANDLE  hEventRemix;
    TCHAR   ach[256];
    DWORD   dwResult;
    BOOL    fResult;

    LONG    dtime;
    LONG    dtimeSleep;
    LONG    dtimePremix;
    LONG    ddtimePremix;
    LONG    dtimeInvalid;
    LONG    dtimeNextNotify;

    int     cSamplesPremixMax;
    int     cSamplesPremixed;

    DPF(DPFLVL_INFO, "Grace is in the building");

    // We mangle the event names by prepending the address of the DS
    // object for which this thread is running.  This allows unique
    // event names for each DS object.

    wsprintf(ach, strFormatMixEventTerminate, this);
    hEventTerminate = CreateEvent(NULL, FALSE, FALSE, ach);
    DPF(DPFLVL_INFO, "Terminate event name '%s'", ach);

    wsprintf(ach, strFormatMixEventRemix, this);
    hEventRemix = CreateEvent(NULL, FALSE, FALSE, ach);
    DPF(DPFLVL_INFO, "Remix event name '%s'", ach);

    // Here we do a simple handshake with the creator of this thread.  We
    // signal the IAH_TERMINATE event.  When our creator sees it, it will
    // signal the IAH_REMIX event.

    fResult = SetEvent(hEventTerminate);
    ASSERT(fResult);
    dwResult = WaitObject(INFINITE, hEventRemix);
    ASSERT(WAIT_OBJECT_0 == dwResult);

    dtimeSleep = MIXER_MAXPREMIX / 2;

    while (TRUE)
    {
        HANDLE ah[] = {hEventTerminate, hEventRemix};

        ASSERT(dtimeSleep <= MIXER_MAXPREMIX/2);

        dwResult = WaitObjectArray(2, INFINITE, FALSE, ah);
        if (WAIT_OBJECT_0 == dwResult) break;

        dwResult = ENTER_MIXER_MUTEX_OR_EVENT(hEventTerminate);
        if (WAIT_OBJECT_0 == dwResult) break;

        // Three cases:
        //   1) mixer is stopped
        //   2) mixer running and a remix is pending
        //   3) mixer running and no remix is pending

        if (MIXERSTATE_STOPPED == m_kMixerState)
        {
            dtimeSleep = INFINITE;
        }
        else
        {
            dtime = timeGetTime();

            if (m_fdwMixerSignal & DSMIXERSIGNAL_REMIX)
            {
                ResetEvent(hEventRemix);

                dtimePremix = MIXER_MINPREMIX;  // Initial premix length
                ddtimePremix = 2;               // increment

                cSamplesPremixMax = MulDivRD(dtimePremix, m_pDest->m_nFrequency, 1000);
                Refresh(TRUE, cSamplesPremixMax, &cSamplesPremixed, &dtimeNextNotify);
            }
            else
            {
                dtimePremix += ddtimePremix;
                if (dtimePremix > MIXER_MAXPREMIX)
                    dtimePremix = MIXER_MAXPREMIX;
                else
                    ddtimePremix += 2;

                cSamplesPremixMax = MulDivRD(dtimePremix, m_pDest->m_nFrequency, 1000);
                Refresh(FALSE, cSamplesPremixMax, &cSamplesPremixed, &dtimeNextNotify);
            }

            dtimeInvalid = MulDivRD(cSamplesPremixed, 1000, m_pDest->m_nFrequency);
            dtime = timeGetTime() - dtime;
            dtimeInvalid -= 2 * dtime;

            dtimeSleep = min(dtimeInvalid/2, dtimeNextNotify);
            dtimeSleep = max(dtimeSleep, MIXER_MINPREMIX/2);
        }

        LEAVE_MIXER_MUTEX();
    }

    CloseHandle(hEventRemix);
    CloseHandle(hEventTerminate);

    DPF(DPFLVL_INFO, "Grace is outta here");
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::Initialize"

HRESULT CNaGrace::Initialize(CGrDest *pDest)
{
    HANDLE  hMixEventTerminate;
    HANDLE  hMixEventRemix;
    TCHAR   ach[256];
    DWORD   dwResult;
    BOOL    fResult;
    HRESULT hr;

    hr = CGrace::Initialize(pDest);

    if (SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Creating mixer thread");

        ASSERT(NULL == m_hMixThread);
        ASSERT(NULL == m_vxdhMixEventTerminate);
        ASSERT(NULL == m_vxdhMixEventRemix);

        // We mangle the event names by prepending the address of the Grace
        // object for which this thread is running.  This allows unique
        // event names for each DS object.

        wsprintf(ach, strFormatMixEventTerminate, this);
        hMixEventTerminate = CreateEvent(NULL, FALSE, FALSE, ach);
        hr = HRFROMP(hMixEventTerminate);
    }

    if (SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Terminate event name '%s'", ach);

        wsprintf(ach, strFormatMixEventRemix, this);
        hMixEventRemix = CreateEvent(NULL, FALSE, FALSE, ach);
        hr = HRFROMP(hMixEventRemix);
    }
    
    if (SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Remix event name '%s'", ach);

        m_vxdhMixEventTerminate = OpenVxDHandle(hMixEventTerminate);
        ASSERT(m_vxdhMixEventTerminate != 0);

        m_vxdhMixEventRemix = OpenVxDHandle(hMixEventRemix);
        ASSERT(m_vxdhMixEventRemix != 0);

#ifdef SHARED
        m_hMixThread = HelperCreateDSMixerThread(NaGrace_ThreadStartRoutine, this, 0, NULL);
#else
        DWORD dwTid;
        m_hMixThread = CreateThread(NULL, 0, NaGrace_ThreadStartRoutine, this, 0, &dwTid);
#endif

        hr = HRFROMP(m_hMixThread);
        if (FAILED(hr))
            DPF(DPFLVL_MOREINFO, "Unable to create mixer thread");
        else
        {
            DPF(DPFLVL_MOREINFO, "Mixer thread created: 0x%p", m_hMixThread);

            dwResult = WaitObject(INFINITE, hMixEventTerminate);
            ASSERT(dwResult == WAIT_OBJECT_0);
            fResult = SetEvent(hMixEventRemix);
            ASSERT(fResult);

            fResult = CloseHandle(hMixEventTerminate);
            ASSERT(fResult);
            fResult = CloseHandle(hMixEventRemix);
            ASSERT(fResult);
        }
    }

    return hr;
}

//--------------------------------------------------------------------------;
//
// mxTerminate
//
// This function is called to terminate the grace mixer thread for the
// specified DS object.  It returns the handle to the thread that is being
// terminated.  After releasing any critical sections that the grace mixer
// thread may be waiting on, the caller should wait for the thread handle
// to become signaled.  For Win32 beginners: the thread handle is signalled
// after the thread terminates.
//
//--------------------------------------------------------------------------;

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::Terminate"

void CNaGrace::Terminate()
{
    VxdEventScheduleWin32Event(m_vxdhMixEventTerminate, 0);

    VxdEventCloseVxdHandle(m_vxdhMixEventTerminate);
    VxdEventCloseVxdHandle(m_vxdhMixEventRemix);

    // Wait for mixer thread to die

    if (m_hMixThread)
    {
        DWORD dwResult;
        HANDLE hHelper;
        HANDLE hMixThreadOurs;

        DPF(DPFLVL_MOREINFO, "Note: waiting for mixer thread to terminate");
        hHelper = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwHelperPid);
        if (hHelper)
        {
            if (DuplicateHandle(hHelper, m_hMixThread, GetCurrentProcess(),
                                &hMixThreadOurs, SYNCHRONIZE | THREAD_TERMINATE,
                                FALSE, DUPLICATE_CLOSE_SOURCE))
            {
                dwResult = WaitObject(INFINITE, hMixThreadOurs);
                ASSERT(WAIT_OBJECT_0 == dwResult);
                dwResult = CloseHandle(hMixThreadOurs);
                ASSERT(dwResult);
            }
            dwResult = CloseHandle(hHelper);
            ASSERT(dwResult);
        }
    }

    m_hMixThread = NULL;
    m_vxdhMixEventTerminate = NULL;
    m_vxdhMixEventRemix = NULL;

    CGrace::Terminate();
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::GetMaxRemix"

int CNaGrace::GetMaxRemix()
{
    // Return max number of samples we might remix
    return (MulDivRU(MIXER_MAXPREMIX, m_pDest->m_nFrequency, 1000));
}

#endif // NOVXD

#undef DPF_FNAME
#define DPF_FNAME "WeGrDest_New"

PVOID WeGrDest_New(UINT uDeviceId)
{
    return NEW(CWeGrDest(uDeviceId));
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::CWeGrDest"

CWeGrDest::CWeGrDest(UINT uWaveDeviceId)
{
    m_uDeviceId = uWaveDeviceId;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::Initialize"

HRESULT CWeGrDest::Initialize(void)
{
    MMRESULT mmr;
    ASSERT(!m_pBuffer);

    mmr = InitializeEmulator();
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(DPFLVL_MOREINFO, "InitializeEmulator() returned %lu", mmr);
        return MMRESULTtoHRESULT(mmr);
    }

    m_cSamples = m_cbBuffer >> m_nBlockAlignShift;

    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::Terminate"

void CWeGrDest::Terminate(void)
{
    if (m_hWaveThread)
        ShutdownEmulator();

    MEMFREE(m_pBuffer);
    MEMFREE(m_awhWaveHeaders);
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::SetFormat"

HRESULT CWeGrDest::SetFormat(LPWAVEFORMATEX pwfx)
{
    MMRESULT mmr;
    HRESULT hr;

    DPF_ENTER();

    // ??? Can we optimize this process at all? Do we need to?

    if (m_hwo)
    {
        ShutdownEmulator();
        m_hwo = NULL;
    }

    // FIXME allocation and freeing of the looping buffer is
    // really screwy.  Need to review relevant code.  Esp. check
    // case where SetFormat fails and then attempts to restore the
    // original format
    
    // In this case, the looping buffer will not be free'd
    // because that is normally the job of the release code for
    // the primary. Do it now.

    MEMFREE(m_pBuffer);
    MEMFREE(m_awhWaveHeaders);

    SetFormatInfo(pwfx);

    mmr = InitializeEmulator();
    if (!mmr)
        hr = DS_OK;
    else
    {
        DPF(DPFLVL_WARNING, "Attempt to reinitialize emulator failed! %u",mmr);
        if (WAVERR_BADFORMAT == mmr)
            hr = DSERR_BADFORMAT;
        else if (MMSYSERR_NOMEM == mmr)
            hr = DSERR_OUTOFMEMORY;
        else
            hr = DSERR_GENERIC;
    }

    m_cSamples = m_cbBuffer >> m_nBlockAlignShift;

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::AllocMixer"

HRESULT CWeGrDest::AllocMixer(CMixer **ppMixer)
{
    HRESULT hr;
    ASSERT(m_pBuffer);
    
    *ppMixer = NULL;
    
    m_pWeGrace = NEW(CWeGrace);
    hr = HRFROMP(m_pWeGrace);

    if (SUCCEEDED(hr))
        hr = m_pWeGrace->Initialize(this);

    if (SUCCEEDED(hr))
        *ppMixer = m_pWeGrace;
    else
        DELETE(m_pWeGrace);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::FreeMixer"

void CWeGrDest::FreeMixer()
{
    ASSERT(m_pWeGrace);

    m_pWeGrace->Terminate();
    DELETE(m_pWeGrace);
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::Play"

void CWeGrDest::Play()
{
    // REMIND must reimplement to actually play, especially if we ever fix
    // this to support DSSCL_WRITEPRIMARY apps in wave emulation mode.
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::Stop"

void CWeGrDest::Stop()
{
    // REMIND must reimplement to actually stop, especially if we ever fix
    // this to support DSSCL_WRITEPRIMARY apps in wave emulation mode.
    if (m_pBuffer)
        FillMemory(m_pBuffer, m_cbBuffer, (H_16_BITS & m_hfFormat) ? 0x00 : 0x80);
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::GetSamplePosition"

HRESULT CWeGrDest::GetSamplePosition(int *pposPlay, int *pposWrite)
{
    MMTIME mmt;
    int iawhWrite;
    int iawhPrevious;
    int posStartOfPreviousHeader;
    MMRESULT mmr;
    HRESULT hr = DSERR_GENERIC;

    if(pposPlay && pposWrite && m_hwo)
    {
        // For the play position, try to get sample position from wave driver.
        // If that doesn't work then we'll return a play position based on the
        // last done wave header.
        mmt.wType = TIME_SAMPLES;
        mmr = waveOutGetPosition(m_hwo, &mmt, sizeof(mmt));

        // Note: This assert might need to be #ifdef'd out on Win2K because of a
        // known bug in WDMAUD's memory error propagation (see Windows Bug 176033).
        ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
        // Want to catch bugs, but still handle error in case of bad drivers

        if (!mmr && (TIME_SAMPLES == mmt.wType))
            *pposPlay = mmt.u.sample % m_cSamples;
        else if (!mmr && (TIME_BYTES == mmt.wType))
            *pposPlay = (mmt.u.cb % m_cbBuffer) >> m_nBlockAlignShift;
        else
            *pposPlay = (m_iawhPlaying * m_cbDMASize) >> m_nBlockAlignShift;

        // Some ill-behaved drivers are completing headers before the wave
        // position gets past the data in the header.  Let's do a sanity check
        // to make sure the reported position is not in the last completed header

        iawhPrevious = (m_iawhPlaying + m_cWaveHeaders - 1) % m_cWaveHeaders;
        posStartOfPreviousHeader = iawhPrevious * (m_cbDMASize >> m_nBlockAlignShift);
        if (*pposPlay >= posStartOfPreviousHeader &&
            *pposPlay < posStartOfPreviousHeader + (int)(m_cbDMASize >> m_nBlockAlignShift))
        {
            *pposPlay = (m_iawhPlaying * m_cbDMASize) >> m_nBlockAlignShift;
        }
    
        // The write position is based on the last done header
        iawhWrite = (m_iawhPlaying + N_EMU_WAVE_HDRS_INQUEUE) % m_cWaveHeaders;
        *pposWrite = (iawhWrite * m_cbDMASize) >> m_nBlockAlignShift;

        hr = DS_OK;
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::GetSamplePositionNoWin16"

HRESULT CWeGrDest::GetSamplePositionNoWin16(int *pposPlay, int *pposWrite)
{
    int iawhWrite;
    
    // Estimate play position by just using position at start of
    // currently playing header
    *pposPlay = (m_iawhPlaying * m_cbDMASize) >> m_nBlockAlignShift;

    // The write position is based on the last done header
    iawhWrite = (m_iawhPlaying + N_EMU_WAVE_HDRS_INQUEUE) % m_cWaveHeaders;
    *pposWrite = (iawhWrite * m_cbDMASize) >> m_nBlockAlignShift;

    return DS_OK;
}

//---------------------------------------------------------------------------
//
// waveThreadLoop
//
//  This function is responsible for continuously writing our wave headers
// to the wave device.  It also calls the MixThreadCallback routine to
// mix more data into the wave headers.
//
//  This function waits for a WaveHeaderDone event signalled by
// waveThreadCallback, which is a waveOutProc callback function.  Upon
// receving the signal this function will write all done headers back to
// the wave device.  Normally one header will be done on each signal.  But
// there may be more in cases where more than one header finishex before this
// thread is scheduled.
//
//  Once all done headers are rewritten to the wave device, the header
// following the last one written is considered to be the one currently
// playing.  This header is called the "committed" header and an index to
// it is saved in pds->iawhPlaying.
//
//  The count of done headers is maintained using the Interlocked APIs.  The
// waveThreadCallback function will increment the count and this function will
// decrement it.
//
//  This function will also react to a terminate event.  This event is
// signalled during release of the DirectSound object.  This loop will
// terminate and return to the waveThread function which will clean up
// and terminate.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::WaveThreadLoop"

void CWeGrDest::WaveThreadLoop(HANDLE hEventTerminate)
{
    MMRESULT mmr;

    while (TRUE)
    {
        DWORD dwResult;
        LPWAVEHDR pwh;
        int iawhWrite;
        HANDLE ah[2] = {hEventTerminate, m_hEventWaveHeaderDone};

        // The first wait is for either a terminate or headerdone event.
        // The second wait is for either a terminate or the DLL mutex.
        dwResult = WaitObjectArray(2, INFINITE, FALSE, ah);
        if (WAIT_OBJECT_0 == dwResult) break;

        InterlockedDecrement(&m_cwhDone);
        while (m_cwhDone >= 0)
        {
            dwResult = ENTER_MIXER_MUTEX_OR_EVENT(hEventTerminate);
            if (WAIT_OBJECT_0 == dwResult)
                break;

            m_iawhPlaying = (m_iawhPlaying + 1) % m_cWaveHeaders;

            if (m_pWeGrace)
                m_pWeGrace->Refresh(m_cbDMASize >> m_nBlockAlignShift);
            
            iawhWrite = (m_iawhPlaying + N_EMU_WAVE_HDRS_INQUEUE) % m_cWaveHeaders;
            pwh = m_awhWaveHeaders + iawhWrite;

            // Leave the mixer mutex in order to avoid deadlock situations
            // with the Win16Mutex and waveOutWrite.
            LEAVE_MIXER_MUTEX();

            mmr = waveOutWrite(m_hwo, pwh, sizeof(*pwh));
            ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);

            InterlockedDecrement(&m_cwhDone);
        }
        InterlockedIncrement(&m_cwhDone);

        if (WAIT_OBJECT_0 == dwResult)
            break;
    }

    DPF_LEAVE_VOID();
}


//---------------------------------------------------------------------------
//
// WaveCallback
//
//  This is a waveOutProc callback function.  Its sole purpose is to
// increment a count of done headers and signal and event to waveThreadLoop
// that another header is done.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "WaveCallbackC"

VOID CALLBACK WaveCallbackC
(
    HWAVE     hwo,
    UINT      uMsg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
)
{
    ((CWeGrDest *)dwUser)->WaveCallback(hwo, uMsg, dwParam1, dwParam2);
}

//---------------------------------------------------------------------------
//
// waveThreadCallback
//
//  This is a waveOutProc callback function.  Its sole purpose is to
// increment a count of done headers and signal and event to waveThreadLoop
// that another header is done.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::WaveCallback"

VOID CWeGrDest::WaveCallback
(
    HWAVE     hwo,
    UINT      uMsg,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
)
{
    if ((MM_WOM_DONE == uMsg) && (m_hEventWaveHeaderDone))
    {
        InterlockedIncrement(&m_cwhDone);
        SetEvent(m_hEventWaveHeaderDone);
    }
}

#undef DPF_FNAME
#define DPF_FNAME "WaveThreadC"

DWORD WINAPI WaveThreadC
(
    PVOID pThreadParams
)
{
    return ((CWeGrDest *)pThreadParams)->WaveThread();
}
    

//---------------------------------------------------------------------------
//
// WaveThread
//
// This thread proc initializes the wave device for DS emulation and then
// calls waveThreadLoop.  See the waveThreadLoop comment header.  Upon
// return from waveThreadLoop, this function will clean up and terminate.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::WaveThread"

DWORD CWeGrDest::WaveThread(void)
{
    HANDLE      hEventInitDone;
    HANDLE      hEventTerminate;
    DWORD       dwVolume;
    MMRESULT    mmrInit;
    MMRESULT    mmr;
    BOOL        f;

    // mmrInit - holds the result code to be passed back to the creator
    //  via pds->mmrWaveThreadInit.
    //
    // mmr - a temp result code
    
    DPF(DPFLVL_INFO, "WaveThread startup for pWeGrDest=%08lX", this);

    ASSERT(NULL == m_hwo);

    hEventInitDone = CreateEvent(NULL, FALSE, FALSE, m_szEventWaveThreadInitDone);
    if (!hEventInitDone)
    {
        DPF(DPFLVL_ERROR, "Couldn't create hEventInitDone");
        return 0;
    }

    // The waveOutOpen call below needs to happen at normal process
    // and thread priority, to prevent tedious deadlocks in WinMM

    HANDLE hProcess = GetCurrentProcess();
    HANDLE hThread  = GetCurrentThread();
    DWORD dwProcPri = GetPriorityClass(hProcess);
    INT nThreadPri  = GetThreadPriority(hThread);

    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    SetThreadPriority(hThread, THREAD_PRIORITY_NORMAL);

    mmrInit = waveOutOpen(&m_hwo, m_uDeviceId, &m_wfx, (DWORD_PTR)WaveCallbackC, (DWORD_PTR)this, CALLBACK_FUNCTION);

    SetPriorityClass(hProcess, dwProcPri);
    SetThreadPriority(hThread, nThreadPri);

    if (MMSYSERR_NOERROR == mmrInit)
    {
        // Some mmsystem wave drivers will program their wave mixer
        // hardware only while the device is open.  By doing the
        // following, we can get such drivers to program the hardware:

        mmr = waveOutGetVolume(m_hwo, &dwVolume);
        if (MMSYSERR_NOERROR == mmr)
            mmr = waveOutSetVolume(m_hwo, dwVolume);

        #ifndef WINNT
        ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
        // Note: #ifdef'd out on NT for now because of a known bug in
        // WDMAUD's memory error propagation (see Windows Bug 176033).
        #endif

        f = SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
        ASSERT(f);
        
        mmrInit = WaveDetermineDMASize(m_hwo, &m_wfx, &m_cbBuffer, &m_cWaveHeaders, &m_cbDMASize);
        if (MMSYSERR_NOERROR == mmrInit) 
        {
            ASSERT(NULL == m_hEventWaveHeaderDone);
            m_cwhDone = 0;
            m_hEventWaveHeaderDone = CreateEvent(NULL, FALSE, FALSE, m_szEventWaveHeaderDone);
            if (!m_hEventWaveHeaderDone)
                mmrInit = MMSYSERR_NOMEM;
            if (!mmrInit)
            {
                m_iawhPlaying = 0;
                ASSERT(m_cbDMASize * m_cWaveHeaders == m_cbBuffer);

                mmrInit = WaveAllocAndPrepareLoopingBuffers(m_hwo, &m_wfx, m_cWaveHeaders,
                    N_EMU_WAVE_HDRS_INQUEUE, &m_awhWaveHeaders, m_cbDMASize, &m_pBuffer);
                
                if (!mmrInit)
                {
                    hEventTerminate = CreateEvent(NULL, FALSE, FALSE, m_szEventTerminateWaveThread);
                    if (!hEventTerminate) mmrInit = MMSYSERR_NOMEM;
                    if (!mmrInit)
                    {
                        // Signal that we're finished with initialization.
                        // mmrInit should not be modified below this point.
                        m_mmrWaveThreadInit = mmrInit;
                        SetEvent(hEventInitDone);

                        WaveThreadLoop(hEventTerminate);

                        CloseHandle(hEventTerminate);
                    }

                    mmr = waveOutReset(m_hwo);
                    ASSERT(MMSYSERR_NOERROR == mmr);

                    WaveUnprepareLoopingBuffers(m_hwo, m_awhWaveHeaders, m_cWaveHeaders);
                }

                CloseHandle(m_hEventWaveHeaderDone);
                m_hEventWaveHeaderDone = NULL;
            }
        }

        mmr = waveOutReset(m_hwo);
        ASSERT(MMSYSERR_NOERROR == mmr);

        mmr = waveOutClose(m_hwo);
        ASSERT(MMSYSERR_NOERROR == mmr);
        m_hwo = NULL;
    }

    // If init failed, set the result code and signal init done.
    if (MMSYSERR_NOERROR != mmrInit)
    {
        m_hwo = NULL;
        m_mmrWaveThreadInit = mmrInit;
        SetEvent(hEventInitDone);
    }
    
    CloseHandle(hEventInitDone);
    return 0;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::InitializeEmulator"

MMRESULT CWeGrDest::InitializeEmulator(void)
{
    DWORD       dwResult;
    HANDLE      hEventInitDone;
    MMRESULT    mmr;

    DPF_ENTER();

    ASSERT(sizeof(m_szEventWaveHeaderDone) >= 7+8+8+1);
    wsprintf(m_szEventWaveHeaderDone, TEXT("DS-EWHD%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_szEventWaveThreadInitDone) >= 8+8+8+1);
    wsprintf(m_szEventWaveThreadInitDone, TEXT("DS-EWTID%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_szEventTerminateWaveThread) >= 7+8+8+1);
    wsprintf(m_szEventTerminateWaveThread, TEXT("DS-ETWT%08lX%08lX"), GetCurrentProcessId(), this);

    hEventInitDone = CreateEvent(NULL, FALSE, FALSE, m_szEventWaveThreadInitDone);
    if (!hEventInitDone)
        return MMSYSERR_NOMEM;

    // Side effects begin (hEventInitDone created)
    // hWaveThread is the thread which recycles wave buffers

#ifdef SHARED

    m_hWaveThread = HelperCreateDSMixerThread(WaveThreadC, this, 0, NULL);

#else // SHARED

    DWORD dwTid;
    m_hWaveThread = CreateThread(NULL, 0, WaveThreadC, this, 0, &dwTid);

#endif // SHARED

    mmr = (m_hWaveThread) ? MMSYSERR_NOERROR : MMSYSERR_NOMEM;

    if (MMSYSERR_NOERROR == mmr)
    {
        DPF(DPFLVL_MOREINFO, "Mixer thread created: 0x%p", m_hWaveThread);

        dwResult = WaitObject(INFINITE, hEventInitDone);
        ASSERT(WAIT_OBJECT_0 == dwResult);
        mmr = m_mmrWaveThreadInit;

        if (mmr)
        {
            HANDLE hHelper;
            HANDLE hWaveThreadOurs;

            // Something went wrong.  Clean up.

            // Note that hWaveThread is relative to the helper process.
            hHelper = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwHelperPid);
            if (hHelper)
            {
                if (DuplicateHandle(hHelper, m_hWaveThread,
                                    GetCurrentProcess(), &hWaveThreadOurs,
                                    SYNCHRONIZE | THREAD_TERMINATE,
                                    FALSE, DUPLICATE_CLOSE_SOURCE))
                {
                    dwResult = WaitObject(INFINITE, hWaveThreadOurs);
                    ASSERT(WAIT_OBJECT_0 == dwResult);
                    dwResult = CloseHandle(hWaveThreadOurs);
                    ASSERT(dwResult);
                }
                dwResult = CloseHandle(hHelper);
                ASSERT(dwResult);
            }
            m_hWaveThread = NULL;
        }
    }
    else
    {
        DPF(DPFLVL_ERROR, "Unable to create mixer thread");
    }

    dwResult = CloseHandle(hEventInitDone);
    ASSERT(dwResult);
    
    return mmr;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::ShutdownEmulator"

MMRESULT CWeGrDest::ShutdownEmulator(void)
{
    HANDLE  hEventTerminate;
    HANDLE  hHelper;
    HANDLE  hWaveThreadOurs;
    DWORD   dwResult;

    DPF(DPFLVL_INFO, "About to shutdown emulator");

    ASSERT(m_hWaveThread);
    
    // Signal wave thread to go away.

    hEventTerminate = CreateEvent(NULL, FALSE, FALSE, m_szEventTerminateWaveThread);
    if (hEventTerminate)
    {
        SetEvent(hEventTerminate);
        CloseHandle(hEventTerminate);
        hEventTerminate = NULL;
    }

    DPF(DPFLVL_MOREINFO, "Emulator: Wait for callback thread to die");

    hHelper = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwHelperPid);
    if (hHelper)
    {
        if (DuplicateHandle(hHelper, m_hWaveThread, GetCurrentProcess(),
                            &hWaveThreadOurs, SYNCHRONIZE | THREAD_TERMINATE,
                            FALSE, DUPLICATE_CLOSE_SOURCE))
        {
            dwResult = WaitObject(INFINITE, hWaveThreadOurs);
            ASSERT(dwResult == WAIT_OBJECT_0);

            if(GetExitCodeThread(hWaveThreadOurs, &dwResult) && 0 == dwResult)
            {
                ASSERT(NULL == m_hwo);   // waveThread should do this if it terminates normally
                m_hwo = NULL;
            }

            dwResult = CloseHandle(hWaveThreadOurs);
            ASSERT(dwResult);
        }
        dwResult = CloseHandle(hHelper);
        ASSERT(dwResult);
    }
    else
    {
        DPF(DPFLVL_WARNING, "Emulator: couldn't open handle on helper");
    }

    m_hWaveThread = NULL;
        
    return MMSYSERR_NOERROR;
}


#ifndef NOVXD

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::CNaGrDest"

CNaGrDest::CNaGrDest(LPNAGRDESTDATA pData)
{
    m_pBuffer = pData->pBuffer;
    m_cbBuffer = pData->cbBuffer;
    m_hBuffer = pData->hBuffer;
    m_phwo = pData->phwo;
    m_uDeviceId = pData->uDeviceId;
    m_fdwDriverDesc = pData->fdwDriverDesc;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Initialize"

HRESULT CNaGrDest::Initialize(void)
{
    m_cSamples = m_cbBuffer >> m_nBlockAlignShift;
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Terminate"

void CNaGrDest::Terminate(void)
{
    if(m_phwo)
        CloseWaveOut(m_phwo);
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Terminate"

HRESULT CNaGrDest::SetFormat(LPWAVEFORMATEX pwfx)
{
    HRESULT hr = DS_OK;

    SetFormatInfo(pwfx);

    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    if (DSDDESC_DOMMSYSTEMSETFORMAT & m_fdwDriverDesc)
    {
        // We need to set the wave format by doing a waveOutOpen
        // on the mmsystem wave device
        DPF(DPFLVL_MOREINFO, "DSDDESC_DOMMSYSTEMSETFORMAT");

        hr = CloseWaveOut(m_phwo);

        if (SUCCEEDED(hr))
            hr = OpenWaveOut(m_phwo, m_uDeviceId, pwfx);
    }

    if (SUCCEEDED(hr))
    {
        // If the driver specified DOMMSYSTEMSETFORMAT, this call
        // is just a notification to the DS driver that we've set the
        // format through waveOutOpen.  It is okay for the driver to
        // return DS_NOTSUPPORTED in that case.

        hr = VxdBufferSetFormat(m_hBuffer, pwfx);
        if ((DSDDESC_DOMMSYSTEMSETFORMAT & m_fdwDriverDesc) && (DSERR_UNSUPPORTED == hr))
            hr = DS_OK;
    
        if (FAILED(hr))
            DPF(DPFLVL_ERROR, "VxdBufferSetFormat returned %s", HRESULTtoSTRING(hr));
    }

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::AllocMixer"

HRESULT CNaGrDest::AllocMixer(CMixer **ppMixer)
{
    HRESULT hr;
    ASSERT(m_pBuffer);
    
    *ppMixer = NULL;
    
    m_pNaGrace = NEW(CNaGrace);
    hr = HRFROMP(m_pNaGrace);

    if (SUCCEEDED(hr))
        hr = m_pNaGrace->Initialize(this);

    if (SUCCEEDED(hr))
        *ppMixer = m_pNaGrace;
    else
        DELETE(m_pNaGrace);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::FreeMixer"

void CNaGrDest::FreeMixer()
{
    ASSERT(m_pNaGrace);

    m_pNaGrace->Terminate();
    DELETE(m_pNaGrace);
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Play"

void CNaGrDest::Play()
{
    VxdBufferPlay(m_hBuffer, 0, 0, DSBPLAY_LOOPING);
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Stop"

void CNaGrDest::Stop()
{
    VxdBufferStop(m_hBuffer);
}
    
#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Lock"

HRESULT CNaGrDest::Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite)
{
    LOCKCIRCULARBUFFER lcb;
    HRESULT            hr;
    
    lcb.pHwBuffer = m_hBuffer;
    lcb.pvBuffer = m_pBuffer;
    lcb.cbBuffer = m_cbBuffer;
    lcb.fPrimary = TRUE;
    lcb.fdwDriverDesc = m_fdwDriverDesc;
    lcb.ibRegion = ibWrite;
    lcb.cbRegion = cbWrite;

    hr = LockCircularBuffer(&lcb);

    if(SUCCEEDED(hr))
    {
        *ppBuffer1 = lcb.pvLock[0];
        *pcbBuffer1 = lcb.cbLock[0];

        if(ppBuffer2)
        {
            *ppBuffer2 = lcb.pvLock[1];
        }
        else
        {
            ASSERT(!lcb.pvLock[1]);
        }

        if(pcbBuffer2)
        {
            *pcbBuffer2 = lcb.cbLock[1];
        }
        else
        {
            ASSERT(!lcb.cbLock[1]);
        }
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Unlock"

HRESULT CNaGrDest::Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2)
{
    LOCKCIRCULARBUFFER lcb;

    lcb.pHwBuffer = m_hBuffer;
    lcb.pvBuffer = m_pBuffer;
    lcb.cbBuffer = m_cbBuffer;
    lcb.fPrimary = TRUE;
    lcb.fdwDriverDesc = m_fdwDriverDesc;
    lcb.pvLock[0] = pBuffer1;
    lcb.cbLock[0] = cbBuffer1;
    lcb.pvLock[1] = pBuffer2;
    lcb.cbLock[1] = cbBuffer2;

    return UnlockCircularBuffer(&lcb);
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::GetSamplePosition"

HRESULT CNaGrDest::GetSamplePosition(int *pposPlay, int *pposWrite)
{
    HRESULT hr;
    DWORD dwPlay, dwWrite;
    
    ASSERT(pposPlay && pposWrite);
    
    hr = VxdBufferGetPosition(m_hBuffer, &dwPlay, &dwWrite);
    if (SUCCEEDED(hr))
    {
        *pposPlay = dwPlay >> m_nBlockAlignShift;
        *pposWrite = dwWrite >> m_nBlockAlignShift;

        // Until we write code to actually profile the performance, we'll just
        // pad the write position with a hard coded amount
        *pposWrite += m_nFrequency * HW_WRITE_CURSOR_MSEC_PAD / 1024;
        if (*pposWrite >= m_cSamples) *pposWrite -= m_cSamples;
        ASSERT(*pposWrite < m_cSamples);
    }
    else
    {
        *pposPlay = *pposWrite = 0;
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::Terminate"

void CThMixer::Terminate(void)
{
    DPF_ENTER();
    
    m_pKeMixer = NULL;
    /*
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_Terminate,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);
    */
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::Run"

HRESULT CThMixer::Run(void)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    DPF_ENTER();

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_Run,
                          &ioparams,
                          sizeof(ioparams),
                          &hr,
                          sizeof(hr),
                          &cbReturned,
                          NULL);

    if (!fOk)
    {
        DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
        hr = DSERR_GENERIC;
    }
    else
    {
        ASSERT(cbReturned == sizeof(hr));
    }

    LEAVE_MIXER_MUTEX();
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::Stop"

BOOL CThMixer::Stop(void)
{
    BOOL f;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_Stop,
                          &ioparams,
                          sizeof(ioparams),
                          &f,
                          sizeof(f),
                          &cbReturned,
                          NULL);

    if (!fOk)
    {
        f = FALSE;
        DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    }
    else
    {
        ASSERT(cbReturned == sizeof(f));
    }

    LEAVE_MIXER_MUTEX();
    return f;
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::PlayWhenIdle"

void CThMixer::PlayWhenIdle(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_PlayWhenIdle,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::StopWhenIdle"

void CThMixer::StopWhenIdle(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_StopWhenIdle,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::MixListAdd"

void CThMixer::MixListAdd(CMixSource *pSource)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);
    ASSERT(pSource);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_MixListAdd,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::MixListRemove"

void CThMixer::MixListRemove(CMixSource *pSource)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_MixListRemove,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::FilterOn"

void CThMixer::FilterOn(CMixSource *pSource)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_FilterOn,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::FilterOff"

void CThMixer::FilterOff(CMixSource *pSource)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_FilterOff,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::GetBytePosition"

void CThMixer::GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
        int *pibPlay;
        int *pibWrite;
    } ioparams;

    ENTER_MIXER_MUTEX();
    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    ioparams.pibPlay = pibPlay;
    ioparams.pibWrite = pibWrite;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_GetBytePosition,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE (%lu)", GetLastError());
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::SignalRemix"

void CThMixer::SignalRemix(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_SignalRemix,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::Initialize"

HRESULT CThMixer::Initialize(PVOID pKeMixer)
{
    DPF_ENTER();

    ASSERT(!m_pKeMixer);
    m_pKeMixer = pKeMixer;
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::CThDest"

CThDest::CThDest(LPNAGRDESTDATA pData)
{
    CopyMemory(&m_ngdd, pData, sizeof(NAGRDESTDATA));
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::New"

HRESULT CThDest::New(void)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        LPNAGRDESTDATA pData;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ioparams.pData = &m_ngdd;
    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_KeDest_New,
                          &ioparams,
                          sizeof(ioparams),
                          &m_pKeDest,
                          sizeof(m_pKeDest),
                          &cbReturned,
                          NULL);

    if (!fOk)
    {
        DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
        m_pKeDest = NULL;
        hr = DSERR_GENERIC;
    }
    else
    {
        ASSERT(cbReturned == sizeof(m_pKeDest));
    }

    hr = HRFROMP(m_pKeDest);

    LEAVE_MIXER_MUTEX();
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::Initialize"

HRESULT CThDest::Initialize(void)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;
    
    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Initialize,
                          &ioparams,
                          sizeof(ioparams),
                          &hr,
                          sizeof(hr),
                          &cbReturned,
                          NULL);

    if (!fOk)
    {
        DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
        hr = DSERR_GENERIC;
    }
    else
    {
        ASSERT(cbReturned == sizeof(hr));
    }

    LEAVE_MIXER_MUTEX();
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::Terminate"

void CThDest::Terminate(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Terminate,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Delete,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::SetFormatInfo"

void CThDest::SetFormatInfo(LPWAVEFORMATEX pwfx)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
        LPWAVEFORMATEX pwfx;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    ioparams.pwfx = pwfx;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_SetFormatInfo,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::SetFormat"

HRESULT CThDest::SetFormat(LPWAVEFORMATEX pwfx)
{
    HRESULT hr = DS_OK;

    SetFormatInfo(pwfx);

    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    if (DSDDESC_DOMMSYSTEMSETFORMAT & m_ngdd.fdwDriverDesc)
    {
        // We need to set the wave format by doing a waveOutOpen
        // on the mmsystem wave device
        DPF(DPFLVL_MOREINFO, "DSDDESC_DOMMSYSTEMSETFORMAT");

        hr = CloseWaveOut(m_ngdd.phwo);

        if (SUCCEEDED(hr))
            hr = OpenWaveOut(m_ngdd.phwo, m_ngdd.uDeviceId, pwfx);
    }

    if (SUCCEEDED(hr))
    {
        // If the driver specified DOMMSYSTEMSETFORMAT, this call
        // is just a notification to the driver that we've set the
        // format through waveOutOpen.  It is OK for the driver to
        // return DS_NOTSUPPORTED in that case.

        struct {
            PVOID pKeDest;
            LPWAVEFORMATEX pwfx;
        } ioparams;

        ASSERT(m_pKeDest);

        ioparams.pKeDest = m_pKeDest;
        ioparams.pwfx = pwfx;
        DWORD cbReturned = 0;

        BOOL fOk = DeviceIoControl(g_hDsVxd,
                                   DSVXD_IOCTL_MixDest_SetFormat,
                                   &ioparams,
                                   sizeof(ioparams),
                                   &hr,
                                   sizeof(hr),
                                   &cbReturned,
                                   NULL);
        if (!fOk)
        {
            DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
            hr = DSERR_GENERIC;
        }
        else
            ASSERT(cbReturned == sizeof(hr));

        if ((DSDDESC_DOMMSYSTEMSETFORMAT & m_ngdd.fdwDriverDesc) && (DSERR_UNSUPPORTED == hr))
            // Drivers can return DSERR_UNSUPPORTED if they set DOMMSYSTEMSETFORMAT
            hr = DS_OK;

        if (FAILED(hr))
            DPF(DPFLVL_ERROR, "VxdBufferSetFormat returned %s", HRESULTtoSTRING(hr));
    }

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::AllocMixer"

HRESULT CThDest::AllocMixer(CMixer **ppMixer)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
        PVOID *ppKeMixer;
    } ioparamsAlloc;

    struct {
        PVOID pKeDest;
    } ioparamsFree;

    PVOID pKeMixer;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);
    ASSERT(!m_pThMixer);

    // 1) Allocate a ThMixer object
    // 2) Call KeDest object to allocate a KeMixer object
    // 3) Initialize the ThMixer object, passing the KeMixer object

    *ppMixer = NULL;

    // Allocate the ThMixer object
    m_pThMixer = NEW(CThMixer);
    hr = HRFROMP(m_pThMixer);

    if (SUCCEEDED(hr))
    {
        // Call KeDest object to allocate the KeMixer object
        ioparamsAlloc.pKeDest = m_pKeDest;
        ioparamsAlloc.ppKeMixer = &pKeMixer;
        cbReturned = 0;
    
        fOk = DeviceIoControl(g_hDsVxd,
                              DSVXD_IOCTL_MixDest_AllocMixer,
                              &ioparamsAlloc,
                              sizeof(ioparamsAlloc),
                              &hr,
                              sizeof(hr),
                              &cbReturned,
                              NULL);
        ASSERT(fOk);
        ASSERT(SUCCEEDED(hr));
        
        if (!fOk)
            hr = DSERR_GENERIC;
        else
            ASSERT(cbReturned == sizeof(hr));

        if (SUCCEEDED(hr))
        {
            ASSERT(pKeMixer);

            // Initialize the ThMixer object with the KeMixer object
            hr = m_pThMixer->Initialize(pKeMixer);
            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
            {
                ioparamsFree.pKeDest = m_pKeDest;
                cbReturned = 0;
            
                fOk = DeviceIoControl(g_hDsVxd,
                                      DSVXD_IOCTL_MixDest_FreeMixer,
                                      &ioparamsFree,
                                      sizeof(ioparamsFree),
                                      NULL,
                                      0,
                                      &cbReturned,
                                      NULL);
                ASSERT(fOk);
            }
        }

        if (FAILED(hr))
            DELETE(m_pThMixer);
    }

    if (SUCCEEDED(hr))
        *ppMixer = m_pThMixer;

    LEAVE_MIXER_MUTEX();
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::FreeMixer"

void CThDest::FreeMixer(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);
    ASSERT(m_pThMixer);

    m_pThMixer->Terminate();
    DELETE(m_pThMixer);
    
    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_FreeMixer,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::Play"

void CThDest::Play(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Play,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_ERROR, "DSVXD_IOCTL_MixDest_Play failed!");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::Stop"

void CThDest::Stop(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Stop,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_ERROR, "DSVXD_IOCTL_MixDest_Stop failed!");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::GetSamplePosition"

HRESULT CThDest::GetSamplePosition(int *pposPlay, int *pposWrite)
{
    ASSERT(FALSE);
    return DSERR_GENERIC;
    /*
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
        int *pposPlay;
        int *pposWrite;
    } ioparams;

    ENTER_MIXER_MUTEX();
    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    ioparams.pposPlay = pposPlay;
    ioparams.pposWrite = pposWrite;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_GetSamplePosition,
                          &ioparams,
                          sizeof(ioparams),
                          &hr,
                          sizeof(hr),
                          &cbReturned,
                          NULL);

    if (!fOk) {
        DPF(DPFLVL_ERROR, "DSVXD_IOCTL_MixDest_GetSamplePosition failed!");
        hr = DSERR_GENERIC;
    } else {
        ASSERT(cbReturned == sizeof(hr));
    }

    LEAVE_MIXER_MUTEX();
    return hr;
    */
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::GetFrequency"

ULONG CThDest::GetFrequency(void)
{
    ULONG nFrequency;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_GetFrequency,
                          &ioparams,
                          sizeof(ioparams),
                          &nFrequency,
                          sizeof(nFrequency),
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_ERROR, "DSVXD_IOCTL_MixDest_GetFrequency failed!");
    ASSERT(cbReturned == sizeof(nFrequency));

    LEAVE_MIXER_MUTEX();
    return nFrequency;
}

#endif // NOVXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\iirlut.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iirlut.h
 *  Content:    DirectSound3D IIR algorithm look up table
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/

#if !defined(LUT_HEADER)
#define LUT_HEADER
#pragma once

// Project-specific INCLUDEs
#include "dsoundi.h"
#include "vmaxhead.h"
#include "vmaxcoef.h"

#ifdef __cplusplus

// ---------------------------------------------------------------------------
// Typedefs

typedef FLOAT TCanonicalCoeffs[KSDS3D_COEFF_COUNT][NumBiquadsToNumCanonicalCoeffsHalf(CbyMaxBiquads)];


// ---------------------------------------------------------------------------
// VMAx 3D Interactive look-up table (LUT)

class CIirLut 
{
public:
    CIirLut();
    ~CIirLut();
    
    HRESULT Initialize(KSDS3D_HRTF_COEFF_FORMAT, KSDS3D_HRTF_FILTER_QUALITY, DWORD);

    ULONG GetMaxBiquadCoeffs() const;
    const PVOID GetCoeffs(const D3DVALUE, const D3DVALUE, const ESampleRate, const EFilter, PUINT);
    BOOL HaveCoeffsChanged(const D3DVALUE, const D3DVALUE, const ESampleRate, const EFilter);
    BOOL GetNegativeAzimuth() const;
    BOOL GetPreviousNegativeAzimuth() const;
    BOOL GetZeroAzimuthIndex() const;
    BOOL GetPreviousZeroAzimuthIndex() const;
    BOOL GetZeroAzimuthTransition() const;
    BOOL GetSymmetricalZeroAzimuthTransition() const;
    KSDS3D_HRTF_FILTER_QUALITY GetCoeffQuality() const;
    KSDS3D_HRTF_COEFF_FORMAT GetCoeffFormat() const;
    DWORD GetFilterTransitionMuteLength(const KSDS3D_HRTF_FILTER_QUALITY, const ESampleRate);
    DWORD GetFilterOverlapBufferLength(const KSDS3D_HRTF_FILTER_QUALITY, const ESampleRate);
    DWORD GetOutputOverlapBufferLength(const ESampleRate);
    HRESULT DsFrequencyToIirSampleRate(DWORD,ESampleRate*);

private:
    // Prohibit copy construction and assignment
    CIirLut(const CIirLut&);
    CIirLut& operator=(const CIirLut&);

    HRESULT ConvertDsSpeakerConfig(DWORD,ESpeakerConfig*);
    VOID InitData();
    VOID AnglesToIndices(D3DVALUE, D3DVALUE, INT&, UINT&);
    BOOL BiquadToCanonical(const FLOAT[], const UINT, TCanonicalCoeffs&);
    VOID FreeCoefficientMemory();
    DWORD GetBiquadCoeffOffset(const KSDS3D_HRTF_FILTER_QUALITY, const ESpeakerConfig, const ESampleRate, const UINT, const UINT, const BOOL);
    PFLOAT m_pfCoeffs;
    PSHORT m_psCoeffs;
    UINT m_uiPreviousElevationIndex;

    UINT m_aauiNumBiquadCoeffs[KSDS3D_FILTER_QUALITY_COUNT][espeakerconfigCount];
    UINT m_aauiNumCanonicalCoeffs[KSDS3D_FILTER_QUALITY_COUNT][espeakerconfigCount];
    UINT m_aauiNumPreviousElevationFilters[esamplerateCount][CuiNumElevationBins];

    UINT m_auiPreviousElevationIndex[efilterCount];
    int m_aiPreviousAzimuthIndex[efilterCount];
    ESampleRate m_aePreviousSampleRate[efilterCount];
    
    UINT m_uiNumElevationFilters[CuiNumElevationBins];
//    UINT m_uiTotalElevationFilters;

    KSDS3D_HRTF_COEFF_FORMAT m_eCoeffFormat;
    KSDS3D_HRTF_FILTER_QUALITY m_eCoeffQuality;
    ESpeakerConfig m_eSpeakerConfig;
    BYTE m_byMaxBiquadCoeffs;              
    BOOL m_bNegativeAzimuth;
    BOOL m_bPreviousNegativeAzimuth;
    BOOL m_bZeroAzimuthIndex;
    BOOL m_bPreviousZeroAzimuthIndex;
    BOOL m_bZeroAzimuthTransition;
    BOOL m_bSymmetricalZeroAzimuthTransition;

    HINSTANCE  m_hLutFile;
    HANDLE m_hLutFileMapping;
    PFLOAT m_pfLut;


};

// ---------------------------------------------------------------------------
// Include inline definitions inline in release version

#ifndef DEBUG
#include "iirlut.inl"
#endif

#endif // __cplusplus

#endif

// End of LUT.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\iirlut.inl ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iirlut.inl
 *  Content:    DirectSound3D IIR algorithm look up table
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/

#if !defined(LUT_INLINE)
#define LUT_INLINE
#pragma once

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

#if !defined(_DEBUG)
#define INLINE _inline
#else
#define INLINE
#endif


/***************************************************************************
 *
 *  ~CIirLut
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIirLut:~CIirLut"

INLINE CIirLut::~CIirLut()
{
    DPF_ENTER();
    DPF_DESTRUCT(CIirLut);

    // Free owned objects
    FreeLibrary(m_hLutFile);
    FreeCoefficientMemory();

    DPF_LEAVE_VOID();
}

// Get maximum filter length
INLINE ULONG CIirLut::GetMaxBiquadCoeffs() const
{
    return (ULONG)m_byMaxBiquadCoeffs;
}

// Get negative azimuth flag
INLINE BOOL CIirLut::GetNegativeAzimuth() const
{
    return m_bNegativeAzimuth;
}

// Get previous negative azimuth flag
INLINE BOOL CIirLut::GetPreviousNegativeAzimuth() const
{
    return m_bPreviousNegativeAzimuth;
}

// Get zero azimuth index flag
INLINE BOOL CIirLut::GetZeroAzimuthIndex() const
{
    return m_bZeroAzimuthIndex;
}

// Get previous zero azimuth index flag
INLINE BOOL CIirLut::GetPreviousZeroAzimuthIndex() const
{
    return m_bPreviousZeroAzimuthIndex;
}

// Get zero azimuth transition flag
INLINE BOOL CIirLut::GetZeroAzimuthTransition() const
{
    return m_bZeroAzimuthTransition;
}

// Get symmetrical zero azimuth transition flag
INLINE BOOL CIirLut::GetSymmetricalZeroAzimuthTransition() const
{
    return m_bSymmetricalZeroAzimuthTransition;
}

// Get zero azimuth index flag
INLINE KSDS3D_HRTF_COEFF_FORMAT CIirLut::GetCoeffFormat() const
{
    return m_eCoeffFormat;
}

// Get biquad coefficient offset
INLINE DWORD CIirLut::GetBiquadCoeffOffset
(
    const KSDS3D_HRTF_FILTER_QUALITY CeFilterQuality, 
    const ESpeakerConfig CeSpeakerConfig, 
    const ESampleRate CeSampleRate, 
    const UINT CuiElevationIndex, 
    const UINT CuiAzimuthIndex, 
    const BOOL CbTableLookup
)
{
    ASSERT(CeFilterQuality >= 0 && CeFilterQuality < KSDS3D_FILTER_QUALITY_COUNT);
    ASSERT(CeSpeakerConfig >= 0 && CeSpeakerConfig < espeakerconfigCount);
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);
    ASSERT(CuiElevationIndex >= 0 && CuiElevationIndex < CuiNumElevationBins);
    ASSERT(CuiAzimuthIndex >= 0 && CuiAzimuthIndex < CauiNumAzimuthBins[CuiElevationIndex]);
    
    DWORD dwOffset(CaaaaawBiquadCoeffOffset[CeFilterQuality][CeSpeakerConfig][CeSampleRate][CuiElevationIndex][CuiAzimuthIndex]);
    if (CbTableLookup == TRUE)
        dwOffset += CaadwBiquadCoeffOffsetOffset[CeFilterQuality][CeSpeakerConfig];
    return dwOffset * ebiquadcoefftypeCount;
}

// Get biquad coefficient offset
INLINE DWORD CIirLut::GetFilterTransitionMuteLength
(
    const KSDS3D_HRTF_FILTER_QUALITY CeFilterQuality, 
    const ESampleRate CeSampleRate
)
{
    ASSERT(CeFilterQuality >= 0 && CeFilterQuality < KSDS3D_FILTER_QUALITY_COUNT);
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);
    
    return CaastFilterMuteLength[CeFilterQuality][CeSampleRate];
}

// Get biquad coefficient offset
INLINE DWORD CIirLut::GetFilterOverlapBufferLength
(
    const KSDS3D_HRTF_FILTER_QUALITY CeFilterQuality, 
    const ESampleRate CeSampleRate
)
{
    ASSERT(CeFilterQuality >= 0 && CeFilterQuality < KSDS3D_FILTER_QUALITY_COUNT);
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);
    
    return CaastFilterOverlapLength[CeFilterQuality][CeSampleRate];
}

// Get biquad coefficient offset
INLINE DWORD CIirLut::GetOutputOverlapBufferLength
( 
    const ESampleRate CeSampleRate
)
{
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);
    
    return CastOutputOverlapLength[CeSampleRate];
}

#endif

// End of LUT.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\grsource.cpp ===
//--------------------------------------------------------------------------;
//
//  File: grsource.cpp
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/25/96    FrankYe     Created
//
//  Implementation notes:
//
// The CMixSource class is used in both ring 0 and ring 3.  MixSource
// objects are passed across the rings, so it is important that the physical
// layout of the class be consistent in both rings.  It is also crucial that
// member functions are called directly instead of through the vtable, as a
// MixSource object created in ring 3 will have a vtable pointing to ring 3
// functions, which of course ring 0 cannot call.  Ring 0 must call the ring 0
// implementation of these functions.
//
// If you do something to break this, it'll probably be apparent almost
// immediately when you test with ring 0 mixing.
//
// Also, because the MixSource objects are accessed in both rings, any
// member data that can be accessed by both rings simultaneously must be
// serialized via the MixerMutex.  Member data always accessed only by a single
// ring are probably okay.  Those called only in ring 3 are protected by the
// DLL mutex, and those called only in ring 0 are protected by the MixerMutex.
//
// Member functions called from ring 0 should not call the
// ENTER_MIXER_MUTEX / LEAVE_MIXER_MUTEX macros as these work only
// for ring 3.
//
//--------------------------------------------------------------------------;
#define NODSOUNDSERVICETABLE

#include "dsoundi.h"

#ifndef Not_VxD
#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG
#endif

PVOID MixSource_New(PVOID pMixer)
{
    return NEW(CMixSource((CMixer *)pMixer));
}

void MixSource_Delete(PVOID pMixSource)
{
    CMixSource *p = (CMixSource *)pMixSource;
    DELETE(p);
}

BOOL MixSource_Stop(PVOID pMixSource)
{
    return ((CMixSource *)pMixSource)->Stop();
}

void MixSource_Play(PVOID pMixSource, BOOL fLooping)
{
    ((CMixSource *)pMixSource)->Play(fLooping);
}

void MixSource_Update(PVOID pMixSource, int ibUpdate1, int cbUpdate1, int ibUpdate2, int cbUpdate2)
{
    ((CMixSource *)pMixSource)->Update(ibUpdate1, cbUpdate1, ibUpdate2, cbUpdate2);
}

HRESULT MixSource_Initialize(PVOID pMixSource, PVOID pBuffer, int cbBuffer, LPWAVEFORMATEX pwfx, PFIRCONTEXT *ppFirLeft, PFIRCONTEXT *ppFirRight)
{
    return ((CMixSource *)pMixSource)->Initialize(pBuffer, cbBuffer, pwfx, ppFirLeft, ppFirRight);
}

void MixSource_FilterOn(PVOID pMixSource)
{
    ((CMixSource *)pMixSource)->FilterOn();
}

void MixSource_FilterOff(PVOID pMixSource)
{
    ((CMixSource *)pMixSource)->FilterOff();
}

BOOL MixSource_HasFilter(PVOID pMixSource)
{
    return ((CMixSource *)pMixSource)->HasFilter();
}

void MixSource_SetVolumePan(PVOID pMixSource, PDSVOLUMEPAN pdsVolPan)
{
    ((CMixSource *)pMixSource)->SetVolumePan(pdsVolPan);
}

void MixSource_SetFrequency(PVOID pMixSource, ULONG nFrequency)
{
    ((CMixSource *)pMixSource)->SetFrequency(nFrequency);
}

ULONG MixSource_GetFrequency(PVOID pMixSource)
{
    return ((CMixSource *)pMixSource)->GetFrequency();
}

HRESULT MixSource_SetNotificationPositions(PVOID pMixSource, int cNotes, LPCDSBPOSITIONNOTIFY paNotes)
{
    return ((CMixSource *)pMixSource)->SetNotificationPositions(cNotes, paNotes);
}

void MixSource_MuteOn(PVOID pMixSource)
{
    ((CMixSource *)pMixSource)->m_fMute = TRUE;
}

void MixSource_MuteOff(PVOID pMixSource)
{
    ((CMixSource *)pMixSource)->m_fMute = FALSE;
}

void MixSource_SetBytePosition(PVOID pMixSource, int ibPosition)
{
    ((CMixSource *)pMixSource)->SetBytePosition(ibPosition);
}

void MixSource_GetBytePosition1(PVOID pMixSource, int *pibPlay, int *pibWrite)
{
    ((CMixSource *)pMixSource)->GetBytePosition1(pibPlay, pibWrite);
}

void MixSource_GetBytePosition(PVOID pMixSource, int *pibPlay, int *pibWrite, int *pibMix)
{
    ((CMixSource *)pMixSource)->GetBytePosition(pibPlay, pibWrite, pibMix);
}

BOOL MixSource_IsPlaying(PVOID pMixSource)
{
    return ((CMixSource *)pMixSource)->IsPlaying();
}


//--------------------------------------------------------------------------;
//
// CMixSource::CMixSource constructor
//
//--------------------------------------------------------------------------;
CMixSource::CMixSource(CMixer *pMixer)
{
    m_cSamplesMixed = 0;
    m_cSamplesRemixed = 0;
    m_pDsbNotes = NULL;
    m_MapTable = NULL;
    
    m_pMixer = pMixer;

    m_dwSignature = ~MIXSOURCE_SIGNATURE;
}

//--------------------------------------------------------------------------;
//
// CMixSource::~CMixSource destructor
//
//--------------------------------------------------------------------------;
CMixSource::~CMixSource(void)
{
#ifdef PROFILEREMIXING
    if (0 != (m_cSamplesMixed - m_cSamplesRemixed)) {
        int Percentage = MulDivRN(m_cSamplesRemixed, 100, (m_cSamplesMixed - m_cSamplesRemixed));
#ifdef Not_VxD
        DPF(3, "this MixSource=%08Xh remixed %d percent", this, Percentage);
#else
        DPF(("this MixSource=%08Xh remixed %d percent", this, Percentage));
#endif
    } else {
#ifdef Not_VxD
        DPF(3, "this MixSource=%08Xh had no net mix");
#else
        DPF(("this MixSource=%08Xh had no net mix"));
#endif
    }
#endif

    DELETE(m_pDsbNotes);
    MEMFREE(m_MapTable);
}

//--------------------------------------------------------------------------;
//
// CMixSource::Initialize
//
//--------------------------------------------------------------------------;
HRESULT CMixSource::Initialize(PVOID pBuffer, int cbBuffer, LPWAVEFORMATEX pwfx, PFIRCONTEXT *ppFirContextLeft, PFIRCONTEXT *ppFirContextRight)
{
#ifdef Not_VxD
    ASSERT(m_pBuffer == NULL);
    ASSERT(pwfx->wFormatTag == WAVE_FORMAT_PCM);

    m_pDsbNotes = NEW(CDsbNotes);
    HRESULT hr = m_pDsbNotes ? S_OK : E_OUTOFMEMORY;

    if (S_OK == hr)
    {
        hr = m_pDsbNotes->Initialize(cbBuffer);

        m_ppFirContextLeft = ppFirContextLeft;
        m_ppFirContextRight = ppFirContextRight;
        m_pBuffer = pBuffer;
        m_cbBuffer = cbBuffer;
        m_cSamples = m_cbBuffer >> m_nBlockAlignShift;

        m_dwLVolume = 0xffff;
        m_dwRVolume = 0xffff;
        m_dwMVolume = 0xffff;
        m_nFrequency = pwfx->nSamplesPerSec;

        m_dwFraction = 0;
        m_nLastMergeFrequency = m_nFrequency + 1;        // Different.
        m_MapTable   = NULL;
        m_dwLastLVolume = 0;
        m_dwLastRVolume = 0;

        // m_nUserFrequency = pwfx->nSamplesPerSec;

        m_hfFormat &= ~H_LOOP;

        if (pwfx->wBitsPerSample == 8)
            m_hfFormat |= (H_8_BITS | H_UNSIGNED);
        else
            m_hfFormat |= (H_16_BITS | H_SIGNED);
        if (pwfx->nChannels == 2)
            m_hfFormat |= (H_STEREO | H_ORDER_LR);
        else
            m_hfFormat |= H_MONO;

        m_cSamples = m_cbBuffer / pwfx->nBlockAlign;

        switch (pwfx->nBlockAlign)
        {
            case 1: m_nBlockAlignShift = 0; break;
            case 2: m_nBlockAlignShift = 1; break;
            case 4: m_nBlockAlignShift = 2; break;
            default: ASSERT(FALSE);
        }

#ifdef USE_INLINE_ASM
        #define CPU_ID _asm _emit 0x0f _asm _emit 0xa2  
        int No_MMX = 1;
        _asm 
        {
            push    ebx
            pushfd                      // Store original EFLAGS on stack
            pop     eax                 // Get original EFLAGS in EAX
            mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
            xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
            push    eax                 // Save new EFLAGS value on stack
            popfd                       // Replace current EFLAGS value
            pushfd                      // Store new EFLAGS on stack
            pop     eax                 // Get new EFLAGS in EAX
            xor     eax, ecx            // Can we toggle ID bit?
            jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
            mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
            CPU_ID                      // Get family/model/stepping/features
            test    edx, 0x00800000L    // Check if mmx technology available
            jz      Done                // Jump if no
            dec     No_MMX              // MMX present
            Done:
            pop     ebx
        }
        m_fUse_MMX = !No_MMX;
//      m_fUse_MMX = 0; 
#endif // USE_INLINE_ASM
    }

    if (S_OK != hr) DELETE(m_pDsbNotes);
    if (S_OK == hr) m_dwSignature = MIXSOURCE_SIGNATURE;
    
    return hr;
#else // Not_VxD
    ASSERT(FALSE);
    return E_UNEXPECTED;
#endif // Not_VxD
}

//--------------------------------------------------------------------------;
//
// CMixSource::IsPlaying
//
//--------------------------------------------------------------------------;
BOOL CMixSource::IsPlaying()
{
    return MIXSOURCESTATE_STOPPED != m_kMixerState;
}

//--------------------------------------------------------------------------;
//
// CMixSource::Stop
//
//        Note this function does not notify the CMixSource's Stop event, if
// it has one.  The caller of this function should also call
// CMixSource::NotifyStop if appropriate.
//
//--------------------------------------------------------------------------;
BOOL CMixSource::Stop()
{
#ifdef Not_VxD
    int ibPlay;
    int dbNextNotify;

    if (MIXSOURCESTATE_STOPPED == m_kMixerState) return FALSE;
    
    m_pMixer->GetBytePosition(this, &ibPlay, NULL);
    m_pMixer->MixListRemove(this);
    m_posNextMix = ibPlay >> m_nBlockAlignShift;
    
    if (!m_fMute) m_pMixer->SignalRemix();

    ASSERT(m_pDsbNotes);

    m_pDsbNotes->NotifyToPosition(ibPlay, &dbNextNotify);

    return TRUE;
#else
    ASSERT(FALSE);
    return TRUE;
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::Play
//
//--------------------------------------------------------------------------;
void CMixSource::Play(BOOL fLooping)
{
#ifdef Not_VxD
    if (fLooping) {
        LoopingOn();
    } else {
        LoopingOff();
    }

    ENTER_MIXER_MUTEX();

    if (MIXSOURCESTATE_STOPPED == m_kMixerState) {
        
        // Add this source to the mixer's list
        m_pMixer->MixListAdd(this);
        SignalRemix();

        // Must move the notification position pointer otherwise we'll signal
        // everything from the beginning of the buffer.
        if (m_pDsbNotes) {
            int ibPlay;
            m_pMixer->GetBytePosition(this, &ibPlay, NULL);
            m_pDsbNotes->SetPosition(ibPlay);
        }
    }

    LEAVE_MIXER_MUTEX();
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::Update
//
//--------------------------------------------------------------------------;
void CMixSource::Update(int ibUpdate1, int cbUpdate1, int ibUpdate2, int cbUpdate2)
{
    int ibWrite, ibMix;
    int cbPremixed;
    BOOL fRegionsIntersect;
        
    if (MIXSOURCESTATE_STOPPED == m_kMixerState) return;

    GetBytePosition(NULL, &ibWrite, &ibMix);

    cbPremixed = ibMix - ibWrite;
    if (cbPremixed < 0) cbPremixed += m_cbBuffer;
    ASSERT(cbPremixed >= 0);

    fRegionsIntersect = CircularBufferRegionsIntersect(m_cbBuffer,
        ibWrite, cbPremixed, ibUpdate1, cbUpdate1);

    if (!fRegionsIntersect && ibUpdate2) {
        fRegionsIntersect = CircularBufferRegionsIntersect(m_cbBuffer,
            ibWrite, cbPremixed, ibUpdate2, cbUpdate2);
    }

    if (fRegionsIntersect) {
        // DPF(4, "Lock: note: unlocked premixed region");
        SignalRemix();
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::SetVolumePan
//
//--------------------------------------------------------------------------;
void CMixSource::SetVolumePan(PDSVOLUMEPAN pdsVolPan)
{
    m_dwLVolume = pdsVolPan->dwTotalLeftAmpFactor;
    m_dwRVolume = pdsVolPan->dwTotalRightAmpFactor;
    m_dwMVolume = (m_dwLVolume + m_dwRVolume) / 2;

    // Make MapTable for both left and right sides.  Low and high byte.
    if (m_dwRVolume != 0xffff || m_dwLVolume != 0xffff) {
        if (!m_fUse_MMX && !m_MapTable) {
            if (m_hfFormat & H_16_BITS) {
#ifdef USE_SLOWER_TABLES    // Of course, DONT!
                m_MapTable = MEMALLOC_A(LONG, (2 * 256) + (2 * 256));
#endif
            } else {
                m_MapTable = MEMALLOC_A(LONG, (2 * 256));
            }
        }
        if (m_MapTable &&
            (m_dwLastLVolume != m_dwLVolume || m_dwLastRVolume != m_dwRVolume))
            {
            m_dwLastLVolume = m_dwLVolume;
            m_dwLastRVolume = m_dwRVolume;

            // Fill low byte part.
            int  i;
            LONG volL, volLinc;
            LONG volR, volRinc;

            volLinc = m_dwLVolume;
            volRinc = m_dwRVolume;

            // Byte case.  Fold conversion into this.
            if (m_hfFormat & H_16_BITS) {
#ifdef USE_SLOWER_TABLES    // Of course, DONT!
                volL = m_dwLVolume;
                volR = m_dwRVolume;

                for (i = 0; i < 256; ++i)                   // Low byte.
                {
                    m_MapTable[i + 0  ] = volL >> 16;
                    m_MapTable[i + 256] = volR >> 16;
    
                    volL += m_dwLVolume;
                    volR += m_dwRVolume;
                }

                volL = - (LONG)(m_dwLVolume * 128 * 256);   // High byte.
                volR = - (LONG)(m_dwRVolume * 128 * 256);

                volLinc = m_dwLVolume * 256;
                volRinc = m_dwRVolume * 256;

                for (i = 0; i < 256; ++i)
                {
                    m_MapTable[512 + i + 0  ] = volL >> 16;
                    m_MapTable[512 + i + 256] = volR >> 16;
    
                    volL += volLinc;
                    volR += volRinc;
                }
#endif // USE_SLOWER_TABLES
            } else {
                volL = - (LONG)(m_dwLVolume * 128 * 256);
                volR = - (LONG)(m_dwRVolume * 128 * 256);

                volLinc = m_dwLVolume * 256;
                volRinc = m_dwRVolume * 256;

                for (i = 0; i < 256; ++i)
                {
                    m_MapTable[i + 0  ] = volL >> 16;
                    m_MapTable[i + 256] = volR >> 16;

                    volL += volLinc;
                    volR += volRinc;
                }
            }
        }
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::GetFrequency
//
//--------------------------------------------------------------------------;
ULONG CMixSource::GetFrequency()
{
    return m_nFrequency;
}

//--------------------------------------------------------------------------;
//
// CMixSource::SetFrequency
//
//--------------------------------------------------------------------------;
void CMixSource::SetFrequency(ULONG nFrequency)
{
    ASSERT(0 != nFrequency);
    ENTER_MIXER_MUTEX();
    m_nFrequency = nFrequency;
    LEAVE_MIXER_MUTEX();
    SignalRemix();
}

//--------------------------------------------------------------------------;
//
// CMixSource::GetNextMixBytePosition
//
//--------------------------------------------------------------------------;
int CMixSource::GetNextMixBytePosition()
{
    return (m_posNextMix << m_nBlockAlignShift);
}

//--------------------------------------------------------------------------;
//
// CMixSource::SetBytePosition
//
//--------------------------------------------------------------------------;
void CMixSource::SetBytePosition(int ibPosition)
{
    ENTER_MIXER_MUTEX();
    m_posNextMix = ibPosition >> m_nBlockAlignShift;

    if (MIXSOURCESTATE_STOPPED != m_kMixerState) {
        if (0 == (DSBMIXERSIGNAL_SETPOSITION & m_fdwMixerSignal)) {
            m_fdwMixerSignal |= DSBMIXERSIGNAL_SETPOSITION;
            // REMIND the following line should really be done in grace.cpp
            //  where we check for SETPOSITION flag set; and also, all those
            //  calls should call uMixNewBuffer, instead of looping/nonlooping.
            m_kMixerSubstate = MIXSOURCESUBSTATE_NEW;
        }
        SignalRemix();
    }

    m_pDsbNotes->SetPosition(m_posNextMix << m_nBlockAlignShift);

    LEAVE_MIXER_MUTEX();
}

//--------------------------------------------------------------------------;
//
// CMixSource::GetBytePosition1
//
// This is a version of GetBytePosition that maintains compatibility with
// DirectX 1 in which the reported play position is the actual write position,
// and the reported write position is one sample ahead of the actual write
// position.  This happenned in DirectX 1 only on wave emulation and therefore
// this function should be called only for wave emulated DirectSound buffers.
// 
//--------------------------------------------------------------------------;
void CMixSource::GetBytePosition1(int *pibPlay, int *pibWrite)
{
#ifdef Not_VxD
    if (MIXSOURCESTATE_STOPPED == m_kMixerState) {
        if (pibPlay)
            *pibPlay  = GetNextMixBytePosition();
        if (pibWrite)
            *pibWrite = GetNextMixBytePosition();
    } else {
        m_pMixer->GetBytePosition(this, pibPlay, pibWrite);
        if (pibPlay && pibWrite)
            *pibPlay = *pibWrite;
        if (pibWrite) {
            *pibWrite += 1 << m_nBlockAlignShift;
            if (*pibWrite >= m_cbBuffer) *pibWrite -= m_cbBuffer;
        }
    }
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::GetBytePosition
//
//--------------------------------------------------------------------------;
void CMixSource::GetBytePosition(int *pibPlay, int *pibWrite, int *pibMix)
{
#ifdef Not_VxD
    if (pibMix)
        *pibMix = GetNextMixBytePosition();
    if (MIXSOURCESTATE_STOPPED == m_kMixerState) {
        if (pibPlay)
            *pibPlay = GetNextMixBytePosition();
        if (pibWrite)
            *pibWrite = GetNextMixBytePosition();
    } else {
        m_pMixer->GetBytePosition(this, pibPlay, pibWrite);
    }
#else
    ASSERT(FALSE);
#endif
}

HRESULT CMixSource::SetNotificationPositions(int cNotes, LPCDSBPOSITIONNOTIFY paNotes)
{
#ifdef Not_VxD
    HRESULT hr;
    
    // Can only set notifications when buffer is stopped
    if (MIXSOURCESTATE_STOPPED != m_kMixerState) {
        DPF(0, "SetNotificationPositions called while playing");
        return DSERR_INVALIDCALL;
    }

    ENTER_MIXER_MUTEX();
    hr = m_pDsbNotes->SetNotificationPositions(cNotes, paNotes);
    LEAVE_MIXER_MUTEX();
    return hr;
#else
    ASSERT(FALSE);
    return E_NOTIMPL;
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::LoopingOn
//
//--------------------------------------------------------------------------;
void CMixSource::LoopingOn()
{
    m_hfFormat |= H_LOOP;
}

//--------------------------------------------------------------------------;
//
// CMixSource::LoopingOff
//
//--------------------------------------------------------------------------;
void CMixSource::LoopingOff()
{
    m_hfFormat &= ~H_LOOP;
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterOn
//
//--------------------------------------------------------------------------;
void CMixSource::FilterOn()
{
#ifdef Not_VxD
    m_pMixer->FilterOn(this);
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterOff
//
//--------------------------------------------------------------------------;
void CMixSource::FilterOff()
{
#ifdef Not_VxD
    m_pMixer->FilterOff(this);
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterClear
//
// This should be called only by the CMixer object.  It instructs the
// MixSource to clear its filter history.  That is, reset to initial state.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterClear()
{
    //DPF(3, "~`FC ");
    m_cSamplesInCache = 0;
    if (HasFilter() && !m_fFilterError) {
        ::FilterClear(*m_ppFirContextLeft);
        ::FilterClear(*m_ppFirContextRight);
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterChunkUpdate
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterChunkUpdate(int cSamples)
{
    if (HasFilter() && !m_fFilterError) {
        ::FilterChunkUpdate(*m_ppFirContextLeft, cSamples);
        ::FilterChunkUpdate(*m_ppFirContextRight, cSamples);
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterRewind
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterRewind(int cSamples)
{
    m_cSamplesInCache -= cSamples;
    //DPF(3, "~`FR%X %X ", cSamples, m_cSamplesInCache);
    ASSERT(0 == (m_cSamplesInCache % MIXER_REWINDGRANULARITY));
    
    if (HasFilter() && !m_fFilterError) {
        ::FilterRewind(*m_ppFirContextLeft, cSamples);
        ::FilterRewind(*m_ppFirContextRight, cSamples);
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterAdvance
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterAdvance(int cSamples)
{
    m_cSamplesInCache += cSamples;
    //DPF(3, "~`FA%X %X ", cSamples, m_cSamplesInCache);
    if (HasFilter() && !m_fFilterError) {
        ::FilterAdvance(*m_ppFirContextLeft, cSamples);
        ::FilterAdvance(*m_ppFirContextRight, cSamples);
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterPreprare
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterPrepare(int cMaxRewindSamples)
{
    BOOL fPrepared;
    
    //DPF(3, "~`FP ");
    m_cSamplesInCache = 0;
    fPrepared = TRUE;
    
    if (HasFilter()) {
        fPrepared = ::FilterPrepare(*m_ppFirContextLeft, cMaxRewindSamples);
        if (fPrepared) {
            fPrepared = ::FilterPrepare(*m_ppFirContextRight, cMaxRewindSamples);
            if (!fPrepared) {
                ::FilterUnprepare(*m_ppFirContextLeft);
            }
        }
    }
    
    m_fFilterError = !fPrepared;
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterUnprepare
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterUnprepare(void)
{
    if (HasFilter() && !m_fFilterError) {
        ::FilterUnprepare(*m_ppFirContextLeft);
        ::FilterUnprepare(*m_ppFirContextRight);
    }
    m_fFilterError = FALSE;
}

//--------------------------------------------------------------------------;
//
// CMixSource::SignalRemix
// 
//--------------------------------------------------------------------------;
void CMixSource::SignalRemix()
{
#ifdef Not_VxD
    if (IsPlaying() && !GetMute()) {
        m_pMixer->SignalRemix();
    }
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::HasNotifications
//
//--------------------------------------------------------------------------;
BOOL CMixSource::HasNotifications(void)
{
    ASSERT(m_pDsbNotes);
    return m_pDsbNotes->HasNotifications();
}

//--------------------------------------------------------------------------;
//
// CMixSource::NotifyToPosition
//
// Notes:
//      This function should be called only from user mode
//
//--------------------------------------------------------------------------;
void CMixSource::NotifyToPosition(IN int ibPosition,
                                  OUT PLONG pdtimeToNextNotify)
{
    int dbNextNotify;
    
    m_pDsbNotes->NotifyToPosition(ibPosition, &dbNextNotify);
    *pdtimeToNextNotify = MulDivRD(dbNextNotify >> m_nBlockAlignShift,
                                   1000, m_nFrequency);
}

//--------------------------------------------------------------------------;
//
// CMixSource::NotifyStop
//
// Notes:
//      This function should be called only from user mode
//
//--------------------------------------------------------------------------;
void CMixSource::NotifyStop(void)
{
    m_pDsbNotes->NotifyStop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\ks3d.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ks3d.h
 *  Content:    WDM/CSA 3D object class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/6/98      dereks  Created.
 *
 ***************************************************************************/

#ifdef NOKS
#error ks3d.h included with NOKS defined
#endif // NOKS

#ifndef __KS3D_H__
#define __KS3D_H__

#ifdef __cplusplus

#include "multi3d.h" // For the CMultiPan3dListener base class

// Forward declarations
class CKs3dListener;
class CKsHw3dObject;
class CKsIir3dObject;
class CKsItd3dObject;

class CKsSecondaryRenderWaveBuffer;

// KS 3D listener
class CKs3dListener
    : public CMultiPan3dListener
{
    friend class CKsHw3dObject;
    friend class CKsItd3dObject;

protected:
    CList<CKsHw3dObject *>  m_lstHw3dObjects;       // List of hardware 3D objects
    BOOL                    m_fAllocated;           // Is the HW 3D listener allocated?

public:
    CKs3dListener(void);
    virtual ~CKs3dListener(void);

public:
    // Listener location
    virtual DWORD GetListenerLocation(void);

protected:
    // C3dListener overrides
    virtual HRESULT UpdateAllObjects(DWORD);

    // Properties
    virtual HRESULT SetProperty(REFGUID, ULONG, LPCVOID, ULONG);
};

inline DWORD CKs3dListener::GetListenerLocation(void)
{
    return DSBCAPS_LOCSOFTWARE | DSBCAPS_LOCHARDWARE;
}

// KS ITD software 3D object
class CKsItd3dObject
    : public CItd3dObject
{
private:
    CKsSecondaryRenderWaveBuffer *  m_pBuffer;              // Owning buffer object
    HANDLE                          m_hPin;                 // Pin handle
    ULONG                           m_ulNodeId;             // 3D node id
    BOOL                            m_fMute;                // Are we muting at max distance?

public:
    CKsItd3dObject(CKs3dListener *, BOOL, BOOL, DWORD, CKsSecondaryRenderWaveBuffer *, HANDLE, ULONG);
    virtual ~CKsItd3dObject(void);

protected:
    // Commiting 3D data to the device
    virtual HRESULT Commit3dChanges(void);

    // The final 3D output sample rate
    virtual DWORD Get3dOutputSampleRate(void);

private:
    virtual void CvtContext(LPOBJECT_ITD_CONTEXT, PKSDS3D_ITD_PARAMS);
};

// KS IIR 3D object
class CKsIir3dObject
    : public CIir3dObject
{
private:
    CKsSecondaryRenderWaveBuffer *  m_pBuffer;              // Owning buffer object
    HANDLE                          m_hPin;                 // Pin handle
    ULONG                           m_ulNodeId;             // 3D node id
    ULONG                           m_ulNodeCpuResources;   // 3D node CPU resources
    KSDS3D_HRTF_COEFF_FORMAT        m_eCoeffFormat;         // 3d IIR coefficient format.
    BOOL                            m_fMute;                // Are we muting at max distance?
    FLOAT                           m_flPrevAttenuation;    // Previous Attnuation
    FLOAT                           m_flPrevAttDistance;    // Previous Distance Attenuation


public:
    CKsIir3dObject(CKs3dListener *, REFGUID, BOOL, BOOL, DWORD, CKsSecondaryRenderWaveBuffer *, HANDLE, ULONG, ULONG);
    virtual ~CKsIir3dObject(void);

public:
    virtual HRESULT Initialize(void);

protected:
    // Commiting 3D data to the device
    virtual HRESULT Commit3dChanges(void);

private:
    // Desired Filter Coefficient Format
    virtual HRESULT GetFilterMethodAndCoeffFormat(KSDS3D_HRTF_FILTER_METHOD*,KSDS3D_HRTF_COEFF_FORMAT*);
    virtual HRESULT InitializeFilters(KSDS3D_HRTF_FILTER_QUALITY, FLOAT, ULONG, ULONG, ULONG, ULONG);
};

// KS hardware 3D object
class CKsHw3dObject
    : public CHw3dObject
{
    friend class CKs3dListener;

protected:
    CKs3dListener *         m_pKsListener;          // KS listener
    LPVOID                  m_pvInstance;           // Instance identifier
    ULONG                   m_ulNodeId;             // 3D node identifier
    CKsSecondaryRenderWaveBuffer * m_pBuffer;       // Owning buffer

public:
    CKsHw3dObject(CKs3dListener *, BOOL, BOOL, LPVOID, ULONG, CKsSecondaryRenderWaveBuffer *);
    virtual ~CKsHw3dObject(void);

public:
    // Initialization
    virtual HRESULT Initialize(void);

    // Object calculation
    virtual HRESULT Recalc(DWORD, DWORD);

protected:
    // Properties
    virtual HRESULT SetProperty(REFGUID, ULONG, LPCVOID, ULONG);

private:
    // Object calculation
    virtual HRESULT RecalcListener(DWORD);
    virtual HRESULT RecalcObject(DWORD);
};

#endif // __cplusplus

#endif // __KS3D_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\kscap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kscap.cpp
 *  Content:    WDM/CSA Virtual Audio Device audio capture class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/6/98      dereks  Created.
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifdef NOKS
#error kscap.cpp being built with NOKS defined
#endif

#include "dsoundi.h"


/***************************************************************************
 *
 *  CKsCaptureDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::CKsCaptureDevice"

CKsCaptureDevice::CKsCaptureDevice()
    : CCaptureDevice(VAD_DEVICETYPE_KSCAPTURE),
      CKsDevice(VAD_DEVICETYPE_KSCAPTURE)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsCaptureDevice);

    m_paTopologyInformation = NULL;
    m_fSplitter = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsCaptureDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::~CKsCaptureDevice"

CKsCaptureDevice::~CKsCaptureDevice()
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsCaptureDevice);

    MEMFREE(m_paTopologyInformation);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::Initialize"

HRESULT CKsCaptureDevice::Initialize(CDeviceDescription* pDesc)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    ASSERT(CDevice::m_vdtDeviceType == pDesc->m_vdtDeviceType);
    ASSERT(CKsDevice::m_vdtKsDevType == pDesc->m_vdtDeviceType);

    // Initialize the base classes
    hr = CKsDevice::Initialize(pDesc);

    if(SUCCEEDED(hr))
    {
        hr = CCaptureDevice::Initialize(pDesc);
    }

    // Get topology information
    if(SUCCEEDED(hr))
    {
        m_paTopologyInformation = MEMALLOC_A(KSCDTOPOLOGY, m_ulPinCount);
        hr = HRFROMP(m_paTopologyInformation);
    }

    for(ULONG i = 0; i < m_ulValidPinCount && SUCCEEDED(hr); ++i)
    {
        hr = GetTopologyInformation(m_paTopologies[m_pulValidPins[i]],
                                    &m_paTopologyInformation[m_pulValidPins[i]]);
    }

    m_fSplitter = g_pDsAdmin->IsCaptureSplitterAvailable();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCCAPS structure with the capabilities of the device.
 *
 *  Arguments:
 *      LPDSCCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::GetCaps"

HRESULT CKsCaptureDevice::GetCaps
(
    LPDSCCAPS               pCaps
)
{
    HRESULT                 hr                  = DS_OK;
    KSDATARANGE_AUDIO       DataRange;
    KSDATARANGE_AUDIO       AggregateDataRange;
    PKSDATARANGE_AUDIO      pDataRange;

    DPF_ENTER();

    ASSERT(sizeof(*pCaps) == pCaps->dwSize);

    ZeroMemory(&AggregateDataRange, sizeof(AggregateDataRange));

    pDataRange = &AggregateDataRange;

    // Get the audio data ranges and number of pins for all valid pin IDs
    for(ULONG i = 0; i < m_ulValidPinCount; ++i)
    {
        // We're only looking for hardware pins
        if (FAILED(ValidatePinCaps(m_pulValidPins[i], DSCBCAPS_LOCHARDWARE)))
        {
            continue;
        }

        // Get audio datarange
        hr = KsGetPinPcmAudioDataRange(m_hDevice, m_pulValidPins[i], pDataRange, TRUE);

        if(FAILED(hr))
        {
            continue;
        }

        if (&AggregateDataRange == pDataRange)
        {
            pDataRange = &DataRange;
        }
        else
        {
            KsAggregatePinAudioDataRange(pDataRange, &AggregateDataRange);
        }
    }

    // Fill out caps structure
    if(SUCCEEDED(hr))
    {
        ZeroMemoryOffset(pCaps, pCaps->dwSize, sizeof(pCaps->dwSize));

        // Is the splitter installed?
        pCaps->dwFlags = m_fSplitter ? DSCCAPS_MULTIPLECAPTURE : 0;

        pCaps->dwFormats = KsGetSupportedFormats(&AggregateDataRange);
        pCaps->dwChannels = AggregateDataRange.MaximumChannels;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CreateBuffer
 *
 *  Description:
 *      Creates a wave buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPWAVEFORMATEX [in]: buffer format.
 *      LPVOID [in]: instance data
 *      CCaptureWaveBuffer ** [out]: receives pointer to new wave
 *                                           buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::CreateBuffer"

HRESULT CKsCaptureDevice::CreateBuffer
(
    DWORD                           dwFlags,
    DWORD                           dwBufferBytes,
    LPCWAVEFORMATEX                 pwfxFormat,
    CCaptureEffectChain *           pFXChain,
    LPVOID                          pvInstance,
    CCaptureWaveBuffer **           ppBuffer
)
{
    CKsCaptureWaveBuffer *          pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    #pragma warning(disable:4530)  // Disable the nag about compiling with -GX
    try
    {
        pBuffer = NEW(CKsCaptureWaveBuffer(this));
    }
    catch (...)
    {
        // This exception handler is silly, since it makes us leak the memory
        // allocated for CKsCaptureWaveBuffer above (which wasn't assigned to
        // pBuffer yet), and possibly also m_csSS and m_cs, which is exactly
        // what we don't want to do if we're low on memory in the first place.
        //
        // But InitializeCriticalSection is supposed to be fixed in Blackcomb
        // not to throw exceptions any more, so we can live with this for now.

        ASSERT(pBuffer == NULL);
        ASSERT(!"InitializeCriticalSection() threw an exception");
    }
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(dwFlags, dwBufferBytes, pwfxFormat, pFXChain);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CreateCapturePin
 *
 *  Description:
 *      Creates a pin.
 *
 *  Arguments:
 *      ULONG [in]: pin ID.
 *      LPWAVEFORMATEX [in]: pin format.
 *      LPHANDLE [out]: receives pin handle.
 *      PULONG [out]: receives pin ID.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::CreateCapturePin"

HRESULT
CKsCaptureDevice::CreateCapturePin
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    CCaptureEffectChain *   pFXChain,
    LPHANDLE                phPin,
    PULONG                  pulPinId
)
{
    PKSAUDIOPINDESC         pPinDesc    = NULL;
    ULONG                   ulNodeId    = NODE_UNINITIALIZED;
    HRESULT                 hr          = DSERR_NODRIVER;
    HANDLE                  hPin        = NULL;
    ULONG                   i;
    DPF_ENTER();

    // If no pin ID was specified, we'll try each pin ID until one succeeds
    if (-1 == ulPinId)
    {
        hr = DSERR_NODRIVER;
        for(i = 0; i < m_ulValidPinCount && FAILED(hr); ++i)
            hr = CreateCapturePin(m_pulValidPins[i], dwFlags, pwfxFormat, pFXChain, phPin, pulPinId);
    }
    else
    {
        // Validate that the pin ID is capable of creating this pin
        hr = ValidatePinCaps(ulPinId, dwFlags);

        if(SUCCEEDED(hr) && pFXChain)
        {
            // Validate that the pin ID is capable of creating this pin
            hr = m_paTopologies[ulPinId]->FindCapturePinFromEffectChain(NULL, NULL, pFXChain, pFXChain->GetFxCount()-1);
        }

        if(SUCCEEDED(hr) && pFXChain)
        {
            // Initialize the effect flags for the device
            i = 0;
            CNode<CCaptureEffect*>* pFxNode = pFXChain->m_fxList.GetListHead();

            while(SUCCEEDED(hr) && i<pFXChain->GetFxCount())
            {
                ulNodeId = pFxNode->m_data->m_ksNode.NodeId;

                if(IS_VALID_NODE(ulNodeId))
                {
                    if(SUCCEEDED(hr))
                    {
                        hr = KsSysAudioSelectGraph(m_hDevice, ulPinId, ulNodeId);

                        if(FAILED(hr))
                        {
                            DPF(DPFLVL_ERROR, "Unable to set SysAudio device instance");
                        }
                    }
                }
                pFxNode = pFxNode->m_pNext;
                i++;
            }
        }

        // Build the pin description
        if(SUCCEEDED(hr))
        {
            hr = KsBuildCapturePinDescription(ulPinId, pwfxFormat, &pPinDesc);
        }

        // Create the pin
        if(SUCCEEDED(hr))
        {
            hr = CreatePin(&pPinDesc->Connect, GENERIC_READ, KSSTATE_STOP, &hPin);
        }

        if(SUCCEEDED(hr) && pFXChain)
        {
            // Enable the effects in the kernel
            i = 0;
            CNode<CCaptureEffect*>* pFxNode = pFXChain->m_fxList.GetListHead();

            while(SUCCEEDED(hr) && i<pFXChain->GetFxCount())
            {
                ulNodeId = pFxNode->m_data->m_ksNode.NodeId;

                if(IS_VALID_NODE(ulNodeId))
                {
                    hr = pFxNode->m_data->m_pDMOProxy->InitializeNode(hPin, ulNodeId);

                    if(SUCCEEDED(hr))
                    {
                        hr = KsEnableTopologyNode(hPin, ulNodeId, TRUE);
                    }

                    if(SUCCEEDED(hr))
                    {
                        if(pFxNode->m_data->m_ksNode.CpuResources == KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU)
                        {
                            pFxNode->m_data->m_fxStatus = DSCFXR_LOCHARDWARE;
                        }
                        else
                        {
                            pFxNode->m_data->m_fxStatus = DSCFXR_LOCSOFTWARE;
                        }
                    }
                    else
                    {
                        DPF(DPFLVL_ERROR, "Unable to enable topology node %d", ulNodeId);
                    }
                }
                pFxNode = pFxNode->m_pNext;
                i++;
            }
        }

        // Transition the pin to the pause state
        if(SUCCEEDED(hr))
        {
            hr = KsTransitionState(hPin, KSSTATE_STOP, KSSTATE_PAUSE);
        }

        // Success
        if(SUCCEEDED(hr))
        {
            *phPin = hPin;

            if(pulPinId)
            {
                *pulPinId = pPinDesc->Connect.PinId;
            }
        }
        else
        {
            CLOSE_HANDLE(hPin);
        }

        // Clean up
        MEMFREE(pPinDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetTopologyInformation
 *
 *  Description:
 *      Gets topology information.
 *
 *  Arguments:
 *      CKsDeviceTopology * [in]: topology object.
 *      PKSCDTOPOLOGY [out]: receives topology information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::GetTopologyInformation"

HRESULT
CKsCaptureDevice::GetTopologyInformation
(
    CKsTopology *           pTopology,
    PKSCDTOPOLOGY           pInfo
)
{
    PKSTOPOLOGY_CONNECTION  pSrcConnection;
    HRESULT                 hr;

    DPF_ENTER();

    // Find topology nodes
    pSrcConnection = pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_SRC);

    // Fill in data about each node
    hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSrcConnection), &pInfo->SrcNode);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  ValidatePinCaps
 *
 *  Description:
 *      Validates that certain capabilities of the pin are implemented.
 *
 *  Arguments:
 *      ULONG [in]: pin ID.
 *      DWORD [in]: buffer flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::ValidatePinCaps"

HRESULT
CKsCaptureDevice::ValidatePinCaps
(
    ULONG                   ulPinId,
    DWORD                   dwFlags
)
{
    ULONG                   ulInvalidCpuResources   = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;
    HRESULT                 hr                      = DS_OK;

    DPF_ENTER();

    if(dwFlags & DSCBCAPS_LOCHARDWARE)
    {
        ulInvalidCpuResources = KSAUDIO_CPU_RESOURCES_HOST_CPU;
    }
    else if(dwFlags & DSCBCAPS_LOCSOFTWARE)
    {
        ulInvalidCpuResources = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
    }

    // Check required SRC resources
    if(SUCCEEDED(hr) && KSAUDIO_CPU_RESOURCES_UNINITIALIZED != ulInvalidCpuResources)
    {
        if(ulInvalidCpuResources == m_paTopologyInformation[ulPinId].SrcNode.CpuResources)
        {
            hr = DSERR_INVALIDCALL;
        }

#if 0 // 4/25/00 jstokes, I added this code because it may be needed but I don't currently think so.
        if(SUCCEEDED(hr) && !IS_VALID_NODE(m_paTopologyInformation[ulPinId].SrcNode.NodeId))
        {
            hr = DSERR_CONTROLUNAVAIL;
        }
#endif // 0
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CKsCaptureWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKsRenderDevice * [in]: parent device.
 *      LPVOID [in]: buffer instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::CKsCaptureWaveBuffer"

CKsCaptureWaveBuffer::CKsCaptureWaveBuffer(
    CKsCaptureDevice *pKsDevice)
    : CCaptureWaveBuffer(pKsDevice)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsCaptureWaveBuffer);

    // Initialize defaults
    m_pKsDevice = pKsDevice;

    ASSERT(NULL == m_hPin);
    ASSERT(0 == m_dwState);
    ASSERT(0 == m_fdwSavedState);

    ASSERT(0 == m_dwFlags);

    ASSERT(NULL == m_pEmCaptureDevice);
    ASSERT(NULL == m_pEmCaptureWaveBuffer);

    ASSERT(NULL == m_rgpksio);
    ASSERT(0 == m_cksio);
    ASSERT(0 == m_iksioDone);
    ASSERT(0 == m_cksioDropped);

    ASSERT(NULL == m_pBuffer);
    ASSERT(NULL == m_pBufferMac);
    ASSERT(NULL == m_pBufferNext);
    ASSERT(0 == m_cbBuffer);
    ASSERT(0 == m_cbRecordChunk);
    ASSERT(0 == m_cLoops);

    ASSERT(0 == m_iNote);
    ASSERT(0 == m_cNotes);
    ASSERT(NULL == m_paNotes);
    ASSERT(NULL == m_pStopNote);

    ASSERT(NULL == m_pwfx);
    ASSERT(NULL == m_pFXChain);

#ifdef DEBUG
    ASSERT(NULL == m_hEventStop);
    ASSERT(m_cIrpsSubmitted == 0);
    ASSERT(m_cIrpsReturned == 0);
#endif

#ifdef SHARED
    ASSERT(NULL == m_hEventThread);
    ASSERT(NULL == m_hEventAck);
    ASSERT(NULL == m_hThread);
    ASSERT(0 == m_dwSetState);
    ASSERT(0 == m_hrReturn);

    InitializeCriticalSection(&m_csSS);
#endif // SHARED

    ASSERT(NULL == m_rgpCallbackEvent);

    // FIXME: Do we still need these critical sections, since the DLL mutex also
    // prevents the EventSignalCallback from interfering with the other methods?

    m_fCritSectsValid = FALSE;
    InitializeCriticalSection(&m_cs);
    InitializeCriticalSection(&m_csPN);
    m_fCritSectsValid = TRUE;
    m_fFirstSubmittedIrp = TRUE;
    m_PinState = KSSTATE_STOP;

    ASSERT(NULL == m_pBufferProcessed);
    ASSERT(0 == m_dwCaptureCur);
    ASSERT(0 == m_dwCaptureLast);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsCaptureWaveBuffer
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::~CKsCaptureWaveBuffer"

CKsCaptureWaveBuffer::~CKsCaptureWaveBuffer()
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsCaptureWaveBuffer);

    if (!m_fCritSectsValid)
    {
        return;
    }

    // Free the pin
    if(m_hPin)
    {
        // Stop the buffer
        SetState(VAD_BUFFERSTATE_STOPPED);

        // Free any leftover notifications
        FreeNotificationPositions();

        // Close the pin
        CloseHandle(m_hPin);
    }

#ifdef DEBUG
    DPF(DPFLVL_MOREINFO, "IRPs submitted=%lu, returned=%lu", m_cIrpsSubmitted, m_cIrpsReturned);
    ASSERT(m_cIrpsSubmitted == m_cIrpsReturned);
#endif

#ifdef SHARED

    if (m_hThread)
    {
        // Sending special code to terminate thread
        SetStateThread(TERMINATE_STATE_THREAD);

        CloseHandle(m_hThread);
        CloseHandle(m_hEventThread);
        CloseHandle(m_hEventAck);
        m_hEventAck     = NULL;
        m_hEventThread  = NULL;
        m_hThread       = NULL;
    }

    DeleteCriticalSection(&m_csSS);

#endif // SHARED

    if(m_rgpCallbackEvent)
    {
        for(LONG i = 0; i < m_cksio; ++i)
        {
            if(m_rgpCallbackEvent[i])
            {
                m_pKsDevice->m_pEventPool->FreeEvent(m_rgpCallbackEvent[i]);
            }
        }

        MEMFREE(m_rgpCallbackEvent);
    }

    // Allocated for focus aware support
    if (NULL != m_pwfx)
    {
        MEMFREE(m_pwfx);
    }

    RELEASE(m_pEmCaptureWaveBuffer);
    RELEASE(m_pEmCaptureDevice);

    // Free the overlapped IO data
    MEMFREE(m_rgpksio);

    m_fCritSectsValid = FALSE;
    DeleteCriticalSection(&m_csPN);
    DeleteCriticalSection(&m_cs);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPWAVEFORMATEX [in]: buffer format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::Initialize"

HRESULT CKsCaptureWaveBuffer::Initialize
(
    DWORD                   dwFlags,
    DWORD                   dwBufferBytes,
    LPCWAVEFORMATEX         pwfxFormat,
    CCaptureEffectChain *   pFXChain
)
{
    DPF_ENTER();

    // Store the caps requested
    m_dwFlags = dwFlags;

    // Reset the First Submitted IRP flag.  Doing so will cause
    // the KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY flag to
    // be set on the first IRP submitted to the kernel.
    m_fFirstSubmittedIrp = TRUE;

    // Initialize the base class
    HRESULT hr = CCaptureWaveBuffer::Initialize(dwBufferBytes);

    // Try to create a pin on the device
    if(SUCCEEDED(hr))
    {
        // For focus aware buffers, we only allocate the device on Start
        if ((dwFlags & DSCBCAPS_FOCUSAWARE) && !m_pKsDevice->m_fSplitter)
        {
            // We'll need to save these...
            m_pwfx = CopyWfxAlloc(pwfxFormat);
            m_pFXChain = pFXChain;

#ifdef SHARED
            // Adding code to throw SetState to application thread
            m_hEventThread = CreateEvent(NULL, FALSE, FALSE, NULL);

            if (NULL == m_hEventThread)
            {
                DPF(DPFLVL_ERROR, "Unable to create event");
                hr = WIN32ERRORtoHRESULT(GetLastError());
            }

            if (SUCCEEDED(hr))
            {
                m_hEventAck = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (NULL == m_hEventAck)
                {
                    DPF(DPFLVL_ERROR, "Unable to create ack event");
                    CLOSE_HANDLE(m_hEventThread);
                    hr = WIN32ERRORtoHRESULT(GetLastError());
                }
            }

            if (SUCCEEDED(hr))
            {
                DWORD dwThreadID;
                m_hThread = CreateThread(NULL, 0, CKsCaptureWaveBuffer::StateThread, this, 0, &dwThreadID);

                if (NULL == m_hThread)
                {
                    DPF(DPFLVL_ERROR, "Unable to create thread");
                    CLOSE_HANDLE(m_hEventAck);
                    CLOSE_HANDLE(m_hEventThread);
                    hr = WIN32ERRORtoHRESULT(GetLastError());
                }
            }
#endif // SHARED

        }
        else // Not a focus-aware buffer, or the splitter is available:
        {
            // Try to create a hardware pin first
            hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCHARDWARE, pwfxFormat, pFXChain, &m_hPin, NULL);

            // If that failed, try to create a software pin
            if(FAILED(hr))
            {
                hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCSOFTWARE, pwfxFormat, pFXChain, &m_hPin, NULL);
            }

            // If that failed and the user asked that we try the mapper, create an emulated buffer,
            // as long as there is no FX chain.  (Emulated buffers can't have capture effects.)
            if(FAILED(hr) && (dwFlags & DSCBCAPS_WAVEMAPPED) && pFXChain == NULL)
            {
                hr = CreateEmulatedBuffer(m_pKsDevice->m_pKsDevDescription->m_uWaveDeviceId, dwFlags, dwBufferBytes, const_cast<LPWAVEFORMATEX>(pwfxFormat), pFXChain, &m_pEmCaptureDevice, &m_pEmCaptureWaveBuffer);

                // We don't need the KS capture buffer's memory since the emulated
                // buffer has its own
                if(SUCCEEDED(hr))
                {
                    RELEASE(m_pSysMemBuffer);
                    m_pSysMemBuffer = ADDREF(m_pEmCaptureWaveBuffer->m_pSysMemBuffer);
                }
            }
        }
    }

    if(SUCCEEDED(hr) && (NULL == m_pEmCaptureDevice))
    {
        // Make a copy of important info
        m_cbBuffer = m_pSysMemBuffer->GetSize();

        m_pBufferProcessed = m_pBufferNext = m_pBuffer = m_pSysMemBuffer->GetWriteBuffer();

        // Calculate the end of the buffer
        m_pBufferMac = m_pBuffer + m_cbBuffer;

        // Record Chunk should be 10 msec. long to match the capture buffer used in the kernel.
        m_cbRecordChunk = pwfxFormat->nAvgBytesPerSec / 100;

        // Round up to multiple of nBlockAlign
        DWORD cbSize = m_cbRecordChunk % pwfxFormat->nBlockAlign;
        if (cbSize)
        {
            m_cbRecordChunk += pwfxFormat->nBlockAlign - cbSize;
        }

        // Calculate number of blocks
        {
            DWORD   cbLastBlock;

            // calculate number of blocks of size m_cbRecordChunk bytes
            m_cksio = m_cbBuffer / m_cbRecordChunk;

            // See if we have a partial-sized block
            cbLastBlock = (m_cbBuffer % m_cbRecordChunk);
            if (0 != cbLastBlock)
            {
                ++m_cksio;
            }
        }

        // Create at most cksioDefault KSSTREAMIOs
        if(m_cksio > cksioDefault)
        {
            m_cksio = cksioDefault;
        }

        ASSERT(0 < m_cksio);

        m_cksioDropped = m_cksio;

        // Allocate space for KSSTREAMIO array, etc.
        m_rgpksio = MEMALLOC_A(KSSTREAMIO, m_cksio);
        m_rgpCallbackEvent = MEMALLOC_A(CCallbackEvent *, m_cksio);

        if ((NULL == m_rgpksio) || (NULL == m_rgpCallbackEvent))
        {
            RPF(DPFLVL_ERROR, "Unable to alloc KSSTREAMIOs");
            hr = DSERR_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            for (LONG i = 0; (i < m_cksio) && SUCCEEDED(hr); ++i)
            {
                hr = AllocCallbackEvent(m_pKsDevice->m_pEventPool, &m_rgpCallbackEvent[i]);
            }
        }

        if(SUCCEEDED(hr))
        {
            for (LONG i = 0; i < m_cksio; ++i)
            {
                m_rgpksio[i].Overlapped.hEvent = m_rgpCallbackEvent[i]->GetEventHandle();
            }
        }

#ifdef DEBUG
        if(SUCCEEDED(hr))
        {
            m_hEventStop = CreateGlobalEvent(NULL, TRUE);
            hr = HRFROMP(m_hEventStop);
        }
#endif

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Gets capabilities for the buffer.
 *
 *  Arguments:
 *      LPDSCBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::GetCaps"

HRESULT CKsCaptureWaveBuffer::GetCaps
(
    LPDSCBCAPS pDscbCaps
)
{
    DPF_ENTER();

    ASSERT(sizeof(*pDscbCaps) == pDscbCaps->dwSize);

    if(m_pEmCaptureWaveBuffer)
    {
        m_pEmCaptureWaveBuffer->GetCaps(pDscbCaps);
    }
    else
    {
        pDscbCaps->dwFlags = m_dwFlags;
        pDscbCaps->dwBufferBytes = m_cbBuffer;
        pDscbCaps->dwReserved = 0;
    }

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::GetState"

HRESULT CKsCaptureWaveBuffer::GetState
(
    LPDWORD                 pdwState
)
{
    HRESULT                 hr = DS_OK;

    DPF_ENTER();

    if(m_pEmCaptureWaveBuffer)
    {
        hr = m_pEmCaptureWaveBuffer->GetState(pdwState);
    }
    else
    {
        *pdwState = m_dwState & VAD_SETSTATE_MASK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  NotifyFocusChange
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::NotifyFocusChange"

HRESULT CKsCaptureWaveBuffer::NotifyFocusChange(void)
{
    HRESULT                 hr = DS_OK;

    DPF_ENTER();

    if (m_hEventFocus)
    {

#ifndef SHARED
        SetEvent(m_hEventFocus);
#else
        // Are we in the same process or in DDHelp?
        DWORD dwProcessID = GetOwnerProcessId();
        if (dwProcessID == GetCurrentProcessId())
        {
            SetEvent(m_hEventFocus);
        }
        else
        {
            HANDLE hEvent = GetLocalHandleCopy(m_hEventFocus, dwProcessID, FALSE);
            if (hEvent)
            {
                SetEvent(hEvent);
                CloseHandle(hEvent);
            }
            else
            {
                hr = WIN32ERRORtoHRESULT(GetLastError());
            }
        }
#endif // SHARED

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  StateThread
 *
 *  Description:
 *      Processes focus changes under Win9x
 *
 *  Arguments:
 *      LPVOID [in] : pointer to instance data
 *
 *  Returns:
 *      DWORD
 *
 ***************************************************************************/

#ifdef SHARED

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::StateThread"

DWORD WINAPI CKsCaptureWaveBuffer::StateThread(LPVOID pv)
{
    CKsCaptureWaveBuffer   *pThis = (CKsCaptureWaveBuffer *)pv;

    DPF_ENTER();

    // This thread just sits during the duration of the buffer, it processes
    // SetState() calls from DDHelp in application process.

    while (TRUE)
    {
        WaitObject(INFINITE, pThis->m_hEventThread);

        if (pThis->m_dwSetState == TERMINATE_STATE_THREAD)
        {
            SetEvent(pThis->m_hEventAck);
            break;
        }
        else
        {
            pThis->m_hrReturn = pThis->SetState(pThis->m_dwSetState);
            SetEvent(pThis->m_hEventAck);
        }
    }

    DPF_LEAVE_VOID();
    return 0;
}

#endif // SHARED


/***************************************************************************
 *
 *  SetStateThread
 *
 *  Description:
 *      Sets buffer state on application thread.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetStateThread"

HRESULT CKsCaptureWaveBuffer::SetStateThread
(
    DWORD                   dwState
)
{
    HRESULT                 hr = DS_OK;
    HANDLE                  hEventSend, hEventAck;

    DPF_ENTER();

    DWORD dwProcessID = GetOwnerProcessId();

#ifdef SHARED
    BOOL fMapped = (dwProcessID != GetCurrentProcessId());
    if (fMapped)
    {
        hEventSend = GetLocalHandleCopy(m_hEventThread, dwProcessID, FALSE);
        hEventAck  = GetLocalHandleCopy(m_hEventAck, dwProcessID, FALSE);
    }
    else
#endif // SHARED

    {
        hEventSend = m_hEventThread;
        hEventAck  = m_hEventAck;
    }

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    EnterCriticalSection(&m_csSS);

    m_dwSetState = dwState;
    m_hrReturn   = DS_OK;

    // "Sending" the message.
    ResetEvent(hEventAck);
    SetEvent(hEventSend);
    WaitObject(INFINITE, hEventAck);

    hr = m_hrReturn;

    LeaveCriticalSection(&m_csSS);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

#ifdef SHARED
    if (fMapped)
    {
        CloseHandle(hEventSend);
        CloseHandle(hEventAck);
    }
#endif // SHARED

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetState"

HRESULT CKsCaptureWaveBuffer::SetState
(
    DWORD           dwState
)
{
    HRESULT         hr          = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, VAD_SETSTATE_MASK));

#ifdef DEBUG_CAPTURE
    DPF(DPFLVL_INFO, "SetState(%s) called", StateName(dwState));
    DPF(DPFLVL_INFO, "  Current state: %s", StateName(m_dwState));
#endif // DEBUG_CAPTURE

#ifdef SHARED
    if (GetOwnerProcessId() != GetCurrentProcessId())
    {
        if (!m_pKsDevice->m_fSplitter)
        {
            hr = SetStateThread(dwState);
            DPF_LEAVE_HRESULT(hr);
            return hr;
        }
    }
#endif

    if (m_pEmCaptureWaveBuffer)
    {
        hr = m_pEmCaptureWaveBuffer->SetState(dwState);
    }
    else
    {
        //==========================================================//
        //                  Enter Critical section                  //
        //                                                          //
        ASSERT(m_fCritSectsValid);
        EnterCriticalSection(&m_cs);

        if (dwState != m_dwState)
        {
            if(dwState & VAD_BUFFERSTATE_STARTED) // Need to start capturing
            {
                if ((m_dwFlags & DSCBCAPS_FOCUSAWARE) && !m_pKsDevice->m_fSplitter)
                {
                    // Focus aware buffer
                    if (m_dwState & VAD_BUFFERSTATE_INFOCUS)
                    {
                        if (NULL == m_hPin)
                        {
                            // Try to create a hardware pin first
                            hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCHARDWARE, m_pwfx, m_pFXChain, &m_hPin, NULL);

                            // If that failed, try to create a software pin
                            if (FAILED(hr))
                                hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCSOFTWARE, m_pwfx, m_pFXChain, &m_hPin, NULL);
                        }

                        if (SUCCEEDED(hr))
                        {
                            if (m_dwState & VAD_BUFFERSTATE_STARTED)
                                hr = UpdateCaptureState(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
                            else
                                hr = SetCaptureState(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
                        }
                        else
                        {
                            // We can't seem to allocate the device; let's save its state for now
                            m_fdwSavedState = dwState;
                        }
                    }
                    else
                    {
                        // We're not starting the device because we don't have focus, but we're saving the state.
                        m_fdwSavedState = dwState;
                    }
                }
                else
                {
                    // Regular buffer
                    if (m_dwState & VAD_BUFFERSTATE_STARTED)
                        hr = UpdateCaptureState(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
                    else
                        hr = SetCaptureState(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
                }
            }
            else if (dwState == VAD_BUFFERSTATE_INFOCUS)
            {
                // Only focus-aware buffers start capturing when they gain focus
                if (m_dwFlags & DSCBCAPS_FOCUSAWARE)
                {
                    // If the capture focus state is changing...
                    if ((m_dwState & VAD_FOCUSFLAGS) != VAD_BUFFERSTATE_INFOCUS)
                    {
                        // Update m_dwState according to the dwState argument
                        m_dwState &= ~VAD_FOCUSFLAGS;
                        m_dwState |= VAD_BUFFERSTATE_INFOCUS;

                        // Notify the application of the focus change
                        NotifyFocusChange();

                        // If we were capturing previously, get our pin back if necessary
                        if (m_fdwSavedState & VAD_BUFFERSTATE_STARTED)
                        {
                            if (NULL == m_hPin)
                            {
                                for (UINT ii = 4; ii; ii--)
                                {
                                    // Try to create a hardware pin first
                                    hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCHARDWARE, m_pwfx, m_pFXChain, &m_hPin, NULL);

                                    // If that failed, try to create a software pin
                                    if (FAILED(hr))
                                        hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCSOFTWARE, m_pwfx, m_pFXChain, &m_hPin, NULL);

                                    if (SUCCEEDED(hr))
                                        break;

                                    DPF(DPFLVL_ERROR, "CreateCapturePin failed for FA buffer; retrying after 20ms");
                                    Sleep(20);
                                }
                            }
                            hr = SetCaptureState(MAKEBOOL(m_fdwSavedState & VAD_BUFFERSTATE_LOOPING));
                        }
                    }
                }
            }
            else if (dwState & (VAD_BUFFERSTATE_OUTOFFOCUS | VAD_BUFFERSTATE_LOSTCONSOLE))
            {
                // Only focus-aware buffers stop capturing when they lose focus
                if (m_dwFlags & DSCBCAPS_FOCUSAWARE)
                {
                    // If the capture focus state is changing...
                    if ((m_dwState & VAD_FOCUSFLAGS) != dwState)
                    {
                        // Update m_dwState according to the dwState argument
                        m_dwState &= ~VAD_FOCUSFLAGS;
                        m_dwState |= dwState;

                        // Notify the application of the focus change
                        NotifyFocusChange();

                        // If there's no splitter OR we've lost the console, stop capturing
                        if (!m_pKsDevice->m_fSplitter || (dwState & VAD_BUFFERSTATE_LOSTCONSOLE))
                        {
                            if(m_dwState & VAD_BUFFERSTATE_STARTED)
                            {
                                m_fdwSavedState = m_dwState; // Save the buffer state
                                hr = SetStopState(TRUE);
                            }
                            // It's only necessary to actually release the pin if there's no splitter
                            if (!m_pKsDevice->m_fSplitter)
                            {
                                CLOSE_HANDLE(m_hPin);
                            }
                        }
                    }
                }
            }
            else // VAD_BUFFERSTATE_STOPPED case; need to stop capturing
            {
                ASSERT(dwState == VAD_BUFFERSTATE_STOPPED);  // By elimination

                if(m_dwState & VAD_BUFFERSTATE_STARTED)
                {
                    hr = SetStopState(TRUE);

                    if (DSCBCAPS_FOCUSAWARE & m_dwFlags)
                        CLOSE_HANDLE(m_hPin);
                }
                m_fdwSavedState = 0;
            }
        }

        LeaveCriticalSection(&m_cs);
        //                                                          //
        //                 Leave Critical Section                   //
        //==========================================================//
    }

#ifdef DEBUG_CAPTURE
    DPF(DPFLVL_INFO, "  Final state: %s", StateName(m_dwState));
    DPF(DPFLVL_INFO, "  (Saved state: %s)", StateName(m_fdwSavedState));
#endif // DEBUG_CAPTURE

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Gets the current capture/read positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives capture cursor position.
 *      LPDWORD [out]: receives read cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::GetCursorPosition"

HRESULT CKsCaptureWaveBuffer::GetCursorPosition
(
    LPDWORD                 pdwCapturePosition,
    LPDWORD                 pdwReadPosition
)
{
    HRESULT                 hr                  = DS_OK;

    DPF_ENTER();

    if(m_pEmCaptureWaveBuffer)
    {
        hr = m_pEmCaptureWaveBuffer->GetCursorPosition(pdwCapturePosition, pdwReadPosition);
    }
    else
    {
        KSAUDIO_POSITION    Position;
        DWORD               dwRead;

        dwRead = ((m_dwCaptureCur + m_dwCaptureLast) % m_cbBuffer);

        if(VAD_BUFFERSTATE_STARTED & m_dwState)
        {
            // Focus aware and stopped?
            ASSERT(NULL != m_hPin);

            hr =
                KsGetProperty
                (
                    m_hPin,
                    KSPROPSETID_Audio,
                    KSPROPERTY_AUDIO_POSITION,
                    &Position,
                    sizeof(KSAUDIO_POSITION)
                );

            if(SUCCEEDED(hr))
            {
                ASSERT(Position.WriteOffset <= MAX_DWORD);
                ASSERT(Position.PlayOffset <= MAX_DWORD);

                if(pdwCapturePosition)
                {
                    *pdwCapturePosition = (m_dwCaptureLast + (DWORD)Position.PlayOffset) % m_cbBuffer;
                }
            }
            else
            {
                DPF(DPFLVL_ERROR, "Unable to get cursor position");
            }
        }
        else
        {
            if(pdwCapturePosition)
            {
                *pdwCapturePosition = dwRead;
            }
        }

        if(SUCCEEDED(hr) && pdwReadPosition)
        {
            *pdwReadPosition = dwRead;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetCaptureState
 *
 *  Description:
 *      Sets the buffer to a "capture" state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to capture looped.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetCaptureState"

HRESULT CKsCaptureWaveBuffer::SetCaptureState(BOOL fLoop)
{
    HRESULT                 hr          = DS_OK;
    LONG                    iksio       = 0;
    HANDLE                  hPin        = m_hPin;

    DPF_ENTER();

    ASSERT(!m_pEmCaptureWaveBuffer);

#ifdef SHARED
    if (GetOwnerProcessId() != GetCurrentProcessId())
        hPin = GetLocalHandleCopy(m_hPin, GetOwnerProcessId(), FALSE);
#endif

    while ((m_cksioDropped > 0) &&
           (fLoop || (m_cLoops == 0)))
    {
        PKSSTREAMIO pksio = m_rgpksio + iksio;

        hr = SubmitKsStreamIo(pksio, hPin);
        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "SubmitKsStreamIo failed");
            break;
        }

        iksio += 1;
        ASSERT(iksio <= m_cksio);
        InterlockedDecrement(&m_cksioDropped);
    }

#ifdef DEBUG
    if(m_cksioDropped != 0)
    {
        ASSERT(!(VAD_BUFFERSTATE_LOOPING & m_dwState));
    }
#endif

    // Start capturing noise
    if(SUCCEEDED(hr))
    {
        hr = KsSetState(hPin, KSSTATE_RUN);
    }

#ifdef SHARED
    CLOSE_HANDLE(hPin);
#endif

    // Update our status
    if(SUCCEEDED(hr))
    {
        m_PinState = KSSTATE_RUN;
        m_dwState &= VAD_FOCUSFLAGS; // Preserve focus flags
        m_dwState |= VAD_BUFFERSTATE_STARTED;

        if(fLoop)
        {
            m_dwState |= VAD_BUFFERSTATE_LOOPING;
        }

        // update to next KSSTREAMIO expected
        m_iksioDone = 0;

        // Remember last valid position
        m_dwCaptureLast += m_dwCaptureCur;

        m_dwCaptureCur = 0;
    }
    else
    {
        DPF(DPFLVL_ERROR, "Failed to transition to KSSTATE_RUN; cancelling pending IRPs");
        SetStopState(TRUE);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CancelAllPendingIRPs
 *
 *  Description:
 *      Cancels all the pending READ IRPs
 *
 *  Arguments:
 *      BOOL [in]: TRUE to wait for all submitted IRPs.
 *      HANDLE [in]: Optional pin handle to use instead of m_hPin.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::CancelAllPendingIRPs"

HRESULT CKsCaptureWaveBuffer::CancelAllPendingIRPs(BOOL fWait, HANDLE hPin)
{
    HRESULT hr;

    DPF_ENTER();

    // If the calling process isn't our owning process, hPin is our pin handle
    // mapped to the calling process, so we should use it instead of m_hPin
    hPin = (hPin ? hPin : m_hPin);

    // DPF(DPFLVL_MOREINFO, "Calling KsResetState(hPin=%08x, KSRESET_BEGIN)", hPin);
    hr = KsResetState(hPin, KSRESET_BEGIN);

    // Wait for all the submitted KSSTREAMIOs to finish
    if(SUCCEEDED(hr) && fWait)
    {
        DWORD   iksio;
        DWORD   iksioOrig;
        DWORD   dwWait;

        iksioOrig = iksio = m_iksioDone;

        do
        {
            if(m_rgpksio[iksio].fPendingIrp)
            {
                DPF(DPFLVL_MOREINFO, "KSIO #%d at %p: Data=%p FrExt=%lu DataUsed=%lu Flags=0x%lx Event=0x%lx",
                    iksio,
                    m_rgpksio + iksio,
                    m_rgpksio[iksio].Header.DataUsed,
                    m_rgpksio[iksio].Header.FrameExtent,
                    m_rgpksio[iksio].Header.Data,
                    m_rgpksio[iksio].Header.OptionsFlags,
                    m_rgpCallbackEvent[iksio]->GetEventHandle());

                dwWait = m_rgpCallbackEvent[iksio]->Wait(INFINITE);
                if(WAIT_OBJECT_0 == dwWait)
                {
                    EventSignalCallback(m_rgpCallbackEvent[iksio]);
                    ASSERT(!m_rgpksio[iksio].fPendingIrp);
#ifdef DEBUG
                    ASSERT(WAIT_OBJECT_0 != m_rgpCallbackEvent[iksio]->Wait(0));
#endif
                }
            }

            iksio = (iksio + 1) % m_cksio;
        } while (iksio != iksioOrig);

        ASSERT(m_cksioDropped == m_cksio);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsResetState(hPin, KSRESET_END);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  UpdateCaptureState
 *
 *  Description:
 *      Changes the loop flag on a capturing buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to capture looped.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::UpdateCaptureState"

HRESULT CKsCaptureWaveBuffer::UpdateCaptureState(BOOL fLoop)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    ASSERT(m_dwState & VAD_BUFFERSTATE_STARTED);

    // Do we need to submit any read IRPs?
    if(fLoop != MAKEBOOL(VAD_BUFFERSTATE_LOOPING & m_dwState))
    {
        m_dwState |= DSCBSTATUS_STOPPING | DSCBSTATUS_PAUSE;

        // Pause the pin
        hr = KsSetState(m_hPin, KSSTATE_PAUSE);

        if(SUCCEEDED(hr))
        {
            // Update our current notion of the pin state
            m_PinState = KSSTATE_PAUSE;

            hr = CancelAllPendingIRPs(TRUE);

#ifdef DEBUG
            if(SUCCEEDED(hr))
            {
                ASSERT(WAIT_OBJECT_0 == WaitObject(0, m_hEventStop));
            }
#endif
        }

        // Update the buffer state flag
        if(SUCCEEDED(hr))
        {
            m_dwState &= VAD_FOCUSFLAGS;  // Preserve focus flags
            m_dwState |= VAD_BUFFERSTATE_STOPPED | DSCBSTATUS_STOPPED | DSCBSTATUS_STOPPING;
        }
        else
        {
            m_dwState &= ~(DSCBSTATUS_STOPPING | DSCBSTATUS_STOPPED | DSCBSTATUS_PAUSE);
        }

        // Resubmit the read IRP
        if(SUCCEEDED(hr))
        {
            hr = SetCaptureState(fLoop);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetStopState
 *
 *  Description:
 *      Sets the buffer to a "stop" state.
 *
 *  Arguments:
 *      BOOL [in] : if TRUE, wait for all submitted IRPs.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetStopState"

HRESULT CKsCaptureWaveBuffer::SetStopState(BOOL fWait)
{
    HRESULT                 hr          = DS_OK;
    HANDLE                  hPin        = m_hPin;

    DPF_ENTER();

    ASSERT(!m_pEmCaptureWaveBuffer);
    ASSERT((m_PinState == KSSTATE_PAUSE) || (m_dwState & VAD_BUFFERSTATE_STARTED));

    m_dwState |= DSCBSTATUS_STOPPING;

#ifdef SHARED
    if (GetOwnerProcessId() != GetCurrentProcessId())
        hPin = GetLocalHandleCopy(m_hPin, GetOwnerProcessId(), FALSE);
#endif

    if (m_PinState == KSSTATE_RUN)
    {
        // Pause the pin
        hr = KsSetState(hPin, KSSTATE_PAUSE);

        // Update our internal pin state;
        if (SUCCEEDED(hr))
        {
            m_PinState = KSSTATE_PAUSE;
        }
    }

    // Cancel all the KSSTREAMIOs
    if(SUCCEEDED(hr))
    {
        hr = CancelAllPendingIRPs(fWait, hPin);

        ASSERT(SUCCEEDED(hr) && "Failed to CancelAllPendingIRPs");

#ifdef DEBUG
        if(SUCCEEDED(hr) && fWait)
        {
            ASSERT(WAIT_OBJECT_0 == WaitObject(0, m_hEventStop));
        }
#endif

    }

#ifdef DEBUG
    DPF(DPFLVL_MOREINFO, "IRPs submitted=%lu, returned=%lu", m_cIrpsSubmitted, m_cIrpsReturned);
    ASSERT(m_cIrpsSubmitted == m_cIrpsReturned);
#endif

#ifdef SHARED
    CLOSE_HANDLE(hPin);
#endif

    // Update the buffer state flag
    if(SUCCEEDED(hr))
    {
        // Preserving focus flags...
        m_dwState &= VAD_FOCUSFLAGS;
        m_dwState |= VAD_BUFFERSTATE_STOPPED | DSCBSTATUS_STOPPING | DSCBSTATUS_STOPPED;
    }
    else
    {
        m_dwState &= ~(VAD_BUFFERSTATE_STOPPED | DSCBSTATUS_STOPPING | DSCBSTATUS_STOPPED);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetNotificationPositions"

HRESULT CKsCaptureWaveBuffer::SetNotificationPositions
(
    DWORD                   dwCount,
    LPCDSBPOSITIONNOTIFY    paNotes
)
{
    LPDSBPOSITIONNOTIFY     paNotesCopy = NULL;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    if(m_pEmCaptureWaveBuffer)
    {
        hr = m_pEmCaptureWaveBuffer->SetNotificationPositions(dwCount, paNotes);
    }
    else
    {
        //==========================================================//
        //                  Enter Critical section                  //
        //                                                          //
        ASSERT(m_fCritSectsValid);
        EnterCriticalSection(&m_csPN);

        // Make a local copy of the notifications
        if(paNotes)
        {
            paNotesCopy = MEMALLOC_A_COPY(DSBPOSITIONNOTIFY, dwCount, paNotes);
            hr = HRFROMP(paNotesCopy);
        }

        // Disable any current events
        if(SUCCEEDED(hr))
        {
            hr = FreeNotificationPositions();
        }

        // Save the new events
        if(SUCCEEDED(hr))
        {
            m_paNotes = paNotesCopy;
            m_cNotes = dwCount;
        }

        // Set new position notifications
        if(SUCCEEDED(hr) && (0 != dwCount) &&
           (DSBPN_OFFSETSTOP == m_paNotes[dwCount-1].dwOffset))
        {
            // We won't actually pass the stop event down to KS, but
            // instead will keep our own copy of it
            ASSERT(!m_pStopNote);
            m_pStopNote = &m_paNotes[dwCount-1];
        }

        LeaveCriticalSection(&m_csPN);
        //                                                          //
        //                 Leave Critical Section                   //
        //==========================================================//
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FreeNotificationPositions
 *
 *  Description:
 *      Removes all position notifications and frees allocated resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::FreeNotificationPositions"

HRESULT CKsCaptureWaveBuffer::FreeNotificationPositions(void)
{
    DPF_ENTER();

    ASSERT(!m_pEmCaptureWaveBuffer);

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    // Clean up
    MEMFREE(m_paNotes);

    m_pStopNote = NULL;
    m_cNotes = 0;

    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SignalNotificationPositions"

void CKsCaptureWaveBuffer::SignalNotificationPositions(PKSSTREAMIO pksio)
{
    DPF_ENTER();

    // grab critical section for position notify handling
    //

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    // Scan for any position notifies that need to be signaled
    if (m_cNotes)
    {
        DWORD   iNoteOld = m_iNote;
        DWORD   dwBufferStart = PtrDiffToUlong((LPBYTE)pksio->Header.Data - m_pBuffer);
        DWORD   dwBufferEnd = dwBufferStart + pksio->Header.DataUsed;

        DPF(DPFLVL_MOREINFO, "Checking NP:  %8.8ld - %8.8ld (%8.8lX - %8.8lX)",
            dwBufferStart, dwBufferEnd, dwBufferStart, dwBufferEnd);

        // Is there a position.notify within the start.end of this
        // captured data?
        // Is the current position.notify to be signaled on Stop?
        //
        while (((m_paNotes[m_iNote].dwOffset >= dwBufferStart) &&
                (m_paNotes[m_iNote].dwOffset < dwBufferEnd)) ||
               (DSBPN_OFFSETSTOP == m_paNotes[m_iNote].dwOffset))
        {
            // Only signal if not for Stop pos.notify
            if(DSBPN_OFFSETSTOP != m_paNotes[m_iNote].dwOffset)
            {
                DPF(DPFLVL_INFO, "Signalled:  %8.8ld (%08X) [%d]",
                    m_paNotes[m_iNote].dwOffset, m_paNotes[m_iNote].dwOffset, m_iNote);
                try
                {
                    SetEvent(m_paNotes[m_iNote].hEventNotify);
                } catch (...) {}
            }

            // go on to the next pos.notify
            m_iNote = (m_iNote + 1) % m_cNotes;

            // Infinite loop?
            if(m_iNote == iNoteOld)
            {
                break;
            }
        }
    }

    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EventSignalCallback
 *
 *  Description:
 *      Callback function called when a pin's IO completion event is
 *      signalled.  This function is called from within the callback event
 *      pool's lock, so we get thread synchronization for free.
 *
 *  Arguments:
 *      CCallbackEvent * [in]: callback event.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::EventSignalCallback"

void CKsCaptureWaveBuffer::EventSignalCallback(CCallbackEvent *pEvent)
{
    PKSSTREAMIO pksio;
    LONG        iksioExpect;
    LONG        iksioCurrent;
    LONG        cksioToProcess;
    HANDLE      hEvent;
    LONG        i;

    DPF_ENTER();

    ASSERT(!m_pEmCaptureWaveBuffer);

    iksioExpect = m_iksioDone;

    // WaitForMultipleObjects seems to return the first
    // signaled event in the array.
    //
    // So if we're expecting the fifth IRP, the first IRP
    // may have completed as well and WFMO will say that the
    // first IRP has finished even though 5...8 have also
    // finished.
    //
    // So we check for the expected IRP.
    // If we see it, then we're fine.
    // Otherwise, we have to determine what position
    // that the signaled event maps to. Then
    // we have to process all the IRPs from the
    // expected IRP to the IRP that we were told about.

    // This is the signaled handle that
    // WaitForMultipleObjects returned
    hEvent = pEvent->GetEventHandle();

    // Is this the expected event?
    if(hEvent == m_rgpCallbackEvent[iksioExpect]->GetEventHandle())
    {
        i = iksioExpect;
    }
    else
    {
        // Find the position for the signaled event in our list
        for (i = 0; i < m_cksio; ++i)
        {
            if (hEvent == m_rgpCallbackEvent[i]->GetEventHandle())
            {
                break;
            }
        }
    }

    // We've never seen this event before
    ASSERT(m_cksio != i);

    // Remember the current signaled IRP
    iksioCurrent = i;

    // Determine number of IRPs to process
    if (iksioCurrent >= iksioExpect)
    {
        cksioToProcess = iksioCurrent - iksioExpect + 1;
    }
    else
    {
        cksioToProcess = (m_cksio - iksioExpect) + iksioCurrent + 1;
    }

    DPF(DPFLVL_MOREINFO, "ToProcess:%d Current:%d Expected:%d (event %lX)", cksioToProcess, iksioCurrent, iksioExpect, hEvent);

    // Can only have 1...m_cksio IRPs to process
    ASSERT((cksioToProcess > 0) && (cksioToProcess <= m_cksio));

    while (cksioToProcess > 0)
    {
        pksio = m_rgpksio + m_iksioDone;

        DPF(DPFLVL_MOREINFO, "Got KSIO #%d at 0x%p: Data=0x%p FrExt=%lu DataUsed=%lu Flags=0x%lx Event=0x%lX",
            m_iksioDone,
            pksio,
            pksio->Header.Data,
            pksio->Header.FrameExtent,
            pksio->Header.DataUsed,
            pksio->Header.OptionsFlags,
            pksio->Overlapped.hEvent);

        DWORD dwWait = WaitObject(10000, pksio->Overlapped.hEvent);
        ASSERT(WAIT_OBJECT_0 == dwWait);
#ifdef DEBUG
        ++m_cIrpsReturned;
#endif

        if (pksio->fPendingIrp && !(DSCBSTATUS_STOPPING & m_dwState))
        {
#if 0
            ASSERT(0 != pksio->Header.DataUsed);
#endif
        }

        // If the user calls Stop, (which grabs the DLL mutex), KS
        // may signal that an IRP has completed and so the EventPool's
        // worker thread will try to process the IRP associated with the
        // signalled event. Before the worker thread calls our
        // EventSignalCallback method, it tries to grab the DLL mutex.
        // If we're already processing the Stop method, we will "complete"
        // all the IRPs before the worker thread can grab the mutex and
        // tell us about the completed IRP it knows about.
        //
        // So we need to check that fPendingIRP is TRUE in case
        // we've already seen this IRP before.
        //
        if ((0 != pksio->Header.DataUsed) &&
            pksio->fPendingIrp &&
            !(DSCBSTATUS_STOPPED & m_dwState))
        {
            BOOL    fEndOfBuffer = FALSE;

            ASSERT(WAIT_OBJECT_0 == m_rgpCallbackEvent[m_iksioDone]->Wait(0));
            ASSERT(TRUE == pksio->fPendingIrp);

            // update number of recorded bytes
            m_dwCaptureCur += pksio->Header.DataUsed;

#if 0
            ASSERT(m_pBufferProcessed == (LPBYTE)pksio->Header.Data);
#endif
            m_pBufferProcessed += pksio->Header.DataUsed;
            if(m_pBufferProcessed >= m_pBufferMac)
            {
                m_pBufferProcessed = m_pBuffer;
                fEndOfBuffer = TRUE;
            }

            SignalNotificationPositions(pksio);

            // Transition buffer to stop state:
            // if the capture buffer end has been reached AND
            // if the buffer is non-LOOPING AND
            // if the buffer isn't in the middle of stopping
            //
            // Do this after the position notifications since STOP notification
            // is after any buffer-offset notification.
            //
            if(fEndOfBuffer &&
               (0 == (VAD_BUFFERSTATE_LOOPING & m_dwState)) &&
               (0 == (DSCBSTATUS_STOPPING & m_dwState)))
            {
                //==========================================================//
                //                  Enter Critical section                  //
                //                                                          //
                ASSERT(m_fCritSectsValid && "NT bug 306910 - notify dsound team");
                EnterCriticalSection(&m_cs);

                SetStopState(FALSE);

                LeaveCriticalSection(&m_cs);
                //                                                          //
                //                 Leave Critical Section                   //
                //==========================================================//

                ASSERT(DSCBSTATUS_STOPPING & m_dwState);
                ASSERT((m_cksioDropped+1) == m_cksio);
            }

            pksio->Header.DataUsed = 0;
        }

        pksio->fPendingIrp = FALSE;
        m_rgpCallbackEvent[m_iksioDone]->Reset();

        // We're stopping, let's drop everything
        if(DSCBSTATUS_STOPPING & m_dwState)
        {
Drop:
            InterlockedIncrement(&m_cksioDropped);

            // when all KSSTREAMIOs have been dropped
            if(m_cksioDropped == m_cksio)
            {
                // set the next point in the data buffer to capture to
                m_pBufferNext = m_pBufferProcessed;
                m_cLoops = 0;
#ifdef DEBUG
                SetEvent(m_hEventStop);
#endif
                // Notify user that we've stopped
                if (!(DSCBSTATUS_PAUSE & m_dwState))
                {
                    NotifyStop();
                }
            }
            else if (m_cksioDropped > m_cksio)
            {
                ASSERT(FALSE);
            }
        }
        else
        {
            ASSERT(VAD_BUFFERSTATE_STARTED & m_dwState);

            // If we're LOOPING or we haven't reached the end of the buffer yet
            // then put the KSSTREAMIO back on to the queue with a new position
            // in the buffer, etc.
            BOOL fAddToQueue = (VAD_BUFFERSTATE_LOOPING & m_dwState) ||
                               (m_pBufferNext > (LPBYTE)pksio->Header.Data);

            if (fAddToQueue)
            {
                HRESULT hr;
                BOOL    fDrop;

                //==========================================================//
                //                  Enter Critical section                  //
                //                                                          //
                ASSERT(m_fCritSectsValid && "NT bug 306910 - notify dsound team");
                EnterCriticalSection(&m_cs);

                if ((DSCBSTATUS_STOPPED | DSCBSTATUS_STOPPING) & m_dwState)
                {
                    fDrop = TRUE;
                }
                else
                {
                    hr = SubmitKsStreamIo(pksio);
                    fDrop = FALSE;
                }

                LeaveCriticalSection(&m_cs);
                //                                                          //
                //                 Leave Critical Section                   //
                //==========================================================//

                if (fDrop)
                {
                    goto Drop;
                }

                // What can we do if there's an error?
                ASSERT(SUCCEEDED(hr));
            }
            else
            {
                InterlockedIncrement(&m_cksioDropped);

                // If no KSSTREAMIOs are submitted then if the user
                // starts capturing again, we submit the KSSTREAMIOs
                // from the beginning
                if (m_cksio == m_cksioDropped)
                {
#ifdef DEBUG
                    if (!(VAD_BUFFERSTATE_LOOPING & m_dwState))
                        ASSERT(m_cLoops > 0);
                    SetEvent(m_hEventStop);
#endif
                    // Notify user that we've stopped
                    NotifyStop();
                }
                else if (m_cksioDropped > m_cksio)
                {
                    ASSERT(FALSE);
                }
            }
        }

        m_iksioDone = (m_iksioDone + 1) % m_cksio;

        cksioToProcess -= 1;
    }

    if (iksioCurrent >= m_iksioDone)
    {
        ASSERT(iksioCurrent == (m_cksio - 1));
        ASSERT(0 == m_iksioDone);
    }
    else
    {
        ASSERT(iksioCurrent == (m_iksioDone-1));
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  NotifyStop
 *
 *  Description:
 *      Sets any events that are supposed to set when capturing stops
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      None.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::NotifyStop"

void CKsCaptureWaveBuffer::NotifyStop(void)
{
    DPF_ENTER();

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    // Signal any STOP pos.notifies - only one allowed
    //
    if (m_pStopNote)
    {
        try
        {
            SetEvent(m_pStopNote->hEventNotify);
        }
        catch (...) {}
    }

    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SubmitKsStreamIo
 *
 *  Description:
 *      Submits a Read IRP to KS.
 *
 *  Arguments:
 *      PKSSTREAMIO [in] : KSSTREAMIO to submit.
 *      HANDLE [in]: Optional pin handle to use instead of m_hPin.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SubmitKsStreamIo"

HRESULT CKsCaptureWaveBuffer::SubmitKsStreamIo
(
    PKSSTREAMIO                     pksio,
    HANDLE                          hPin
)
{
    HRESULT     hr;
    DWORD       dwFlags = 0;

    DPF_ENTER();

    // If the calling process isn't our owning process, hPin is our pin handle
    // mapped to the calling process, so we should use it instead of m_hPin
    hPin = (hPin ? hPin : m_hPin);

    ULONG cbBuffer = m_cbRecordChunk;

    // does capture buffer extend beyond end of buffer?
    //
    // If the amount left at end of buffer is less than threshold,
    // make this IRP extend to the end of the buffer so we don't
    // end up submitting a tiny IRP next time
    if (m_pBufferMac < (m_pBufferNext + m_cbRecordChunk))
    {
        cbBuffer = PtrDiffToUlong(m_pBufferMac - m_pBufferNext);
    }

    // Submit the IR
    hr = KsReadStream(hPin, m_pBufferNext, cbBuffer, dwFlags, pksio);

    if(SUCCEEDED(hr))
    {
        ASSERT((LPBYTE)pksio->Header.Data == m_pBufferNext);
        ASSERT((m_pBufferNext + pksio->Header.FrameExtent) <= m_pBufferMac);

        m_pBufferNext += cbBuffer;

#ifdef DEBUG
        ++m_cIrpsSubmitted;
#endif

        // Wraparound?
        if (m_pBufferNext >= m_pBufferMac)
        {
            m_pBufferNext = m_pBuffer;
            m_cLoops += 1;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CreateEmulatedBuffer
 *
 *  Description:
 *      Opens the emulated capture device and buffer with the given
 *      parameters.  This function is used strictly as a backup.
 *
 *  Arguments:
 *      UINT [in]: waveIn device ID.
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      CEmCaptureDevice ** [out]: receives device pointer.
 *      CEmCaptureWaveBuffer ** [out]: receives buffer pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::CreateEmulatedBuffer"

HRESULT CKsCaptureWaveBuffer::CreateEmulatedBuffer
(
    UINT                            uDeviceId,
    DWORD                           dwFlags,
    DWORD                           dwBufferBytes,
    LPCWAVEFORMATEX                 pwfx,
    CCaptureEffectChain *           pFXChain,
    CEmCaptureDevice **             ppDevice,
    CEmCaptureWaveBuffer **         ppBuffer
)
{
    CEmCaptureDevice *              pDevice     = NULL;
    CEmCaptureWaveBuffer *          pBuffer     = NULL;
    HRESULT                         hr          = DS_OK;
    CObjectList<CDeviceDescription> lstDrivers;
    CNode<CDeviceDescription *> *   pNode;

    DPF_ENTER();

    ASSERT(DSCBCAPS_WAVEMAPPED & dwFlags);

    // Create an emulated device using the same waveIn device ID as the one
    // the KS device is using.
    hr = g_pVadMgr->EnumDrivers(VAD_DEVICETYPE_EMULATEDCAPTURE, 0, &lstDrivers);

    if(SUCCEEDED(hr))
    {
        for(pNode = lstDrivers.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(uDeviceId == pNode->m_data->m_uWaveDeviceId)
            {
                break;
            }
        }

        if (!pNode)
        {
            hr = DSERR_NODRIVER;
        }
    }

    if(SUCCEEDED(hr))
    {
        pDevice = NEW(CEmCaptureDevice);
        hr = HRFROMP(pDevice);
    }

    if(SUCCEEDED(hr))
    {
        hr = pDevice->Initialize(pNode->m_data);
    }

    // Try and create the buffer
    if(SUCCEEDED(hr))
    {
        hr = pDevice->CreateBuffer(dwFlags, dwBufferBytes, pwfx, pFXChain, NULL, (CCaptureWaveBuffer **)&pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        *ppDevice = pDevice;
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
        ABSOLUTE_RELEASE(pDevice);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\kshlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kshlp.cpp
 *  Content:    WDM/CSA helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/5/98      dereks  Created.
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifdef NOKS
#error kshlp.cpp being built with NOKS defined
#endif

#include "dsoundi.h"
#include <devioctl.h>
#include <tchar.h>      // For _tcsrchr()

ULONG g_ulKsIoctlCount = 0;
ULONG g_ulWdmVersion = WDM_NONE;


/***************************************************************************
 *
 *  KsQueryWDMVersion
 *
 *  Description:
 *      Determine the WDM version available by looking at the OS version
 *      and set the global g_ulWdmVersion appropriately.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsQueryWdmVersion"

void
KsQueryWdmVersion()
{
    DPF_ENTER();

    OSVERSIONINFO   OsVersion;

    OsVersion.dwOSVersionInfoSize = sizeof(OsVersion);
    GetVersionEx(&OsVersion);

    g_ulWdmVersion = WDM_NONE;

    switch (OsVersion.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_WINDOWS:
            // Running on Win9x. GetVersionEx on Win9x puts the version
            // in the high word of the build number
            OsVersion.dwBuildNumber &= 0x0000FFFF;

            if (OsVersion.dwMajorVersion > 4)
            {
                // We will have at least 1.1 on future Win9x versions
                g_ulWdmVersion = WDM_1_1;
            }
            else if (OsVersion.dwMajorVersion == 4)
            {
                // Less than 10 is Win95 (4.0.950) or some OSR of it, which
                // therefore has no WDM support
                if (OsVersion.dwMinorVersion == 10)
                {
                    // Some build of Windows 98
                    if (OsVersion.dwBuildNumber == 1998)
                    {
                        // Windows 98 gold, WDM 1.0
                        g_ulWdmVersion = WDM_1_0;
                    }
                    else if (OsVersion.dwBuildNumber > 1998)
                    {
                        // Windows 98 SE or Millenium, WDM 1.1
                        g_ulWdmVersion = WDM_1_1;
                    }
                }
                else if (OsVersion.dwMinorVersion > 10)
                {
                    // Some later version we don't know about now.
                    g_ulWdmVersion = WDM_1_1;
                }
            }
            break;

        case VER_PLATFORM_WIN32_NT:
            // NT is easy since WDM 1.0 never shipped on it.
            // 5.0 and above have at least 1.1, before has nothing.
            if (OsVersion.dwMajorVersion >= 5)
            {
                g_ulWdmVersion = WDM_1_1;
            }
            break;

        default:
            // Windows CE or some other thing that we don't understand.
            break;
    }

    switch (g_ulWdmVersion)
    {
        case WDM_NONE:
            DPF(DPFLVL_INFO, "No WDM on this platform");
            break;

        case WDM_1_0:
            DPF(DPFLVL_INFO, "WDM Version 1.0 on this platform");
            break;

        case WDM_1_1:
            DPF(DPFLVL_INFO, "WDM Version 1.1 or better on this platform");
            break;

        default:
            ASSERT(!"Unknown platform - can't determine WDM version");
            break;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CKsDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     VADDEVICETYPE [in]: device type.
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::CKsDevice"

CKsDevice::CKsDevice
(
    VADDEVICETYPE           vdtDeviceType
)
    : m_vdtKsDevType(vdtDeviceType)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsDevice);

    // Initialize defaults
    m_pKsDevDescription = NULL;
    m_hDevice = NULL;
    m_ulDeviceId = MAX_ULONG;
    m_ulPinCount = 0;
    m_ulValidPinCount = 0;
    m_pulValidPins = NULL;
    m_paTopologies = NULL;
    m_pEventPool = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::~CKsDevice"

CKsDevice::~CKsDevice(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsDevice);

    // Workaround for an unexplained stress failure in which we enter
    // this destructor TWICE (the second time with m_ulPinCount == -1):
    if (LONG(m_ulPinCount) > 0 && m_paTopologies)
        while(m_ulPinCount--)
            RELEASE(m_paTopologies[m_ulPinCount]);

    MEMFREE(m_pulValidPins);
    MEMFREE(m_paTopologies);
    RELEASE(m_pEventPool);
    CLOSE_HANDLE(m_hDevice);
    RELEASE(m_pKsDevDescription);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumDrivers
 *
 *  Description:
 *      Creates a list of driver GUIDs that can be used to initialize this
 *      device.
 *
 *  Arguments:
 *      CList* [in/out]: CList object that will be filled with DRVNAME
 *                       structures.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::EnumDrivers"

HRESULT
CKsDevice::EnumDrivers
(
    CObjectList<CDeviceDescription> *   plstDrivers
)
{
    LPTSTR                              pszName         = NULL;
    LPTSTR                              pszPath         = NULL;
    LPTSTR                              pszInterface    = NULL;
    ULONG                               cDevices        = 0;
    ULONG                               ulDeviceId;
    ULONG                               cPins;
    CDeviceDescription *                pDesc           = NULL;
    HRESULT                             hr;

    DPF_ENTER();

    // Open the system audio device
    hr = OpenSysAudioDevice(-1);

    // Get the total count of devices that SAD knows about
    if(SUCCEEDED(hr))
    {
        hr = GetDeviceCount(&cDevices);
    }

    // LIMITATION: We can't support more than 0xFF WDM devices,
    // because we pack the device ID into a byte member of a GUID.
    if(SUCCEEDED(hr))
    {
        cDevices = NUMERIC_CAST(cDevices, BYTE);
    }

    // Examine each device to determine if it suits our needs
    for(ulDeviceId = 0; (ulDeviceId < cDevices) && SUCCEEDED(hr); ulDeviceId++)
    {
        // Reopen the system audio device
        hr = OpenSysAudioDevice(ulDeviceId);

        // Get the count of pins on this device
        if(SUCCEEDED(hr))
        {
            hr = GetPinCount(ulDeviceId, &cPins);
        }

        // Get the count of usable pins
        if(SUCCEEDED(hr))
        {
            hr = KsEnumDevicePins(m_hDevice, IS_CAPTURE_VAD(m_vdtKsDevType), NULL, cPins, &cPins);
        }

        if(SUCCEEDED(hr) && !cPins)
        {
            continue;
        }

        // Create the device description
        if(SUCCEEDED(hr))
        {
            pDesc = NEW(CDeviceDescription(m_vdtKsDevType));
            hr = HRFROMP(pDesc);
        }

        // Get the device GUID
        if(SUCCEEDED(hr))
        {
            g_pVadMgr->GetDriverGuid(m_vdtKsDevType, (BYTE)ulDeviceId, &pDesc->m_guidDeviceId);
        }

        // Get the device interface path
        if(SUCCEEDED(hr))
        {
            hr = KsGetDeviceInterfaceName(m_hDevice, ulDeviceId, &pszInterface);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strInterface = pszInterface;
        }

        // Get the device's friendly name
        if(SUCCEEDED(hr))
        {
            hr = KsGetDeviceFriendlyName(m_hDevice, ulDeviceId, &pszName);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strName = pszName;
        }

        // Get the driver filename
        if(SUCCEEDED(hr))
        {
            hr = KsGetDeviceDriverPathAndDevnode(pszInterface, &pszPath, &pDesc->m_dwDevnode);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strPath = pszPath;
        }

        // Get the device's wave id
        if(SUCCEEDED(hr))
        {
#ifdef WINNT
            GetWaveDeviceIdFromInterface(pszInterface, IS_CAPTURE_VAD(m_vdtKsDevType), &pDesc->m_uWaveDeviceId);
#else // WINNT
            GetWaveDeviceIdFromDevnode(pDesc->m_dwDevnode, IS_CAPTURE_VAD(m_vdtKsDevType), &pDesc->m_uWaveDeviceId);
#endif // WINNT
        }

        // Success
        if(SUCCEEDED(hr))
        {
            hr = HRFROMP(plstDrivers->AddNodeToList(pDesc));
        }

        // Clean up
        MEMFREE(pszInterface);
        MEMFREE(pszName);
        MEMFREE(pszPath);
        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: device description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::Initialize"

HRESULT
CKsDevice::Initialize
(
    CDeviceDescription *    pDesc
)
{
    BYTE                    bData;
    HRESULT                 hr = DS_OK;

    DPF_ENTER();
    ASSERT(m_vdtKsDevType == pDesc->m_vdtDeviceType);

    if (pDesc == NULL)
        hr = DSERR_INVALIDPARAM;

    if (SUCCEEDED(hr))
    {
        // Save a copy of the device description
        m_pKsDevDescription = ADDREF(pDesc);

        // Get the device ID from the driver GUID
        g_pVadMgr->GetDriverDataFromGuid(m_vdtKsDevType, pDesc->m_guidDeviceId, &bData);
        m_ulDeviceId = bData;

        // Open the system audio device
        hr = OpenSysAudioDevice(m_ulDeviceId);
    }

    // Get the count of pins on this device
    if(SUCCEEDED(hr))
    {
        hr = GetPinCount(m_ulDeviceId, &m_ulPinCount);
    }

    // Build the usable pin list
    if(SUCCEEDED(hr))
    {
        hr = KsEnumDevicePins(m_hDevice, IS_CAPTURE_VAD(m_vdtKsDevType), &m_pulValidPins, m_ulPinCount, &m_ulValidPinCount);
    }

    // Allocate memory for topology objects
    if(SUCCEEDED(hr))
    {
        ASSERT(m_ulPinCount);
        m_paTopologies = MEMALLOC_A(CKsTopology *, m_ulPinCount);
        hr = HRFROMP(m_paTopologies);
    }

    // Get device topology
    for(ULONG i = 0; i < m_ulValidPinCount && SUCCEEDED(hr); i++)
    {
        m_paTopologies[m_pulValidPins[i]] = NEW(CKsTopology(m_hDevice, m_ulPinCount, m_pulValidPins[i]));
        hr = HRFROMP(m_paTopologies[m_pulValidPins[i]]);

        if(SUCCEEDED(hr))
        {
            hr = m_paTopologies[m_pulValidPins[i]]->Initialize(IS_CAPTURE_VAD(m_vdtKsDevType) ? KSPIN_DATAFLOW_CAPTURE : KSPIN_DATAFLOW_RENDER);
        }
    }

    // Create the event pool
    if(SUCCEEDED(hr))
    {
        m_pEventPool = NEW(CMultipleCallbackEventPool(IS_RENDER_VAD(m_vdtKsDevType), 1));
        hr = HRFROMP(m_pEventPool);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pEventPool->Initialize();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCertification
 *
 *  Description:
 *      Returns the certification status of the driver.
 *
 *  Arguments:
 *      LPDWORD [out]: receives certification status.
 *      BOOL [in]: whether we're called from GetCaps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::GetCertification"

HRESULT
CKsDevice::GetCertification
(
    LPDWORD                 pdwCertification,
    BOOL                    fGetCaps
)
{
    DPF_ENTER();

    // Millenium bug #127578
    // Disabling only for KS for GetCaps.

    if (fGetCaps)
    {
        *pdwCertification = VERIFY_CERTIFIED;
    }
    else
    {
        *pdwCertification = KsGetDriverCertification(m_pKsDevDescription->m_strInterface);
    }

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  CreatePin
 *
 *  Description:
 *      Creates a pin on the device.
 *
 *  Arguments:
 *      PKSPIN_CONNECT [in/out]: pin description.  On exit, the PinId member
 *                               of this structure will be filled in.
 *      ACCESS_MASK [in]: access mask.
 *      KSSTATE [in]: pin state.
 *      LPHANDLE [out]: receives pin handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::CreatePin"

HRESULT
CKsDevice::CreatePin
(
    PKSPIN_CONNECT          pConnect,
    ACCESS_MASK             dwAccessMask,
    KSSTATE                 nState,
    LPHANDLE                phPin
)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(-1 == pConnect->PinId)
    {
        hr = DSERR_NODRIVER;
        for(ULONG i = 0; i < m_ulValidPinCount && FAILED(hr); i++)
        {
            pConnect->PinId = m_pulValidPins[i];
            hr = CreatePin(pConnect, dwAccessMask, nState, phPin);
        }
    }
    else
    {
        hr = KsCreateAudioPin(m_hDevice, pConnect, dwAccessMask, nState, phPin);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenSysAudioDevice
 *
 *  Description:
 *      Initializes the system audio device.
 *
 *  Arguments:
 *      ULONG [in]: device instance to use, or -1 for none.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::OpenSysAudioDevice"

HRESULT
CKsDevice::OpenSysAudioDevice
(
    ULONG                   ulDeviceId
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Open the system audio device
    if(SUCCEEDED(hr) && !m_hDevice)
    {
        hr = KsOpenSysAudioDevice(&m_hDevice);

        if(SUCCEEDED(hr) && IS_RENDER_VAD(m_vdtKsDevType))
        {
            if(!MakeHandleGlobal(&m_hDevice))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }
    }

    // Set the device instance
    if(SUCCEEDED(hr) && -1 != ulDeviceId)
    {
        hr = KsSetSysAudioDeviceInstance(m_hDevice, ulDeviceId);

        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "Unable to set SysAudio device instance");
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDeviceCount
 *
 *  Description:
 *      Gets the count of devices managed by SysAudio.
 *
 *  Arguments:
 *      PULONG [out]: receives device count.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::GetDeviceCount"

HRESULT
CKsDevice::GetDeviceCount
(
    PULONG                  pulDeviceCount
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetSysAudioProperty(m_hDevice, KSPROPERTY_SYSAUDIO_DEVICE_COUNT, 0, pulDeviceCount, sizeof(*pulDeviceCount));

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "SysAudio manages %lu devices", *pulDeviceCount);
    }
    else
    {
        DPF(DPFLVL_ERROR, "Can't get SysAudio device count");
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetPinCount
 *
 *  Description:
 *      Gets the count of pins managed by a given device.
 *
 *  Arguments:
 *      ULONG [in]: device id.  It's assumed that this device has already
 *                  been selected as the device instance.
 *      PULONG [out]: receives pin count.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::GetPinCount"

HRESULT
CKsDevice::GetPinCount
(
    ULONG                   ulDeviceId,
    PULONG                  pulPinCount
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetPinProperty(m_hDevice, KSPROPERTY_PIN_CTYPES, 0, pulPinCount, sizeof(*pulPinCount));

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Device %lu sprouts %lu pins", ulDeviceId, *pulPinCount);
    }
    else
    {
        DPF(DPFLVL_ERROR, "Can't get count of pin types");
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CKsTopology
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: pin id.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::CKsTopology"

CKsTopology::CKsTopology
(
    HANDLE                  hDevice,
    ULONG                   ulPinCount,
    ULONG                   ulPinId
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsTopology);

    // Initialize defaults
    m_hDevice = hDevice;
    m_ulPinCount = ulPinCount;
    m_ulPinId = ulPinId;
    m_paNodeItems = NULL;
    m_paNodes = NULL;
    m_paConnectionItems = NULL;
    m_paConnections = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsTopology
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::~CKsTopology"

CKsTopology::~CKsTopology(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsTopology);

    // Free memory
    MEMFREE(m_paNodeItems);
    MEMFREE(m_paConnectionItems);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      KSPIN_DATAFLOW [in]: device dataflow.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::Initialize"

HRESULT
CKsTopology::Initialize
(
    KSPIN_DATAFLOW          DataFlow
)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Get the array of node GUIDs
    hr = KsGetMultipleTopologyProperties(m_hDevice, KSPROPERTY_TOPOLOGY_NODES, &m_paNodeItems);

    if(SUCCEEDED(hr))
    {
        m_paNodes = (LPGUID)(m_paNodeItems + 1);
    }

    // Get the array of connections
    if(SUCCEEDED(hr))
    {
        hr = KsGetMultipleTopologyProperties(m_hDevice, KSPROPERTY_TOPOLOGY_CONNECTIONS, &m_paConnectionItems);
    }

    if(SUCCEEDED(hr))
    {
        m_paConnections = (PKSTOPOLOGY_CONNECTION)(m_paConnectionItems + 1);
    }

    // Reorder the connections
    if(SUCCEEDED(hr))
    {
        hr = OrderConnectionItems(DataFlow);
    }
#if 0  // Breaks with AEC
    // Remove any connections that have multiple destination nodes
    if(SUCCEEDED(hr))
    {
        hr = RemovePanicConnections();
    }
#endif // 0

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetNextConnection
 *
 *  Description:
 *      Gets the next connection for a given pin topology.
 *
 *  Arguments:
 *      PKSTOPOLOGY_CONNECTION [in]: current connection.
 *
 *  Returns:
 *      PKSTOPOLOGY_CONNECTION: Next connection, or NULL.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::GetNextConnection"

PKSTOPOLOGY_CONNECTION
CKsTopology::GetNextConnection
(
    PKSTOPOLOGY_CONNECTION  pConnection
)
{
    KSTOPOLOGY_CONNECTION   Next;

    DPF_ENTER();

    if(pConnection)
    {
        Next.FromNode = pConnection->ToNode;
        // The new FromNodePin is most likely the exclusive OR of the
        // current ToNodePin with 1.  For two pin filters, this means
        // 1->0.  For Aec, this means 3->2 for capture or 1->0 for playback.
        // This will need to further special cased if we decide to handle
        // muxes or demuxes.
        Next.FromNodePin = pConnection->ToNodePin ^ 1;
    }
    else
    {
        Next.FromNode = KSFILTER_NODE;
        Next.FromNodePin = m_ulPinId;
    }

    Next.ToNode = NODE_WILDCARD;
    Next.ToNodePin = NODE_WILDCARD;

    pConnection = KsFindConnection(m_paConnections, m_paConnectionItems->Count, &Next);

    DPF_LEAVE(pConnection);
    return pConnection;
}


/***************************************************************************
 *
 *  FindControlConnection
 *
 *  Description:
 *      Finds a topology connection based on the control id.
 *
 *  Arguments:
 *      PKSTOPOLOGY_CONNECTION [in]: connection index to start with.
 *      PKSTOPOLOGY_CONNECTION [in]: connection index to stop at.
 *      REFGUID [in]: control id.
 *
 *  Returns:
 *      PKSTOPOLOGY_CONNECTION: connection pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindControlConnection"

PKSTOPOLOGY_CONNECTION
CKsTopology::FindControlConnection
(
    PKSTOPOLOGY_CONNECTION  pStartConnection,
    PKSTOPOLOGY_CONNECTION  pEndConnection,
    REFGUID                 ControlId
)
{
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;

    DPF_ENTER();

    // Initialize the starting connection point
    if(pStartConnection)
    {
        pConnection = pStartConnection;
    }
    else
    {
        pConnection = GetNextConnection(NULL);
    }

    // Find the connection that matches the control id
    while(pConnection && pConnection != pEndConnection)
    {
        if(GetControlFromNodeId(pConnection->ToNode) == ControlId)
        {
            break;
        }

        pConnection = GetNextConnection(pConnection);
    }

    // If we hit the end, return failure
    if(pConnection == pEndConnection)
    {
        pConnection = NULL;
    }

    DPF_LEAVE(pConnection);
    return pConnection;
}


/***************************************************************************
 *
 *  OrderConnectionItems
 *
 *  Description:
 *      Reorders the connection structure based on the device dataflow.
 *
 *  Arguments:
 *      KSPIN_DATAFLOW [in]: dataflow.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::OrderConnectionItems"

HRESULT
CKsTopology::OrderConnectionItems
(
    KSPIN_DATAFLOW          DataFlow
)
{
    ULONG                   i;

    DPF_ENTER();

    if(KSPIN_DATAFLOW_OUT == DataFlow)
    {
        for(i = 0; i < m_paConnectionItems->Count; i++)
        {
            SwapValues(&m_paConnections[i].FromNode, &m_paConnections[i].ToNode);
            SwapValues(&m_paConnections[i].FromNodePin, &m_paConnections[i].ToNodePin);
        }
    }

    DPF_LEAVE(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  RemovePanicConnections
 *
 *  Description:
 *      Removes any connections that have multiple "to" destinations.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::RemovePanicConnections"

HRESULT
CKsTopology::RemovePanicConnections
(
    void
)
{
    const ULONG             cFilterConnections          = m_ulPinCount;
    const ULONG             cNodeConnections            = m_paNodeItems->Count;
    const ULONG             cConnectionItems            = m_paConnectionItems->Count;
    PULONG                  pacFilterConnectionCounts   = NULL;
    PULONG                  pacNodeConnectionCounts     = NULL;
    ULONG                   cCount;
    HRESULT                 hr;
    ULONG                   i;

    DPF_ENTER();

    pacFilterConnectionCounts = MEMALLOC_A(ULONG, cFilterConnections);
    hr = HRFROMP(pacFilterConnectionCounts);

    if(SUCCEEDED(hr))
    {
        pacNodeConnectionCounts = MEMALLOC_A(ULONG, cNodeConnections);
        hr = HRFROMP(pacNodeConnectionCounts);
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < cConnectionItems; i++)
        {
            if(KSFILTER_NODE == m_paConnections[i].FromNode)
            {
                ASSERT(m_paConnections[i].FromNodePin < cFilterConnections);
                pacFilterConnectionCounts[m_paConnections[i].FromNodePin]++;
            }
            else
            {
                ASSERT(m_paConnections[i].FromNode < cNodeConnections);
                pacNodeConnectionCounts[m_paConnections[i].FromNode]++;
            }
        }

        for(i = 0; i < cConnectionItems; i++)
        {
            if(KSFILTER_NODE == m_paConnections[i].FromNode)
            {
                ASSERT(m_paConnections[i].FromNodePin < cFilterConnections);
                cCount = pacFilterConnectionCounts[m_paConnections[i].FromNodePin];
            }
            else
            {
                ASSERT(m_paConnections[i].FromNode < cNodeConnections);
                cCount = pacNodeConnectionCounts[m_paConnections[i].FromNode];
            }

            if(cCount > 1)
            {
                // DPF(DPFLVL_MOREINFO, "Removing panic connection %lu", i);  // Too noisy
                m_paConnections[i].ToNode = -1;
                m_paConnections[i].ToNodePin = -1;
            }
        }
    }

    MEMFREE(pacFilterConnectionCounts);
    MEMFREE(pacNodeConnectionCounts);

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindNodeIdsFromControl
 *
 *  Description:
 *      Searches the Node table for all nodes which match
 *      the control GUID.  JStokes added the method
 *      for finding all instances of the AEC node since
 *      FindControlConnection fails to find it given
 *      the bypass path in the topology around the
 *      node on the render side.  This function may be removed
 *      if the topology is parsed smarter or SysAudio
 *      provides additional helper functions in the future.
 *
 *  Arguments:
 *      REFGUID [in]: control.
 *      PULONG  [out]: number of nodes found which match the control GUID
 *      PPULONG [out]: pointer to the array containing node ids
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindNodeIdsFromControl"

HRESULT
CKsTopology::FindNodeIdsFromControl
(
    REFGUID     gControl,
    PULONG      pCount,
    PULONG*     ppNodes
)
{
    ULONG       i;
    ULONG       j;
    HRESULT     hr;

    DPF_ENTER();

    // Count all instances of nodes which match the Control GUID.
    *pCount = 0;
    for(i = 0; i < m_paNodeItems->Count; i++)
    {
        if(gControl == m_paNodes[i])
        {
            (*pCount)++;
        }
    }

    // Allocate the array to hold the node numbers
    *ppNodes = MEMALLOC_A(ULONG, *pCount);
    hr = HRFROMP(*ppNodes);

    // Fill the array with the Node IDs which match
    // the control GUID.
    if(SUCCEEDED(hr))
    {
        j = 0;
        for(i = 0; i < m_paNodeItems->Count; i++)
        {
            if(gControl == m_paNodes[i])
            {
                (*ppNodes)[j++] = i;
            }
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindNodeIdFromEffectDesc
 *
 *  Description:
 *      Searches the Node table for all nodes which match
 *      the control GUID.  JStokes added the method
 *      for finding all instances of the AEC node since
 *      FindControlConnection fails to find it given
 *      the bypass path in the topology around the
 *      node on the render side.  This function may be removed
 *      if the topology is parsed smarter or SysAudio
 *      provides additional helper functions in the future.
 *
 *  Arguments:
 *      REFGUID [in]: control.
 *      PULONG  [out]: number of nodes found which match the control GUID
 *      PPULONG [out]: pointer to the array containing node ids
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindNodeIdFromEffectDesc"

HRESULT
CKsTopology::FindNodeIdFromEffectDesc
(
    HANDLE      hPin,
    CCaptureEffect* pDSCEffect,
    PULONG      pNodeId
)
{
    DWORD       i;
    HRESULT     hr = DSERR_UNSUPPORTED;
    HRESULT     hrTemp;
    ULONG       ulCpuResources;

    DPF_ENTER();

    // Find all instances of nodes which match the Control GUID.
    for(i = 0; i < m_paNodeItems->Count; i++)
    {
        if(pDSCEffect->m_fxDescriptor.guidDSCFXClass == m_paNodes[i])
        {
            // Do the CPU Resources match?
            hrTemp = KsGetCpuResources(hPin, i, &ulCpuResources);

            // FIXME: Why do we ignore ulCpuResources here?

            // Does the Instance GUID match?
            if(SUCCEEDED(hrTemp))
            {
                //hrTemp = KsGetAlgorithmInstance(hPin, i, guidInstance);
            }

            // If CPU resources and Instance GUID match, then break
            if(SUCCEEDED(hrTemp))
            {
                *pNodeId = i;
                hr = DS_OK;
            }
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  VerifyCaptureFxCpuResources
 *
 *  Description:
 *      Searches the Node table for all nodes which match
 *      the control GUID.  JStokes added the method
 *      for finding all instances of the AEC node since
 *      FindControlConnection fails to find it given
 *      the bypass path in the topology around the
 *      node on the render side.  This function may be removed
 *      if the topology is parsed smarter or SysAudio
 *      provides additional helper functions in the future.
 *
 *  Arguments:
 *      REFGUID [in]: control.
 *      PULONG  [out]: number of nodes found which match the control GUID
 *      PPULONG [out]: pointer to the array containing node ids
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::VerifyCaptureFxCpuResources"

BOOL
CKsTopology::VerifyCaptureFxCpuResources
(
    ULONG   ulFlags,
    ULONG   ulCpuResources
)
{
    BOOL fOk = FALSE;  // Assume the flags do not match the CPU resources

    DPF_ENTER();

    if(ulCpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU)
    {
        if(!(ulFlags & DSCFX_LOCHARDWARE))
        {
            fOk = TRUE;
        }
    }
    else
    {
        if(!(ulFlags & DSCFX_LOCSOFTWARE))
        {
            fOk = TRUE;
        }
    }

    DPF_LEAVE(fOk);
    return fOk;
}


/***************************************************************************
 *
 *  FindCapturePinFromEffectChain
 *
 *  Description:
 *      Searches the Connection and Node lists to find a
 *      capture pin that can support the desired
 *      capture FX chain.  This is a recursive routine.
 *
 *  Arguments:
 *   PKSTOPOLOGY_CONNECTION [in]: starting connection to search
 *   PKSTOPOLOGY_CONNECTION [in]: ending connection to search
 *   CCaptureEffectChain *  [in]: FX chain to match
 *   ULONG                  [in]: current effect in the chain to match.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindCapturePinFromEffectChain"

HRESULT
CKsTopology::FindCapturePinFromEffectChain
(
    PKSTOPOLOGY_CONNECTION  pStartConnection,
    PKSTOPOLOGY_CONNECTION  pEndConnection,
    CCaptureEffectChain *   pFXChain,
    ULONG                   ulCurrentEffect
)
{
    DWORD                   i;
    HRESULT                 hr = DSERR_FXUNAVAILABLE;
    HRESULT                 hrTemp = DS_OK;
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;
    ULONG                   ulMatchingConnectionCount;
    PULONG                  pulConnectionIndexes = NULL;
    KSTOPOLOGY_CONNECTION   tempConnection;
    KSNODE                  tempKsNode;
    BOOL                    fSupportsAlgorithmInstance;
    KSCOMPONENTID           ComponentId;
    const GUID GUID_MICROSOFT = {DEFINE_MMREG_MID_GUID(MM_MICROSOFT)};

    DPF_ENTER();

    // Initialize the starting connection point
    if(pStartConnection)
    {
        pConnection = pStartConnection;
    }
    else
    {
        pConnection = GetNextConnection(NULL);
    }

    CNode<CCaptureEffect*>* pFxNode = pFXChain->m_fxList.GetNodeByIndex(ulCurrentEffect);

    // Walk the topology until we get to the end
    while(SUCCEEDED(hrTemp) && pFxNode && pConnection && pConnection != pEndConnection)
    {
        // Are there multiple ToNodes?
        if((pConnection->FromNode != NODE_UNINITIALIZED) ||
           (pConnection->FromNodePin != NODE_PIN_UNINITIALIZED))
            hrTemp = FindMultipleToNodes
            (
                pConnection->FromNode,
                pConnection->FromNodePin,
                &ulMatchingConnectionCount,
                &pulConnectionIndexes
            );
        else
            ulMatchingConnectionCount = 1;

        // Yes; call ourselves recursively
        if(SUCCEEDED(hrTemp))
        {
            if(ulMatchingConnectionCount > 1)
            {
                for(i=0; i<ulMatchingConnectionCount; i++)
                {
                    tempConnection = m_paConnections[pulConnectionIndexes[i]];
                    tempConnection.FromNode = NODE_UNINITIALIZED;
                    tempConnection.FromNodePin = NODE_PIN_UNINITIALIZED;

                    hrTemp = FindCapturePinFromEffectChain
                             (
                                 &tempConnection,
                                 pEndConnection,
                                 pFXChain,
                                 ulCurrentEffect
                             );

                    if(SUCCEEDED(hrTemp))
                    {
                        hr = DS_OK;
                        pConnection = pEndConnection;
                        if(pulConnectionIndexes)
                            MEMFREE(pulConnectionIndexes);
                        break;
                    }
                }
            }
            else
            {
                // Does this node type match the GUID in the effect descriptor?
                GUID guidToNode = GetControlFromNodeId(pConnection->ToNode);
                if(guidToNode == pFxNode->m_data->m_fxDescriptor.guidDSCFXClass)
                {
                    // Initialize
                    hrTemp = KsGetNodeInformation(m_hDevice, pConnection->ToNode, &tempKsNode);

                    if(SUCCEEDED(hrTemp))
                    {
                        GUID& guidInstance = pFxNode->m_data->m_fxDescriptor.guidDSCFXInstance;
                        hrTemp = KsSetAlgorithmInstance(m_hDevice, pConnection->ToNode, guidInstance);

                        if(SUCCEEDED(hrTemp))
                        {
                            // We don't allow any non-MS software filter to be the default system AEC.
                            // If this node is in software and a system full-duplex effect was requested,
                            // check that its ComponentId.Manufacturer is GUID_MICROSOFT.
                            fSupportsAlgorithmInstance = TRUE;
                            if(tempKsNode.CpuResources != KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU)
                            {
                                if((guidInstance == GUID_DSCFX_SYSTEM_AEC) ||
                                   (guidInstance == GUID_DSCFX_SYSTEM_NS)  ||
                                   (guidInstance == GUID_DSCFX_SYSTEM_AGC))
                                {
                                    hrTemp = KsGetNodeProperty(m_hDevice, KSPROPSETID_General, KSPROPERTY_GENERAL_COMPONENTID, pConnection->ToNode, &ComponentId, sizeof(ComponentId));

                                    if(FAILED(hrTemp) || ComponentId.Manufacturer != GUID_MICROSOFT)
                                    {
                                        fSupportsAlgorithmInstance = FALSE;
                                    }
                                    else
                                    {
                                        if (guidInstance == GUID_DSCFX_SYSTEM_AEC)
                                            guidInstance = GUID_DSCFX_MS_AEC;
                                        else if (guidInstance == GUID_DSCFX_SYSTEM_NS)
                                            guidInstance = GUID_DSCFX_MS_NS;
                                        else if (guidInstance == GUID_DSCFX_SYSTEM_AGC)
                                            guidInstance = GUID_DSCFX_MS_AGC;
                                    }
                                }
                            }
                        }
                        else
                            fSupportsAlgorithmInstance = FALSE;

                        if(fSupportsAlgorithmInstance &&
                           VerifyCaptureFxCpuResources(pFxNode->m_data->m_fxDescriptor.dwFlags, tempKsNode.CpuResources))
                        {
                            pFxNode->m_data->m_ksNode = tempKsNode;

                            if(!ulCurrentEffect)
                            {
                                hr = DS_OK;
                                pConnection = pEndConnection;
                                if(pulConnectionIndexes)
                                    MEMFREE(pulConnectionIndexes);
                                break;
                            }
                            else
                            {
                                ulCurrentEffect--;
                                pFxNode = pFxNode->m_pPrev;
                            }
                        }
                        else if(guidToNode == KSNODETYPE_ADC)
                        {
                            pConnection = pEndConnection;
                            if(pulConnectionIndexes)
                                MEMFREE(pulConnectionIndexes);
                            break;
                        }
                    }
                }
                else if(guidToNode == KSNODETYPE_ADC)
                {
                    pConnection = pEndConnection;
                    if(pulConnectionIndexes)
                        MEMFREE(pulConnectionIndexes);
                    break;
                }

                pConnection = GetNextConnection(pConnection);
            }

            if(pulConnectionIndexes)
                MEMFREE(pulConnectionIndexes);
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindRenderPinWithAec
 *
 *  Description:
 *      Searches the Connection and Node lists to find a
 *      render pin that can support the desired
 *      AEC.  This is a recursive routine
 *
 *  Arguments:
 *   HANDLE                 [in]: handle to the pin to check.
 *   PKSTOPOLOGY_CONNECTION [in]: starting connection to search
 *   PKSTOPOLOGY_CONNECTION [in]: ending connection to search
 *   REFGUID                [in]: desired AEC instance GUID
 *   DWORD                  [in]: desired AEC flags
 *   PKSNODE                [out]: pointer to the AEC node
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindRenderPinWithAec"

HRESULT
CKsTopology::FindRenderPinWithAec
(
    HANDLE                  hPin,
    PKSTOPOLOGY_CONNECTION  pStartConnection,
    PKSTOPOLOGY_CONNECTION  pEndConnection,
    REFGUID                 guidDSCFXInstance,
    DWORD                   dwFlags,
    PKSNODE                 pAecNode
)
{
    DWORD                   i;
    HRESULT                 hr = DSERR_UNSUPPORTED;
    HRESULT                 hrTemp = DS_OK;
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;
    ULONG                   ulMatchingConnectionCount;
    PULONG                  pulConnectionIndexes = NULL;
    KSTOPOLOGY_CONNECTION   tempConnection;
    KSNODE                  tempKsNode;
    BOOL                    fSupportsAlgorithmInstance;
    KSCOMPONENTID           ComponentId;
    const GUID GUID_MICROSOFT = {DEFINE_MMREG_MID_GUID(MM_MICROSOFT)};

    DPF_ENTER();

    // Initialize the starting connection point
    if(pStartConnection)
    {
        pConnection = pStartConnection;
    }
    else
    {
        pConnection = GetNextConnection(NULL);
    }

    // Walk the topology until you get to the end
    while(SUCCEEDED(hrTemp) && pConnection && pConnection != pEndConnection)
    {
        // Are there multiple ToNodes?
        if((pConnection->FromNode != NODE_UNINITIALIZED) ||
           (pConnection->FromNodePin != NODE_PIN_UNINITIALIZED))
            hrTemp = FindMultipleToNodes
            (
                pConnection->FromNode,
                pConnection->FromNodePin,
                &ulMatchingConnectionCount,
                &pulConnectionIndexes
            );
        else
            ulMatchingConnectionCount = 1;

        // Yes; call ourselves recursively
        if(SUCCEEDED(hrTemp))
        {
            if(ulMatchingConnectionCount > 1)
            {
                for(i=0; i<ulMatchingConnectionCount; i++)
                {
                    tempConnection = m_paConnections[pulConnectionIndexes[i]];
                    tempConnection.FromNode = NODE_UNINITIALIZED;
                    tempConnection.FromNodePin = NODE_PIN_UNINITIALIZED;

                    hrTemp = FindRenderPinWithAec
                             (
                                 hPin,
                                 &tempConnection,
                                 pEndConnection,
                                 guidDSCFXInstance,
                                 dwFlags,
                                 pAecNode
                             );

                    if(SUCCEEDED(hrTemp))
                    {
                        hr = DS_OK;
                        pConnection = pEndConnection;
                        if(pulConnectionIndexes)
                            MEMFREE(pulConnectionIndexes);
                        break;
                    }
                }
            }
            else
            {
                // Does this node type match the GUID in the effect descriptor?
                GUID guidToNode = GetControlFromNodeId(pConnection->ToNode);
                if(guidToNode == GUID_DSCFX_CLASS_AEC)
                {
                    // Initialize
                    hrTemp = KsGetNodeInformation(m_hDevice, pConnection->ToNode, &tempKsNode);

                    if(SUCCEEDED(hrTemp))
                    {
                        hrTemp = KsSetAlgorithmInstance
                                 (
                                     m_hDevice,
                                     pConnection->ToNode,
                                     guidDSCFXInstance
                                 );

                        if(SUCCEEDED(hrTemp))
                        {
                            fSupportsAlgorithmInstance = TRUE;
                            if(tempKsNode.CpuResources != KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU)
                            {
                                if(guidDSCFXInstance == GUID_DSCFX_SYSTEM_AEC)
                                {
                                    hrTemp = KsGetNodeProperty(m_hDevice, KSPROPSETID_General, KSPROPERTY_GENERAL_COMPONENTID, pConnection->ToNode, &ComponentId, sizeof(ComponentId));

                                    if(FAILED(hrTemp) || ComponentId.Manufacturer != GUID_MICROSOFT)
                                        fSupportsAlgorithmInstance = FALSE;
                                }
                            }
                        }
                        else
                            fSupportsAlgorithmInstance = FALSE;

                        if(fSupportsAlgorithmInstance &&
                           VerifyCaptureFxCpuResources(dwFlags, tempKsNode.CpuResources))
                        {
                            *pAecNode = tempKsNode;
                            hr = DS_OK;
                            pConnection = pEndConnection;
                            if(pulConnectionIndexes)
                                MEMFREE(pulConnectionIndexes);
                            break;
                        }
                    }
                }
                else if(guidToNode == KSNODETYPE_DAC)
                {
                    pConnection = pEndConnection;
                    if(pulConnectionIndexes)
                        MEMFREE(pulConnectionIndexes);
                    break;
                }

                pConnection = GetNextConnection(pConnection);
            }

            if(pulConnectionIndexes)
                MEMFREE(pulConnectionIndexes);
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindMultipleToNodes
 *
 *  Description:
 *      Searches the connection table for all connections which share
 *      the same FromNode and FromNodePin.  JStokes added the method
 *      for correctly parsing the capture pin topology.  This function
 *      may be removed if the topology is parsed smarter or SysAudio
 *      provides additional helper functions in the future.
 *
 *  Arguments:
 *      REFGUID [in]: control.
 *      PULONG  [out]: number of nodes found which match the control GUID
 *      PPULONG [out]: pointer to the array containing node ids
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindMultipleToNodes"

HRESULT
CKsTopology::FindMultipleToNodes
(
    ULONG       ulFromNode,
    ULONG       ulFromNodePin,
    PULONG      pCount,
    PULONG*     ppConnectionIndexes
)
{
    ULONG       i;
    ULONG       j;
    HRESULT     hr;

    DPF_ENTER();

    // Count all instances of connection which match the FromNode and FromNodePin.
    *pCount = 0;
    for(i = 0; i < m_paConnectionItems->Count; i++)
    {
        if((ulFromNode == m_paConnections[i].FromNode) &&
           (ulFromNodePin == m_paConnections[i].FromNodePin))
        {
            (*pCount)++;
        }
    }

    // Allocate the array to hold the node numbers
    *ppConnectionIndexes = MEMALLOC_A(ULONG, *pCount);
    hr = HRFROMP(*ppConnectionIndexes);

    // Fill the array with the Node IDs which match
    // the control GUID.
    if(SUCCEEDED(hr))
    {
        j = 0;
        for(i = 0; i < m_paConnectionItems->Count; i++)
        {
            if((ulFromNode == m_paConnections[i].FromNode) &&
               (ulFromNodePin == m_paConnections[i].FromNodePin))
            {
                (*ppConnectionIndexes)[j++] = i;
            }
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  CKsPropertySet
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      LPVOID [in]: instance identifier.
 *      CKsTopology * [in]: pin topology.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::CKsPropertySet"

CKsPropertySet::CKsPropertySet
(
    HANDLE                  hPin,
    LPVOID                  pvInstance,
    CKsTopology *           pTopology
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsPropertySet);

    // Intialize defaults
    m_hPin = hPin;
    m_pvInstance = pvInstance;
    m_pTopology = ADDREF(pTopology);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsPropertySet
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::~CKsPropertySet"

CKsPropertySet::~CKsPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsPropertySet);

    // Release the topology object
    RELEASE(m_pTopology);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for property set support.
 *
 *  Arguments:
 *      REFGUID [in]: property set to query for.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property paramaters.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::QuerySupport"

HRESULT
CKsPropertySet::QuerySupport
(
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    PULONG                  pulSupport
)
{
    KSDSPROPERTY            KsDsProperty;
    HRESULT                 hr;

    DPF_ENTER();

    // Search for the node id corresponding to the property set and id
    hr = FindNodeFromProperty(guidPropertySet, ulPropertyId, &KsDsProperty);

    // Convert the access flags to support flags
    if(SUCCEEDED(hr))
    {
        *pulSupport = 0;

        if(KsDsProperty.AccessFlags & KSPROPERTY_TYPE_GET)
        {
            *pulSupport |= KSPROPERTY_SUPPORT_GET;
        }

        if(KsDsProperty.AccessFlags & KSPROPERTY_TYPE_SET)
        {
            *pulSupport |= KSPROPERTY_SUPPORT_SET;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetProperty
 *
 *  Description:
 *      Gets a property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: context data.
 *      ULONG [in]: size of context data.
 *      LPVOID [in]: property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::GetProperty"

HRESULT
CKsPropertySet::GetProperty
(
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvParam,
    ULONG                   cbParam,
    LPVOID                  pvData,
    PULONG                  pcbData
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = DoProperty(guidPropertySet, ulPropertyId, KSPROPERTY_TYPE_GET, pvParam, cbParam, pvData, pcbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets a property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: context data.
 *      ULONG [in]: size of context data.
 *      LPVOID [in]: property data.
 *      ULONG [in]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::SetProperty"

HRESULT
CKsPropertySet::SetProperty
(
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvParam,
    ULONG                   cbParam,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = DoProperty(guidPropertySet, ulPropertyId, KSPROPERTY_TYPE_SET, pvParam, cbParam, pvData, &cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DoProperty
 *
 *  Description:
 *      Gets or sets a property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      DWORD [in]: Get/set flags.
 *      LPVOID [in]: context data.
 *      ULONG [in]: size of context data.
 *      LPVOID [in]: property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::DoProperty"

HRESULT
CKsPropertySet::DoProperty
(
    REFGUID                         guidPropertySet,
    ULONG                           ulPropertyId,
    DWORD                           dwFlags,
    LPVOID                          pvParam,
    ULONG                           cbParam,
    LPVOID                          pvData,
    PULONG                          pcbData
)
{
    PKSNODEPROPERTY_AUDIO_PROPERTY  pProperty       = NULL;
    DWORD                           cbProperty      = BLOCKALIGNPAD(sizeof(*pProperty) + cbParam, 8);
    KSDSPROPERTY                    KsDsProperty;
    HRESULT                         hr;

    DPF_ENTER();

    ASSERT(KSPROPERTY_TYPE_GET == dwFlags || KSPROPERTY_TYPE_SET == dwFlags);

    // Search for the node id corresponding to the property set and id
    hr = FindNodeFromProperty(guidPropertySet, ulPropertyId, &KsDsProperty);

    if(SUCCEEDED(hr) && !(KsDsProperty.AccessFlags & dwFlags))
    {
        RPF(DPFLVL_ERROR, "The property does not support this method");
        hr = DSERR_UNSUPPORTED;
    }

    // Create the property description
    if(SUCCEEDED(hr))
    {
        pProperty = (PKSNODEPROPERTY_AUDIO_PROPERTY)MEMALLOC_A(BYTE, cbProperty);
        hr = HRFROMP(pProperty);
    }

    if(SUCCEEDED(hr))
    {
        pProperty->NodeProperty.Property.Set = KsDsProperty.PropertySet;
        pProperty->NodeProperty.Property.Id = KsDsProperty.PropertyId;
        pProperty->NodeProperty.Property.Flags = KSPROPERTY_TYPE_TOPOLOGY | dwFlags;

        pProperty->NodeProperty.NodeId = KsDsProperty.NodeId;
        pProperty->NodeProperty.Reserved = 0;

        pProperty->AppContext = m_pvInstance;
        pProperty->Length = cbParam;

#ifndef WIN64

        pProperty->Reserved = 0;

#endif // WIN64

        if(cbParam)
        {
            CopyMemory(pProperty + 1, pvParam, cbParam);
        }
    }

    // Get the property
    if(SUCCEEDED(hr))
    {
        hr = PostDevIoctl(m_hPin, IOCTL_KS_PROPERTY, pProperty, cbProperty, pvData, *pcbData, pcbData);
    }

    // Clean up
    MEMFREE(pProperty);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindNodeFromProperty
 *
 *  Description:
 *      Searches the linked list associating the property set and id
 *      with the Device Specific node Id.
 *
 *  Arguments:
 *      REFGUID [in]: property set to query for.
 *      ULONG [in]: property id.
 *      PKSDSPROPERTY [out]: receives property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::FindNodeFromProperty"

HRESULT
CKsPropertySet::FindNodeFromProperty
(
    REFGUID                         guidPropertySet,
    ULONG                           ulPropertyId,
    PKSDSPROPERTY                   pKsDsProperty
)
{
    HRESULT                         hr              = DS_OK;
    PKSTOPOLOGY_CONNECTION          pConnection     = NULL;
    KSNODEPROPERTY_AUDIO_PROPERTY   Property;
    KSPROPERTY_DESCRIPTION          Description;
    CNode<KSDSPROPERTY> *           pPropertyNode;

    DPF_ENTER();

    // Do we already know about this property?
    for(pPropertyNode = m_lstProperties.GetListHead(); pPropertyNode; pPropertyNode = pPropertyNode->m_pNext)
    {
        if(guidPropertySet == pPropertyNode->m_data.PropertySet)
        {
            if(ulPropertyId == pPropertyNode->m_data.PropertyId)
            {
                break;
            }
        }
    }

    if(pPropertyNode)
    {
        // Yup.  Fill in the property.
        CopyMemory(pKsDsProperty, &pPropertyNode->m_data, sizeof(pPropertyNode->m_data));
    }
    else
    {
        // Nope.  Let's query the driver for it.

        // Since in general we'll only find the first node that supports the property we're interested in,
        // for "special" properties we'll try to increase the likelihood of getting the correct node

        if(guidPropertySet == KSPROPSETID_Audio && ulPropertyId == KSPROPERTY_AUDIO_QUALITY)
        {
            // Get the same SRC connection that dsound uses internally for SRC quality setting
            PKSTOPOLOGY_CONNECTION pSummingConnection = m_pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_SUM);
            pConnection = m_pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_SRC);
        }

        Property.NodeProperty.Property.Set = guidPropertySet;
        Property.NodeProperty.Property.Id = ulPropertyId;
        Property.NodeProperty.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;
        Property.NodeProperty.Reserved = 0;
        Property.AppContext = 0;
        Property.Length = 0;

        if(pConnection)
        {
            // this is a special case property and we've already found the node we're interested in
            Property.NodeProperty.NodeId = m_pTopology->GetNodeIdFromConnection(pConnection);

            hr = PostDevIoctl(m_hPin, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &Description, sizeof(Description));

            // We found a node that supports the property.  Add it to the list of known properties.
            if(SUCCEEDED(hr))
            {
                pKsDsProperty->PropertySet = Property.NodeProperty.Property.Set;
                pKsDsProperty->PropertyId = Property.NodeProperty.Property.Id;
                pKsDsProperty->NodeId = Property.NodeProperty.NodeId;
                pKsDsProperty->AccessFlags = Description.AccessFlags;

                pPropertyNode = m_lstProperties.AddNodeToList(*pKsDsProperty);
                hr = HRFROMP(pPropertyNode);
            }
        }
        else
        {
            // Else traverse through the connections looking for the first node that supports this property
            while(pConnection = m_pTopology->GetNextConnection(pConnection))
            {
                Property.NodeProperty.NodeId = m_pTopology->GetNodeIdFromConnection(pConnection);

                hr = PostDevIoctl(m_hPin, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &Description, sizeof(Description));

                // We found a node that supports the property.  Add it to the list of known properties.
                if(SUCCEEDED(hr))
                {
                    pKsDsProperty->PropertySet = Property.NodeProperty.Property.Set;
                    pKsDsProperty->PropertyId = Property.NodeProperty.Property.Id;
                    pKsDsProperty->NodeId = Property.NodeProperty.NodeId;
                    pKsDsProperty->AccessFlags = Description.AccessFlags;

                    pPropertyNode = m_lstProperties.AddNodeToList(*pKsDsProperty);
                    hr = HRFROMP(pPropertyNode);

                    break;
                }
            }
        }
    }

    if(FAILED(hr) || (SUCCEEDED(hr) && !pPropertyNode))
    {
        RPF(DPFLVL_ERROR, "Unable to find a topology node supporting the requested property");
        hr = DSERR_UNSUPPORTED;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  PostDevIoctl
 *
 *  Description:
 *      Wrapper for DeviceIoControl.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: control code.
 *      LPVOID [in]: input data.
 *      DWORD [in]: size of input data.
 *      LPVOID [out]: receives output data.
 *      DWORD [in]: size of output data buffer.
 *      LPOVERLAPPED [in]: overlapped IO data.  This argument may be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PostDevIoctl"

HRESULT
PostDevIoctl
(
    HANDLE                  hDevice,
    DWORD                   dwControlCode,
    LPVOID                  pvIn,
    DWORD                   cbIn,
    LPVOID                  pvOut,
    DWORD                   cbOut,
    LPDWORD                 pcbReturned,
    LPOVERLAPPED            pOverlapped
)
{
    HRESULT                 hr          = DS_OK;
    static OVERLAPPED       ovlAsynch;
    DWORD                   cbReturned;
    BOOL                    fSuccess;
    DWORD                   dwError;
    DWORD                   dwWait;

    DPF_ENTER();

    // The returned size parameter is optional
    if(!pcbReturned)
    {
        pcbReturned = &cbReturned;
    }

    *pcbReturned = MAX_DWORD;

    // All IOCTLs must have an overlapped structure.  This function cannot
    // be used for any devices that were not opened with FILE_FLAG_OVERLAPPED.
    if(!pOverlapped)
    {
        if(!ovlAsynch.hEvent)
        {
            // We're going to leak this event when the DLL unloads, but
            // that's OK; Windows will clean up for us.  Note: because
            // we're using a static structure and a single event, this
            // function must ALWAYS be synchronized across threads.
            ovlAsynch.hEvent = CreateGlobalEvent(NULL, FALSE);

            if(!IsValidHandleValue(ovlAsynch.hEvent))
            {
                hr = GetLastErrorToHRESULT();
            }
        }

        pOverlapped = &ovlAsynch;
    }

    // Post the IOCTL
    if(SUCCEEDED(hr))
    {
        fSuccess = DeviceIoControl(hDevice, dwControlCode, pvIn, cbIn, pvOut, cbOut, pcbReturned, pOverlapped);

        if(fSuccess)
        {
            dwError = ERROR_SUCCESS;
        }
        else
        {
            dwError = GetLastError();
            ASSERT(ERROR_SUCCESS != dwError);
        }

        // Check the return value for ERROR_IO_PENDING.  If we sent an
        // asynchronous IOCTL, DeviceIoControl will actually fail with
        // ERROR_IO_PENDING.  As long as the calling function specified an
        // overlapped object, that's ok.
        if(ERROR_IO_PENDING == dwError)
        {
            dwError = ERROR_SUCCESS;

            if(&ovlAsynch == pOverlapped)
            {
                dwWait = WaitObject(INFINITE, pOverlapped->hEvent);
                ASSERT(WAIT_OBJECT_0 == dwWait);

                fSuccess = GetOverlappedResult(hDevice, pOverlapped, pcbReturned, FALSE);

                if(!fSuccess)
                {
                    dwError = GetLastError();
                    ASSERT(ERROR_SUCCESS != dwError);
                    ASSERT(ERROR_IO_PENDING != dwError);
                }
            }
        }

        // Check the return value for any variations of ERROR_INSUFFICIENT_BUFFER.
        // It's possible that more data is available.
        if(ERROR_BUFFER_OVERFLOW == dwError || ERROR_MORE_DATA == dwError || ERROR_INSUFFICIENT_BUFFER == dwError)
        {
            ASSERT(MAX_DWORD != *pcbReturned);

            if(&cbReturned != pcbReturned)
            {
                dwError = ERROR_SUCCESS;
            }
        }

        // Done with error handling
        if(ERROR_SUCCESS != dwError)
        {
            if (dwError == ERROR_NOT_FOUND || dwError == ERROR_SET_NOT_FOUND)
            {
                // These are very common return codes from KS in normal operation
                DPF(DPFLVL_MOREINFO, "DeviceIoControl failed with ERROR_%sNOT_FOUND",
                    dwError == ERROR_SET_NOT_FOUND ? TEXT("SET_") : TEXT(""));
            }
            else
            {
                DPF(DPFLVL_WARNING, "DeviceIoControl failed with error %lu", dwError);
            }
            hr = WIN32ERRORtoHRESULT(dwError);
        }
    }

#ifdef DEBUG
    g_ulKsIoctlCount++;
#endif // DEBUG

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetProperty
 *
 *  Description:
 *      Retrieves a particular property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      DWORD [in]: property id.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetProperty"

HRESULT
KsGetProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSPROPERTY              Property;
    HRESULT                 hr;

    DPF_ENTER();

    Property.Set = guidPropertySet;
    Property.Id = ulPropertyId;
    Property.Flags = KSPROPERTY_TYPE_GET;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof(Property), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetProperty
 *
 *  Description:
 *      Sets a particular property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      DWORD [in]: property id.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetProperty"

HRESULT
KsSetProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSPROPERTY              Property;
    HRESULT                 hr;

    DPF_ENTER();

    Property.Set = guidPropertySet;
    Property.Id = ulPropertyId;
    Property.Flags = KSPROPERTY_TYPE_SET;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof(Property), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetState
 *
 *  Description:
 *      Retrieves a state property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSSTATE [out]: receives state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetState"

HRESULT
KsGetState
(
    HANDLE                  hDevice,
    PKSSTATE                pState
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetProperty(hDevice, KSPROPSETID_Connection, KSPROPERTY_CONNECTION_STATE, pState, sizeof(*pState));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetState
 *
 *  Description:
 *      Sets a state property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      KSSTATE [in]: state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetState"

HRESULT
KsSetState
(
    HANDLE                  hDevice,
    KSSTATE                 State
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsSetProperty(hDevice, KSPROPSETID_Connection, KSPROPERTY_CONNECTION_STATE, &State, sizeof(State));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsTransitionState
 *
 *  Description:
 *      Sets a state property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      KSSTATE [in]: current state.
 *      KSSTATE [in]: new state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsTransitionState"

HRESULT
KsTransitionState
(
    HANDLE                  hDevice,
    KSSTATE                 nCurrentState,
    KSSTATE                 nNewState
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    while(nCurrentState != nNewState)
    {
        if(nCurrentState < nNewState)
        {
            nCurrentState = (KSSTATE)(nCurrentState + 1);
        }
        else
        {
            nCurrentState = (KSSTATE)(nCurrentState - 1);
        }

        hr = KsSetState(hDevice, nCurrentState);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsResetState
 *
 *  Description:
 *      Resets the state of a pin back to the state
 *      it was in upon being set to PAUSE originally.
 *      Dsound is using it to cancel pending irps on the
 *      capture and render devices.  The pin must be
 *      in the PAUSE state when calling this function.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      KSSTATE [in]: state.
 *      PKSSTREAMIO [in/out]: stream data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsResetState"

HRESULT
KsResetState
(
    HANDLE                  hDevice,
    KSRESET                 ResetValue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = PostDevIoctl(hDevice, IOCTL_KS_RESET_STATE, &ResetValue, sizeof(ResetValue));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetPinProperty
 *
 *  Description:
 *      Retrieves a particular property on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinProperty"

HRESULT
KsGetPinProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    DPF_ENTER();

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = ulPropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetPinProperty
 *
 *  Description:
 *      Sets a particular property on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      LPVOID [out]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetPinProperty"

HRESULT
KsSetPinProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    DPF_ENTER();

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = ulPropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_SET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsFindConnection
 *
 *  Description:
 *      Finds a particular topology connection structure from an array.
 *
 *  Arguments:
 *      PKSTOPOLOGY_CONNECTION [in]: connection structure array.
 *      ULONG [in]: count of items in the connection array.
 *      PKSTOPOLOGY_CONNECTION [in]: item to find.
 *
 *  Returns:
 *      PKSTOPOLOGY_CONNECTION: connection.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsFindConnection"

PKSTOPOLOGY_CONNECTION
KsFindConnection
(
    PKSTOPOLOGY_CONNECTION  paConnections,
    ULONG                   cConnections,
    PKSTOPOLOGY_CONNECTION  pNext
)
{
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;

    DPF_ENTER();

    while(cConnections--)
    {
        if(NODE_WILDCARD == pNext->FromNode || pNext->FromNode == paConnections->FromNode)
        {
            if(NODE_WILDCARD == pNext->FromNodePin || pNext->FromNodePin == paConnections->FromNodePin)
            {
                if(NODE_WILDCARD == pNext->ToNode || pNext->ToNode == paConnections->ToNode)
                {
                    if(NODE_WILDCARD == pNext->ToNodePin || pNext->ToNodePin == paConnections->ToNodePin)
                    {
                        pConnection = paConnections;
                        break;
                    }
                }
            }
        }

        paConnections++;
    }

    pConnection = KsValidateConnection(pConnection);

    DPF_LEAVE(pConnection);
    return pConnection;
}


#ifndef WINNT

/***************************************************************************
 *
 *  KsGetFirstPinConnection
 *
 *  Description:
 *      Gets the index of the first topology connection.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PULONG [out]: receives index identifier.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetFirstPinConnection"

HRESULT
KsGetFirstPinConnection
(
    HANDLE                  hDevice,
    PULONG                  pIndex
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetProperty(hDevice, KSPROPSETID_Sysaudio_Pin, KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX, pIndex, sizeof(*pIndex));

    if(SUCCEEDED(hr) && MAX_ULONG == *pIndex)
    {
        hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // !WINNT


/***************************************************************************
 *
 *  KsWriteStream
 *
 *  Description:
 *      Writes data to a stream pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      LPVOID [out]: data.
 *      ULONG [in]: size of above buffer.
 *      ULONG [in]: flags.
 *      PKSSTREAMIO [in]: overlapped io data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsWriteStream"

HRESULT
KsWriteStream
(
    HANDLE                  hDevice,
    LPCVOID                 pvData,
    ULONG                   cbData,
    ULONG                   ulFlags,
    PKSSTREAMIO             pKsStreamIo
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(!pKsStreamIo->fPendingIrp);

    pKsStreamIo->Header.Size = sizeof(pKsStreamIo->Header);
    pKsStreamIo->Header.TypeSpecificFlags = 0;

    pKsStreamIo->Header.PresentationTime.Time = 0;
    pKsStreamIo->Header.PresentationTime.Numerator = 1;
    pKsStreamIo->Header.PresentationTime.Denominator = 1;

    pKsStreamIo->Header.Duration = 0;
    pKsStreamIo->Header.FrameExtent = cbData;
    pKsStreamIo->Header.DataUsed = cbData;
    pKsStreamIo->Header.Data = (LPVOID)pvData;
    pKsStreamIo->Header.OptionsFlags = ulFlags;

    hr = PostDevIoctl(hDevice, IOCTL_KS_WRITE_STREAM, NULL, 0, &pKsStreamIo->Header, pKsStreamIo->Header.Size, NULL, &pKsStreamIo->Overlapped);

    if(SUCCEEDED(hr))
    {
        pKsStreamIo->fPendingIrp = TRUE;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsReadStream
 *
 *  Description:
 *      Reads data from a stream pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      LPVOID [out]: data.
 *      ULONG [in]: size of above buffer.
 *      ULONG [in]: flags.
 *      PKSSTREAMIO [in]: stream overlapped io data block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsReadStream"

HRESULT
KsReadStream
(
    HANDLE                  hDevice,
    LPVOID                  pvData,
    ULONG                   cbData,
    ULONG                   ulFlags,
    PKSSTREAMIO             pKsStreamIo
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(!pKsStreamIo->fPendingIrp);

    pKsStreamIo->Header.Size = sizeof(pKsStreamIo->Header);
    pKsStreamIo->Header.TypeSpecificFlags = 0;

    pKsStreamIo->Header.PresentationTime.Time = 0;
    pKsStreamIo->Header.PresentationTime.Numerator = 1;
    pKsStreamIo->Header.PresentationTime.Denominator = 1;

    pKsStreamIo->Header.Duration = 0;
    pKsStreamIo->Header.FrameExtent = cbData;
    pKsStreamIo->Header.DataUsed = 0;
    pKsStreamIo->Header.Data = pvData;
    pKsStreamIo->Header.OptionsFlags = ulFlags;

    hr = PostDevIoctl(hDevice, IOCTL_KS_READ_STREAM, NULL, 0, &pKsStreamIo->Header, pKsStreamIo->Header.Size, NULL, &pKsStreamIo->Overlapped);

    if(SUCCEEDED(hr))
    {
        pKsStreamIo->fPendingIrp = TRUE;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetNodeProperty
 *
 *  Description:
 *      Retrieves a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetNodeProperty"

HRESULT
KsGetNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSNODEPROPERTY          NodeProperty;
    HRESULT                 hr;

    DPF_ENTER();

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetNodeProperty
 *
 *  Description:
 *      Sets a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetNodeProperty"

HRESULT
KsSetNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSNODEPROPERTY          NodeProperty;
    HRESULT                 hr;

    DPF_ENTER();

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#ifdef DEAD_CODE
/***************************************************************************
 *
 *  KsGet3dNodeProperty
 *
 *  Description:
 *      Retrieves a particular property on a 3d listener or effects
 *      topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      LPVOID [in]: instance data.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGet3dNodeProperty"

HRESULT
KsGet3dNodeProperty
(
    HANDLE                              hDevice,
    REFGUID                             guidPropertySet,
    ULONG                               ulPropertyId,
    ULONG                               ulNodeId,
    LPVOID                              pvInstance,
    LPVOID                              pvData,
    ULONG                               cbData,
    PULONG                              pcbDataReturned
)
{
    KSNODEPROPERTY_AUDIO_3D_LISTENER    Listener;
    HRESULT                             hr;

    DPF_ENTER();

    Listener.NodeProperty.Property.Set = guidPropertySet;
    Listener.NodeProperty.Property.Id = ulPropertyId;
    Listener.NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    Listener.NodeProperty.NodeId = ulNodeId;
    Listener.NodeProperty.Reserved = 0;

    Listener.ListenerId = pvInstance;

#ifndef WIN64

    Listener.Reserved = 0;

#endif // WIN64

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Listener, sizeof(Listener), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // DEAD_CODE


/***************************************************************************
 *
 *  KsSet3dNodeProperty
 *
 *  Description:
 *      Sets a particular property on a 3d listener or effects
 *      topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      LPVOID [in]: instance data.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSet3dNodeProperty"

HRESULT
KsSet3dNodeProperty
(
    HANDLE                              hDevice,
    REFGUID                             guidPropertySet,
    ULONG                               ulPropertyId,
    ULONG                               ulNodeId,
    LPVOID                              pvInstance,
    LPVOID                              pvData,
    DWORD                               cbData
)
{
    KSNODEPROPERTY_AUDIO_3D_LISTENER    Listener;
    HRESULT                             hr;

    DPF_ENTER();

    Listener.NodeProperty.Property.Set = guidPropertySet;
    Listener.NodeProperty.Property.Id = ulPropertyId;
    Listener.NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    Listener.NodeProperty.NodeId = ulNodeId;
    Listener.NodeProperty.Reserved = 0;

    Listener.ListenerId = pvInstance;

#ifndef WIN64

    Listener.Reserved = 0;

#endif // WIN64

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Listener, sizeof(Listener), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DsSpeakerConfigToKsProperties
 *
 *  Description:
 *      Translates a DirectSound speaker config code into the values taken
 *      by the corresponding KS properties: KSPROPERTY_AUDIO_CHANNEL_CONFIG
 *      and KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY.
 *
 *  Arguments:
 *      DWORD [in]: DirectSound speaker configuration.
 *      PLONG [out]: receives KsSpeakerConfig value.
 *      PLONG [out]: receives KsStereoSpeakerGeometry value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsSpeakerConfigToKsProperties"

HRESULT
DsSpeakerConfigToKsProperties
(
    DWORD                               dwSpeakerConfig,
    PLONG                               pKsSpeakerConfig,
    PLONG                               pKsStereoSpeakerGeometry
)
{
    HRESULT                             hr = DS_OK;

    DPF_ENTER();

    switch (DSSPEAKER_CONFIG(dwSpeakerConfig))
    {
        case DSSPEAKER_DIRECTOUT:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_DIRECTOUT;
            break;

        case DSSPEAKER_HEADPHONE:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_STEREO;
            *pKsStereoSpeakerGeometry = KSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE;
            break;

        case DSSPEAKER_MONO:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_MONO;
            break;

        case DSSPEAKER_STEREO:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_STEREO;
            *pKsStereoSpeakerGeometry = (LONG)DSSPEAKER_GEOMETRY(dwSpeakerConfig);
            if (!*pKsStereoSpeakerGeometry)
                *pKsStereoSpeakerGeometry = KSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE;
            break;

        case DSSPEAKER_QUAD:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_QUAD;
            break;

        case DSSPEAKER_SURROUND:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_SURROUND;
            break;

        case DSSPEAKER_5POINT1:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_5POINT1;
            break;

        case DSSPEAKER_7POINT1:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_7POINT1;
            break;

        default:
            ASSERT(FALSE);
            hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DsBufferFlagsToKsPinFlags
 *
 *  Description:
 *      Converts DirectSound flags to KSDATAFORMAT_DSOUND flags.
 *
 *  Arguments:
 *      DWORD [in]: DirectSound buffer flags.
 *
 *  Returns:
 *      DWORD: KSDATAFORMAT_DSOUND flags.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsBufferFlagsToKsPinFlags"

DWORD
DsBufferFlagsToKsPinFlags
(
    DWORD                   dwDsFlags
)
{
    DWORD                   dwKsFlags   = 0;

    DPF_ENTER();

    if(dwDsFlags & DSBCAPS_PRIMARYBUFFER)
    {
        dwKsFlags |= KSDSOUND_BUFFER_PRIMARY;
    }

    if(dwDsFlags & DSBCAPS_STATIC)
    {
        dwKsFlags |= KSDSOUND_BUFFER_STATIC;
    }

    if(dwDsFlags & DSBCAPS_LOCHARDWARE)
    {
        dwKsFlags |= KSDSOUND_BUFFER_LOCHARDWARE;
    }
    else if(dwDsFlags & DSBCAPS_LOCSOFTWARE)
    {
        dwKsFlags |= KSDSOUND_BUFFER_LOCSOFTWARE;
    }

    DPF_LEAVE(dwKsFlags);
    return dwKsFlags;
}


/***************************************************************************
 *
 *  DsBufferFlagsToKsControlFlags
 *
 *  Description:
 *      Converts DirectSound flags to KSDATAFORMAT_DSOUND control flags.
 *
 *  Arguments:
 *      DWORD [in]: DirectSound buffer flags.
 *      REFGUID [in]: 3D algorithm GUID.
 *
 *  Returns:
 *      DWORD: KSDATAFORMAT_DSOUND control flags.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsBufferFlagsToKsControlFlags"

DWORD
DsBufferFlagsToKsControlFlags
(
    DWORD                   dwDsFlags,
    REFGUID                 guid3dAlgorithm
)
{
    DWORD                   dwKsFlags   = 0;

    DPF_ENTER();

    if(dwDsFlags & DSBCAPS_CTRLFREQUENCY)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_FREQUENCY;
    }

    if(dwDsFlags & DSBCAPS_CTRLPAN)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_PAN;
    }

    if(dwDsFlags & DSBCAPS_CTRLVOLUME)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_VOLUME;
    }

    if(dwDsFlags & DSBCAPS_CTRLPOSITIONNOTIFY)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY;
    }

    if(dwDsFlags & DSBCAPS_CTRL3D)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_3D;

        if(DS3DALG_HRTF_FULL == guid3dAlgorithm || DS3DALG_HRTF_LIGHT == guid3dAlgorithm)
        {
            dwKsFlags |= KSDSOUND_BUFFER_CTRL_HRTF_3D;
        }
    }

    DPF_LEAVE(dwKsFlags);
    return dwKsFlags;
}


/***************************************************************************
 *
 *  Ds3dModeToKs3dMode
 *
 *  Description:
 *      Converts DirectSound 3D mode to KS 3D Mode.
 *
 *  Arguments:
 *      DWORD [in]:  DirectSound 3D mode.
 *
 *  Returns:
 *      DWORD: KS 3D mode.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Ds3dModeToKs3dMode"

DWORD
Ds3dModeToKs3dMode
(
    DWORD                   dwDsMode
)
{
    DWORD                   dwKsMode;

    switch(dwDsMode)
    {
        default:
            ASSERT(!"Impossible dwDsMode");
            // Fall through to set the mode to NORMAL

        case DS3DMODE_NORMAL:
            dwKsMode = KSDSOUND_3D_MODE_NORMAL;
            break;

        case DS3DMODE_HEADRELATIVE:
            dwKsMode = KSDSOUND_3D_MODE_HEADRELATIVE;
            break;

        case DS3DMODE_DISABLE:
            dwKsMode = KSDSOUND_3D_MODE_DISABLE;
            break;
    }

    return dwKsMode;
}


/***************************************************************************
 *
 *  KsGetMultiplePinProperties
 *
 *  Description:
 *      Retrieves a particular property on a pin.  Use this function when
 *      the property is expected to come back in KSMULTIPLE_ITEM format.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      PKSMULTIPLE_ITEM * [out]: receives pointer to property data.  This
 *                                memory must be freed by the caller.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetMultiplePinProperties"

HRESULT
KsGetMultiplePinProperties
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
)
{
    LPVOID                  pvProperty  = NULL;
    ULONG                   cbProperty  = 0;
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetPinProperty(hDevice, ulPropertyId, ulPinId, NULL, 0, &cbProperty);

    if(SUCCEEDED(hr) && !cbProperty)
    {
        DPF(DPFLVL_ERROR, "Property size is 0");
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr))
    {
        pvProperty = MEMALLOC_A(BYTE, cbProperty);
        hr = HRFROMP(pvProperty);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetPinProperty(hDevice, ulPropertyId, ulPinId, pvProperty, cbProperty);
    }

    if(SUCCEEDED(hr))
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)pvProperty;
    }
    else
    {
        MEMFREE(pvProperty);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetMultipleTopologyProperties
 *
 *  Description:
 *      Retrieves a particular property on a node.  Use this function when
 *      the property is expected to come back in KSMULTIPLE_ITEM format.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: node id.
 *      PKSMULTIPLE_ITEM * [out]: receives pointer to property data.  This
 *                                memory must be freed by the caller.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetMultipleTopologyProperties"

HRESULT
KsGetMultipleTopologyProperties
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
)
{
    LPVOID                  pvProperty  = NULL;
    ULONG                   cbProperty  = 0;
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetProperty(hDevice, KSPROPSETID_Topology, ulPropertyId, NULL, 0, &cbProperty);

    if(SUCCEEDED(hr) && !cbProperty)
    {
        DPF(DPFLVL_ERROR, "Property size is 0");
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr))
    {
        pvProperty = MEMALLOC_A(BYTE, cbProperty);
        hr = HRFROMP(pvProperty);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetProperty(hDevice, KSPROPSETID_Topology, ulPropertyId, pvProperty, cbProperty);
    }

    if(SUCCEEDED(hr))
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)pvProperty;
    }
    else
    {
        MEMFREE(pvProperty);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetPinPcmAudioDataRange
 *
 *  Description:
 *      Retrieves PCM audio data range for a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: pin id.
 *      PKSDATARANGE_AUDIO [out]: receives aggregate data range.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinPcmAudioDataRange"

HRESULT
KsGetPinPcmAudioDataRange
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PKSDATARANGE_AUDIO      pDataRange,
    BOOL                    fCapture
)
{
    PKSMULTIPLE_ITEM        pMultiItem      = NULL;
    PKSDATARANGE_AUDIO      pLocalDataRange;
    BOOL                    fFoundIt;
    HRESULT                 hr;

    DPF_ENTER();

    // Get supported data range(s)
    hr = KsGetMultiplePinProperties(hDevice, KSPROPERTY_PIN_DATARANGES, ulPinId, &pMultiItem);

    // Look for the audio data range(s)
    if(SUCCEEDED(hr))
    {
        for(pLocalDataRange = (PKSDATARANGE_AUDIO)(pMultiItem + 1), fFoundIt = FALSE; pMultiItem->Count; pMultiItem->Count--, pLocalDataRange = (PKSDATARANGE_AUDIO)((LPBYTE)pLocalDataRange + pLocalDataRange->DataRange.FormatSize))
        {
            if(pLocalDataRange->DataRange.MajorFormat == GUID_NULL ||
               pLocalDataRange->DataRange.MajorFormat == KSDATAFORMAT_TYPE_AUDIO)
            {
                if(pLocalDataRange->DataRange.SubFormat == GUID_NULL ||
                   pLocalDataRange->DataRange.SubFormat == KSDATAFORMAT_SUBTYPE_PCM)
                {
#ifdef NO_DSOUND_FORMAT_SPECIFIER
                    if (pLocalDataRange->DataRange.Specifier == KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
#else
                    // Note: we only use the DSOUND format specifier for render pins
                    if (pLocalDataRange->DataRange.Specifier == (fCapture ? KSDATAFORMAT_SPECIFIER_WAVEFORMATEX : KSDATAFORMAT_SPECIFIER_DSOUND))
#endif
                    {
                        // The pin may support multiple data ranges, so we'll
                        // use an aggregate of all the values
                        if(fFoundIt)
                        {
                            KsAggregatePinAudioDataRange(pLocalDataRange, pDataRange);
                        }
                        else
                        {
                            CopyMemory(pDataRange, pLocalDataRange, sizeof(*pDataRange));
                            fFoundIt = TRUE;
                        }
                    }
                }
            }
        }

        if(!fFoundIt)
        {
            DPF(DPFLVL_ERROR, "Can't find PCM audio data range on pin %u", ulPinId);
            hr = DSERR_GENERIC;
        }
    }

    // Clean up
    MEMFREE(pMultiItem);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsOpenSysAudioDevice
 *
 *  Description:
 *      Opens the system audio device device.
 *
 *  Arguments:
 *      LPHANDLE [out]: receives system audio device handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsOpenSysAudioDevice"

HRESULT
KsOpenSysAudioDevice
(
    LPHANDLE                    phDevice
)
{
    CPnpHelper *                pPnp                = NULL;
    SP_DEVICE_INTERFACE_DATA    DeviceInterfaceData;
    HRESULT                     hr;

    DPF_ENTER();

    // Create the PnP helper object
    pPnp = NEW(CPnpHelper);
    hr = HRFROMP(pPnp);

    if(SUCCEEDED(hr))
    {
        hr = pPnp->Initialize(KSCATEGORY_SYSAUDIO, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
    }

    // Get the first interface in the set
    if(SUCCEEDED(hr))
    {
        hr = pPnp->EnumDeviceInterface(KSCATEGORY_SYSAUDIO, 0, &DeviceInterfaceData);

        if(S_FALSE == hr)
        {
            DPF(DPFLVL_ERROR, "No interfaces matching KSCATEGORY_SYSAUDIO exist");
            hr = DSERR_NODRIVER;
        }
    }

    // Open the interface
    if(SUCCEEDED(hr))
    {
        hr = pPnp->OpenDeviceInterface(&DeviceInterfaceData, phDevice);
    }

    // Clean up
    RELEASE(pPnp);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetSysAudioProperty
 *
 *  Description:
 *      Gets a SAD property.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      ULONG [in]: property id.
 *      ULONG [in]: device index.
 *      LPVOID [out]: data buffer.
 *      ULONG [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetSysAudioProperty"

HRESULT
KsGetSysAudioProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulDeviceId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSSADPROPERTY           SadProperty;
    HRESULT                 hr;

    DPF_ENTER();

    SadProperty.Property.Set = KSPROPSETID_Sysaudio;
    SadProperty.Property.Id = ulPropertyId;
    SadProperty.Property.Flags = KSPROPERTY_TYPE_GET;

    SadProperty.DeviceId = ulDeviceId;
    SadProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &SadProperty, sizeof(SadProperty), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetSysAudioProperty
 *
 *  Description:
 *      Sets a SAD property.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      ULONG [in]: property id.
 *      ULONG [in]: device index.
 *      LPVOID [in]: data buffer.
 *      ULONG [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetSysAudioProperty"

HRESULT
KsSetSysAudioProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulDeviceId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSSADPROPERTY           SadProperty;
    HRESULT                 hr;

    DPF_ENTER();

    SadProperty.Property.Set = KSPROPSETID_Sysaudio;
    SadProperty.Property.Id = ulPropertyId;
    SadProperty.Property.Flags = KSPROPERTY_TYPE_SET;

    SadProperty.DeviceId = ulDeviceId;
    SadProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &SadProperty, sizeof(SadProperty), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsCreateSysAudioVirtualSource
 *
 *  Description:
 *      Create a virtual source on SAD.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      PULONG [out]: Virtual source index pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsCreateSysAudioVirtualSource"

HRESULT
KsCreateSysAudioVirtualSource
(
    HANDLE                          hDevice,
    PULONG                          pulVirtualSourceIndex
)
{
    SYSAUDIO_CREATE_VIRTUAL_SOURCE  CreateVirtualSource;
    HRESULT                         hr;

    DPF_ENTER();

    CreateVirtualSource.Property.Set = KSPROPSETID_Sysaudio;
    CreateVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
    CreateVirtualSource.Property.Flags = KSPROPERTY_TYPE_GET;

    CreateVirtualSource.PinCategory = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;
    CreateVirtualSource.PinName = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &CreateVirtualSource, sizeof(CreateVirtualSource), pulVirtualSourceIndex, sizeof(*pulVirtualSourceIndex));

    if(SUCCEEDED(hr) && MAX_ULONG == *pulVirtualSourceIndex)
    {
        hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsAttachVirtualSource
 *
 *  Description:
 *      Attachs a pin to a virtual source on SAD.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      ULONG [in]: virtual source index.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsAttachVirtualSource"

HRESULT
KsAttachVirtualSource
(
    HANDLE                          hDevice,
    ULONG                           ulVirtualSourceIndex
)
{
    SYSAUDIO_ATTACH_VIRTUAL_SOURCE  AttachVirtualSource;
    HRESULT                         hr;

    DPF_ENTER();

    AttachVirtualSource.Property.Set = KSPROPSETID_Sysaudio_Pin;
    AttachVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE;
    AttachVirtualSource.Property.Flags = KSPROPERTY_TYPE_SET;

    AttachVirtualSource.MixerPinId = ulVirtualSourceIndex;
    AttachVirtualSource.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &AttachVirtualSource, sizeof(AttachVirtualSource));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsCreateSysAudioVirtualSource
 *
 *  Description:
 *      Create a virtual source on SAD.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      PULONG [out]: Virtual source index pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSysAudioSelectGraph"

HRESULT
KsSysAudioSelectGraph
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    ULONG                   ulNodeId
)
{
    SYSAUDIO_SELECT_GRAPH   SelectGraph;
    HRESULT                 hr;

    DPF_ENTER();

    SelectGraph.Property.Set = KSPROPSETID_Sysaudio;
    SelectGraph.Property.Id = KSPROPERTY_SYSAUDIO_SELECT_GRAPH;
    SelectGraph.Property.Flags = KSPROPERTY_TYPE_SET;

    SelectGraph.PinId = ulPinId;
    SelectGraph.NodeId = ulNodeId;
    SelectGraph.Flags = 0;
    SelectGraph.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &SelectGraph, sizeof(SelectGraph), NULL, 0);

    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "KsSysAudioSelectGraph's IOCTL failed");
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsCancelPendingIrps
 *
 *  Description:
 *      Cancels any pending IRPs.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      PKSSTREAMIO [in/out]: stream IO data.
 *      BOOL [in]: TRUE to wait for all IRPs to complete.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsCancelPendingIrps"

HRESULT
KsCancelPendingIrps
(
    HANDLE                  hPin,
    PKSSTREAMIO             pKsStreamIo,
    BOOL                    fWait
)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwWait;

    DPF_ENTER();

    // Don't bother actually doing anything if there's no pending IRP(s).
    // If no KSSTREAMIO was provided, we'll just reset the pin state
    // without updating any information.
    if(!pKsStreamIo || pKsStreamIo->fPendingIrp)
    {
        // Don't wait if there's no known pending IRP(s)
        if(!pKsStreamIo)
        {
            fWait = FALSE;
        }

        // Begin the reset of the pin state
        hr = KsResetState(hPin, KSRESET_BEGIN);

        // Wait for completion of the outstanding IRP(s)
        if(SUCCEEDED(hr) && fWait)
        {
            dwWait = WaitObject(INFINITE, pKsStreamIo->Overlapped.hEvent);
            ASSERT(WAIT_OBJECT_0 == dwWait);

            ResetEvent(pKsStreamIo->Overlapped.hEvent);
        }

        // There is no longer any pending IRP(s)
        if(SUCCEEDED(hr) && pKsStreamIo)
        {
            pKsStreamIo->fPendingIrp = FALSE;
        }

        // End the pin state reset
        if(SUCCEEDED(hr))
        {
            hr = KsResetState(hPin, KSRESET_END);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsBuildAudioPinDescription
 *
 *  Description:
 *      Builds the description for a dsound pin.
 *
 *  Arguments:
 *      KSINTERFACE_STANDARD [in]: pin interface.
 *      ULONG [in]: pin instance id.
 *      LPWAVEFORMATEX [in]: pin format.
 *      PKSAUDIOPINDESC * [out]: receives pin description.  The caller is
 *                                  responsible for freeing this structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsBuildAudioPinDescription"

HRESULT
KsBuildAudioPinDescription
(
    KSINTERFACE_STANDARD    nInterface,
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
)
{
    PKSAUDIOPINDESC         pPinDesc;
    ULONG                   cbPinDesc;
    ULONG                   cbWfx = sizeof(WAVEFORMATEX);;
    HRESULT                 hr;

    DPF_ENTER();

    cbPinDesc = sizeof(*pPinDesc);

    if(pwfxFormat)
    {
        cbWfx = GetWfxSize(pwfxFormat, GENERIC_WRITE);

        if(cbWfx > sizeof(WAVEFORMATEX))
        {
            cbPinDesc += cbWfx - sizeof(WAVEFORMATEX);
        }
    }

    pPinDesc = (PKSAUDIOPINDESC)MEMALLOC_A(BYTE, cbPinDesc);
    hr = HRFROMP(pPinDesc);

    if(SUCCEEDED(hr))
    {
        pPinDesc->Connect.Interface.Set = KSINTERFACESETID_Standard;
        pPinDesc->Connect.Interface.Id = nInterface;

        pPinDesc->Connect.Medium.Set = KSMEDIUMSETID_Standard;
        pPinDesc->Connect.Medium.Id = KSMEDIUM_STANDARD_DEVIO;

        pPinDesc->Connect.PinId = ulPinId;

        pPinDesc->Connect.Priority.PriorityClass = KSPRIORITY_NORMAL;
        pPinDesc->Connect.Priority.PrioritySubClass = 1;

        pPinDesc->DataFormat.DataFormat.FormatSize = sizeof(pPinDesc->DataFormat) + cbWfx - sizeof(WAVEFORMATEX);

        pPinDesc->DataFormat.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;

        // Compute KSDATAFORMAT.SubFormat from WAVEFORMATEX
        if (pwfxFormat)
        {
            if (pwfxFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
            {
                PWAVEFORMATEXTENSIBLE pwfext = (PWAVEFORMATEXTENSIBLE)pwfxFormat;
                ASSERT(pwfxFormat->cbSize >= (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)));
                pPinDesc->DataFormat.DataFormat.SubFormat = pwfext->SubFormat;
            }
            else
            {
                INIT_WAVEFORMATEX_GUID(&pPinDesc->DataFormat.DataFormat.SubFormat, pwfxFormat->wFormatTag);
            }

            // KS1 kmixer has a bug that prevents SubFormat=IEEE_FLOAT from working
            // FIXME: this workaround should be restricted to some subset of platforms
            if (pPinDesc->DataFormat.DataFormat.SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
            {
                pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
            }
        }
        else
        {
            pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
        }

        pPinDesc->DataFormat.DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

        if(pwfxFormat)
        {
            pPinDesc->DataFormat.DataFormat.SampleSize = pwfxFormat->nBlockAlign;
            CopyWfx(pwfxFormat, &pPinDesc->DataFormat.WaveFormatEx);
        }

        *ppPinDesc = pPinDesc;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsBuildRenderPinDescription
 *
 *  Description:
 *      Builds the description for a dsound render pin.
 *
 *  Arguments:
 *      ULONG [in]: pin instance id.
 *      DWORD [in]: dsound buffer flags.
 *      LPWAVEFORMATEX [in]: pin format.
 *      PKSAUDIOPINDESC * [out]: receives pin description.  The caller is
 *                                responsible for freeing this structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsBuildRenderPinDescription"

#ifdef NO_DSOUND_FORMAT_SPECIFIER

HRESULT
KsBuildRenderPinDescription
(
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsBuildAudioPinDescription(KSINTERFACE_STANDARD_LOOPED_STREAMING, ulPinId, pwfxFormat, ppPinDesc);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#else // NO_DSOUND_FORMAT_SPECIFIER

HRESULT
KsBuildRenderPinDescription
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    PKSDSRENDERPINDESC *    ppPinDesc
)
{
    PKSDSRENDERPINDESC      pPinDesc;
    ULONG                   cbPinDesc;
    ULONG                   cbWfx = sizeof(WAVEFORMATEX);

    HRESULT                 hr;

    DPF_ENTER();

    cbPinDesc = sizeof(*pPinDesc);

    if(pwfxFormat)
    {
        cbWfx = GetWfxSize(pwfxFormat, GENERIC_WRITE);

        if(cbWfx > sizeof(WAVEFORMATEX))
        {
            cbPinDesc += cbWfx - sizeof(WAVEFORMATEX);
        }
    }

    pPinDesc = (PKSDSRENDERPINDESC)MEMALLOC_A(BYTE, cbPinDesc);
    hr = HRFROMP(pPinDesc);

    if(SUCCEEDED(hr))
    {
        pPinDesc->Connect.Interface.Set = KSINTERFACESETID_Standard;
        pPinDesc->Connect.Interface.Id = KSINTERFACE_STANDARD_LOOPED_STREAMING;

        pPinDesc->Connect.Medium.Set = KSMEDIUMSETID_Standard;
        pPinDesc->Connect.Medium.Id = KSMEDIUM_STANDARD_DEVIO;

        pPinDesc->Connect.PinId = ulPinId;

        pPinDesc->Connect.Priority.PriorityClass = KSPRIORITY_NORMAL;
        pPinDesc->Connect.Priority.PrioritySubClass = 1;

        pPinDesc->DataFormat.DataFormat.FormatSize = sizeof(pPinDesc->DataFormat) + cbWfx - sizeof(WAVEFORMATEX);

        pPinDesc->DataFormat.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;

        // Compute KSDATAFORMAT.SubFormat from WAVEFORMATEX
        if (pwfxFormat)
        {
            if (pwfxFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
            {
                PWAVEFORMATEXTENSIBLE pwfext = (PWAVEFORMATEXTENSIBLE)pwfxFormat;
                ASSERT(pwfxFormat->cbSize >= (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)));
                pPinDesc->DataFormat.DataFormat.SubFormat = pwfext->SubFormat;
            }
            else
            {
                INIT_WAVEFORMATEX_GUID(&pPinDesc->DataFormat.DataFormat.SubFormat, pwfxFormat->wFormatTag);
            }
            // KS1 kmixer has a bug that prevents SubFormat=IEEE_FLOAT from working
            // FIXME: this workaround should be restricted to some subset of platforms
            if (pPinDesc->DataFormat.DataFormat.SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
            {
                pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
            }
        }
        else
        {
            pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
        }

        pPinDesc->DataFormat.DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_DSOUND;

        pPinDesc->DataFormat.BufferDesc.Flags = DsBufferFlagsToKsPinFlags(dwFlags);
        pPinDesc->DataFormat.BufferDesc.Control = DsBufferFlagsToKsControlFlags(dwFlags, guid3dAlgorithm);

        if(pwfxFormat)
        {
            pPinDesc->DataFormat.DataFormat.SampleSize = pwfxFormat->nBlockAlign;
            CopyWfx(pwfxFormat, &pPinDesc->DataFormat.BufferDesc.WaveFormatEx);
        }

        *ppPinDesc = pPinDesc;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#ifndef WINNT
// This function is only used on WDM 1.0 (Windows 98)

HRESULT
KsBuildRenderPinDescription_10
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    PKSDSRENDERPINDESC_10 * ppPinDesc
)
{
    PKSDSRENDERPINDESC_10   pPinDesc;
    ULONG                   cbPinDesc;
    ULONG                   cbWfx = sizeof(WAVEFORMATEX);

    HRESULT                 hr;

    DPF_ENTER();

    cbPinDesc = sizeof(*pPinDesc);

    if(pwfxFormat)
    {
        cbWfx = GetWfxSize(pwfxFormat, GENERIC_WRITE);

        if(cbWfx > sizeof(WAVEFORMATEX))
        {
            cbPinDesc += cbWfx - sizeof(WAVEFORMATEX);
        }
    }

    pPinDesc = (PKSDSRENDERPINDESC_10)MEMALLOC_A(BYTE, cbPinDesc);
    hr = HRFROMP(pPinDesc);

    if(SUCCEEDED(hr))
    {
        pPinDesc->Connect.Interface.Set = KSINTERFACESETID_Standard;
        pPinDesc->Connect.Interface.Id = KSINTERFACE_STANDARD_LOOPED_STREAMING;

        pPinDesc->Connect.Medium.Set = KSMEDIUMSETID_Standard;
        pPinDesc->Connect.Medium.Id = KSMEDIUM_STANDARD_DEVIO;

        pPinDesc->Connect.PinId = ulPinId;

        pPinDesc->Connect.Priority.PriorityClass = KSPRIORITY_NORMAL;
        pPinDesc->Connect.Priority.PrioritySubClass = 1;

        pPinDesc->DataFormat.DataFormat.FormatSize = sizeof(pPinDesc->DataFormat) + cbWfx - sizeof(WAVEFORMATEX);

        pPinDesc->DataFormat.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;

        // Compute KSDATAFORMAT.SubFormat from WAVEFORMATEX
        if (pwfxFormat)
        {
            if (pwfxFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
            {
                PWAVEFORMATEXTENSIBLE pwfext = (PWAVEFORMATEXTENSIBLE)pwfxFormat;
                ASSERT(pwfxFormat->cbSize >= (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)));
                pPinDesc->DataFormat.DataFormat.SubFormat = pwfext->SubFormat;
            }
            else
            {
                INIT_WAVEFORMATEX_GUID(&pPinDesc->DataFormat.DataFormat.SubFormat, pwfxFormat->wFormatTag);
            }
            // KS1 kmixer has a bug that prevents SubFormat=IEEE_FLOAT from working
            // FIXME: this workaround should be restricted to some subset of platforms
            if (pPinDesc->DataFormat.DataFormat.SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
            {
                pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
            }
        }
        else
        {
            pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
        }

        pPinDesc->DataFormat.DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_DSOUND;

        pPinDesc->DataFormat.BufferDesc.Flags = DsBufferFlagsToKsPinFlags(dwFlags);
        pPinDesc->DataFormat.BufferDesc.Control = DsBufferFlagsToKsControlFlags(dwFlags, guid3dAlgorithm);
        pPinDesc->DataFormat.BufferDesc.BufferSize = 0; // Unused

        if(pwfxFormat)
        {
            pPinDesc->DataFormat.DataFormat.SampleSize = pwfxFormat->nBlockAlign;
            CopyWfx(pwfxFormat, &pPinDesc->DataFormat.BufferDesc.WaveFormatEx);
        }

        *ppPinDesc = pPinDesc;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // !WINNT

#endif // NO_DSOUND_FORMAT_SPECIFIER


/***************************************************************************
 *
 *  KsBuildCapturePinDescription
 *
 *  Description:
 *      Builds the description for a dsound capture pin.
 *
 *  Arguments:
 *      ULONG [in]: pin instance id.
 *      LPWAVEFORMATEX [in]: pin format.
 *      PPKSAUDIOPINDESC [out]: receives pin description.  The caller is
 *                                  responsible for freeing this structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsBuildCapturePinDescription"

HRESULT
KsBuildCapturePinDescription
(
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsBuildAudioPinDescription(KSINTERFACE_STANDARD_STREAMING, ulPinId, pwfxFormat, ppPinDesc);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsCreateAudioPin
 *
 *  Description:
 *      Creates a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSPIN_CONNECT [in]: pin description.
 *      ACCESS_MASK [in]: desired access flags.
 *      KSSTATE [in]: desired pin state.
 *      LPHANDLE [out]: receives pin handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsCreateAudioPin"

HRESULT
KsCreateAudioPin
(
    HANDLE                  hDevice,
    PKSPIN_CONNECT          pConnect,
    ACCESS_MASK             dwDesiredAccess,
    KSSTATE                 nState,
    LPHANDLE                phPin
)
{
    HANDLE                  hPin        = NULL;
    DWORD                   dwError;
    HRESULT                 hr;

    DPF_ENTER();

    dwError = DsKsCreatePin(hDevice, pConnect, dwDesiredAccess, &hPin);
    hr = WIN32ERRORtoHRESULT(dwError);

    if(FAILED(hr))
    {
        DPF(DPFLVL_MOREINFO, "KsCreatePin(PinId=%d) failed with %s (%lu)", pConnect->PinId, HRESULTtoSTRING(hr), dwError);
    }
    else
    {
        hr = KsTransitionState(hPin, KSSTATE_STOP, nState);
    }

    if(SUCCEEDED(hr))
    {
        *phPin = hPin;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsEnableEvent
 *
 *  Description:
 *      Enables a KS event.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: Property set id.
 *      ULONG [in]: property id.
 *      PKSEVENTDATA [in]: event data.
 *      ULONG [in]: event data size.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsEnableEvent"

HRESULT
KsEnableEvent
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulProperty,
    PKSEVENTDATA            pEventData,
    ULONG                   cbEventData
)
{
    KSEVENT                 Event;
    HRESULT                 hr;

    DPF_ENTER();

    Event.Set = guidPropertySet;
    Event.Id = ulProperty;
    Event.Flags = KSEVENT_TYPE_ENABLE;

    hr = PostDevIoctl(hDevice, IOCTL_KS_ENABLE_EVENT, &Event, sizeof(Event), pEventData, cbEventData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsDisableEvent
 *
 *  Description:
 *      Disables a KS event.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSEVENTDATA [in]: event data.
 *      ULONG [in]: event data size.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsDisableEvent"

HRESULT
KsDisableEvent
(
    HANDLE                  hDevice,
    PKSEVENTDATA            pEventData,
    ULONG                   cbEventData
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = PostDevIoctl(hDevice, IOCTL_KS_DISABLE_EVENT, pEventData, cbEventData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsEnablePositionEvent
 *
 *  Description:
 *      Enables a KS LOOPED_STREAMING position event.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      QWORD [in]: position offset, in samples.
 *      HANDLE [in]: event handle.
 *      PLOOPEDSTREAMING_POSITION_EVENT_DATA [in/out]: receives event data.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsEnablePositionEvent"

HRESULT
KsEnablePositionEvent
(
    HANDLE                                  hDevice,
    QWORD                                   qwSample,
    HANDLE                                  hEvent,
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pNotify
)
{
    HRESULT                                 hr;

    DPF_ENTER();

    // KS requires that the event data sent to the event enable and disable
    // IOCTLs be at the same location in memory.
    pNotify->KsEventData.NotificationType = KSEVENTF_EVENT_HANDLE;
    pNotify->KsEventData.EventHandle.Event = hEvent;
    pNotify->KsEventData.EventHandle.Reserved[0] = 0;
    pNotify->KsEventData.EventHandle.Reserved[1] = 0;

    pNotify->Position = qwSample;

    hr = KsEnableEvent(hDevice, KSEVENTSETID_LoopedStreaming, KSEVENT_LOOPEDSTREAMING_POSITION, &pNotify->KsEventData, sizeof(*pNotify));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsDisablePositionEvent
 *
 *  Description:
 *      Disables a KS LOOPED_STREAMING position event.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PLOOPEDSTREAMING_POSITION_EVENT_DATA [in]: event data.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsDisablePositionEvent"

HRESULT
KsDisablePositionEvent
(
    HANDLE                                  hDevice,
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pNotify
)
{
    HRESULT                                 hr;

    DPF_ENTER();

    // KS requires that the event data sent to the event enable and disable
    // IOCTLs be at the same location in memory.
    hr = KsDisableEvent(hDevice, &pNotify->KsEventData, sizeof(*pNotify));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetCpuResources
 *
 *  Description:
 *      Determines whether or not the node uses the host CPU resources.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: node id.
 *      PULONG [out]: receives the CPU resources value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetCpuResources"

HRESULT
KsGetCpuResources
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PULONG                  pulCpuResources
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetNodeProperty(hDevice, KSPROPSETID_Audio, KSPROPERTY_AUDIO_CPU_RESOURCES, ulNodeId, pulCpuResources, sizeof(*pulCpuResources));

    if(FAILED(hr))
    {
        // Changed this to a warning because it's very frequent and non-critical
        DPF(DPFLVL_WARNING, "Unable to get CPU resources for node %lu", ulNodeId);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetSupportedFormats
 *
 *  Description:
 *      Converts a KSDATARANGE_AUDIO structure into a DWORD compatible with
 *      waveInGetDevCaps
 *
 *  Arguments:
 *      PKSDATARANGE_AUDIO [in]: data range audio struct describing
 *                               capapabilities of audio pin
 *
 *  Returns:
 *      DWORD: describes caps of audio pin
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetSupportedFormats"

DWORD KsGetSupportedFormats
(
    PKSDATARANGE_AUDIO      pDataRange
)
{
    DWORD                   dwSamples   = 0;
    DWORD                   dwChannels  = 0;
    DWORD                   dwBits      = 0;

    DPF_ENTER();

    // The WAVE_FORMAT_XXXX flags are bit flags
    //
    // So we take advantage of that by determining three
    // sets of information:
    // - frequencies that are in the valid range
    // - valid bits per sample
    // - number of channels
    //
    // We than bitwise-AND the three values to get
    // the intersection of valid formats
    //

    // Is 11.025 KHz valid?
    if(pDataRange->MinimumSampleFrequency <= 11025 && pDataRange->MaximumSampleFrequency >= 11025)
    {
        dwSamples |= WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08 | WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16;
    }

    // Is 22.05 KHz valid?
    if(pDataRange->MinimumSampleFrequency <= 22050 && pDataRange->MaximumSampleFrequency >= 22050)
    {
        dwSamples |= WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08 | WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16;
    }

    // Is 44.1KHz valid?
    if(pDataRange->MinimumSampleFrequency <= 44100 && pDataRange->MaximumSampleFrequency >= 44100)
    {
        dwSamples |= WAVE_FORMAT_4M08 | WAVE_FORMAT_4S08 | WAVE_FORMAT_4M16 | WAVE_FORMAT_4S16;
    }

    // Is 8 bit per sample valid?
    if(pDataRange->MinimumBitsPerSample <= 8 && pDataRange->MaximumBitsPerSample >= 8)
    {
        dwBits |= WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08 | WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08 | WAVE_FORMAT_4M08 | WAVE_FORMAT_4S08;
    }

    // Is 16 bits per sample valid?
    if(pDataRange->MinimumBitsPerSample <= 16 && pDataRange->MaximumBitsPerSample >= 16)
    {
        dwBits |= WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16 | WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16 | WAVE_FORMAT_4M16 | WAVE_FORMAT_4S16;
    }

    // Is one channel (aka mono sound) valid?
    if(pDataRange->MaximumChannels >= 1)
    {
        dwChannels |= WAVE_FORMAT_1M08 | WAVE_FORMAT_1M16 | WAVE_FORMAT_2M08 | WAVE_FORMAT_2M16 | WAVE_FORMAT_4M08 | WAVE_FORMAT_4M16;
    }

    // Are two channels (aka stereo sound) valid?
    if(pDataRange->MaximumChannels >= 2)
    {
        dwChannels |= WAVE_FORMAT_1S08 | WAVE_FORMAT_1S16 | WAVE_FORMAT_2S08 | WAVE_FORMAT_2S16 | WAVE_FORMAT_4S08 | WAVE_FORMAT_4S16;
    }

    dwSamples = dwSamples & dwBits & dwChannels;

#ifdef DEBUG

    // Let's double check our result using a simpler method
    DWORD dwFormats = 0;

    if(pDataRange->MinimumSampleFrequency <= 11025 && pDataRange->MaximumSampleFrequency >= 11025)
    {
        if(pDataRange->MinimumBitsPerSample <= 8 && pDataRange->MaximumBitsPerSample >= 8)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_1M08;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_1S08;
            }
        }

        if(pDataRange->MinimumBitsPerSample <= 16 && pDataRange->MaximumBitsPerSample >= 16)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_1M16;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_1S16;
            }
        }
    }

    if(pDataRange->MinimumSampleFrequency <= 22050 && pDataRange->MaximumSampleFrequency >= 22050)
    {
        if(pDataRange->MinimumBitsPerSample <= 8 && pDataRange->MaximumBitsPerSample >= 8)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_2M08;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_2S08;
            }
        }

        if(pDataRange->MinimumBitsPerSample <= 16 && pDataRange->MaximumBitsPerSample >= 16)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_2M16;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_2S16;
            }
        }
    }

    if(pDataRange->MinimumSampleFrequency <= 44100 && pDataRange->MaximumSampleFrequency >= 44100)
    {
        if(pDataRange->MinimumBitsPerSample <= 8 && pDataRange->MaximumBitsPerSample >= 8)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_4M08;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_4S08;
            }
        }

        if(pDataRange->MinimumBitsPerSample <= 16 && pDataRange->MaximumBitsPerSample >= 16)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_4M16;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_4S16;
            }
        }
    }

    ASSERT(dwFormats == dwSamples);

#endif

    DPF_LEAVE(dwSamples);
    return dwSamples;
}


/***************************************************************************
 *
 *  KsGetDeviceInterfaceName
 *
 *  Description:
 *      Gets the device interface name.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: device id.
 *      LPTSTR * [out]: receives pointer to interface name.  This pointer
 *                      must be freed by the caller.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetDeviceInterfaceName"

HRESULT
KsGetDeviceInterfaceName
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId,
    LPTSTR *                ppszInterfaceName
)
{

#ifdef WINNT

    const LPCTSTR           pszMask0        = TEXT("\\??");
    const LPCTSTR           pszMask3        = TEXT("\\\\?");

#else // WINNT

    const LPCTSTR           pszMask0        = TEXT("\\DosDevices");
    const LPCTSTR           pszMask3        = TEXT("\\\\.");

#endif // WINNT

    const ULONG             ccMask0         = lstrlen(pszMask0);
    const ULONG             ccMask3         = lstrlen(pszMask3);
    LPWSTR                  pszInterfaceW   = NULL;
    LPTSTR                  pszInterface0   = NULL;
    LPTSTR                  pszInterface3   = NULL;
    HANDLE                  hInterface      = NULL;
    ULONG                   cbInterfaceW;
    ULONG                   ccInterface0;
    ULONG                   ccInterface3;
    HRESULT                 hr;

    DPF_ENTER();

    // Get the device interface name
    hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME, ulDeviceId, NULL, 0, &cbInterfaceW);

    if(SUCCEEDED(hr) && !cbInterfaceW)
    {
        DPF(DPFLVL_ERROR, "Interface size is 0");
        hr = DSERR_GENERIC;
    }

    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Unable to get device interface name size");
    }

    if(SUCCEEDED(hr))
    {
        pszInterfaceW = (LPWSTR)MEMALLOC_A(BYTE, cbInterfaceW);
        hr = HRFROMP(pszInterfaceW);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME, ulDeviceId, pszInterfaceW, cbInterfaceW);

        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "Unable to get device interface name");
        }
    }

    if(SUCCEEDED(hr))
    {
        pszInterface0 = UnicodeToTcharAlloc(pszInterfaceW);
        hr = HRFROMP(pszInterface0);
    }

    // Convert the device name to its ring-3 equivalent
    if(SUCCEEDED(hr))
    {
        ccInterface0 = lstrlen(pszInterface0) + 1;
        ccInterface3 = ccInterface0 - ccMask0 + ccMask3;

        pszInterface3 = MEMALLOC_A(TCHAR, ccInterface3);
        hr = HRFROMP(pszInterface3);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(ccInterface0 > ccMask0);
        ASSERT(CompareMemory(pszInterface0, pszMask0, ccMask0 * sizeof(TCHAR)));

        lstrcpy(pszInterface3, pszMask3);
        lstrcat(pszInterface3, pszInterface0 + ccMask0);
    }

    if(SUCCEEDED(hr))
    {
        *ppszInterfaceName = pszInterface3;
    }
    else
    {
        MEMFREE(pszInterface3);
    }

    MEMFREE(pszInterface0);
    MEMFREE(pszInterfaceW);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetDeviceFriendlyName
 *
 *  Description:
 *      Gets a KS device's friendly name.
 *
 *  Arguments:
 *      HANDLE [in]: sysaudio device handle.
 *      ULONG [in]: device id.
 *      LPTSTR * [out]: receives friendly name.  The caller is responsible
 *                      for freeing this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetDeviceFriendlyName"

HRESULT
KsGetDeviceFriendlyName
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId,
    LPTSTR *                ppszName
)
{
    KSCOMPONENTID           ComponentId;
    LPTSTR                  pszName     = NULL;
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_COMPONENT_ID, ulDeviceId, &ComponentId, sizeof(ComponentId));

    if(SUCCEEDED(hr))
    {
        HKEY hkeyName;
        TCHAR NameGuidString[80];

        wsprintf(NameGuidString, TEXT(DPF_GUID_STRING), DPF_GUID_VAL(ComponentId.Name));

        hr = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyName, 0, 2, REGSTR_MEDIACATEGORIES, NameGuidString);

        if(SUCCEEDED(hr))
        {
            pszName = (LPTSTR)MEMALLOC_A(TCHAR, MAXNAME);
            hr = HRFROMP(pszName);

            if(SUCCEEDED(hr))
            {
                hr = RhRegGetStringValue(hkeyName, REGSTR_NAME, pszName, MAXNAME);
            }

            if(FAILED(hr))
            {
                DPF(DPFLVL_MOREINFO, "Failed to find Name GUID in registry for this Component ID");
                MEMFREE(pszName);
            }

            // Clean up
            RhRegCloseKey(&hkeyName);
        }
    }

    //  If the Component ID method failed, fall back on the friendly name method
    if(FAILED(hr))
    {
        LPWSTR pszNameW = NULL;
        ULONG cbName;

        hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME, ulDeviceId, NULL, 0, &cbName);

        if(SUCCEEDED(hr))
        {
            pszNameW = (LPWSTR)MEMALLOC_A(BYTE, cbName);
            hr = HRFROMP(pszNameW);
        }

        if(SUCCEEDED(hr))
        {
            hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME, ulDeviceId, pszNameW, cbName);
        }

        if(SUCCEEDED(hr))
        {
            pszName = UnicodeToTcharAlloc(pszNameW);
            hr = HRFROMP(pszName);
        }

        MEMFREE(pszNameW);
    }

    if(SUCCEEDED(hr))
    {
        *ppszName = pszName;
    }
    else
    {
        MEMFREE(pszName);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetDeviceDriverPathAndDevnode
 *
 *  Description:
 *      Gets the fully qualified path for a KS device driver.
 *
 *  Arguments:
 *      LPTSTR [in]: interface path.
 *      LPTSTR * [out]: receives driver path.  The caller is responsible
 *                      for freeing this buffer.
 *      LPDWORD [out]: receives devnode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetDeviceDriverPathAndDevnode"

HRESULT
KsGetDeviceDriverPathAndDevnode
(
    LPCTSTR                     pszInterface,
    LPTSTR *                    ppszPath,
    LPDWORD                     pdwDevnode
)
{

#ifdef WINNT

    const LPCTSTR               pszDotSys           = TEXT(".sys");
    LPTSTR                      pszService          = NULL;
    SC_HANDLE                   hscManager          = NULL;
    SC_HANDLE                   hscService          = NULL;
    LPQUERY_SERVICE_CONFIG      pqsc                = NULL;
    DWORD                       cbRequired;
    BOOL                        f;

#else // WINNT

    HKEY                        hkey                = NULL;
    SP_DEVINFO_DATA             DeviceInfoData;

#endif // WINNT

    CPnpHelper *                pPnp                = NULL;
    LPTSTR                      pszPath             = NULL;
    DWORD                       dwDevnode           = 0;
    LPTSTR                      pszName             = NULL;
    HRESULT                     hr;

    DPF_ENTER();

    // Create the PnP helper object
    pPnp = NEW(CPnpHelper);
    hr = HRFROMP(pPnp);

    if(SUCCEEDED(hr))
    {
        hr = pPnp->Initialize(KSCATEGORY_AUDIO, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
    }

#ifdef WINNT

    // Get the device's service name
    if(SUCCEEDED(hr))
    {
        hr = pPnp->GetDeviceInterfaceRegistryProperty(pszInterface, KSCATEGORY_AUDIO, SPDRP_SERVICE, NULL, NULL, 0, &cbRequired);
    }

    if(SUCCEEDED(hr))
    {
        pszService = (LPTSTR)MEMALLOC_A(BYTE, cbRequired);
        hr = HRFROMP(pszService);
    }

    if(SUCCEEDED(hr))
    {
        hr = pPnp->GetDeviceInterfaceRegistryProperty(pszInterface, KSCATEGORY_AUDIO, SPDRP_SERVICE, NULL, pszService, cbRequired, &cbRequired);
    }

    if(SUCCEEDED(hr))
    {
        // Open default database on local machine
        hscManager = OpenSCManager(NULL, NULL, GENERIC_READ);

        if(!hscManager)
        {
            DPF(DPFLVL_ERROR, "Unable to open SC manager");
            hr = DSERR_GENERIC;
        }

        // Open the specific service
        if(SUCCEEDED(hr))
        {
            hscService = OpenService(hscManager, pszService, GENERIC_READ);

            if(!hscService)
            {
                DPF(DPFLVL_ERROR, "Unable to open service \"%s\"", pszService);
                hr = DSERR_GENERIC;
            }
        }

        // Try to get the binary path name
        if(SUCCEEDED(hr))
        {
            f = QueryServiceConfig(hscService, NULL, 0, &cbRequired);

            if(f || ERROR_INSUFFICIENT_BUFFER != GetLastError())
            {
                DPF(DPFLVL_ERROR, "Error %lu ocurred trying to get service config size", GetLastError());
                hr = DSERR_GENERIC;
            }
        }

        if(SUCCEEDED(hr))
        {
            pqsc = (LPQUERY_SERVICE_CONFIG)MEMALLOC_A(BYTE, cbRequired);
            hr = HRFROMP(pqsc);
        }

        if(SUCCEEDED(hr))
        {
            f = QueryServiceConfig(hscService, pqsc, cbRequired, &cbRequired);

            if(!f)
            {
                DPF(DPFLVL_ERROR, "Error %lu ocurred trying to get service config", GetLastError());
                hr = DSERR_GENERIC;
            }
        }

        // Create the full path
        //
        if(SUCCEEDED(hr))
        {
            // We only want the base part of the path
            //
            pszName = _tcsrchr(pqsc->lpBinaryPathName, TCHAR('\\'));
            if (pszName == NULL)
            {
                pszName = pqsc->lpBinaryPathName;
            }
            else
            {
                pszName++;
            }
            pszPath = TcharToTcharAlloc(pszName);
            hr = HRFROMP(pszPath);
        }
        else
        {
            pszPath = MEMALLOC_A(TCHAR, lstrlen(pszService) + lstrlen(pszDotSys) + 1);
            hr = HRFROMP(pszPath);

            if(SUCCEEDED(hr))
            {
                lstrcat(pszPath, pszService);
                lstrcat(pszPath, pszDotSys);
            }
        }
    }

    // Clean up
    MEMFREE(pqsc);
    MEMFREE(pszService);

    if(hscService)
    {
        CloseServiceHandle(hscService);
    }

    if(hscManager)
    {
        CloseServiceHandle(hscManager);
    }

#else // WINNT

    // Allocate memory
    if(SUCCEEDED(hr))
    {
        pszPath = MEMALLOC_A(TCHAR, MAX_PATH);
        hr = HRFROMP(pszPath);
    }

    // Get the interface's device info data
    if(SUCCEEDED(hr))
    {
        hr = pPnp->GetDeviceInterfaceDeviceInfo(pszInterface, KSCATEGORY_AUDIO, &DeviceInfoData);
    }

    // Save the devnode
    if(SUCCEEDED(hr))
    {
        dwDevnode = DeviceInfoData.DevInst;
    }

    // Open the device registry key
    if(SUCCEEDED(hr))
    {
        hr = pPnp->OpenDeviceRegistryKey(&DeviceInfoData, DIREG_DRV, FALSE, &hkey);
    }

    // Get the driver filename
    if(SUCCEEDED(hr))
    {
        hr = RhRegGetStringValue(hkey, TEXT("Driver"), pszPath, MAX_PATH * sizeof(TCHAR));
    }

    // Clean up
    RhRegCloseKey(&hkey);

#endif // WINNT

    RELEASE(pPnp);

    // Success
    if(SUCCEEDED(hr))
    {
        *ppszPath = pszPath;
        *pdwDevnode = dwDevnode;
    }
    else
    {
        MEMFREE(pszPath);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsIsUsablePin
 *
 *  Description:
 *      Determines if a pin is usable by DirectSound.
 *
 *  Arguments:
 *      HANDLE [in]: system audio device handle.
 *      ULONG [in]: pin id.  It's assumed that the proper device is already
 *                  set up as the default.
 *      KSPIN_DATAFLOW [in]: pin data flow.
 *      KSPIN_COMMUNICATION [in]: pin communication.
 *      PKSAUDIOPINDESC [in]: pin description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.  Returns DS_OK if the device
 *               is usable, S_FALSE if it is not.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsIsUsablePin"

HRESULT
KsIsUsablePin
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    KSPIN_DATAFLOW          PinDataFlow,
    KSPIN_COMMUNICATION     PinCommunication,
    PKSAUDIOPINDESC         pPinDesc
)
{
    PKSMULTIPLE_ITEM        pMultiItem      = NULL;
    PKSPIN_INTERFACE        pInterface;
    PKSPIN_MEDIUM           pMedium;
    PKSDATARANGE            pDataRange;
    KSPIN_DATAFLOW          DataFlow;
    KSPIN_COMMUNICATION     Communication;
    HRESULT                 hr;

    DPF_ENTER();

#ifdef DEBUG
    static const TCHAR* pszDataFlows[] = {TEXT("Invalid"), TEXT("In"), TEXT("Out")};
    static const TCHAR* pszCommunications[] = {TEXT("None"), TEXT("Sink"), TEXT("Source"), TEXT("Both"), TEXT("Bridge")};
#endif

    // Check data flow
    hr = KsGetPinProperty(hDevice, KSPROPERTY_PIN_DATAFLOW, ulPinId, &DataFlow, sizeof(DataFlow));

    if(SUCCEEDED(hr))
    {
        if(DataFlow != PinDataFlow)
        {
            DPF(DPFLVL_MOREINFO, "Pin %lu does not support dataflow (%s; wanted %s)", ulPinId, pszDataFlows[DataFlow], pszDataFlows[PinDataFlow]);
            hr = S_FALSE;
        }
    }
    else
    {
        DPF(DPFLVL_ERROR, "Can't get pin dataflow");
    }

    // Check communication type
    if(DS_OK == hr)
    {
        hr = KsGetPinProperty(hDevice, KSPROPERTY_PIN_COMMUNICATION, ulPinId, &Communication, sizeof(Communication));

        if(SUCCEEDED(hr))
        {
            if(Communication != PinCommunication)
            {
                DPF(DPFLVL_MOREINFO, "Pin %lu does not support communication (%s; wanted %s)", ulPinId, pszCommunications[Communication], pszCommunications[PinCommunication]);
                hr = S_FALSE;
            }
        }
        else
        {
            DPF(DPFLVL_ERROR, "Can't get pin communication");
        }
    }

    // Check interfaces
    if(DS_OK == hr)
    {
        hr = KsGetMultiplePinProperties(hDevice, KSPROPERTY_PIN_INTERFACES, ulPinId, &pMultiItem);

        if(SUCCEEDED(hr))
        {
            for(pInterface = (PKSPIN_INTERFACE)(pMultiItem + 1), hr = S_FALSE; pMultiItem->Count; pInterface++, pMultiItem->Count--)
            {
                if(pInterface->Set == pPinDesc->Connect.Interface.Set && pInterface->Id == pPinDesc->Connect.Interface.Id)
                {
                    hr = DS_OK;
                    break;
                }
            }

            if(S_FALSE == hr)
            {
                DPF(DPFLVL_MOREINFO, "Pin %lu does not support interface", ulPinId);
            }
        }
        else
        {
            DPF(DPFLVL_ERROR, "Can't get pin interfaces");
        }

        MEMFREE(pMultiItem);
    }

    // Check mediums
    if(DS_OK == hr)
    {
        hr = KsGetMultiplePinProperties(hDevice, KSPROPERTY_PIN_MEDIUMS, ulPinId, &pMultiItem);

        if(SUCCEEDED(hr))
        {
            for(pMedium = (PKSPIN_MEDIUM)(pMultiItem + 1), hr = S_FALSE; pMultiItem->Count; pMedium++, pMultiItem->Count--)
            {
                if(pMedium->Set == pPinDesc->Connect.Medium.Set && pMedium->Id == pPinDesc->Connect.Medium.Id)
                {
                    hr = DS_OK;
                    break;
                }
            }

            if(S_FALSE == hr)
            {
                DPF(DPFLVL_MOREINFO, "Pin %lu does not support medium", ulPinId);
            }
        }
        else
        {
            DPF(DPFLVL_ERROR, "Can't get pin mediums");
        }

        MEMFREE(pMultiItem);
    }

    // Check dataranges
    if(DS_OK == hr)
    {
        hr = KsGetMultiplePinProperties(hDevice, KSPROPERTY_PIN_DATARANGES, ulPinId, &pMultiItem);

        if(SUCCEEDED(hr))
        {
            for(pDataRange = (PKSDATARANGE)(pMultiItem + 1), hr = S_FALSE; pMultiItem->Count; pDataRange = (PKSDATARANGE)((LPBYTE)pDataRange + pDataRange->FormatSize), pMultiItem->Count--)
            {
                if(pDataRange->MajorFormat == pPinDesc->DataFormat.DataFormat.MajorFormat && pDataRange->Specifier == pPinDesc->DataFormat.DataFormat.Specifier)
                {
                    hr = DS_OK;
                    break;
                }
            }

            if(S_FALSE == hr)
            {
                DPF(DPFLVL_MOREINFO, "Pin %lu does not support data range", ulPinId);
            }
        }
        else
        {
            DPF(DPFLVL_ERROR, "Can't get pin dataranges");
        }

        MEMFREE(pMultiItem);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsEnumDevicePins
 *
 *  Description:
 *      Builds a list of available audio pins on the current device.
 *
 *  Arguments:
 *      HANDLE [in]: system audio device handle.
 *      BOOL [in]: TRUE if capture.
 *      ULONG ** [out]: receives array of valid pins.
 *      ULONG [in]: count of pins on the device.
 *      PULONG [out]: receives count of valid pins.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsEnumDevicePins"

HRESULT
KsEnumDevicePins
(
    HANDLE                      hDevice,
    BOOL                        fCapture,
    ULONG **                    ppulValidPinIds,
    ULONG                       ulPinCount,
    PULONG                      pulValidPinCount
)
{
    const KSPIN_DATAFLOW        nDataFlow       = fCapture ? KSPIN_DATAFLOW_CAPTURE : KSPIN_DATAFLOW_RENDER;
    const KSPIN_COMMUNICATION   nCommunication  = KSPIN_COMMUNICATION_SINK;
    PKSAUDIOPINDESC             pPinDesc        = NULL;
    ULONG *                     pulPinIds       = NULL;
    HRESULT                     hr              = DS_OK;

    DPF_ENTER();
    ASSERT(pulValidPinCount);

    *pulValidPinCount = 0;

    if(ppulValidPinIds)
    {
        pulPinIds = MEMALLOC_A(ULONG, ulPinCount);
        hr = HRFROMP(pulPinIds);
    }

    if (SUCCEEDED(hr))
    {
        // Build the pin description
        if(fCapture)
        {
            hr = KsBuildCapturePinDescription(-1, NULL, &pPinDesc);
        }
        else
        {

#ifdef NO_DSOUND_FORMAT_SPECIFIER
            hr = KsBuildRenderPinDescription(-1, NULL, &pPinDesc);
#else // NO_DSOUND_FORMAT_SPECIFIER
#ifndef WINNT
            if (g_ulWdmVersion == WDM_1_0)
            {
                hr = KsBuildRenderPinDescription_10(-1, 0, NULL, GUID_NULL, (PKSDSRENDERPINDESC_10 *)&pPinDesc);
            }
            else
#endif // !WINNT
            {
                hr = KsBuildRenderPinDescription(-1, 0, NULL, GUID_NULL, (PKSDSRENDERPINDESC *)&pPinDesc);
            }
#endif // NO_DSOUND_FORMAT_SPECIFIER

        }

        // Examine each pin to determine if it suits our needs
        for(ULONG ulPinId = 0; SUCCEEDED(hr) && ulPinId < ulPinCount; ulPinId++)
        {
            hr = KsIsUsablePin(hDevice, ulPinId, nDataFlow, nCommunication, pPinDesc);
            if(hr == DS_OK)
            {
                if(pulPinIds)
                {
                    pulPinIds[*pulValidPinCount] = ulPinId;
                }
                ++*pulValidPinCount;
            }
        }

        if(SUCCEEDED(hr) && ppulValidPinIds)
        {
            *ppulValidPinIds = MEMALLOC_A(ULONG, *pulValidPinCount);
            hr = HRFROMP(*ppulValidPinIds);

            if(SUCCEEDED(hr))
            {
                CopyMemory(*ppulValidPinIds, pulPinIds, *pulValidPinCount * sizeof(ULONG));
            }
        }

        // Clean up
        MEMFREE(pPinDesc);
        MEMFREE(pulPinIds);

        // Useful logging info
        #ifdef DEBUG
        if (ppulValidPinIds)
        {
            const int nMaxPins = 100;   // Limitation OK - only affects internal builds
            const int nPinStrLen = 3;   // Space for 1 space character and 2 digits
            TCHAR szValidPins[nPinStrLen * nMaxPins];
            for (ULONG i=0; i < MIN(nMaxPins, *pulValidPinCount); ++i)
                wsprintf(szValidPins + i*nPinStrLen, TEXT(" %2d"), (*ppulValidPinIds)[i]);
            DPF(DPFLVL_INFO, "Found %d valid %s pins:%s", *pulValidPinCount, fCapture ? TEXT("capture") : TEXT("render"), szValidPins);
        }
        else
        {
            DPF(DPFLVL_INFO, "Found %d valid %s pins", *pulValidPinCount, fCapture ? TEXT("capture") : TEXT("render"));
        }
        #endif // DEBUG

        // Let's not propagate a success code other than DS_OK
        if(SUCCEEDED(hr))
        {
            hr = DS_OK;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetChannelProperty
 *
 *  Description:
 *      Gets a property for a particular channel on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      ULONG [in]: volume node id.
 *      ULONG [in]: channel index or -1 for master.
 *      LPVOID [out]: receives data.
 *      ULONG [in]: data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetChannelProperty"

HRESULT
KsGetChannelProperty
(
    HANDLE                          hPin,
    GUID                            guidPropertySet,
    ULONG                           ulPropertyId,
    ULONG                           ulNodeId,
    ULONG                           ulChannelId,
    LPVOID                          pvData,
    ULONG                           cbData,
    PULONG                          pcbDataReturned
)
{
    KSNODEPROPERTY_AUDIO_CHANNEL    Channel;
    HRESULT                         hr;

    DPF_ENTER();

    Channel.NodeProperty.Property.Set = guidPropertySet;
    Channel.NodeProperty.Property.Id = ulPropertyId;
    Channel.NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    Channel.NodeProperty.NodeId = ulNodeId;
    Channel.NodeProperty.Reserved = 0;

    Channel.Channel = ulChannelId;
    Channel.Reserved = 0;

    hr = PostDevIoctl(hPin, IOCTL_KS_PROPERTY, &Channel, sizeof(Channel), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetChannelProperty
 *
 *  Description:
 *      Sets a property for a particular channel on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      ULONG [in]: volume node id.
 *      ULONG [in]: channel index or -1 for master.
 *      LPVOID [in]: data.
 *      ULONG [in]: data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetChannelProperty"

HRESULT
KsSetChannelProperty
(
    HANDLE                          hPin,
    GUID                            guidPropertySet,
    ULONG                           ulPropertyId,
    ULONG                           ulNodeId,
    ULONG                           ulChannelId,
    LPVOID                          pvData,
    ULONG                           cbData
)
{
    KSNODEPROPERTY_AUDIO_CHANNEL    Channel;
    HRESULT                         hr;

    DPF_ENTER();

    Channel.NodeProperty.Property.Set = guidPropertySet;
    Channel.NodeProperty.Property.Id = ulPropertyId;
    Channel.NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    Channel.NodeProperty.NodeId = ulNodeId;
    Channel.NodeProperty.Reserved = 0;

    Channel.Channel = ulChannelId;
    Channel.Reserved = 0;

    hr = PostDevIoctl(hPin, IOCTL_KS_PROPERTY, &Channel, sizeof(Channel), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetPinMute
 *
 *  Description:
 *      Gets the mute state for a pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      ULONG [in]: volume node id.
 *      LPBOOL [out]: receives mute state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinMute"

HRESULT
KsGetPinMute
(
    HANDLE                  hPin,
    ULONG                   ulNodeId,
    LPBOOL                  pfMute
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetChannelProperty(hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MUTE, ulNodeId, -1, pfMute, sizeof(*pfMute));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetPinMute
 *
 *  Description:
 *      Sets the mute state for a pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      ULONG [in]: volume node id.
 *      BOOL [in]: mute state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetPinMute"

HRESULT
KsSetPinMute
(
    HANDLE                  hPin,
    ULONG                   ulNodeId,
    BOOL                    fMute
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsSetChannelProperty(hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MUTE, ulNodeId, -1, &fMute, sizeof(fMute));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetBasicSupport
 *
 *  Description:
 *      Gets a range for a given KS property.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: pin id.
 *      PKSPROPERTY_DESCRIPTION * [out]: receives property description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetBasicSupport"

HRESULT
KsGetBasicSupport
(
    HANDLE                      hDevice,
    REFGUID                     guidPropertySet,
    ULONG                       ulPropertyId,
    ULONG                       ulNodeId,
    PKSPROPERTY_DESCRIPTION *   ppPropDesc
)
{
    PKSPROPERTY_DESCRIPTION     pPropDesc       = NULL;
    KSNODEPROPERTY              NodeProperty;
    KSPROPERTY_DESCRIPTION      Description;
    HRESULT                     hr;

    DPF_ENTER();

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), &Description, sizeof(Description));

    if(SUCCEEDED(hr) && !Description.DescriptionSize)
    {
        DPF(DPFLVL_ERROR, "Description size is 0");
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr))
    {
        pPropDesc = (PKSPROPERTY_DESCRIPTION)MEMALLOC_A(BYTE, Description.DescriptionSize);
        hr = HRFROMP(pPropDesc);
    }

    if(SUCCEEDED(hr))
    {
        hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), pPropDesc, Description.DescriptionSize);
    }

    if(SUCCEEDED(hr))
    {
        *ppPropDesc = pPropDesc;
    }
    else
    {
        MEMFREE(pPropDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetDriverCertification
 *
 *  Description:
 *      Checks driver certification for a given devnode.
 *
 *  Arguments:
 *      LPCTSTR [in]: driver interface.
 *
 *  Returns:
 *      DWORD [in]: VERIFY_* flag.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetDriverCertification"

DWORD KsGetDriverCertification
(
    LPCTSTR                 pszInterface
)
{

#ifdef DEBUG
    DWORD                   dwTime;
#endif

    BOOL                    fCertified;
    DWORD                   dwCertified;

    DPF_ENTER();

#ifdef DEBUG
    dwTime = timeGetTime();
#endif

    fCertified = GetDriverCertificationStatus(pszInterface);

#ifdef DEBUG
    DPF(DPFLVL_MOREINFO, "Certification check took %lu ms", timeGetTime() - dwTime);
#endif

    dwCertified = fCertified ? VERIFY_CERTIFIED : VERIFY_UNCERTIFIED;

    DPF_LEAVE(dwCertified);
    return dwCertified;
}


/***************************************************************************
 *
 *  KsGetPinInstances
 *
 *  Description:
 *      Gets the number of pins on the renderer.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: pin id.
 *      PKSPIN_CINSTANCES [out]: receives instance data.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinInstances"

HRESULT
KsGetPinInstances
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PKSPIN_CINSTANCES       pInstances
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    DPF_ENTER();

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_CINSTANCES;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), pInstances, sizeof(*pInstances));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetVolumeRange
 *
 *  Description:
 *      Gets the volume level range for a node.
 *
 *  Arguments:
 *      HANDLE [in]: pin id.
 *      ULONG [in]: node id.
 *      PKSPROPERTY_STEPPING_LONG [out]: receives volume range.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetVolumeRange"

HRESULT
KsGetVolumeRange
(
    HANDLE                      hPin,
    ULONG                       ulNodeId,
    PKSPROPERTY_STEPPING_LONG   pVolumeRange
)
{
    PKSPROPERTY_DESCRIPTION     pPropDesc       = NULL;
    HRESULT                     hr              = DS_OK;

    DPF_ENTER();

    hr = KsGetBasicSupport(hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_VOLUMELEVEL, ulNodeId, &pPropDesc);

    if(FAILED(hr))
    {
        // Changed this to a warning because it's very frequent and non-critical
        DPF(DPFLVL_WARNING, "Unable to get volume range for node %lu", ulNodeId);
    }

    if(SUCCEEDED(hr))
    {
        CopyMemory(pVolumeRange, ((PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1)) + 1, sizeof(*pVolumeRange));
    }

    MEMFREE(pPropDesc);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetSysAudioDeviceInstance
 *
 *  Description:
 *      Sets the device instance that the System Audio Device should use.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: device id.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetSysAudioDeviceInstance"

HRESULT
KsSetSysAudioDeviceInstance
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId
)
{
    HRESULT                 hr;

    DPF_ENTER();

#ifndef WINNT
    if (g_ulWdmVersion == WDM_1_0)
    {
        // WDM 1.0 sysaudio does not understand about not combining pins
        //
        KSPROPERTY  Property;

        Property.Set = KSPROPSETID_Sysaudio;
        Property.Id = KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE;
        Property.Flags = KSPROPERTY_TYPE_SET;

        hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &ulDeviceId, sizeof(ulDeviceId));
    }
    else
#endif // !WINNT
    {
        SYSAUDIO_INSTANCE_INFO InstanceInfo;
        InstanceInfo.Property.Set = KSPROPSETID_Sysaudio;
        InstanceInfo.Property.Id = KSPROPERTY_SYSAUDIO_INSTANCE_INFO;
        InstanceInfo.Property.Flags = KSPROPERTY_TYPE_SET;

        InstanceInfo.Flags = SYSAUDIO_FLAGS_DONT_COMBINE_PINS;
        InstanceInfo.DeviceNumber = ulDeviceId;

        hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &InstanceInfo, sizeof(InstanceInfo));
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsAggregatePinAudioDataRange
 *
 *  Description:
 *      Aggregates values in a KSDATARANGE_AUDIO structure.
 *
 *  Arguments:
 *      PKSDATARANGE_AUDIO [in]: data range.
 *      PKSDATARANGE_AUDIO [in/out]: receives aggregate data range.  It
 *                                   is assumed that this parameter has
 *                                   already had its values initialized.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsAggregatePinAudioDataRange"

void
KsAggregatePinAudioDataRange
(
    PKSDATARANGE_AUDIO      pDataRange,
    PKSDATARANGE_AUDIO      pAggregateDataRange
)
{
    DPF_ENTER();

    pAggregateDataRange->MaximumChannels = max(pAggregateDataRange->MaximumChannels, pDataRange->MaximumChannels);
    pAggregateDataRange->MinimumBitsPerSample = min(pAggregateDataRange->MinimumBitsPerSample, pDataRange->MinimumBitsPerSample);
    pAggregateDataRange->MaximumBitsPerSample = max(pAggregateDataRange->MaximumBitsPerSample, pDataRange->MaximumBitsPerSample);
    pAggregateDataRange->MinimumSampleFrequency = min(pAggregateDataRange->MinimumSampleFrequency, pDataRange->MinimumSampleFrequency);
    pAggregateDataRange->MaximumSampleFrequency = max(pAggregateDataRange->MaximumSampleFrequency, pDataRange->MaximumSampleFrequency);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  KsAggregatePinInstances
 *
 *  Description:
 *      Aggregates values in a KSPIN_CINSTANCES structure.
 *
 *  Arguments:
 *      PKSPIN_CINSTANCES [in]: instance data.
 *      PKSPIN_CINSTANCES [out]: receives aggregate instance data.
 *                               It's assumed that this parameter has
 *                               already had its values initialized.
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsAggregatePinInstances"

void
KsAggregatePinInstances
(
    PKSPIN_CINSTANCES       pInstances,
    PKSPIN_CINSTANCES       pAggregateInstances
)
{
    ULONGLONG               ullAggregate;

    DPF_ENTER();

    ullAggregate = (ULONGLONG)pAggregateInstances->PossibleCount + (ULONGLONG)pInstances->PossibleCount;
    pAggregateInstances->PossibleCount = NUMERIC_CAST(ullAggregate, ULONG);

    ullAggregate = (ULONGLONG)pAggregateInstances->CurrentCount + (ULONGLONG)pInstances->CurrentCount;
    pAggregateInstances->CurrentCount = NUMERIC_CAST(ullAggregate, ULONG);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  KsGetNodeInformation
 *
 *  Description:
 *      Gets information about a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSNODE [in/out]: node information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetNodeInformation"

HRESULT
KsGetNodeInformation
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PKSNODE                 pNode
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    pNode->NodeId = ulNodeId;
    pNode->CpuResources = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;

    if(IS_VALID_NODE(ulNodeId))
    {

#pragma TODO("KSPROPERTY_AUDIO_CPU_RESOURCES must be supported")

        /*hr = */KsGetCpuResources(hDevice, ulNodeId, &pNode->CpuResources);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetAlgorithmInstance
 *
 *  Description:
 *      Get the primary algorithm instance for the topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSNODE [in/out]: node information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetAlgorithmInstance"

HRESULT
KsGetAlgorithmInstance
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    LPGUID                  lpGuidAlgorithmInstance
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetNodeProperty
         (
             hDevice,
             KSPROPSETID_Audio,
             KSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
             ulNodeId,
             lpGuidAlgorithmInstance,
             sizeof(GUID)
         );

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetAlgorithmInstance
 *
 *  Description:
 *      Set a topology node to a particular algorithm instance.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSNODE [in/out]: node information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetAlgorithmInstance"

HRESULT
KsSetAlgorithmInstance
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    GUID                    guidAlgorithmInstance
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsSetNodeProperty
         (
             hDevice,
             KSPROPSETID_Audio,
             KSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
             ulNodeId,
             &guidAlgorithmInstance,
             sizeof(guidAlgorithmInstance)
         );

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetVolumeNodeInformation
 *
 *  Description:
 *      Gets information about a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSVOLUMENODE [in/out]: node information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetVolumeNodeInformation"

HRESULT
KsGetVolumeNodeInformation
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PKSVOLUMENODE           pNode
)
{
    HRESULT                 hr;

    DPF_ENTER();

    pNode->VolumeRange.SteppingDelta = 1;
    pNode->VolumeRange.Reserved = 0;
    pNode->VolumeRange.Bounds.SignedMinimum = MIN_LONG;
    pNode->VolumeRange.Bounds.SignedMaximum = 0;

    hr = KsGetNodeInformation(hDevice, ulNodeId, &pNode->Node);

    if(SUCCEEDED(hr) && IS_VALID_NODE(ulNodeId))
    {
        // If the node doesn't support KSPROPERTY_AUDIO_VOLUMERANGE,
        // we'll just go with the defaults
        KsGetVolumeRange(hDevice, ulNodeId, &pNode->VolumeRange);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsEnableTopologyNode
 *
 *  Description:
 *      Enables or disables a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: node id.
 *      BOOL [in]: enable value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsEnableTopologyNode"

HRESULT
KsEnableTopologyNode
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fEnable
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsSetNodeProperty(hDevice, KSPROPSETID_TopologyNode, KSPROPERTY_TOPOLOGYNODE_ENABLE, ulNodeId, &fEnable, sizeof(fEnable));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\kshlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kshlp.h
 *  Content:    WDM/CSA helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/5/98      dereks  Created.
 *
 ***************************************************************************/

#ifdef NOKS
#error kshlp.h included with NOKS defined
#endif // NOKS

#ifndef __KSHLP_H__
#define __KSHLP_H__

#include "pset.h"

// #define NO_DSOUND_FORMAT_SPECIFIER

#define KSPIN_DATAFLOW_CAPTURE  KSPIN_DATAFLOW_OUT
#define KSPIN_DATAFLOW_RENDER   KSPIN_DATAFLOW_IN

// Device-specific DirectSound property sets
typedef struct tagKSDSPROPERTY
{
    GUID    PropertySet;
    ULONG   PropertyId;
    ULONG   NodeId;
    ULONG   AccessFlags;
} KSDSPROPERTY, *PKSDSPROPERTY;

// KS stream data
typedef struct tagKSSTREAMIO
{
    KSSTREAM_HEADER Header;
    OVERLAPPED      Overlapped;
    BOOL            fPendingIrp;
} KSSTREAMIO, *PKSSTREAMIO;

// System audio device properties
typedef struct tagKSSADPROPERTY
{
    KSPROPERTY  Property;
    ULONG       DeviceId;
    ULONG       Reserved;
} KSSADPROPERTY, *PKSSADPROPERTY;

// WAVEFORMATEX pin description
typedef struct tagKSAUDIOPINDESC
{
    KSPIN_CONNECT               Connect;
    KSDATAFORMAT_WAVEFORMATEX   DataFormat;
} KSAUDIOPINDESC, *PKSAUDIOPINDESC;

// DirectSound render pin description

#ifndef NO_DSOUND_FORMAT_SPECIFIER

typedef struct tagKSDSRENDERPINDESC
{
    KSPIN_CONNECT       Connect;
    KSDATAFORMAT_DSOUND DataFormat;
} KSDSRENDERPINDESC, *PKSDSRENDERPINDESC;

// This is ugly. KSDATAFORMAT_DSOUND was changed between WDM 1.0 and 1.1.
// We need to old structure to run on 1.0.
//
#include <pshpack1.h>
// DirectSound buffer description
typedef struct {
    ULONG               Flags;
    ULONG               Control;
    ULONG               BufferSize;     // Does not exist in 1.1
    WAVEFORMATEX        WaveFormatEx;
} KSDSOUND_BUFFERDESC_10, *PKSDSOUND_BUFFERDESC_10;

// DirectSound format
typedef struct {
    KSDATAFORMAT            DataFormat;
    KSDSOUND_BUFFERDESC_10  BufferDesc;
} KSDATAFORMAT_DSOUND_10, *PKSDATAFORMAT_DSOUND_10;
#include <poppack.h>

typedef struct tagKSDSRENDERPINDESC_10
{
    KSPIN_CONNECT           Connect;
    KSDATAFORMAT_DSOUND_10  DataFormat;
} KSDSRENDERPINDESC_10, *PKSDSRENDERPINDESC_10;


#endif // NO_DSOUND_FORMAT_SPECIFIER

// Topology node information
typedef struct tagKSNODE
{
    ULONG   NodeId;
    ULONG   CpuResources;
} KSNODE, *PKSNODE;

typedef struct tagKSVOLUMENODE
{
    KSNODE                      Node;
    KSPROPERTY_STEPPING_LONG    VolumeRange;
} KSVOLUMENODE, *PKSVOLUMENODE;

// Our own version of NTSTATUS
typedef LONG NTSTATUS;

#define NT_SUCCESS(s)       ((NTSTATUS)(s) >= 0)
#define NT_INFORMATION(s)   ((ULONG)(s) >> 30 == 1)
#define NT_WARNING(s)       ((ULONG)(s) >> 30 == 2)
#define NT_ERROR(s)         ((ULONG)(s) >> 30 == 3)

// Reserved node identifiers
#define NODE_UNINITIALIZED  0xFFFFFFFF
#define NODE_WILDCARD       0xFFFFFFFE

#define NODE_PIN_UNINITIALIZED  0xFFFFFFFF

#define IS_VALID_NODE(nodeid) \
            (NODE_UNINITIALIZED != (nodeid))

// Node implementation
#define KSAUDIO_CPU_RESOURCES_UNINITIALIZED 'ENON'

#define IS_HARDWARE_NODE(impl) \
            (KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU == (impl))

#define IS_SOFTWARE_NODE(impl) \
            (KSAUDIO_CPU_RESOURCES_HOST_CPU == (impl))

#ifdef __cplusplus

// Helper functions
void 
KsQueryWdmVersion();

#define WDM_NONE            (0)
#define WDM_1_0             (0x0100)
#define WDM_1_1             (0x0101)    // or better

extern ULONG g_ulWdmVersion;

HRESULT 
PostDevIoctl
(
    HANDLE                  hDevice, 
    DWORD                   dwControlCode, 
    LPVOID                  pvIn            = NULL,
    DWORD                   cbIn            = 0,
    LPVOID                  pvOut           = NULL,
    DWORD                   cbOut           = 0,
    LPDWORD                 pcbReturned     = NULL,
    LPOVERLAPPED            pOverlapped     = NULL
);

HRESULT 
KsGetProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);

HRESULT 
KsSetProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

HRESULT 
KsGetState
(
    HANDLE                  hDevice, 
    PKSSTATE                pState
);

HRESULT 
KsSetState
(
    HANDLE                  hDevice, 
    KSSTATE                 State
);

HRESULT 
KsTransitionState
(
    HANDLE                  hDevice, 
    KSSTATE                 nCurrentState,
    KSSTATE                 nNewState
);

HRESULT 
KsResetState
(
    HANDLE                  hDevice, 
    KSRESET                 ResetValue
);

HRESULT 
KsGetPinProperty
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned = NULL
);

HRESULT 
KsSetPinProperty
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

PKSTOPOLOGY_CONNECTION 
KsFindConnection
(
    PKSTOPOLOGY_CONNECTION  paConnections,
    ULONG                   cConnections,
    PKSTOPOLOGY_CONNECTION  pNext
);

#ifndef WINNT
HRESULT 
KsGetFirstPinConnection
(
    HANDLE                  hDevice, 
    PULONG                  pIndex
);
#endif // !WINNT

HRESULT 
KsWriteStream
(
    HANDLE                  hDevice, 
    LPCVOID                 pvData, 
    ULONG                   cbData, 
    ULONG                   ulFlags, 
    PKSSTREAMIO             pKsStreamIo
);

HRESULT 
KsReadStream
(
    HANDLE                  hDevice,
    LPVOID                  pvData, 
    ULONG                   cbData, 
    ULONG                   ulFlags, 
    PKSSTREAMIO             pKsStreamIo
);

HRESULT 
KsGetNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);

HRESULT 
KsSetNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

#ifdef DEAD_CODE
HRESULT 
KsGet3dNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvInstance,
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);
#endif

HRESULT 
KsSet3dNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvInstance,
    LPVOID                  pvData, 
    DWORD                   cbData
);

HRESULT 
DsSpeakerConfigToKsProperties
(
    DWORD                   dwSpeakerConfig,
    PLONG                   pKsSpeakerConfig,
    PLONG                   pKsStereoSpeakerGeometry
);

DWORD 
DsBufferFlagsToKsPinFlags
(
    DWORD                   dwDsFlags
);

DWORD 
DsBufferFlagsToKsControlFlags
(
    DWORD                   dwDsFlags,
    REFGUID                 guid3dAlgorithm
);

DWORD
Ds3dModeToKs3dMode
(
    DWORD                   dwDsMode
);

HRESULT 
KsGetMultiplePinProperties
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
);

HRESULT 
KsGetMultipleTopologyProperties
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
);

HRESULT 
KsGetPinPcmAudioDataRange
(
    HANDLE                  hDevice, 
    ULONG                   ulPinId,
    PKSDATARANGE_AUDIO      pDataRange,
    BOOL                    fCapture = FALSE
);

HRESULT 
KsOpenSysAudioDevice
(
    LPHANDLE                phDevice
);

HRESULT 
KsGetSysAudioProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulDeviceId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned = NULL
);

HRESULT 
KsSetSysAudioProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulDeviceId,
    LPVOID                  pvData,
    ULONG                   cbData
);

HRESULT 
KsCreateSysAudioVirtualSource
(
    HANDLE                  hDevice,
    PULONG                  pulVirtualSourceIndex 
);

HRESULT 
KsAttachVirtualSource
(
    HANDLE                  hDevice,
    ULONG                   ulVirtualSourceIndex 
);

HRESULT 
KsSysAudioSelectGraph
(
    HANDLE                  hDevice,
    ULONG                   ulPinId, 
    ULONG                   ulNodeId 
);

HRESULT 
KsCancelPendingIrps
(
    HANDLE                  hPin,
    PKSSTREAMIO             pKsStreamIo = NULL,
    BOOL                    fWait       = FALSE
);

HRESULT 
KsBuildAudioPinDescription
(
    KSINTERFACE_STANDARD    nInterface,
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
);

#ifdef NO_DSOUND_FORMAT_SPECIFIER

HRESULT 
KsBuildRenderPinDescription
(
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
);

#else // NO_DSOUND_FORMAT_SPECIFIER

HRESULT 
KsBuildRenderPinDescription
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    PKSDSRENDERPINDESC *    ppPinDesc
);

// This function is only used on WDM 1.0 (Windows 98)
#ifndef WINNT
HRESULT 
KsBuildRenderPinDescription_10
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    PKSDSRENDERPINDESC_10 * ppPinDesc
);
#endif // !WINNT

#endif // NO_DSOUND_FORMAT_SPECIFIER

HRESULT 
KsBuildCapturePinDescription
(
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
);

HRESULT 
KsCreateAudioPin
(
    HANDLE                  hDevice,
    PKSPIN_CONNECT          pConnect,
    ACCESS_MASK             dwDesiredAccess,
    KSSTATE                 nState,
    LPHANDLE                phPin
);

HRESULT 
KsEnableEvent
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulProperty,
    PKSEVENTDATA            pEventData,
    ULONG                   cbEventData
);

HRESULT 
KsDisableEvent
(
    HANDLE                  hDevice,
    PKSEVENTDATA            pEventData,
    ULONG                   cbEventData
);

HRESULT 
KsEnablePositionEvent
(
    HANDLE                                  hDevice,
    QWORD                                   qwSample,
    HANDLE                                  hEvent,
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pNotify
);

HRESULT 
KsDisablePositionEvent
(
    HANDLE                                  hDevice,
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pNotify
);

HRESULT 
KsGetCpuResources
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId, 
    PULONG                  pulCpuResources
);

DWORD KsGetSupportedFormats
(
    PKSDATARANGE_AUDIO      AudioDataRange
);

HRESULT 
KsGetDeviceInterfaceName
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId,
    LPTSTR *                ppszInterfaceName
);

HRESULT 
KsGetDeviceFriendlyName
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId,
    LPTSTR *                ppszName
);

HRESULT 
KsGetDeviceDriverPathAndDevnode
(
    LPCTSTR                 pszInterface,
    LPTSTR  *               ppszPath,
    LPDWORD                 pdwDevnode
);

HRESULT 
KsIsUsablePin
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    KSPIN_DATAFLOW          PinDataFlow,
    KSPIN_COMMUNICATION     PinCommunication,
    PKSAUDIOPINDESC         pPinDesc
);

HRESULT 
KsEnumDevicePins
(
    HANDLE                  hDevice,
    BOOL                    fCapture,
    ULONG **                ppulValidPinIds,
    ULONG                   ulPinCount,
    PULONG                  pulPinCount
);

HRESULT 
KsGetChannelProperty
(
    HANDLE                  hPin,
    GUID                    guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    ULONG                   ulChannelId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned = NULL
);

HRESULT 
KsSetChannelProperty
(
    HANDLE                  hPin,
    GUID                    guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    ULONG                   ulChannelId,
    LPVOID                  pvData,
    ULONG                   cbData
);

HRESULT 
KsGetPinMute
(
    HANDLE                  hPin,
    ULONG                   ulNodeId,
    LPBOOL                  pfMute
);

HRESULT 
KsSetPinMute
(
    HANDLE                  hPin,
    ULONG                   ulNodeId,
    BOOL                    fMute
);

HRESULT 
KsGetBasicSupport
(
    HANDLE                      hDevice,
    REFGUID                     guidPropertySet,
    ULONG                       ulPropertyId,
    ULONG                       ulNodeId,
    PKSPROPERTY_DESCRIPTION *   ppPropDesc
);

DWORD 
KsGetDriverCertification
(
    LPCTSTR                 pszInterface
);

HRESULT 
KsGetPinInstances
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PKSPIN_CINSTANCES       pInstances
);

#ifndef WINNT
HRESULT 
KsGetRenderPinInstances
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PKSPIN_CINSTANCES       pInstances
);
#endif // !WINNT

HRESULT 
KsGetVolumeRange
(
    HANDLE                      hPin,
    ULONG                       ulNodeId,
    PKSPROPERTY_STEPPING_LONG   pVolumeRange
);

inline
LONG 
DsAttenuationToKsVolume
(
    LONG                        lVolume,
    PKSPROPERTY_STEPPING_LONG   pVolumeRange
)       
{
    lVolume = (LONG)((FLOAT)lVolume * 65536.0f / 100.0f);
    lVolume += pVolumeRange->Bounds.SignedMaximum;
    lVolume = max(lVolume, pVolumeRange->Bounds.SignedMinimum);
    
    return lVolume;
}

HRESULT
KsSetSysAudioDeviceInstance
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId
);

void
KsAggregatePinAudioDataRange
(
    PKSDATARANGE_AUDIO      pDataRange,
    PKSDATARANGE_AUDIO      pAggregateDataRange
);

void 
KsAggregatePinInstances
(
    PKSPIN_CINSTANCES       pInstances,
    PKSPIN_CINSTANCES       pAggregateInstances
);

HRESULT
KsGetNodeInformation
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PKSNODE                 pNode
);

HRESULT
KsGetAlgorithmInstance
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    LPGUID                  lpGuidAlgorithmInstance
);

HRESULT
KsSetAlgorithmInstance
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    GUID                    guidAlgorithmInstance
);

HRESULT
KsGetVolumeNodeInformation
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PKSVOLUMENODE           pNode
);

inline 
PKSTOPOLOGY_CONNECTION
KsValidateConnection
(
    PKSTOPOLOGY_CONNECTION  pConnection
)
{
    if(pConnection && KSFILTER_NODE == pConnection->ToNode)
    {
        pConnection = NULL;
    }

    return pConnection;
}

HRESULT
KsEnableTopologyNode
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fEnable
);

// Fwd decl
class CKsTopology;
class CCaptureEffect;

// The KS Audio Device class
class CKsDevice 
{
protected:
    const VADDEVICETYPE         m_vdtKsDevType;         // Device type
    CDeviceDescription *        m_pKsDevDescription;    // Device description
    HANDLE                      m_hDevice;              // System audio device handle
    ULONG                       m_ulDeviceId;           // Device id
    ULONG                       m_ulPinCount;           // Count of pins on the device
    ULONG                       m_ulValidPinCount;      // Count of usable pins on the device
    PULONG                      m_pulValidPins;         // Array of usable pin IDs
    CKsTopology **              m_paTopologies;         // Array of pin topologies
    CCallbackEventPool *        m_pEventPool;           // Event pool

public:
    CKsDevice(VADDEVICETYPE);
    virtual ~CKsDevice(void);

public:
    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCertification(LPDWORD, BOOL);

    // Pin creation
    virtual HRESULT CreatePin(PKSPIN_CONNECT, ACCESS_MASK, KSSTATE, LPHANDLE);

private:
    // Device creation
    virtual HRESULT OpenSysAudioDevice(ULONG);

    // Device enumeration
    virtual HRESULT GetDeviceCount(PULONG);
    virtual HRESULT GetPinCount(ULONG, PULONG);
};

// KS topology object
class CKsTopology
    : public CDsBasicRuntime
{
protected:
    HANDLE                  m_hDevice;
    ULONG                   m_ulPinCount;
    ULONG                   m_ulPinId;
    PKSMULTIPLE_ITEM        m_paNodeItems;
    LPGUID                  m_paNodes;
    PKSMULTIPLE_ITEM        m_paConnectionItems;
    PKSTOPOLOGY_CONNECTION  m_paConnections;

public:
    CKsTopology(HANDLE, ULONG, ULONG);
    virtual ~CKsTopology(void);

public:
    // Initialization
    virtual HRESULT Initialize(KSPIN_DATAFLOW);

    // Basic topology helpers
    virtual REFGUID GetControlFromNodeId(ULONG);
    virtual ULONG GetNodeIdFromConnection(PKSTOPOLOGY_CONNECTION);

    // Advanced topology helpers
    virtual PKSTOPOLOGY_CONNECTION GetNextConnection(PKSTOPOLOGY_CONNECTION);
    virtual PKSTOPOLOGY_CONNECTION FindControlConnection(PKSTOPOLOGY_CONNECTION, PKSTOPOLOGY_CONNECTION, REFGUID);
    virtual HRESULT FindNodeIdsFromControl(REFGUID, PULONG, PULONG*);
    virtual HRESULT FindNodeIdFromEffectDesc(HANDLE, CCaptureEffect*, PULONG);
    virtual HRESULT FindMultipleToNodes(ULONG, ULONG, PULONG, PULONG*);
    virtual BOOL VerifyCaptureFxCpuResources(ULONG, ULONG);
    virtual HRESULT FindCapturePinFromEffectChain(PKSTOPOLOGY_CONNECTION, PKSTOPOLOGY_CONNECTION, CCaptureEffectChain *, ULONG);
    virtual HRESULT FindRenderPinWithAec(HANDLE, PKSTOPOLOGY_CONNECTION, PKSTOPOLOGY_CONNECTION, REFGUID, DWORD, PKSNODE);

private:
    virtual PKSTOPOLOGY_CONNECTION ValidateConnectionIndex(ULONG);
    virtual HRESULT OrderConnectionItems(KSPIN_DATAFLOW);
    virtual HRESULT RemovePanicConnections(void);
};

inline REFGUID CKsTopology::GetControlFromNodeId(ULONG ulNodeId)
{
    ASSERT(ulNodeId < m_paNodeItems->Count);
    return m_paNodes[ulNodeId];
}

inline ULONG CKsTopology::GetNodeIdFromConnection(PKSTOPOLOGY_CONNECTION pConnection)
{
    pConnection = KsValidateConnection(pConnection);
    return pConnection ? pConnection->ToNode : NODE_UNINITIALIZED;
}

inline PKSTOPOLOGY_CONNECTION CKsTopology::ValidateConnectionIndex(ULONG ulIndex)
{
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;
    
    if(ulIndex < m_paConnectionItems->Count)
    {
        pConnection = KsValidateConnection(m_paConnections + ulIndex);
    }

    return pConnection;
}

// KS property set object
class CKsPropertySet
    : public CPropertySet
{
protected:
    HANDLE              m_hPin;             // Pin handle
    LPVOID              m_pvInstance;       // Instance identifer
    CKsTopology *       m_pTopology;        // Pin topology
    CList<KSDSPROPERTY> m_lstProperties;    // List of supported properties

public:
    CKsPropertySet(HANDLE, LPVOID, CKsTopology *);
    virtual ~CKsPropertySet(void);

public:
    // Property support
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG);
    
    // Property data
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);

private:
    // Property data
    virtual HRESULT DoProperty(REFGUID, ULONG, DWORD, LPVOID, ULONG, LPVOID, PULONG);

    // Converting property descriptions to topology nodes
    virtual HRESULT FindNodeFromProperty(REFGUID, ULONG, PKSDSPROPERTY);
};

#ifdef DEBUG

extern ULONG g_ulKsIoctlCount;

#endif // DEBUG

#endif // __cplusplus

#endif // __KSHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\ksuserw.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:    DLL entry point
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   1/19/00    jimge   Created
 *
 ***************************************************************************/

#ifndef __KSUSERW__H_
#define __KSUSERW__H_

extern DWORD DsKsCreatePin(
    IN HANDLE           hFilter,
    IN PKSPIN_CONNECT   pConnect,
    IN ACCESS_MASK      dwDesiredAccess,
    OUT PHANDLE         pConnectionHandle);
    
extern VOID RemovePerProcessKsUser(
    DWORD dwProcessId);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\kscap.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kscap.h
 *  Content:    WDM/CSA Virtual Audio Device audio capture class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/6/98      dereks  Created.
 *
 ***************************************************************************/

#ifdef NOKS
#error kscap.h included with NOKS defined
#endif // NOKS

#ifndef __KSCAP_H__
#define __KSCAP_H__

// Capture device topology info
typedef struct tagKSCDTOPOLOGY
{
    KSNODE          SrcNode;
} KSCDTOPOLOGY, *PKSCDTOPOLOGY;

// Flag used to terminate the StateThread
#define TERMINATE_STATE_THREAD 0xffffffff

#ifdef __cplusplus

// Fwd decl
class CKsCaptureDevice;
class CKsCaptureWaveBuffer;

// The KS Audio Capture Device class
class CKsCaptureDevice
    : public CCaptureDevice, public CKsDevice
{
    friend class CKsCaptureWaveBuffer;

protected:
    PKSCDTOPOLOGY               m_paTopologyInformation;    // Topology information
    BOOL                        m_fSplitter;

public:
    CKsCaptureDevice(void);
    virtual ~CKsCaptureDevice(void);

public:
    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCaps(LPDSCCAPS);
    virtual HRESULT GetCertification(LPDWORD, BOOL);

    // Buffer management
    virtual HRESULT CreateBuffer(DWORD, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *, LPVOID, CCaptureWaveBuffer **);

    // Pin helpers
    virtual HRESULT CreateCapturePin(ULONG, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *, LPHANDLE, PULONG);

protected:
    // Pin/topology helpers
    virtual HRESULT ValidatePinCaps(ULONG, DWORD);

private:
    // Topology helpers
    virtual HRESULT GetTopologyInformation(CKsTopology *, PKSCDTOPOLOGY);
};

inline HRESULT CKsCaptureDevice::EnumDrivers(CObjectList<CDeviceDescription> *plst)
{
    return CKsDevice::EnumDrivers(plst);
}

inline HRESULT CKsCaptureDevice::GetCertification(LPDWORD pdwCertification, BOOL fGetCaps)
{
    return CKsDevice::GetCertification(pdwCertification, fGetCaps);
}


// The KS capture wave buffer
class CKsCaptureWaveBuffer
    : public CCaptureWaveBuffer, private CUsesCallbackEvent
{
    friend class CKsCaptureDevice;

private:
    enum { cksioDefault = 25 };
    enum { IKSIO_INVALID = -1 };
    enum { DSCBSTATUS_PAUSE = 0x20000000 };

    PKSSTREAMIO                             m_rgpksio;              // array of KSSTREAMIO for capturing
    LONG                                    m_cksio;                // number of capture KSTREAMIO buffers
    LONG                                    m_iksioDone;
    LONG                                    m_cksioDropped;

    LPBYTE                                  m_pBuffer;              // buffer for data
    LPBYTE                                  m_pBufferMac;           // end of buffer for data
    LPBYTE                                  m_pBufferNext;          // next part of buffer to be queued
    DWORD                                   m_cbBuffer;             // size of buffer
    DWORD                                   m_cbRecordChunk;        // capture chunk size used for waveInAddBuffer
    DWORD                                   m_cLoops;               // how many times we've looped around

    DWORD                                   m_iNote;
    DWORD                                   m_cNotes;               // Count of notification positions
    LPDSBPOSITIONNOTIFY                     m_paNotes;              // Current notification positions
    LPDSBPOSITIONNOTIFY                     m_pStopNote;            // Stop notification

    LPWAVEFORMATEX                          m_pwfx;                 // WaveFormat stored for focus aware support
    CCaptureEffectChain *                   m_pFXChain;             // Capture Effects chain stored for FA support
    KSSTATE                                 m_PinState;             // The current state of m_hPin

#ifdef DEBUG
    HANDLE                                  m_hEventStop;
    DWORD                                   m_cIrpsSubmitted;       // Total number of capture IRPs submitted
    DWORD                                   m_cIrpsReturned;        // Total number of capture IRPs returned
#endif

#ifdef SHARED
    HANDLE                                  m_hEventThread;         // Event to signal focus change thread
    HANDLE                                  m_hEventAck;            // Event to acknoledge call
    HANDLE                                  m_hThread;              // Thread handle for focus change
    DWORD                                   m_dwSetState;           // State sent to the SetState() API
    DWORD                                   m_hrReturn;             // Return value
    CRITICAL_SECTION                        m_csSS;                 // critial section to protect multi-threaded access
#endif // SHARED

    CCallbackEvent **                       m_rgpCallbackEvent;     // array of callback events

    BOOL                                    m_fCritSectsValid;      // Critical sections currently OK
    CRITICAL_SECTION                        m_cs;                   // critical section to protect multi-thread access
    CRITICAL_SECTION                        m_csPN;                 // critical section to protect multi-thread access
                                                                    // used for position notification processing

    LPBYTE                                  m_pBufferProcessed;
    DWORD                                   m_dwCaptureCur;         // offset to last processed capture head position
                                                                    // i.e. data up to this point is valid
    DWORD                                   m_dwCaptureLast;        // offset into buffer where capturing stopped last
    BOOL                                    m_fFirstSubmittedIrp;   // allows setting of the DATADISCONTINUITY flag 
                                                                    // for the first IRP.
protected:
    CKsCaptureDevice *                      m_pKsDevice;            // KS audio device
    HANDLE                                  m_hPin;                 // Audio device pin
    DWORD                                   m_dwState;              // Current buffer state
    DWORD                                   m_fdwSavedState;        // Last buffer state set (ignoring capture focus)
    CEmCaptureDevice *                      m_pEmCaptureDevice;     // emulated capture device (WAVE_MAPPED)
    CEmCaptureWaveBuffer *                  m_pEmCaptureWaveBuffer; // emulated capture buffer (WAVE_MAPPED)

public:
    CKsCaptureWaveBuffer(CKsCaptureDevice *);
    virtual ~CKsCaptureWaveBuffer();

public:
    // Initialization
    virtual HRESULT Initialize(DWORD, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *);

    // Buffer capabilities
    virtual HRESULT GetCaps(LPDSCBCAPS);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);

    // Notification positions
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

#ifdef SHARED
    static DWORD WINAPI StateThread(LPVOID pv);
#endif // SHARED 

private:
    virtual HRESULT SetCaptureState(BOOL);
    virtual HRESULT UpdateCaptureState(BOOL);
    virtual HRESULT SetStopState(BOOL);
    virtual HRESULT FreeNotificationPositions(void);
    virtual void EventSignalCallback(CCallbackEvent *);
    virtual HRESULT CreateEmulatedBuffer(UINT, DWORD, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *, CEmCaptureDevice **, CEmCaptureWaveBuffer **);

    // Focus management support
    void    NotifyStop(void);
    HRESULT NotifyFocusChange(void);
    HRESULT SubmitKsStreamIo(PKSSTREAMIO, HANDLE hPin = NULL);
    HRESULT CancelAllPendingIRPs(BOOL, HANDLE hPin = NULL);
    void    SignalNotificationPositions(PKSSTREAMIO);
    
#ifdef SHARED
    HRESULT SetStateThread(DWORD);
#endif // SHARED 
    
};

#endif // __cplusplus

#endif // __KSCAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\ksuserw.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ksuserw.cpp
 *  Content:    Wrapper functions for ksuser
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/13/00    jimge   Created
 *
 ***************************************************************************/

#include "dsoundi.h"

typedef DWORD (*PKSCREATEPIN)(
    IN HANDLE           hFilter,
    IN PKSPIN_CONNECT   pConnect,
    IN ACCESS_MASK      dwDesiredAccess,
    OUT PHANDLE         pConnectionHandle
);

struct KsUserProcessInstance    
{
    DWORD                   dwProcessId;
    HMODULE                 hKsUser;
    PKSCREATEPIN            pCreatePin;
    KsUserProcessInstance   *pNext;
};

static KsUserProcessInstance *pKsUserList;

/***************************************************************************
 *
 *  DsKsCreatePin
 *
 *  Description:
 *      Wraps the KsCreatePin from ksuser.dll. For performance reasons
 *      we only want to load ksuser.dll once per process, so this
 *      function tracks process ID's and loads ksuser on first request.
 * 
 *      Unfortunately we cannot unload the DLL on process cleanup because
 *      FreeLibrary is spec'ed as not being safe from DllMain. However,
 *      we can clean up the list.
 *
 *      Note that the list is protected by the DLL mutex, which is held
 *      by any call attempting to create a pin.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsKsCreatePin"

DWORD DsKsCreatePin(
    IN HANDLE           hFilter,
    IN PKSPIN_CONNECT   pConnect,
    IN ACCESS_MASK      dwDesiredAccess,
    OUT PHANDLE         pConnectionHandle)
{
    DPF_ENTER();

    DWORD dwThisProcessId = GetCurrentProcessId();
    KsUserProcessInstance *pInstance;

    for (pInstance = pKsUserList; pInstance; pInstance = pInstance->pNext) 
    {
        if (pInstance->dwProcessId == dwThisProcessId)
        {
            break;
        }
    }

    if (pInstance == NULL)
    {
        pInstance = NEW(KsUserProcessInstance);
        if (!pInstance)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pInstance->hKsUser = LoadLibrary(TEXT("KsUser.dll"));
        if (pInstance->hKsUser == (HANDLE)NULL)
        {
            DELETE(pInstance);
            return GetLastError();
        }

        pInstance->pCreatePin = (PKSCREATEPIN)GetProcAddress(
            pInstance->hKsUser,
            "KsCreatePin");
        if (pInstance->pCreatePin == NULL) 
        {
            FreeLibrary(pInstance->hKsUser);
            DELETE(pInstance);
            return ERROR_INVALID_HANDLE;
        }

        pInstance->dwProcessId = dwThisProcessId;
        pInstance->pNext = pKsUserList;
        pKsUserList = pInstance;
    }

    DWORD dw = (*pInstance->pCreatePin)(
        hFilter, 
        pConnect, 
        dwDesiredAccess, 
        pConnectionHandle);

    DPF_LEAVE(dw);

    return dw;
}

/***************************************************************************
 *
 *  KsCreatePin
 *
 *  Description:
 *      Wraps the KsCreatePin from ksuser.dll. For performance reasons
 *      we only want to load ksuser.dll once per process, so this
 *      function tracks process ID's and loads ksuser on first request.
 * 
 *      Unfortunately we cannot unload the DLL on process cleanup because
 *      FreeLibrary is spec'ed as not being safe from DllMain. However,
 *      we can clean up the list.
 *
 *      Note that the list is protected by the DLL mutex, which is held
 *      by any call attempting to create a pin.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RemovePerProcessKsUser"

VOID RemovePerProcessKsUser(
    DWORD dwProcessId)
{
    DPF_ENTER();

    KsUserProcessInstance *prev;
    KsUserProcessInstance *curr;

    for (prev = NULL, curr = pKsUserList; curr; prev = curr, curr = curr->pNext)
    {
        if (curr->dwProcessId == dwProcessId)
        {
            break;
        }
    }

    if (curr)
    {
        if (prev)
        {
            prev->pNext = curr->pNext;
        }
        else
        {
            pKsUserList = curr->pNext;
        }

        DELETE(curr);
    }

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\ksvad.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ksvad.cpp
 *  Content:    WDM/CSA Virtual Audio Device class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/25/97     dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifdef NOKS
#error ksvad.cpp being built with NOKS defined
#endif

#include "ksvad.h"      // Our public interface

// Default speaker index table; maps the first speaker (LEFT)
// to channel 0 and the second speaker (RIGHT) to channel 1.

INT CKsRenderDevice::m_anDefaultSpeakerIndexTable[] = {0, 1};


/***************************************************************************
 *
 *  CKsRenderDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CKsRenderDevice"

CKsRenderDevice::CKsRenderDevice
(
    void
)
    : CRenderDevice(VAD_DEVICETYPE_KSRENDER), CKsDevice(VAD_DEVICETYPE_KSRENDER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsRenderDevice);

    // Initialize defaults
    m_pPinCache = NULL;
    m_paTopologyInformation = NULL;
    m_pwfxFormat = NULL;
    m_nSrcQuality = DIRECTSOUNDMIXER_SRCQUALITY_DEFAULT;
    m_dwSpeakerConfig = -1;  // Invalid value; forces first SetSpeakerConfig() call to set it up
    m_hPin = NULL;
    m_liDriverVersion.QuadPart = 0;
    m_lSpeakerPositions = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
    m_ulChannelCount = 2;
    m_pnSpeakerIndexTable = m_anDefaultSpeakerIndexTable;
    m_ulPanNodeId = NODE_UNINITIALIZED;
    m_ulSurroundNodeId = NODE_UNINITIALIZED;
    m_ulDacNodeId = NODE_UNINITIALIZED;
    m_dwMinHwSampleRate = -1;
    m_dwMaxHwSampleRate = -1;
    m_fIncludeAec = FALSE;
    
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsRenderDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::~CKsRenderDevice"

CKsRenderDevice::~CKsRenderDevice
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsRenderDevice);

    CLOSE_HANDLE(m_hPin);

    RELEASE(m_pPinCache);

    MEMFREE(m_paTopologyInformation);
    MEMFREE(m_pwfxFormat);
    if (m_pnSpeakerIndexTable != m_anDefaultSpeakerIndexTable)
        MEMFREE(m_pnSpeakerIndexTable);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::Initialize"

HRESULT
CKsRenderDevice::Initialize
(
    CDeviceDescription *    pDesc
)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    ASSERT(CDevice::m_vdtDeviceType == pDesc->m_vdtDeviceType);
    ASSERT(CKsDevice::m_vdtKsDevType == pDesc->m_vdtDeviceType);

    // Initialize the base classes
    hr = CKsDevice::Initialize(pDesc);

    if(SUCCEEDED(hr))
    {
        hr = CRenderDevice::Initialize(pDesc);
    }

    // Get topology information
    if(SUCCEEDED(hr))
    {
        m_paTopologyInformation = MEMALLOC_A(KSRDTOPOLOGY, m_ulPinCount);
        hr = HRFROMP(m_paTopologyInformation);
    }

    for(ULONG i = 0; i < m_ulValidPinCount && SUCCEEDED(hr); i++)
    {
        hr = GetTopologyInformation(m_paTopologies[m_pulValidPins[i]],
                                   &m_paTopologyInformation[m_pulValidPins[i]]);
    }

    // Order the valid pins from least-capable to most-capable (manbug 30402)
    if(SUCCEEDED(hr))
    {
        PULONG pulValidPinsCopy = MEMALLOC_A(ULONG, m_ulValidPinCount);
        hr = HRFROMP(pulValidPinsCopy);
        if(SUCCEEDED(hr))
        {
            CopyMemory(pulValidPinsCopy, m_pulValidPins, sizeof(ULONG) * m_ulValidPinCount);

            HRESULT hrTemp;
            ULONG i;
            int nCurSlot = 0;

            // Place the pins not capable of HW 3D first in the list
            for(i = 0; i < m_ulValidPinCount; i++)
            {
                hrTemp = ValidatePinCaps(m_pulValidPins[i], DSBCAPS_LOCHARDWARE|DSBCAPS_CTRL3D, GUID_NULL);
                if (FAILED(hrTemp))
                {
                    m_pulValidPins[nCurSlot++] = pulValidPinsCopy[i];
                    pulValidPinsCopy[i] = -1;
                }
            }

            // Now place all the others pins
            for(i = 0; i < m_ulValidPinCount; i++)
            {
                if (pulValidPinsCopy[i] != -1)
                {
                    m_pulValidPins[nCurSlot++] = pulValidPinsCopy[i];
                }
            }

            MEMFREE(pulValidPinsCopy);
        }
    }

    // Determine the Virtual Source Index which will be used to associate
    // each pin with the Wave Out master volume.
    if(SUCCEEDED(hr))
    {
        hr = KsCreateSysAudioVirtualSource(m_hDevice, &m_ulVirtualSourceIndex);

        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "Can't create virtual source");
        }
    }

    // Initialize the default format
    if(SUCCEEDED(hr))
    {
        m_pwfxFormat = AllocDefWfx();
        hr = HRFROMP(m_pwfxFormat);
    }

    // Create the pin cache
    if(SUCCEEDED(hr))
    {
        m_pPinCache = NEW(CKsRenderPinCache);
        hr = HRFROMP(m_pPinCache);
    }

    // Get the driver version number
    if(SUCCEEDED(hr))
    {
        GetDriverVersion(&m_liDriverVersion);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCAPS structure with the capabilities of the device.
 *
 *  Arguments:
 *      LPDSCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetCaps"

HRESULT
CKsRenderDevice::GetCaps
(
    LPDSCAPS                pCaps
)
{
    BOOL                    fHardwareRenderer   = TRUE;
    HRESULT                 hr                  = DS_OK;
    KSDATARANGE_AUDIO       DataRange;
    KSPIN_CINSTANCES        PinInstances;
    KSPIN_CINSTANCES        ThreedPinInstances;

    DPF_ENTER();

    ASSERT(sizeof(*pCaps) == pCaps->dwSize);

    // Get caps for the hardware renderer
    hr = GetKsDeviceCaps(DSBCAPS_LOCHARDWARE, GUID_NULL, &DataRange, &PinInstances, &ThreedPinInstances);

    // If we failed to find a hardware renderer, go ahead and get software caps
    if(S_FALSE == hr)
    {
        DPF(DPFLVL_MOREINFO, "No hardware renderer found.  Getting software renderer caps");
        fHardwareRenderer = FALSE;
        hr = GetKsDeviceCaps(DSBCAPS_LOCSOFTWARE, GUID_NULL, &DataRange, &PinInstances, &ThreedPinInstances);
    }

    if(S_FALSE == hr)
    {
        DPF(DPFLVL_ERROR, "No usable renderer found!");
        ASSERT(S_FALSE != hr);
        hr = DSERR_NODRIVER;
    }

    // Fill out caps structure
    if(SUCCEEDED(hr))
    {
        ZeroMemoryOffset(pCaps, pCaps->dwSize, sizeof(pCaps->dwSize));

#pragma TODO("We should qualify whether or not the driver really does support CONTINUOUSRATE")

        pCaps->dwFlags = DSCAPS_CONTINUOUSRATE;

        if(DataRange.MaximumChannels >= 1)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYMONO | DSCAPS_SECONDARYMONO;
        }

        if(DataRange.MaximumChannels >= 2)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYSTEREO | DSCAPS_SECONDARYSTEREO;
        }

        if(DataRange.MinimumBitsPerSample <= 8 && DataRange.MaximumBitsPerSample >= 8)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARY8BIT | DSCAPS_SECONDARY8BIT;
        }

        if(DataRange.MinimumBitsPerSample <= 16 && DataRange.MaximumBitsPerSample >= 16)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARY16BIT | DSCAPS_SECONDARY16BIT;
        }

        pCaps->dwMinSecondarySampleRate = DataRange.MinimumSampleFrequency;
        pCaps->dwMaxSecondarySampleRate = DataRange.MaximumSampleFrequency;

        // Cache this data for use by GetFrequencyRange()
        m_dwMinHwSampleRate = pCaps->dwMinSecondarySampleRate;
        m_dwMaxHwSampleRate = pCaps->dwMaxSecondarySampleRate;

        if(fHardwareRenderer)
        {
            pCaps->dwMaxHwMixingAllBuffers  = pCaps->dwMaxHwMixingStaticBuffers  = pCaps->dwMaxHwMixingStreamingBuffers  = PinInstances.PossibleCount;
            pCaps->dwFreeHwMixingAllBuffers = pCaps->dwFreeHwMixingStaticBuffers = pCaps->dwFreeHwMixingStreamingBuffers = PinInstances.PossibleCount - PinInstances.CurrentCount;
            pCaps->dwMaxHw3DAllBuffers      = pCaps->dwMaxHw3DStaticBuffers      = pCaps->dwMaxHw3DStreamingBuffers      = ThreedPinInstances.PossibleCount;
            pCaps->dwFreeHw3DAllBuffers     = pCaps->dwFreeHw3DStaticBuffers     = pCaps->dwFreeHw3DStreamingBuffers     = ThreedPinInstances.PossibleCount - ThreedPinInstances.CurrentCount;
        }

        pCaps->dwReserved1 = m_liDriverVersion.LowPart;
        pCaps->dwReserved2 = m_liDriverVersion.HighPart;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetFrequencyRange
 *
 *  Description:
 *      Obtains this device's minimum and maximum supported frequencies.
 *      Caches this information to avoid repeated calls to GetCaps().
 *
 *  Arguments:
 *      LPDWORD [out]: 
 *      LPDWORD [out]: 
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetFrequencyRange"

HRESULT CKsRenderDevice::GetFrequencyRange(LPDWORD pdwMinHwSampleRate, LPDWORD pdwMaxHwSampleRate)
{
    HRESULT hr = DSERR_GENERIC;
    DPF_ENTER();

    ASSERT(pdwMinHwSampleRate && pdwMaxHwSampleRate);

    if (m_dwMinHwSampleRate == -1)
    {
        DSCAPS dscaps;
        InitStruct(&dscaps, sizeof dscaps);
        GetCaps(&dscaps);
    }

    if (m_dwMinHwSampleRate != -1)
    {
        *pdwMinHwSampleRate = m_dwMinHwSampleRate;
        *pdwMaxHwSampleRate = m_dwMaxHwSampleRate;
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetKsDeviceCaps
 *
 *  Description:
 *      Gets capabilities for the underlying KS device.
 *
 *  Arguments:
 *      DWORD [in]: device location flags.
 *      REFGUID [in]: 3D algorithm identifier.
 *      PKSDATARANGE_AUDIO [out]: receives aggregate dataranges for all
 *                                pins.
 *      PKSPIN_CINSTANCES [out]: receives aggregate instance count of
 *                               pins.
 *      PKSPIN_CINSTANCES [out]: receives aggregate instance count of
 *                               3D pins.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetKsDeviceCaps"

HRESULT
CKsRenderDevice::GetKsDeviceCaps
(
    DWORD                   dwLocation,
    REFGUID                 guid3dAlgorithm,
    PKSDATARANGE_AUDIO      pAggregateDataRange,
    PKSPIN_CINSTANCES       pAggregatePinInstances,
    PKSPIN_CINSTANCES       pAggregateThreedPinInstances
)
{
    HRESULT                 hr                          = S_FALSE;
    KSDATARANGE_AUDIO       DataRange;
    PKSDATARANGE_AUDIO      pDataRange;
    KSPIN_CINSTANCES        PinInstances;
    PKSPIN_CINSTANCES       pPinInstances;
    KSPIN_CINSTANCES        ThreedPinInstances;
    PKSPIN_CINSTANCES       pThreedPinInstances;
    HRESULT                 hrTemp;

    DPF_ENTER();

    ASSERT(DSBCAPS_LOCSOFTWARE == dwLocation || DSBCAPS_LOCHARDWARE == dwLocation);

    ZeroMemory(pAggregateDataRange, sizeof(*pAggregateDataRange));
    ZeroMemory(pAggregatePinInstances, sizeof(*pAggregatePinInstances));
    ZeroMemory(pAggregateThreedPinInstances, sizeof(*pAggregateThreedPinInstances));

    pDataRange = pAggregateDataRange;
    pPinInstances = pAggregatePinInstances;
    pThreedPinInstances = pAggregateThreedPinInstances;

    // Get the audio data ranges and number of pins for all valid pins
    for(ULONG i = 0; i < m_ulValidPinCount; i++)
    {
        // Qualify the basic pin capabilities
        hrTemp = ValidatePinCaps(m_pulValidPins[i], dwLocation, guid3dAlgorithm);
        if(FAILED(hrTemp))
            continue;

        // Get audio datarange
        hr = KsGetPinPcmAudioDataRange(m_hDevice, m_pulValidPins[i], pDataRange);
        if(FAILED(hr))
            continue;

        if(pAggregateDataRange == pDataRange)
            pDataRange = &DataRange;
        else
            KsAggregatePinAudioDataRange(pDataRange, pAggregateDataRange);

        // Are we allowed to look for 2D pins?
        if((DSBCAPS_LOCHARDWARE == dwLocation) && (m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS))
            continue;

        // Get 2D pin instances. On WDM 1.0, fall back on the sysaudio property
        // to ask how many there really are
#ifndef WINNT
        if (g_ulWdmVersion == WDM_1_0)
        {
            hr = KsGetRenderPinInstances(m_hDevice, m_pulValidPins[i], pPinInstances);
        }
        else
#endif // !WINNT
        {
            hr = KsGetPinInstances(m_hDevice, m_pulValidPins[i], pPinInstances);
        }

        if(FAILED(hr))
            break;

        if(pAggregatePinInstances == pPinInstances)
            pPinInstances = &PinInstances;
        else
            KsAggregatePinInstances(pPinInstances, pAggregatePinInstances);

        // Are we allowed to look for 3D pins?
        if((DSBCAPS_LOCHARDWARE == dwLocation) && (m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D))
            continue;

        // Does the device even support 3D?
        hrTemp = ValidatePinCaps(m_pulValidPins[i], dwLocation | DSBCAPS_CTRL3D, GUID_NULL);
        if(FAILED(hrTemp))
            continue;

        // Get 3D pin instances
        hr = KsGetPinInstances(m_hDevice, m_pulValidPins[i], pThreedPinInstances);
        if(FAILED(hr))
            break;

        if(pAggregateThreedPinInstances == pThreedPinInstances)
            pThreedPinInstances = &ThreedPinInstances;
        else
            KsAggregatePinInstances(pThreedPinInstances, pAggregateThreedPinInstances);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePrimaryBuffer
 *
 *  Description:
 *      Creates a primary buffer object.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      LPVOID [in]: buffer instance identifier.
 *      CPrimaryRenderWaveBuffer ** [out]: receives pointer to primary
 *                                         buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CreatePrimaryBuffer"

HRESULT
CKsRenderDevice::CreatePrimaryBuffer
(
    DWORD                       dwFlags,
    LPVOID                      pvInstance,
    CPrimaryRenderWaveBuffer ** ppBuffer
)
{
    CKsPrimaryRenderWaveBuffer *pBuffer;
    HRESULT                     hr;

    DPF_ENTER();

    pBuffer = NEW(CKsPrimaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateSecondaryBuffer
 *
 *  Description:
 *      Creates a wave buffer.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      LPVOID [in]: buffer instance identifier.
 *      CSecondaryRenderWaveBuffer ** [out]: receives pointer to new wave
 *                                           buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CreateSecondaryBuffer"

HRESULT
CKsRenderDevice::CreateSecondaryBuffer
(
    LPCVADRBUFFERDESC               pDesc,
    LPVOID                          pvInstance,
    CSecondaryRenderWaveBuffer **   ppBuffer
)
{
    CKsSecondaryRenderWaveBuffer *  pBuffer;
    HRESULT                         hr;

    DPF_ENTER();

    pBuffer = NEW(CKsSecondaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(pDesc, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateKsSecondaryBuffer
 *
 *  Description:
 *      Creates a wave buffer.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      LPVOID [in]: buffer instance identifier.
 *      CSecondaryRenderWaveBuffer ** [out]: receives pointer to new wave
 *                                           buffer.
 *      CSysMemBuffer * [in]: System memory buffer to use.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CreateKsSecondaryBuffer"

HRESULT
CKsRenderDevice::CreateKsSecondaryBuffer
(
    LPCVADRBUFFERDESC               pDesc,
    LPVOID                          pvInstance,
    CSecondaryRenderWaveBuffer **   ppBuffer,
    CSysMemBuffer *                 pSysMemBuffer
)
{
    CKsSecondaryRenderWaveBuffer *  pBuffer;
    HRESULT                         hr;

    DPF_ENTER();

    pBuffer = NEW(CKsSecondaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(pDesc, NULL, pSysMemBuffer);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetGlobalFormat
 *
 *  Description:
 *      Retrieves the format for the device.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives format.
 *      LPDWORD [in/out]: size of the above format.  On entry, this argument
 *                        contains the size of the buffer.  On exit, this
 *                        contains the required size of the buffer.  Call
 *                        this function twice: once to get the size, and
 *                        again to get the actual data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetGlobalFormat"

HRESULT
CKsRenderDevice::GetGlobalFormat
(
    LPWAVEFORMATEX          pwfxFormat,
    LPDWORD                 pdwSize
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CopyWfxApi(m_pwfxFormat, pwfxFormat, pdwSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetGlobalFormat
 *
 *  Description:
 *      Sets the format for the device.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: new format, or NULL to reapply the current
 *                           format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::SetGlobalFormat"

HRESULT
CKsRenderDevice::SetGlobalFormat
(
    LPCWAVEFORMATEX                     pwfxFormat
)
{
    LPWAVEFORMATEX                      pwfxOld = m_pwfxFormat;
    CNode<CPrimaryRenderWaveBuffer *> * pNode;
    HRESULT                             hr;

    DPF_ENTER();

    // Save a copy of the new format
    m_pwfxFormat = CopyWfxAlloc(pwfxFormat);
    hr = HRFROMP(m_pwfxFormat);

    // Update all primary buffers
    for(pNode = m_lstPrimaryBuffers.GetListHead(); pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
    {
        hr = ((CKsPrimaryRenderWaveBuffer *)pNode->m_data)->OnSetFormat();
    }

    // Clean up
    if(SUCCEEDED(hr))
    {
        MEMFREE(pwfxOld);
    }
    else
    {
        MEMFREE(m_pwfxFormat);
        m_pwfxFormat = pwfxOld;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSrcQuality
 *
 *  Description:
 *      Sets the mixer's SRC quality.
 *
 *  Arguments:
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: mixer SRC quality.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::SetSrcQuality"

HRESULT
CKsRenderDevice::SetSrcQuality
(
    DIRECTSOUNDMIXER_SRCQUALITY             SrcQuality
)
{
    CNode<CSecondaryRenderWaveBuffer *> *   pNode;

    DPF_ENTER();

    // Update all existing buffers.  We don't care if they succeed or not.
    for(pNode = m_lstSecondaryBuffers.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        ((CKsSecondaryRenderWaveBuffer *)pNode->m_data)->SetSrcQuality(SrcQuality);
    }

    // Save the new SRC quality as the default
    m_nSrcQuality = SrcQuality;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Tries to set the device's speaker configuration.  If successful,
 *      stores it in m_dwSpeakerConfig.  Some pseudocode follows:
 *
 *      1. If no pins have yet been instantiated: set the config and geometry
 *      on the DAC node, if found. (Assumes that this node can only be found
 *      on the driver.)  (If the config is Surround and the card has a Dolby
 *      encoder, this should force the card into 4-channel mode.)
 *
 *      2. If no pins instantiated: if the speaker config is Surround, try to
 *      enable kmixer's encoder.  (Will fail if the card's in 4-channel mode,
 *      which is correct.)
 *
 *      3. If pins instantiated: read the pan node's channel config, and see
 *      if it supports the requested spk. config - otherwise, fail the call.
 *
 *      Usage A: When dsound opens a KS device, SetSpeakerConfig() gets called
 *      twice (once before any pins are instantiated, once after), so if all
 *      goes well the second call should succeed.
 *
 *      Usage B: When an app calls the API's SetSpeakerConfig(), the KS device
 *      must already be open, hence the call will fail unless we're already in
 *      the configuration requested - which is correct.  (I'm not about to try
 *      to tear down all the pins, change the config and recreate them - apart
 *      from the glitching involved, this isn't guaranteed to work anyway,
 *      since most drivers can't change mode if ANY streams are active on them,
 *      including non-dsound ones.)  This API call always changes the config in
 *      the registry and returns DS_OK, even if it fails, so next time dsound
 *      starts up another attempt will be made to set the config.
 *
 *      The astute reader will have noticed a flaw in all this: if we enable
 *      kmixer's surround encoder, and the app creates a Pan3D buffer which
 *      happens to get a HW-accelerated pin, we'll only have two channels to
 *      play with, not four.  To handle this, CreateMultiPan3dObject() checks
 *      the supermix table on the pin, and if it doesn't have the expected no.
 *      of outputs we drop down to stereo Pan3D.
 *
 *  Arguments:
 *      DWORD [in]: speaker configuration in dsound DSSPEAKER format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::SetSpeakerConfig"

HRESULT CKsRenderDevice::SetSpeakerConfig(DWORD dwReqSpeakerConfig)
{
    LONG lKsSpeakerConfig;
    LONG lKsStereoSpeakerGeometry;
    HRESULT hr, hrTemp;
    DPF_ENTER();

    DPF(DPFLVL_MOREINFO, "Current configuration is 0x%8.8lX; requested 0x%8.8lX; %s created",
        m_dwSpeakerConfig, dwReqSpeakerConfig, m_hPin ? TEXT("some pins already") : TEXT("no pins yet"));

    // First let the base class do its thing
    hr = CRenderDevice::SetSpeakerConfig(dwReqSpeakerConfig);

    // Only do any work if the speaker config is changing
    if (SUCCEEDED(hr) && (dwReqSpeakerConfig != m_dwSpeakerConfig))
    {
        DsSpeakerConfigToKsProperties(dwReqSpeakerConfig, &lKsSpeakerConfig, &lKsStereoSpeakerGeometry);

        // Inform the driver (via its DAC node) of the speaker config change.
        // This will fail (harmlessly) on some cards with DS3D acceleration,
        // which expect this info on the 3D node of a specific pin instance;
        // these cards will be handled by the legacy code in ks3d.cpp.
        if (IS_VALID_NODE(m_ulDacNodeId))  // We found a DAC node
        {
            hrTemp = KsSetNodeProperty(m_hDevice, KSPROPSETID_Audio, KSPROPERTY_AUDIO_CHANNEL_CONFIG,
                                       m_ulDacNodeId, &lKsSpeakerConfig, sizeof lKsSpeakerConfig);
            DPF(DPFLVL_MOREINFO, "Setting the CHANNEL_CONFIG property on the DAC returned %s", HRESULTtoSTRING(hrTemp));

            // NOTE: if the speaker config is Surround, and the card supports it, this call will succeed
            // and set up a >2 channel config on the card, which will make kmixer refuse to enable its
            // surround node below; that should make multichannel Pan3D work fine, so all is well.

            if (SUCCEEDED(hrTemp) && lKsSpeakerConfig == KSAUDIO_SPEAKER_STEREO)
            {
                // In this case, we should set the speaker "geometry" (angular separation) too.
                hrTemp = KsSetNodeProperty(m_hDevice, KSPROPSETID_Audio, KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
                                           m_ulDacNodeId, &lKsStereoSpeakerGeometry, sizeof lKsStereoSpeakerGeometry);
                DPF(DPFLVL_MOREINFO, "Setting the SPEAKER_GEOMETRY property on the DAC returned %s", HRESULTtoSTRING(hrTemp));
            }

            // NOTE 2: we don't care whether these calls succeed or fail (either because the driver
            // doesn't support them, or because it has active streams and can't reconfigure itself);
            // what matters is whether the card ends up in the requested speaker, and we check this
            // below, indirectly, by looking at kmixer's output format.
        }

        // Enable of disable the Prologic surround encoder node in KMixer if necessary.
        // This only works if no pins have yet been instantiated.
        if (IS_VALID_NODE(m_ulSurroundNodeId) &&            // We have a Surround node...
            (m_hPin == NULL) &&                             // No pins have been created yet...
            (m_dwSpeakerConfig == -1 ||                     // We haven't got a speaker config yet...
            ((dwReqSpeakerConfig == DSSPEAKER_SURROUND) !=  // or the surround state is changing
             (m_dwSpeakerConfig == DSSPEAKER_SURROUND))))
        {
            BOOL fEnable = (dwReqSpeakerConfig == DSSPEAKER_SURROUND);
            hrTemp = KsSetNodeProperty(m_hDevice, KSPROPSETID_Audio, KSPROPERTY_AUDIO_SURROUND_ENCODE,
                                       m_ulSurroundNodeId, &fEnable, sizeof fEnable);

            DPF(FAILED(hrTemp) ? DPFLVL_WARNING : DPFLVL_MOREINFO,
                "%sabling KMixer's Surround encoder returned %s (failure expected on Win2K)",
                fEnable ? TEXT("En") : TEXT("Dis"), HRESULTtoSTRING(hrTemp));
        }

        // Ask the pan node (immediately after supermix) for its channel positions table.
        // This can only work if some pin has been instantiated - any will do; we use m_hPin.
        if (IS_VALID_NODE(m_ulPanNodeId) && (m_hPin != NULL))
        {
            KSAUDIO_CHANNEL_CONFIG ChannelConfig;
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_CHANNEL_CONFIG,
                                   m_ulPanNodeId, &ChannelConfig, sizeof ChannelConfig);
            if (FAILED(hr))
            {
                DPF(DPFLVL_WARNING, "Failed to obtain the pan node's channel config (%s)", HRESULTtoSTRING(hr));
            }
            else // Save the channel positions, to support SetChannelVolume()
            {
                if (m_pnSpeakerIndexTable != m_anDefaultSpeakerIndexTable)
                    MEMFREE(m_pnSpeakerIndexTable);
                m_pnSpeakerIndexTable = MEMALLOC_A(int, MAX_SPEAKER_POSITIONS);
                hr = HRFROMP(m_pnSpeakerIndexTable);

                if (FAILED(hr))
                    m_pnSpeakerIndexTable = m_anDefaultSpeakerIndexTable;
                else
                {
                    m_lSpeakerPositions = ChannelConfig.ActiveSpeakerPositions;
                    m_ulChannelCount = 0;
                    int nIndex = 0;

                    for (LONG lSpkr = 1; lSpkr != SPEAKER_ALL; lSpkr <<= 1)
                        m_pnSpeakerIndexTable[nIndex++] = (m_lSpeakerPositions & lSpkr) ? m_ulChannelCount++ : -1;
                    ASSERT(m_ulChannelCount == ULONG(CountBits(m_lSpeakerPositions)));

                    // Figure out if our channel positions now match the requested speaker config
                    if (m_lSpeakerPositions == lKsSpeakerConfig)
                    {
                        // Success; update our copy of the speaker configuration
                        m_dwSpeakerConfig = dwReqSpeakerConfig;
                    }
                    else
                    {
                        DPF(DPFLVL_WARNING, "Pan node's channel config (0x%lX) doesn't match requested config (0x%lX)",
                            m_lSpeakerPositions, lKsSpeakerConfig);
                    }

                    // FIXME: for now we require a perfect match between our
                    // desired speaker config and the real channel config.
                    // Later on we could allow cases in which the former is
                    // a subset of the latter, but we'd have to maintain a
                    // mapping from our speaker positions to KS's channels.
                }
            }
        }

        // Finally, make sure we return a useful return code
        if (SUCCEEDED(hr) && (m_dwSpeakerConfig != dwReqSpeakerConfig))
        {
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CreateRenderPin
 *
 *  Description:
 *      Creates a pin.
 *
 *  Arguments:
 *      ULONG [in]: pin id.
 *      DWORD [in]: buffer flags.
 *      LPCWAVEFORMATEX [in]: pin format.
 *      REFGUID [in]: pin 3D algorithm.
 *      LPHANDLE [out]: receives pin handle.
 *      PULONG [out]: receives pin id.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CreateRenderPin"

HRESULT
CKsRenderDevice::CreateRenderPin
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    LPHANDLE                phPin,
    PULONG                  pulPinId
)
{
#ifdef NO_DSOUND_FORMAT_SPECIFIER
    PKSAUDIOPINDESC         pPinDesc    = NULL;
#else
    LPVOID                  pPinDesc    = NULL;
#endif

    HANDLE                  hPin        = NULL;
    HRESULT                 hr;
    PKSPIN_CONNECT          pConnect    = NULL;

    DPF_ENTER();

    // If no pin id was specified, we'll try each pin id until one succeeds

    if(-1 == ulPinId)
    {
        hr = DSERR_NODRIVER;
        for(ULONG i = 0; i < m_ulValidPinCount && FAILED(hr); i++)
            hr = CreateRenderPin(m_pulValidPins[i], dwFlags, pwfxFormat, guid3dAlgorithm, phPin, pulPinId);
    }
    else
    {
        // Validate that the pin id is capable of creating this pin
        hr = ValidatePinCaps(ulPinId, dwFlags, guid3dAlgorithm);

        // If specified, make sysaudio include AEC in the render graph
        if(SUCCEEDED(hr) && m_fIncludeAec)
        {
            // Validate that the pin id is capable of creating this pin
            hr = m_paTopologies[ulPinId]->FindRenderPinWithAec
                 (
                     phPin,
                     NULL,
                     NULL,
                     m_guidAecInstance,
                     m_dwAecFlags,
                     &m_paTopologyInformation[ulPinId].AecNode
                 );

            if(SUCCEEDED(hr) && IS_VALID_NODE(m_paTopologyInformation[ulPinId].AecNode.NodeId))
            {
                hr = KsSysAudioSelectGraph
                     (
                         m_hDevice,
                         ulPinId,
                         m_paTopologyInformation[ulPinId].AecNode.NodeId
                     );

                if(FAILED(hr))
                {
                    DPF(DPFLVL_ERROR, "Unable to set SysAudio device instance");

                    // If KsSysAudioSelectGraph() fails, we assume that it is
                    // because the graph has already been built without AEC,
                    // and return a useful return code:
                    hr = DSERR_FXUNAVAILABLE;
                }
            }
        }

        // Build the pin description
        if(SUCCEEDED(hr))
        {
#ifdef NO_DSOUND_FORMAT_SPECIFIER

            hr = KsBuildRenderPinDescription(ulPinId, pwfxFormat, &pPinDesc);
            pConnect = &pPinDesc->Connect;

#else // NO_DSOUND_FORMAT_SPECIFIER

#ifndef WINNT
            if (g_ulWdmVersion == WDM_1_0)
            {
                hr = KsBuildRenderPinDescription_10(ulPinId, dwFlags, pwfxFormat, guid3dAlgorithm, (PKSDSRENDERPINDESC_10 *)&pPinDesc);
                pConnect = &((PKSDSRENDERPINDESC_10)pPinDesc)->Connect;
            }
            else
#endif // !WINNT
            {
                hr = KsBuildRenderPinDescription(ulPinId, dwFlags, pwfxFormat, guid3dAlgorithm, (PKSDSRENDERPINDESC *)&pPinDesc);
                pConnect = &((PKSDSRENDERPINDESC)pPinDesc)->Connect;
            }

#endif // NO_DSOUND_FORMAT_SPECIFIER

        }

        // Create the pin
        if(SUCCEEDED(hr))
        {
            hr = CreatePin(pConnect, GENERIC_WRITE, KSSTATE_STOP, &hPin);
        }

        if(SUCCEEDED(hr))
        {
            if(!MakeHandleGlobal(&hPin))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }

#ifdef NO_DSOUND_FORMAT_SPECIFIER

        // Enable required nodes
        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRL3D))
        {
            hr = KsEnableTopologyNode(hPin, m_paTopologyInformation[ulPinId].ThreedNode.NodeId, TRUE);
        }

        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLFREQUENCY))
        {
            hr = KsEnableTopologyNode(hPin, m_paTopologyInformation[ulPinId].SrcNode.NodeId, TRUE);
        }

        if(SUCCEEDED(hr) && (dwFlags & (DSBCAPS_CTRLPAN
#ifdef FUTURE_MULTIPAN_SUPPORT
            | DSBCAPS_CTRLCHANNELVOLUME
#endif
            )))
        {
            hr = KsEnableTopologyNode(hPin, m_paTopologyInformation[ulPinId].PanNode.Node.NodeId, TRUE);
        }

        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLVOLUME))
        {
            hr = KsEnableTopologyNode(hPin, m_paTopologyInformation[ulPinId].VolumeNode.Node.NodeId, TRUE);
        }

        // Tell the 3D node which algorithm to use

#pragma TODO("Tell the 3D node which algorithm to use")

#endif // NO_DSOUND_FORMAT_SPECIFIER

        // Transition the pin to the pause state
        if(SUCCEEDED(hr))
        {
            hr = KsTransitionState(hPin, KSSTATE_STOP, KSSTATE_PAUSE);
        }

        // Success
        if(SUCCEEDED(hr))
        {
            *phPin = hPin;

            if(pulPinId)
            {
                *pulPinId = pConnect->PinId;
            }
        }
        else
        {
            CLOSE_HANDLE(hPin);
        }

        MEMFREE(pPinDesc);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetTopologyInformation
 *
 *  Description:
 *      Gets topology information.
 *
 *  Arguments:
 *      CKsDeviceTopology * [in]: topology object.
 *      PKSRDTOPOLOGY [out]: receives topology information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetTopologyInformation"

HRESULT
CKsRenderDevice::GetTopologyInformation
(
    CKsTopology *           pTopology,
    PKSRDTOPOLOGY           pInfo
)
{
    PKSTOPOLOGY_CONNECTION  pSummingConnection;
    PKSTOPOLOGY_CONNECTION  pSuperMixerConnection;
    PKSTOPOLOGY_CONNECTION  pSrcConnection;
    PKSTOPOLOGY_CONNECTION  pVolumeConnection;
    PKSTOPOLOGY_CONNECTION  pPanConnection;
    PKSTOPOLOGY_CONNECTION  pThreedConnection;
    PKSTOPOLOGY_CONNECTION  pMuteConnection;
    PKSTOPOLOGY_CONNECTION  pSurroundConnection;
    PKSTOPOLOGY_CONNECTION  pDacConnection;
    HRESULT                 hr;

    DPF_ENTER();

    // Find topology nodes
    pSummingConnection = pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_SUM);
    pSuperMixerConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_SUPERMIX);
    pSrcConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_SRC);
    pVolumeConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_VOLUME);
    pPanConnection = pTopology->FindControlConnection(pSuperMixerConnection, pSummingConnection, KSNODETYPE_VOLUME);
    pThreedConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_3D_EFFECTS);
    pMuteConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_MUTE);
    pSurroundConnection = pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_SURROUND_ENCODER);
    pDacConnection = pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_DAC);

    // Fill in data about each node
    hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSummingConnection), &pInfo->SummingNode);

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSuperMixerConnection), &pInfo->SuperMixNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSrcConnection), &pInfo->SrcNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetVolumeNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pVolumeConnection), &pInfo->VolumeNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetVolumeNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pPanConnection), &pInfo->PanNode);

        // This code is a little odd. We have as many CKsTopology objects as valid pins,
        // all identical except for the m_ulPinId member; and m_ulPinCount KSRDTOPOLOGY
        // structs, most of which are never filled in. Pending a full rewrite, we store
        // the node IDs we need to use in CKsRenderDevice in this hackish manner:
        if (IS_VALID_NODE(pInfo->PanNode.Node.NodeId) && pInfo->PanNode.Node.CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU)
        {
            if (m_ulPanNodeId == NODE_UNINITIALIZED)
            {
                m_ulPanNodeId = pInfo->PanNode.Node.NodeId;
                DPF(DPFLVL_MOREINFO, "Found kmixer's pan node id: %d", m_ulPanNodeId);
            }
            else
            {
                // Complain if we find two different SW pan nodes in the topology
                ASSERT(m_ulPanNodeId == pInfo->PanNode.Node.NodeId);
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pThreedConnection), &pInfo->ThreedNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pMuteConnection), &pInfo->MuteNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSurroundConnection), &pInfo->SurroundNode);

        // Bogus code follows - see comment above
        if (IS_VALID_NODE(pInfo->SurroundNode.NodeId) && pInfo->SurroundNode.CpuResources != KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU)
        {
            // We don't use "CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU" because kmixer
            // appears not to support KSPROPERTY_AUDIO_CPU_RESOURCES on its surround node.
            if (m_ulSurroundNodeId == NODE_UNINITIALIZED)
            {
                m_ulSurroundNodeId = pInfo->SurroundNode.NodeId;
                DPF(DPFLVL_MOREINFO, "Found kmixer's Surround node id: %d", m_ulSurroundNodeId);
            }
            else
            {
                // Complain if we find 2 different SW surround nodes in the topology
                ASSERT(m_ulSurroundNodeId == pInfo->SurroundNode.NodeId);
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pDacConnection), &pInfo->DacNode);

        // Bogus code follows - see comment above
        if (IS_VALID_NODE(pInfo->DacNode.NodeId) && pInfo->DacNode.CpuResources != KSAUDIO_CPU_RESOURCES_HOST_CPU)
        {
            if (m_ulDacNodeId == NODE_UNINITIALIZED)
            {
                m_ulDacNodeId = pInfo->DacNode.NodeId;
                DPF(DPFLVL_MOREINFO, "Found driver's DAC node id: %d", m_ulDacNodeId);
            }
            else
            {
                // Complain if we find two different DACs on the card
                ASSERT(m_ulDacNodeId == pInfo->DacNode.NodeId);
            }
        }
    }

    // Set the AecNode to UNITIALIZED since we cannot determine the
    // NodeId and the CpuResources until the FullDuplexObject is created.
    if(SUCCEEDED(hr))
    {
        pInfo->AecNode.NodeId = NODE_UNINITIALIZED;
        pInfo->AecNode.CpuResources = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  ValidatePinCaps
 *
 *  Description:
 *      Validates that certain capabilities of the pin are implemented.
 *
 *  Arguments:
 *      ULONG [in]: pin id.
 *      DWORD [in]: buffer flags.
 *      REFGUID [in]: 3D algorithm.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::ValidatePinCaps"

HRESULT
CKsRenderDevice::ValidatePinCaps
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    REFGUID                 guid3dAlgorithm
)
{
    ULONG                   ulInvalidCpuResources   = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;
    HRESULT                 hr                      = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_READ_PTR(m_paTopologyInformation, (ulPinId+1) * sizeof *m_paTopologyInformation));
    if (!m_paTopologyInformation)
    {
        // This should never happen, but it has happened, in stress.
        // So we treat the symptom and at least don't GPF (OSR 139942).
        hr = DSERR_GENERIC;
    }

    // Determine which CPU resource identifier is invalid.  We look for an
    // invalid identifier instead of a valid identifier because the node
    // may not actually exist (or may not support KSPROPERTY_AUDIO_CPU_RESOURCES).
    // If we don't have any resource information about the node, we assume
    // the best.

    if (SUCCEEDED(hr))
    {
        if(dwFlags & DSBCAPS_LOCHARDWARE)
        {
            ulInvalidCpuResources = KSAUDIO_CPU_RESOURCES_HOST_CPU;
        }
        else if(dwFlags & DSBCAPS_LOCSOFTWARE)
        {
            ulInvalidCpuResources = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
        }

        // Check required mixer resources
        if(KSAUDIO_CPU_RESOURCES_UNINITIALIZED != ulInvalidCpuResources)
        {
            if(ulInvalidCpuResources == m_paTopologyInformation[ulPinId].SummingNode.CpuResources)
            {
                DPF(DPFLVL_INFO, "Pin %d: Invalid CPU resources on summing node (%s)", ulPinId,
                    m_paTopologyInformation[ulPinId].SummingNode.CpuResources == KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU ? TEXT("NOT_HOST_CPU") :
                    m_paTopologyInformation[ulPinId].SummingNode.CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU ? TEXT("HOST_CPU") :
                    m_paTopologyInformation[ulPinId].SummingNode.CpuResources == KSAUDIO_CPU_RESOURCES_UNINITIALIZED ? TEXT("uninitialized") :
                    TEXT("impossible value!"));
                hr = DSERR_INVALIDCALL;
            }
        }
    }

    // Check required SRC resources
    if(SUCCEEDED(hr) && KSAUDIO_CPU_RESOURCES_UNINITIALIZED != ulInvalidCpuResources)
    {
        if(ulInvalidCpuResources == m_paTopologyInformation[ulPinId].SrcNode.CpuResources)
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid CPU resources on SRC node (%s)", ulPinId,
                m_paTopologyInformation[ulPinId].SrcNode.CpuResources == KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU ? TEXT("NOT_HOST_CPU") :
                m_paTopologyInformation[ulPinId].SrcNode.CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU ? TEXT("HOST_CPU") :
                m_paTopologyInformation[ulPinId].SrcNode.CpuResources == KSAUDIO_CPU_RESOURCES_UNINITIALIZED ? TEXT("uninitialized") :
                TEXT("impossible value!"));
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Check optional 3D resources
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRL3D))
    {
        if(!IS_VALID_NODE(m_paTopologyInformation[ulPinId].ThreedNode.NodeId))
        {
            // DPF(DPFLVL_MOREINFO, "Pin %d: Invalid 3D node", ulPinId);  // Too noisy
            hr = DSERR_CONTROLUNAVAIL;
        }

        if(SUCCEEDED(hr) && KSAUDIO_CPU_RESOURCES_UNINITIALIZED != ulInvalidCpuResources)
        {
            if(ulInvalidCpuResources == m_paTopologyInformation[ulPinId].ThreedNode.CpuResources)
            {
                DPF(DPFLVL_INFO, "Pin %d: Invalid CPU resources on 3D node (%s)", ulPinId,
                    m_paTopologyInformation[ulPinId].ThreedNode.CpuResources == KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU ? TEXT("NOT_HOST_CPU") :
                    m_paTopologyInformation[ulPinId].ThreedNode.CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU ? TEXT("HOST_CPU") :
                    m_paTopologyInformation[ulPinId].ThreedNode.CpuResources == KSAUDIO_CPU_RESOURCES_UNINITIALIZED ? TEXT("uninitialized") :
                    TEXT("impossible value!"));
                hr = DSERR_INVALIDCALL;
            }
        }
    }

    // Check optional SRC resources
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        if(!IS_VALID_NODE(m_paTopologyInformation[ulPinId].SrcNode.NodeId))
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid SRC node", ulPinId);
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

    // Check optional volume resources
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLVOLUME))
    {
        if(!IS_VALID_NODE(m_paTopologyInformation[ulPinId].VolumeNode.Node.NodeId))
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid volume node", ulPinId);
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

    // Check optional pan resources
    if(SUCCEEDED(hr) && (dwFlags & (DSBCAPS_CTRLPAN
#ifdef FUTURE_MULTIPAN_SUPPORT
        | DSBCAPS_CTRLCHANNELVOLUME
#endif
        )))
    {
        if(!IS_VALID_NODE(m_paTopologyInformation[ulPinId].PanNode.Node.NodeId))
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid pan node", ulPinId);
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

#ifdef FUTURE_MULTIPAN_SUPPORT
    // Check optional channel volume resources
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLCHANNELVOLUME))
    {
        // To support CTRLCHANNELVOLUME we need CTRLPAN support, plus support for the
        // KSPROPERTY_AUDIO_MIX_LEVEL_CAPS/TABLE on the Supermix node

        ULONG ulSuperMixNodeId = m_paTopologyInformation[ulPinId].SuperMixNode.NodeId;

        if(!IS_VALID_NODE(ulSuperMixNodeId))
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid supermix node", ulPinId);
            hr = DSERR_CONTROLUNAVAIL;
        }
        else
        {
            // FIXME: Check support for the properties above?
        }
    }
#endif // FUTURE_MULTIPAN_SUPPORT

#pragma TODO("Validate the 3D algorithm")

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  PreloadSoftwareGraph
 *
 *  Description:
 *      Pre-loads the software render graph.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::PreloadSoftwareGraph"

HRESULT
CKsRenderDevice::PreloadSoftwareGraph
(
    void
)
{
    HRESULT                 hr          = DSERR_NODRIVER;
    KSDATARANGE_AUDIO       DataRange;
    WAVEFORMATEX            wfx;

    DPF_ENTER();
    ASSERT(IS_VALID_READ_PTR(m_pulValidPins, m_ulValidPinCount * sizeof *m_pulValidPins));

    if (m_hPin == NULL)
    {
        // Create the pin we use to preload kmixer.  Note: if kmixer appears in more
        // than one pin ID's graph, only the first will be loaded.

        for(ULONG i = 0; i < m_ulValidPinCount && FAILED(hr); i++)
        {
            hr = ValidatePinCaps(m_pulValidPins[i], DSBCAPS_LOCSOFTWARE, GUID_NULL);

            if(SUCCEEDED(hr))
            {
                hr = KsGetPinPcmAudioDataRange(m_hDevice, m_pulValidPins[i], &DataRange);
            }

            if(SUCCEEDED(hr))
            {
                FillPcmWfx(&wfx, 1, DataRange.MinimumSampleFrequency, (WORD)DataRange.MinimumBitsPerSample);

                hr = CreateRenderPin(m_pulValidPins[i], DSBCAPS_LOCSOFTWARE, &wfx, GUID_NULL, &m_hPin, NULL);
            }
        }
    }
    else
    {
        // Got one last time
        hr = S_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CKsPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKsRenderDevice * [in]: parent device.
 *      LPVOID [in]: buffer instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::CKsPrimaryRenderWaveBuffer"

CKsPrimaryRenderWaveBuffer::CKsPrimaryRenderWaveBuffer
(
    CKsRenderDevice *       pKsDevice,
    LPVOID                  pvInstance
)
    : CPrimaryRenderWaveBuffer(pKsDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsPrimaryRenderWaveBuffer);

    // Initialize defaults
    m_pKsDevice = pKsDevice;
    m_p3dListener = NULL;
    m_pSecondaryBuffer = NULL;
    m_dwState = VAD_BUFFERSTATE_STOPPED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::~CKsPrimaryRenderWaveBuffer"

CKsPrimaryRenderWaveBuffer::~CKsPrimaryRenderWaveBuffer
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsPrimaryRenderWaveBuffer);

    // Free owned objects
    ABSOLUTE_RELEASE(m_p3dListener);
    ABSOLUTE_RELEASE(m_pSecondaryBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::Initialize"

HRESULT
CKsPrimaryRenderWaveBuffer::Initialize
(
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    VADRBUFFERDESC          vrbd;

    DPF_ENTER();

    // Preload the software graph
    hr = m_pKsDevice->PreloadSoftwareGraph();

    if(SUCCEEDED(hr))
    {
        vrbd.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_LOCSOFTWARE;
        vrbd.dwBufferBytes = DEF_PRIMARY_SIZE;
        vrbd.pwfxFormat = m_pKsDevice->m_pwfxFormat;
        vrbd.guid3dAlgorithm = GUID_NULL;

        hr = CPrimaryRenderWaveBuffer::Initialize(&vrbd, m_pSecondaryBuffer, NULL);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RequestWriteAccess
 *
 *  Description:
 *      Requests write access to the primary buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to request primary access, FALSE to relenquish it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::RequestWriteAccess"

HRESULT
CKsPrimaryRenderWaveBuffer::RequestWriteAccess
(
    BOOL                    fRequest
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // If we're becoming WRITEPRIMARY, we need to create a pin
    if(fRequest)
    {
        if(!m_pSecondaryBuffer)
        {
            hr = m_pKsDevice->CreateKsSecondaryBuffer(&m_vrbd, m_pvInstance, (CSecondaryRenderWaveBuffer **)&m_pSecondaryBuffer, m_pSysMemBuffer);

            if(SUCCEEDED(hr))
            {
                hr = SetState(m_dwState);
            }

            if(FAILED(hr))
            {
                RELEASE(m_pSecondaryBuffer);
            }
        }
    }
    else
    {
        RELEASE(m_pSecondaryBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = FixUpBaseClass();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::CommitToDevice"

HRESULT
CKsPrimaryRenderWaveBuffer::CommitToDevice
(
    DWORD                   ibCommit,
    DWORD                   cbCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pSecondaryBuffer);

    hr = m_pSecondaryBuffer->CommitToDevice(ibCommit, cbCommit);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::GetState"

HRESULT
CKsPrimaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();

    *pdwState = m_dwState;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::SetState"

HRESULT
CKsPrimaryRenderWaveBuffer::SetState(DWORD dwState)
{
    static const DWORD      dwValidMask     = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING | VAD_BUFFERSTATE_WHENIDLE;
    static const DWORD      dwSecondaryMask = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING;
    static const DWORD      dwPwiMask       = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_WHENIDLE;
    HRESULT                 hr              = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, dwValidMask));

    // Ignore any play when idle calls.  This state doesn't apply to
    // KS buffers.
    if((dwState & dwPwiMask) != dwPwiMask && m_pSecondaryBuffer)
    {
        hr = m_pSecondaryBuffer->SetState(dwState & dwSecondaryMask);

        if(SUCCEEDED(hr) && !(dwState & VAD_BUFFERSTATE_STARTED))
        {
            hr = m_pSecondaryBuffer->SetCursorPosition(0);
        }
    }

    if (SUCCEEDED(hr))
    {
        m_dwState = dwState;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::GetCursorPosition"

HRESULT
CKsPrimaryRenderWaveBuffer::GetCursorPosition
(
    LPDWORD                 pdwPlay,
    LPDWORD                 pdwWrite
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pSecondaryBuffer);

    hr = m_pSecondaryBuffer->GetCursorPosition(pdwPlay, pdwWrite);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  OnSetFormat
 *
 *  Description:
 *      Informs the primary buffer of a format change.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::OnSetFormat"

HRESULT
CKsPrimaryRenderWaveBuffer::OnSetFormat
(
    void
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    LPWAVEFORMATEX pwfex = CopyWfxAlloc(m_pKsDevice->m_pwfxFormat);
    hr = HRFROMP(pwfex);

    // Change the format of the secondary buffer
    if(SUCCEEDED(hr) && m_pSecondaryBuffer)
    {
        hr = m_pSecondaryBuffer->SetFormat(m_pKsDevice->m_pwfxFormat);
    }

    // Save format
    if (SUCCEEDED(hr))
    {
        MEMFREE(m_vrbd.pwfxFormat);
        m_vrbd.pwfxFormat = pwfex;
    }
    else
    {
        MEMFREE(pwfex);
    }

    // Fix up the base class
    if(SUCCEEDED(hr))
    {
        hr = FixUpBaseClass();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Create3dListener
 *
 *  Description:
 *      Creates the 3D listener.
 *
 *  Arguments:
 *      C3dListener ** [out]: receives pointer to the 3D listener object.
 *                            The caller is responsible for freeing this
 *                            object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::Create3dListener"

HRESULT
CKsPrimaryRenderWaveBuffer::Create3dListener
(
    C3dListener **          pp3dListener
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(!m_p3dListener)
    {
        m_p3dListener = NEW(CKs3dListener);
        hr = HRFROMP(m_p3dListener);
    }

    if(SUCCEEDED(hr))
    {
        *pp3dListener = ADDREF(m_p3dListener);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FixUpBaseClass
 *
 *  Description:
 *      Fixes up the CRenderWaveBuffer base class.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::FixUpBaseClass"

HRESULT
CKsPrimaryRenderWaveBuffer::FixUpBaseClass
(
    void
)
{
    HRESULT                 hr      = DS_OK;
    VADRBUFFERCAPS          vrbc;

    DPF_ENTER();

    if(m_pSecondaryBuffer)
    {
        hr = m_pSecondaryBuffer->GetCaps(&vrbc);

        if(SUCCEEDED(hr))
        {
            ASSERT(LXOR(vrbc.dwFlags & DSBCAPS_LOCHARDWARE, vrbc.dwFlags & DSBCAPS_LOCSOFTWARE));
            m_vrbd.dwFlags = (m_vrbd.dwFlags & ~DSBCAPS_LOCMASK) | (vrbc.dwFlags & DSBCAPS_LOCMASK);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CKsSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKsRenderDevice * [in]: parent device.
 *      LPVOID [in]: buffer instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CKsSecondaryRenderWaveBuffer"

CKsSecondaryRenderWaveBuffer::CKsSecondaryRenderWaveBuffer
(
    CKsRenderDevice *       pKsDevice,
    LPVOID                  pvInstance
)
    : CSecondaryRenderWaveBuffer(pKsDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsSecondaryRenderWaveBuffer);

    // Initialize defaults
    m_pKsDevice = pKsDevice;
    m_pPin = NULL;
    m_dwState = VAD_BUFFERSTATE_STOPPED;
    m_pCallbackEvent = NULL;
    m_pLoopingEvent = NULL;
    m_paNotes = NULL;
    m_pStopNote = NULL;
    m_cNotes = 0;
    m_dwPositionCache = 0;
    m_fNoVirtRequested = FALSE;
    m_fSoft3dAlgUnavail = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::~CKsSecondaryRenderWaveBuffer"

CKsSecondaryRenderWaveBuffer::~CKsSecondaryRenderWaveBuffer
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsSecondaryRenderWaveBuffer);

    // Stop the buffer
    SetStopState(FALSE, FALSE);

    // Forcibly release stuff in case SetStopState() failed
    if (m_pCallbackEvent)
    {
        m_pKsDevice->m_pEventPool->FreeEvent(m_pCallbackEvent);
        m_pCallbackEvent = NULL;
    }
    RELEASE(m_pLoopingEvent);

    // Free notification positions
    FreeNotificationPositions();

    // Free the pin
    FreePin(TRUE);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      LPCVADRBUFFERDESC [in]: buffer description.
 *      CKsSecondaryRenderWaveBuffer* [in]: pointer to the buffer to duplicate
 *                                          from, or NULL to initialize as a
 *                                          new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::Initialize"

HRESULT
CKsSecondaryRenderWaveBuffer::Initialize
(
    LPCVADRBUFFERDESC               pDesc,
    CKsSecondaryRenderWaveBuffer *  pSource,
    CSysMemBuffer *                 pSysMemBuffer
)
{
    DWORD                           dwLocationFlags;
    HRESULT                         hr;

    DPF_ENTER();

    ASSERT(LXOR(pDesc, pSource));

    // Initialize the base class
    hr = CSecondaryRenderWaveBuffer::Initialize(pDesc, pSource, pSysMemBuffer);

    // Mask off the location flags since they're not used here (only in AcquireResources)
    dwLocationFlags = m_vrbd.dwFlags & DSBCAPS_LOCMASK;
    m_vrbd.dwFlags &= ~DSBCAPS_LOCMASK;

    // If this is a 3D buffer, set up the fallback software 3D algorithm mechanism
    if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_CTRL3D))
    {
        // If NoVirt specifically requested, enable the fallback to 2D NoVirt hardware
        if(m_vrbd.guid3dAlgorithm == DS3DALG_NO_VIRTUALIZATION)
        {
            m_fNoVirtRequested = TRUE;
        }
        // If 3D algorithm is DS3DALG_DEFAULT (i.e. NULL), replace with default
        if(IS_NULL_GUID(&m_vrbd.guid3dAlgorithm))
        {
            m_vrbd.guid3dAlgorithm = *m_pKsDevice->GetDefault3dAlgorithm();
            DPF(DPFLVL_MOREINFO, "Using default 3D algorithm " DPF_GUID_STRING, DPF_GUID_VAL(m_vrbd.guid3dAlgorithm));
        }
        // The HRTF algorithms aren't supported on WDM 1.0, so in this case we
        // fall back to a NoVirt 2D software pin.
        if (g_ulWdmVersion == WDM_1_0 && (m_vrbd.guid3dAlgorithm == DS3DALG_HRTF_LIGHT ||
                                          m_vrbd.guid3dAlgorithm == DS3DALG_HRTF_FULL))
        {
            m_vrbd.guid3dAlgorithm = DS3DALG_NO_VIRTUALIZATION;
            m_fSoft3dAlgUnavail = TRUE;
            RPF(DPFLVL_MOREINFO, "WDM 1.0: Replacing HRTF 3D algorithm with NO_VIRTUALIZATION");
        }
        // 3D buffers need a frequency control for Doppler, unless they use effects, and the are not sink
        if (!(m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN))
        {
            m_vrbd.dwFlags |= DSBCAPS_CTRLFREQUENCY;
        }
    }

    // Set up the default buffer properties
    if(SUCCEEDED(hr))
    {
        if(pSource)
        {
            m_lVolume = pSource->m_lVolume;
            m_lPan = pSource->m_lPan;
            m_fMute = pSource->m_fMute;
            m_nSrcQuality = pSource->m_nSrcQuality;
        }
        else
        {
            m_lVolume = DSBVOLUME_MAX;
            m_lPan = DSBPAN_CENTER;
            m_fMute = FALSE;
            m_nSrcQuality = m_pKsDevice->m_nSrcQuality;
        }
    }

    // Acquire resources
    if(SUCCEEDED(hr) && !(m_vrbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        hr = AcquireResources(dwLocationFlags);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquires hardware resources for the buffer.
 *
 *  Arguments:
 *      DWORD [in]: location flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::AcquireResources"

HRESULT
CKsSecondaryRenderWaveBuffer::AcquireResources
(
    DWORD                   dwLocationFlags
)
{
    CKsRenderPin *          pPin    = NULL;
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());

    dwLocationFlags &= DSBCAPS_LOCMASK;

    // Modify the buffer flags to conform to the acceleration flags
    if(m_pKsDevice->m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS)
    {
        if(dwLocationFlags & DSBCAPS_LOCHARDWARE)
        {
            RPF(DPFLVL_ERROR, "Specified LOCHARDWARE with hardware buffer acceleration features disabled");
            hr = DSERR_INVALIDCALL;
        }
        else
        {
            dwLocationFlags = DSBCAPS_LOCSOFTWARE;
        }
    }

    if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_CTRL3D))
    {
        if(m_pKsDevice->m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D)
        {
            if(dwLocationFlags & DSBCAPS_LOCHARDWARE)
            {
                RPF(DPFLVL_ERROR, "Specified LOCHARDWARE | CTRL3D with hardware 3D acceleration features disabled");
                hr = DSERR_INVALIDCALL;
            }
            else
            {
                dwLocationFlags = DSBCAPS_LOCSOFTWARE;
            }
        }
    }

    // Acquire pin resources
    if(SUCCEEDED(hr))
    {
        hr = DSERR_GENERIC;
        m_hrSuccessCode = DS_OK;

        if(!(dwLocationFlags & DSBCAPS_LOCSOFTWARE))
        {
            // Try to create a hardware pin
            hr = CreatePin(m_vrbd.dwFlags | DSBCAPS_LOCHARDWARE, m_vrbd.pwfxFormat, GUID_NULL, &pPin);

            if(FAILED(hr) && m_fNoVirtRequested)
            {
                // The app specifically requested DS3DALG_NO_VIRTUALIZATION,
                // so try to create a NoVirt 2D hardware pin
                hr = CreatePin((m_vrbd.dwFlags & ~DSBCAPS_CTRL3D) | DSBCAPS_LOCHARDWARE | DSBCAPS_CTRLNOVIRT, m_vrbd.pwfxFormat, GUID_NULL, &pPin);
            }
        }
        if(FAILED(hr) && !(dwLocationFlags & DSBCAPS_LOCHARDWARE))
        {
            if ((m_vrbd.dwFlags & DSBCAPS_CTRL3D) && (m_vrbd.guid3dAlgorithm == DS3DALG_NO_VIRTUALIZATION))
            {
                // The app either wants NoVirt, or wanted an HRTF algorithm
                // which isn't supported on WDM 1.0; in either case, we try
                // to create a NoVirt 2D software pin.
                hr = CreatePin((m_vrbd.dwFlags & ~DSBCAPS_CTRL3D) | DSBCAPS_LOCSOFTWARE | DSBCAPS_CTRLNOVIRT, m_vrbd.pwfxFormat, GUID_NULL, &pPin);
                if (m_fSoft3dAlgUnavail)
                {
                    // The app had asked for an unsupported HRTF algorithm;
                    // return special success code DS_NO_VIRTUALIZATION.
                    m_hrSuccessCode = DS_NO_VIRTUALIZATION;
                }
            }
            else
            {
                // Try to create a software pin
                hr = CreatePin(m_vrbd.dwFlags | DSBCAPS_LOCSOFTWARE, m_vrbd.pwfxFormat, m_vrbd.guid3dAlgorithm, &pPin);
            }
        }
    }

    // Handle resource acquistion
    if(SUCCEEDED(hr))
    {
        hr = HandleResourceAcquisition(pPin);
        if (FAILED(hr))
            RELEASE(pPin);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  StealResources
 *
 *  Description:
 *      Steals hardware resources from another object.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer * [in]: source object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::StealResources"

HRESULT
CKsSecondaryRenderWaveBuffer::StealResources
(
    CSecondaryRenderWaveBuffer *    pSource
)
{
    CKsSecondaryRenderWaveBuffer *  pKsSource   = (CKsSecondaryRenderWaveBuffer *)pSource;
    CKsRenderPin *                  pPin;
    HRESULT                         hr;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());
    ASSERT(pKsSource->HasAcquiredResources());

    // Steal the pin
    pPin = ADDREF(pKsSource->m_pPin);

    // Free the source buffer's resources
    hr = pKsSource->FreeResources();

    // Synch up buffer and pin properties
    if(SUCCEEDED(hr))
    {
        hr = HandleResourceAcquisition(pPin);
        if (FAILED(hr))
            RELEASE(pPin);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePin
 *
 *  Description:
 *      Creates a pin.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *      LPCWAVEFORMATEX [in]: format.
 *      REFGUID [in]: 3D algorithm.
 *      CKsRenderPin ** [out]: receives pin.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreatePin"

HRESULT
CKsSecondaryRenderWaveBuffer::CreatePin
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    CKsRenderPin **         ppPin
)
{
    CKsRenderPin *          pPin    = NULL;
    HRESULT                 hr;

    DPF_ENTER();

    // Can we get a pin from the cache?  If not, create a new one
    hr = m_pKsDevice->m_pPinCache->GetPinFromCache(dwFlags, pwfxFormat, guid3dAlgorithm, &pPin);

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p reusing pin at 0x%p", this, pPin);
    }
    else
    {
        pPin = NEW(CKsRenderPin(m_pKsDevice));
        hr = HRFROMP(pPin);

        if(SUCCEEDED(hr))
        {
            hr = pPin->Initialize(dwFlags, pwfxFormat, guid3dAlgorithm);
        }
    }

    if(SUCCEEDED(hr))
    {
        *ppPin = pPin;
    }
    else
    {
        ABSOLUTE_RELEASE(pPin);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  HandleResourceAcquisition
 *
 *  Description:
 *      Applies all buffer properties to the pin.
 *
 *  Arguments:
 *      CKsRenderPin * [in]: pin.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::HandleResourceAcquisition"

HRESULT
CKsSecondaryRenderWaveBuffer::HandleResourceAcquisition
(
    CKsRenderPin *          pPin
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());

    // If we're CTRLCHANNELVOLUME, set up the supermix table accordingly.
    // FIXME: we only have to keep redoing this here if the pin can be used
    // for non-CTRLCHANNELVOLUME playback too, which is impossible?

    // FIXME: if a pin has previously had SetSuperMix() called on it and is
    // then stolen or recycled as a normal pin, we should set the supermix
    // table back to the usual "only first 2 channels active" mode.

#ifdef FUTURE_MULTIPAN_SUPPORT
    if(m_vrbd.dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
    {
        hr = pPin->SetSuperMix();
    }
#endif

    // Set attenuation levels
    if (SUCCEEDED(hr) && (pPin->m_dwFlags & DSBCAPS_CTRLVOLUME))
    {
        hr = pPin->SetVolume(m_lVolume);
    }

    if(SUCCEEDED(hr) && (pPin->m_dwFlags & DSBCAPS_CTRLPAN))
    {
        hr = pPin->SetPan(m_lPan);
    }

    // Set mute.  We have to set mute after setting volume because
    // SetMute may change the current pin volume.
    if(SUCCEEDED(hr))
    {
        hr = pPin->SetMute(m_fMute);
    }

    // Set frequency
    if(SUCCEEDED(hr) && (pPin->m_dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        hr = pPin->SetFrequency(m_vrbd.pwfxFormat->nSamplesPerSec);
    }

    // Set SRC quality.  We don't care if this succeeds or not.
    if(SUCCEEDED(hr))
    {
        pPin->SetSrcQuality(m_nSrcQuality);
    }

    // Enable notification positions
    if(SUCCEEDED(hr))
    {
        hr = pPin->EnableNotificationPositions(m_paNotes, m_cNotes);
    }

    // Set the pin position
    if(SUCCEEDED(hr))
    {
        hr = pPin->SetCursorPosition(m_dwPositionCache);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has acquired resources at 0x%p", this, pPin);

        // Save a pointer to the pin object
        m_pPin = pPin;

        // Set our buffer location according to the pin's location
        m_vrbd.dwFlags |= (pPin->m_dwFlags & DSBCAPS_LOCMASK);

        ASSERT(HasAcquiredResources());
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeResources
 *
 *  Description:
 *      Frees the pin and all resources attached to it.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::FreeResources"

HRESULT
CKsSecondaryRenderWaveBuffer::FreeResources
(
    void
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = FreePin(FALSE);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreePin
 *
 *  Description:
 *      Frees the pin.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to cache the pin before freeing.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::FreePin"

HRESULT
CKsSecondaryRenderWaveBuffer::FreePin
(
    BOOL                    fCache
)
{
    const DWORD             dwNoCacheMask   = DSBCAPS_PRIMARYBUFFER | DSBCAPS_LOCHARDWARE;
    HRESULT                 hr              = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        // Make sure the pin is stopped
        hr = SetStopState(FALSE, TRUE);

        // Save the buffer position
        if(SUCCEEDED(hr))
        {
            hr = GetCursorPosition(&m_dwPositionCache, NULL);
        }

        // Never cache a DRM pin
        if (FormatTagFromWfx(m_vrbd.pwfxFormat) == WAVE_FORMAT_DRM)
        {
            DPF(DPFLVL_INFO, "Not caching DRM format pin");
            fCache = FALSE;
        }

        // Cache the pin
        if(SUCCEEDED(hr) && fCache && !(m_vrbd.dwFlags & dwNoCacheMask))
        {
            hr = m_pKsDevice->m_pPinCache->AddPinToCache(m_pPin);
        }

        // Free the pin
        if(SUCCEEDED(hr))
        {
            RELEASE(m_pPin);
        }

        // Remove the buffer location flags
        if(SUCCEEDED(hr))
        {
            m_vrbd.dwFlags &= ~DSBCAPS_LOCMASK;
        }

        if(SUCCEEDED(hr))
        {
            DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has freed its resources", this);
        }
    }

    if (HasAcquiredResources())
    {
        DPF(DPFLVL_ERROR, "Buffer at 0x%p failed to free pin resources", this);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Duplicate
 *
 *  Description:
 *      Duplicates the buffer.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer ** [out]: receives duplicate buffer.  Use
 *                                           Release to free this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::Duplicate"

HRESULT
CKsSecondaryRenderWaveBuffer::Duplicate
(
    CSecondaryRenderWaveBuffer **   ppBuffer
)
{
    CKsSecondaryRenderWaveBuffer *  pBuffer;
    HRESULT                         hr;

    DPF_ENTER();

    pBuffer = NEW(CKsSecondaryRenderWaveBuffer(m_pKsDevice, m_pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(NULL, this, m_pSysMemBuffer);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CommitToDevice"

HRESULT
CKsSecondaryRenderWaveBuffer::CommitToDevice
(
    DWORD                   ibCommit,
    DWORD                   cbCommit
)
{
    DPF_ENTER();

    // Kmixer uses our system memory buffer, so there's nothing to do

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::GetState"

HRESULT
CKsSecondaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();

    // Get the buffer state
    if(m_dwState & VAD_BUFFERSTATE_STARTED && !(m_dwState & VAD_BUFFERSTATE_LOOPING))
    {
        ASSERT(HasAcquiredResources());
        ASSERT(m_pCallbackEvent);

        // Are we really still playing?
        if(WAIT_OBJECT_0 == m_pCallbackEvent->Wait(0))
        {
            // No
            EventSignalCallback(m_pCallbackEvent);
        }
    }

    *pdwState = m_dwState;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetState"

HRESULT
CKsSecondaryRenderWaveBuffer::SetState(DWORD dwState)
{
    const DWORD             dwValidMask = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING;
    const BOOL              fLoop       = MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING);
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, dwValidMask));

    // Update the buffer state
    if((dwState & dwValidMask) != m_dwState)
    {
        if(dwState & VAD_BUFFERSTATE_STARTED)
        {
            // If we're LOCDEFER and need resources, get them
            if((m_vrbd.dwFlags & DSBCAPS_LOCDEFER) && !HasAcquiredResources())
                AcquireResources(m_vrbd.dwFlags & DSBCAPS_LOCMASK);
            if(SUCCEEDED(hr))
                hr = SetPlayState(fLoop);
        }
        else
        {
            hr = SetStopState(FALSE, TRUE);
            // If we're LOCDEFER and stopped, free our resources
            if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_LOCDEFER))
                FreePin(TRUE);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetPlayState
 *
 *  Description:
 *      Sets the buffer to a "play" state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to play looped.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetPlayState"

HRESULT
CKsSecondaryRenderWaveBuffer::SetPlayState
(
    BOOL                    fLoop
)
{
    HRESULT                 hr      = DS_OK;
    CEvent *                pEvent;

    DPF_ENTER();

    ASSERT(HasAcquiredResources());

    // Set up the OVERLAPPED event
    if(fLoop)
    {
        if(!m_pLoopingEvent)
        {
            m_pLoopingEvent = NEW(CEvent);
            hr = HRFROMP(m_pLoopingEvent);
        }

        if(SUCCEEDED(hr))
        {
            pEvent = m_pLoopingEvent;
        }
    }
    else
    {
        if(!m_pCallbackEvent)
        {
            hr = AllocCallbackEvent(m_pKsDevice->m_pEventPool, &m_pCallbackEvent);
        }

        if(SUCCEEDED(hr))
        {
            pEvent = m_pCallbackEvent;
        }
    }

    // Start the pin playing
    if(SUCCEEDED(hr))
    {
        hr = m_pPin->SetPlayState(m_pSysMemBuffer->GetPlayBuffer(), m_pSysMemBuffer->GetSize(), fLoop, pEvent->GetEventHandle());
    }

    // Update the buffer state flags
    if(SUCCEEDED(hr))
    {
        m_dwState = VAD_BUFFERSTATE_STARTED;

        if(fLoop)
        {
            m_dwState |= VAD_BUFFERSTATE_LOOPING;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetStopState
 *
 *  Description:
 *      Sets the buffer to a "stop" state.
 *
 *  Arguments:
 *      BOOL: TRUE if there's a pending write IRP.
 *      BOOL: whether to cache the current position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetStopState"

HRESULT
CKsSecondaryRenderWaveBuffer::SetStopState
(
    BOOL                    fNaturalStop,
    BOOL                    fCachePosition
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        ASSERT(HasAcquiredResources());

        // Stop the pin
        hr = m_pPin->SetStopState(fNaturalStop, fCachePosition);

        // Free the overlapped events
        if(SUCCEEDED(hr))
        {
            if(m_pCallbackEvent)
            {
                m_pKsDevice->m_pEventPool->FreeEvent(m_pCallbackEvent);
                m_pCallbackEvent = NULL;
            }

            RELEASE(m_pLoopingEvent);
        }

        // Signal the application's stop event
        if(SUCCEEDED(hr) && m_pStopNote)
        {
            SetEvent(m_pStopNote->hEventNotify);
        }

        // Update the buffer state flags
        if(SUCCEEDED(hr))
        {
            m_dwState = VAD_BUFFERSTATE_STOPPED;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Retrieves the current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the play position.
 *      LPDWORD [out]: receives the write position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::GetCursorPosition"

HRESULT
CKsSecondaryRenderWaveBuffer::GetCursorPosition
(
    LPDWORD                 pdwPlay,
    LPDWORD                 pdwWrite
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pPin->GetCursorPosition(pdwPlay, pdwWrite);
    }
    else
    {
        ASSERT(&m_dwPositionCache != pdwPlay);
        ASSERT(&m_dwPositionCache != pdwWrite);

        if(pdwPlay)
        {
            *pdwPlay = m_dwPositionCache;
        }

        if(pdwWrite)
        {
            *pdwWrite = m_dwPositionCache;
        }
    }

    if(SUCCEEDED(hr) && pdwWrite && (m_vrbd.dwFlags & DSBCAPS_LOCHARDWARE) && (m_dwState & VAD_BUFFERSTATE_STARTED))
    {
        *pdwWrite = PadHardwareWriteCursor(*pdwWrite, m_pSysMemBuffer->GetSize(), m_vrbd.pwfxFormat);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCursorPosition
 *
 *  Description:
 *      Sets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetCursorPosition"

HRESULT
CKsSecondaryRenderWaveBuffer::SetCursorPosition
(
    DWORD                   dwPlay
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pPin->SetCursorPosition(dwPlay);
    }
    else
    {
        m_dwPositionCache = dwPlay;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the buffer frequency.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *      BOOL [in]: whether to clamp to the driver's supported frequency
 *                 range, if the call fails on a hardware buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetFrequency"

HRESULT
CKsSecondaryRenderWaveBuffer::SetFrequency
(
    DWORD                   dwFrequency,
    BOOL                    fClamp
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if (m_vrbd.dwFlags & DSBCAPS_CTRLFX)
    {
        DPF(DPFLVL_INFO, "Called on FX buffer - ignored");
    }
    else
    {
        if (HasAcquiredResources())
        {
            hr = m_pPin->SetFrequency(dwFrequency);

            if (FAILED(hr) && (m_vrbd.dwFlags & DSBCAPS_LOCHARDWARE) && fClamp)
            {
                DWORD dwMinHwSampleRate, dwMaxHwSampleRate;
                hr = m_pKsDevice->GetFrequencyRange(&dwMinHwSampleRate, &dwMaxHwSampleRate);
                if (SUCCEEDED(hr))
                {
                    dwFrequency = BETWEEN(dwFrequency, dwMinHwSampleRate, dwMaxHwSampleRate);
                    hr = m_pPin->SetFrequency(dwFrequency);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            m_vrbd.pwfxFormat->nSamplesPerSec = dwFrequency;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Mutes or unmutes the buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to mute the buffer, FALSE to restore it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetMute"

HRESULT
CKsSecondaryRenderWaveBuffer::SetMute
(
    BOOL                    fMute
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pPin->SetMute(fMute);
    }

    if(SUCCEEDED(hr))
    {
        m_fMute = fMute;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSrcQuality
 *
 *  Description:
 *      Sets the quality of the buffer's sample rate converter.
 *
 *  Arguments:
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: new quality.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetSrcQuality"

HRESULT
CKsSecondaryRenderWaveBuffer::SetSrcQuality
(
    DIRECTSOUNDMIXER_SRCQUALITY nSrcQuality
)
{
    HRESULT                     hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pPin->SetSrcQuality(nSrcQuality);
    }

    if(SUCCEEDED(hr))
    {
        m_nSrcQuality = nSrcQuality;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Sets the attenuation for two stereo channels.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetAttenuation"

HRESULT
CKsSecondaryRenderWaveBuffer::SetAttenuation
(
    PDSVOLUMEPAN            pdsvp
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        if (!m_fMute)
            hr = m_pPin->SetVolume(pdsvp->lVolume);

        if(SUCCEEDED(hr))
            hr = m_pPin->SetPan(pdsvp->lPan);
    }

    if(SUCCEEDED(hr))
    {
        m_lVolume = pdsvp->lVolume;
        m_lPan = pdsvp->lPan;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#ifdef FUTURE_MULTIPAN_SUPPORT
/***************************************************************************
 *
 *  SetChannelAttenuations
 *
 *  Description:
 *      Sets this buffer's attenuation on the channels corresponding to
 *      the requested speaker positions.
 *
 *      We get called from CDirectSoundSecondaryBuffer's methods SetVolume()
 *      and SetChannelVolume(), since both of them modify the channel levels
 *      matrix.  This is analogous to how SetVolume() and SetPan() both end
 *      up calling SetAttenuation(), for regular CTRLPAN buffers.
 *
 *      Note: we're using the term "speaker" here for a channel's positional
 *      destination, even though our device's output channels may not feed
 *      into speakers at all. This is to avoid ambiguity with the "channels"
 *      present in our audio data stream.
 *
 *  Arguments:
 *      LONG [in]: main volume level
 *      DWORD [in]: number of speaker positions
 *      const DWORD* [in]: array of speaker position codes
 *      const LONG* [in]: array of speaker position levels
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetChannelAttenuations"

HRESULT
CKsSecondaryRenderWaveBuffer::SetChannelAttenuations
(
    LONG                    lVolume,
    DWORD                   dwSpeakerCount,
    const DWORD *           pdwSpeakers,
    const LONG *            plSpeakerVolumes
)
{
    HRESULT                 hr = DS_OK;

    DPF_ENTER();

    ASSERT(m_pPin->m_dwFlags & DSBCAPS_CTRLCHANNELVOLUME);

    if (dwSpeakerCount == 0)
    {
        // We're in a SetVolume() API call and SetChannelVolume() has not been
        // called yet; so we translate directly into a SetVolume() on our pin
        ASSERT(!pdwSpeakers && !plSpeakerVolumes);  // Sanity checking

        if (!m_fMute)
            hr = m_pPin->SetVolume(lVolume);
    }
    else  // Non-zero dwSpeakerCount:
    {
        ASSERT(pdwSpeakers && plSpeakerVolumes);

        // We set up a complete array of channel levels, then fill it in according
        // to the values passed in plSpeakerVolumes.

        LONG * plAllChannelVolumes = MEMALLOC_A(LONG, m_pKsDevice->m_ulChannelCount);
        hr = HRFROMP(plAllChannelVolumes);

        if (SUCCEEDED(hr))
            for (ULONG i=0; i < m_pKsDevice->m_ulChannelCount; ++i)
                plAllChannelVolumes[i] = DSBVOLUME_MIN;

        for (DWORD i=0; i < dwSpeakerCount && SUCCEEDED(hr); ++i)
        {
            // See if the requested speaker position is available on the device
            if (pdwSpeakers[i] & m_pKsDevice->m_lSpeakerPositions)
            {
                // If so, find out which of our output channels has that position
                // (m_pnSpeakerIndexTable maps from speaker positions to channels)
                DWORD dwSpeaker = HighestBit(pdwSpeakers[i]) - 1;
                ASSERT(dwSpeaker < m_pKsDevice->m_ulChannelCount);
                plAllChannelVolumes[m_pKsDevice->m_pnSpeakerIndexTable[dwSpeaker]] = plSpeakerVolumes[i];
            }
            else
            {
                hr = DSERR_INVALIDPARAM;
                RPF(DPFLVL_ERROR, "Channel position 0x$lx is not available", pdwSpeakers[i]);
            }
        }

        if (SUCCEEDED(hr))
            hr = SetAllChannelAttenuations(lVolume, m_pKsDevice->m_ulChannelCount, plAllChannelVolumes);

        MEMFREE(plAllChannelVolumes);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
#endif // FUTURE_MULTIPAN_SUPPORT


/***************************************************************************
 *
 *  SetAllChannelAttenuations
 *
 *  Description:
 *      Sets the attenuation on all channels of this buffer.
 *
 *  Arguments:
 *      LONG [in]:  main volume level
 *      DWORD [in]: number of channels
 *      PLONG [in]: channel attenuation levels
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetAllChannelAttenuations"

HRESULT
CKsSecondaryRenderWaveBuffer::SetAllChannelAttenuations
(
    LONG                    lVolume,
    DWORD                   dwChannelCount,
    LPLONG                  plChannelVolumes
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if (HasAcquiredResources())
    {
        if (!m_fMute)
            hr = m_pPin->SetVolume(lVolume);

        if (SUCCEEDED(hr))
            hr = m_pPin->SetChannelLevels(dwChannelCount, plChannelVolumes);
    }

    if (SUCCEEDED(hr))
        m_lVolume = lVolume;

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPCDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetNotificationPositions"

HRESULT
CKsSecondaryRenderWaveBuffer::SetNotificationPositions
(
    DWORD                   dwCount,
    LPCDSBPOSITIONNOTIFY    paNotes
)
{
    const DWORD             dwProcessId = GetCurrentProcessId();
    LPDSBPOSITIONNOTIFY     paNotesCopy = NULL;
    HRESULT                 hr          = DS_OK;
    DWORD                   i;

    DPF_ENTER();

    // Make a local copy of the notifications, converting all the
    // handles to global.
    if(paNotes)
    {
        paNotesCopy = MEMALLOC_A_COPY(DSBPOSITIONNOTIFY, dwCount, paNotes);
        hr = HRFROMP(paNotesCopy);
    }

    if(paNotesCopy)
    {
        for(i = 0; i < dwCount && SUCCEEDED(hr); i++)
        {
            paNotesCopy[i].hEventNotify = GetGlobalHandleCopy(paNotesCopy[i].hEventNotify, dwProcessId, FALSE);
            hr = HRFROMP(paNotesCopy[i].hEventNotify);
        }
    }

    // Disable any current events
    if(SUCCEEDED(hr))
    {
        hr = FreeNotificationPositions();
    }

    // Save the new events
    if(SUCCEEDED(hr))
    {
        m_paNotes = paNotesCopy;
        m_cNotes = dwCount;
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < m_cNotes; i++)
        {
            if(DSBPN_OFFSETSTOP == m_paNotes[i].dwOffset)
            {
                // We won't actually pass the stop event down to Kmixer, but
                // instead will keep our own copy of it
                m_pStopNote = &m_paNotes[i];
                break;
            }
        }
    }

    // Enable position notifications
    if(SUCCEEDED(hr) && HasAcquiredResources())
    {
        hr = m_pPin->EnableNotificationPositions(m_paNotes, m_cNotes);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeNotificationPositions
 *
 *  Description:
 *      Removes all position notifications and frees allocated resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::FreeNotificationPositions"

HRESULT
CKsSecondaryRenderWaveBuffer::FreeNotificationPositions
(
    void
)
{
    HRESULT                 hr  = DS_OK;
    UINT                    i;

    DPF_ENTER();

    // Disable all position notification events
    if(HasAcquiredResources())
    {
        hr = m_pPin->DisableNotificationPositions();
    }

    // Clean up
    if(SUCCEEDED(hr))
    {
        for(i = 0; i < m_cNotes; i++)
        {
            CLOSE_HANDLE(m_paNotes[i].hEventNotify);
        }

        MEMFREE(m_paNotes);

        m_pStopNote = NULL;
        m_cNotes = 0;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the buffer format.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: new format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetFormat"

HRESULT
CKsSecondaryRenderWaveBuffer::SetFormat
(
    LPCWAVEFORMATEX                 pwfxFormat
)
{
    const DWORD                     dwLocationFlags = (m_vrbd.dwFlags & DSBCAPS_LOCMASK);
    DWORD                           dwState;
    HRESULT                         hr;

    DPF_ENTER();

    // Fix up the buffer description
    MEMFREE(m_vrbd.pwfxFormat);

    m_vrbd.pwfxFormat = CopyWfxAlloc(pwfxFormat);
    hr = HRFROMP(m_vrbd.pwfxFormat);

    // Save the buffer state
    if(SUCCEEDED(hr))
    {
        hr = GetState(&dwState);
    }

    // We can't change the format of the pin, so we'll free and reaquire
    // resources.
    if(SUCCEEDED(hr) && HasAcquiredResources())
    {
        hr = FreePin(TRUE);

        if(SUCCEEDED(hr))
        {
            hr = AcquireResources(dwLocationFlags);
        }

        if(SUCCEEDED(hr))
        {
            hr = SetState(dwState);
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, "Buffer format set to %lu Hz, %u-bit, %s...", pwfxFormat->nSamplesPerSec, pwfxFormat->wBitsPerSample, (1 == pwfxFormat->nChannels) ? TEXT("mono") : TEXT("stereo"));
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EventSignalCallback
 *
 *  Description:
 *      Callback function called when a pin's IO completion event is
 *      signalled.  This function is called from within the callback event
 *      pool's lock, so we get thread synchronization for free.
 *
 *  Arguments:
 *      CCallbackEvent * [in]: callback event.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::EventSignalCallback"

void
CKsSecondaryRenderWaveBuffer::EventSignalCallback
(
    CCallbackEvent *        pEvent
)
{
    DPF_ENTER();

    ASSERT(HasAcquiredResources());

    // Allow the buffer to handle the stop event
    SetStopState(TRUE, FALSE);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CreatePropertySet
 *
 *  Description:
 *      Creates the property set object.
 *
 *  Arguments:
 *      CPropertySet ** [out]: receives pointer to the property set object.
 *                             The caller is responsible for freeing this
 *                             object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreatePropertySet"

HRESULT
CKsSecondaryRenderWaveBuffer::CreatePropertySet
(
    CPropertySet **         ppPropertySet
)
{
    HRESULT                 hr              = DS_OK;
    CKsPropertySet *        pPropertySet;

    DPF_ENTER();

    ASSERT(HasAcquiredResources());

    if(m_pKsDevice->m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWPROPSETS)
    {
        hr = DSERR_UNSUPPORTED;
    }

    if(SUCCEEDED(hr))
    {
        pPropertySet = NEW(CKsPropertySet(m_pPin->m_hPin, m_pvInstance, m_pKsDevice->m_paTopologies[m_pPin->m_ulPinId]));
        hr = HRFROMP(pPropertySet);
    }

    if(SUCCEEDED(hr))
    {
        *ppPropertySet = pPropertySet;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Create3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::Create3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::Create3dObject
(
    C3dListener *           p3dListener,
    C3dObject **            pp3dObject
)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    C3dObject *             p3dObject               = NULL;
    HRESULT                 hr                      = DSERR_UNSUPPORTED;

    DPF_ENTER();

    ASSERT(HasAcquiredResources());
    ASSERT(m_vrbd.dwFlags & DSBCAPS_CTRL3D);

    if(m_pPin->m_dwFlags & DSBCAPS_CTRL3D)
    {
        if(IS_HARDWARE_NODE(m_pKsDevice->m_paTopologyInformation[m_pPin->m_ulPinId].ThreedNode.CpuResources))
        {
            // The IIR 3D object supports both hardware and software pins.  We'll
            // try to create that one first.  If it fails, we'll fall back on
            // a standard hardware 3D object.
            if(DS3DALG_HRTF_FULL == m_vrbd.guid3dAlgorithm || DS3DALG_HRTF_LIGHT == m_vrbd.guid3dAlgorithm)
            {
                hr = CreateIir3dObject(p3dListener, &p3dObject);
            }

            if(FAILED(hr))
            {
                hr = CreateHw3dObject(p3dListener, &p3dObject);
            }
        }
        else if(DS3DALG_HRTF_FULL == m_vrbd.guid3dAlgorithm || DS3DALG_HRTF_LIGHT == m_vrbd.guid3dAlgorithm)
        {
            hr = CreateIir3dObject(p3dListener, &p3dObject);
        }
        else if(DS3DALG_ITD == m_vrbd.guid3dAlgorithm)
        {
            hr = CreateItd3dObject(p3dListener, &p3dObject);
        }
    }
    else if(DS3DALG_NO_VIRTUALIZATION == m_vrbd.guid3dAlgorithm)
    {
        // See if we have a multichannel speaker configuration
        BYTE bSpkConf = DSSPEAKER_CONFIG(m_pKsDevice->m_dwSpeakerConfig);

        BOOL fMultiChannel = bSpkConf == DSSPEAKER_QUAD ||
                             bSpkConf == DSSPEAKER_SURROUND ||
                             bSpkConf == DSSPEAKER_5POINT1 ||
                             bSpkConf == DSSPEAKER_7POINT1;
        if (fMultiChannel)
        {
            hr = CreateMultiPan3dObject(p3dListener, fMute3dAtMaxDistance, m_vrbd.pwfxFormat->nSamplesPerSec, &p3dObject);
            if (FAILED(hr))
            {
                DPF(DPFLVL_INFO, "Multichannel pan object creation failed with %s", HRESULTtoSTRING(hr));
            }
        }
        if (!fMultiChannel || FAILED(hr))
        {
            hr = CreatePan3dObject(p3dListener, fMute3dAtMaxDistance, m_vrbd.pwfxFormat->nSamplesPerSec, &p3dObject);
        }
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateHw3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreateHw3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::CreateHw3dObject
(
    C3dListener *           p3dListener,
    C3dObject **            pp3dObject
)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    const PKSNODE           pNode                   = &m_pKsDevice->m_paTopologyInformation[m_pPin->m_ulPinId].ThreedNode;
    CKsHw3dObject *         p3dObject;
    HRESULT                 hr;

    DPF_ENTER();

    p3dObject = NEW(CKsHw3dObject((CKs3dListener *)p3dListener, fMute3dAtMaxDistance, fDopplerEnabled, m_pvInstance, pNode->NodeId, this));
    hr = HRFROMP(p3dObject);

    if(SUCCEEDED(hr))
    {
        hr = p3dObject->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }
    else
    {
        RELEASE(p3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateIir3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreateIir3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::CreateIir3dObject
(
    C3dListener *           p3dListener,
    C3dObject **            pp3dObject
)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    const PKSNODE           pNode                   = &m_pKsDevice->m_paTopologyInformation[m_pPin->m_ulPinId].ThreedNode;
    CKsIir3dObject *        p3dObject;
    HRESULT                 hr;

    DPF_ENTER();

    p3dObject = NEW(CKsIir3dObject((CKs3dListener *)p3dListener, m_vrbd.guid3dAlgorithm, fMute3dAtMaxDistance, fDopplerEnabled, m_vrbd.pwfxFormat->nSamplesPerSec, this, m_pPin->m_hPin, pNode->NodeId, pNode->CpuResources));
    hr = HRFROMP(p3dObject);

    if(SUCCEEDED(hr))
    {
        hr = p3dObject->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }
    else
    {
        RELEASE(p3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateItd3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreateItd3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::CreateItd3dObject
(
    C3dListener *           p3dListener,
    C3dObject **            pp3dObject
)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    const PKSNODE           pNode                   = &m_pKsDevice->m_paTopologyInformation[m_pPin->m_ulPinId].ThreedNode;
    CKsItd3dObject *        p3dObject;
    HRESULT                 hr;

    DPF_ENTER();

    p3dObject = NEW(CKsItd3dObject((CKs3dListener *)p3dListener, fMute3dAtMaxDistance, fDopplerEnabled, m_vrbd.pwfxFormat->nSamplesPerSec, this, m_pPin->m_hPin, pNode->NodeId));
    hr = HRFROMP(p3dObject);

    if(SUCCEEDED(hr))
    {
        hr = p3dObject->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }
    else
    {
        RELEASE(p3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateMultiPan3dObject
 *
 *  Description:
 *      Creates a multichannel panning 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: 3D listener object.
 *      BOOL [in]:          whether to mute the sound at max distance.
 *      DWORD [in]:         buffer frequency.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreateMultiPan3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::CreateMultiPan3dObject
(
    C3dListener *           p3dListener,
    BOOL                    fMute3dAtMaxDistance,
    DWORD                   dwFrequency,
    C3dObject **            pp3dObject
)
{
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    CMultiPan3dObject *     p3dObject = NULL;
    HRESULT                 hr;

    DPF_ENTER();

    // First set up the supermix table properly for this buffer's pin;
    // if this fails, there is no need to create the CMultiPan3dObject.
    hr = m_pPin->SetSuperMix();

    if (SUCCEEDED(hr))
    {
        p3dObject = NEW(CMultiPan3dObject((CMultiPan3dListener*)p3dListener, fMute3dAtMaxDistance, fDopplerEnabled, dwFrequency, this));
        hr = HRFROMP(p3dObject);
    }

    if (SUCCEEDED(hr))
        hr = p3dObject->Initialize();

    if (SUCCEEDED(hr))
        *pp3dObject = p3dObject;
    else
        RELEASE(p3dObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  HasAcquiredResources
 *
 *  Description:
 *      Determines whether or not hardware resources have been acquired.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if resources have been acquired.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::HasAcquiredResources"

BOOL
CKsSecondaryRenderWaveBuffer::HasAcquiredResources
(
    void
)
{
    if(m_pPin)
    {
        ASSERT(LXOR(m_vrbd.dwFlags & DSBCAPS_LOCHARDWARE, m_vrbd.dwFlags & DSBCAPS_LOCSOFTWARE));
    }
    else
    {
        ASSERT(!(m_vrbd.dwFlags & DSBCAPS_LOCMASK));
    }

    return MAKEBOOL(m_pPin);
}


/***************************************************************************
 *
 *  CKsRenderPin
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKsRenderDevice * [in]: parent device.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::CKsRenderPin"

CKsRenderPin::CKsRenderPin
(
    CKsRenderDevice *       pKsDevice
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsRenderPin);

    // Initialize defaults
    m_pKsDevice = pKsDevice;
    m_ulPinId = MAX_ULONG;
    m_dwFlags = 0;
    m_pwfxFormat = NULL;
    m_guid3dAlgorithm = GUID_NULL;
    m_hPin = NULL;
    m_dwState = VAD_BUFFERSTATE_STOPPED;
    m_paEventData = NULL;
    m_cEventData = 0;
    m_dwPositionCache = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsRenderPin
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::~CKsRenderPin"

CKsRenderPin::~CKsRenderPin
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsRenderPin);

    SetStopState(FALSE, FALSE);

    DisableNotificationPositions();

    CLOSE_HANDLE(m_hPin);

    MEMFREE(m_pwfxFormat);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the render pin object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      DWORD [in]: Pin creation flags.
 *      LPCVADRBUFFERDESC [in]: buffer description.
 *      REFGUID [in]: GUID of 3D algorithm to be used, if applicable.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::Initialize"

HRESULT
CKsRenderPin::Initialize
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm
)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(dwFlags & DSBCAPS_CTRL3D)
    {
        ASSERT(DS3DALG_NO_VIRTUALIZATION != guid3dAlgorithm);
    }
    else
    {
        ASSERT(IS_NULL_GUID(&guid3dAlgorithm));
    }

    m_dwFlags = dwFlags;
    m_guid3dAlgorithm = guid3dAlgorithm;

    // For non-PCM formats we don't always require the VOLUME/PAN/FREQUENCY caps.
    // This fixes Millennium bug 139752 (cannot play AC3 format, DVD is blocked)

    WORD wFormatTag = FormatTagFromWfx(pwfxFormat);
    if (wFormatTag == WAVE_FORMAT_PCM || wFormatTag == WAVE_FORMAT_IEEE_FLOAT)
    {
        m_dwFlags |= DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY;
    }

    m_pwfxFormat = CopyWfxAlloc(pwfxFormat);
    hr = HRFROMP(m_pwfxFormat);

    // Create the pin
    if(SUCCEEDED(hr))
    {
        hr = m_pKsDevice->CreateRenderPin(-1, m_dwFlags, m_pwfxFormat, m_guid3dAlgorithm, &m_hPin, &m_ulPinId);
    }

#ifdef FUTURE_MULTIPAN_SUPPORT
    // If we're CTRLCHANNELVOLUME, set up the supermix table accordingly.
    // This is done here so we will correctly return DSERR_CONTROLUNAVAIL if a
    // driver's Supermix node doesn't support the MIX_LEVEL_TABLE properties.
    if(SUCCEEDED(hr) && (m_dwFlags & DSBCAPS_CTRLCHANNELVOLUME))
    {
        hr = SetSuperMix();
    }
#endif

    // Attach the new pin to the render device's virtual source to allow
    // wave out volume/pan changes to affect the pin.
    if(SUCCEEDED(hr))
    {
        hr = KsAttachVirtualSource(m_hPin, m_pKsDevice->m_ulVirtualSourceIndex);
    }

    // Set up the default pin properties
    if(SUCCEEDED(hr))
    {
        m_lVolume = DSBVOLUME_MAX;
        m_lPan = DSBPAN_CENTER;
        m_fMute = FALSE;
        m_nSrcQuality = DIRECTSOUNDMIXER_SRCQUALITY_PINDEFAULT;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Retrieves the pin's current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the play position.
 *      LPDWORD [out]: receives the write position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::GetCursorPosition"

HRESULT
CKsRenderPin::GetCursorPosition
(
    LPDWORD                 pdwPlay,
    LPDWORD                 pdwWrite
)
{
    HRESULT                 hr          = DS_OK;
    KSAUDIO_POSITION        Position;

    DPF_ENTER();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        hr = KsGetProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_POSITION, &Position, sizeof(Position));
    }
    else
    {
        ASSERT(&m_dwPositionCache != pdwPlay);
        ASSERT(&m_dwPositionCache != pdwWrite);

        Position.PlayOffset = m_dwPositionCache;
        Position.WriteOffset = m_dwPositionCache;
    }

    if(SUCCEEDED(hr))
    {
        if(pdwPlay)
        {
            *pdwPlay = (DWORD)Position.PlayOffset;
        }

        if(pdwWrite)
        {
            *pdwWrite = (DWORD)Position.WriteOffset;
        }
    }
    else
    {
        DPF(DPFLVL_ERROR, "Unable to get cursor position");
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCursorPosition
 *
 *  Description:
 *      Sets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetCursorPosition"

HRESULT
CKsRenderPin::SetCursorPosition
(
    DWORD                   dwPosition
)
{
    HRESULT                 hr          = DS_OK;
    KSAUDIO_POSITION        Position;

    DPF_ENTER();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        Position.PlayOffset = dwPosition;

        hr = KsSetProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_POSITION, &Position, sizeof(Position));
    }
    else
    {
        m_dwPositionCache = dwPosition;
    }

    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Unable to set cursor position");
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the pin's frequency.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetFrequency"

HRESULT
CKsRenderPin::SetFrequency
(
    DWORD                   dwFrequency
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(dwFrequency != m_pwfxFormat->nSamplesPerSec)
    {
        ASSERT(m_dwFlags & DSBCAPS_CTRLFREQUENCY);
        ASSERT(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].SrcNode.NodeId));

        hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_SAMPLING_RATE, m_pKsDevice->m_paTopologyInformation[m_ulPinId].SrcNode.NodeId, &dwFrequency, sizeof(dwFrequency));

        if(SUCCEEDED(hr))
        {
            m_pwfxFormat->nSamplesPerSec = dwFrequency;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Mutes or unmutes the pin.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to mute the buffer, FALSE to restore it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetMute"

HRESULT
CKsRenderPin::SetMute
(
    BOOL                    fMute
)
{
    HRESULT                 hr      = DS_OK;
    LONG                    lVolume;

    DPF_ENTER();

    if(fMute != m_fMute)
    {
        if(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].MuteNode.NodeId))
        {
            hr = KsSetPinMute(m_hPin, m_pKsDevice->m_paTopologyInformation[m_ulPinId].MuteNode.NodeId, fMute);
        }
        else if (m_dwFlags & DSBCAPS_CTRLVOLUME)  // Only try the below if we have a volume node; otherwise, just return OK
        {
            lVolume = m_lVolume;
            m_lVolume = ~m_lVolume;

            hr = SetVolume(fMute ? DSBVOLUME_MIN : lVolume);

            if(SUCCEEDED(hr))
            {
                m_lVolume = lVolume;
            }
        }

        if(SUCCEEDED(hr))
        {
            m_fMute = fMute;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSrcQuality
 *
 *  Description:
 *      Sets the quality of the pin's sample rate converter.
 *
 *  Arguments:
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: new quality.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetSrcQuality"

HRESULT
CKsRenderPin::SetSrcQuality
(
    DIRECTSOUNDMIXER_SRCQUALITY nSrcQuality
)
{
    ULONG                       aulKsQuality[]  = { KSAUDIO_QUALITY_WORST, KSAUDIO_QUALITY_PC, KSAUDIO_QUALITY_BASIC, KSAUDIO_QUALITY_ADVANCED };
    HRESULT                     hr              = DS_OK;

    DPF_ENTER();

    ASSERT(nSrcQuality >= 0 && nSrcQuality < NUMELMS(aulKsQuality));

    if(nSrcQuality != m_nSrcQuality)
    {
        if(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].SrcNode.NodeId))
        {
            hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_QUALITY, m_pKsDevice->m_paTopologyInformation[m_ulPinId].SrcNode.NodeId, &aulKsQuality[nSrcQuality], sizeof(aulKsQuality[nSrcQuality]));
        }
        else
        {
            hr = DSERR_UNSUPPORTED;
        }

        if(SUCCEEDED(hr))
        {
            m_nSrcQuality = nSrcQuality;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the attenuation for each channel.
 *
 *  Arguments:
 *      LONG [in]: attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetVolume"

HRESULT
CKsRenderPin::SetVolume
(
    LONG                    lVolume
)
{
    HRESULT                 hr      = DS_OK;
    LONG                    lLevel;

    DPF_ENTER();

    if(lVolume != m_lVolume)
    {
        ASSERT(m_dwFlags & DSBCAPS_CTRLVOLUME);
        ASSERT(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].VolumeNode.Node.NodeId));

        lLevel = DsAttenuationToKsVolume(lVolume, &m_pKsDevice->m_paTopologyInformation[m_ulPinId].VolumeNode.VolumeRange);

        hr = KsSetChannelProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_VOLUMELEVEL, m_pKsDevice->m_paTopologyInformation[m_ulPinId].VolumeNode.Node.NodeId, -1, &lLevel, sizeof(lLevel));

        if(SUCCEEDED(hr))
        {
            m_lVolume = lVolume;
        }
        else
        {
            DPF(DPFLVL_ERROR, "Unable to set local volume");
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPan
 *
 *  Description:
 *      Sets the attenuation for each channel.
 *
 *  Arguments:
 *      LONG [in]: attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetPan"

HRESULT
CKsRenderPin::SetPan
(
    LONG                    lPan
)
{
    HRESULT                 hr              = DS_OK;
    ULONG                   ulChannel;
    LONG                    lLevel;
    LONG                    lPanValue[2];

    DPF_ENTER();

    if(lPan != m_lPan)
    {
        ASSERT(m_dwFlags & DSBCAPS_CTRLPAN);
        ASSERT(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.Node.NodeId));

        VolumePanToAttenuation(DSBVOLUME_MAX, lPan, &lPanValue[0], &lPanValue[1]);

        for(ulChannel = 0; ulChannel < 2; ulChannel++)
        {
            lLevel = DsAttenuationToKsVolume(lPanValue[ulChannel], &m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.VolumeRange);

            hr = KsSetChannelProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_VOLUMELEVEL, m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.Node.NodeId, ulChannel, &lLevel, sizeof(lLevel));

            if(FAILED(hr))
            {
                DPF(DPFLVL_ERROR, "Unable to set local pan on channel %lu", ulChannel);
                break;
            }
        }

        if(SUCCEEDED(hr))
        {
            m_lPan = lPan;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSuperMix
 *
 *  Description:
 *      Sets up this pin's supermix node for multichannel pan control.
 *      (By making every input channel present on all output channels.)
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetSuperMix"

HRESULT
CKsRenderPin::SetSuperMix(void)
{
    PKSAUDIO_MIXCAP_TABLE   pMixcapTable     = NULL;
    PKSAUDIO_MIXLEVEL       pMixLevels       = NULL;
    ULONG                   ulSuperMixNodeId = m_pKsDevice->m_paTopologyInformation[m_ulPinId].SuperMixNode.NodeId;
    HRESULT                 hr = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_NODE(ulSuperMixNodeId));

    // If this is a common-or-garden 2-channel pin, it already has the supermix
    // table set up correctly for CTRLCHANNELVOLUME, so we just return success.

    if (m_pKsDevice->m_ulChannelCount != 2)
    {
        // In the interest of speed, rather than make two system calls we
        // assume that there are at most 2 inputs and 32 outputs, so that
        // the most MixCaps structures we can ever get back are 64:
        size_t nMixcapTableSize = sizeof(KSAUDIO_MIXCAP_TABLE) + 64 * sizeof(KSAUDIO_MIX_CAPS);

        pMixcapTable = (PKSAUDIO_MIXCAP_TABLE) MEMALLOC_A(CHAR, nMixcapTableSize);
        hr = HRFROMP(pMixcapTable);

        if (SUCCEEDED(hr))
        {
            DPF(DPFLVL_MOREINFO, "Reading supermix table on node id %d", ulSuperMixNodeId);
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
                                   ulSuperMixNodeId, pMixcapTable, nMixcapTableSize);
        }

        if (SUCCEEDED(hr))
        {
            DPF(DPFLVL_MOREINFO, "Supermix table has %d inputs and %d outputs", pMixcapTable->InputChannels, pMixcapTable->OutputChannels);
            ASSERT(pMixcapTable->InputChannels <= 2);
            ASSERT(pMixcapTable->OutputChannels <= 32);

            if (pMixcapTable->OutputChannels != m_pKsDevice->m_ulChannelCount)
                DPF(DPFLVL_WARNING, "Supermix node has %d outputs, but there are %d bits set in the pan node's CHANNEL_CONFIG", pMixcapTable->OutputChannels, m_pKsDevice->m_ulChannelCount);

            pMixLevels = MEMALLOC_A(KSAUDIO_MIXLEVEL, pMixcapTable->InputChannels * pMixcapTable->OutputChannels);
            hr = HRFROMP(pMixLevels);
        }

        if (SUCCEEDED(hr))
        {
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, ulSuperMixNodeId, pMixLevels,
                                   sizeof(KSAUDIO_MIXLEVEL) * pMixcapTable->InputChannels * pMixcapTable->OutputChannels);
        }

        if (SUCCEEDED(hr))
        {
            // Set up the supermix table so that every input is present on all outputs.
            for (ULONG m=0; m<pMixcapTable->InputChannels; ++m)
            {
                for (ULONG n=0; n<pMixcapTable->OutputChannels; ++n)
                {
                    PKSAUDIO_MIXLEVEL pMixLevel = pMixLevels + m*pMixcapTable->OutputChannels + n;
                    pMixLevel->Mute = FALSE;
                    pMixLevel->Level = 0;   // Means "no attenuation" - full signal.
                }
            }

            hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, ulSuperMixNodeId, pMixLevels,
                                   sizeof(KSAUDIO_MIXLEVEL) * pMixcapTable->InputChannels * pMixcapTable->OutputChannels);
        }

        if (pMixLevels)
            MEMFREE(pMixLevels);

        if (pMixcapTable)
            MEMFREE(pMixcapTable);

        // If the property set calls failed, return DSERR_CONTROLUNAVAIL
        if (FAILED(hr) && hr != DSERR_OUTOFMEMORY)
            hr = DSERR_CONTROLUNAVAIL;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetChannelLevels
 *
 *  Description:
 *      Sets the attenuation for each channel.
 *
 *  Arguments:
 *      DWORD [in]: number of channels
 *      const LONG * [in]: channel attenuation levels
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetChannelLevels"

HRESULT
CKsRenderPin::SetChannelLevels
(
    DWORD                   dwChannelCount,
    const LONG *            plChannelVolumes
)
{
    ULONG                   ulPanNodeId     = m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.Node.NodeId;
    HRESULT                 hr              = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_NODE(ulPanNodeId));

    if (dwChannelCount != m_pKsDevice->m_ulChannelCount)
        DPF(DPFLVL_WARNING, "Called with dwChannelCount = %d, but no. of bits set in pan node's CHANNEL_CONFIG = %d", dwChannelCount, m_pKsDevice->m_ulChannelCount);

    for (DWORD dwChan=0; dwChan<dwChannelCount && SUCCEEDED(hr); ++dwChan)
    {
        LONG lLevel = DsAttenuationToKsVolume(plChannelVolumes[dwChan], &m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.VolumeRange);
        hr = KsSetChannelProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_VOLUMELEVEL, ulPanNodeId, dwChan, &lLevel, sizeof lLevel);
        if (FAILED(hr))
            DPF(DPFLVL_WARNING, "Failed to set level %ld on channel %d", lLevel, dwChan);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetPlayState
 *
 *  Description:
 *      Sets the buffer to a "play" state.
 *
 *  Arguments:
 *      LPCVOID [in]: data buffer pointer.
 *      DWORD [in]: size of data bufer.
 *      BOOL [in]: TRUE to play looped.
 *      HANDLE [in]: overlapped event handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetPlayState"

HRESULT
CKsRenderPin::SetPlayState
(
    LPCVOID                 pvBuffer,
    DWORD                   cbBuffer,
    BOOL                    fLoop,
    HANDLE                  hEvent
)
{
    HRESULT                 hr;
    BOOL                    fStreamStarted = FALSE;

    DPF_ENTER();

    // If we're already playing, stop the buffer before contining
    hr = SetStopState(FALSE, TRUE);

    // Update the buffer state flags
    if(SUCCEEDED(hr))
    {
        m_dwState = VAD_BUFFERSTATE_STARTED;

        if(fLoop)
        {
            m_dwState |= VAD_BUFFERSTATE_LOOPING;
        }
    }

    // Set up the OVERLAPPED data
    if(SUCCEEDED(hr))
    {
        m_kssio.Overlapped.hEvent = hEvent;
    }

    // Feed the stream
    if(SUCCEEDED(hr))
    {
        hr = KsWriteStream(m_hPin, pvBuffer, cbBuffer, fLoop ? KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA : 0, &m_kssio);
    }

    // Set the play cursor position
    if(SUCCEEDED(hr))
    {
        fStreamStarted = TRUE;
        hr = SetCursorPosition(m_dwPositionCache);
    }

    // Start making noise
    if(SUCCEEDED(hr))
    {
        hr = KsSetState(m_hPin, KSSTATE_RUN);
    }

    // Clean up
    if(FAILED(hr))
    {
        if (fStreamStarted)
        {
            // Stream was started, but we're going back to the stop state.
            // Make sure we don't leave stream I/O hanging around.
            KsCancelPendingIrps(m_hPin, &m_kssio, TRUE);
        }
        m_dwState = VAD_BUFFERSTATE_STOPPED;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetStopState
 *
 *  Description:
 *      Sets the buffer to a "stop" state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE if pin played to completion and is being notified
 *                 of the event.
 *      BOOL [in]: TRUE to cache the pin position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetStopState"

HRESULT
CKsRenderPin::SetStopState
(
    BOOL                    fNaturalStop,
    BOOL                    fCachePosition
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        if(fNaturalStop)
        {
            ASSERT(m_kssio.fPendingIrp);
            m_kssio.fPendingIrp = FALSE;
            fCachePosition = FALSE;
        }

        // Pause the pin
        hr = KsSetState(m_hPin, KSSTATE_PAUSE);

        // Cache the play cursor position
        if(SUCCEEDED(hr))
        {
            if(fCachePosition)
            {
                hr = GetCursorPosition(&m_dwPositionCache, NULL);
            }
            else
            {
                m_dwPositionCache = 0;
            }
        }

        // Cancel the pending write IRP
        if(SUCCEEDED(hr) && m_kssio.fPendingIrp)
        {
            hr = KsCancelPendingIrps(m_hPin, &m_kssio, TRUE);
        }

        // Update the buffer state flags
        if(SUCCEEDED(hr))
        {
            m_dwState = VAD_BUFFERSTATE_STOPPED;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EnableNotificationPositions
 *
 *  Description:
 *      Enables set position notifications.
 *
 *  Arguments:
 *      LPCDSBPOSITIONNOTIFY [in]: notification positions.
 *      DWORD [in]: count of notification positions.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::EnableNotificationPositions"

HRESULT
CKsRenderPin::EnableNotificationPositions
(
    LPCDSBPOSITIONNOTIFY                    paNotes,
    DWORD                                   cNotes
)
{
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pEventData;
    HRESULT                                 hr;
    DPF_ENTER();

    // Disable any current notifications
    hr = DisableNotificationPositions();

    // Count the number of notifications
    for(DWORD i=0; i<cNotes && SUCCEEDED(hr); i++)
    {
        if(DSBPN_OFFSETSTOP != paNotes[i].dwOffset)
        {
            m_cEventData++;
        }
    }

    // Allocate event data
    if(SUCCEEDED(hr))
    {
        m_paEventData = MEMALLOC_A(LOOPEDSTREAMING_POSITION_EVENT_DATA, m_cEventData);
        hr = HRFROMP(m_paEventData);
    }

    // Enable notifications
    for(pEventData = m_paEventData, i = 0; i < cNotes && SUCCEEDED(hr); i++)
    {
        if(DSBPN_OFFSETSTOP == paNotes[i].dwOffset)
        {
            continue;
        }

        hr = KsEnablePositionEvent(m_hPin, paNotes[i].dwOffset, paNotes[i].hEventNotify, pEventData++);

        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Unable to set notify number %lu", i);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DisableNotificationPositions
 *
 *  Description:
 *      Removes position notifications and frees allocated resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::DisableNotificationPositions"

HRESULT
CKsRenderPin::DisableNotificationPositions
(
    void
)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Disable all position notification events
    for(DWORD i=0; i<m_cEventData && SUCCEEDED(hr); i++)
    {
        hr = KsDisablePositionEvent(m_hPin, &m_paEventData[i]);
        if(FAILED(hr))
            DPF(DPFLVL_ERROR, "Unable to disable notify number %lu", i);
    }

    MEMFREE(m_paEventData);
    m_cEventData = 0;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CKsRenderPinCache
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::CKsRenderPinCache"

const DWORD CKsRenderPinCache::m_dwTimeout = 5000;   // 5 seconds

CKsRenderPinCache::CKsRenderPinCache
(
    void
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsRenderPinCache);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsRenderPinCache
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::~CKsRenderPinCache"

CKsRenderPinCache::~CKsRenderPinCache
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsRenderPinCache);

    // Flush any remaining pins from the cache
    FlushCache();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  AddPinToCache
 *
 *  Description:
 *      Adds a pin to the cache.
 *
 *  Arguments:
 *      CKsRenderPin * [in]: pin cache data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::AddPinToCache"

HRESULT
CKsRenderPinCache::AddPinToCache
(
    CKsRenderPin *          pPin
)
{
    CNode<KSPINCACHE> *     pNode;
    KSPINCACHE              kspc;
    HRESULT                 hr;

    DPF_ENTER();

    // Remove any expired pins from the cache
    FlushExpiredPins();

    // Add the pin to the cache list
    kspc.Pin = ADDREF(pPin);
    kspc.CacheTime = GetTickCount();

    pNode = m_lstPinCache.AddNodeToList(kspc);
    hr = HRFROMP(pNode);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPinFromCache
 *
 *  Description:
 *      Gets a pin from the cache.
 *
 *  Arguments:
 *      DWORD [in]: dsound buffer flags.
 *      LPCWAVEFORMATEX:
 *      REFGUID:
 *      CKsRenderPin ** [out]: receives pin data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::GetPinFromCache"

HRESULT
CKsRenderPinCache::GetPinFromCache
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    CKsRenderPin **         ppPin
)
{
    HRESULT                 hr      = DS_OK;
    COMPAREBUFFER           cmp[2];
    CNode<KSPINCACHE> *     pNode;

    DPF_ENTER();

    cmp[0].dwFlags = dwFlags;
    cmp[0].pwfxFormat = pwfxFormat;
    cmp[0].guid3dAlgorithm = guid3dAlgorithm;

    for(pNode = m_lstPinCache.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        cmp[1].dwFlags = pNode->m_data.Pin->m_dwFlags;
        cmp[1].pwfxFormat = pNode->m_data.Pin->m_pwfxFormat;
        cmp[1].guid3dAlgorithm = pNode->m_data.Pin->m_guid3dAlgorithm;

        if(CompareBufferProperties(&cmp[0], &cmp[1]))
        {
            break;
        }
    }

    if(!pNode)
    {
        hr = DSERR_BADFORMAT;
    }

    if(SUCCEEDED(hr))
    {
        *ppPin = ADDREF(pNode->m_data.Pin);
        RemovePinFromCache(pNode);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RemovePinFromCache
 *
 *  Description:
 *      Removes a pin from the cache.
 *
 *  Arguments:
 *      CNode<KSPINCACHE> * [in]: pin node.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::RemovePinFromCache"

void CKsRenderPinCache::RemovePinFromCache
(
    CNode<KSPINCACHE> *     pNode
)
{
    DPF_ENTER();

    // Free the pin
    RELEASE(pNode->m_data.Pin);

    // Remove the pin from the list
    m_lstPinCache.RemoveNodeFromList(pNode);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  FlushExpiredPins
 *
 *  Description:
 *      Removes expired pins from the cache.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::FlushExpiredPins"

void CKsRenderPinCache::FlushExpiredPins
(
    void
)
{
    const DWORD             dwTime  = GetTickCount();
    CNode<KSPINCACHE> *     pNode;
    CNode<KSPINCACHE> *     pNext;

    DPF_ENTER();

    // Remove all pins whose timeouts have elapsed
    pNode = m_lstPinCache.GetListHead();

    while(pNode)
    {
        pNext = pNode->m_pNext;

        if(pNode->m_data.CacheTime + m_dwTimeout <= dwTime)
        {
            RemovePinFromCache(pNode);
        }

        pNode = pNext;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  FlushCache
 *
 *  Description:
 *      Removes all pins from the cache.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::FlushCache"

void CKsRenderPinCache::FlushCache
(
    void
)
{
    CNode<KSPINCACHE> *     pNode;

    DPF_ENTER();

    // Remove all pins from the cache
    while(pNode = m_lstPinCache.GetListHead())
    {
        RemovePinFromCache(pNode);
    }

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\makefile.inc ===
#############################################################################
#
#       Copyright (C) Microsoft Corporation 1997-1998
#       All Rights Reserved.
#
#############################################################################

misc: ..\dsdriver.h ..\dsdrvi.h ..\modeflag.h ..\modeflag.inc ..\mix.cpp \
      ..\dpf.c ..\w95help.c

..\dsdriver.h: ..\dsdriver.x
        hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ $?

..\dpf.c: $(DXROOT)\misc\dpf.c
        copy $? $@

..\dsdrvi.h: ..\dsdriver.x
        copy $? $@

..\mix.cpp: ..\mix.m4
        m4 ..\mix.m4 > ..\mix.cpp

..\modeflag.h: ..\modeflag.m4
        m4 -Dmodeflag_h ..\modeflag.m4 > ..\modeflag.h

..\modeflag.inc: ..\modeflag.m4
        m4 -Dmodeflag_inc ..\modeflag.m4 > ..\modeflag.inc

..\w95help.c: $(DXROOT)\misc\w95help.c
        copy $? $@

placeVxD:
        binplace ..\..\dsvxd\dsound.vxd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge101.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge101 */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE101ASM
BOOL Merge101Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

#if 1
	if (1 || !pMixSource->m_fUse_MMX)	//Non-MMX is faster.
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	movsx	ecx, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	edi, 8			// plBuild += 2
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi-8]
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ebx, ecx
	add	eax, ebp		// dwFraction += dwStep
	mov	DWORD PTR [edi-8], ebx	// *plBuild += x

	mov	ebx, DWORD PTR [edi-4]
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movsx	ecx, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	edi, 8			// plBuild += 2
	add	ecx, ebx		// NewSample += x

	movd		mm1, ecx
	punpckldq	mm1, mm1
	paddd		mm1, QWORD PTR [edi-8]
	movq		QWORD PTR [edi-8], mm1

//	mov	ebx, DWORD PTR [edi-8]
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ebx, ecx
	add	eax, ebp		// dwFraction += dwStep
//	mov	DWORD PTR [edi-8], ebx	// *plBuild += x

//	mov	ebx, DWORD PTR [edi-4]
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleNext, SampleSave;
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG Sample;
      Sample = ((LONG)*((SHORT*)(XpSource)));
      SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
      LONG dwFrac = dwFraction & FRACT_MASK;
      SampleSave = Sample;
      Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      *XplBuild += Sample;
      *(XplBuild + 1) += Sample;
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge162.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge162 */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE162ASM
BOOL Merge162Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define USE_ITERS		// Keep separate from RESAMPLE to ease removal.
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;

    ASSERT((pMixSource->m_dwLVolume & 0xffff0000) == 0);
    ASSERT((pMixSource->m_dwRVolume & 0xffff0000) == 0);

#if 0 // {
#ifdef Not_VxD
    DPF(0, "Merge162: LVolume 0x%08lx RVolume 0x%08lx", pMixSource->m_dwLVolume, pMixSource->m_dwRVolume);
#else
    DPF(("Merge162: LVolume 0x%08lx RVolume 0x%08lx", pMixSource->m_dwLVolume, pMixSource->m_dwRVolume));
#endif
#endif // }

#if 1
    if (iters) {
      _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*2-2]
	push	ebp
	cmp	ebx, 14
        mov	edi, plBuild
	mov	ebp, pMixSource
	jl	LastSamples

	mov	eax, [ebp]pMixSource.m_fUse_MMX
	test	eax, eax
	je	LastSamples

	sub	ebx, 6
	pxor	mm0, mm0
	mov	eax, 128
	movd		mm5, eax	// 0, 0, 0, 128
	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128


	mov	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [ebp]pMixSource.m_dwLVolume
	shr	eax, 1
	shr	ecx, 1
	shl	ecx, 16
	and	eax, 0xffff
	or	ecx, eax
	movd		mm6, ecx
	punpckldq	mm6, mm6

	lea	ecx, [esi+ebx]
	test	ecx, 6
	je	DoMMX

	add	ebx, 6

FirstSamples:	
	xor	edx, edx
	xor	ecx, ecx

	mov	dl, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	sub	edx, 128
	sub	ecx, 128

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*4]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], edx
	add	eax, ecx

	sub	ebx, 2

	mov	DWORD PTR [edi+ebx*4+12], eax
	lea	ecx, [esi+ebx]

	and	ecx, 7
	cmp	ecx, 6

	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load 4 samples.
	movq		mm3, mm1
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	punpckhbw	mm3, mm0
	psubw		mm1, mm5
	psubw		mm3, mm5
	psllw		mm1, 8				// * 256
	psllw		mm3, 8
	pmulhw		mm1, mm6			// Only need high parts.

	jmp	DoMMX100

DoMMX10:
	movq		mm1, QWORD PTR [esi+ebx]	// Load 4 samples.

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	movq		mm3, mm1

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	punpckhbw	mm3, mm0

	psubw		mm1, mm5
	psubw		mm3, mm5

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	psllw		mm1, 8				// * 256

	psllw		mm3, 8
	pmulhw		mm1, mm6			// Only need high parts.

DoMMX100:
	punpckhwd	mm2, mm1			// 32 bit stereo...

	pmulhw		mm3, mm6

	punpcklwd	mm1, mm1
	sub		ebx, 8

	psrad		mm1, 15

	punpckhwd	mm4, mm3

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpcklwd	mm3, mm3

	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	psrad		mm2, 15

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	jge		DoMMX10

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load 4 samples.
	movq		mm3, mm1
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	punpckhbw	mm3, mm0
	psubw		mm1, mm5
	psubw		mm3, mm5
	psllw		mm1, 8				// * 256
	psllw		mm3, 8
	
	pmulhw		mm1, mm6			// Only need high parts.
	pmulhw		mm3, mm6

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1
	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 15
	psrad		mm2, 15
	psrad		mm3, 15
	psrad		mm4, 15
	
	paddd		mm1, QWORD PTR [edi+ebx*4]
	paddd		mm2, QWORD PTR [edi+ebx*4+8]
	paddd		mm3, QWORD PTR [edi+ebx*4+16]
	paddd		mm4, QWORD PTR [edi+ebx*4+24]
	movq		QWORD PTR [edi+ebx*4],    mm1
	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
	mov	eax, [ebp]pMixSource.m_MapTable
	test	eax, eax
	je	NoMapTable
	
	mov	ebp, eax

UseMapTable:
	xor	edx, edx
	xor	ecx, ecx

	mov	dl, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	mov	ecx, DWORD PTR [ebp+ecx*4+1024]
	mov	edx, DWORD PTR [ebp+edx*4+0]

//	sub	edx, 128
//	sub	ecx, 128

//	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
//	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

//	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*4]

//	sar	edx, 16

//	shl	ecx, 8
	add	edx, eax

//	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], edx
	add	eax, ecx

	sub	ebx, 2

	mov	DWORD PTR [edi+ebx*4+12], eax
	jge	UseMapTable

	jmp	Done

NoMapTable:
	xor	edx, edx
	xor	ecx, ecx

	mov	dl, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	sub	edx, 128
	sub	ecx, 128

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*4]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], edx
	add	eax, ecx

	sub	ebx, 2

	mov	DWORD PTR [edi+ebx*4+12], eax
	jge	NoMapTable
Done:
	pop	ebp
        }
       }
#elif 0
	if (iters)
	_asm {
	mov	esi, pSource
	mov	edi, plBuild
	mov	ebx, iters
	push	ebp
	mov	ebp, pMixSource

	lea	ebx, [ebx*2-2]
Lab:
	xor	edx, edx
	xor	ecx, ecx

	mov	dl, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	sub	edx, 128
	sub	ecx, 128

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*4]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], edx
	add	eax, ecx

	sub	ebx, 2
	mov	DWORD PTR [edi+ebx*4+12], eax

	jge	Lab

	pop	ebp
	}
#else
    while(--iters >= 0)
    {
      LONG SampleL;
      LONG SampleR;
      SampleL = ((LONG)(*((BYTE*)(XpSource))))     * 256 - 32768L;
      SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
      *XplBuild += SampleL;
      *(XplBuild + 1) += SampleR;
    }
#endif
    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
  pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge160.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge160 */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE160ASM
BOOL Merge160Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;

    ASSERT((pMixSource->m_dwLVolume & 0xffff0000) == 0);
    ASSERT((pMixSource->m_dwRVolume & 0xffff0000) == 0);

#if 0 // {
#ifdef Not_VxD
    DPF(0, "Merge160: LVolume 0x%08lx RVolume 0x%08lx", pMixSource->m_dwLVolume, pMixSource->m_dwRVolume);
#else
    DPF(("Merge160: LVolume 0x%08lx RVolume 0x%08lx", pMixSource->m_dwLVolume, pMixSource->m_dwRVolume));
#endif
#endif // }

#if 1
    if (iters) {
      _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*1-1]
	xor	edx, edx
	push	ebp
	cmp	ebx, 7
        mov	edi, plBuild
	mov	ebp, pMixSource
	jl	LastSamples

	mov	eax, [ebp]pMixSource.m_fUse_MMX
	test	eax, eax
	je	LastSamples

	sub	ebx, 3

	pxor		mm0, mm0
	mov		eax, 128
	movd		mm5, eax	// 0, 0, 0, 128
	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128

	mov	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [ebp]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	lea	ecx, [esi+ebx]
	test	ecx, 3
	je	DoMMX

	add	ebx, 3

FirstSamples:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	lea	ecx, [esi+ebx]

	and	ecx, 3
	cmp	ecx, 3

	jne	FirstSamples

	sub	ebx, 3

DoMMX:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	jmp	DoMMX100

DoMMX10:
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+8 +32],  mm2
	psubw		mm1, mm5

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	psllw		mm1, 8				// * 256

	movq		mm3, mm1			// Mono samples
	punpcklwd	mm1, mm1			// Make stereo

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	punpckhwd	mm3, mm3

DoMMX100:
	pmulhw		mm1, mm6			// Only need high parts.

	punpckhwd	mm2, mm1			// 32 bit stereo...

	pmulhw		mm3, mm6
	punpcklwd	mm1, mm1

	psrad		mm1, 15				// Approx. shr16, shl 1.

	paddd		mm1, QWORD PTR [edi+ebx*8]
	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*8],    mm1
	psrad		mm2, 15

	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	psrad		mm4, 15
	
	sub		ebx, 4
	jge		DoMMX10

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6			// Only need high parts.
	pmulhw		mm3, mm6

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1
	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 15				// Approx. shr16, shl 1.
	psrad		mm2, 15
	psrad		mm3, 15
	psrad		mm4, 15
	
	paddd		mm1, QWORD PTR [edi+ebx*8]
	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	paddd		mm4, QWORD PTR [edi+ebx*8+24]
	movq		QWORD PTR [edi+ebx*8],    mm1
	movq		QWORD PTR [edi+ebx*8+8],  mm2
	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX
#endif

	emms
	add	ebx, 4
	je	Done

	dec	ebx
	xor	edx, edx
	
LastSamples:	
	mov	eax, [ebp]pMixSource.m_MapTable
	test	eax, eax
	je	NoMapTable
	
	mov	ebp, eax

UseMapTable:
	mov	dl, BYTE PTR [esi+ebx]

//	sub	edx, 128
//	mov	ecx, edx

	
	mov	ecx, DWORD PTR [ebp+edx*4+1024]
	mov	edx, DWORD PTR [ebp+edx*4+0]

//	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
//	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

//	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

//	sar	edx, 16

//	shl	ecx, 8
	add	edx, eax

//	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	jge	UseMapTable

	jmp	Done

NoMapTable:
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	jge	NoMapTable
Done:
	pop	ebp
        }
       }
#elif 0
	if (iters)
	_asm {
	mov	esi, pSource
	mov	edi, plBuild
	mov	ebx, iters
	push	ebp
	mov	ebp, pMixSource

	dec	ebx
	xor	edx, edx
Lab:
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	jge	Lab

	pop	ebp
	}
#else
    while(--iters >= 0)
    {
      LONG Sample;
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
      *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
      *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    }
#endif

    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\ksvad.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ksvad.h
 *  Content:    WDM/CSA Virtual Audio Device class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/25/97     dereks  Created.
 *
 ***************************************************************************/

#ifdef NOKS
#error ksvad.h included with NOKS defined
#endif

#ifndef __KSVAD_H__
#define __KSVAD_H__

#include "dsoundi.h"
#include "kshlp.h"
#include "ks3d.h"

#define DIRECTSOUNDMIXER_SRCQUALITY_PINDEFAULT  ((DIRECTSOUNDMIXER_SRCQUALITY)-1)

// Highest possible number of SPEAKER_FRONT_LEFT-style position codes,
// given that they are DWORDs and 2^31 is already taken by SPEAKER_ALL

#define MAX_SPEAKER_POSITIONS (8 * sizeof(DWORD) - 1)  // I.e. 31

// Render device topology info
typedef struct tagKSRDTOPOLOGY
{
    KSNODE          SummingNode;
    KSNODE          SuperMixNode;
    KSNODE          SrcNode;
    KSVOLUMENODE    VolumeNode;
    KSVOLUMENODE    PanNode;
    KSNODE          ThreedNode;
    KSNODE          MuteNode;
    KSNODE          SurroundNode;
    KSNODE          DacNode;
    KSNODE          AecNode;
} KSRDTOPOLOGY, *PKSRDTOPOLOGY;


#ifdef __cplusplus

// FormatTagFromWfx(): Extracts the format tag from any kind of wave format
// structure, including WAVEFORMATEXTENSIBLE.  This function should migrate
// to misc.cpp/h if it becomes useful elsewhere in the code.

__inline WORD FormatTagFromWfx(LPCWAVEFORMATEX pwfx)
{
    if (pwfx->wFormatTag != WAVE_FORMAT_EXTENSIBLE)
        return pwfx->wFormatTag;
    else if (CompareMemoryOffset(&PWAVEFORMATEXTENSIBLE(pwfx)->SubFormat, &KSDATAFORMAT_SUBTYPE_WAVEFORMATEX, sizeof(GUID), sizeof(WORD)))
        return WORD(PWAVEFORMATEXTENSIBLE(pwfx)->SubFormat.Data1);
    else
        return WAVE_FORMAT_UNKNOWN;
}

// Fwd decl
class CKsRenderDevice;
class CKsPrimaryRenderWaveBuffer;
class CKsSecondaryRenderWaveBuffer;
class CKsPropertySet;
class CKsRenderPin;
class CKsRenderPinCache;

// Pin reuse data
typedef struct tagKSPINCACHE
{
    CKsRenderPin *  Pin;
    DWORD           CacheTime;
} KSPINCACHE, *PKSPINCACHE;


// The KS Render Audio Device class
class CKsRenderDevice : public CRenderDevice, public CKsDevice
{
    friend class CKsPrimaryRenderWaveBuffer;
    friend class CKsSecondaryRenderWaveBuffer;
    friend class CKsRenderPin;

private:
    CKsRenderPinCache *         m_pPinCache;                        // Pin cache
    PKSRDTOPOLOGY               m_paTopologyInformation;            // Topology information
    LPWAVEFORMATEX              m_pwfxFormat;                       // Device format
    DIRECTSOUNDMIXER_SRCQUALITY m_nSrcQuality;                      // Current mixer SRC quality
    DWORD                       m_dwSpeakerConfig;                  // Speaker configuration
    ULONG                       m_ulVirtualSourceIndex;             // Virtual source index for global volume
    HANDLE                      m_hPin;                             // Kmixer preload pin handle
    LARGE_INTEGER               m_liDriverVersion;                  // Driver version

    // To support SetChannelVolume() and multichannel 3D panning:
    LONG                        m_lSpeakerPositions;                // As obtained by KSPROPERTY_AUDIO_CHANNEL_CONFIG
    ULONG                       m_ulChannelCount;                   // No. of bits set in m_lSpeakerPositions
    LPINT                       m_pnSpeakerIndexTable;              // Maps speaker positions to output channels
    static INT                  m_anDefaultSpeakerIndexTable[];     // Default value for m_pnSpeakerIndexTable

    // Used to cache the driver's supported frequency range
    DWORD                       m_dwMinHwSampleRate;
    DWORD                       m_dwMaxHwSampleRate;

    // For AEC control
    BOOL                        m_fIncludeAec;
    GUID                        m_guidAecInstance;
    DWORD                       m_dwAecFlags;

public:
    CKsRenderDevice(void);
    virtual ~CKsRenderDevice(void);

    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCaps(LPDSCAPS);
    virtual HRESULT GetCertification(LPDWORD, BOOL);
    HRESULT GetFrequencyRange(LPDWORD, LPDWORD);

    // Device properties
    virtual HRESULT GetGlobalFormat(LPWAVEFORMATEX, LPDWORD);
    virtual HRESULT SetGlobalFormat(LPCWAVEFORMATEX);
    virtual HRESULT SetSrcQuality(DIRECTSOUNDMIXER_SRCQUALITY);
    virtual HRESULT SetSpeakerConfig(DWORD);

    // Buffer creation
    virtual HRESULT CreatePrimaryBuffer(DWORD, LPVOID, CPrimaryRenderWaveBuffer **);
    virtual HRESULT CreateSecondaryBuffer(LPCVADRBUFFERDESC, LPVOID, CSecondaryRenderWaveBuffer **);
    virtual HRESULT CreateKsSecondaryBuffer(LPCVADRBUFFERDESC, LPVOID, CSecondaryRenderWaveBuffer **, CSysMemBuffer *);

    // Pin helpers
    virtual HRESULT CreateRenderPin(ULONG, DWORD, LPCWAVEFORMATEX, REFGUID, LPHANDLE, PULONG);

    // AEC
    virtual HRESULT IncludeAEC(BOOL, REFGUID, DWORD);

private:
    // Pin/topology helpers
    virtual HRESULT ValidatePinCaps(ULONG, DWORD, REFGUID);

    // Misc
    virtual HRESULT PreloadSoftwareGraph(void);

private:
    // Topology helpers
    virtual HRESULT GetTopologyInformation(CKsTopology *, PKSRDTOPOLOGY);

    // Device capabilities
    virtual HRESULT GetKsDeviceCaps(DWORD, REFGUID, PKSDATARANGE_AUDIO, PKSPIN_CINSTANCES, PKSPIN_CINSTANCES);

    // IDs of the nodes we need to be able to manipulate in CKsRenderDevice
    // (horribly hacky - see the comment in ksvad.cpp)
    ULONG m_ulPanNodeId;
    ULONG m_ulSurroundNodeId;
    ULONG m_ulDacNodeId;
};

inline HRESULT CKsRenderDevice::EnumDrivers(CObjectList<CDeviceDescription> *plst)
{
    return CKsDevice::EnumDrivers(plst);
}

inline HRESULT CKsRenderDevice::GetCertification(LPDWORD pdwCertification, BOOL fGetCaps)
{
    return CKsDevice::GetCertification(pdwCertification, fGetCaps);
}

inline HRESULT CKsRenderDevice::IncludeAEC(BOOL fEnable, REFGUID guidInstance, DWORD dwFlags)
{
    m_fIncludeAec = fEnable;
    m_guidAecInstance = guidInstance;
    m_dwAecFlags = dwFlags;
    return DS_OK;
}
 

// The KS primary wave buffer
class CKsPrimaryRenderWaveBuffer : public CPrimaryRenderWaveBuffer
{
    friend class CKsRenderDevice;

private:
    CKsRenderDevice *               m_pKsDevice;        // KS audio device
    CKs3dListener *                 m_p3dListener;      // 3D listener
    CKsSecondaryRenderWaveBuffer *  m_pSecondaryBuffer; // The secondary buffer
    DWORD                           m_dwState;          // Current buffer state

public:
    CKsPrimaryRenderWaveBuffer(CKsRenderDevice *, LPVOID);
    virtual ~CKsPrimaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(DWORD);

    // Access rights
    virtual HRESULT RequestWriteAccess(BOOL);

    // Buffer data
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dListener(C3dListener **);

private:
    virtual HRESULT OnSetFormat(void);
    virtual HRESULT FixUpBaseClass(void);
};

inline HRESULT CKsPrimaryRenderWaveBuffer::CreatePropertySet(CPropertySet **)
{
    return DSERR_UNSUPPORTED;
}


// The KS secondary wave buffer
class CKsSecondaryRenderWaveBuffer : public CSecondaryRenderWaveBuffer, private CUsesCallbackEvent
{
    friend class CKsRenderDevice;
    friend class CKsPrimaryRenderWaveBuffer;
    friend class CKsItd3dObject;
    friend class CKsIir3dObject;
    friend class CKsHw3dObject;

private:
    CKsRenderDevice *               m_pKsDevice;                // KS audio device
    CKsRenderPin *                  m_pPin;                     // KS render pin
    DWORD                           m_dwState;                  // Current buffer state
    CCallbackEvent *                m_pCallbackEvent;           // The callback event
    CEvent *                        m_pLoopingEvent;            // Looping buffer event
    LPDSBPOSITIONNOTIFY             m_paNotes;                  // Current notification positions
    LPDSBPOSITIONNOTIFY             m_pStopNote;                // Stop notification
    DWORD                           m_cNotes;                   // Count of notification positions
    LONG                            m_lVolume;                  // Buffer volume
    LONG                            m_lPan;                     // Buffer pan
    BOOL                            m_fMute;                    // Buffer mute
    DIRECTSOUNDMIXER_SRCQUALITY     m_nSrcQuality;              // Buffer SRC quality
    DWORD                           m_dwPositionCache;          // Position cache

    // Flags to help with 3D algorithm selection/fallback:
    BOOL                            m_fNoVirtRequested;         // DS3DALG_NO_VIRTUALIZATION requested?
    BOOL                            m_fSoft3dAlgUnavail;        // Unsupported HRTF algorithm requested?

public:
    CKsSecondaryRenderWaveBuffer(CKsRenderDevice *, LPVOID);
    virtual ~CKsSecondaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(LPCVADRBUFFERDESC, CKsSecondaryRenderWaveBuffer *, CSysMemBuffer *pBuffer = NULL);

    // Resource allocation
    virtual HRESULT AcquireResources(DWORD);
    virtual HRESULT StealResources(CSecondaryRenderWaveBuffer *);
    virtual HRESULT FreeResources(void);

    // Buffer creation
    virtual HRESULT Duplicate(CSecondaryRenderWaveBuffer **);

    // Buffer data
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCursorPosition(DWORD);

    // Buffer properties
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN);
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetChannelAttenuations(LONG, DWORD, const DWORD*, const LONG*);
#endif
    virtual HRESULT SetAllChannelAttenuations(LONG, DWORD, LPLONG);
    virtual HRESULT SetFrequency(DWORD, BOOL fClamp =FALSE);
    virtual HRESULT SetMute(BOOL);
    virtual HRESULT SetFormat(LPCWAVEFORMATEX);

    // Position notifications
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);
    virtual HRESULT FreeNotificationPositions(void);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dObject(C3dListener *, C3dObject **);

private:
    // Buffer properties
    virtual HRESULT SetSrcQuality(DIRECTSOUNDMIXER_SRCQUALITY);

    // Pin creation
    virtual HRESULT CreatePin(DWORD, LPCWAVEFORMATEX, REFGUID, CKsRenderPin **);
    virtual HRESULT HandleResourceAcquisition(CKsRenderPin *);
    virtual BOOL HasAcquiredResources(void);

    // Pin freedom
    virtual HRESULT FreePin(BOOL);

    // Buffer control
    virtual HRESULT SetPlayState(BOOL);
    virtual HRESULT SetStopState(BOOL, BOOL);

    // Buffer events
    virtual void EventSignalCallback(CCallbackEvent *);

    // Owned objects
    virtual HRESULT CreateHw3dObject(C3dListener *, C3dObject **);
    virtual HRESULT CreateIir3dObject(C3dListener *, C3dObject **);
    virtual HRESULT CreateItd3dObject(C3dListener *, C3dObject **);
    virtual HRESULT CreateMultiPan3dObject(C3dListener *, BOOL, DWORD, C3dObject **);
};


// The KS render pin object
class CKsRenderPin : public CDsBasicRuntime
{
    friend class CKsSecondaryRenderWaveBuffer;
    friend class CKsRenderPinCache;
    friend class CKsHw3dObject;

private:
    CKsRenderDevice *                       m_pKsDevice;            // KS audio device
    ULONG                                   m_ulPinId;              // KS pin id
    HANDLE                                  m_hPin;                 // Audio device pin
    DWORD                                   m_dwFlags;              // Pin flags
    LPWAVEFORMATEX                          m_pwfxFormat;           // Pin format
    GUID                                    m_guid3dAlgorithm;      // Pin 3D algorithm
    DWORD                                   m_dwState;              // Current buffer state
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    m_paEventData;          // Position notification event data
    DWORD                                   m_cEventData;           // Count of events
    KSSTREAMIO                              m_kssio;                // KS stream IO data
    LONG                                    m_lVolume;              // Pin volume
    LONG                                    m_lPan;                 // Pin pan
    BOOL                                    m_fMute;                // Pin mute
    DIRECTSOUNDMIXER_SRCQUALITY             m_nSrcQuality;          // Pin SRC quality
    DWORD                                   m_dwPositionCache;      // Cached buffer position

public:
    CKsRenderPin(CKsRenderDevice *);
    virtual ~CKsRenderPin(void);

    // Initialization
    virtual HRESULT Initialize(DWORD, LPCWAVEFORMATEX, REFGUID);

    // Pin properties
    virtual HRESULT SetVolume(LONG);
    virtual HRESULT SetPan(LONG);
    virtual HRESULT SetChannelLevels(DWORD, const LONG *);
    virtual HRESULT SetFrequency(DWORD);
    virtual HRESULT SetMute(BOOL);
    virtual HRESULT SetSrcQuality(DIRECTSOUNDMIXER_SRCQUALITY);
    virtual HRESULT SetSuperMix(void);

    // Pin control
    virtual HRESULT SetPlayState(LPCVOID, DWORD, BOOL, HANDLE);
    virtual HRESULT SetStopState(BOOL, BOOL);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCursorPosition(DWORD);

    // Position notifications
    virtual HRESULT EnableNotificationPositions(LPCDSBPOSITIONNOTIFY, DWORD);
    virtual HRESULT DisableNotificationPositions(void);
};


// Pin cache
class CKsRenderPinCache : public CDsBasicRuntime
{
private:
    static const DWORD          m_dwTimeout;            // Timeout for old pins
    CList<KSPINCACHE>           m_lstPinCache;          // Pin-reuse pool

public:
    CKsRenderPinCache(void);
    virtual ~CKsRenderPinCache(void);

    virtual HRESULT AddPinToCache(CKsRenderPin *);
    virtual HRESULT GetPinFromCache(DWORD, LPCWAVEFORMATEX, REFGUID, CKsRenderPin **);
    virtual void FlushCache(void);

private:
    virtual void RemovePinFromCache(CNode<KSPINCACHE> *);
    virtual void FlushExpiredPins(void);
};

#endif // __cplusplus

#endif // __KSVAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge103.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge103 */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE103ASM
BOOL Merge103Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
 
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;
#if 1
	if (!pMixSource->m_fUse_MMX)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	movsx	ecx, WORD PTR [esi+4]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	mov	DWORD PTR [edi], ebx

	movsx	ecx, WORD PTR [esi+6]
	movsx	ebx, WORD PTR [esi+2]
	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movq		mm1, QWORD PTR [esi]
	movq		mm2, mm1
	punpckhdq	mm2, mm2	// Put next sample in low half.
	psubw		mm2, mm1

//	movsx	ecx, WORD PTR [esi+4]
//	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

	movd		mm5, ebp
	punpcklwd	mm1, mm1
	punpcklwd	mm5, mm5	// dwFrac.  Lower dword has 2 copies.

	movq		mm3, mm2	// Use for high half of multiply.
	psrad		mm1, 16

	pmullw		mm2, mm5	// Low word.
	pmulhw		mm3, mm5	// High word results.

	punpcklwd	mm2, mm3	// Low bits are Left, high are Right.
	psrad		mm2, 12
	paddd		mm1, mm2
	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1

//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi]
//	add	ebx, ecx
//	mov	DWORD PTR [edi], ebx

//	movsx	ecx, WORD PTR [esi+6]
//	movsx	ebx, WORD PTR [esi+2]
//	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
       LONG SampleLNext;
       LONG SampleRNext;

       while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
       {
       LONG SampleL;
       LONG SampleR;
       SampleL = *((SHORT*)(XpSource));
       SampleR = *(((SHORT*)(XpSource))+1);
       SampleLNext = *(((SHORT*)(XpSource))+2);
       SampleRNext = *(((SHORT*)(XpSource))+3);

       LONG dwFrac = dwFraction & FRACT_MASK;
       SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
       SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
       dwFraction += dwStep;
       *XplBuild += SampleL;
       *(XplBuild + 1) += SampleR;
   
       plBuild += 2;
       }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }


  *((LONG **)ppSource) = (LONG *)pSource;
   pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
   pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge165.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge165 */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE165ASM
BOOL Merge165Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;
#if 1
     if (iters) {
       _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, plBuild
	push	ebp
        mov	ebp, pMixSource
	jl	LastSamples

	mov	eax, [ebp]pMixSource.m_fUse_MMX
	test	eax, eax
	je	LastSamples

	mov	eax, DWORD PTR [ebp]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	shr	eax, 1
	shr	ecx, 1
	and	ecx, 0xffff
	shl	eax, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 6

FirstSamples:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	DWORD PTR [edi+ebx*4], ecx
	add	DWORD PTR [edi+ebx*4+4], edx

	sub	ebx, 2
	lea	ecx, [esi+ebx]

	and	ecx, 7
	cmp	ecx, 6

	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	jmp	DoMMX100

DoMMX10:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		mm3, mm1			// Mono samples

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklwd	mm1, mm1

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	punpckhwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	pmulhw		mm1, mm6

DoMMX100:
	punpckhwd	mm2, mm1
	sub		ebx, 8

	pmulhw		mm3, mm6
	
	punpcklwd	mm1, mm1

	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	psrad		mm2, 15

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	psrad		mm4, 15

	jge		DoMMX10

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	pmulhw		mm3, mm6
	
	punpckhwd	mm2, mm1
	punpcklwd	mm1, mm1
	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 15
	psrad		mm2, 15
	psrad		mm3, 15
	psrad		mm4, 15

	paddd		mm1, QWORD PTR [edi+ebx*4]
	paddd		mm2, QWORD PTR [edi+ebx*4+8]
	paddd		mm3, QWORD PTR [edi+ebx*4+16]
	paddd		mm4, QWORD PTR [edi+ebx*4+24]
	movq		QWORD PTR [edi+ebx*4],    mm1
	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
#ifdef USE_SLOWER_TABLE
	mov	eax, [ebp]pMixSource.m_MapTable
	test	eax, eax
	je	NoMapTable
	
	mov	ebp, eax

UseMapTable:
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	mov	eax, ecx
	and	ecx, 0xff
	sar	eax, 8
	mov	ecx, DWORD PTR [ebp+ecx*4]
	mov	eax, DWORD PTR [ebp+eax*4+2048+512]
	add	ecx, eax

	mov	eax, DWORD PTR [edi+ebx*4]
	add	eax, ecx

//	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
//	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

//	sar	ecx, 16
//	sar	edx, 16

	mov	ecx, edx
	mov	DWORD PTR [edi+ebx*4], eax
	and	edx, 0xff
	sar	ecx, 8
	mov	edx, DWORD PTR [ebp+edx*4+1024]
	mov	ecx, DWORD PTR [ebp+ecx*4+1024+2048+512]
	add	edx, ecx

        mov	ecx, DWORD PTR [edi+ebx*4+4]
        add	ecx, edx
	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 2

	jge	UseMapTable

	jmp	Done
#endif

NoMapTable:
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx
	mov	eax, DWORD PTR [edi+ebx*4]

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	eax, ecx
        mov	ecx, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], eax
        add	ecx, edx

	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 2

	jge	NoMapTable
Done:
	pop	ebp
	}
    }
#elif 1
    if (iters) {
	_asm {
        mov	ebx, iters
        mov	esi, pSource
        mov	edi, plBuild
        push	ebp
	mov	ebp, pMixSource
	lea	ebx, [ebx*2-2]
	movsx	ecx, WORD PTR [esi+ebx]

Lab:
	mov	edx, ecx
	mov	eax, DWORD PTR [edi+ebx*4]

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	eax, ecx
        mov	ecx, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], eax
        add	ecx, edx

	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 2

	movsx	ecx, WORD PTR [esi+ebx]
        jne	Lab
	pop	ebp
	}
    }
#else
    while(--iters >= 0)
    {
      LONG Sample;
      Sample = ((LONG)*((SHORT*)(XpSource)));
      *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
      *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    }
#endif

    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge224.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge224 */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE224ASM
BOOL Merge224Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

#if 1
    if (!pMixSource->m_fUse_MMX) {
	if (!pMixSource->m_MapTable)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	add	esi, ecx		// pSource
	push	ebp			// Create local frame...
	mov	ecx,  DWORD PTR pMixSource
	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
	xor	ecx, ecx
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	mov	cl, BYTE PTR [esi+1]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebp, ecx
	imul	ecx, DWORD PTR [esp+12]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	edi, 8			// plBuild += 2
	add	ebx, ecx
	mov	DWORD PTR [edi-8], ebx
	imul	ebp, DWORD PTR [esp+16]
	mov	ecx, DWORD PTR [esp+8]	// dwStep
	sar	ebp, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ecx		// dwFraction += dwStep
	add	ebx, ebp
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*1]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	add	esi, ecx		// pSource
	push	ebp			// Create local frame...
	mov	ecx,  DWORD PTR pMixSource
	push	edx
	mov	edx, DWORD PTR [ecx]pMixSource.m_MapTable
//	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
//	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit1

	mov	ebp, eax
	xor	ecx, ecx
Lab1:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit1

	mov	cl, BYTE PTR [esi+1]
	xor	ebx, ebx
//	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebp, ecx
	mov	ecx, DWORD PTR [edx+ecx*4]
//	imul	ecx, DWORD PTR [esp+12]
//	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	edi, 8			// plBuild += 2
	add	ebx, ecx
	mov	DWORD PTR [edi-8], ebx
	mov	ebp, DWORD PTR [edx+ebp*4+1024]
//	imul	ebp, DWORD PTR [esp+16]
	mov	ecx, DWORD PTR [esp+8]	// dwStep
//	sar	ebp, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ecx		// dwFraction += dwStep
	add	ebx, ebp
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	mov	ebx, DWORD PTR [esp+12]
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [ebx+ecx*1]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab1
Exit1:
	add	esp, 16
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
    }
    else
	_asm {
	mov	eax, pMixSource
	mov	ecx, DWORD PTR [eax]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [eax]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
//	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
//	punpckldq	mm6, mm6

	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	add	esi, ecx		// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
	xor	ecx, ecx
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	mov	cl, BYTE PTR [esi+1]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
//	mov	ebp, DWORD PTR [edi]
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x

	movd		mm1, ecx
	punpcklwd	mm1, mm1
	
	pmulhw		mm1, mm6			// Only need high parts.
	punpcklwd	mm1, mm1
	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1
	
//	mov	ebx, DWORD PTR [edi+4]
//	add	ebp, ecx
//	add	ebx, ecx
//	mov	DWORD PTR [edi], ebp
	add	edi, 8			// plBuild += 2
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	add	eax, ebp		// dwFraction += dwStep
	mov	ecx, eax
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*1]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleNext, SampleSave;
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG Sample;
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
      SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
      LONG dwFrac = dwFraction & FRACT_MASK;
      SampleSave = Sample;
      Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
      *(XplBuild+1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge167.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge167 */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE167ASM
BOOL Merge167Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  
  #define USE_ITERS		// Keep separate from RESAMPLE to ease removal.
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;
#if 1
     if (iters) {
      if (pMixSource->m_fUse_MMX)
      _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*4-4]				// 2 at a time.
	cmp	ebx, 12
        mov	edi, plBuild
	push	ebp
	mov	ebp, pMixSource
	jl	OneSample

	mov	eax, DWORD PTR [ebp]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	shr	eax, 1					   // Keep positive.
	shr	ecx, 1
	and	ecx, 0xffff
	shl	eax, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	sub	ebx, 4
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 4

OneSample:	
	movsx	ecx, WORD PTR [esi+ebx]
	movsx	edx, WORD PTR [esi+ebx+2]

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	DWORD PTR [edi+ebx*2], ecx
	add	DWORD PTR [edi+ebx*2+4], edx

	test	ebx, ebx
	je	Done

	sub	ebx, 4
	je	OneSample

	sub	ebx, 4
DoMMX:
#ifdef GTW_REORDER
	cmp	ebx, 16
	jl	DoMMX001


	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	pmulhw		mm1, mm6
	punpckhwd	mm2, mm1			// First stereo sample
	sub	ebx, 16
	punpcklwd	mm1, mm1			// Second stereo sample
	psrad		mm1, 15
	psrad		mm2, 15

	movq		mm3, QWORD PTR [esi+ebx-8+16]	// Load source
	jmp	DoMMX0001
DoMMX01:
	movq		mm3, QWORD PTR [esi+ebx-8+16]	// Load source
	psrad		mm2, 15
DoMMX0001:
	paddd		mm1, QWORD PTR [edi+ebx*2+32]
	pmulhw		mm3, mm6

	paddd		mm2, QWORD PTR [edi+ebx*2+8+32]
	punpckhwd	mm4, mm3			// First stereo sample

	movq		QWORD PTR [edi+ebx*2+32], mm1
	punpcklwd	mm3, mm3			// Second stereo sample

	movq		QWORD PTR [edi+ebx*2+8+32], mm2
	psrad		mm3, 15

	movq		mm1, QWORD PTR [esi+ebx-16+16]	// Load source
	psrad		mm4, 15

	paddd		mm3, QWORD PTR [edi+ebx*2-16+32]
	pmulhw		mm1, mm6

	paddd		mm4, QWORD PTR [edi+ebx*2+8-16+32]
	punpckhwd	mm2, mm1			// First stereo sample

	movq		QWORD PTR [edi+ebx*2-16+32], mm3
	punpcklwd	mm1, mm1			// Second stereo sample

	movq		QWORD PTR [edi+ebx*2+8-16+32], mm4
	psrad		mm1, 15

	sub	ebx, 16
	jge	DoMMX01

	psrad		mm2, 15
	paddd		mm1, QWORD PTR [edi+ebx*2+32]
	paddd		mm2, QWORD PTR [edi+ebx*2+8+32]
	movq		QWORD PTR [edi+ebx*2+32], mm1
	movq		QWORD PTR [edi+ebx*2+8+32], mm2

	add		ebx, 8
	jge		DoMMX001

	add		ebx, 4
	je		OneSample
	jmp		Done
	
#endif
DoMMX001:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	pmulhw		mm1, mm6
	
	punpckhwd	mm2, mm1			// First stereo sample
	punpcklwd	mm1, mm1			// Second stereo sample
	psrad		mm1, 15
	psrad		mm2, 15
	paddd		mm1, QWORD PTR [edi+ebx*2]
	paddd		mm2, QWORD PTR [edi+ebx*2+8]
	movq		QWORD PTR [edi+ebx*2], mm1
	movq		QWORD PTR [edi+ebx*2+8], mm2
	
	sub		ebx, 8
	jge		DoMMX001

	add	ebx, 4
	je	OneSample
	
Done:
	emms
	pop	ebp
	}
      else if (0 && pMixSource->m_MapTable) {
        _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*4-4]
        mov	edi, plBuild
        push	ebp
	mov	ebp, pMixSource
	mov	ebp, [ebp]pMixSource.m_MapTable
UseMapTable:
	movsx	ecx, WORD PTR [esi+ebx]

	mov	eax, ecx
	and	ecx, 0xff
	sar	eax, 8
	mov	ecx, DWORD PTR [ebp+ecx*4]
	mov	eax, DWORD PTR [ebp+eax*4+2048+512]
	add	ecx, eax

	mov	eax, DWORD PTR [edi+ebx*4]
	add	eax, ecx

	movsx	ecx, WORD PTR [esi+ebx+2]
	mov	DWORD PTR [edi+ebx*4], eax
	mov	edx, ecx
	and	ecx, 0xff
	sar	edx, 8
	mov	ecx, DWORD PTR [ebp+ecx*4+1024]
	mov	edx, DWORD PTR [ebp+edx*4+1024+2048+512]
	add	edx, ecx

        mov	ecx, DWORD PTR [edi+ebx*4+4]
        add	ecx, edx
	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 4

	jge	UseMapTable
	
	pop	ebp
      }
    }
    else
        _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*4-4]
        mov	edi, plBuild
        push	ebp
	mov	ebp, pMixSource
	push	[ebp]pMixSource.m_dwRVolume
	push	[ebp]pMixSource.m_dwLVolume
	mov	ebp, DWORD PTR [esi+ebx]
Lab:
	mov	edx, ebp

	sal	ebp, 16
	mov	ecx, DWORD PTR[edi+ebx*2]

	sar	edx, 16
	mov	eax, DWORD PTR[edi+ebx*2+4]

	sar	ebp, 16

	imul	edx, DWORD PTR [esp+4]
	imul	ebp, DWORD PTR [esp+0]

	sar	edx, 16
	sar	ebp, 16

	add	edx, eax

	add	ecx, ebp
	sub	ebx, 4

	mov	DWORD PTR [edi+ebx*2+8], ecx
	mov	ebp, DWORD PTR [esi+ebx]

	mov	DWORD PTR [edi+ebx*2+12], edx
	jge	SHORT Lab

	add	esp, 8
        pop	ebp
      }
    }
#elif 0
    if (iters) {
	_asm {
        mov	ebx, iters
        mov	esi, pSource
        mov	edi, plBuild
        push	ebp
	mov	ebp, pMixSource
	lea	ebx, [ebx*4-4]

	mov	ecx, DWORD PTR [esi+ebx]	// !!!
Lab:
//	movsx	ecx, WORD PTR [esi+ebx]
//	movsx	edx, WORD PTR [esi+ebx+2]

	mov	edx, ecx
	shl	ecx, 16
	sar	edx, 16
	sar	ecx, 16

	mov	eax, DWORD PTR [edi+ebx*2]

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	eax, ecx
        mov	ecx, DWORD PTR [edi+ebx*2+4]

	mov	DWORD PTR [edi+ebx*2], eax
        add	ecx, edx

	mov	DWORD PTR [edi+ebx*2+4], ecx
        sub	ebx,4

	mov	ecx, DWORD PTR [esi+ebx]	// !!!
        jne	Lab
	pop	ebp
	}
    }
#else
    while(--iters >= 0)
    {
      LONG SampleL;
      LONG SampleR;
      SampleL = *((SHORT*)(XpSource));
      SampleR = *(((SHORT*)(XpSource))+1);
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
      *XplBuild += SampleL;
      *(XplBuild + 1) += SampleR;
    }
#endif
    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
  pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge226.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge226 */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE226ASM
BOOL Merge226Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#if 1
    if (!pMixSource->m_fUse_MMX) {
	if (!pMixSource->m_MapTable)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp			// Create local frame...
	mov	ecx,  DWORD PTR pMixSource
	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
	xor	ecx, ecx
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	mov	cl, BYTE PTR [esi+2]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	imul	ecx, DWORD PTR [esp+12]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	xor	ecx, ecx
	mov	DWORD PTR [edi], ebx
	mov	cl, BYTE PTR [esi+3]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi+1]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	add	edi, 8			// plBuild += 2
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
	imul	ecx, DWORD PTR [esp+16]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp			// Create local frame...
	mov	ecx,  DWORD PTR pMixSource
	push	edx
	mov	edx, DWORD PTR [ecx]pMixSource.m_MapTable
//	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
//	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit1

	mov	ebp, eax
	xor	ecx, ecx
Lab1:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit1

	mov	cl, BYTE PTR [esi+2]
	xor	ebx, ebx
//	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ecx, DWORD PTR [edx+ecx*4]
//	imul	ecx, DWORD PTR [esp+12]
//	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	xor	ecx, ecx
	mov	DWORD PTR [edi], ebx
	mov	cl, BYTE PTR [esi+3]
	xor	ebx, ebx
//	sub	ecx, 128
	mov	bl, BYTE PTR [esi+1]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	add	edi, 8			// plBuild += 2
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
	mov	ecx, DWORD PTR [edx+ecx*4+1024]
//	imul	ecx, DWORD PTR [esp+16]
//	sar	ecx, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebx, DWORD PTR [esp+12]
	mov	ebp, eax
	lea	esi, [ebx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab1
Exit1:
	add	esp, 16
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
    }
    else
	_asm {
	mov	eax, pMixSource
	mov	ecx, DWORD PTR [eax]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [eax]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
//	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
//	punpckldq	mm6, mm6

	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov		ecx, 128
	movd		mm7, ecx	// 0, 0, 0, 128
	punpcklwd	mm7, mm7	// 0, 0, 128, 128
	punpckldq	mm7, mm7	// 128, 128, 128, 128

	mov	ebp, eax
	xor	ecx, ecx

Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movd		mm1, DWORD PTR [esi]
	punpcklbw	mm1, mm0
	psubw		mm1, mm7
	psllw		mm1, 8

	movq		mm2, mm1
	punpckhdq	mm2, mm2	// Put next sample in low half.
	psubw		mm2, mm1

//	mov	cl, BYTE PTR [esi+2]
//	xor	ebx, ebx
//	sub	ecx, 128
//	mov	bl, BYTE PTR [esi]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

	movd		mm5, ebp
	punpcklwd	mm1, mm1	
	punpcklwd	mm5, mm5	
	psrad		mm1, 16
#ifdef DO_MORE_ACCURATE_VERSION
	movq		mm3, mm2	// Use for high half of multiply.

	pmullw		mm2, mm5	// Low word.
	pmulhw		mm3, mm5	// High word results.

	punpcklwd	mm2, mm3	// Low bits are Left, high are Right.
#else
	pmulhw		mm2, mm5
	punpcklwd	mm2, mm2	// Lower 4 bits are randomized.
#endif
	psrad		mm2, 12
	paddd		mm1, mm2

	packssdw	mm1, mm1	// Shift low 16 bits of high dword 16.

	pmulhw		mm1, mm6
	punpcklwd	mm1, mm1	// Move to high part.
	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1

//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi]
//	add	ebx, ecx
//	xor	ecx, ecx
//	mov	DWORD PTR [edi], ebx
//	mov	cl, BYTE PTR [esi+3]
//	xor	ebx, ebx
//	sub	ecx, 128
//	mov	bl, BYTE PTR [esi+1]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	add	edi, 8			// plBuild += 2
//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleLNext;
    LONG SampleRNext;

    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG SampleL;
      LONG SampleR;
      SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
      SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
      SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
      SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
      LONG dwFrac = dwFraction & FRACT_MASK;
      SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
      SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
      *XplBuild += SampleL;
      *(XplBuild + 1) += SampleR;
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge231.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge231 */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE231ASM
BOOL Merge231Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
  {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#if 1 
    if (!pMixSource->m_fUse_MMX) {
	if (1 || !pMixSource->m_MapTable)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	mov	ecx, DWORD PTR pMixSource
	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	movsx	ecx, WORD PTR [esi+4]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	imul	ecx, DWORD PTR [esp+12]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	mov	DWORD PTR [edi], ebx

	movsx	ecx, WORD PTR [esi+6]
	movsx	ebx, WORD PTR [esi+2]
	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
	imul	ecx, DWORD PTR [esp+16]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	mov	ecx, DWORD PTR pMixSource
	push	edx
	mov	edx, DWORD PTR [ecx]pMixSource.m_MapTable
//	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
//	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit1

	mov	ebp, eax
Lab1:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit1

	movsx	ecx, WORD PTR [esi+4]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
//	imul	ecx, DWORD PTR [esp+12]
//	sar	ecx, 16

	mov	ebx, ecx
	and	ecx, 0xff
	sar	ebx, 8
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edx+ebx*4+2048+512]
	add	ecx, ebx

	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	mov	DWORD PTR [edi], ebx

	movsx	ecx, WORD PTR [esi+6]
	movsx	ebx, WORD PTR [esi+2]
	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
//	imul	ecx, DWORD PTR [esp+16]
//	sar	ecx, 16

	mov	ebx, ecx
	and	ecx, 0xff
	sar	ebx, 8
	mov	ecx, DWORD PTR [edx+ecx*4+1024]
	mov	ebx, DWORD PTR [edx+ebx*4+1024+2048+512]
	add	ecx, ebx

	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebx, DWORD PTR [esp+12]
	mov	ebp, eax
	lea	esi, [ebx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab1
Exit1:
	add	esp, 16
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
    }
    else
	_asm {
	mov	eax, pMixSource
	mov	ecx, DWORD PTR [eax]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [eax]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
//	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
//	punpckldq	mm6, mm6

	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movq		mm1, QWORD PTR [esi]
	movq		mm2, mm1
	punpckhdq	mm2, mm2	// Put next sample in low half.
	psubw		mm2, mm1

//	movsx	ecx, WORD PTR [esi+4]
//	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

	movd		mm5, ebp
	punpcklwd	mm1, mm1	// Make 32 bits.
	punpcklwd	mm5, mm5	// dwFrac.  Lower dword has 2 copies.

	movq		mm3, mm2	// Use for high half of multiply.
	psrad		mm1, 16

	pmullw		mm2, mm5	// Low word.
	pmulhw		mm3, mm5	// High word results.

	punpcklwd	mm2, mm3	// Low bits are Left, high are Right.
	psrad		mm2, 12
	paddd		mm1, mm2

	packssdw	mm1, mm1	// Shift low 16 bits of high dword 16.

	pmulhw		mm1, mm6
	punpcklwd	mm1, mm1	// Move to high part.
	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1

//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi]
//	add	ebx, ecx
//	mov	DWORD PTR [edi], ebx

//	movsx	ecx, WORD PTR [esi+6]
//	movsx	ebx, WORD PTR [esi+2]
//	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleLNext;
    LONG SampleRNext;
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG SampleL;
      LONG SampleR;
      SampleL = *((SHORT*)(XpSource));
      SampleR = *(((SHORT*)(XpSource))+1);
      SampleLNext = *(((SHORT*)(XpSource))+2);
      SampleRNext = *(((SHORT*)(XpSource))+3);
      LONG dwFrac = dwFraction & FRACT_MASK;
      SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
      SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
      *XplBuild += SampleL;
      *(XplBuild + 1) += SampleR;
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge32.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge32 */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE32ASM
BOOL Merge32Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE))
  
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  
  #define USE_ITERS		// Keep separate from RESAMPLE to ease removal.
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))
  

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;
    
       LONG iters, i;
       i     = plBuildEnd - plBuild;
       iters = pSourceEnd - pSource;
       iters /= STEP_SIZE;
       i /= 2;;
       if (i < iters) iters = i;
       i = iters;
#if 1
       if (iters) {
        _asm {
	mov	ecx, pMixSource
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*1-1]
	xor	eax, eax
	cmp	ebx, 7
        mov	edi, plBuild
	jl	LastSamples

	mov	ecx, [ecx]pMixSource.m_fUse_MMX
	test	ecx, ecx
	jmp	LastSamples
	je	LastSamples

	sub	ebx, 3
	lea	ecx, [esi+ebx]
	pxor	mm0, mm0

	mov	edx, 128
	movd		mm5, edx	// 0, 0, 0, 128
	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128


	test	ecx, 3
	je	DoMMX

	add	ebx, 3

FirstSamples:	
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ecx, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ecx, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ecx
	dec	ebx
	lea	ecx, [esi+ebx]
	and	ecx, 3
	cmp	ecx, 3
	jne	FirstSamples

	sub	ebx, 3

DoMMX:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	jmp	DoMMX00

DoMMX0:
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpckhdq	mm4, mm4

	paddd		mm3, QWORD PTR [edi+ebx*8+16+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	psubw		mm1, mm5

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	punpckhwd	mm3, mm1

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	punpcklwd	mm1, mm1
DoMMX00:
	psrad		mm1, 16
	sub		ebx, 4

	psrad		mm3, 16
	movq		mm2, mm1

	punpckldq	mm1, mm1
	movq		mm4, mm3

	paddd		mm1, QWORD PTR [edi+ebx*8+32]
	punpckhdq	mm2, mm2

	paddd		mm2, QWORD PTR [edi+ebx*8+8+32]
	punpckldq	mm3, mm3

	movq		QWORD PTR [edi+ebx*8+32],    mm1
	jge		DoMMX0

	paddd		mm3, QWORD PTR [edi+ebx*8+16+32]
	punpckhdq	mm4, mm4

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
#if 0
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1
	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 16
	psrad		mm2, 16
	psrad		mm3, 16
	psrad		mm4, 16
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	movq		mm4, mm3

	punpckldq	mm1, mm1
	punpckhdq	mm2, mm2
	punpckldq	mm3, mm3
	punpckhdq	mm4, mm4
#endif
	paddd		mm1, QWORD PTR [edi+ebx*8]
	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	paddd		mm4, QWORD PTR [edi+ebx*8+24]
	movq		QWORD PTR [edi+ebx*8],    mm1
	movq		QWORD PTR [edi+ebx*8+8],  mm2
	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX
#endif

	emms
	add	ebx, 4
	je	Done

	dec	ebx
	xor	eax, eax
	
LastSamples:	
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ecx, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ecx, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ecx
	dec	ebx
	jge	LastSamples
Done:
        }
       }
#elif 0
	if (iters)
	_asm {
	mov	esi, pSource
	mov	edi, plBuild
	mov	ebx, iters
	push	ebp

	dec	ebx
	xor	eax, eax
Lab:
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ebp, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ebp, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ebp
	dec	ebx
	jge	Lab

	pop	ebp
	}
#else
       while(--iters >= 0)
       {
          LONG Sample;
	  Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
         *XplBuild += Sample;
         *(XplBuild + 1) += Sample;
        
       }
#endif
       iters = i;
       i *= 2;;
       plBuild  += i;
     
       pSource          = XpSource;
       nInputByteCount -=  pSource - pSourceStart;

       if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
          pSource -= pMixSource->m_cbBuffer;
       }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
    }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge229.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge229 */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE229ASM
BOOL Merge229Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD))

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#if 1
    if (!pMixSource->m_fUse_MMX) {
	if (1 || !pMixSource->m_MapTable)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	mov	ecx, DWORD PTR pMixSource
	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	movsx	ecx, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebp, ecx
	imul	ecx, DWORD PTR [esp+12]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	mov	DWORD PTR [edi], ebx

	add	edi, 8			// plBuild += 2
	mov	ecx, DWORD PTR [esp+8]	// dwStep
	imul	ebp, DWORD PTR [esp+16]
	sar	ebp, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ecx		// dwFraction += dwStep
	add	ebx, ebp
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	edx
	mov	ecx, DWORD PTR pMixSource
	mov	ecx, DWORD PTR [ecx]pMixSource.m_MapTable
	push	ecx
//	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
//	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit1

	mov	ebp, eax
Lab1:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit1

	movsx	ecx, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebp, ecx
	and	ecx, 0xff
	mov	ebx, ebp
	mov	edx, DWORD PTR [esp+12]
	sar	ebx, 8
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edx+ebx*4+2048+512]
	add	edi, 8			// plBuild += 2
	add	ecx, ebx
//	imul	ecx, DWORD PTR [esp+12]
//	sar	ecx, 16
	mov	ebx, DWORD PTR [edi-8]
	add	ebx, ecx
	mov	DWORD PTR [edi-8], ebx

	mov	ebx, ebp
	and	ebp, 0xff
	sar	ebx, 8
	mov	ebp, DWORD PTR [edx+ebp*4+1024]
	mov	edx, DWORD PTR [edx+ebx*4+1024+2048+512]
	mov	ecx, DWORD PTR [esp+8]	// dwStep
	add	ebp, edx
//	imul	ebp, DWORD PTR [esp+16]
//	sar	ebp, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ecx		// dwFraction += dwStep
	add	ebx, ebp
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	mov	edx, DWORD PTR [esp+16]

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab1
Exit1:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
     }
     else
	_asm {
	mov	eax, pMixSource
	mov	ecx, DWORD PTR [eax]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [eax]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
//	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movsx	ecx, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	edi, 8			// plBuild += 2
	add	ecx, ebx		// NewSample += x

	movd		mm1, ecx
	punpcklwd	mm1, mm1
	
	pmulhw		mm1, mm6			// Only need high parts.
	punpcklwd	mm1, mm1
	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi-8]
	movq		QWORD PTR [edi-8], mm1

//	mov	ebx, DWORD PTR [edi-8]
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ebx, ecx
	add	eax, ebp		// dwFraction += dwStep
//	mov	DWORD PTR [edi-8], ebx	// *plBuild += x

//	mov	ebx, DWORD PTR [edi-4]
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleNext;
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG Sample;
      Sample = ((LONG)*((SHORT*)(XpSource)));
      SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
      LONG dwFrac = dwFraction & FRACT_MASK;
      Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
      *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge37.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge37 */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE37ASM
BOOL Merge37Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;
#if 1
     if (iters) {
       _asm {
        mov	ecx, pMixSource
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, plBuild
	jl	LastSamples

	mov	ecx, [ecx]pMixSource.m_fUse_MMX
	test	ecx, ecx
	je	LastSamples

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 6

FirstSamples:	
	movsx	ecx, WORD PTR [esi+ebx]
	add	DWORD PTR [edi+ebx*4], ecx
	add	DWORD PTR [edi+ebx*4+4], ecx
	sub	ebx, 2
	lea	ecx, [esi+ebx]
	and	ecx, 7
	cmp	ecx, 6
	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	jmp	DoMMX00

DoMMX0:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	punpckhwd	mm3, mm1

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklwd	mm1, mm1

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	psrad		mm1, 16

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	psrad		mm3, 16

DoMMX00:
	movq		mm2, mm1
	sub		ebx, 8

	punpckldq	mm1, mm1

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpckhdq	mm2, mm2

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	movq		mm4, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	punpckldq	mm3, mm3

	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	punpckhdq	mm4, mm4

	jge		DoMMX0

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
#if 0
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	punpckhwd	mm2, mm1
	punpcklwd	mm1, mm1
	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 16
	psrad		mm2, 16
	psrad		mm3, 16
	psrad		mm4, 16
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	movq		mm4, mm3

	punpckldq	mm1, mm1
	punpckhdq	mm2, mm2
	punpckldq	mm3, mm3
	punpckhdq	mm4, mm4
#endif
	paddd		mm1, QWORD PTR [edi+ebx*4]
	paddd		mm2, QWORD PTR [edi+ebx*4+8]
	paddd		mm3, QWORD PTR [edi+ebx*4+16]
	paddd		mm4, QWORD PTR [edi+ebx*4+24]
	movq		QWORD PTR [edi+ebx*4],    mm1
	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
	movsx	eax, WORD PTR [esi+ebx]

	mov	ecx, DWORD PTR[edi+ebx*4]
	mov	edx, DWORD PTR[edi+ebx*4+4]

	add	ecx, eax
	add	edx, eax

	sub	ebx, 2
	mov	DWORD PTR [edi+ebx*4+8], ecx

	mov	DWORD PTR [edi+ebx*4+12], edx
	jge	LastSamples
Done:
	}
    }
#elif 0
    if (iters) {
      _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*2-2]
        mov	edi, plBuild
Lab:
	movsx	eax, WORD PTR [esi+ebx]

	mov	ecx, DWORD PTR[edi+ebx*4]
	mov	edx, DWORD PTR[edi+ebx*4+4]

	add	ecx, eax
	add	edx, eax

	sub	ebx, 2
	mov	DWORD PTR [edi+ebx*4+8], ecx

	mov	DWORD PTR [edi+ebx*4+12], edx
	jge	SHORT Lab
      }
    }
#else
    while(--iters >= 0)
    {
      LONG Sample;
      Sample = ((LONG)*((SHORT*)(XpSource)));
      *XplBuild += Sample;
      *(XplBuild + 1) += Sample;
    }
#endif
    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge34.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge34 */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE34ASM
BOOL Merge34Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;
#if 1
    if (iters) {
      _asm {
	mov	ecx, pMixSource
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*2-2]
	cmp	ebx, 14
        mov	edi, plBuild
	push	ebp
	jl	LastSamples

	mov	ecx, [ecx]pMixSource.m_fUse_MMX
	test	ecx, ecx
	je	LastSamples

	sub	ebx, 6
	lea	ecx, [esi+ebx]
	pxor	mm0, mm0
	mov	edx, 128
	movd		mm5, edx	// 0, 0, 0, 128
	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128

	test	ecx, 7
	je	DoMMX

	add	ebx, 6

FirstSamples:	
	xor	eax, eax
	xor	ecx, ecx

	mov	al, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	mov	edx, DWORD PTR [edi+ebx*4]
	mov	ebp, DWORD PTR [edi+ebx*4+4]

	sub	eax, 128
	sub	ecx, 128

	shl	eax, 8
	shl	ecx, 8

	add	edx, eax
	add	ebp, ecx

	mov	DWORD PTR [edi+ebx*4], edx
	mov	DWORD PTR [edi+ebx*4+4], ebp

	sub	ebx, 2
	lea	ecx, [esi+ebx]
	and	ecx, 7
	cmp	ecx, 6
	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load 4 samples.
	movq		mm3, mm1
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	punpckhbw	mm3, mm0
	psubw		mm1, mm5
	psubw		mm3, mm5
	psllw		mm1, 8				// * 256
	psllw		mm3, 8
	jmp	DoMMX00
DoMMX0:
	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	psrad		mm2, 16

	movq		mm1, QWORD PTR [esi+ebx]	// Load 4 samples.
	psrad		mm4, 16

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		mm3, mm1

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	punpckhbw	mm3, mm0

	psubw		mm1, mm5
	psubw		mm3, mm5

	movq		QWORD PTR [edi+ebx*4+8+32],  mm2
	psllw		mm1, 8				// * 256

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	psllw		mm3, 8

DoMMX00:
	punpckhwd	mm2, mm1
	sub		ebx, 8

	punpcklwd	mm1, mm1
	movq		mm4, mm3

	psrad		mm1, 16

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	psrad		mm3, 16

	jge		DoMMX0

	psrad		mm2, 16

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	psrad		mm4, 16

	movq		QWORD PTR [edi+ebx*4+8+32],  mm2
	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load 4 samples.
	movq		mm3, mm1
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	punpckhbw	mm3, mm0
	psubw		mm1, mm5
	psubw		mm3, mm5
	psllw		mm1, 8				// * 256
	psllw		mm3, 8
	punpckhwd	mm2, mm1

	movq		mm4, mm3
	punpcklwd	mm1, mm1

	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 16
	psrad		mm2, 16

	paddd		mm1, QWORD PTR [edi+ebx*4]
	psrad		mm3, 16

	paddd		mm2, QWORD PTR [edi+ebx*4+8]
	psrad		mm4, 16

	paddd		mm3, QWORD PTR [edi+ebx*4+16]
	paddd		mm4, QWORD PTR [edi+ebx*4+24]
	movq		QWORD PTR [edi+ebx*4],    mm1
	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
	xor	eax, eax
	xor	ecx, ecx

	mov	al, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	mov	edx, DWORD PTR [edi+ebx*4]
	mov	ebp, DWORD PTR [edi+ebx*4+4]

	sub	eax, 128
	sub	ecx, 128

	shl	eax, 8
	shl	ecx, 8

	add	edx, eax
	add	ebp, ecx

	mov	DWORD PTR [edi+ebx*4], edx
	mov	DWORD PTR [edi+ebx*4+4], ebp

	sub	ebx, 2
	jge	LastSamples
Done:
	pop	ebp
	}
    }
#elif 0
    if (iters)
	_asm {
	mov	esi, pSource
	mov	edi, plBuild
	mov	ebx, iters
	push	ebp

	lea	ebx, [ebx*2-2]
Lab:
	xor	eax, eax
	xor	ecx, ecx

	mov	al, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	mov	edx, DWORD PTR [edi+ebx*4]
	mov	ebp, DWORD PTR [edi+ebx*4+4]

	sub	eax, 128
	sub	ecx, 128

	shl	eax, 8
	shl	ecx, 8

	add	edx, eax
	add	ebp, ecx

	mov	DWORD PTR [edi+ebx*4], edx
	mov	DWORD PTR [edi+ebx*4+4], ebp

	sub	ebx, 2
	jge	Lab

	pop	ebp
	}
#else
    while(--iters >= 0)
    {
       LONG SampleL;
       LONG SampleR;
       SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
       SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
       *XplBuild += SampleL;
       *(XplBuild + 1) += SampleR;
    }
#endif

    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge98.inc ===
/*
 * Merge98.inc
 *
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 */

/* Merge98 */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE98ASM
BOOL Merge98Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
  
  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;
    
#if 1
	if (!pMixSource->m_fUse_MMX)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
	xor	ecx, ecx
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	mov	cl, BYTE PTR [esi+2]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	xor	ecx, ecx
	mov	DWORD PTR [edi], ebx
	mov	cl, BYTE PTR [esi+3]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi+1]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	add	edi, 8			// plBuild += 2
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov		ecx, 128
	movd		mm6, ecx	// 0, 0, 0, 128
	punpcklwd	mm6, mm6	// 0, 0, 128, 128
	punpckldq	mm6, mm6	// 128, 128, 128, 128

	mov	ebp, eax
	xor	ecx, ecx

Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movd		mm1, DWORD PTR [esi]
	punpcklbw	mm1, mm0
	psubw		mm1, mm6
	psllw		mm1, 8

	movq		mm2, mm1
	punpckhdq	mm2, mm2	// Put next sample in low half.
	psubw		mm2, mm1

//	mov	cl, BYTE PTR [esi+2]
//	xor	ebx, ebx
//	sub	ecx, 128
//	mov	bl, BYTE PTR [esi]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

	movd		mm5, ebp
	punpcklwd	mm1, mm1	
	punpcklwd	mm5, mm5	
	psrad		mm1, 16
#ifdef DO_MORE_ACCURATE_VERSION
	movq		mm3, mm2	// Use for high half of multiply.

	pmullw		mm2, mm5	// Low word.
	pmulhw		mm3, mm5	// High word results.

	punpcklwd	mm2, mm3	// Low bits are Left, high are Right.
#else
	pmulhw		mm2, mm5
	punpcklwd	mm2, mm2	// Lower 4 bits are randomized.
#endif
	psrad		mm2, 12
	paddd		mm1, mm2
	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1

//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi]
//	add	ebx, ecx
//	xor	ecx, ecx
//	mov	DWORD PTR [edi], ebx
//	mov	cl, BYTE PTR [esi+3]
//	xor	ebx, ebx
//	sub	ecx, 128
//	mov	bl, BYTE PTR [esi+1]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	add	edi, 8			// plBuild += 2
//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG SampleLNext;
      LONG SampleRNext;
      LONG SampleL;
      LONG SampleR;
          
      SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
      SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
      SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
      SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;

        LONG dwFrac = dwFraction & FRACT_MASK;
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
        dwFraction += dwStep;
        *XplBuild += SampleL;
        *(XplBuild + 1) += SampleR;
        plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge39.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge39 */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE39ASM
BOOL Merge39Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;
#if 1
     if (iters) {
      if (pMixSource->m_fUse_MMX)
      _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*4-4]				// 2 at a time.
	cmp	ebx, 12
        mov	edi, plBuild
	jl	OneSample

	sub	ebx, 4
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 4

OneSample:	
	movsx	ecx, WORD PTR [esi+ebx]
	movsx	edx, WORD PTR [esi+ebx+2]
	add	DWORD PTR [edi+ebx*2], ecx
	add	DWORD PTR [edi+ebx*2+4], edx
	test	ebx, ebx
	je	Done

	sub	ebx, 4
	je	OneSample				// Actually 2 samples

	sub	ebx, 4
DoMMX:
#ifdef GTW_REORDER
	cmp	ebx, 16
	jl	DoMMX00


	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	punpckhwd	mm2, mm1			// First stereo sample
	sub	ebx, 16
	punpcklwd	mm1, mm1			// Second stereo sample
	psrad		mm1, 16
	psrad		mm2, 16

	movq		mm3, QWORD PTR [esi+ebx-8+16]	// Load source
	jmp	DoMMX000
DoMMX0:
	movq		mm3, QWORD PTR [esi+ebx-8+16]	// Load source
	psrad		mm2, 16
DoMMX000:
	paddd		mm1, QWORD PTR [edi+ebx*2+32]
	punpckhwd	mm4, mm3			// First stereo sample

	paddd		mm2, QWORD PTR [edi+ebx*2+8+32]
	punpcklwd	mm3, mm3			// Second stereo sample

	movq		QWORD PTR [edi+ebx*2+32], mm1
	psrad		mm3, 16

	movq		QWORD PTR [edi+ebx*2+8+32], mm2
	psrad		mm4, 16

	movq		mm1, QWORD PTR [esi+ebx-16+16]	// Load source

	paddd		mm3, QWORD PTR [edi+ebx*2-16+32]
	punpckhwd	mm2, mm1			// First stereo sample

	paddd		mm4, QWORD PTR [edi+ebx*2+8-16+32]
	punpcklwd	mm1, mm1			// Second stereo sample

	movq		QWORD PTR [edi+ebx*2-16+32], mm3
	psrad		mm1, 16

	movq		QWORD PTR [edi+ebx*2+8-16+32], mm4
	sub	ebx, 16

	jge	DoMMX0

	psrad		mm2, 16
	paddd		mm1, QWORD PTR [edi+ebx*2+32]
	paddd		mm2, QWORD PTR [edi+ebx*2+8+32]
	movq		QWORD PTR [edi+ebx*2+32], mm1
	movq		QWORD PTR [edi+ebx*2+8+32], mm2

	add		ebx, 8
	jge		DoMMX00

	add		ebx, 4
	je		OneSample
	jmp		Done
	
#endif
DoMMX00:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	punpckhwd	mm2, mm1			// First stereo sample
	punpcklwd	mm1, mm1			// Second stereo sample
	psrad		mm1, 16
	psrad		mm2, 16
	paddd		mm1, QWORD PTR [edi+ebx*2]
	paddd		mm2, QWORD PTR [edi+ebx*2+8]
	movq		QWORD PTR [edi+ebx*2], mm1
	movq		QWORD PTR [edi+ebx*2+8], mm2
	
	sub		ebx, 8
	jge		DoMMX00

	add	ebx, 4
	je	OneSample
	
Done:
	emms
	}
      else
        _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*4-4]
        mov	edi, plBuild
        push	ebp
	mov	ebp, DWORD PTR [esi+ebx]
Lab:
	mov	eax, ebp

	sal	ebp, 16
	mov	ecx, DWORD PTR[edi+ebx*2]

	sar	eax, 16
	mov	edx, DWORD PTR[edi+ebx*2+4]

	sar	ebp, 16
	add	edx, eax

	add	ecx, ebp
	sub	ebx, 4

	mov	DWORD PTR [edi+ebx*2+8], ecx
	mov	ebp, DWORD PTR [esi+ebx]

	mov	DWORD PTR [edi+ebx*2+12], edx
	jge	SHORT Lab

        pop	ebp
      }
    }
#elif 0
    if (iters) {
      _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*4-4]
        mov	edi, plBuild
        push	ebp
	mov	ebp, DWORD PTR [esi+ebx]
Lab:
	mov	eax, ebp

	sal	ebp, 16
	mov	ecx, DWORD PTR[edi+ebx*2]

	sar	eax, 16
	mov	edx, DWORD PTR[edi+ebx*2+4]

	sar	ebp, 16
	add	edx, eax

	add	ecx, ebp
	sub	ebx, 4

	mov	DWORD PTR [edi+ebx*2+8], ecx
	mov	ebp, DWORD PTR [esi+ebx]

	mov	DWORD PTR [edi+ebx*2+12], edx
	jge	SHORT Lab
        pop	ebp
      }
    }
#else
    while(--iters >= 0)
    {
    	LONG SampleR;
	LONG SampleL;
	SampleL = *((SHORT*)(XpSource));
      	SampleR = *(((SHORT*)(XpSource))+1);
        *XplBuild += SampleL;
        *(XplBuild + 1) += SampleR;
    }
#endif
    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }


  *((LONG **)ppSource) = (LONG *)pSource;
  pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\merge96.inc ===
/*
 * Merge96.inc
 *
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 */

/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE96ASM
BOOL Merge96Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#if 1
	if (1 || !pMixSource->m_fUse_MMX)	// Non-MMX is faster.
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	add	esi, ecx		// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
	xor	ecx, ecx
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	mov	cl, BYTE PTR [esi+1]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	mov	ebp, DWORD PTR [edi]
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi+4]
	add	ebp, ecx
	add	ebx, ecx
	mov	DWORD PTR [edi], ebp
	add	edi, 8			// plBuild += 2
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	add	eax, ebp		// dwFraction += dwStep
	mov	ecx, eax
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*1]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	add	esi, ecx		// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
	xor	ecx, ecx
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	mov	cl, BYTE PTR [esi+1]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
//	mov	ebp, DWORD PTR [edi]
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x

	movd		mm1, ecx
	punpckldq	mm1, mm1
	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1
	
//	mov	ebx, DWORD PTR [edi+4]
//	add	ebp, ecx
//	add	ebx, ecx
//	mov	DWORD PTR [edi], ebp
	add	edi, 8			// plBuild += 2
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	add	eax, ebp		// dwFraction += dwStep
	mov	ecx, eax
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*1]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleNext, SampleSave;
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG Sample;
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
      SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
      LONG dwFrac = dwFraction & FRACT_MASK;
      SampleSave = Sample;
      Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      *XplBuild += Sample;
      *(XplBuild + 1) += Sample;
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\mergexxx.inc ===
/*
 * MergeXXX - do a SRC conversion of two 32-bit buffers.
 *
 * Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 */

void
MergeXXX
	(
	PLONG pSrc,
	PLONG pSrcEnd,
	PLONG pDst,
	PLONG pDstEnd,
	DWORD dwFrac
	)
{
#if 0
#ifdef Not_VxD
    DPF(0, "MergeXXX ENT: pDst 0x%08lx pDstEnd 0x%08lx pSrc 0x%08lx pSrcEnd 0x%08lx Frac 0x%08lx", pDst, pDstEnd, pSrc, pSrcEnd, dwFrac);
#else
    DPF(("Merge32 ENT: pDst 0x%08lx pDstEnd 0x%08lx pSrc 0x%08lx pSrcEnd 0x%08lx dwFrac 0x%08lx", pDst, pDstEnd, pSrc, pSrcEnd, dwFrac));
#endif
#endif
   /*	No nested loops, just a simple traversal.
    */
   _asm {
	mov	esi, pSrc
	mov	edi, pDst

	push	dwFrac
	push	pDstEnd
	mov	eax, pSrcEnd
	sub	eax, 8
	push	eax
	push	ebp
	xor	eax, eax		// Fractional counter.
	mov	edx, esi
	mov	ebp, eax		// Current fraction.

	cmp	edi, DWORD PTR [esp+8]	// plBuild >= plBuildEnd
	jae	Exit

Top:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	mov	ecx, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [edi], ebx

	mov	ebx, DWORD PTR [esi+4]
	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+12]	// dwStep
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
	cmp	edi, DWORD PTR [esp+8]	// plBuild < plBuildEnd
	jb	Top
Exit:
	pop	ebp
	add	esp, 12
	mov pDst, edi
	mov pSrc, esi
	}
#if 0
#ifdef Not_VxD
    DPF(0, "MergeXXX EXT: pDst 0x%08lx pDstEnd 0x%08lx pSrc 0x%08lx pSrcEnd 0x%08lx", pDst, pDstEnd, pSrc, pSrcEnd);
#else
    DPF(("Merge32 EXT: pDst 0x%08lx pDstEnd 0x%08lx pSrc 0x%08lx pSrcEnd 0x%08lx", pDst, pDstEnd, pSrc, pSrcEnd));
#endif
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\mergefak.inc ===
/*
 * MergeFak.inc
 *
 * Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 */

BOOL MergeFake
    (long operation,
    CMixSource *pMixSource,
    DWORD nInputByteCount,
    void *pSourceWrap,
    PLONG *pplBuild,
    PLONG plBuildEnd,
    void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  int StepSize;

  StepSize = 1;
  if (operation & H_STEREO)  StepSize *= 2; // Source operands.
  if (operation & H_16_BITS) StepSize *= 2;

  #ifdef XplBuild
  #undef XplBuild
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif

  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * StepSize))

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if ((pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  *((BYTE **)&pSourceWrap) -= StepSize;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
  {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

#if 1
    // Precalc this!
    long x = PtrDiffToLong(plBuildEnd - plBuild)  / 2;     // Max output samples.
    long y = PtrDiffToLong(pSourceEnd - XpSource) / StepSize;  // Max input samples.

//  y <<= 12;
//  y +=  dwStep - 1;           // Round to next item.
//  y  /= dwStep;
    y = (long)((((__int64)y << 12) + (dwStep-1)) / dwStep);
////    y >>= 12;               // Number of input steps.

    if (y > x) {                // More input than output.
        plBuild    += x * 2;
        dwFraction += x * dwStep;
    }
    else {
        plBuild    += y * 2;    // More output positions than input.
        dwFraction += y * dwStep;
    }
    // Note that the above could be used in the real routines...
#else
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      dwFraction += dwStep;
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;       // Eliminate accumulated offsets.
    nInputByteCount -=  PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart) / 2;
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\mergemmx.inc ===
/*
 * MergeMMX - do a SRC conversion of two 32-bit buffers.
 *
 * Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 */

void
MergeMMX
	(
	PLONG pSrc,
	PLONG pSrcEnd,
	PLONG pDst,
	PLONG pDstEnd,
	DWORD dwFrac
	)
{
#if 0
#ifdef Not_VxD
    DPF(0, "MergeXXX ENT: pDst 0x%08lx pDstEnd 0x%08lx pSrc 0x%08lx pSrcEnd 0x%08lx Frac 0x%08lx", pDst, pDstEnd, pSrc, pSrcEnd, dwFrac);
#else
    DPF(("Merge32 ENT: pDst 0x%08lx pDstEnd 0x%08lx pSrc 0x%08lx pSrcEnd 0x%08lx dwFrac 0x%08lx", pDst, pDstEnd, pSrc, pSrcEnd, dwFrac));
#endif
#endif
   /*	No nested loops, just a simple traversal.
    */
   _asm {
	mov	esi, pSrc
	mov	edi, pDst

	push	dwFrac
	push	pDstEnd
	mov	eax, pSrcEnd
	sub	eax, 8
	push	eax
	push	ebp
	xor	eax, eax		// Fractional counter.
	mov	edx, esi
	mov	ebp, eax		// Current fraction.

// Note that the exact number of times through the loop can be calculated...

	cmp	edi, DWORD PTR [esp+8]	// plBuild >= plBuildEnd
	jae	Exit

Top:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

// End note.

	movq		mm1, QWORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

	movq		mm2, QWORD PTR [esi+8]
	movd		mm5, ebp

	psubd		mm2, mm1
	punpcklwd	mm5, mm5

	packssdw	mm2, mm2	// Use the 2 lowest words.
	add	edi, 8			// plBuild += 2

	movq		mm3, mm2
	pmullw		mm2, mm5

	movq		mm6, QWORD PTR [edi-8]
	pmulhw		mm3, mm5

	mov	ebp, DWORD PTR [esp+12]	// dwStep
	paddd		mm1, mm6

	add	eax, ebp		// dwFraction += dwStep
	punpcklwd	mm2, mm3

	mov	ecx, eax
	psrad		mm2, 12

	mov	ebp, eax
	shr	ecx, 12

	paddd		mm1, mm2
	movq		QWORD PTR [edi-8], mm1

	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
	cmp	edi, DWORD PTR [esp+8]	// plBuild < plBuildEnd

	jb	Top
Exit:
	emms
	pop	ebp
	add	esp, 12
	mov pDst, edi
	mov pSrc, esi
	}
#if 0
#ifdef Not_VxD
    DPF(0, "MergeXXX EXT: pDst 0x%08lx pDstEnd 0x%08lx pSrc 0x%08lx pSrcEnd 0x%08lx", pDst, pDstEnd, pSrc, pSrcEnd);
#else
    DPF(("Merge32 EXT: pDst 0x%08lx pDstEnd 0x%08lx pSrc 0x%08lx pSrcEnd 0x%08lx", pDst, pDstEnd, pSrc, pSrcEnd));
#endif
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\misc.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       misc.c
 *  Content:    Miscelaneous utility functions
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/31/96    dereks  Created
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <mediaerr.h>  // For DMO_E_TYPE_NOT_ACCEPTED

// Some error code descriptions used by HresultToString() below
#define REGDB_E_CLASSNOTREG_EXPLANATION     TEXT("Class not registered")
#define DMO_E_TYPE_NOT_ACCEPTED_EXPLANATION TEXT("Wave format not supported by effect")
#define S_FALSE_EXPLANATION                 TEXT("Special success code")


/***************************************************************************
 *
 *  OpenWaveOut
 *
 *  Description:
 *      Opens the waveOut device.
 *
 *  Arguments:
 *      LPHWAVEOUT * [out]: receives pointer to the waveOut device handle.
 *      UINT [in]: device id.
 *      LPWAVEFORMATEX [in]: format in which to open the device.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "OpenWaveOut"

HRESULT OpenWaveOut(LPHWAVEOUT phWaveOut, UINT uDeviceId, LPCWAVEFORMATEX pwfxFormat)
{
    const HANDLE            hProcess        = GetCurrentProcess();
    const HANDLE            hThread         = GetCurrentThread();
    LPHWAVEOUT              phwo            = NULL;
    LPWAVEFORMATEX          pwfx            = NULL;
    BOOL                    fInHelper       = FALSE;
    DWORD                   dwPriorityClass;
    INT                     nPriority;
    HRESULT                 hr;
    MMRESULT                mmr;

    DPF_ENTER();
    CHECK_WRITE_PTR(phWaveOut);
    CHECK_READ_PTR(pwfxFormat);

    // Here's a quick lesson on the Win9X kernel.  If process A and
    // process B look at the memory at address 0x12345678, the data will
    // not be the same.  This is part of the fun of virtual addresses.
    // The only way to get around this is to allocate from a shared heap.
    // In order to make waveOutOpen and waveOutClose work properly from
    // within DDHELP's process space, we can only pass pointers into the
    // shared heap around unless we're actually running in DDHELP's
    // context.  For that reason, this function actually allocates an
    // HWAVEOUT.

    // Another thing to know here is that waveOutOpen doesn't respond well
    // to being called with a process or thread priority higher than normal.

    #ifdef SHARED
    // Are we being called from the helper process?
    if(GetCurrentProcessId() == dwHelperPid)
        fInHelper = TRUE;
    #endif // SHARED

    // Save the current process and thread priorities and reset them to normal
    if(!fInHelper)
    {
        dwPriorityClass = GetPriorityClass(hProcess);
        nPriority = GetThreadPriority(hThread);

        SetPriorityClass(hProcess, NORMAL_PRIORITY_CLASS);
        SetThreadPriority(hThread, THREAD_PRIORITY_NORMAL);
    }

    // Allocate a copy of the waveOut handle
    if(IN_SHARED_MEMORY(phWaveOut))
        phwo = phWaveOut;
    else
        phwo = MEMALLOC(HWAVEOUT);
    hr = HRFROMP(phwo);

    // Allocate a copy of the format
    if(SUCCEEDED(hr))
    {
        if(IN_SHARED_MEMORY(pwfxFormat))
            pwfx = (LPWAVEFORMATEX)pwfxFormat;
        else
            pwfx = CopyWfxAlloc(pwfxFormat);
        hr = HRFROMP(pwfx);
    }

    // Open the waveOut device
    if(SUCCEEDED(hr))
    {
        #ifdef SHARED
        if(!fInHelper)
            mmr = HelperWaveOpen(phwo, uDeviceId, pwfx);
        else
        #endif
            mmr = waveOutOpen(phwo, uDeviceId, pwfx, 0, 0, 0);

        hr = MMRESULTtoHRESULT(mmr);
        DPF(SUCCEEDED(hr) ? DPFLVL_MOREINFO : DPFLVL_ERROR, "waveOutOpen returned %s (%lu)", HRESULTtoSTRING(hr), mmr);
    }

    // Restore the process and thread priorities
    if(!fInHelper)
    {
        SetPriorityClass(hProcess, dwPriorityClass);
        SetThreadPriority(hThread, nPriority);
    }

    // Success
    if(SUCCEEDED(hr))
        *phWaveOut = *phwo;

    if(phwo != phWaveOut)
        MEMFREE(phwo);

    if(pwfx != pwfxFormat)
        MEMFREE(pwfx);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CloseWaveOut
 *
 *  Description:
 *      Closes the waveOut device.
 *
 *  Arguments:
 *      LPHWAVEOUT * [in/out]: waveOut device handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CloseWaveOut"

HRESULT CloseWaveOut(LPHWAVEOUT phWaveOut)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();
    CHECK_WRITE_PTR(phWaveOut);

    if (IsValidHandleValue(*phWaveOut))
    {
        HANDLE      hProcess        = GetCurrentProcess();
        HANDLE      hThread         = GetCurrentThread();
        DWORD       dwPriorityClass = GetPriorityClass(hProcess);
        INT         nPriority       = GetThreadPriority(hThread);
        MMRESULT    mmr;

        // Temporarily reset our process and thread priorities
        SetPriorityClass(hProcess, NORMAL_PRIORITY_CLASS);
        SetThreadPriority(hThread, THREAD_PRIORITY_NORMAL);

        // Close the waveOut device
        #ifdef SHARED
        if(GetCurrentProcessId() != dwHelperPid)
            mmr = HelperWaveClose((DWORD)*phWaveOut);
        else
        #endif
            mmr = waveOutClose(*phWaveOut);
        *phWaveOut = NULL;

        // Restore the process and thread priorities
        SetPriorityClass(hProcess, dwPriorityClass);
        SetThreadPriority(hThread, nPriority);

        hr = MMRESULTtoHRESULT(mmr);
        DPF(SUCCEEDED(hr) ? DPFLVL_MOREINFO : DPFLVL_ERROR, "waveOutClose returned %s (%lu)", HRESULTtoSTRING(hr), mmr);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenWaveIn
 *
 *  Description:
 *      Opens the waveIn device safely (by temporarily lowering our process
 *      and thread priorities during the waveInOpen call)
 *
 *  Arguments:
 *      LPHWAVEIN * [out]: receives pointer to the waveIn device handle.
 *      UINT [in]: device id.
 *      LPWAVEFORMATEX [in]: format in which to open the device.
 *      DWORD_PTR [in]: callback function pointer.
 *      DWORD_PTR [in]: context pointer for the callback function.
 *      DWORD [in]: flags for opening the device
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "OpenWaveIn"

HRESULT OpenWaveIn(LPHWAVEIN phWaveIn, UINT uDeviceId, LPCWAVEFORMATEX pwfxFormat,
                   DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
{
    const HANDLE            hProcess        = GetCurrentProcess();
    const HANDLE            hThread         = GetCurrentThread();
    DWORD                   dwPriorityClass = GetPriorityClass(hProcess);
    INT                     nPriority       = GetThreadPriority(hThread);
    HRESULT                 hr;
    MMRESULT                mmr;

    DPF_ENTER();
    CHECK_READ_PTR(pwfxFormat);

    // Temporarily reset our process and thread priorities
    SetPriorityClass(hProcess, NORMAL_PRIORITY_CLASS);
    SetThreadPriority(hThread, THREAD_PRIORITY_NORMAL);

    // Open the waveIn device
    mmr = waveInOpen(phWaveIn, uDeviceId, pwfxFormat, dwCallback, dwInstance, fdwOpen);
    hr = MMRESULTtoHRESULT(mmr);
    DPF(SUCCEEDED(hr) ? DPFLVL_MOREINFO : DPFLVL_WARNING, "waveInOpen returned %s (%lu)", HRESULTtoSTRING(hr), mmr);

    // Restore the process and thread priorities
    SetPriorityClass(hProcess, dwPriorityClass);
    SetThreadPriority(hThread, nPriority);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CloseWaveIn
 *
 *  Description:
 *      Closes the waveIn device safely.
 *
 *  Arguments:
 *      LPHWAVEIN * [in/out]: waveIn device handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CloseWaveIn"

HRESULT CloseWaveIn(LPHWAVEIN phWaveIn)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();
    CHECK_WRITE_PTR(phWaveIn);

    if (IsValidHandleValue(*phWaveIn))
    {
        HANDLE      hProcess        = GetCurrentProcess();
        HANDLE      hThread         = GetCurrentThread();
        DWORD       dwPriorityClass = GetPriorityClass(hProcess);
        INT         nPriority       = GetThreadPriority(hThread);
        MMRESULT    mmr;

        // Temporarily reset our process and thread priorities
        SetPriorityClass(hProcess, NORMAL_PRIORITY_CLASS);
        SetThreadPriority(hThread, THREAD_PRIORITY_NORMAL);

        // Close the waveIn device
        mmr = waveInClose(*phWaveIn);
        *phWaveIn = 0;

        // Restore the process and thread priorities
        SetPriorityClass(hProcess, dwPriorityClass);
        SetThreadPriority(hThread, nPriority);

        hr = MMRESULTtoHRESULT(mmr);
        DPF(SUCCEEDED(hr) ? DPFLVL_MOREINFO : DPFLVL_ERROR, "waveInClose returned %s (%lu)", HRESULTtoSTRING(hr), mmr);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  MMRESULTtoHRESULT
 *
 *  Description:
 *      Translates an MMRESULT to an HRESULT.
 *
 *  Arguments:
 *      MMRESULT [in]: multimedia result code.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MMRESULTtoHRESULT"

HRESULT MMRESULTtoHRESULT(MMRESULT mmr)
{
    HRESULT                 hr;

    switch(mmr)
    {
        case MMSYSERR_NOERROR:
            hr = DS_OK;
            break;

        case MMSYSERR_BADDEVICEID:
        case MMSYSERR_NODRIVER:
            hr = DSERR_NODRIVER;
            break;

        case MMSYSERR_ALLOCATED:
            hr = DSERR_ALLOCATED;
            break;

        case MMSYSERR_NOMEM:
            hr = DSERR_OUTOFMEMORY;
            break;

        case MMSYSERR_NOTSUPPORTED:
            hr = DSERR_UNSUPPORTED;
            break;

        case WAVERR_BADFORMAT:
            hr = DSERR_BADFORMAT;
            break;

        default:
            DPF(DPFLVL_INFO, "Unexpected MMRESULT code: %ld", mmr);
            hr = DSERR_GENERIC;
            break;
    }

    return hr;
}


/***************************************************************************
 *
 *  WIN32ERRORtoHRESULT
 *
 *  Description:
 *      Translates a Win32 error code to an HRESULT.
 *
 *  Arguments:
 *      DWORD [in]: Win32 error code.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WIN32ERRORtoHRESULT"

HRESULT WIN32ERRORtoHRESULT(DWORD dwError)
{
    HRESULT                 hr;

    switch(dwError)
    {
        case ERROR_SUCCESS:
            hr = DS_OK;
            break;

        case ERROR_INVALID_FUNCTION:
        case ERROR_BAD_COMMAND:
            hr = DSERR_INVALIDCALL;
            break;

        case ERROR_INVALID_DATA:
        case ERROR_INVALID_PARAMETER:
        case ERROR_INSUFFICIENT_BUFFER:
        case ERROR_NOACCESS:
        case ERROR_INVALID_FLAGS:
            hr = DSERR_INVALIDPARAM;
            break;

        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_OUTOFMEMORY:
        case ERROR_NO_SYSTEM_RESOURCES:
        case ERROR_NONPAGED_SYSTEM_RESOURCES:
        case ERROR_PAGED_SYSTEM_RESOURCES:
            hr = DSERR_OUTOFMEMORY;
            break;

        case ERROR_NOT_SUPPORTED:
        case ERROR_CALL_NOT_IMPLEMENTED:
        case ERROR_PROC_NOT_FOUND:
        // These three are often returned by KS filters:
        case ERROR_NOT_FOUND:
        case ERROR_NO_MATCH:
        case ERROR_SET_NOT_FOUND:
            hr = DSERR_UNSUPPORTED;
            break;

        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case ERROR_DLL_NOT_FOUND:
            hr = DSERR_NODRIVER;
            break;

        case ERROR_ACCESS_DENIED:
            hr = DSERR_ACCESSDENIED;
            break;

        default:
            DPF(DPFLVL_INFO, "Unexpected Win32 error code: %ld", dwError);
            hr = DSERR_GENERIC;
            break;
    }

    return hr;
}


/***************************************************************************
 *
 *  GetLastErrorToHRESULT
 *
 *  Description:
 *      Converts the error code returned from GetLastError to an HRESULT.
 *      Note that this function should never be called when success is
 *      assumed.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetLastErrorToHRESULT"

HRESULT GetLastErrorToHRESULT(void)
{
    DWORD                   dwError;
    HRESULT                 hr;

    dwError = GetLastError();

    if(ERROR_SUCCESS == dwError)
    {
        // ASSERT(ERROR_SUCCESS != dwError);
        // This ASSERT has been commented out for years with a cryptic note
        // "Removed for path problem".  Re-instating to see what happens...
        //
        // OK, the path problem we were talking about was a failure with
        // GetFileVersionInfoSize() - when passed a pathname including a
        // nonexistent directory, it fails but doesn't set the last error.

        hr = DSERR_GENERIC;
    }
    else
    {
        hr = WIN32ERRORtoHRESULT(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  AnsiToAnsi
 *
 *  Description:
 *      Converts an ANSI string to ANSI.
 *
 *  Arguments:
 *      LPCSTR [in]: source string.
 *      LPSTR [out]: destination string.
 *      DWORD [in]: size of destination string, in characters.
 *
 *  Returns:
 *      DWORD: required size of destination string buffer, in characters.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AnsiToAnsi"

DWORD AnsiToAnsi(LPCSTR pszSource, LPSTR pszDest, DWORD ccDest)
{
    if(pszDest && ccDest)
    {
        lstrcpynA(pszDest, pszSource, ccDest);
    }

    return lstrlenA(pszSource) + 1;
}


/***************************************************************************
 *
 *  AnsiToUnicode
 *
 *  Description:
 *      Converts an ANSI string to Unicode.
 *
 *  Arguments:
 *      LPCSTR [in]: source string.
 *      LPWSTR [out]: destination string.
 *      DWORD [in]: size of destination string, in characters.
 *
 *  Returns:
 *      DWORD: required size of destination string buffer, in characters.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AnsiToUnicode"

DWORD AnsiToUnicode(LPCSTR pszSource, LPWSTR pszDest, DWORD ccDest)
{
    if(!pszDest)
    {
        ccDest = 0;
    }
    else if(!ccDest)
    {
        pszDest = NULL;
    }

    return MultiByteToWideChar(CP_ACP, 0, pszSource, -1, pszDest, ccDest);
}


/***************************************************************************
 *
 *  UnicodeToAnsi
 *
 *  Description:
 *      Converts a Unicode string to ANSI.
 *
 *  Arguments:
 *      LPCWSTR [in]: source string.
 *      LPSTR [out]: destination string.
 *      DWORD [in]: size of destination string, in characters.
 *
 *  Returns:
 *      DWORD: required size of destination string buffer, in characters.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "UnicodeToAnsi"

DWORD UnicodeToAnsi(LPCWSTR pszSource, LPSTR pszDest, DWORD ccDest)
{
    if(!pszDest)
    {
        ccDest = 0;
    }
    else if(!ccDest)
    {
        pszDest = NULL;
    }

    return WideCharToMultiByte(CP_ACP, 0, pszSource, -1, pszDest, ccDest, NULL, NULL);
}


/***************************************************************************
 *
 *  UnicodeToUnicode
 *
 *  Description:
 *      Converts a Unicode string to Unicode.
 *
 *  Arguments:
 *      LPCWSTR [in]: source string.
 *      LPWSTR [out]: destination string.
 *      DWORD [in]: size of destination string, in characters.
 *
 *  Returns:
 *      DWORD: required size of destination string buffer, in characters.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "UnicodeToUnicode"

DWORD UnicodeToUnicode(LPCWSTR pszSource, LPWSTR pszDest, DWORD ccDest)
{
    if(pszDest && ccDest)
    {
        lstrcpynW(pszDest, pszSource, ccDest);
    }

    return lstrlenW(pszSource) + 1;
}


/***************************************************************************
 *
 *  AnsiToAnsiAlloc
 *
 *  Description:
 *      Converts an ANSI string to ANSI.  Use MemFree to free the
 *      returned string.
 *
 *  Arguments:
 *      LPCSTR [in]: source string.
 *
 *  Returns:
 *      LPSTR: destination string.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AnsiToAnsiAlloc"

LPSTR AnsiToAnsiAlloc(LPCSTR pszSource)
{
    LPSTR                   pszDest;
    DWORD                   ccDest;

    ccDest = AnsiToAnsi(pszSource, NULL, 0);
    pszDest = MEMALLOC_A(CHAR, ccDest);

    if(pszDest)
    {
        AnsiToAnsi(pszSource, pszDest, ccDest);
    }

    return pszDest;
}


/***************************************************************************
 *
 *  AnsiToUnicodeAlloc
 *
 *  Description:
 *      Converts an ANSI string to Unicode.  Use MemFree to free the
 *      returned string.
 *
 *  Arguments:
 *      LPCSTR [in]: source string.
 *
 *  Returns:
 *      LPWSTR: destination string.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AnsiToUnicodeAlloc"

LPWSTR AnsiToUnicodeAlloc(LPCSTR pszSource)
{
    LPWSTR                  pszDest;
    DWORD                   ccDest;

    ccDest = AnsiToUnicode(pszSource, NULL, 0);
    pszDest = MEMALLOC_A(WCHAR, ccDest);

    if(pszDest)
    {
        AnsiToUnicode(pszSource, pszDest, ccDest);
    }

    return pszDest;
}


/***************************************************************************
 *
 *  UnicodeToAnsiAlloc
 *
 *  Description:
 *      Converts a Unicode string to ANSI.  Use MemFree to free the
 *      returned string.
 *
 *  Arguments:
 *      LPCWSTR [in]: source string.
 *
 *  Returns:
 *      LPSTR: destination string.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "UnicodeToAnsiAlloc"

LPSTR UnicodeToAnsiAlloc(LPCWSTR pszSource)
{
    LPSTR                   pszDest;
    DWORD                   ccDest;

    ccDest = UnicodeToAnsi(pszSource, NULL, 0);
    pszDest = MEMALLOC_A(CHAR, ccDest);

    if(pszDest)
    {
        UnicodeToAnsi(pszSource, pszDest, ccDest);
    }

    return pszDest;
}


/***************************************************************************
 *
 *  UnicodeToUnicodeAlloc
 *
 *  Description:
 *      Converts a Unicode string to Unicode.  Use MemFree to free the
 *      returned string.
 *
 *  Arguments:
 *      LPCWSTR [in]: source string.
 *
 *  Returns:
 *      LPWSTR: destination string.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "UnicodeToUnicodeAlloc"

LPWSTR UnicodeToUnicodeAlloc(LPCWSTR pszSource)
{
    LPWSTR                  pszDest;
    DWORD                   ccDest;

    ccDest = UnicodeToUnicode(pszSource, NULL, 0);
    pszDest = MEMALLOC_A(WCHAR, ccDest);

    if(pszDest)
    {
        UnicodeToUnicode(pszSource, pszDest, ccDest);
    }

    return pszDest;
}


/***************************************************************************
 *
 *  GetRootParentWindow
 *
 *  Description:
 *      Retrieves the topmost unowned window in a family.
 *
 *  Arguments:
 *      HWND [in]: window handle who's parent we're looking for.
 *
 *  Returns:
 *      HWND: topmost unowned window in the family.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetRootParentWindow"

HWND GetRootParentWindow(HWND hWnd)
{
    HWND                hWndParent;

    while(hWndParent = GetParent(hWnd))
    {
        hWnd = hWndParent;
    }

    return hWnd;
}


/***************************************************************************
 *
 *  GetForegroundApplication
 *
 *  Description:
 *      Finds the window handle for the application that currently has
 *      focus.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HWND: Window handle of the app in focus.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetForegroundApplication"

HWND GetForegroundApplication(void)
{
    HWND                    hWnd;

    hWnd = GetForegroundWindow();

    if(hWnd)
    {
        hWnd = GetRootParentWindow(hWnd);
    }

    return hWnd;
}


/***************************************************************************
 *
 *  GetWindowState
 *
 *  Description:
 *      Retrieves the show state of the given window.
 *
 *  Arguments:
 *      HWND [in]: window in question.
 *
 *  Returns:
 *      UINT: show state of the window.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetWindowState"

UINT GetWindowState(HWND hWnd)
{
    UINT                    uState  = SW_NOSTATE;
    WINDOWPLACEMENT         wp;

    wp.length = sizeof(wp);

    if(IsWindow(hWnd) && GetWindowPlacement(hWnd, &wp))
    {
        uState = wp.showCmd;
    }

    return uState;
}


/***************************************************************************
 *
 *  FillPcmWfx
 *
 *  Description:
 *      Fills a WAVEFORMATEX structure, given only the necessary values.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: structure to fill.
 *      WORD [in]: number of channels.
 *      DWORD [in]: samples per second.
 *      WORD [in]: bits per sample.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FillPcmWfx"

void FillPcmWfx(LPWAVEFORMATEX pwfx, WORD wChannels, DWORD dwSamplesPerSec, WORD wBitsPerSample)
{
    DPF_ENTER();

    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = BETWEEN(wChannels, 1, 2);
    pwfx->nSamplesPerSec = BETWEEN(dwSamplesPerSec, DSBFREQUENCY_MIN, DSBFREQUENCY_MAX);

    if(wBitsPerSample < 12)
    {
        pwfx->wBitsPerSample = 8;
    }
    else
    {
        pwfx->wBitsPerSample = 16;
    }

    pwfx->nBlockAlign = pwfx->nChannels * pwfx->wBitsPerSample / 8;
    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;
    pwfx->cbSize = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  AllocPcmWfx
 *
 *  Description:
 *      Allocates and fills a WAVEFORMATEX structure, given only the
 *      necessary values.
 *
 *  Arguments:
 *      WORD [in]: number of channels.
 *      DWORD [in]: samples per second.
 *      WORD [in]: bits per sample.
 *
 *  Returns:
 *      LPWAVEFORMATEX: pointer to the format.  The caller is responsible
 *                      for freeing this buffer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AllocPcmWfx"

LPWAVEFORMATEX AllocPcmWfx(WORD wChannels, DWORD dwSamplesPerSec, WORD wBitsPerSample)
{
    LPWAVEFORMATEX          pwfx;

    DPF_ENTER();

    pwfx = MEMALLOC(WAVEFORMATEX);

    if(pwfx)
    {
        FillPcmWfx(pwfx, wChannels, dwSamplesPerSec, wBitsPerSample);
    }

    DPF_LEAVE(pwfx);

    return pwfx;
}


/***************************************************************************
 *
 *  GetWfxSize
 *
 *  Description:
 *      Gets the size of a WAVEFORMATEX structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: source.
 *      DWORD [in]: access rights.
 *
 *  Returns:
 *      DWORD: size of the above structure.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetWfxSize"

DWORD GetWfxSize(LPCWAVEFORMATEX pwfxSrc, DWORD dwAccess)
{
    DWORD                   dwSize;

    DPF_ENTER();

    ASSERT(LXOR(GENERIC_READ == dwAccess, GENERIC_WRITE == dwAccess));

    if(WAVE_FORMAT_PCM == pwfxSrc->wFormatTag)
    {
        if(GENERIC_READ == dwAccess)
        {
            dwSize = sizeof(PCMWAVEFORMAT);
        }
        else
        {
            dwSize = sizeof(WAVEFORMATEX);
        }
    }
    else
    {
        dwSize = sizeof(WAVEFORMATEX) + pwfxSrc->cbSize;
    }

    DPF_LEAVE(dwSize);

    return dwSize;
}


/***************************************************************************
 *
 *  CopyWfx
 *
 *  Description:
 *      Makes a copy of a WAVEFORMATEX structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: source.
 *      LPWAVEFORMATEX [out]: dest.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CopyWfx"

void CopyWfx(LPCWAVEFORMATEX pwfxSrc, LPWAVEFORMATEX pwfxDest)
{
    DWORD                   cbSrc;
    DWORD                   cbDest;

    DPF_ENTER();

    cbSrc = GetWfxSize(pwfxSrc, GENERIC_READ);
    cbDest = GetWfxSize(pwfxSrc, GENERIC_WRITE);

    CopyMemory(pwfxDest, pwfxSrc, cbSrc);
    ZeroMemoryOffset(pwfxDest, cbDest, cbSrc);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CopyWfxAlloc
 *
 *  Description:
 *      Makes a copy of a WAVEFORMATEX structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: source.
 *
 *  Returns:
 *      LPWAVEFORMATEX: destination.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CopyWfxAlloc"

LPWAVEFORMATEX CopyWfxAlloc(LPCWAVEFORMATEX pwfxSrc)
{
    LPWAVEFORMATEX          pwfxDest;
    DWORD                   cbSrc;
    DWORD                   cbDest;

    DPF_ENTER();

    cbSrc = GetWfxSize(pwfxSrc, GENERIC_READ);
    cbDest = GetWfxSize(pwfxSrc, GENERIC_WRITE);

    pwfxDest = (LPWAVEFORMATEX)MEMALLOC_A(BYTE, cbDest);

    if(pwfxDest)
    {
        CopyMemory(pwfxDest, pwfxSrc, cbSrc);
        ZeroMemoryOffset(pwfxDest, cbDest, cbSrc);
    }

    DPF_LEAVE(pwfxDest);

    return pwfxDest;
}


/***************************************************************************
 *
 *  CopyDSCFXDescAlloc
 *
 *  Description:
 *      Makes a copy of a WAVEFORMATEX structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: source.
 *
 *  Returns:
 *      LPWAVEFORMATEX: destination.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CopyDSCFXDescAlloc"

LPDSCEFFECTDESC CopyDSCFXDescAlloc
(
    DWORD           dwFXCount,
    LPDSCEFFECTDESC pDSCFXDesc
)
{
    LPDSCEFFECTDESC         lpDSCFXDesc;

    DPF_ENTER();

    lpDSCFXDesc = (LPDSCEFFECTDESC)MEMALLOC_A(BYTE, dwFXCount*sizeof(DSCEFFECTDESC));

    if(lpDSCFXDesc)
    {
        CopyMemory(lpDSCFXDesc, pDSCFXDesc, dwFXCount*sizeof(DSCEFFECTDESC));
    }

    DPF_LEAVE(lpDSCFXDesc);

    return lpDSCFXDesc;
}


/***************************************************************************
 *
 *  CopyWfxApi
 *
 *  Description:
 *      Copies one WAVEFORMATEX to another.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: source format.
 *      LPWAVEFORMATEX [out]: destination format.
 *      LPDWORD [in/out]: destination format size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CopyWfxApi"

HRESULT CopyWfxApi(LPCWAVEFORMATEX pwfxSource, LPWAVEFORMATEX pwfxDest, LPDWORD pdwSize)
{
    const DWORD             dwEntrySize = *pdwSize;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    *pdwSize = GetWfxSize(pwfxSource, GENERIC_WRITE);

    if(*pdwSize > dwEntrySize && pwfxDest)
    {
        RPF(DPFLVL_ERROR, "Buffer too small");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pwfxDest)
    {
        CopyWfx(pwfxSource, pwfxDest);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CmpWfx
 *
 *  Description:
 *      Compares two WAVEFORMATEX structures.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format 1.
 *      LPCWAVEFORMATEX [in]: format 2.
 *
 *  Returns:
 *      BOOL: TRUE if they are identical.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CmpWfx"

BOOL CmpWfx(LPCWAVEFORMATEX pwfx1, LPCWAVEFORMATEX pwfx2)
{
    BOOL                    fCmp    = TRUE;
    DWORD                   dwSize1;
    DWORD                   dwSize2;

    DPF_ENTER();

    dwSize1 = GetWfxSize(pwfx1, GENERIC_READ);
    dwSize2 = GetWfxSize(pwfx2, GENERIC_READ);

    if(dwSize1 != dwSize2)
    {
        fCmp = FALSE;
    }

    if(fCmp)
    {
        fCmp = CompareMemory(pwfx1, pwfx2, dwSize1);
    }

    DPF_LEAVE(fCmp);

    return fCmp;
}


/***************************************************************************
 *
 *  VolumePanToAttenuation
 *
 *  Description:
 *      Calculates channel attenuation based on volume and pan.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      LONG [in]: pan.
 *      LPLONG [out]: receives left attenuation.
 *      LPLONG [out]: receives right attenuation.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "VolumePanToAttenuation"

void VolumePanToAttenuation(LONG lVolume, LONG lPan, LPLONG plLeft, LPLONG plRight)
{
    LONG                    lLeft;
    LONG                    lRight;

    DPF_ENTER();

    if(lPan >= 0)
    {
        lLeft = lVolume - lPan;
        lRight = lVolume;
    }
    else
    {
        lLeft = lVolume;
        lRight = lVolume + lPan;
    }

    if(plLeft)
    {
        *plLeft = lLeft;
    }

    if(plRight)
    {
        *plRight = lRight;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  AttenuationToVolumePan
 *
 *  Description:
 *      Calculates volume and pan based on channel attenuation.
 *
 *  Arguments:
 *      LONG [in]: left attenuation.
 *      LONG [in]: right attenuation.
 *      LPLONG [out]: receives volume.
 *      LPLONG [out]: receives pan.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AttenuationToVolumePan"

void AttenuationToVolumePan(LONG lLeft, LONG lRight, LPLONG plVolume, LPLONG plPan)
{
    LONG                    lVolume;
    LONG                    lPan;

    DPF_ENTER();

    if(lLeft >= lRight)
    {
        lVolume = lLeft;
        lPan = lRight - lVolume;
    }
    else
    {
        lVolume = lRight;
        lPan = lVolume - lLeft;
    }

    if(plVolume)
    {
        *plVolume = lVolume;
    }

    if(plPan)
    {
        *plPan = lPan;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  MultiChannelToStereoPan
 *
 *  Description:
 *      Calculates volume and pan based on channel attenuation.
 *
 *  Arguments:
 *      DWORD [in]: number of channels in following two arrays.
 *      const DWORD* [in]: speaker position codes for each channel.
 *      const LONG* [in]: DSBVOLUME levels for each channel.
 *
 *  Returns:
 *      LONG: pan value calculated.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MultiChannelToStereoPan"

LONG MultiChannelToStereoPan(DWORD dwChannelCount, const DWORD* pdwChannels, const LONG* plChannelVolumes)
{
    LONG lPan = 0;
    DWORD i;

    DPF_ENTER();
    ASSERT(dwChannelCount && pdwChannels && plChannelVolumes);

    for (i=0; i<dwChannelCount; ++i)
    {
        switch (pdwChannels[i])
        {
            case SPEAKER_FRONT_LEFT:
            case SPEAKER_BACK_LEFT:
            case SPEAKER_FRONT_LEFT_OF_CENTER:
            case SPEAKER_SIDE_LEFT:
            case SPEAKER_TOP_FRONT_LEFT:
            case SPEAKER_TOP_BACK_LEFT:
                --lPan;
                break;

            case SPEAKER_FRONT_RIGHT:
            case SPEAKER_BACK_RIGHT:
            case SPEAKER_FRONT_RIGHT_OF_CENTER:
            case SPEAKER_SIDE_RIGHT:
            case SPEAKER_TOP_FRONT_RIGHT:
            case SPEAKER_TOP_BACK_RIGHT:
                ++lPan;
                break;
        }
    }

    lPan = (lPan * DSBPAN_RIGHT) / dwChannelCount;
    ASSERT(DSBPAN_LEFT <= lPan && lPan <= DSBPAN_RIGHT);
    // FIXME - this hack isn't acoustically correct

    DPF_LEAVE(lPan);
    return lPan;
}


/***************************************************************************
 *
 *  FillDsVolumePan
 *
 *  Description:
 *      Fills a DSVOLUMEPAN structure based on volume and pan dB values.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      LONG [in]: pan.
 *      PDSVOLUMEPAN [out]: receives calculated volume and pan.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FillDsVolumePan"

void FillDsVolumePan(LONG lVolume, LONG lPan, PDSVOLUMEPAN pdsvp)
{
    LONG                    lLeft;
    LONG                    lRight;

    DPF_ENTER();

    lVolume = BETWEEN(lVolume, DSBVOLUME_MIN, DSBVOLUME_MAX);
    lPan = BETWEEN(lPan, DSBPAN_LEFT, DSBPAN_RIGHT);

    VolumePanToAttenuation(lVolume, lPan, &lLeft, &lRight);

    pdsvp->lVolume = lVolume;
    pdsvp->lPan = lPan;

    pdsvp->dwTotalLeftAmpFactor = DBToAmpFactor(lLeft);
    pdsvp->dwTotalRightAmpFactor = DBToAmpFactor(lRight);

    pdsvp->dwVolAmpFactor = DBToAmpFactor(pdsvp->lVolume);

    if(pdsvp->lPan >= 0)
    {
        pdsvp->dwPanLeftAmpFactor = DBToAmpFactor(-pdsvp->lPan);
        pdsvp->dwPanRightAmpFactor = DBToAmpFactor(0);
    }
    else
    {
        pdsvp->dwPanLeftAmpFactor = DBToAmpFactor(0);
        pdsvp->dwPanRightAmpFactor = DBToAmpFactor(pdsvp->lPan);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CountBits
 *
 *  Description:
 *      Counts the numbers of bits set to 1 in a DWORD.
 *
 *  Arguments:
 *      DWORD [in]: a DWORD.
 *
 *  Returns:
 *      int: number of bits set in the DWORD.
 *
 ***************************************************************************/

int CountBits(DWORD dword)
{
    int bitCount = 0;

    if (dword)
        do ++bitCount;
        while (dword &= (dword-1));

    return bitCount;
}


/***************************************************************************
 *
 *  HighestBit
 *
 *  Description:
 *      Finds the highest set bit in a DWORD.
 *
 *  Arguments:
 *      DWORD [in]: a DWORD.
 *
 *  Returns:
 *      int: highest bit set in the DWORD.
 *
 ***************************************************************************/

int HighestBit(DWORD dword)
{
    int highestBit = 0;

    if (dword)
        do ++highestBit;
        while (dword >>= 1);

    return highestBit;
}


/***************************************************************************
 *
 *  GetAlignedBufferSize
 *
 *  Description:
 *      Returns a properly aligned buffer size.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format of the buffer.
 *      DWORD [in]: buffer size.
 *
 *  Returns:
 *      DWORD: buffer size.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetAlignedBufferSize"

DWORD GetAlignedBufferSize(LPCWAVEFORMATEX pwfx, DWORD dwSize)
{
    DWORD dwAlignError=0;

    DPF_ENTER();

    if (pwfx->nBlockAlign != 0) // Otherwise we get a divide-by-0 below
    {
        dwAlignError = dwSize % pwfx->nBlockAlign;
    }

    if(dwAlignError)
    {
        RPF(DPFLVL_WARNING, "Buffer size misaligned by %lu bytes", dwAlignError);
        dwSize += pwfx->nBlockAlign - dwAlignError;
    }

    DPF_LEAVE(dwSize);

    return dwSize;
}


/***************************************************************************
 *
 *  FillSilence
 *
 *  Description:
 *      Fills a buffer with silence.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the buffer.
 *      DWORD [in]: sizer of above buffer.
 *      WORD [in]: bits per sample - determines the silence level
 *                 (0x80 for 8-bit data, 0x0 for 16-bit data)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FillSilence"

void FillSilence(LPVOID pvBuffer, DWORD cbBuffer, WORD wBitsPerSample)
{
    DPF_ENTER();

    FillMemory(pvBuffer, cbBuffer, (BYTE)((8 == wBitsPerSample) ? 0x80 : 0));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  FillNoise
 *
 *  Description:
 *      Fills a buffer with white noise.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the buffer.
 *      DWORD [in]: size of above buffer.
 *      WORD [in]: bits per sample - determines the silence level
 *                 (0x80 for 8-bit data, 0x0 for 16-bit data)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FillNoise"

void FillNoise(LPVOID pvBuffer, DWORD dwSize, WORD wBitsPerSample)
{
    LPBYTE                  pb      = (LPBYTE)pvBuffer;
    DWORD                   dwRand  = 0;

    DPF_ENTER();

    while(dwSize--)
    {
        dwRand *= 214013;
        dwRand += 2531011;

        *pb = (BYTE)((dwRand >> 24) & 0x0000003F);
        if (wBitsPerSample == 8)
            *pb = *pb + 0x60;  // So we end up with a range of 0x60 to 0x9F
        else
            *pb = *pb - 0x20;  // Range of -0x2020 to 0x1F1F
        ++pb;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  InterruptSystemEventCallback
 *
 *  Description:
 *      Stops any currently playing system event.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: device format.
 *      LPVOID [in]: context argument.
 *
 *  Returns:
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "InterruptSystemEventCallback"

BOOL CALLBACK InterruptSystemEventCallback(LPCWAVEFORMATEX pwfx, LPVOID pvContext)
{
    HWAVEOUT                hwo;
    HRESULT                 hr;

    DPF_ENTER();

    // The easiest (best? only?) way to cancel a system event is to open
    // waveOut.  So, we'll just open it and close it.  Let's use a really
    // simple format that every card should support...
    hr = OpenWaveOut(&hwo, *(LPUINT)pvContext, pwfx);

    if(SUCCEEDED(hr))
        CloseWaveOut(&hwo);

    DPF_LEAVE(FAILED(hr));
    return FAILED(hr);
}


/***************************************************************************
 *
 *  InterruptSystemEvent
 *
 *  Description:
 *      Stops any currently playing system event.
 *
 *  Arguments:
 *      UINT [in]: waveOut device id, or WAVE_DEVICEID_NONE.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "InterruptSystemEvent"

void InterruptSystemEvent(UINT uDeviceId)
{
    DPF_ENTER();

    // The easiest (best? only?) way to cancel a system event is to open
    // waveOut.  So, we'll just open it and close it.
    EnumStandardFormats(NULL, NULL, InterruptSystemEventCallback, &uDeviceId);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumStandardFormats
 *
 *  Description:
 *      Finds the next closest useable format for the given output device.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: preferred format.
 *      LPWAVEFORMATEX [out]: receives next best format.
 *      LPFNEMUMSTDFMTCALLBACK [in]: callback function.
 *      LPVOID [in]: context argument passed directly to callback function.
 *
 *  Returns:
 *      BOOL: TRUE if the callback function returned FALSE, indicating a
 *            format was selected.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "EnumStandardFormats"

BOOL EnumStandardFormats(LPCWAVEFORMATEX pwfxPreferred, LPWAVEFORMATEX pwfxFormat, LPFNEMUMSTDFMTCALLBACK pfnCallback, LPVOID pvContext)
{
    const WORD              aChannels[]         = { 1, 2 };
    const DWORD             aSamplesPerSec[]    = { 8000, 11025, 22050, 44100, 48000 };
    const WORD              aBitsPerSample[]    = { 8, 16 };
    BOOL                    fContinue           = TRUE;
    BOOL                    fExactMatch         = FALSE;
    UINT                    iChannels           = 0;
    UINT                    iSamplesPerSec      = 0;
    UINT                    iBitsPerSample      = 0;
    BOOL                    fPcmFormat          = TRUE;
    UINT                    cChannels;
    UINT                    cSamplesPerSec;
    UINT                    cBitsPerSample;
    WAVEFORMATEX            wfx;

    DPF_ENTER();

    // Try the preferred format first
    if(pwfxPreferred)
    {
        fPcmFormat = IsValidPcmWfx(pwfxPreferred);

        DPF(DPFLVL_INFO, "Trying %u channels, %lu Hz, %u-bit (preferred)...", pwfxPreferred->nChannels, pwfxPreferred->nSamplesPerSec, pwfxPreferred->wBitsPerSample);
        fContinue = pfnCallback(pwfxPreferred, pvContext);
    }

    // Did the preferred format work?
    if(fContinue && pwfxPreferred && fPcmFormat)
    {
        // Find the preferred format in our list of standard formats
        for(iChannels = 0; iChannels < NUMELMS(aChannels) - 1; iChannels++)
        {
            if(pwfxPreferred->nChannels >= aChannels[iChannels] && pwfxPreferred->nChannels < aChannels[iChannels + 1])
            {
                break;
            }
        }

        for(iSamplesPerSec = 0; iSamplesPerSec < NUMELMS(aSamplesPerSec) - 1; iSamplesPerSec++)
        {
            if(pwfxPreferred->nSamplesPerSec >= aSamplesPerSec[iSamplesPerSec] && pwfxPreferred->nSamplesPerSec < aSamplesPerSec[iSamplesPerSec + 1])
            {
                break;
            }
        }

        for(iBitsPerSample = 0; iBitsPerSample < NUMELMS(aBitsPerSample) - 1; iBitsPerSample++)
        {
            if(pwfxPreferred->wBitsPerSample >= aBitsPerSample[iBitsPerSample] && pwfxPreferred->wBitsPerSample < aBitsPerSample[iBitsPerSample + 1])
            {
                break;
            }
        }

        // Does the preferred format match a standard format exactly?
        if(pwfxPreferred->nChannels == aChannels[iChannels])
        {
            if(pwfxPreferred->nSamplesPerSec == aSamplesPerSec[iSamplesPerSec])
            {
                if(pwfxPreferred->wBitsPerSample == aBitsPerSample[iBitsPerSample])
                {
                    fExactMatch = TRUE;
                }
            }
        }
    }

    // Loop through each standard format looking for one that works
    if(fContinue && fPcmFormat)
    {
        pwfxPreferred = &wfx;

        for(cChannels = NUMELMS(aChannels); fContinue && cChannels; cChannels--, INC_WRAP(iChannels, NUMELMS(aChannels)))
        {
            for(cSamplesPerSec = NUMELMS(aSamplesPerSec); fContinue && cSamplesPerSec; cSamplesPerSec--, INC_WRAP(iSamplesPerSec, NUMELMS(aSamplesPerSec)))
            {
                for(cBitsPerSample = NUMELMS(aBitsPerSample); fContinue && cBitsPerSample; cBitsPerSample--, INC_WRAP(iBitsPerSample, NUMELMS(aBitsPerSample)))
                {
                    // Let's not try the preferred format twice
                    if(fExactMatch)
                    {
                        fExactMatch = FALSE;
                        continue;
                    }

                    FillPcmWfx(&wfx, aChannels[iChannels], aSamplesPerSec[iSamplesPerSec], aBitsPerSample[iBitsPerSample]);

                    DPF(DPFLVL_INFO, "Trying %u channels, %lu Hz, %u-bit (standard)...", wfx.nChannels, wfx.nSamplesPerSec, wfx.wBitsPerSample);
                    fContinue = pfnCallback(&wfx, pvContext);
                }
            }
        }
    }

    if(!fContinue)
    {
        DPF(DPFLVL_INFO, "Whaddaya know?  It worked!");

        if(pwfxFormat)
        {
            CopyWfx(pwfxPreferred, pwfxFormat);
        }
    }

    DPF_LEAVE(!fContinue);

    return !fContinue;
}


/***************************************************************************
 *
 *  GetWaveOutVolume
 *
 *  Description:
 *      Gets attenuation for a waveOut device
 *
 *  Arguments:
 *      UINT [in]: device id.
 *      DWORD [in]: WAVEOUTCAPS support flags.
 *      LPLONG [out]: receives left-channel attenuation.
 *      LPLONG [out]: receives right-channel attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetWaveOutVolume"

HRESULT GetWaveOutVolume(UINT uDeviceId, DWORD dwSupport, LPLONG plLeft, LPLONG plRight)
{
    DWORD                   dwVolume    = MAX_DWORD;
    HRESULT                 hr          = DS_OK;
    MMRESULT                mmr;

    DPF_ENTER();

    if(WAVE_DEVICEID_NONE != uDeviceId && dwSupport & WAVECAPS_VOLUME)
    {
        mmr = waveOutGetVolume((HWAVEOUT)IntToPtr(uDeviceId), &dwVolume);
        hr = MMRESULTtoHRESULT(mmr);

        if(SUCCEEDED(hr) && !(dwSupport & WAVECAPS_LRVOLUME))
        {
            dwVolume = MAKELONG(LOWORD(dwVolume), LOWORD(dwVolume));
        }
    }

    if(SUCCEEDED(hr) && plLeft)
    {
        *plLeft = AmpFactorToDB(LOWORD(dwVolume));
    }

    if(SUCCEEDED(hr) && plRight)
    {
        *plRight = AmpFactorToDB(HIWORD(dwVolume));
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetWaveOutVolume
 *
 *  Description:
 *      Sets attenuation on a waveOut device
 *
 *  Arguments:
 *      UINT [in]: device id.
 *      DWORD [in]: WAVEOUTCAPS support flags.
 *      LONG [in]: left-channel attenuation.
 *      LONG [in]: right-channel attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "SetWaveOutVolume"

HRESULT SetWaveOutVolume(UINT uDeviceId, DWORD dwSupport, LONG lLeft, LONG lRight)
{
    HRESULT                 hr  = DS_OK;
    MMRESULT                mmr;

    DPF_ENTER();

    if(WAVE_DEVICEID_NONE != uDeviceId && dwSupport & WAVECAPS_VOLUME)
    {
        if(!(dwSupport & WAVECAPS_LRVOLUME))
        {
            lLeft += lRight;
            lLeft /= 2;
            lRight = lLeft;
        }

        mmr = waveOutSetVolume((HWAVEOUT)IntToPtr(uDeviceId), MAKELONG(DBToAmpFactor(lLeft), DBToAmpFactor(lRight)));
        hr = MMRESULTtoHRESULT(mmr);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  HRESULTtoSTRING
 *
 *  Description:
 *      Translates a DirectSound error code to a string value.
 *
 *  Arguments:
 *      HRESULT [in]: result code.
 *
 *  Returns:
 *      LPCSTR: string representation.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "HRESULTtoSTRING"

LPCTSTR HRESULTtoSTRING(HRESULT hr)
{
    static TCHAR            szResult[0x100];

    HresultToString(hr, szResult, NUMELMS(szResult), NULL, 0);

    return szResult;
}


/***************************************************************************
 *
 *  HresultToString
 *
 *  Description:
 *      Translates a DirectSound error code to a string value.
 *
 *  Arguments:
 *      HRESULT [in]: result code.
 *      LPCSTR [out]: string form of result code buffer.
 *      UINT [in]: size of above buffer, in characters.
 *      LPCSTR [out]: result code explanation.
 *      UINT [in]: size of above buffer, in characters.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "HresultToString"

void HresultToString(HRESULT hr, LPTSTR pszString, UINT ccString, LPTSTR pszExplanation, UINT ccExplanation)
{
    if(SUCCEEDED(hr) && S_OK != hr && S_FALSE != hr && DS_NO_VIRTUALIZATION != hr && DS_INCOMPLETE != hr)
    {
        DPF(DPFLVL_WARNING, "Unknown successful return code 0x%8.8lX", hr);
    }

#define CASE_HRESULT_LOOKUP(a) \
            case a: \
                if(pszString && ccString) lstrcpyn(pszString, TEXT(#a), ccString); \
                if(pszExplanation && ccExplanation) lstrcpyn(pszExplanation, a##_EXPLANATION, ccExplanation); \
                break;

    switch(hr)
    {
        CASE_HRESULT_LOOKUP(DS_OK);
        CASE_HRESULT_LOOKUP(S_FALSE);
        CASE_HRESULT_LOOKUP(DS_NO_VIRTUALIZATION);
        CASE_HRESULT_LOOKUP(DS_INCOMPLETE);
        CASE_HRESULT_LOOKUP(DSERR_ALLOCATED);
        CASE_HRESULT_LOOKUP(DSERR_CANTLOCKPLAYCURSOR);
        CASE_HRESULT_LOOKUP(DSERR_CONTROLUNAVAIL);
        CASE_HRESULT_LOOKUP(DSERR_INVALIDPARAM);
        CASE_HRESULT_LOOKUP(DSERR_INVALIDCALL);
        CASE_HRESULT_LOOKUP(DSERR_GENERIC);
        CASE_HRESULT_LOOKUP(DSERR_PRIOLEVELNEEDED);
        CASE_HRESULT_LOOKUP(DSERR_OUTOFMEMORY);
        CASE_HRESULT_LOOKUP(DSERR_BADFORMAT);
        CASE_HRESULT_LOOKUP(DSERR_UNSUPPORTED);
        CASE_HRESULT_LOOKUP(DSERR_NODRIVER);
        CASE_HRESULT_LOOKUP(DSERR_ALREADYINITIALIZED);
        CASE_HRESULT_LOOKUP(DSERR_NOAGGREGATION);
        CASE_HRESULT_LOOKUP(DSERR_BUFFERLOST);
        CASE_HRESULT_LOOKUP(DSERR_OTHERAPPHASPRIO);
        CASE_HRESULT_LOOKUP(DSERR_UNINITIALIZED);
        CASE_HRESULT_LOOKUP(DSERR_NOINTERFACE);
        CASE_HRESULT_LOOKUP(DSERR_ACCESSDENIED);
        CASE_HRESULT_LOOKUP(DSERR_DS8_REQUIRED);
        CASE_HRESULT_LOOKUP(DSERR_SENDLOOP);
        CASE_HRESULT_LOOKUP(DSERR_BADSENDBUFFERGUID);
        CASE_HRESULT_LOOKUP(DSERR_OBJECTNOTFOUND);

        // Some external codes that can be returned by the dsound API
        CASE_HRESULT_LOOKUP(REGDB_E_CLASSNOTREG);
        CASE_HRESULT_LOOKUP(DMO_E_TYPE_NOT_ACCEPTED);

        default:
            if(pszString && ccString >= 11) wsprintf(pszString, TEXT("0x%8.8lX"), hr);
            if(pszExplanation && ccExplanation) lstrcpyn(pszExplanation, TEXT("Unknown error"), ccExplanation);
            break;
    }

#undef CASE_HRESULT_LOOKUP
}


/***************************************************************************
 *
 *  IsWaveDeviceMappable
 *
 *  Description:
 *      Determines if a waveOut device is mappable or not.
 *
 *  Arguments:
 *      UINT [in]: waveOut device id.
 *      BOOL [in]: TRUE if capture.
 *
 *  Returns:
 *      BOOL: TRUE if the device is mappable.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsWaveDeviceMappable"

BOOL IsWaveDeviceMappable(UINT uDeviceId, BOOL fCapture)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = WaveMessage(uDeviceId, fCapture, DRV_QUERYMAPPABLE, 0, 0);

    DPF_LEAVE(SUCCEEDED(hr));

    return SUCCEEDED(hr);
}


/***************************************************************************
 *
 *  GetNextMappableWaveDevice
 *
 *  Description:
 *      Gets the next valid, mappable waveIn/Out device.
 *
 *  Arguments:
 *      UINT [in]: starting device id, or WAVE_DEVICEID_NONE.
 *      BOOL [in]: TRUE if capture.
 *
 *  Returns:
 *      UINT: next device id, or WAVE_DEVICEID_NONE
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetNextMappableWaveDevice"

UINT GetNextMappableWaveDevice(UINT uDeviceId, BOOL fCapture)
{
    const UINT                    cDevices  = WaveGetNumDevs(fCapture);

    DPF_ENTER();

    if(WAVE_DEVICEID_NONE == uDeviceId)
    {
        uDeviceId = 0;
    }
    else
    {
        uDeviceId++;
    }

    while(uDeviceId < cDevices)
    {
        if(IsValidWaveDevice(uDeviceId, fCapture, NULL))
        {
            if(IsWaveDeviceMappable(uDeviceId, fCapture))
            {
                break;
            }
        }

        uDeviceId++;
    }

    if(uDeviceId >= cDevices)
    {
        uDeviceId = WAVE_DEVICEID_NONE;
    }

    DPF_LEAVE(uDeviceId);

    return uDeviceId;
}


/***************************************************************************
 *
 *  GetFixedFileInformation
 *
 *  Description:
 *      Gets fixed file information for a specified file.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      VS_FIXEDFILEINFO * [out]: receives fixed file information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetFixedFileInformationA"

HRESULT GetFixedFileInformationA(LPCSTR pszFile, VS_FIXEDFILEINFO *pInfo)
{
    LPVOID                  pvFileVersionInfo   = NULL;
    HRESULT                 hr                  = DS_OK;
    DWORD                   cbFileVersionInfo;
    LPVOID                  pvFixedFileInfo;
    UINT                    cbFixedFileInfo;
    BOOL                    f;

    DPF_ENTER();

    // Get the file's version information size
    cbFileVersionInfo = GetFileVersionInfoSizeA((LPSTR)pszFile, NULL);

    if(!cbFileVersionInfo)
    {
        hr = GetLastErrorToHRESULT();
        DPF(DPFLVL_ERROR, "GetFileVersionInfoSize failed with %s (%lu)", HRESULTtoSTRING(hr), GetLastError());
    }

    // Allocate the version information
    if(SUCCEEDED(hr))
    {
        pvFileVersionInfo = MEMALLOC_A(BYTE, cbFileVersionInfo);
        hr = HRFROMP(pvFileVersionInfo);
    }

    // Get the version information
    if(SUCCEEDED(hr))
    {
        f = GetFileVersionInfoA((LPSTR)pszFile, 0, cbFileVersionInfo, pvFileVersionInfo);

        if(!f)
        {
            hr = GetLastErrorToHRESULT();
            DPF(DPFLVL_ERROR, "GetFileVersionInfo failed with %s (%lu)", HRESULTtoSTRING(hr), GetLastError());
        }
    }

    // Get the fixed file information
    if(SUCCEEDED(hr))
    {
        f = VerQueryValueA(pvFileVersionInfo, "\\", &pvFixedFileInfo, &cbFixedFileInfo);

        if(!f)
        {
            hr = GetLastErrorToHRESULT();
            DPF(DPFLVL_ERROR, "VerQueryValue failed with %s (%lu)", HRESULTtoSTRING(hr), GetLastError());
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(sizeof(*pInfo) <= cbFixedFileInfo);
        CopyMemory(pInfo, pvFixedFileInfo, sizeof(*pInfo));
    }

    // Clean up
    MEMFREE(pvFileVersionInfo);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "GetFixedFileInformationW"

HRESULT GetFixedFileInformationW(LPCWSTR pszFile, VS_FIXEDFILEINFO *pInfo)
{
    HRESULT                 hr                  = DS_OK;
#ifdef UNICODE
    LPVOID                  pvFileVersionInfo   = NULL;
    DWORD                   cbFileVersionInfo;
    LPVOID                  pvFixedFileInfo;
    UINT                    cbFixedFileInfo;
    BOOL                    f;
#else // UNICODE
    LPSTR                   pszFileA;
#endif // UNICODE

    DPF_ENTER();

#ifdef UNICODE

    // Get the file's version information size
    cbFileVersionInfo = GetFileVersionInfoSizeW((LPWSTR)pszFile, NULL);

    if(!cbFileVersionInfo)
    {
        hr = GetLastErrorToHRESULT();
        DPF(DPFLVL_ERROR, "GetFileVersionInfoSize failed with %s (%lu)", HRESULTtoSTRING(hr), GetLastError());
    }

    // Allocate the version information
    if(SUCCEEDED(hr))
    {
        pvFileVersionInfo = MEMALLOC_A(BYTE, cbFileVersionInfo);
        hr = HRFROMP(pvFileVersionInfo);
    }

    // Get the version information
    if(SUCCEEDED(hr))
    {
        f = GetFileVersionInfoW((LPWSTR)pszFile, 0, cbFileVersionInfo, pvFileVersionInfo);

        if(!f)
        {
            hr = GetLastErrorToHRESULT();
            DPF(DPFLVL_ERROR, "GetFileVersionInfo failed with %s (%lu)", HRESULTtoSTRING(hr), GetLastError());
        }
    }

    // Get the fixed file information
    if(SUCCEEDED(hr))
    {
        f = VerQueryValueW(pvFileVersionInfo, L"\\", &pvFixedFileInfo, &cbFixedFileInfo);

        if(!f)
        {
            hr = GetLastErrorToHRESULT();
            DPF(DPFLVL_ERROR, "VerQueryValue failed with %s (%lu)", HRESULTtoSTRING(hr), GetLastError());
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(sizeof(*pInfo) <= cbFixedFileInfo);
        CopyMemory(pInfo, pvFixedFileInfo, sizeof(*pInfo));
    }

    // Clean up
    MEMFREE(pvFileVersionInfo);

#else // UNICODE

    pszFileA = UnicodeToAnsiAlloc(pszFile);
    hr = HRFROMP(pszFileA);

    if(SUCCEEDED(hr))
    {
        hr = GetFixedFileInformationA(pszFileA, pInfo);
    }

    MEMFREE(pszFileA);

#endif // UNICODE

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  PadCursor
 *
 *  Description:
 *      Pads a play or write cursor.
 *
 *  Arguments:
 *      DWORD [in]: cursor position.
 *      DWORD [in]: buffer size.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      LONG [in]: pad value in milliseconds.
 *
 *  Returns:
 *      DWORD: new cursor position.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PadCursor"

DWORD PadCursor(DWORD dwPosition, DWORD cbBuffer, LPCWAVEFORMATEX pwfx, LONG lPad)
{
    DPF_ENTER();

    dwPosition += ((pwfx->nSamplesPerSec * lPad + 500) / 1000) * pwfx->nBlockAlign;
    dwPosition %= cbBuffer;

    DPF_LEAVE(dwPosition);
    return dwPosition;
}


/***************************************************************************
 *
 *  CopyDsBufferDesc
 *
 *  Description:
 *      Copies a DSBUFFERDESC structure.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: source.
 *      LPDSBUFFERDESC [out]: destination.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CopyDsBufferDesc"

HRESULT CopyDsBufferDesc(LPCDSBUFFERDESC pSource, LPDSBUFFERDESC pDest)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    CopyMemory(pDest, pSource, sizeof(*pSource));

    if(pSource->lpwfxFormat)
    {
        pDest->lpwfxFormat = CopyWfxAlloc(pSource->lpwfxFormat);
        hr = HRFROMP(pDest->lpwfxFormat);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  WaveMessage
 *
 *  Description:
 *      Sends a message to a wave device.
 *
 *  Arguments:
 *      UINT [in]: waveOut device.
 *      BOOL [in]: TRUE if capture.
 *      UINT [in]: message identifier.
 *      DWORD [in]: parameter 1.
 *      DWORD [in]: parameter 2.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveMessage"

HRESULT WaveMessage(UINT uDeviceId, BOOL fCapture, UINT uMessage, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    typedef MMRESULT (WINAPI *LPFNWAVEOUTMESSAGE)(HWAVEOUT, UINT, DWORD_PTR, DWORD_PTR);

    LPFNWAVEOUTMESSAGE      pfn;
    MMRESULT                mmr;
    HRESULT                 hr;

    DPF_ENTER();

    if(fCapture)
    {
        pfn = (LPFNWAVEOUTMESSAGE)waveInMessage;
    }
    else
    {
        pfn = waveOutMessage;
    }

    mmr = pfn((HWAVEOUT)IntToPtr(uDeviceId), uMessage, dwParam1, dwParam2);

    // In Win9x, MMSYSERR_INVALPARAM here means no device.
    if (mmr == MMSYSERR_INVALPARAM)
    {
        hr = DSERR_NODRIVER;
    }
    else
    {
        hr = MMRESULTtoHRESULT(mmr);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  WaveGetNumDevs
 *
 *  Description:
 *      Gets the number of wave devices in the system.
 *
 *  Arguments:
 *      BOOL [in]: TRUE if capture.
 *
 *  Returns:
 *      UINT: number of wave devices.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveGetNumDevs"

UINT WaveGetNumDevs(BOOL fCapture)
{
    UINT                    cDevs;

    DPF_ENTER();

    if(fCapture)
    {
        cDevs = waveInGetNumDevs();
    }
    else
    {
        cDevs = waveOutGetNumDevs();
    }

    DPF_LEAVE(cDevs);
    return cDevs;
}


/***************************************************************************
 *
 *  GetWaveDeviceInterface
 *
 *  Description:
 *      Gets the interface for a given waveOut device id.
 *
 *  Arguments:
 *      UINT [in]: waveOut device id.
 *      BOOL [in]: TRUE if capture.
 *      LPTSTR * [out]: receives interface string.  The caller is
 *                      responsible for freeing this memory.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetWaveDeviceInterface"

HRESULT GetWaveDeviceInterface(UINT uDeviceId, BOOL fCapture, LPTSTR *ppszInterface)
{
    LPWSTR                      pszInterfaceW   = NULL;
    LPTSTR                      pszInterface    = NULL;
    ULONG                       cbInterface;
    HRESULT                     hr;

    DPF_ENTER();

    // Note: There is no mechanism for getting the interface for a legacy
    // driver on NT; only WDM drivers.
    hr = WaveMessage(uDeviceId, fCapture, DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbInterface, 0);

    if(SUCCEEDED(hr))
    {
        pszInterfaceW = (LPWSTR)MEMALLOC_A(BYTE, cbInterface);
        hr = HRFROMP(pszInterfaceW);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaveMessage(uDeviceId, fCapture, DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)pszInterfaceW, cbInterface);
    }

    if(SUCCEEDED(hr))
    {
        pszInterface = UnicodeToTcharAlloc(pszInterfaceW);
        hr = HRFROMP(pszInterface);
    }

    if(SUCCEEDED(hr))
    {
        *ppszInterface = pszInterface;
    }

    MEMFREE(pszInterfaceW);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetWaveDeviceIdFromInterface
 *
 *  Description:
 *      Gets the waveOut device id for a given device interface.
 *
 *  Arguments:
 *      LPCWSTR [in]: device interface.
 *      BOOL [in]: TRUE if capture.
 *      LPUINT [out]: receives wave device id.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetWaveDeviceIdFromInterface"

HRESULT GetWaveDeviceIdFromInterface(LPCTSTR pszInterface, BOOL fCapture, LPUINT puDeviceId)
{
    const UINT              cDevices    = WaveGetNumDevs(fCapture);
    LPTSTR                  pszThis     = NULL;
    HRESULT                 hr          = DS_OK;
    UINT                    uId;

    DPF_ENTER();

    for(uId = 0; uId < cDevices; uId++)
    {
        hr = GetWaveDeviceInterface(uId, fCapture, &pszThis);

        if(SUCCEEDED(hr) && !lstrcmpi(pszInterface, pszThis))
        {
            break;
        }

        MEMFREE(pszThis);
    }

    MEMFREE(pszThis);

    if(uId < cDevices)
    {
        *puDeviceId = uId;
    }
    else
    {
        DPF(DPFLVL_ERROR, "Can't find waveIn/Out device id for interface %s", pszInterface);
        hr = DSERR_NODRIVER;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetWaveDeviceDevnode
 *
 *  Description:
 *      Gets the devnode for a given waveOut device id.
 *
 *  Arguments:
 *      UINT [in]: waveOut device id.
 *      BOOL [in]: TRUE if capture.
 *      LPDWORD [out]: receives devnode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetWaveDeviceDevnode"

HRESULT GetWaveDeviceDevnode(UINT uDeviceId, BOOL fCapture, LPDWORD pdwDevnode)
{
    HRESULT                     hr;

    DPF_ENTER();

    hr = WaveMessage(uDeviceId, fCapture, DRV_QUERYDEVNODE, (DWORD_PTR)pdwDevnode, 0);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetWaveDeviceIdFromDevnode
 *
 *  Description:
 *      Gets the waveOut device id for a given devnode.
 *
 *  Arguments:
 *      DWORD [in]: devnode.
 *      BOOL [in]: TRUE if capture.
 *      LPUINT [out]: receives wave device id.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetWaveDeviceIdFromDevnode"

HRESULT GetWaveDeviceIdFromDevnode(DWORD dwDevnode, BOOL fCapture, LPUINT puDeviceId)
{
    const UINT              cDevices    = WaveGetNumDevs(fCapture);
    HRESULT                 hr          = DS_OK;
    UINT                    uId;
    DWORD                   dwThis;

    DPF_ENTER();

    for(uId = 0; uId < cDevices; uId++)
    {
        hr = GetWaveDeviceDevnode(uId, fCapture, &dwThis);

        if(SUCCEEDED(hr) && dwThis == dwDevnode)
        {
            break;
        }
    }

    if(uId < cDevices)
    {
        *puDeviceId = uId;
    }
    else
    {
        DPF(DPFLVL_ERROR, "Can't find waveIn/Out device id for devnode 0x%8.8lX", dwDevnode);
        hr = DSERR_NODRIVER;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CompareBufferProperties
 *
 *  Description:
 *      Determines if a buffer supports a set of properties.
 *
 *  Arguments:
 *      LPCCOMPAREBUFFER [in]: buffer 1.
 *      LPCCOMPAREBUFFER [in]: buffer 2.
 *
 *  Returns:
 *      BOOL: TRUE if the buffers are compatible.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CompareBufferProperties"

BOOL CompareBufferProperties(LPCCOMPAREBUFFER pBuffer1, LPCCOMPAREBUFFER pBuffer2)
{
    const DWORD             dwOptionalMask  = DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPOSITIONNOTIFY;
    const DWORD             dwIgnoreMask    = dwOptionalMask | DSBCAPS_FOCUSMASK | DSBCAPS_CTRLFX;
    DWORD                   dwFlags[2];
    BOOL                    fCompare;

    DPF_ENTER();

    // Compare the necessary flags
    dwFlags[0] = pBuffer1->dwFlags;
    dwFlags[0] &= ~dwIgnoreMask;

    dwFlags[1] = pBuffer2->dwFlags;
    dwFlags[1] &= ~dwIgnoreMask;

    if(!(dwFlags[0] & DSBCAPS_LOCMASK))
    {
        dwFlags[1] &= ~DSBCAPS_LOCMASK;
    }

    fCompare = (dwFlags[0] == dwFlags[1]);

    // Compare the optional flags
    if(fCompare)
    {
        dwFlags[0] = pBuffer1->dwFlags;
        dwFlags[0] &= dwOptionalMask;

        dwFlags[1] = pBuffer2->dwFlags;
        dwFlags[1] &= dwOptionalMask;

        // Make sure buffer 1 has no optional flags that are absent in buffer 2
        fCompare = !(dwFlags[0] & (dwFlags[1] ^ dwFlags[0]));
    }

    // Compare the format
    if(fCompare)
    {
        const WAVEFORMATEX *pwfx1 = pBuffer1->pwfxFormat;
        const WAVEFORMATEX *pwfx2 = pBuffer2->pwfxFormat;

        if (pwfx1->wFormatTag == pwfx2->wFormatTag) {
            if (WAVE_FORMAT_PCM == pwfx1->wFormatTag) {
                fCompare = !memcmp(pwfx1, pwfx2, sizeof(PCMWAVEFORMAT));
            } else if (pwfx1->cbSize == pwfx2->cbSize) {
                fCompare = !memcmp(pwfx1, pwfx2, sizeof(WAVEFORMATEX) + pwfx1->cbSize);
            } else {
                fCompare = FALSE;
            }
        } else {
            fCompare = FALSE;
        }
    }

    // Compare the 3D algorithm
    if(fCompare && (pBuffer1->dwFlags & DSBCAPS_CTRL3D))
    {
        fCompare = IsEqualGUID(&pBuffer1->guid3dAlgorithm, &pBuffer2->guid3dAlgorithm);
    }

    DPF_LEAVE(fCompare);
    return fCompare;
}


/***************************************************************************
 *
 *  GetWindowsVersion
 *
 *  Description:
 *      Determines the version of Windows we are running on.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      WINVERSION: Host Windows version.
 *
 ***************************************************************************/

WINVERSION GetWindowsVersion(void)
{
    WINVERSION winVersion = WIN_UNKNOWN;
    OSVERSIONINFO osvi;

    // Initialize the osvi structure
    ZeroMemory(&osvi,sizeof osvi);
    osvi.dwOSVersionInfoSize = sizeof osvi;

    if (GetVersionEx(&osvi))
        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) // Win9x
            if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 90)
                winVersion = WIN_ME;
            else
                winVersion = WIN_9X;
        else // WinNT
            if (osvi.dwMajorVersion == 4)
                winVersion = WIN_NT;
            else if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
                winVersion = WIN_2K;
            else
                winVersion = WIN_XP;

    return winVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\misc.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       misc.h
 *  Content:    Miscelaneous utility functions
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/31/96    dereks  Created
 *
 ***************************************************************************/

#ifndef __MISC_H__
#define __MISC_H__

// No appropriate waveOut/waveIn device id
#define WAVE_DEVICEID_NONE          MAX_UINT

// Non-window state
#define SW_NOSTATE                  MAX_UINT

// EnumStandardFormats callback type
typedef BOOL (CALLBACK *LPFNEMUMSTDFMTCALLBACK)(LPCWAVEFORMATEX, LPVOID);

// Pragma reminders
#define QUOTE0(a)           #a
#define QUOTE1(a)           QUOTE0(a)
#define MESSAGE(a)          message(__FILE__ ", line " QUOTE1(__LINE__) ": " a)
#define TODO(a)             MESSAGE("TODO: " a)

// Default buffer format
#define DEF_FMT_CHANNELS    2
#define DEF_FMT_SAMPLES     22050
#define DEF_FMT_BITS        8

// Default primary buffer size
#define DEF_PRIMARY_SIZE    0x8000

// Miscellaneous helper macros
#define LXOR(a, b) \
            (!(a) != !(b))

#define BLOCKALIGN(a, b) \
            (((a) / (b)) * (b))

#define BLOCKALIGNPAD(a, b) \
            (BLOCKALIGN(a, b) + (((a) % (b)) ? (b) : 0))

#define HRFROMP(p) \
            ((p) ? DS_OK : DSERR_OUTOFMEMORY)

#define MAKEBOOL(a) \
            (!!(a))

#define NUMELMS(a) \
            (sizeof(a) / sizeof((a)[0]))

#define ADD_WRAP(val, add, max) \
            (((val) + (add)) % (max))

#define INC_WRAP(val, max) \
            ((val) = ADD_WRAP(val, 1, max))

#define MIN(a, b) \
            min(a, b)

#define MAX(a, b) \
            max(a, b)

#define BETWEEN(value, minimum, maximum) \
            min(maximum, max(minimum, value))

#define ABS(n) \
            ((n) > 0 ? (n) : (-n))

typedef struct tagCOMPAREBUFFER
{
    DWORD           dwFlags;
    LPCWAVEFORMATEX pwfxFormat;
    GUID            guid3dAlgorithm;
} COMPAREBUFFER, *LPCOMPAREBUFFER;

typedef const COMPAREBUFFER *LPCCOMPAREBUFFER;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// DDHELP globals
extern DWORD dwHelperPid;
extern HINSTANCE hModule;

// Versions of Windows that we care about
typedef enum
{
    WIN_UNKNOWN,
    WIN_9X,
    WIN_ME,
    WIN_NT,
    WIN_2K,
    WIN_XP
} WINVERSION;

// Find simplified Windows version
extern WINVERSION GetWindowsVersion(void);

// waveIn/Out helpers
extern HRESULT OpenWaveOut(LPHWAVEOUT, UINT, LPCWAVEFORMATEX);
extern HRESULT CloseWaveOut(LPHWAVEOUT);
extern HRESULT OpenWaveIn(LPHWAVEIN, UINT, LPCWAVEFORMATEX, DWORD_PTR, DWORD_PTR, DWORD);
extern HRESULT CloseWaveIn(LPHWAVEIN);
extern void InterruptSystemEvent(UINT);
extern HRESULT GetWaveOutVolume(UINT, DWORD, LPLONG, LPLONG);
extern HRESULT SetWaveOutVolume(UINT, DWORD, LONG, LONG);
extern BOOL IsWaveDeviceMappable(UINT, BOOL);
extern UINT GetNextMappableWaveDevice(UINT, BOOL);
extern HRESULT WaveMessage(UINT, BOOL, UINT, DWORD_PTR, DWORD_PTR);
extern UINT WaveGetNumDevs(BOOL);
extern HRESULT GetWaveDeviceInterface(UINT, BOOL, LPTSTR *);
extern HRESULT GetWaveDeviceIdFromInterface(LPCTSTR, BOOL, LPUINT);
extern HRESULT GetWaveDeviceDevnode(UINT, BOOL, LPDWORD);
extern HRESULT GetWaveDeviceIdFromDevnode(DWORD, BOOL, LPUINT);

// Error code translations
extern HRESULT MMRESULTtoHRESULT(MMRESULT);
extern HRESULT WIN32ERRORtoHRESULT(DWORD);
extern HRESULT GetLastErrorToHRESULT(void);
extern LPCTSTR HRESULTtoSTRING(HRESULT);
extern void HresultToString(HRESULT, LPTSTR, UINT, LPTSTR, UINT);

// ANSI/Unicode conversion
extern DWORD AnsiToAnsi(LPCSTR, LPSTR, DWORD);
extern DWORD AnsiToUnicode(LPCSTR, LPWSTR, DWORD);
extern DWORD UnicodeToAnsi(LPCWSTR, LPSTR, DWORD);
extern DWORD UnicodeToUnicode(LPCWSTR, LPWSTR, DWORD);

#ifdef UNICODE
#define AnsiToTchar AnsiToUnicode
#define TcharToAnsi UnicodeToAnsi
#define UnicodeToTchar UnicodeToUnicode
#define TcharToUnicode UnicodeToUnicode
#else // UNICODE
#define AnsiToTchar AnsiToAnsi
#define TcharToAnsi AnsiToAnsi
#define UnicodeToTchar UnicodeToAnsi
#define TcharToUnicode AnsiToUnicode
#endif // UNICODE

extern LPSTR AnsiToAnsiAlloc(LPCSTR);
extern LPWSTR AnsiToUnicodeAlloc(LPCSTR);
extern LPSTR UnicodeToAnsiAlloc(LPCWSTR);
extern LPWSTR UnicodeToUnicodeAlloc(LPCWSTR);

#ifdef UNICODE
#define AnsiToTcharAlloc AnsiToUnicodeAlloc
#define TcharToAnsiAlloc UnicodeToAnsiAlloc
#define UnicodeToTcharAlloc UnicodeToUnicodeAlloc
#define TcharToUnicodeAlloc UnicodeToUnicodeAlloc
#define TcharToTcharAlloc UnicodeToUnicodeAlloc
#else // UNICODE
#define AnsiToTcharAlloc AnsiToAnsiAlloc
#define TcharToAnsiAlloc AnsiToAnsiAlloc
#define UnicodeToTcharAlloc UnicodeToAnsiAlloc
#define TcharToUnicodeAlloc AnsiToUnicodeAlloc
#define TcharToTcharAlloc AnsiToAnsiAlloc
#endif // UNICODE

__inline UINT lstrsizeA(LPCSTR pszString)
{
    return pszString ? lstrlenA(pszString) + 1 : 0;
}

__inline UINT lstrsizeW(LPCWSTR pszString)
{
    return pszString ? sizeof(WCHAR) * (lstrlenW(pszString) + 1) : 0;
}

#ifdef UNICODE
#define lstrsize lstrsizeW
#else // UNICODE
#define lstrsize lstrsizeA
#endif // UNICODE

// Window helpers
extern HWND GetRootParentWindow(HWND);
extern HWND GetForegroundApplication(void);
extern UINT GetWindowState(HWND);

// Wave format helpers
extern void FillPcmWfx(LPWAVEFORMATEX, WORD, DWORD, WORD);
extern LPWAVEFORMATEX AllocPcmWfx(WORD, DWORD, WORD);
extern DWORD GetWfxSize(LPCWAVEFORMATEX, DWORD);
extern void CopyWfx(LPCWAVEFORMATEX, LPWAVEFORMATEX);
extern LPWAVEFORMATEX CopyWfxAlloc(LPCWAVEFORMATEX);
extern LPDSCEFFECTDESC CopyDSCFXDescAlloc(DWORD,LPDSCEFFECTDESC);
extern HRESULT CopyWfxApi(LPCWAVEFORMATEX, LPWAVEFORMATEX, LPDWORD);
extern BOOL CmpWfx(LPCWAVEFORMATEX, LPCWAVEFORMATEX);
extern LPWAVEFORMATEX AllocPcmWfx(WORD, DWORD, WORD);
extern BOOL EnumStandardFormats(LPCWAVEFORMATEX, LPWAVEFORMATEX, LPFNEMUMSTDFMTCALLBACK, LPVOID);
extern void FillSilence(LPVOID, DWORD, WORD);
extern void FillNoise(LPVOID, DWORD, WORD);

__inline void FillDefWfx(LPWAVEFORMATEX pwfx)
{
    FillPcmWfx(pwfx, DEF_FMT_CHANNELS, DEF_FMT_SAMPLES, DEF_FMT_BITS);
}

__inline LPWAVEFORMATEX AllocDefWfx(void)
{
    return AllocPcmWfx(DEF_FMT_CHANNELS, DEF_FMT_SAMPLES, DEF_FMT_BITS);
}

// Attenuation value conversion
extern void VolumePanToAttenuation(LONG, LONG, LPLONG, LPLONG);
extern void AttenuationToVolumePan(LONG, LONG, LPLONG, LPLONG);
extern LONG MultiChannelToStereoPan(DWORD, const DWORD*, const LONG*);
extern void FillDsVolumePan(LONG, LONG, PDSVOLUMEPAN);

// Miscellaneous dsound helpers
extern int CountBits(DWORD word);
extern int HighestBit(DWORD word);
extern DWORD GetAlignedBufferSize(LPCWAVEFORMATEX, DWORD);
extern DWORD PadCursor(DWORD, DWORD, LPCWAVEFORMATEX, LONG);
extern HRESULT CopyDsBufferDesc(LPCDSBUFFERDESC, LPDSBUFFERDESC);
extern BOOL CompareBufferProperties(LPCCOMPAREBUFFER, LPCCOMPAREBUFFER);

__inline ULONG AddRef(PULONG pulRefCount)
{
    ASSERT(pulRefCount);
    ASSERT(*pulRefCount < MAX_ULONG);
    
    if(*pulRefCount < MAX_ULONG)
    {
        (*pulRefCount)++;
    }

    return *pulRefCount;
}

__inline ULONG Release(PULONG pulRefCount)
{
    ASSERT(pulRefCount);
    ASSERT(*pulRefCount > 0);
    
    if(*pulRefCount > 0)
    {
        (*pulRefCount)--;
    }

    return *pulRefCount;
}

// File information
extern HRESULT GetFixedFileInformationA(LPCSTR, VS_FIXEDFILEINFO *);
extern HRESULT GetFixedFileInformationW(LPCWSTR, VS_FIXEDFILEINFO *);

#ifdef UNICODE
#define GetFixedFileInformation GetFixedFileInformationW
#else // UNICODE
#define GetFixedFileInformation GetFixedFileInformationA
#endif // UNICODE

#ifdef __cplusplus
}
#endif // __cplusplus

#ifdef __cplusplus

// Callback function wrapper classes
class CUsesEnumStandardFormats
{
public:
    CUsesEnumStandardFormats(void);
    virtual ~CUsesEnumStandardFormats(void);

protected:
    virtual BOOL EnumStandardFormats(LPCWAVEFORMATEX, LPWAVEFORMATEX);
    virtual BOOL EnumStandardFormatsCallback(LPCWAVEFORMATEX) = 0;

private:
    static BOOL CALLBACK EnumStandardFormatsCallbackStatic(LPCWAVEFORMATEX, LPVOID);
};

#endif // __cplusplus

#endif __MISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\miscinl.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       miscinl.h
 *  Content:    Miscelaneous inline objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/28/98    dereks  Created
 *
 ***************************************************************************/

#ifndef __MISCINL_H__
#define __MISCINL_H__

#ifdef __cplusplus

// A simple string class
class CString
{
private:
    LPSTR                   m_pszAnsi;      // Ansi version of the string
    LPWSTR                  m_pszUnicode;   // Unicode version of the string

public:
    CString(void);
    virtual ~CString(void);

public:
    virtual LPCSTR operator =(LPCSTR);
    virtual LPCWSTR operator =(LPCWSTR);
    virtual operator LPCSTR(void);
    virtual operator LPCWSTR(void);
    virtual BOOL IsEmpty(void);

private:
    virtual void AssertValid(void);
};

// The DirectSound device description
class CDeviceDescription
    : public CDsBasicRuntime
{
public:
    VADDEVICETYPE               m_vdtDeviceType;        // The device type
    GUID                        m_guidDeviceId;         // The device identifier
    CString                     m_strName;              // The device name
    CString                     m_strPath;              // The device path
    CString                     m_strInterface;         // The device interface
    DWORD                       m_dwDevnode;            // The device devnode
    UINT                        m_uWaveDeviceId;        // The wave device identifer

public:
    CDeviceDescription(VADDEVICETYPE = 0, REFGUID = GUID_NULL, UINT = WAVE_DEVICEID_NONE);
    virtual ~CDeviceDescription(void);
};

// Helper functions
template <class type> void SwapValues(type *, type *);

#endif // __cplusplus

#endif // __MISCINL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\miscinl.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       miscinl.cpp
 *  Content:    Miscelaneous inline objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/28/98    dereks  Created
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  CString
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CString::CString"

inline CString::CString(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CString);

    m_pszAnsi = NULL;
    m_pszUnicode = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CString
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CString::~CString"

inline CString::~CString(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CString);

    MEMFREE(m_pszAnsi);
    MEMFREE(m_pszUnicode);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  operator =(LPCSTR)
 *
 *  Description:
 *      Assignment operator.
 *
 *  Arguments:
 *      LPCSTR [in]: string.
 *
 *  Returns:  
 *      LPCSTR [in]: string.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CString::operator =(LPCSTR)"

inline LPCSTR CString::operator =(LPCSTR pszAnsi)
{
    MEMFREE(m_pszAnsi);
    MEMFREE(m_pszUnicode);

    if(pszAnsi)
    {
        m_pszAnsi = AnsiToAnsiAlloc(pszAnsi);
        m_pszUnicode = AnsiToUnicodeAlloc(pszAnsi);
    }
    
    AssertValid();
    
    return pszAnsi;
}


/***************************************************************************
 *
 *  operator =(LPCWSTR)
 *
 *  Description:
 *      Assignment operator.
 *
 *  Arguments:
 *      LPCWSTR [in]: string.
 *
 *  Returns:  
 *      LPCWSTR [in]: string.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CString::operator =(LPCWSTR)"

inline LPCWSTR CString::operator =(LPCWSTR pszUnicode)
{
    MEMFREE(m_pszAnsi);
    MEMFREE(m_pszUnicode);

    if(pszUnicode)
    {
        m_pszAnsi = UnicodeToAnsiAlloc(pszUnicode);
        m_pszUnicode = UnicodeToUnicodeAlloc(pszUnicode);
    }
    
    AssertValid();
    
    return pszUnicode;
}


/***************************************************************************
 *
 *  operator LPCSTR
 *
 *  Description:
 *      Cast operator.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      LPCSTR: string.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CString::operator LPCSTR"

inline CString::operator LPCSTR(void)
{
    AssertValid();
    
    return m_pszAnsi;
}


/***************************************************************************
 *
 *  operator LPCWSTR
 *
 *  Description:
 *      Cast operator.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      LPCWSTR: string.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CString::operator LPCWSTR"

inline CString::operator LPCWSTR(void)
{
    AssertValid();
    
    return m_pszUnicode;
}


/***************************************************************************
 *
 *  IsEmpty
 *
 *  Description:
 *      Determines if the string is empty or not.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the string is empty.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CString::IsEmpty"

inline BOOL CString::IsEmpty(void)
{
    AssertValid();

    return !m_pszAnsi || !m_pszUnicode;
}


/***************************************************************************
 *
 *  AssertValid
 *
 *  Description:
 *      Asserts that the object is valid.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CString::AssertValid"

inline void CString::AssertValid(void)
{
    ASSERT((m_pszAnsi && m_pszUnicode) || (!m_pszAnsi && !m_pszUnicode));
}


/***************************************************************************
 *
 *  CDeviceDescription
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDeviceDescription::CDeviceDescription"

inline CDeviceDescription::CDeviceDescription(VADDEVICETYPE vdtDeviceType, REFGUID guidDeviceId, UINT uWaveDeviceId)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDeviceDescription);

    m_vdtDeviceType = vdtDeviceType;
    m_guidDeviceId = guidDeviceId;
    m_dwDevnode = 0;
    m_uWaveDeviceId = uWaveDeviceId;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDeviceDescription
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDeviceDescription::~CDeviceDescription"

inline CDeviceDescription::~CDeviceDescription(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDeviceDescription);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CUsesEnumStandardFormats
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUsesEnumStandardFormats::CUsesEnumStandardFormats"

inline CUsesEnumStandardFormats::CUsesEnumStandardFormats(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CUsesEnumStandardFormats);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CUsesEnumStandardFormats
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUsesEnumStandardFormats::~CUsesEnumStandardFormats"

inline CUsesEnumStandardFormats::~CUsesEnumStandardFormats(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CUsesEnumStandardFormats);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumStandardFormats
 *
 *  Description:
 *      Wrapper around EnumStandardFormats.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: preferred format.
 *      LPWAVEFORMATEX [out]: receives format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUsesEnumStandardFormats::EnumStandardFormats"

inline BOOL CUsesEnumStandardFormats::EnumStandardFormats(LPCWAVEFORMATEX pwfxPreferred, LPWAVEFORMATEX pwfxFormat)
{
    return ::EnumStandardFormats(pwfxPreferred, pwfxFormat, EnumStandardFormatsCallbackStatic, this);
}


/***************************************************************************
 *
 *  EnumStandardFormatsCallbackStatic
 *
 *  Description:
 *      Static callback function for EnumStandardFormats.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *      LPVOID [in]: context argument.
 *
 *  Returns:  
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUsesEnumStandardFormats::EnumStandardFormatsCallbackStatic"

inline BOOL CALLBACK CUsesEnumStandardFormats::EnumStandardFormatsCallbackStatic(LPCWAVEFORMATEX pwfxFormat, LPVOID pvContext)
{
    return ((CUsesEnumStandardFormats *)pvContext)->EnumStandardFormatsCallback(pwfxFormat); 
}


/***************************************************************************
 *
 *  SwapValues
 *
 *  Description:
 *      Swaps two values.
 *
 *  Arguments:
 *      type * [in/out]: value 1.
 *      type * [in/out]: value 2.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "SwapValues"

template <class type> void SwapValues(type *p1, type *p2)
{
    type                    temp;

    temp = *p2;
    *p2 = *p1;
    *p1 = temp;
}


/***************************************************************************
 *
 *  CUsesCallbackEvent
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUsesCallbackEvent::CUsesCallbackEvent"

inline CUsesCallbackEvent::CUsesCallbackEvent(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CUsesCallbackEvent);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CUsesCallbackEvent
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUsesCallbackEvent::~CUsesCallbackEvent"

inline CUsesCallbackEvent::~CUsesCallbackEvent(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CUsesCallbackEvent);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  AllocCallbackEvent
 *
 *  Description:
 *      Allocates a callback event.
 *
 *  Arguments:
 *      CCallbackEventPool * [in]: pool to allocate from.
 *      CCallbackEvent ** [out]: receives event.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUsesCallbackEvent::AllocCallbackEvent"

inline HRESULT CUsesCallbackEvent::AllocCallbackEvent(CCallbackEventPool *pPool, CCallbackEvent **ppEvent)
{
    return pPool->AllocEvent(EventSignalCallbackStatic, this, ppEvent);
}


/***************************************************************************
 *
 *  EventSignalCallbackStatic
 *
 *  Description:
 *      Static callback function for the callback event.
 *
 *  Arguments:
 *      CCallbackEvent * [in]: event.
 *      LPVOID [in]: context argument.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUsesCallbackEvent::EventSignalCallbackStatic"

inline void CALLBACK CUsesCallbackEvent::EventSignalCallbackStatic(CCallbackEvent *pEvent, LPVOID pvContext)
{
    #pragma warning(disable:4530)  // Disable the nag about compiling with -GX
    try
    {
        ((CUsesCallbackEvent *)pvContext)->EventSignalCallback(pEvent); 
    } catch (...) {}
}


/***************************************************************************
 *
 *  CEvent
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      LPCTSTR [in]: event name.
 *      BOOL [in]: TRUE to create a manual-reset event.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEvent::CEvent"

inline CEvent::CEvent(LPCTSTR pszName, BOOL fManualReset)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEvent);

    m_hEvent = CreateGlobalEvent(pszName, fManualReset);
    ASSERT(IsValidHandleValue(m_hEvent));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEvent
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      HANDLE [in]: handle to duplicate.
 *      DWORD [in]: id of the process that owns the handle.
 *      BOOL [in]: TRUE if the source handle should be closed.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEvent::CEvent"

inline CEvent::CEvent(HANDLE hEvent, DWORD dwProcessId, BOOL fCloseSource)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEvent);

    m_hEvent = GetGlobalHandleCopy(hEvent, dwProcessId, fCloseSource);
    ASSERT(IsValidHandleValue(m_hEvent));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEvent
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEvent::~CEvent"

inline CEvent::~CEvent(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CEvent);

    CLOSE_HANDLE(m_hEvent);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Wait
 *
 *  Description:
 *      Waits for the event to be signalled.
 *
 *  Arguments:
 *      DWORD [in]: timeout value (in ms).
 *
 *  Returns:  
 *      DWORD: wait result.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEvent::Wait"

inline DWORD CEvent::Wait(DWORD dwTimeout)
{
    return WaitObject(dwTimeout, m_hEvent);
}


/***************************************************************************
 *
 *  Set
 *
 *  Description:
 *      Sets the event.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEvent::Set"

inline BOOL CEvent::Set(void)
{
    return SetEvent(m_hEvent);
}


/***************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      Resets the event.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEvent::Reset"

inline BOOL CEvent::Reset(void)
{
    return ResetEvent(m_hEvent);
}


/***************************************************************************
 *
 *  GetEventHandle
 *
 *  Description:
 *      Gets the actual event handle.  We use this function instead of a
 *      cast operator because I don't trust an LPVOID (which is what HANDLE)
 *      is defined as) cast operator.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HANDLE: event handle.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEvent::GetEventHandle"

inline HANDLE CEvent::GetEventHandle(void)
{
    return m_hEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\multi3d.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       multi3d.h
 *
 *  Content:    CMultiPan3dObject declaration.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 10/30/99     DuganP  Created
 *
 ***************************************************************************/

#ifndef __MULTI3D_H__
#define __MULTI3D_H__

// The current largest speaker configuration:
#define MAX_CHANNELS 8

// Forward declarations
class CMultiPan3dListener;
class CKsSecondaryRenderWaveBuffer;

// The multichannel-panning 3D object
class CMultiPan3dObject : public CSw3dObject
{
    friend class CMultiPan3dListener;

private:
    CMultiPan3dListener*          m_pPan3dListener;        // Associated 3d listener object
    CKsSecondaryRenderWaveBuffer* m_pBuffer;                    // Associated KS render buffer
    LONG                          m_lUserVolume;                // Most recent volume set by app
    BOOL                          m_fUserMute;                  // Whether buffer was muted by app
    D3DVECTOR                     m_vHrp;                       // Head-relative position vector
    LONG                          m_lPanLevels[MAX_CHANNELS];   // Channel attenuation values

public:
    CMultiPan3dObject(CMultiPan3dListener*, BOOL, BOOL, DWORD, CKsSecondaryRenderWaveBuffer*);
    ~CMultiPan3dObject(void);

public:
    // Object events
    HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    HRESULT SetMute(BOOL, LPBOOL);

private:
    // Nice math
    void UpdateAlgorithmHrp(D3DVECTOR*);
    LONG CalculateVolume(void);
    void CalculatePanValues(int);
    void DistributeSignal(double, double, int, double[]);

    // Writes data to the device
    HRESULT Commit3dChanges(void);
};

// The multichannel-panning 3D listener
class CMultiPan3dListener : public C3dListener
{
    friend class CMultiPan3dObject;

private:
    // Currently supported multichannel speaker layouts:
    static const double m_adStereoSpeakers[];
    static const double m_adSurroundSpeakers[];
    static const double m_adQuadSpeakers[];
    static const double m_ad5Point1Speakers[];
    static const double m_ad7Point1Speakers[];

    // Data used by our 3D objects for their pan calculations:
    int                 m_nChannels;    // Number of channels (speakers)
    const double*       m_adSpeakerPos; // Speaker position azimuth angles

public:
    // Speaker configuration
    virtual HRESULT SetSpeakerConfig(DWORD);
};

#endif // __MULTI3D_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\onwow64.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

/***************************************************************************
 *
 *  OnWow64
 *
 *  Description:
 *      Determines if we're running in the 32-bit WOW64 subsystem on Win64.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if we're running on WOW64.
 *
 ***************************************************************************/

BOOL OnWow64(void)
{
#ifdef _WIN64
    return FALSE;
#else
    PVOID Wow64Info = NULL;
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
    LONG lStatus = NtQueryInformationProcess(hProcess, ProcessWow64Information, &Wow64Info, sizeof Wow64Info, NULL);
    CloseHandle(hProcess);
    return !NT_ERROR(lStatus) && Wow64Info;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\mxvad.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mxvad.cpp
 *  Content:    DirectSound mixer virtual audio device class.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/29/98     dereks  Created
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CMxRenderDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     VADDEVICETYPE [in]: device type.
 *
 *  Returns:  
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMxRenderDevice::CMxRenderDevice"

CMxRenderDevice::CMxRenderDevice(VADDEVICETYPE vdt)
    : CRenderDevice(vdt)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CMxRenderDevice);

    // Initialize defaults
    m_pMixer = NULL;
    m_pMixDest = NULL;
    m_pwfxFormat = NULL;
    m_dwMixerState = VAD_BUFFERSTATE_STOPPED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CMxRenderDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:  
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMxRenderDevice::~CMxRenderDevice"

CMxRenderDevice::~CMxRenderDevice(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CMxRenderDevice);
    
    // Free the mixer    
    FreeMixer();

    DPF_LEAVE_VOID();    
}
    

/***************************************************************************
 *
 *  GetGlobalFormat
 *
 *  Description:
 *      Retrieves the format for the device.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives format.
 *      LPDWORD [in/out]: size of the above format.  On entry, this argument
 *                        contains the size of the buffer.  On exit, this
 *                        contains the required size of the buffer.  Call
 *                        this function twice: once to get the size, and
 *                        again to get the actual data.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMxRenderDevice::GetGlobalFormat"

HRESULT CMxRenderDevice::GetGlobalFormat(LPWAVEFORMATEX pwfxFormat, LPDWORD pdwSize)
{
    HRESULT                 hr;

    DPF_ENTER();
    
    ASSERT(m_pwfxFormat);
    
    hr = CopyWfxApi(m_pwfxFormat, pwfxFormat, pdwSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetGlobalFormat
 *
 *  Description:
 *      Sets the format for the device.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: new format
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMxRenderDevice::SetGlobalFormat"

HRESULT CMxRenderDevice::SetGlobalFormat(LPCWAVEFORMATEX pwfxFormat)
{
    HRESULT                                 hr              = DS_OK;
    CNode<CSecondaryRenderWaveBuffer *> *   pBufferNode;
    DWORD                                   dwMixerState;
    HRESULT                                 hrTemp;
    LPVOID                                  pvLock;
    DWORD                                   cbLock;

#ifdef DEBUG

    DWORD                                   dwState;

#endif // DEBUG

    DPF_ENTER();
    
    // We only support PCM
    if(!IsValidPcmWfx(pwfxFormat))
    {
        hr = DSERR_BADFORMAT;
    }

    // Suspend all playing software secondary buffers
    if(SUCCEEDED(hr))
    {
        for(pBufferNode = m_lstSecondaryBuffers.GetListHead(); pBufferNode; pBufferNode = pBufferNode->m_pNext)
        {
            // Note: CVxdSecondaryRenderWaveBuffer::SetState ignores
            // the SUSPEND flag.

#ifdef DEBUG

            hrTemp = pBufferNode->m_data->GetState(&dwState);
            ASSERT(SUCCEEDED(hrTemp) && !(dwState & VAD_BUFFERSTATE_SUSPEND));

#endif // DEBUG

            hrTemp = pBufferNode->m_data->SetState(VAD_BUFFERSTATE_SUSPEND);

            if(FAILED(hrTemp))
            {
                RPF(DPFLVL_ERROR, "Unable to suspend software secondary buffer");
            }
        }
    
        // Stop the mixer
        dwMixerState = m_dwMixerState;
        SetMixerState(VAD_BUFFERSTATE_STOPPED);

        // Set the mixer destination format
        hr = m_pMixDest->SetFormat((LPWAVEFORMATEX)pwfxFormat);
    
        if(FAILED(hr))
        {
            // Uh-oh.  Try to put the format back the way it was.
            pwfxFormat = m_pwfxFormat;
            hrTemp = m_pMixDest->SetFormat((LPWAVEFORMATEX)pwfxFormat);

            if(FAILED(hrTemp))
            {
                RPF(DPFLVL_ERROR, "Unable to restore orignal device format");
            }
        }

        // Fill the mixer destination with silence
        if(SUCCEEDED(hr))
        {
            hrTemp = LockMixerDestination(0, MAX_DWORD, &pvLock, &cbLock, NULL, NULL);

            if(SUCCEEDED(hrTemp))
            {
                FillSilence(pvLock, cbLock, pwfxFormat->wBitsPerSample);
            }

            if(SUCCEEDED(hrTemp))
            {
                hrTemp = UnlockMixerDestination(pvLock, cbLock, 0, 0);
            }

            if(FAILED(hrTemp))
            {
                RPF(DPFLVL_ERROR, "Unable to fill primary buffer with silence");
            }
        }

        // Restart the mixer
        SetMixerState(dwMixerState);

        // Restart all suspended buffers
        for(pBufferNode = m_lstSecondaryBuffers.GetListHead(); pBufferNode; pBufferNode = pBufferNode->m_pNext)
        {
            hrTemp = pBufferNode->m_data->SetState(VAD_BUFFERSTATE_SUSPEND);

            if(FAILED(hrTemp))
            {
                RPF(DPFLVL_ERROR, "Unable to restart suspended software secondary buffer");
            }
        }

        // Update the local copy of the format
        if(SUCCEEDED(hr) && pwfxFormat != m_pwfxFormat)
        {
            MEMFREE(m_pwfxFormat);

            m_pwfxFormat = CopyWfxAlloc(pwfxFormat);
            hr = HRFROMP(m_pwfxFormat);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateEmulatedSecondaryBuffer
 *
 *  Description:
 *      Creates a secondary wave buffer.
 *
 *  Arguments:
 *      LPCVADRBUFFERDESC [in]: buffer description.
 *      LPVOID [in]: buffer instace identifier.
 *      CSecondaryRenderWaveBuffer ** [out]: receives pointer to new wave 
 *                                           buffer.  Use Release to free 
 *                                           this object.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMxRenderDevice::CreateEmulatedSecondaryBuffer"

HRESULT CMxRenderDevice::CreateEmulatedSecondaryBuffer(LPCVADRBUFFERDESC pDesc, LPVOID pvInstance, CSysMemBuffer *pSysMemBuffer, CEmSecondaryRenderWaveBuffer **ppBuffer)
{
    CEmSecondaryRenderWaveBuffer *  pBuffer = NULL;
    HRESULT                         hr      = DS_OK;
    
    DPF_ENTER();
    
    pBuffer = NEW(CEmSecondaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(pDesc, NULL, pSysMemBuffer);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateMixer
 *
 *  Description:
 *      Creates and initializes the mixer and mixer destination.
 *
 *  Arguments:
 *      CMixDest * [in]: mixer destination object pointer.  This object
 *                       should only be allocated, not actually initialized.
 *      LPWAVEFORMATEX [in]: mixer format.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMxRenderDevice::CreateMixer"

HRESULT CMxRenderDevice::CreateMixer(CMixDest *pMixDest, LPCWAVEFORMATEX pwfxFormat)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(!m_pMixDest);
    ASSERT(!m_pMixer);
    ASSERT(!m_pwfxFormat);

    // Save the mixer destination pointer
    m_pMixDest = pMixDest;

    // Save a copy of the format
    m_pwfxFormat = CopyWfxAlloc(pwfxFormat);
    hr = HRFROMP(m_pwfxFormat);

    // Set the mixer destination format information
    if(SUCCEEDED(hr))
    {
        m_pMixDest->SetFormatInfo((LPWAVEFORMATEX)pwfxFormat);
    }

    // Initialize the destination
    if(SUCCEEDED(hr))
    {
        hr = m_pMixDest->Initialize();
    }

    // Create the mixer
    if(SUCCEEDED(hr))
    {
        hr = m_pMixDest->AllocMixer(&m_pMixer);
    }

    // Set the mixer destination format
    if(SUCCEEDED(hr))
    {
        hr = m_pMixDest->SetFormat((LPWAVEFORMATEX)pwfxFormat);
    }

    // Start the mixer running
    if(SUCCEEDED(hr))
    {
        hr = SetMixerState(VAD_BUFFERSTATE_STOPPED | VAD_BUFFERSTATE_WHENIDLE);
    }

    // Clean up
    // FIXME -- We are going to end up freeing m_pMixDest, but we didn't
    // Allocate it
    if(FAILED(hr))
    {
        FreeMixer();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeMixer
 *
 *  Description:
 *      Frees the mixer and mixer destination objects.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMxRenderDevice::FreeMixer"

void CMxRenderDevice::FreeMixer(void)
{
    DPF_ENTER();

    if(m_pMixDest)
    {
        if(m_pMixer) 
        {
            m_pMixer->Stop();
        }

        m_pMixDest->Stop();
        m_pMixDest->Terminate();
        
        if (m_pMixer)
        {
            m_pMixDest->FreeMixer();
            m_pMixer = NULL;
        }

        //FIXME -- We didn't allocate this, but we're going to free it!
        DELETE(m_pMixDest);
    }

    DELETE(m_pwfxFormat);

    m_dwMixerState = VAD_BUFFERSTATE_STOPPED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetMixerState
 *
 *  Description:
 *      Sets mixer state.
 *
 *  Arguments:
 *      DWORD [in]: mixer state.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMxRenderDevice::SetMixerState"

HRESULT CMxRenderDevice::SetMixerState(DWORD dwState)
{
    const DWORD             dwValidMask = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING | VAD_BUFFERSTATE_WHENIDLE;
    HRESULT                 hr          = DS_OK;
    
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    ASSERT(IS_VALID_FLAGS(dwState, dwValidMask));
    
    // Update the mixer and mixer destination states
    if(dwState & VAD_BUFFERSTATE_STARTED)
    {
        ASSERT(dwState & VAD_BUFFERSTATE_LOOPING);
        
        if(dwState & VAD_BUFFERSTATE_WHENIDLE)
        {
            m_pMixer->PlayWhenIdle();
            hr = m_pMixer->Run();
        }
        else
        {
            m_pMixer->Stop();
            m_pMixDest->Play();
        }
    }
    else
    {
        if(dwState & VAD_BUFFERSTATE_WHENIDLE)
        {
            m_pMixer->StopWhenIdle();
            hr = m_pMixer->Run();
        }
        else
        {
            m_pMixer->Stop();
            m_pMixDest->Stop();
        }
    }

    // Save a copy of the new state
    DPF(DPFLVL_INFO, "Mixer state set to 0x%8.8lX", dwState);
    m_dwMixerState = dwState;

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\multi3d.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       multi3d.cpp
 *
 *  Content:    CMultiPan3dObject: the multichannel-panning 3D object.
 *              CMultiPan3dListener: corresponding 3D listener object.
 *              This class extends the hierarchy in ds3d.cpp; it's only
 *              separate because ds3d.cpp has become absurdly huge.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 10/30/99     DuganP  Created (based on code kindly provided by JeffTay)
 *
 ***************************************************************************/

#include <math.h>       // For atan2()

#include "dsoundi.h"    // Blob of headers
#include "multi3d.h"    // Our public interface
#include "vector.h"     // For D3DVECTOR and PI

// Uncomment this line for some trace messages specific to this file:
//#define DPF_MULTI3D DPF
#pragma warning(disable:4002)
#define DPF_MULTI3D()

#define DPF_DECIMAL(x) int(x), int(x*100 - (int)x*100)

// Any angles or distances smaller than EPSILON are considered equivalent to 0
#define EPSILON 0.00001

// Supported speaker positions, represented as azimuth angles.
//
// Here's a picture of the azimuth angles for the 8 cardinal points,
// seen from above.  The listener's head is at the origin 0, facing
// in the +z direction, with +x to the right.
//
//          +z | 0  <-- azimuth 
//             | 
//    -pi/4 \  |  / pi/4
//           \ | /
//            \|/
// -pi/2-------0-------pi/2
//      -x    /|\    +x
//           / | \
//   -3pi/4 /  |  \ 3pi/4
//             |
//          -z | pi
//
// If and when we support the SPEAKER_TOP_* speaker positions, we'll
// have to define some elevation angles here too.

#define LEFT_AZIMUTH                    (-PI/2)
#define RIGHT_AZIMUTH                   (PI/2)
#define FRONT_LEFT_AZIMUTH              (-PI/4)
#define FRONT_RIGHT_AZIMUTH             (PI/4)
#define FRONT_CENTER_AZIMUTH            0.0
#define LOW_FREQUENCY_AZIMUTH           42.0
#define BACK_LEFT_AZIMUTH               (-3*PI/4)
#define BACK_RIGHT_AZIMUTH              (3*PI/4)
#define BACK_CENTER_AZIMUTH             PI
#define FRONT_LEFT_OF_CENTER_AZIMUTH    (-PI/8)
#define FRONT_RIGHT_OF_CENTER_AZIMUTH   (PI/8)

// Supported speaker layouts:

const double CMultiPan3dListener::m_adStereoSpeakers[] =
{
    LEFT_AZIMUTH,
    RIGHT_AZIMUTH
};
// Note: we can't use FRONT_LEFT_AZIMUTH and FRONT_RIGHT_AZIMUTH here because
// of the angle-based panning algorithm below; it doesn't work well if there
// are 2 speakers with more than 180 degrees between them.  This problem may
// go away if and when we change over to a distance-based panning algorithm.

const double CMultiPan3dListener::m_adSurroundSpeakers[] =
{
    FRONT_LEFT_AZIMUTH,
    FRONT_RIGHT_AZIMUTH,
    FRONT_CENTER_AZIMUTH,
    BACK_CENTER_AZIMUTH
};
const double CMultiPan3dListener::m_adQuadSpeakers[] =
{
    FRONT_LEFT_AZIMUTH,
    FRONT_RIGHT_AZIMUTH,
    BACK_LEFT_AZIMUTH,
    BACK_RIGHT_AZIMUTH
};
const double CMultiPan3dListener::m_ad5Point1Speakers[] =
{
    FRONT_LEFT_AZIMUTH,
    FRONT_RIGHT_AZIMUTH,
    FRONT_CENTER_AZIMUTH,
    LOW_FREQUENCY_AZIMUTH,
    BACK_LEFT_AZIMUTH,
    BACK_RIGHT_AZIMUTH
};
const double CMultiPan3dListener::m_ad7Point1Speakers[] =
{
    FRONT_LEFT_AZIMUTH,
    FRONT_RIGHT_AZIMUTH,
    FRONT_CENTER_AZIMUTH,
    LOW_FREQUENCY_AZIMUTH,
    BACK_LEFT_AZIMUTH,
    BACK_RIGHT_AZIMUTH,
    FRONT_LEFT_OF_CENTER_AZIMUTH,
    FRONT_RIGHT_OF_CENTER_AZIMUTH
};


/***************************************************************************
 *    
 *  CMultiPan3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener* [in]: (passed on to our base constructor)
 *      BOOL [in]:         (passed on to our base constructor)
 *      DWORD [in]:        (passed on to our base constructor)
 *      CKsSecondaryRenderWaveBuffer* [in]: buffer we're associated to
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dObject::CMultiPan3dObject"

CMultiPan3dObject::CMultiPan3dObject(CMultiPan3dListener* pListener, BOOL fMuteAtMaxDistance, BOOL fDopplerEnabled,
                                     DWORD dwFrequency, CKsSecondaryRenderWaveBuffer* pBuffer)
    : CSw3dObject(pListener, DS3DALG_NO_VIRTUALIZATION, fMuteAtMaxDistance, fDopplerEnabled, dwFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CMultiPan3dObject);

    // Initialize defaults
    m_pPan3dListener = pListener;
    m_pBuffer = pBuffer;
    m_lUserVolume = DSBVOLUME_MAX;
    m_fUserMute = FALSE;
    m_vHrp.x = m_vHrp.y = m_vHrp.z = 0;
    ZeroMemory(m_lPanLevels, sizeof m_lPanLevels);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CMultiPan3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dObject::~CMultiPan3dObject"

CMultiPan3dObject::~CMultiPan3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CMultiPan3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Gives the 3D object first notification of an attenuation change
 *      to its owning buffer.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation values.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dObject::SetAttenuation"

HRESULT CMultiPan3dObject::SetAttenuation(PDSVOLUMEPAN pdsvp, LPBOOL pfContinue)
{
    HRESULT hr;
    DPF_ENTER();

    m_lUserVolume = pdsvp->lVolume;
    hr = Commit3dChanges();
    if (SUCCEEDED(hr))
        *pfContinue = FALSE;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Gives the 3D object first notification of a mute status change
 *      to its owning buffer.
 *
 *  Arguments:
 *      BOOL [in]: mute value.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dObject::SetMute"

HRESULT CMultiPan3dObject::SetMute(BOOL fMute, LPBOOL pfContinue)
{
    HRESULT hr;
    DPF_ENTER();

    m_fUserMute = fMute;
    hr = Commit3dChanges();
    if (SUCCEEDED(hr))
        *pfContinue = FALSE;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  UpdateAlgorithmHrp
 *
 *  Description:
 *      Updates Pan algorithm specific head-relative position.
 *
 *  Arguments:
 *      D3DVECTOR*: new head-relative position vector.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dObject::UpdateAlgorithmHrp"

void CMultiPan3dObject::UpdateAlgorithmHrp(D3DVECTOR* pvHrp)
{
    DPF_ENTER();

    // Save the head-relative position vector (for use in Commit3dChanges)
    m_vHrp = *pvHrp;

    // Update m_spherical.rho too, since the UpdatePositionAttenuation()
    // method in our base class CSw3dObject needs this info
    if (pvHrp->x == 0 && pvHrp->y == 0 && pvHrp->z == 0)
        m_spherical.rho = 0.f;
    else
        m_spherical.rho = MagnitudeVector(pvHrp);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Commit3dChanges
 *
 *  Description:
 *      Commits 3D data to the device
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dObject::Commit3dChanges"

HRESULT CMultiPan3dObject::Commit3dChanges(void)
{
    HRESULT hr;
    LONG lVolume;
    BOOL fMute;
    DWORD dwFrequency;
    int nChannels = m_pPan3dListener->m_nChannels;

    DPF_ENTER();

    if (nChannels == 0)
    {
        DPF(DPFLVL_INFO, "Called before CMultiPan3dListener::SetSpeakerConfig()");
        hr = DS_OK;  // This is OK - we'll be called again later 
    }
    else
    {
        // Calculate values
        if (DS3DMODE_DISABLE == m_opCurrent.dwMode)
        {
            lVolume = m_lUserVolume;
            fMute = m_fUserMute;
            dwFrequency = m_dwUserFrequency;
            for (int i=0; i<nChannels; ++i)
                m_lPanLevels[i] = DSBVOLUME_MAX;
        }
        else
        {
            lVolume = m_lUserVolume + CalculateVolume();
            fMute = m_fUserMute || (lVolume <= DSBVOLUME_MIN);
            dwFrequency = m_dwDopplerFrequency;
            CalculatePanValues(nChannels);
        }
        
        // Apply values
        hr = m_pBuffer->SetMute(fMute);

        if (SUCCEEDED(hr) && m_fDopplerEnabled)
            hr = m_pBuffer->SetBufferFrequency(dwFrequency, TRUE);

        if (SUCCEEDED(hr))
            hr = m_pBuffer->SetAllChannelAttenuations(lVolume, nChannels, m_lPanLevels);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CalculateVolume
 *
 *  Description:
 *      Calculates the volume value based on the object's position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      LONG: Volume.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dObject::CalculateVolume"

LONG CMultiPan3dObject::CalculateVolume(void)
{
    static const double d2000log2 = 602.059991328;  // 2000 * log10(2)
    // FIXME: shouldn't this be 1000 * log10(2)?
    LONG lVolume;
    DPF_ENTER();

    if (IsAtMaxDistance())
        lVolume = DSBVOLUME_MIN;
    else
    {
        double dAttenuation = m_flAttenuation * m_flAttDistance;
        if (dAttenuation > 0.0)
        {
            lVolume = LONG(fylog2x(d2000log2, dAttenuation));
            // Reduce the volume to roughly match the HRTF algorithm's level
            lVolume -= PAN3D_HRTF_ADJUSTMENT;
        }
        else
            lVolume = DSBVOLUME_MIN;
    }

    DPF_LEAVE(lVolume);
    return lVolume;
}


/***************************************************************************
 *
 *  CalculatePanValues
 *
 *  Description:
 *      Calculates the channel levels based on the object's position.
 *
 *  Arguments:
 *      int: number of channels to calculate.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dObject::CalculatePanValues"

void CMultiPan3dObject::CalculatePanValues(int nChannels)
{
    static const double d1000log2 = 301.03; // 1000 * log10(2)
    static const float flThreshold = 2.5;   // FIXME: maybe this should be dynamic

    float xPos = m_vHrp.x, zPos = m_vHrp.z; // Head-relative sound coordinates
    double dAttenuations[MAX_CHANNELS];     // Speaker attenuations calculated
    int i;                                  // Loop counter

    DPF_ENTER();

    // Find the sound's Head-Relative Position vector's length
    // and azimuth angle (see diagram at beginning of this file)
    double dHrpAzimuth = atan2(xPos, zPos);
    double dHrpLength;  // Optimized; calculated below, only if needed

    DPF_MULTI3D(DPFLVL_INFO, "Sound source is at (x=%d.%02d, z=%d.%02d) relative to listener", DPF_DECIMAL(xPos), DPF_DECIMAL(zPos));
    DPF_MULTI3D(DPFLVL_INFO, "Sound source's azimuth angle: %d.%02d", DPF_DECIMAL(dHrpAzimuth));

    // Make the X and Z coordinates positive for convenience
    if (xPos < 0) xPos = -xPos;
    if (zPos < 0) zPos = -zPos;

    if ((xPos < EPSILON) && (zPos < EPSILON))
    {
        // The sound is practically on top of the listener;
        // distribute the signal equally to all speakers
        for (i=0; i<nChannels; ++i)
            dAttenuations[i] = 1.0 / nChannels;
    }
    else
    {
        // Initialize the speaker attenuations to silence
        for (i=0; i<nChannels; ++i)
            dAttenuations[i] = 0.0;

        if ((xPos < flThreshold) && (zPos < flThreshold) &&
            (dHrpLength = sqrt(xPos*xPos + zPos*zPos)) < flThreshold)
        {
            // Within the zero-crossing threshold, we distribute part of the
            // signal to a "phantom sound source" diametrically opposite the
            // real one, to make the crossover a little smoother
            double dPower = 0.5 + dHrpLength / (2.0 * flThreshold);
            DistributeSignal(dPower, dHrpAzimuth, nChannels, dAttenuations);
            DistributeSignal(1.0 - dPower, dHrpAzimuth + PI, nChannels, dAttenuations);
        }
        else
        {
            // Assign all the signal to the two nearest speakers
            DistributeSignal(1.0, dHrpAzimuth, nChannels, dAttenuations);
        }
    }

    // Set up the final channel levels in dsound units (millibels):
    for (i=0; i<nChannels; ++i)
    {
        if (dAttenuations[i] == 0.0)
            m_lPanLevels[i] = DSBVOLUME_MIN;
        else
            m_lPanLevels[i] = LONG(fylog2x(d1000log2, dAttenuations[i]));

        // I.e. m_lPanLevels[i] = 1000 * log10(dAttenuations[i])
        DPF_MULTI3D(DPFLVL_MOREINFO, "Speaker %d: %ld", i, m_lPanLevels[i]);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DistributeSignal
 *
 *  Description:
 *      Calculates the channel levels based on the object's position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dObject::DistributeSignal"

void CMultiPan3dObject::DistributeSignal(double dSignal, double dAzimuth, int nChannels, double dAttenuations[])
{
    DPF_ENTER();

    // Sanity checking
    ASSERT(dSignal >= 0.0 && dSignal <= 1.0);  // Fraction of signal to be distributed
    ASSERT(nChannels > 1);

    // Get the speaker position azimuth angles from our 3D listener
    const double* adSpeakerPos = m_pPan3dListener->m_adSpeakerPos;
    ASSERT(adSpeakerPos != NULL);

    // Calculate the angular distance from each speaker to the HRPV,
    // and choose the two closest speakers on either side of the HRPV
    int nSpk1 = -1, nSpk2 = -1;
    double dSpkDist1 = -4, dSpkDist2 = 4;  // 4 > PI
    for (int i=0; i<nChannels; ++i)
    {
        double dCurDist = dAzimuth - adSpeakerPos[i];

        // Normalize the distance if abs(distance) > PI
        if (dCurDist > PI)
            dCurDist -= PI_TIMES_TWO;
        else if (dCurDist < -PI)
            dCurDist += PI_TIMES_TWO;
            
        if (dCurDist <= 0 && dCurDist > dSpkDist1)
            nSpk1 = i, dSpkDist1 = dCurDist;
        else if (dCurDist >= 0 && dCurDist < dSpkDist2)
            nSpk2 = i, dSpkDist2 = dCurDist;
    }
    if (dSpkDist1 < 0) dSpkDist1 = -dSpkDist1;
    if (dSpkDist2 < 0) dSpkDist2 = -dSpkDist2;

    if (nSpk1 == -1 || nSpk2 == -1)
    {
        DPF(DPFLVL_WARNING, "Couldn't find the two closest speakers! (nSpk1=%d, nSpk2=%d)", nSpk1, nSpk2);
        nSpk1 = nSpk2 = 0;
    }

    DPF_MULTI3D(DPFLVL_INFO, "Found closest speakers: %d (angle %d.%02d, %d.%02d away) and %d (angle %d.%02d, %d.%02d away)",
                nSpk1, DPF_DECIMAL(adSpeakerPos[nSpk1]), DPF_DECIMAL(dSpkDist1),
                nSpk2, DPF_DECIMAL(adSpeakerPos[nSpk2]), DPF_DECIMAL(dSpkDist2));

    if (dSpkDist1 < EPSILON)
        dAttenuations[nSpk1] += dSignal;
    else if (dSpkDist2 < EPSILON)
        dAttenuations[nSpk2] += dSignal;
    else
    {
        // Scale the HRPV's angle between the speakers to the range [0, pi/2]
        // and take the resulting angle's tangent; this is the ratio we want
        // between the powers coming from the two chosen speakers.
        double dRatio = tan(PI_OVER_TWO * dSpkDist1 / (dSpkDist1 + dSpkDist2));

        //                     signal                      signal*ratio
        // Give first speaker --------- and second speaker ------------ :
        //                    1 + ratio                     1 + ratio

        dSignal /= (1.0 + dRatio);
        dAttenuations[nSpk1] += dSignal;
        dAttenuations[nSpk2] += dSignal * dRatio;
    }

    DPF_MULTI3D(DPFLVL_INFO, "Added %d.%02d of signal to speaker %d and %d.%02d to speaker %d",
                DPF_DECIMAL(dAttenuations[nSpk1]), nSpk1, DPF_DECIMAL(dAttenuations[nSpk2]), nSpk2);
                
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *    
 *  SetSpeakerConfig
 *
 *  Description:
 *      Sets the speaker configuration for this 3D listener.
 *
 *  Arguments:
 *      DWORD [in]: speaker configuration.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultiPan3dListener::SetSpeakerConfig"

HRESULT CMultiPan3dListener::SetSpeakerConfig(DWORD dwSpeakerConfig)
{
    DPF_ENTER();

    // First set up our internal speaker config data
    switch (DSSPEAKER_CONFIG(dwSpeakerConfig))
    {
        default:
            DPF(DPFLVL_WARNING, "Invalid speaker config; defaulting to stereo"); // Fallthru

        case DSSPEAKER_DIRECTOUT:
        case DSSPEAKER_STEREO:
        case DSSPEAKER_HEADPHONE:
            m_nChannels = 2; m_adSpeakerPos = m_adStereoSpeakers; break;

        case DSSPEAKER_SURROUND:
            m_nChannels = 4; m_adSpeakerPos = m_adSurroundSpeakers; break;

        case DSSPEAKER_QUAD:
            m_nChannels = 4; m_adSpeakerPos = m_adQuadSpeakers; break;

        case DSSPEAKER_5POINT1:
            m_nChannels = 6; m_adSpeakerPos = m_ad5Point1Speakers; break;

        case DSSPEAKER_7POINT1:
            m_nChannels = 8; m_adSpeakerPos = m_ad7Point1Speakers; break;
    }

    // Call the base class version
    HRESULT hr = C3dListener::SetSpeakerConfig(dwSpeakerConfig);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\mxvad.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mxvad.h
 *  Content:    DirectSound mixer virtual audio device class.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/29/98     dereks  Created
 *
 ***************************************************************************/

#ifndef __MXVAD_H__
#define __MXVAD_H__

#ifdef __cplusplus

// Fwd decl
class CEmSecondaryRenderWaveBuffer;

// The DirectSound mixer audio device class
class CMxRenderDevice 
    : public CRenderDevice
{
public:
    CMixer *                m_pMixer;                           // The mixer object
    CMixDest *              m_pMixDest;                         // The mixer destination object
    LPWAVEFORMATEX          m_pwfxFormat;                       // Device format
    DWORD                   m_dwMixerState;                     // Mixer state

public:
    CMxRenderDevice(VADDEVICETYPE);
    virtual ~CMxRenderDevice(void);

public:
    // Device properties
    virtual HRESULT GetGlobalFormat(LPWAVEFORMATEX, LPDWORD);
    virtual HRESULT SetGlobalFormat(LPCWAVEFORMATEX);
    virtual HRESULT SetSrcQuality(DIRECTSOUNDMIXER_SRCQUALITY);

    // Buffer management
    virtual HRESULT CreateSecondaryBuffer(LPCVADRBUFFERDESC, LPVOID, CSecondaryRenderWaveBuffer **);
    virtual HRESULT CreateEmulatedSecondaryBuffer(LPCVADRBUFFERDESC, LPVOID, CSysMemBuffer *, CEmSecondaryRenderWaveBuffer **);

    // Mixer management
    virtual HRESULT CreateMixer(CMixDest *, LPCWAVEFORMATEX);
    virtual HRESULT SetMixerState(DWORD);
    virtual HRESULT LockMixerDestination(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD) = 0;
    virtual HRESULT UnlockMixerDestination(LPVOID, DWORD, LPVOID, DWORD) = 0;
    virtual void FreeMixer(void);
};

inline HRESULT CMxRenderDevice::SetSrcQuality(DIRECTSOUNDMIXER_SRCQUALITY)
{
    return DSERR_UNSUPPORTED;
}

inline HRESULT CMxRenderDevice::CreateSecondaryBuffer(LPCVADRBUFFERDESC pDesc, LPVOID pvInstance, CSecondaryRenderWaveBuffer **ppBuffer)
{
    return CreateEmulatedSecondaryBuffer(pDesc, pvInstance, NULL, (CEmSecondaryRenderWaveBuffer **)ppBuffer);
}

#endif // __cplusplus

#endif // __MXVAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\perf.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       perf.cpp
 *  Content:    Glitch instrumentation.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/29/00    arthurz Created
 *  03/19/01    duganp  Fixed memory corruption, tidied up
 *
 ***************************************************************************/

#include "dsoundi.h"

#ifdef ENABLE_PERFLOG

// Performance logging parameters
struct {
    PERFLOG_LOGGING_PARAMS Params;
    TRACE_GUID_REGISTRATION TraceGuids[1];
} g_perflogParams;

LARGE_INTEGER g_PerfFrequency;
LONGLONG g_TicksPerRegion;

// Prototypes
void OnPerflogStateChanged(void);


/***************************************************************************
 *
 *  InitializePerflog
 *
 *  Description:
 *      This routine initializes performance logging.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "InitializePerflog"

void InitializePerflog(void)
{
    DPF_ENTER();

    QueryPerformanceFrequency(&g_PerfFrequency);
    g_TicksPerRegion = g_PerfFrequency.QuadPart / 64;

    g_perflogParams.Params.ControlGuid = GUID_DSHOW_CTL;
    g_perflogParams.Params.OnStateChanged = OnPerflogStateChanged;
    g_perflogParams.Params.NumberOfTraceGuids = 1;
    g_perflogParams.Params.TraceGuids[0].Guid = &GUID_DSOUNDGLITCH;

    PerflogInitialize(&g_perflogParams.Params);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  OnPerflogStateChanged
 *
 *  Description:
 *      This routine is called whenever the perf logging state changes,
 *      e.g. a logging client becomes active.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "OnPerflogStateChanged"

void OnPerflogStateChanged(void)
{
    CNode<CDirectSound*>* pDsObj;
    CNode<CDirectSoundSecondaryBuffer*>* pDsBuf;
    DPF_ENTER();

    //
    // Enumerate existing buffers.
    //

    for (pDsObj = g_pDsAdmin->m_lstDirectSound.GetListHead();
         pDsObj != NULL;
         pDsObj = pDsObj->m_pNext)
    {
        for (pDsBuf = pDsObj->m_data->m_lstSecondaryBuffers.GetListHead();
             pDsBuf != NULL;
             pDsBuf = pDsBuf->m_pNext)
        {
            BufferPerfState* PerfState = NEW(BufferPerfState(pDsBuf->m_data));
            if (PerfState != NULL)
            {
                DELETE(pDsBuf->m_data->m_pPerfState);
                pDsBuf->m_data->m_pPerfState = PerfState;
            }
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  BufferPerfState constructor/destructor.
 *
 ***************************************************************************/

BufferPerfState::BufferPerfState(CDirectSoundSecondaryBuffer* pBuffer)
{
    m_pBuffer = pBuffer;
    m_liRegionMap = NULL;
    m_fGlitchState = GLITCHTYPE_DSOUNDFIRSTGOOD;
    m_llLastStateChangeTime = 0;
}

BufferPerfState::~BufferPerfState()
{
    MEMFREE(m_liRegionMap);
}


/***************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      This routine resets the internal state. Following this call,
 *      the buffer is considered up-to-date.
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

void BufferPerfState::Reset()
{
    //
    // Calculate buffer duration.
    //

    m_dwBufferSize = m_pBuffer->GetBufferSize();

    double dBufferDurationInSecs = double(m_dwBufferSize) /
                                   double(m_pBuffer->Format()->nAvgBytesPerSec);


    m_llBufferDuration = LONGLONG(dBufferDurationInSecs * double(g_PerfFrequency.QuadPart));

    m_nBytesPerRegion = m_pBuffer->Format()->nAvgBytesPerSec / 64;

    //
    // Reset the region list (mark everything as updated right now).
    //

    LARGE_INTEGER liTimeStamp;
    QueryPerformanceCounter(&liTimeStamp);

    // This division needs to round up, or we'll corrupt memory in OnUnlockBuffer:
    int nNumberOfRegions = (m_dwBufferSize + m_nBytesPerRegion - 1) / m_nBytesPerRegion;

    MEMFREE(m_liRegionMap);
    m_liRegionMap = MEMALLOC_A(LARGE_INTEGER, nNumberOfRegions);
    if (m_liRegionMap == NULL) {
        return;
    }

    LARGE_INTEGER* pRegion = m_liRegionMap;
    LARGE_INTEGER* pMaxRegion = m_liRegionMap + nNumberOfRegions;

    while (pRegion < pMaxRegion) {
        pRegion->QuadPart = liTimeStamp.QuadPart;
        pRegion += 1;
    }
}


/***************************************************************************
 *
 *  OnUnlockBuffer
 *
 *  Description:
 *      This routine analyzes the buffer state to determine if a glitch
 *      occurred, and updates the state.
 *
 *  Arguments:
 *      Region offset (relative to the beginning of the buffer)
 *      and size (in bytes).
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

void BufferPerfState::OnUnlockBuffer(DWORD dwOffset, DWORD dwSize)
{
    DWORD dwPlayCursor;
    DWORD dwMaxOffset;
    LONGLONG llLag;
    LARGE_INTEGER liPerfCounter;
    LARGE_INTEGER* liRegionTimeStamp;
    HRESULT hr;
    DWORD dwGlitch = GLITCHTYPE_DSOUNDFIRSTGOOD;

    //
    // Protect against unforseen circumstances.
    //

    if (m_liRegionMap == NULL) {
        return;
    }

    QueryPerformanceCounter(&liPerfCounter);

    ENTER_DLL_MUTEX();
    hr = m_pBuffer->GetInternalCursors(&dwPlayCursor, NULL);
    LEAVE_DLL_MUTEX();

    dwMaxOffset = dwOffset + dwSize;

    for (; dwOffset < dwMaxOffset; dwOffset += m_nBytesPerRegion) {

        liRegionTimeStamp = GetRegion(dwOffset);

        //
        // Figure out how far behind the current play cursor we are.
        //

        if (dwPlayCursor < dwOffset) {
            llLag = (LONGLONG)(m_dwBufferSize - dwOffset + dwPlayCursor);
        }
        else {
            llLag = (LONGLONG)(dwPlayCursor - dwOffset);
        }

        llLag = llLag * g_TicksPerRegion / (LONGLONG)m_nBytesPerRegion;    // [llLag] = Ticks

        //
        // Detect a glitch.
        //

        if (liPerfCounter.QuadPart - liRegionTimeStamp->QuadPart >= llLag + m_llBufferDuration) {
            dwGlitch = GLITCHTYPE_DSOUNDFIRSTBAD;
        }

        //
        // Update region.
        //

        liRegionTimeStamp->QuadPart = liPerfCounter.QuadPart;
    }


    if (SUCCEEDED(hr)) {

        // We log a glitch only when the current state is different from the last state,
        // as we are interested only in transitions.  In logging the glitch, we return
        // the last time the buffer was in the other state, as this helps in determining
        // the length of time the buffer is in a certain state.

        if (m_fGlitchState != dwGlitch) {
            PERFLOG_AUDIOGLITCH(ULONG_PTR(this), dwGlitch, liPerfCounter.QuadPart, m_llLastStateChangeTime);
            m_fGlitchState = dwGlitch;
        }
        m_llLastStateChangeTime = liPerfCounter.QuadPart;
    }
}

#endif // ENABLE_PERFLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\perf.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       perf.h
 *  Content:    DirectSound object implementation
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/29/00    arthurz Created
 *
 ***************************************************************************/

#ifndef __PERF_H__
#define __PERF_H__

#ifdef __cplusplus

#include <dxmperf.h>

void InitializePerflog(void);

class BufferPerfState
{
public:
    BufferPerfState(CDirectSoundSecondaryBuffer*);
    ~BufferPerfState();
    void Reset();
    void OnUnlockBuffer(DWORD dwOffset, DWORD dwSize);

private:
    LARGE_INTEGER* GetRegion(DWORD dwOffset) {return m_liRegionMap + dwOffset/m_nBytesPerRegion;}

    CDirectSoundSecondaryBuffer* m_pBuffer;
    LONGLONG m_llBufferDuration; // Measured in QPC ticks
    DWORD m_dwBufferSize;
    int m_nBytesPerRegion;
    LARGE_INTEGER* m_liRegionMap;
    LONGLONG m_llLastStateChangeTime; // Stores the last QPC tick count when the buffer unlock code was last called.
    BOOL m_fGlitchState; // Stores the last state (Glitch or no Glitch) when the buffer unlock code was last called.
};

#endif // __cplusplus
#endif // __PERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\pnphlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pnphlp.c
 *  Content:    PnP helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/17/97    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CPnpHelper
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::CPnpHelper"

CPnpHelper::CPnpHelper(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CPnpHelper);

    InitStruct(&m_dlSetupApi, sizeof(m_dlSetupApi));

    m_hDeviceInfoSet = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CPnpHelper
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::~CPnpHelper"

CPnpHelper::~CPnpHelper(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CPnpHelper);

    if(IsValidHandleValue(m_hDeviceInfoSet))
    {
        CloseDeviceInfoSet(m_hDeviceInfoSet);
    }

    FreeDynaLoadTable(&m_dlSetupApi.Header);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the PnP function table.
 *
 *  Arguments:
 *      REFGUID [in]: class GUID.
 *      DWORD [in]: SetupDiGetClassDevs flags.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::Initialize"

HRESULT 
CPnpHelper::Initialize
(
    REFGUID                 guidClass,
    DWORD                   dwFlags
)
{
    const LPCSTR apszFunctions[] =
    {
        UNICODE_FUNCTION_NAME("SetupDiGetClassDevs"),
        "SetupDiDestroyDeviceInfoList",
        "SetupDiEnumDeviceInfo",
        "SetupDiEnumDeviceInterfaces",
        UNICODE_FUNCTION_NAME("SetupDiGetDeviceInterfaceDetail"),
        "SetupDiOpenDevRegKey",
        UNICODE_FUNCTION_NAME("SetupDiCreateDevRegKey"),
        UNICODE_FUNCTION_NAME("SetupDiGetDeviceRegistryProperty"),
    };


    HRESULT                 hr          = DS_OK;
    BOOL                    fSuccess;
    
    DPF_ENTER();

    // Initialize the function table
    fSuccess = InitDynaLoadTable(TEXT("setupapi.dll"), apszFunctions, NUMELMS(apszFunctions), &m_dlSetupApi.Header);

    if(!fSuccess)
    {
        DPF(DPFLVL_ERROR, "Unable to initialize setupapi function table");
        hr = DSERR_GENERIC;
    }

    // Open the device information set
    if(SUCCEEDED(hr))
    {
        hr = OpenDeviceInfoSet(guidClass, dwFlags, &m_hDeviceInfoSet);
    }

    DPF_LEAVE_HRESULT(hr);
    
    return hr;
}


/***************************************************************************
 *
 *  OpenDeviceInfoSet
 *
 *  Description:
 *      Opens a device information set.
 *
 *  Arguments:
 *      REFGUID [in]: class GUID.
 *      DWORD [in]: SetupDiGetClassDevs flags.
 *      HDEVINFO * [out]: receives device information set handle.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::OpenDeviceInfoSet"

HRESULT 
CPnpHelper::OpenDeviceInfoSet
(
    REFGUID                 guidClass,
    DWORD                   dwFlags,
    HDEVINFO *              phDeviceInfoSet
)
{
    HDEVINFO                hDeviceInfoSet  = NULL;
    HRESULT                 hr              = DS_OK;

    DPF_ENTER();

    if(IS_NULL_GUID(&guidClass))
    {
        dwFlags |= DIGCF_ALLCLASSES;
    }

    hDeviceInfoSet = m_dlSetupApi.SetupDiGetClassDevs(&guidClass, NULL, NULL, dwFlags);

    if(!IsValidHandleValue(hDeviceInfoSet))
    {
        DPF(DPFLVL_ERROR, "Can't open device info set (%lu)", GetLastError());
        hr = GetLastErrorToHRESULT();
    }

    if(SUCCEEDED(hr))
    {
        *phDeviceInfoSet = hDeviceInfoSet;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CloseDeviceInfoSet
 *
 *  Description:
 *      Closes a device information set.
 *
 *  Arguments:
 *      HDEVINFO [in]: device information set HDEVINFO.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::CloseDeviceInfoSet"

HRESULT 
CPnpHelper::CloseDeviceInfoSet
(
    HDEVINFO                hDeviceInfoSet
)
{
    HRESULT                 hr          = DS_OK;
    BOOL                    fSuccess;
    
    DPF_ENTER();

    fSuccess = m_dlSetupApi.SetupDiDestroyDeviceInfoList(hDeviceInfoSet);

    if(!fSuccess)
    {
        DPF(DPFLVL_ERROR, "Can't destroy device info set (%lu)", GetLastError());
        hr = GetLastErrorToHRESULT();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EnumDevice
 *
 *  Description:
 *      Enumerates device in a given information set.
 *
 *  Arguments:
 *      DWORD [in]: device index.
 *      PSP_DEVINFO_DATA [out]: receives device information.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.  This function returns S_FALSE
 *               if no more items are available.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::EnumDevice"

HRESULT 
CPnpHelper::EnumDevice
(
    DWORD                   dwMemberIndex, 
    PSP_DEVINFO_DATA        pDeviceInfoData
)
{
    HRESULT                 hr          = DS_OK;
    BOOL                    fSuccess;

    DPF_ENTER();
    
    InitStruct(pDeviceInfoData, sizeof(*pDeviceInfoData));
    
    fSuccess = m_dlSetupApi.SetupDiEnumDeviceInfo(m_hDeviceInfoSet, dwMemberIndex, pDeviceInfoData);

    if(!fSuccess)
    {
        if(ERROR_NO_MORE_ITEMS == GetLastError())
        {
            hr = S_FALSE;
        }
        else
        {
            DPF(DPFLVL_ERROR, "SetupDiEnumDeviceInfo failed with %lu", GetLastError());
            hr = GetLastErrorToHRESULT();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FindDevice
 *
 *  Description:
 *      Finds a device interface by devnode.
 *
 *  Arguments:
 *      DWORD [in]: devnode.
 *      PSP_DEVINFO_DATA [out]: receives device information.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::FindDevice"

HRESULT 
CPnpHelper::FindDevice
(
    DWORD                   dwDevnode,
    PSP_DEVINFO_DATA        pDeviceInfoData
)
{
    DWORD                   dwMemberIndex   = 0;
    BOOL                    fFoundIt        = FALSE;
    HRESULT                 hr              = DS_OK;
    SP_DEVINFO_DATA         DeviceInfoData;

    DPF_ENTER();

    // Enumerate the devices looking for a devnode match

#ifdef DEBUG
    while(TRUE)
#else // DEBUG
    while(!fFoundIt)
#endif // DEBUG

    {
        hr = EnumDevice(dwMemberIndex++, &DeviceInfoData);

        if(DS_OK != hr)
        {
            break;
        }
        
        // DPF(DPFLVL_MOREINFO, "Found 0x%8.8lX", DeviceInfoData.DevInst);  // Too noisy
        
        if(DeviceInfoData.DevInst == dwDevnode)
        {
            if(!fFoundIt)
            {
                fFoundIt = TRUE;
                CopyMemory(pDeviceInfoData, &DeviceInfoData, sizeof(DeviceInfoData));
            }
            else
            {
                DPF(DPFLVL_ERROR, "Found extra device 0x%8.8lX in device information set", dwDevnode);
                ASSERT(!fFoundIt);
            }
        }
    }

    if(S_FALSE == hr)
    {
        hr = DS_OK;
    }

    if(SUCCEEDED(hr) && !fFoundIt)
    {
        hr = DSERR_GENERIC;
    }

    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Can't find devnode 0x%8.8lX", dwDevnode);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EnumDeviceInterface
 *
 *  Description:
 *      Enumerates device interfaces in a given information set.
 *
 *  Arguments:
 *      REFGUID [in]: interface class guid.
 *      DWORD [in]: interface index.
 *      PSP_DEVICE_INTERFACE_DATA [out]: receives device interface data.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.  This function returns S_FALSE
 *               if no more items are available.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::EnumDeviceInterface"

HRESULT 
CPnpHelper::EnumDeviceInterface
(
    REFGUID                     guidClass, 
    DWORD                       dwMemberIndex, 
    PSP_DEVICE_INTERFACE_DATA   pDeviceInterfaceData
)
{
    HRESULT                     hr          = DS_OK;
    BOOL                        fSuccess;

    DPF_ENTER();
    
    InitStruct(pDeviceInterfaceData, sizeof(*pDeviceInterfaceData));
    
    fSuccess = m_dlSetupApi.SetupDiEnumDeviceInterfaces(m_hDeviceInfoSet, NULL, &guidClass, dwMemberIndex, pDeviceInterfaceData);

    if(!fSuccess)
    {
        if(ERROR_NO_MORE_ITEMS == GetLastError())
        {
            hr = S_FALSE;
        }
        else
        {
            DPF(DPFLVL_ERROR, "SetupDiEnumDeviceInterfaces failed with %lu", GetLastError());
            hr = GetLastErrorToHRESULT();
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FindDeviceInterface
 *
 *  Description:
 *      Finds a device interface by name.
 *
 *  Arguments:
 *      LPWSTR [in]: device interface path.
 *      REFGUID [in]: interface class GUID.
 *      PSP_DEVICE_INTERFACE_DATA [out]: receives device interface data.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::FindDeviceInterface"

HRESULT 
CPnpHelper::FindDeviceInterface
(
    LPCTSTR                     pszInterface,
    REFGUID                     guidClass,
    PSP_DEVICE_INTERFACE_DATA   pDeviceInterfaceData
)
{
    LPTSTR                      pszThisInterface    = NULL;
    DWORD                       dwMemberIndex       = 0;
    BOOL                        fFoundIt            = FALSE;
    HRESULT                     hr                  = DS_OK;
    SP_DEVICE_INTERFACE_DATA    DeviceInterfaceData;

    DPF_ENTER();

    // Enumerate the device interfaces matching the interface class GUID
    // in this device set
    InitStruct(&DeviceInterfaceData, sizeof(DeviceInterfaceData));

#ifdef DEBUG
    while(TRUE)
#else // DEBUG
    while(!fFoundIt)
#endif // DEBUG

    {
        hr = EnumDeviceInterface(guidClass, dwMemberIndex++, &DeviceInterfaceData);

        if(DS_OK != hr)
        {
            break;
        }

        hr = GetDeviceInterfacePath(&DeviceInterfaceData, &pszThisInterface);

        if(SUCCEEDED(hr))
        {
            DPF(DPFLVL_MOREINFO, "Found %s", pszThisInterface);
        }
        
        if(SUCCEEDED(hr) && !lstrcmpi(pszInterface, pszThisInterface))
        {
            if(!fFoundIt)
            {
                fFoundIt = TRUE;
                CopyMemory(pDeviceInterfaceData, &DeviceInterfaceData, sizeof(DeviceInterfaceData));
            }
            else
            {
                DPF(DPFLVL_ERROR, "Found extra device interface %s in device information set", pszInterface);
                ASSERT(!fFoundIt);
            }
        }

        MEMFREE(pszThisInterface);
    }

    if(S_FALSE == hr)
    {
        hr = DS_OK;
    }
    
    if(SUCCEEDED(hr) && !fFoundIt)
    {
        hr = DSERR_GENERIC;
    }
    
    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Can't find interface %s", pszInterface);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDeviceInterfaceDeviceInfo
 *
 *  Description:
 *      Gets device info for a given device interface.
 *
 *  Arguments:
 *      PSP_DEVICE_INTERFACE_DATA [in]: device interface data.
 *      PSP_DEVINFO_DATA [out]: receives device info data.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::GetDeviceInterfaceDeviceInfo"

HRESULT 
CPnpHelper::GetDeviceInterfaceDeviceInfo
(
    PSP_DEVICE_INTERFACE_DATA   pDeviceInterfaceData,
    PSP_DEVINFO_DATA            pDeviceInfoData
)
{
    HRESULT                     hr  = DS_OK;
    BOOL                        fSuccess;

    DPF_ENTER();

    InitStruct(pDeviceInfoData, sizeof(*pDeviceInfoData));
    
    fSuccess = m_dlSetupApi.SetupDiGetDeviceInterfaceDetail(m_hDeviceInfoSet, pDeviceInterfaceData, NULL, 0, NULL, pDeviceInfoData);

    if(!fSuccess && ERROR_INSUFFICIENT_BUFFER != GetLastError())
    {
        DPF(DPFLVL_ERROR, "Can't get device interface detail (%lu)", GetLastError());
        hr = GetLastErrorToHRESULT();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDeviceInterfaceDeviceInfo
 *
 *  Description:
 *      Gets device info for a given device interface.
 *
 *  Arguments:
 *      LPCTSTR [in]: device interface path.
 *      REFGUID [in]: device interface class.
 *      PSP_DEVINFO_DATA [out]: receives device info data.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::GetDeviceInterfaceDeviceInfo"

HRESULT 
CPnpHelper::GetDeviceInterfaceDeviceInfo
(
    LPCTSTR                     pszInterface,
    REFGUID                     guidClass,
    PSP_DEVINFO_DATA            pDeviceInfoData
)
{
    SP_DEVICE_INTERFACE_DATA    DeviceInterfaceData;
    HRESULT                     hr;

    DPF_ENTER();

    InitStruct(&DeviceInterfaceData, sizeof(DeviceInterfaceData));

    hr = FindDeviceInterface(pszInterface, guidClass, &DeviceInterfaceData);

    if(SUCCEEDED(hr))
    {
        hr = GetDeviceInterfaceDeviceInfo(&DeviceInterfaceData, pDeviceInfoData);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDeviceInterfacePath
 *
 *  Description:
 *      Gets detailed information about a device interface.
 *
 *  Arguments:
 *      PSP_DEVICE_INTERFACE_DATA [in]: device interface data.
 *      LPTSTR * [out]: receives pointer to interface path.  This buffer 
 *                      must be freed by the caller.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::GetDeviceInterfacePath"

HRESULT 
CPnpHelper::GetDeviceInterfacePath
(
    PSP_DEVICE_INTERFACE_DATA           pDeviceInterfaceData,
    LPTSTR *                            ppszInterfacePath
)
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pDeviceInterfaceDetailData  = NULL;
    LPTSTR                              pszInterfacePath            = NULL;
    HRESULT                             hr                          = DS_OK;
    DWORD                               dwSize;
    BOOL                                fSuccess;

    DPF_ENTER();

    fSuccess = m_dlSetupApi.SetupDiGetDeviceInterfaceDetail(m_hDeviceInfoSet, pDeviceInterfaceData, NULL, 0, &dwSize, NULL);

    if(fSuccess || ERROR_INSUFFICIENT_BUFFER != GetLastError())
    {
        DPF(DPFLVL_ERROR, "Can't get interface detail size (%lu)", GetLastError());
        hr = GetLastErrorToHRESULT();
    }
    
    if(SUCCEEDED(hr))
    {
        pDeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)MEMALLOC_A(BYTE, dwSize);
        hr = HRFROMP(pDeviceInterfaceDetailData);
    }

    if(SUCCEEDED(hr))
    {
        InitStruct(pDeviceInterfaceDetailData, sizeof(*pDeviceInterfaceDetailData));
        
        fSuccess = m_dlSetupApi.SetupDiGetDeviceInterfaceDetail(m_hDeviceInfoSet, pDeviceInterfaceData, pDeviceInterfaceDetailData, dwSize, NULL, NULL);

        if(!fSuccess)
        {
            DPF(DPFLVL_ERROR, "Can't get device interface detail (%lu)", GetLastError());
            hr = GetLastErrorToHRESULT();
        }
    }

    if(SUCCEEDED(hr))
    {
        pszInterfacePath = MEMALLOC_A_COPY(TCHAR, lstrlen(pDeviceInterfaceDetailData->DevicePath) + 1, pDeviceInterfaceDetailData->DevicePath);
        hr = HRFROMP(pszInterfacePath);
    }

    if(SUCCEEDED(hr))
    {
        *ppszInterfacePath = pszInterfacePath;
    }
    else
    {
        MEMFREE(pszInterfacePath);
    }

    MEMFREE(pDeviceInterfaceDetailData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  OpenDeviceRegistryKey
 *
 *  Description:
 *      Opens the root registry key for a given device.
 *
 *  Arguments:
 *      PSP_DEVINFO_DATA [in]: device information.
 *      DWORD [in]: key type: DIREG_DEV or DIREG_DRV.
 *      BOOL [in]: TRUE to allow creation.
 *      PHKEY [out]: receives registry key handle.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::OpenDeviceRegistryKey"

HRESULT 
CPnpHelper::OpenDeviceRegistryKey
(
    PSP_DEVINFO_DATA        pDeviceInfoData,
    DWORD                   dwKeyType,
    BOOL                    fAllowCreate,
    PHKEY                   phkey
)
{
    HKEY                    hkey    = NULL;
    HRESULT                 hr      = DS_OK;
    UINT                    i;

    DPF_ENTER();

    ASSERT(DIREG_DEV == dwKeyType || DIREG_DRV == dwKeyType);
    
    for(i = 0; i < NUMELMS(g_arsRegOpenKey) && !IsValidHandleValue(hkey); i++)
    {
        hkey = m_dlSetupApi.SetupDiOpenDevRegKey(m_hDeviceInfoSet, pDeviceInfoData, DICS_FLAG_CONFIGSPECIFIC, 0, dwKeyType, g_arsRegOpenKey[i]);
    }

    if(!IsValidHandleValue(hkey) && fAllowCreate)
    {
        hkey = m_dlSetupApi.SetupDiCreateDevRegKey(m_hDeviceInfoSet, pDeviceInfoData, DICS_FLAG_CONFIGSPECIFIC, 0, dwKeyType, NULL, NULL);
    }

    if(!IsValidHandleValue(hkey))
    {
        DPF(DPFLVL_ERROR, "Unable to open device registry key (%lu)", GetLastError());
        hr = GetLastErrorToHRESULT();
    }

    if(SUCCEEDED(hr))
    {
        *phkey = hkey;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  OpenDeviceInterfaceRegistryKey
 *
 *  Description:
 *      Opens the root registry key for a given device.
 *
 *  Arguments:
 *      PSP_DEVINFO_DATA [in]: device information.
 *      DWORD [in]: key type: DIREG_DEV or DIREG_DRV.
 *      BOOL [in]: TRUE to allow creation.
 *      PHKEY [out]: receives registry key handle.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::OpenDeviceInterfaceRegistryKey"

HRESULT 
CPnpHelper::OpenDeviceInterfaceRegistryKey
(
    LPCTSTR                 pszInterface,
    REFGUID                 guidClass,
    DWORD                   dwKeyType,
    BOOL                    fAllowCreate,
    PHKEY                   phkey
)
{
    SP_DEVINFO_DATA         DeviceInfoData;
    HRESULT                 hr;

    DPF_ENTER();
    
    hr = GetDeviceInterfaceDeviceInfo(pszInterface, guidClass, &DeviceInfoData);

    if(SUCCEEDED(hr))
    {
        hr = OpenDeviceRegistryKey(&DeviceInfoData, dwKeyType, fAllowCreate, phkey);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDeviceRegistryProperty
 *
 *  Description:
 *      Gets a registry property for a given device interface.
 *
 *  Arguments:
 *      PSP_DEVINFO_DATA [in]: device info.
 *      DWORD [in]: property id.
 *      LPDWORD [out]: receives property registry data type.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: property buffer size.
 *      LPDWORD [out]: receives required buffer size.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::GetDeviceRegistryProperty"

HRESULT 
CPnpHelper::GetDeviceRegistryProperty
(
    PSP_DEVINFO_DATA            pDeviceInfoData,
    DWORD                       dwProperty,
    LPDWORD                     pdwPropertyRegDataType, 
    LPVOID                      pvPropertyBuffer,
    DWORD                       dwPropertyBufferSize,
    LPDWORD                     pdwRequiredSize 
)
{
    HRESULT                     hr          = DS_OK;
    BOOL                        fSuccess;

    DPF_ENTER();

    fSuccess = m_dlSetupApi.SetupDiGetDeviceRegistryProperty(m_hDeviceInfoSet, pDeviceInfoData, dwProperty, pdwPropertyRegDataType, (LPBYTE)pvPropertyBuffer, dwPropertyBufferSize, pdwRequiredSize);

    if(!fSuccess && ERROR_INSUFFICIENT_BUFFER != GetLastError())
    {
        DPF(DPFLVL_ERROR, "Can't get device registry property (%lu)", GetLastError());
        hr = GetLastErrorToHRESULT();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDeviceInterfaceRegistryProperty
 *
 *  Description:
 *      Gets a registry property for a given device interface.
 *
 *  Arguments:
 *      LPCTSTR [in]: device interface.
 *      REFGUID [in]: interface class.
 *      DWORD [in]: property id.
 *      LPDWORD [out]: receives property registry data type.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: property buffer size.
 *      LPDWORD [out]: receives required buffer size.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::GetDeviceInterfaceRegistryProperty"

HRESULT 
CPnpHelper::GetDeviceInterfaceRegistryProperty
(
    LPCTSTR                     pszInterface,
    REFGUID                     guidClass,
    DWORD                       dwProperty,
    LPDWORD                     pdwPropertyRegDataType, 
    LPVOID                      pvPropertyBuffer,
    DWORD                       dwPropertyBufferSize,
    LPDWORD                     pdwRequiredSize 
)
{
    SP_DEVINFO_DATA             DeviceInfoData;
    HRESULT                     hr;

    DPF_ENTER();

    hr = GetDeviceInterfaceDeviceInfo(pszInterface, guidClass, &DeviceInfoData);

    if(SUCCEEDED(hr))
    {
        hr = GetDeviceRegistryProperty(&DeviceInfoData, dwProperty, pdwPropertyRegDataType, pvPropertyBuffer, dwPropertyBufferSize, pdwRequiredSize);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  OpenDeviceInterface
 *
 *  Description:
 *      Opens a device interface.
 *
 *  Arguments:
 *      LPCTSTR [in]: interface path.
 *      LPHANDLE [out]: receives device handle.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::OpenDeviceInterface"

HRESULT 
CPnpHelper::OpenDeviceInterface
(
    LPCTSTR                 pszInterface,
    LPHANDLE                phDevice
)
{
    HRESULT                 hr      = DS_OK;
    HANDLE                  hDevice;
    
    DPF_ENTER();

    hDevice = CreateFile(pszInterface, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

    if(!IsValidHandleValue(hDevice))
    {
        DPF(DPFLVL_ERROR, "CreateFile failed to open %s with error %lu", pszInterface, GetLastError());
        hr = GetLastErrorToHRESULT();
    }

    if(SUCCEEDED(hr))
    {
        *phDevice = hDevice;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  OpenDeviceInterface
 *
 *  Description:
 *      Opens a device interface.
 *
 *  Arguments:
 *      PSP_DEVICE_INTERFACE_DATA [in]: device interface data.
 *      LPHANDLE [out]: receives device handle.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPnpHelper::OpenDeviceInterface"

HRESULT 
CPnpHelper::OpenDeviceInterface
(
    PSP_DEVICE_INTERFACE_DATA   pDeviceInterfaceData,
    LPHANDLE                    phDevice
)
{
    LPTSTR                      pszInterface    = NULL;
    HRESULT                     hr              = DS_OK;
    
    DPF_ENTER();

    hr = GetDeviceInterfacePath(pDeviceInterfaceData, &pszInterface);

    if(SUCCEEDED(hr))
    {
        hr = OpenDeviceInterface(pszInterface, phDevice);
    }

    MEMFREE(pszInterface);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\pnphlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pnphlp.h
 *  Content:    PnP helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/17/97    dereks  Created.
 *
 ***************************************************************************/

#ifndef __PNPHLP_H__
#define __PNPHLP_H__

#include <setupapi.h>
#include <cfgmgr32.h>

typedef struct tagDYNALOAD_SETUPAPI
{
    DYNALOAD    Header;

    // Begin function table...
    HDEVINFO (WINAPI *SetupDiGetClassDevs)(LPCGUID, LPCTSTR, HWND, DWORD);
    BOOL (WINAPI *SetupDiDestroyDeviceInfoList)(HDEVINFO);
    BOOL (WINAPI *SetupDiEnumDeviceInfo)(HDEVINFO, DWORD, PSP_DEVINFO_DATA);
    BOOL (WINAPI *SetupDiEnumDeviceInterfaces)(HDEVINFO, PSP_DEVINFO_DATA, LPCGUID, DWORD, PSP_DEVICE_INTERFACE_DATA);
    BOOL (WINAPI *SetupDiGetDeviceInterfaceDetail)(HDEVINFO, PSP_DEVICE_INTERFACE_DATA, PSP_DEVICE_INTERFACE_DETAIL_DATA, DWORD, LPDWORD, PSP_DEVINFO_DATA);
    HKEY (WINAPI *SetupDiOpenDevRegKey)(HDEVINFO, PSP_DEVINFO_DATA, DWORD, DWORD, DWORD, REGSAM);
    HKEY (WINAPI *SetupDiCreateDevRegKey)(HDEVINFO, PSP_DEVINFO_DATA, DWORD, DWORD, DWORD, HINF, PCSTR);
    BOOL (WINAPI *SetupDiGetDeviceRegistryProperty)(HDEVINFO, PSP_DEVINFO_DATA, DWORD, LPDWORD, LPBYTE, DWORD, LPDWORD); 
} DYNALOAD_SETUPAPI, *LPDYNALOAD_SETUPAPI;

#ifdef __cplusplus

// The PnP helper object
class CPnpHelper
    : public CDsBasicRuntime
{
private:
    DYNALOAD_SETUPAPI           m_dlSetupApi;
    HDEVINFO                    m_hDeviceInfoSet;

public:
    CPnpHelper(void);
    virtual ~CPnpHelper(void);

public:
    // Initialization
    virtual HRESULT Initialize(REFGUID, DWORD);

    // Devices
    virtual HRESULT EnumDevice(DWORD, PSP_DEVINFO_DATA);
    virtual HRESULT FindDevice(DWORD, PSP_DEVINFO_DATA);
    virtual HRESULT OpenDeviceRegistryKey(PSP_DEVINFO_DATA, DWORD, BOOL, PHKEY);
    virtual HRESULT GetDeviceRegistryProperty(PSP_DEVINFO_DATA, DWORD, LPDWORD, LPVOID, DWORD, LPDWORD);

    // Device interfaces
    virtual HRESULT EnumDeviceInterface(REFGUID, DWORD, PSP_DEVICE_INTERFACE_DATA);
    virtual HRESULT FindDeviceInterface(LPCTSTR, REFGUID, PSP_DEVICE_INTERFACE_DATA);
    virtual HRESULT GetDeviceInterfaceDeviceInfo(PSP_DEVICE_INTERFACE_DATA, PSP_DEVINFO_DATA);
    virtual HRESULT GetDeviceInterfaceDeviceInfo(LPCTSTR, REFGUID, PSP_DEVINFO_DATA);
    virtual HRESULT GetDeviceInterfacePath(PSP_DEVICE_INTERFACE_DATA, LPTSTR *);
    virtual HRESULT OpenDeviceInterfaceRegistryKey(LPCTSTR, REFGUID, DWORD, BOOL, PHKEY);
    virtual HRESULT GetDeviceInterfaceRegistryProperty(LPCTSTR, REFGUID, DWORD, LPDWORD, LPVOID, DWORD, LPDWORD);
    virtual HRESULT OpenDeviceInterface(LPCTSTR, LPHANDLE);
    virtual HRESULT OpenDeviceInterface(PSP_DEVICE_INTERFACE_DATA, LPHANDLE);

private:
    virtual HRESULT OpenDeviceInfoSet(REFGUID, DWORD, HDEVINFO *);
    virtual HRESULT CloseDeviceInfoSet(HDEVINFO);
};

#endif // __cplusplus

#endif // __PNPHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\pset.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pset.h
 *  Content:    Property Set object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  7/29/98     dereks  Created
 *
 ***************************************************************************/

#ifndef __PSET_H__
#define __PSET_H__

typedef HRESULT (WINAPI *LPFNGETHANDLER)(LPVOID, LPVOID, PULONG);
typedef HRESULT (WINAPI *LPFNSETHANDLER)(LPVOID, LPVOID, ULONG);

typedef struct tagPROPERTYHANDLER
{
    ULONG                   ulProperty;
    LPFNGETHANDLER          pfnGetHandler;
    LPFNSETHANDLER          pfnSetHandler;
    ULONG                   cbData;
} PROPERTYHANDLER, *LPPROPERTYHANDLER;

typedef const PROPERTYHANDLER *LPCPROPERTYHANDLER;

typedef struct tagPROPERTYSET
{
    LPCGUID                 pguidPropertySetId;
    ULONG                   cProperties;
    LPCPROPERTYHANDLER      aPropertyHandlers;
} PROPERTYSET, *LPPROPERTYSET;

typedef const PROPERTYSET *LPCPROPERTYSET;

#define GET_PROPERTY_HANDLER_NAME(set) \
            m_aPropertyHandlers_##set

#define BEGIN_DECLARE_PROPERTY_HANDLERS(classname, set) \
            const PROPERTYHANDLER classname##::##GET_PROPERTY_HANDLER_NAME(set)##[] = \
            {

#define DECLARE_PROPERTY_HANDLER3(property, get, set, datasize) \
                { \
                    property, \
                    (LPFNGETHANDLER)(get), \
                    (LPFNSETHANDLER)(set), \
                    datasize \
                },

#define DECLARE_PROPERTY_HANDLER2(property, get, set, datatype) \
                DECLARE_PROPERTY_HANDLER3(property, get, set, sizeof(datatype))

#define DECLARE_PROPERTY_HANDLER(property, get, set) \
                DECLARE_PROPERTY_HANDLER2(property, get, set, property##_DATA)

#define END_DECLARE_PROPERTY_HANDLERS() \
            };

#define BEGIN_DECLARE_PROPERTY_SETS(classname, membername) \
            const PROPERTYSET classname##::##membername##[] = \
            {

#define DECLARE_PROPERTY_SET(classname, set) \
                { \
                    &##set, \
                    NUMELMS(classname##::##GET_PROPERTY_HANDLER_NAME(set)), \
                    classname##::##GET_PROPERTY_HANDLER_NAME(set) \
                },

#define END_DECLARE_PROPERTY_SETS() \
            };

#define DECLARE_PROPERTY_HANDLER_DATA_MEMBER(set) \
    static const PROPERTYHANDLER GET_PROPERTY_HANDLER_NAME(set)[];

#define DECLARE_PROPERTY_SET_DATA_MEMBER(membername) \
    static const PROPERTYSET membername##[];

#ifdef __cplusplus

// Base class for property set objects
class CPropertySet
    : public CDsBasicRuntime
{
public:
    CPropertySet(void);
    virtual ~CPropertySet(void);

public:
    // Property support
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG) = 0;
    
    // Property data
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG) = 0;
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG) = 0;
};

// Property set handler object
class CPropertySetHandler
{
private:
    LPCPROPERTYSET          m_aPropertySets;    // Supported property sets
    ULONG                   m_cPropertySets;    // Count of supported property sets
    LPVOID                  m_pvContext;        // Context argument

public:
    CPropertySetHandler(void);
    virtual ~CPropertySetHandler(void);

public:
    // Property handler setup
    virtual void SetHandlerData(LPCPROPERTYSET, ULONG, LPVOID);
    
    // Property support
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG);
    
    // Property data
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);

protected:
    // Unsupported property handlers
    virtual HRESULT UnsupportedQueryHandler(REFGUID, ULONG, PULONG);
    virtual HRESULT UnsupportedGetHandler(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT UnsupportedSetHandler(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);

private:
    // The proper handler
    virtual LPCPROPERTYHANDLER GetPropertyHandler(REFGUID, ULONG);
};

inline HRESULT CPropertySetHandler::UnsupportedQueryHandler(REFGUID, ULONG, PULONG)
{
    return DSERR_UNSUPPORTED;
}

inline HRESULT CPropertySetHandler::UnsupportedGetHandler(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG)
{
    return DSERR_UNSUPPORTED;
}

inline HRESULT CPropertySetHandler::UnsupportedSetHandler(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG)
{
    return DSERR_UNSUPPORTED;
}

// Wrapper property set object
class CWrapperPropertySet
    : public CPropertySet
{
protected:
    CPropertySet *          m_pPropertySet; // Pointer to the real property set object

public:
    CWrapperPropertySet(void);
    virtual ~CWrapperPropertySet(void);

public:
    // The actual property set object
    virtual HRESULT SetObjectPointer(CPropertySet *);

    // Property support
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG);
    
    // Property data
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);
};

#endif // __cplusplus

#endif // __PSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\pset.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pset.cpp
 *  Content:    Property Set object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  7/29/98     dereks  Created
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CPropertySet
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPropertySet::CPropertySet"

CPropertySet::CPropertySet(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CPropertySet);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CPropertySet
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPropertySet::~CPropertySet"

CPropertySet::~CPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CPropertySet);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CPropertySetHandler
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPropertySetHandler::CPropertySetHandler"

CPropertySetHandler::CPropertySetHandler(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CPropertySetHandler);
    
    // Initialize defaults
    m_aPropertySets = NULL;
    m_cPropertySets = 0;
    m_pvContext = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CPropertySetHandler
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPropertySetHandler::~CPropertySetHandler"

CPropertySetHandler::~CPropertySetHandler(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CPropertySetHandler);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetHandlerData
 *
 *  Description:
 *      Sets up the handler data structures.
 *
 *  Arguments:
 *      LPPROPERTYSET [in]: property set handler data.
 *      ULONG [in]: count of items in the above array.
 *      LPVOID [in]: context argument passed to handler functions.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPropertySetHandler::SetHandlerData"

void
CPropertySetHandler::SetHandlerData
(
    LPCPROPERTYSET          aPropertySets, 
    ULONG                   cPropertySets, 
    LPVOID                  pvContext
)
{
    DPF_ENTER();

    m_aPropertySets = aPropertySets;
    m_cPropertySets = cPropertySets;
    m_pvContext = pvContext;    

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for support of a particular property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      PULONG [out]: receives support bits.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPropertySetHandler::QuerySupport"

HRESULT 
CPropertySetHandler::QuerySupport
(
    REFGUID                 guidPropertySet, 
    ULONG                   ulProperty, 
    PULONG                  pulSupportFlags
)
{
    HRESULT                 hr          = DS_OK;
    LPCPROPERTYHANDLER      pHandler;

    DPF_ENTER();
    
    pHandler = GetPropertyHandler(guidPropertySet, ulProperty);

    if(pHandler)
    {
        ASSERT(pHandler->pfnGetHandler || pHandler->pfnSetHandler);
        
        *pulSupportFlags = 0;
    
        if(pHandler->pfnGetHandler)
        {
            *pulSupportFlags |= KSPROPERTY_SUPPORT_GET;
        }

        if(pHandler->pfnSetHandler)
        {
            *pulSupportFlags |= KSPROPERTY_SUPPORT_SET;
        }
    }
    else
    {
        hr = UnsupportedQueryHandler(guidPropertySet, ulProperty, pulSupportFlags);
    }

    DPF_LEAVE(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetProperty
 *
 *  Description:
 *      Gets the value of a particular property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: property parameters size.
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPropertySetHandler::GetProperty"

HRESULT 
CPropertySetHandler::GetProperty
(
    REFGUID                 guidPropertySet, 
    ULONG                   ulProperty, 
    LPVOID                  pvParam, 
    ULONG                   cbParam, 
    LPVOID                  pvData, 
    PULONG                  pcbData
)
{
    HRESULT                 hr          = DS_OK;
    LPCPROPERTYHANDLER      pHandler;

    DPF_ENTER();
    
    pHandler = GetPropertyHandler(guidPropertySet, ulProperty);

    if(pHandler)
    {
        if(!pHandler->pfnGetHandler)
        {
            RPF(DPFLVL_ERROR, "Property %lu in set " DPF_GUID_STRING " does not support the Get method", ulProperty, DPF_GUID_VAL(guidPropertySet));
            hr = DSERR_UNSUPPORTED;
        }

        if(SUCCEEDED(hr))
        {
            if(pHandler->cbData && *pcbData < pHandler->cbData)
            {
                if(*pcbData)
                {
                    RPF(DPFLVL_ERROR, "Data buffer too small");
                    hr = DSERR_INVALIDPARAM;
                }

                *pcbData = pHandler->cbData;
            }
            else
            {
                hr = pHandler->pfnGetHandler(m_pvContext, pvData, pcbData);
            }
        }
    }
    else
    {
        hr = UnsupportedGetHandler(guidPropertySet, ulProperty, pvParam, cbParam, pvData, pcbData);
    }

    DPF_LEAVE(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets the value of a particular property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: property parameters size.
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPropertySetHandler::SetProperty"

HRESULT CPropertySetHandler::SetProperty
(
    REFGUID                 guidPropertySet, 
    ULONG                   ulProperty, 
    LPVOID                  pvParam, 
    ULONG                   cbParam, 
    LPVOID                  pvData, 
    ULONG                   cbData
)
{
    HRESULT                 hr          = DS_OK;
    LPCPROPERTYHANDLER      pHandler;

    DPF_ENTER();
    
    pHandler = GetPropertyHandler(guidPropertySet, ulProperty);

    if(pHandler)
    {
        if(!pHandler->pfnSetHandler)
        {
            RPF(DPFLVL_ERROR, "Property %lu in set " DPF_GUID_STRING " does not support the Set method", ulProperty, DPF_GUID_VAL(guidPropertySet));
            hr = DSERR_UNSUPPORTED;
        }

        if(SUCCEEDED(hr) && cbData < pHandler->cbData)
        {
            RPF(DPFLVL_ERROR, "Data buffer too small");
            hr = DSERR_INVALIDPARAM;
        }
    
        if(SUCCEEDED(hr))
        {
            ASSERT(!pvParam);
            ASSERT(!cbParam);
            
            hr = pHandler->pfnSetHandler(m_pvContext, pvData, cbData);
        }
    }
    else
    {
        hr = UnsupportedSetHandler(guidPropertySet, ulProperty, pvParam, cbParam, pvData, cbData);
    }

    DPF_LEAVE(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPropertyHandler
 *
 *  Description:
 *      Gets a pointer to the property handler for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set identifier.
 *      ULONG [in]: property identifier.
 *
 *  Returns:  
 *      LPCPROPERTYHANDLER: property handler, or NULL on error.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPropertySetHandler::GetPropertyHandler"

LPCPROPERTYHANDLER 
CPropertySetHandler::GetPropertyHandler
(
    REFGUID                     guidPropertySet,
    ULONG                       ulProperty
)
{
    LPCPROPERTYHANDLER          pHandler        = NULL;
    ULONG                       ulSetIndex;
    ULONG                       ulPropertyIndex;
    
    DPF_ENTER();

    for(ulSetIndex = 0; ulSetIndex < m_cPropertySets && !pHandler; ulSetIndex++)
    {
        if(IsEqualGUID(guidPropertySet, *m_aPropertySets[ulSetIndex].pguidPropertySetId))
        {
            for(ulPropertyIndex = 0; ulPropertyIndex < m_aPropertySets[ulSetIndex].cProperties && !pHandler; ulPropertyIndex++)
            {
                if(ulProperty == m_aPropertySets[ulSetIndex].aPropertyHandlers[ulPropertyIndex].ulProperty)
                {
                    pHandler = &m_aPropertySets[ulSetIndex].aPropertyHandlers[ulPropertyIndex];
                }
            }
        }
    }

    DPF_LEAVE(pHandler);

    return pHandler;
}


/***************************************************************************
 *
 *  CWrapperPropertySet
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *      REFGUID [in]: 3D algorithm.
 *      DWORD [in]: buffer frequency.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapperPropertySet::CWrapperPropertySet"

CWrapperPropertySet::CWrapperPropertySet
(
    void
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CWrapperPropertySet);

    // Initialize defaults
    m_pPropertySet = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CWrapperPropertySet
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapperPropertySet::~CWrapperPropertySet"

CWrapperPropertySet::~CWrapperPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CWrapperPropertySet);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetObjectPointer
 *
 *  Description:
 *      Sets the real property set object pointer.
 *
 *  Arguments:
 *      CPropertySet * [in]: property set object pointer.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapperPropertySet::SetObjectPointer"

HRESULT 
CWrapperPropertySet::SetObjectPointer
(
    CPropertySet *          pPropertySet
)
{
    DPF_ENTER();

    m_pPropertySet = pPropertySet;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for support of a particular property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      PULONG [out]: receives support bits.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapperPropertySet::QuerySupport"

HRESULT 
CWrapperPropertySet::QuerySupport
(
    REFGUID                 guidPropertySet, 
    ULONG                   ulProperty, 
    PULONG                  pulSupportFlags
)
{
    HRESULT                 hr  = DSERR_UNSUPPORTED;

    DPF_ENTER();
    
    if(m_pPropertySet)
    {
        hr = m_pPropertySet->QuerySupport(guidPropertySet, ulProperty, pulSupportFlags);
    }

    DPF_LEAVE(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetProperty
 *
 *  Description:
 *      Gets the value of a particular property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: property parameters size.
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapperPropertySet::GetProperty"

HRESULT 
CWrapperPropertySet::GetProperty
(
    REFGUID                 guidPropertySet, 
    ULONG                   ulProperty, 
    LPVOID                  pvParam, 
    ULONG                   cbParam, 
    LPVOID                  pvData, 
    PULONG                  pcbData
)
{
    HRESULT                 hr  = DSERR_UNSUPPORTED;

    DPF_ENTER();
    
    if(m_pPropertySet)
    {
        hr = m_pPropertySet->GetProperty(guidPropertySet, ulProperty, pvParam, cbParam, pvData, pcbData);
    }

    DPF_LEAVE(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets the value of a particular property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: property parameters size.
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapperPropertySet::SetProperty"

HRESULT CWrapperPropertySet::SetProperty
(
    REFGUID                 guidPropertySet, 
    ULONG                   ulProperty, 
    LPVOID                  pvParam, 
    ULONG                   cbParam, 
    LPVOID                  pvData, 
    ULONG                   cbData
)
{
    HRESULT                 hr  = DSERR_UNSUPPORTED;

    DPF_ENTER();
    
    if(m_pPropertySet)
    {
        hr = m_pPropertySet->SetProperty(guidPropertySet, ulProperty, pvParam, cbParam, pvData, cbData);
    }

    DPF_LEAVE(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\reghlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       reghlp.h
 *  Content:    Registry helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  5/6/98      dereks  Created.
 * 4/19/99      duganp  Added support for global settings (REGSTR_GLOBAL_CONFIG)
 *                      Added a global setting for a default S/W 3D algorithm
 ***************************************************************************/

#ifndef __REGHLP_H__
#define __REGHLP_H__

// FIXME: this is a mess.  Apart from the device-specific settings we store under special
// device registry keys, we use *3* different registry keys for global settings:
//
// Debug spew settings: HKCU\Software\Microsoft\Multimedia\DirectSound\Debug
// Apphacks: HKLM\System\CurrentControlSet\Control\MediaResources\DirectSound\Application Compatibility
// Default 3D algorithm: HKLM\Software\Microsoft\DirectSound\Default Software 3D Algorithm
//
// All these should be under one key, probably HKLM\Software\Microsoft\Multimedia\DirectSound;
// none of them need to be per-user.  (Unless there's some particularly good reason why we use
// the bizarre System\CurrentControlSet\Control\MediaResources key?)

// Main resistry keys under which we store all our info:
#define REGSTR_HKCU                     TEXT("Software\\Microsoft\\Multimedia")
#define REGSTR_HKLM                     TEXT("System\\CurrentControlSet\\Control\\MediaResources")
#define REGSTR_WAVEMAPPER               TEXT("Software\\Microsoft\\Multimedia\\Sound Mapper")
#define REGSTR_GLOBAL_CONFIG            TEXT("Software\\Microsoft\\DirectSound")
#define REGSTR_MEDIACATEGORIES          TEXT("System\\CurrentControlSet\\Control\\MediaCategories")

// Values used under the REGSTR_MEDIACATEGORIES key for a particular name GUID
// retrieved from the KSCOMPONENTID structure
#define MAXNAME                         0x100
#define REGSTR_NAME                     TEXT("Name")

// Values used under the REGSTR_WAVEMAPPER key (see RhRegGetPreferredDevice)
#define REGSTR_PLAYBACK                 TEXT("Playback")
#define REGSTR_RECORD                   TEXT("Record")
#define REGSTR_PREFERREDONLY            TEXT("PreferredOnly")

// Subkeys used under REGSTR_HKLM and the PnP device registry keys (see pnphlp.cpp)
#define REGSTR_DIRECTSOUND              TEXT("DirectSound")
#define REGSTR_DIRECTSOUNDCAPTURE       TEXT("DirectSoundCapture")

// Subkeys of REGSTR_DIRECTSOUND and REGSTR_DIRECTSOUNDCAPTURE above
#define REGSTR_DEVICEPRESENCE           TEXT("Device Presence")
#define REGSTR_MIXERDEFAULTS            TEXT("Mixer Defaults")
#define REGSTR_SPEAKERCONFIG            TEXT("Speaker Configuration")
#define REGSTR_APPHACK                  TEXT("Application Compatibility")

// Global configuration values (under the REGSTR_GLOBAL_CONFIG key)
#define REGSTR_DFLT_3D_ALGORITHM        TEXT("Default Software 3D Algorithm")

// Debug output control (see debug.c)
#define REGSTR_DEBUG                    TEXT("Debug")   // Key under REGSTR_HKCU
#define REGSTR_DPFLEVEL                 TEXT("DPF")     // Values
#define REGSTR_BREAKLEVEL               TEXT("Break")
#define REGSTR_FLAGS                    TEXT("Flags")
#define REGSTR_LOGFILE                  TEXT("Log File")

// Virtual Audio Device types (see dsprvobj.cpp and vad.cpp)
#define REGSTR_EMULATED                 TEXT("Emulated")
#define REGSTR_VXD                      TEXT("VxD")
#define REGSTR_WDM                      TEXT("WDM")

// Audio device mixing properties (under REGSTR_MIXERDEFAULTS)
#define REGSTR_SRCQUALITY               TEXT("SRC Quality")
#define REGSTR_ACCELERATION             TEXT("Acceleration")

#define REGOPENKEY_ALLOWCREATE          0x00000001
#define REGOPENKEY_MASK                 0x00000001

#define REGOPENPATH_ALLOWCREATE         0x00000001
#define REGOPENPATH_DEFAULTPATH         0x00000002
#define REGOPENPATH_DIRECTSOUND         0x00000004
#define REGOPENPATH_DIRECTSOUNDCAPTURE  0x00000008
#define REGOPENPATH_DIRECTSOUNDMASK     0x0000000C
#define REGOPENPATH_MASK                0x0000000F

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

static const REGSAM g_arsRegOpenKey[] = { KEY_ALL_ACCESS, KEY_READ, KEY_QUERY_VALUE };

extern HRESULT RhRegOpenPath(HKEY, PHKEY, DWORD, UINT, ...);

extern HRESULT RhRegOpenKeyA(HKEY, LPCSTR, DWORD, PHKEY);
extern HRESULT RhRegOpenKeyW(HKEY, LPCWSTR, DWORD, PHKEY);

extern HRESULT RhRegGetValueA(HKEY, LPCSTR, LPDWORD, LPVOID, DWORD, LPDWORD);
extern HRESULT RhRegGetValueW(HKEY, LPCWSTR, LPDWORD, LPVOID, DWORD, LPDWORD);

extern HRESULT RhRegSetValueA(HKEY, LPCSTR, DWORD, LPCVOID, DWORD);
extern HRESULT RhRegSetValueW(HKEY, LPCWSTR, DWORD, LPCVOID, DWORD);

extern HRESULT RhRegDuplicateKey(HKEY, DWORD, BOOL, PHKEY);
extern void RhRegCloseKey(PHKEY);

extern HRESULT RhRegGetPreferredDevice(BOOL, LPTSTR, DWORD, LPUINT, LPBOOL);
extern HRESULT RhRegGetSpeakerConfig(HKEY, LPDWORD);
extern HRESULT RhRegSetSpeakerConfig(HKEY, DWORD);

__inline HRESULT RhRegGetBinaryValueA(HKEY hkeyParent, LPCSTR pszValue, LPVOID pvData, DWORD cbData)
{
    return RhRegGetValueA(hkeyParent, pszValue, NULL, pvData, cbData, NULL);
}

__inline HRESULT RhRegGetBinaryValueW(HKEY hkeyParent, LPCWSTR pszValue, LPVOID pvData, DWORD cbData)
{
    return RhRegGetValueW(hkeyParent, pszValue, NULL, pvData, cbData, NULL);
}

__inline HRESULT RhRegGetStringValueA(HKEY hkeyParent, LPCSTR pszValue, LPSTR pszData, DWORD cbData)
{
    return RhRegGetValueA(hkeyParent, pszValue, NULL, pszData, cbData, NULL);
}

__inline HRESULT RhRegGetStringValueW(HKEY hkeyParent, LPCWSTR pszValue, LPWSTR pszData, DWORD cbData)
{
    return RhRegGetValueW(hkeyParent, pszValue, NULL, pszData, cbData, NULL);
}

__inline HRESULT RhRegSetBinaryValueA(HKEY hkeyParent, LPCSTR pszValue, LPVOID pvData, DWORD cbData)
{
    return RhRegSetValueA(hkeyParent, pszValue, (sizeof(DWORD) == cbData) ? REG_DWORD : REG_BINARY, pvData, cbData);
}

__inline HRESULT RhRegSetBinaryValueW(HKEY hkeyParent, LPCWSTR pszValue, LPVOID pvData, DWORD cbData)
{
    return RhRegSetValueW(hkeyParent, pszValue, (sizeof(DWORD) == cbData) ? REG_DWORD : REG_BINARY, pvData, cbData);
}

__inline HRESULT RhRegSetStringValueA(HKEY hkeyParent, LPCSTR pszValue, LPCSTR pszData)
{
    return RhRegSetValueA(hkeyParent, pszValue, REG_SZ, pszData, lstrsizeA(pszData));
}

__inline HRESULT RhRegSetStringValueW(HKEY hkeyParent, LPCWSTR pszValue, LPCWSTR pszData)
{
    return RhRegSetValueW(hkeyParent, pszValue, REG_SZ, pszData, lstrsizeW(pszData));
}

#ifdef UNICODE
#define RhRegOpenKey RhRegOpenKeyW
#define RhRegGetValue RhRegGetValueW
#define RhRegSetValue RhRegSetValueW
#define RhRegGetBinaryValue RhRegGetBinaryValueW
#define RhRegSetBinaryValue RhRegSetBinaryValueW
#define RhRegGetStringValue RhRegGetStringValueW
#define RhRegSetStringValue RhRegSetStringValueW
#else // UNICODE
#define RhRegOpenKey RhRegOpenKeyA
#define RhRegGetValue RhRegGetValueA
#define RhRegSetValue RhRegSetValueA
#define RhRegGetBinaryValue RhRegGetBinaryValueA
#define RhRegSetBinaryValue RhRegSetBinaryValueA
#define RhRegGetStringValue RhRegGetStringValueA
#define RhRegSetStringValue RhRegSetStringValueA
#endif // UNICODE

#ifdef __cplusplus
}
#endif // __cplusplus

#endif __REGHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\resource.h ===
//--------------------------------------------------------------------------;
//
//  File: resource.h
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Contents:
//      Defines for string resources.
//
//--------------------------------------------------------------------------;

#define IDS_PRIMARYDRIVER   1000
#define IDS_EMULATED        1001
#define IDS_DS_DRIVERLD     1002
#define IDS_DSC_DRIVERLD    1003
#define IDS_PRIMARYCAPDRIVER   1004
#define IDS_KSDRIVER        1005
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\rfcircvec.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rfcircvec.cpp
 *  Content:    real float circular vector 
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/

// Project-specific INCLUDEs
#include "dsoundi.h"
#include "rfcircvec.h"

// ---------------------------------------------------------------------------
// Real float circular vector

// Set buffer size
void CRfCircVec::SetSize(const size_t CstSize, const float CfInitValue)
{
	ASSERT(CstSize > 0);

	// Check if preallocation size has been set and if resizing is necessary
	if (m_stPreallocSize != 0 && CstSize <= m_stPreallocSize) {
		// Don't need to resize, just change end pointer and reset buffer
		SetEndPointer(CstSize);
		m_pfIndex = m_pfStart;
		Fill(CfInitValue);
	}
	else
		// Resizing necessary
		ResizeBuffer(CstSize, CfInitValue);
}

// Reset circular buffer
void CRfCircVec::Reset()
{
	MEMFREE(m_pfStart);
	InitData();
}

// Preallocate buffer size (to avoid excessive memory reallocation)
void CRfCircVec::PreallocateSize(const size_t CstSize, const float CfInitValue)
{
	ASSERT(CstSize > 0);
	
	// Check if buffer needs to be resized to accomodate preallocated size
	if (CstSize > m_stPreallocSize) {
		m_stPreallocSize = CstSize;
		ResizeBuffer(CstSize, CfInitValue);
	}
}

// Fill complete buffer with value
void CRfCircVec::Fill(const float CfInitValue)
{
//	DEBUG_ONLY(CheckPointers());

	for (float* pfLoopIndex = m_pfStart; pfLoopIndex<=m_pfEnd; ++pfLoopIndex)
		*pfLoopIndex = CfInitValue;
}

// Initialize data
void CRfCircVec::InitData()
{
	m_stPreallocSize = 0;
	m_pfStart = NULL;
	m_pfEnd = NULL;
	m_pfIndex = NULL;
}

// Allocate memory and initialize pointers
BOOL CRfCircVec::InitPointers(const size_t CstSize)
{
    BOOL fRetVal = FALSE;
	m_pfStart = MEMALLOC_A(FLOAT, CstSize);
	if (m_pfStart != NULL)
    {
        SetEndPointer(CstSize);
        fRetVal = TRUE;
	}
	return fRetVal;
}

// Full initialization as required in regular constructor and resize operation
BOOL CRfCircVec::Init(const size_t CstSize, const float CfInitValue)
{
    BOOL fRetVal=FALSE;

    ASSERT(CstSize > 0);
  
	// Set pointers to initial values
	if (InitPointers(CstSize))
	{
	    m_pfIndex = m_pfStart;
	    
	    // Initialize buffer with specified initialization value
	    Fill(CfInitValue);
	    fRetVal = TRUE;
	}
    return fRetVal;
}

// Resize buffer
void CRfCircVec::ResizeBuffer(const size_t CstSize, const float CfInitValue)
{
	ASSERT(CstSize > 0);

	MEMFREE(m_pfStart);
	Init(CstSize, CfInitValue);
}

// Write loop
void CRfCircVec::WriteLoop(CRfCircVec& rhs, float (CRfCircVec::* pmf)())
{
	for (size_t st(0); st<rhs.GetSize(); ++st)
		Write((rhs.*pmf)());
}

#if defined(_DEBUG)
// Check pointers
void CRfCircVec::CheckPointers() const
{
	// Make sure pointers are good
	ASSERT(m_pfStart != NULL);
//	CHECK_POINTER(m_pfEnd);
//	CHECK_POINTER(m_pfIndex);
	
	// Make sure pointers make sense
	ASSERT(m_pfEnd >= m_pfStart);
	ASSERT(m_pfIndex >= m_pfStart);
	ASSERT(m_pfIndex <= m_pfEnd);
}
#endif

// ---------------------------------------------------------------------------
// Include inline definitions out-of-line in debug version

#if defined(_DEBUG)
#include "rfcircvec.inl"
#endif

// End of RFCIRCVEC.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\reghlp.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       reghlp.c
 *  Content:    Registry helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  5/6/98      dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  RhRegOpenKey
 *
 *  Description:
 *      Opens a registry key.
 *
 *  Arguments:
 *      HKEY [in]: parent key.
 *      LPTSTR [in]: subkey name.
 *      DWORD [in]: flags.
 *      PHKEY [out]: receives key handle.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RhRegOpenKeyA"

HRESULT RhRegOpenKeyA(HKEY hkeyParent, LPCSTR pszName, DWORD dwFlags, PHKEY phkey)
{
    HRESULT                 hr  = DSERR_GENERIC;
    LONG                    lr;
    UINT                    i;

    DPF_ENTER();

    for(i = 0; i < NUMELMS(g_arsRegOpenKey) && FAILED(hr); i++)
    {
        lr = RegOpenKeyExA(hkeyParent, pszName, 0, g_arsRegOpenKey[i], phkey);
        hr = WIN32ERRORtoHRESULT(lr);
    }

    if(FAILED(hr) && (dwFlags & REGOPENKEY_ALLOWCREATE))
    {
        lr = RegCreateKeyA(hkeyParent, pszName, phkey);
        hr = WIN32ERRORtoHRESULT(lr);
    }

    if(FAILED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Unable to open 0x%p\\%s", hkeyParent, pszName);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "RhRegOpenKeyW"

HRESULT RhRegOpenKeyW(HKEY hkeyParent, LPCWSTR pszName, DWORD dwFlags, PHKEY phkey)
{
    HRESULT                 hr  = DSERR_GENERIC;
    LONG                    lr;
    UINT                    i;

    DPF_ENTER();

    for(i = 0; i < NUMELMS(g_arsRegOpenKey) && FAILED(hr); i++)
    {
        lr = RegOpenKeyExW(hkeyParent, pszName, 0, g_arsRegOpenKey[i], phkey);
        hr = WIN32ERRORtoHRESULT(lr);
    }

    if(FAILED(hr) && (dwFlags & REGOPENKEY_ALLOWCREATE))
    {
        lr = RegCreateKeyW(hkeyParent, pszName, phkey);
        hr = WIN32ERRORtoHRESULT(lr);
    }

    if(FAILED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Unable to open 0x%p\\%ls", hkeyParent, pszName);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RhRegOpenPath
 *
 *  Description:
 *      Opens a registry path.
 *
 *  Arguments:
 *      HKEY [in]: parent key.
 *      PHKEY [out]: registry key.
 *      DWORD [in]: flags.
 *      UINT [in]: path string count.
 *      ... [in]: path strings.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RhRegOpenPath"

HRESULT RhRegOpenPath(HKEY hkeyParent, PHKEY phkey, DWORD dwFlags, UINT cStrings, ...)
{
    LPCTSTR                 pszRoot     = NULL;
    LPCTSTR                 pszDsound   = NULL;
    LPTSTR                  pszPath     = NULL;
    UINT                    ccPath      = 1;
    HRESULT                 hr          = DS_OK;
    LPCTSTR                 pszArg;
    va_list                 va;
    UINT                    i;

    DPF_ENTER();

    if(dwFlags & REGOPENPATH_DEFAULTPATH)
    {
        ASSERT(HKEY_CURRENT_USER == hkeyParent || HKEY_LOCAL_MACHINE == hkeyParent);

        if(HKEY_CURRENT_USER == hkeyParent)
        {
            pszRoot = REGSTR_HKCU;
        }
        else
        {
            pszRoot = REGSTR_HKLM;
        }
    }
    
    if(dwFlags & REGOPENPATH_DIRECTSOUNDMASK)
    {
        ASSERT(LXOR(dwFlags & REGOPENPATH_DIRECTSOUND, dwFlags & REGOPENPATH_DIRECTSOUNDCAPTURE));
        pszDsound = (dwFlags & REGOPENPATH_DIRECTSOUND) ? REGSTR_DIRECTSOUND : REGSTR_DIRECTSOUNDCAPTURE;
    }

    if(pszRoot)
    {
        ccPath += lstrlen(pszRoot) + 1;
    }

    if(pszDsound)
    {
        ccPath += lstrlen(pszDsound) + 1;
    }
    
    va_start(va, cStrings);

    for(i = 0; i < cStrings; i++)
    {
        pszArg = va_arg(va, LPCTSTR);
        ccPath += lstrlen(pszArg) + 1;
    }

    va_end(va);

    hr = MEMALLOC_A_HR(pszPath, TCHAR, ccPath);
    
    if(SUCCEEDED(hr))
    {
        if(pszRoot)
        {
            lstrcat(pszPath, pszRoot);
            lstrcat(pszPath, TEXT("\\"));
        }

        if(pszDsound)
        {
            lstrcat(pszPath, pszDsound);
            lstrcat(pszPath, TEXT("\\"));
        }
    
        va_start(va, cStrings);

        for(i = 0; i < cStrings; i++)
        {
            pszArg = va_arg(va, LPCTSTR);
            
            lstrcat(pszPath, pszArg);
            lstrcat(pszPath, TEXT("\\"));
        }

        va_end(va);

        pszPath[ccPath - 2] = TEXT('\0');

        hr = RhRegOpenKey(hkeyParent, pszPath, dwFlags & REGOPENKEY_MASK, phkey);
    }

    MEMFREE(pszPath);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RhRegGetValue
 *
 *  Description:
 *      Gets a value from the registry.
 *
 *  Arguments:
 *      HKEY [in]: parent key.
 *      LPTSTR [in]: value name.
 *      LPDWORD [out]: receives registry type.
 *      LPVOID [out]: buffer to receive value data.
 *      DWORD [in]: size of above buffer.
 *      LPDWORD [out]: receives required buffer size.
 *  
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RhRegGetValueA"

HRESULT RhRegGetValueA(HKEY hkeyParent, LPCSTR pszValue, LPDWORD pdwType, LPVOID pvData, DWORD cbData, LPDWORD pcbRequired)
{
    LONG                    lr;
    HRESULT                 hr;
    
    DPF_ENTER();

    if(!pvData)
    {
        cbData = 0;
    }
    else if(!cbData)
    {
        pvData = NULL;
    }
    
    lr = RegQueryValueExA(hkeyParent, pszValue, NULL, pdwType, (LPBYTE)pvData, &cbData);

    if(ERROR_INSUFFICIENT_BUFFER == lr && !pvData && !cbData && pcbRequired)
    {
        lr = ERROR_SUCCESS;
    }

    if(ERROR_PATH_NOT_FOUND == lr || ERROR_FILE_NOT_FOUND == lr)
    {
        hr =  S_FALSE;
    }
    else
    {
        hr = WIN32ERRORtoHRESULT(lr);
    }

    if(pcbRequired)
    {
        *pcbRequired = cbData;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "RhRegGetValueW"

HRESULT RhRegGetValueW(HKEY hkeyParent, LPCWSTR pszValue, LPDWORD pdwType, LPVOID pvData, DWORD cbData, LPDWORD pcbRequired)
{
    LONG                    lr;
    HRESULT                 hr;
    
    DPF_ENTER();

    if(!pvData)
    {
        cbData = 0;
    }
    else if(!cbData)
    {
        pvData = NULL;
    }
    
    lr = RegQueryValueExW(hkeyParent, pszValue, NULL, pdwType, (LPBYTE)pvData, &cbData);

    if(ERROR_INSUFFICIENT_BUFFER == lr && !pvData && !cbData && pcbRequired)
    {
        lr = ERROR_SUCCESS;
    }

    if(ERROR_PATH_NOT_FOUND == lr || ERROR_FILE_NOT_FOUND == lr)
    {
        hr =  S_FALSE;
    }
    else
    {
        hr = WIN32ERRORtoHRESULT(lr);
    }

    if(pcbRequired)
    {
        *pcbRequired = cbData;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RhRegSetValue
 *
 *  Description:
 *      Sets a value to the registry.
 *
 *  Arguments:
 *      HKEY [in]: parent key.
 *      LPTSTR [in]: value name.
 *      DWORD [in]: value type.
 *      LPVOID [in]: value data.
 *      DWORD [in]: size of above buffer.
 *  
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RhRegSetValueA"

HRESULT RhRegSetValueA(HKEY hkeyParent, LPCSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData)
{
    LONG                    lr;
    HRESULT                 hr;
    
    DPF_ENTER();

    lr = RegSetValueExA(hkeyParent, pszValue, 0, dwType, (const BYTE *)pvData, cbData);
    hr = WIN32ERRORtoHRESULT(lr);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "RhRegSetValueW"

HRESULT RhRegSetValueW(HKEY hkeyParent, LPCWSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData)
{
    LONG                    lr;
    HRESULT                 hr;
    
    DPF_ENTER();

    lr = RegSetValueExW(hkeyParent, pszValue, 0, dwType, (const BYTE *)pvData, cbData);
    hr = WIN32ERRORtoHRESULT(lr);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RhRegDuplicateKey
 *
 *  Description:
 *      Duplicates a registry key.
 *
 *  Arguments:
 *      HKEY [in]: source key.
 *      DWORD [in]: process key was opened in.
 *      BOOL [in]: TRUE to close the source key.
 *      HKEY [out]: duplicated key handle
 *  
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RhRegDuplicateKey"

HRESULT RhRegDuplicateKey(HKEY hkeySource, DWORD dwProcessId, BOOL fCloseSource, PHKEY phkey)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Registry keys can't be duplicated on Win9x.  So, instead of duplicating
    // the handle, we have to just save a copy of the value.  In order to prevent
    // closing the original key, we're just going to leak all registry key handles.

#ifdef WINNT

    *phkey = GetLocalHandleCopy(hkeySource, dwProcessId, fCloseSource);

#else // WINNT

    *phkey = hkeySource;

#endif // WINNT

    hr = HRFROMP(*phkey);
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RhRegCloseKey
 *
 *  Description:
 *      Closes a registry key.
 *
 *  Arguments:
 *      PHKEY [in/out]: key handle.
 *  
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RhRegCloseKey"

void RhRegCloseKey(PHKEY phkey)
{
    DPF_ENTER();

#ifdef WINNT

    if(*phkey)
    {
        RegCloseKey(*phkey);
    }

#endif // WINNT

    *phkey = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  RhRegGetPreferredDevice
 *
 *  Description:
 *      This function accesses the registry settings maintained by the
 *      wave mapper and multimedia control panel to determine the wave id
 *      of the preferred sound device.  If any of the registry keys don't
 *      exist, 0 is used as the default.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to get the capture device, FALSE to get the playback
 *                 device.
 *      LPTSTR [out]: preferred device name.
 *      DWORD [in]: size of above buffer in bytes.
 *      LPUINT [out]: preferred device id.
 *      LPBOOL [out]: TRUE if the user has selected to use the preferred
 *                    device only.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RhRegGetPreferredDevice"

HRESULT RhRegGetPreferredDevice(BOOL fCapture, LPTSTR pszDeviceName, DWORD dwNameSize, LPUINT puId, LPBOOL pfPreferredOnly)
{
    const UINT              cWaveOutDevs                = waveOutGetNumDevs();
    const UINT              cWaveInDevs                 = waveInGetNumDevs();
    HRESULT                 hr                          = DS_OK;
    HKEY                    hkeyWaveMapper;
    TCHAR                   szDeviceName[MAXPNAMELEN];
    BOOL                    fPreferredOnly;
    WAVEOUTCAPS             woc;
    WAVEINCAPS              wic;
    UINT                    uId;
    MMRESULT                mmr;

    DPF_ENTER();

    // Open the wave mapper registry key
    hr = RhRegOpenKey(HKEY_CURRENT_USER, REGSTR_WAVEMAPPER, 0, &hkeyWaveMapper);

    // Query the name of the preferred device
    if(SUCCEEDED(hr))
    {
        hr = RhRegGetStringValue(hkeyWaveMapper, fCapture ? REGSTR_RECORD : REGSTR_PLAYBACK, szDeviceName, sizeof szDeviceName);

        if(S_FALSE == hr)
        {
            DPF(DPFLVL_MOREINFO, "Preferred device value does not exist");
            hr = DSERR_GENERIC;
        }
    }

    // Use preferred only?
    if(SUCCEEDED(hr))
    {
        hr = RhRegGetBinaryValue(hkeyWaveMapper, REGSTR_PREFERREDONLY, &fPreferredOnly, sizeof(fPreferredOnly));

        if(S_FALSE == hr)
        {
            DPF(DPFLVL_MOREINFO, "Preferred only value does not exist");
            fPreferredOnly = FALSE;
        }
    }

    // Find the device id for the preferred device
    if(SUCCEEDED(hr))
    {
        if(fCapture)
        {
            for(uId = 0; uId < cWaveInDevs; uId++)
            {
                mmr = waveInGetDevCaps(uId, &wic, sizeof(wic));
                
                if(MMSYSERR_NOERROR == mmr && !lstrcmp(wic.szPname, szDeviceName))
                {
                    break;
                }
            }

            if(uId >= cWaveInDevs)
            {
                DPF(DPFLVL_MOREINFO, "Preferred device does not exist");
                hr = DSERR_NODRIVER;
            }
        }
        else
        {
            for(uId = 0; uId < cWaveOutDevs; uId++)
            {
                mmr = waveOutGetDevCaps(uId, &woc, sizeof(woc));

                if(MMSYSERR_NOERROR == mmr && !lstrcmp(woc.szPname, szDeviceName))
                {
                    break;
                }
            }

            if(uId >= cWaveOutDevs)
            {
                DPF(DPFLVL_MOREINFO, "Preferred device does not exist");
                hr = DSERR_NODRIVER;
            }
        }
    }

    // Free resources
    RhRegCloseKey(&hkeyWaveMapper);

    // If we failed to get the preferred device, we'll just use the first
    // valid, mappable device.
    if(FAILED(hr))
    {
        uId = GetNextMappableWaveDevice(WAVE_DEVICEID_NONE, fCapture);

        if(WAVE_DEVICEID_NONE != uId)
        {
            if(fCapture)
            {
                mmr = waveInGetDevCaps(uId, &wic, sizeof(wic));

                if(MMSYSERR_NOERROR == mmr)
                {
                    lstrcpy(szDeviceName, wic.szPname);
                }
            }
            else
            {
                mmr = waveOutGetDevCaps(uId, &woc, sizeof(woc));

                if(MMSYSERR_NOERROR == mmr)
                {
                    lstrcpy(szDeviceName, woc.szPname);
                }
            }

            if(MMSYSERR_NOERROR == mmr)
            {
                fPreferredOnly = FALSE;
                hr = DS_OK;
            }
        }
    }

    // Success
    if(SUCCEEDED(hr) && pszDeviceName)
    {
        lstrcpyn(pszDeviceName, szDeviceName, dwNameSize);
    }

    if(SUCCEEDED(hr) && puId)
    {
        *puId = uId;
    }

    if(SUCCEEDED(hr) && pfPreferredOnly)
    {
        *pfPreferredOnly = fPreferredOnly;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RhRegGetSpeakerConfig
 *
 *  Description:
 *      This function accesses the registry settings maintained by the
 *      Sounds and Multimedia control panel applet to determine the
 *      currently selected Speaker Configuration.  If the appropriate
 *      registry key doesn't exist, we return DSSPEAKER_DEFAULT.
 *
 *  Arguments:
 *      HKEY [in]: root registry key of the device to be queried.
 *      LPDWORD [out]: speaker configuration.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RhRegGetSpeakerConfig"

HRESULT RhRegGetSpeakerConfig(HKEY hkeyParent, LPDWORD pdwSpeakerConfig)
{
    HRESULT hr = DS_OK;
    HKEY hkey;
    DPF_ENTER();

    if (pdwSpeakerConfig != NULL)
    {
        *pdwSpeakerConfig = DSSPEAKER_DEFAULT;
        hr = RhRegOpenKey(hkeyParent, REGSTR_SPEAKERCONFIG, 0, &hkey);
        if (SUCCEEDED(hr))
        {
            hr = RhRegGetBinaryValue(hkey, REGSTR_SPEAKERCONFIG, pdwSpeakerConfig, sizeof *pdwSpeakerConfig);
            if (hr == S_FALSE)
                DPF(DPFLVL_MOREINFO, "Speaker configuration not defined in registry");
            RhRegCloseKey(&hkey);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  RhRegSetSpeakerConfig
 *
 *  Description:
 *      This function accesses the registry settings maintained by the
 *      Sounds and Multimedia control panel applet to set the Speaker
 *      Configuration.
 *
 *  Arguments:
 *      HKEY [in]: root registry key of the device to be configured.
 *      DWORD [in]: new speaker configuration.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RhRegSetSpeakerConfig"

HRESULT RhRegSetSpeakerConfig(HKEY hkeyParent, DWORD dwSpeakerConfig)
{
    HRESULT hr;
    HKEY hkey;
    DPF_ENTER();

    hr = RhRegOpenKey(hkeyParent, REGSTR_SPEAKERCONFIG, REGOPENKEY_ALLOWCREATE, &hkey);
    
    if (SUCCEEDED(hr))
    {
        hr = RhRegSetBinaryValue(hkey, REGSTR_SPEAKERCONFIG, &dwSpeakerConfig, sizeof dwSpeakerConfig);
        RhRegCloseKey(&hkey);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\rfcircvec.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rfcircvec.h
 *  Content:    Header for real float circular vector.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/13/98     jstokes  Created
 *
 ***************************************************************************/

#if !defined(RFCIRCVEC_HEADER)
#define RFCIRCVEC_HEADER
#pragma once

// ---------------------------------------------------------------------------
// Real float circular vector

class CRfCircVec {
public:
	CRfCircVec();
	~CRfCircVec();
	BOOL Init(const size_t CstSize, const float CfInitValue);
	void SetSize(const size_t CstSize, const float CfInitValue = 0.0f);
	size_t GetSize() const;
	float LIFORead();
	void LIFONext();
	void SkipBack();
	float FIFORead();
	void FIFONext();
	void SkipForward();
	void Write(const float CfValue);
	void Fill(const float CfInitValue);
	void LIFOFill(CRfCircVec& rhs);
	void FIFOFill(CRfCircVec& rhs);
	size_t GetIndex() const;
	void SetIndex(const size_t CstIndex);
	void Reset();
	void PreallocateSize(const size_t CstSize, const float CfInitValue = 0.0f);

private:
	// Prohibit copy construction and assignment
	CRfCircVec(const CRfCircVec& rhs);
	CRfCircVec& operator=(const CRfCircVec& rhs);

	void InitData();
	float PreviousRead();
	float ReadNext();
	void WriteNext(const float CfValue);
	BOOL InitPointers(const size_t CstSize);
	void ResizeBuffer(const size_t CstSize, const float CfInitValue);
	void SetEndPointer(const size_t CstSize);
	void WriteLoop(CRfCircVec& rhs, float (CRfCircVec::* pmf)());
#if defined(_DEBUG)
	void CheckPointers() const;
#endif

	float* m_pfStart;
	float* m_pfEnd;
	float* m_pfIndex;
	size_t m_stPreallocSize;
};

// ---------------------------------------------------------------------------
// Include inline definitions inline in release version

#if !defined(_DEBUG)
#include "rfcircvec.inl"
#endif

#endif

// End of RFCIRCVEC.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\rfcircvec.inl ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rfcircvec.inl
 *  Content:    real float circular vector 
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/


#if !defined(RFCIRCVEC_INLINE)
#define RFCIRCVEC_INLINE
#pragma once

// Project-specific INCLUDEs
//#include "generallibrary.h"

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

#if !defined(_DEBUG)
#define INLINE _inline
#else
#define INLINE
#endif

// ---------------------------------------------------------------------------
// Real float circular vector

// Default constructor
INLINE CRfCircVec::CRfCircVec()
{
    InitData();
}

// Destructor
INLINE CRfCircVec::~CRfCircVec()
{
	delete[] m_pfStart;
}

// Get buffer size
INLINE size_t CRfCircVec::GetSize() const
{
//	DEBUG_ONLY(CheckPointers());

	return static_cast<size_t>((m_pfEnd - m_pfStart) + 1);
}

// Read item LIFO, advance buffer pointer, wrap around if necessary
INLINE float CRfCircVec::LIFORead()
{
	return PreviousRead();
}

// Read item FIFO, advance buffer pointer, wrap around if necessary
INLINE float CRfCircVec::FIFORead()
{
	return ReadNext();
}

// Write item, advance buffer pointer, wrap around if necessary
INLINE void CRfCircVec::Write(const float CfValue)
{
  WriteNext(CfValue);
}

// Read item from current buffer position (decremented before item was read)
INLINE float CRfCircVec::PreviousRead()
{
//	CHECK_POINTER(m_pfIndex);

	LIFONext();
	return *m_pfIndex;
}

// Read item from current buffer position (decremented before item was read)
INLINE float CRfCircVec::ReadNext()
{
//	CHECK_POINTER(m_pfIndex);

	const float CfValue(*m_pfIndex);
	FIFONext();
	return CfValue;
}

// Write item to current buffer position (incremented after item is written)
INLINE void CRfCircVec::WriteNext(const float CfValue)
{
//	CHECK_POINTER(m_pfIndex);

	*m_pfIndex = CfValue;
	SkipForward();
}

// Increments current buffer position by one, wraps around if necessary
INLINE void CRfCircVec::FIFONext()
{
//	DEBUG_ONLY(CheckPointers());

	// Wrap around if necessary
	if (++m_pfIndex > m_pfEnd)
		m_pfIndex = m_pfStart;
}

// Skip forward one element
INLINE void CRfCircVec::SkipForward()
{
	FIFONext();
}

// Decrements current buffer position by one, wraps around if necessary
INLINE void CRfCircVec::LIFONext()
{
//	DEBUG_ONLY(CheckPointers());

	// Wrap around if necessary
	if (--m_pfIndex < m_pfStart)
		m_pfIndex = m_pfEnd;
}

// Skip back one element
INLINE void CRfCircVec::SkipBack()
{
	LIFONext();
}

// Get current index
INLINE size_t CRfCircVec::GetIndex() const
{
//	DEBUG_ONLY(CheckPointers());

	return static_cast<size_t>(m_pfIndex - m_pfStart);
}

// Set current index
INLINE void CRfCircVec::SetIndex(const size_t CstIndex)
{
	ASSERT(CstIndex < GetSize());
//	DEBUG_ONLY(CheckPointers());

	m_pfIndex = m_pfStart + CstIndex;
}

// Set end pointer
INLINE void CRfCircVec::SetEndPointer(const size_t CstSize)
{
	m_pfEnd = m_pfStart + CstSize - 1;
}

// Fill with contents from other buffer, updating indices but not touching lengths (LIFO)
INLINE void CRfCircVec::LIFOFill(CRfCircVec& rhs)
{
//	DEBUG_ONLY(CheckPointers());

	WriteLoop(rhs, LIFORead);
}

// Fill with contents from other buffer, updating indices but not touching lengths (FIFO)
INLINE void CRfCircVec::FIFOFill(CRfCircVec& rhs)
{
//	DEBUG_ONLY(CheckPointers());

	WriteLoop(rhs, FIFORead);
}

#endif

// End of RFCIRCVEC.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\runtime.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       runtime.c
 *  Content:    New versions of C runtime functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/17/97    dereks  Created
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  FillMemory
 *
 *  Description:
 *      Fills a buffer with a given byte pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      SIZE_T [in]: buffer size.
 *      BYTE [in]: byte pattern.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

RTAPI void RTCALLTYPE FillMemory(LPVOID pvDest, SIZE_T cbBuffer, BYTE bFill)
{

#ifdef Not_VxD

    ASSERT(!IsBadWritePtr(pvDest, cbBuffer));

#endif // Not_VxD

#ifdef USE_FAST_RUNTIME

    FastFillMemory(pvDest, cbBuffer, bFill);

#elif defined(USE_INTRINSICS)

    memset(pvDest, bFill, (size_t)cbBuffer);

#else

    SlowFillMemory(pvDest, cbBuffer, bFill);

#endif

}


/***************************************************************************
 *
 *  FillMemoryDword
 *
 *  Description:
 *      Fills a buffer with a given dword pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      SIZE_T [in]: buffer size.
 *      DWORD [in]: pattern.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

RTAPI void RTCALLTYPE FillMemoryDword(LPVOID pvDest, SIZE_T cbBuffer, DWORD dwFill)
{

#ifdef Not_VxD

    ASSERT(!(cbBuffer % sizeof(DWORD)));
    ASSERT(!IsBadWritePtr(pvDest, cbBuffer));

#endif // Not_VxD

#ifdef USE_FAST_RUNTIME

    FastFillMemoryDword(pvDest, cbBuffer, dwFill);

#else

    SlowFillMemoryDword(pvDest, cbBuffer, dwFill);

#endif

}


/***************************************************************************
 *
 *  FillMemoryOffset
 *
 *  Description:
 *      Fills a buffer with a given byte pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      SIZE_T [in]: buffer size.
 *      BYTE [in]: byte pattern.
 *      SIZE_T [in]: byte offset.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

RTAPI void RTCALLTYPE FillMemoryOffset(LPVOID pvDest, SIZE_T cbBuffer, BYTE bFill, SIZE_T ibOffset)
{
    FillMemory((LPBYTE)pvDest + ibOffset, cbBuffer - ibOffset, bFill);
}


/***************************************************************************
 *
 *  FillMemoryDwordOffset
 *
 *  Description:
 *      Fills a buffer with a given dword pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      SIZE_T [in]: buffer size.
 *      DWORD [in]: pattern.
 *      SIZE_T [in]: byte offset.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

RTAPI void RTCALLTYPE FillMemoryDwordOffset(LPVOID pvDest, SIZE_T cbBuffer, DWORD dwFill, SIZE_T ibOffset)
{
    FillMemoryDword((LPBYTE)pvDest + ibOffset, cbBuffer - ibOffset, dwFill);
}


/***************************************************************************
 *
 *  ZeroMemory
 *
 *  Description:
 *      Fills a buffer with a 0 pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      SIZE_T [in]: buffer size.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

RTAPI void RTCALLTYPE ZeroMemory(LPVOID pvDest, SIZE_T cbBuffer)
{
    FillMemory(pvDest, cbBuffer, 0);
}


/***************************************************************************
 *
 *  ZeroMemoryOffset
 *
 *  Description:
 *      Fills a buffer with a 0 pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      SIZE_T [in]: buffer size.
 *      SIZE_T [in]: byte offset.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

RTAPI void RTCALLTYPE ZeroMemoryOffset(LPVOID pvDest, SIZE_T cbBuffer, SIZE_T ibOffset)
{
    ZeroMemory((LPBYTE)pvDest + ibOffset, cbBuffer - ibOffset);
}


/***************************************************************************
 *
 *  CopyMemory
 *
 *  Description:
 *      Copies one buffer over another of equal size.
 *
 *  Arguments:
 *      LPVOID [in]: destination buffer pointer.
 *      LPVOID [in]: source buffer pointer.
 *      SIZE_T [in]: buffer size.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

RTAPI void RTCALLTYPE CopyMemory(LPVOID pvDest, LPCVOID pvSource, SIZE_T cbBuffer)
{

#ifdef Not_VxD

    ASSERT(!IsBadWritePtr(pvDest, cbBuffer));
    ASSERT(!IsBadReadPtr(pvSource, cbBuffer));

#endif // Not_VxD

    if(pvDest == pvSource)
    {
        return;
    }

#ifdef USE_FAST_RUNTIME

    FastCopyMemory(pvDest, pvSource, cbBuffer);

#elif defined(USE_INTRINSICS)

    memcpy(pvDest, pvSource, (size_t)cbBuffer);

#else

    SlowCopyMemory(pvDest, pvSource, cbBuffer);

#endif

}


/***************************************************************************
 *
 *  CopyMemoryOffset
 *
 *  Description:
 *      Copies one buffer over another of equal size.
 *
 *  Arguments:
 *      LPVOID [in]: destination buffer pointer.
 *      LPVOID [in]: source buffer pointer.
 *      SIZE_T [in]: buffer size.
 *      SIZE_T [in]: byte offset.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

RTAPI void RTCALLTYPE CopyMemoryOffset(LPVOID pvDest, LPCVOID pvSource, SIZE_T cbBuffer, SIZE_T ibOffset)
{
    CopyMemory((LPBYTE)pvDest + ibOffset, (const BYTE *)pvSource + ibOffset, cbBuffer - ibOffset);
}


/***************************************************************************
 *
 *  CompareMemory
 *
 *  Description:
 *      Compares one buffer to another of equal size.
 *
 *  Arguments:
 *      LPVOID [in]: destination buffer pointer.
 *      LPVOID [in]: source buffer pointer.
 *      SIZE_T [in]: buffer size.
 *
 *  Returns:
 *      BOOL: TRUE if the buffers are equal.
 *
 ***************************************************************************/

RTAPI BOOL RTCALLTYPE CompareMemory(LPCVOID pvDest, LPCVOID pvSource, SIZE_T cbBuffer)
{

#ifdef Not_VxD

    ASSERT(!IsBadReadPtr(pvDest, cbBuffer));
    ASSERT(!IsBadReadPtr(pvSource, cbBuffer));

#endif // Not_VxD

    if(pvDest == pvSource)
    {
        return TRUE;
    }

#ifdef USE_FAST_RUNTIME

    return FastCompareMemory(pvDest, pvSource, cbBuffer);

#elif defined(USE_INTRINSICS)

    return !memcmp(pvDest, pvSource, (size_t)cbBuffer);

#else

    return SlowCompareMemory(pvDest, pvSource, cbBuffer);

#endif

}


/***************************************************************************
 *
 *  CompareMemoryOffset
 *
 *  Description:
 *      Compares one buffer to another of equal size.
 *
 *  Arguments:
 *      LPVOID [in]: destination buffer pointer.
 *      LPVOID [in]: source buffer pointer.
 *      SIZE_T [in]: buffer size.
 *      SIZE_T [in]: byte offset.
 *
 *  Returns:
 *      BOOL: TRUE if the buffers are equal.
 *
 ***************************************************************************/

RTAPI BOOL RTCALLTYPE CompareMemoryOffset(LPCVOID pvDest, LPCVOID pvSource, SIZE_T cbBuffer, SIZE_T ibOffset)
{
    return CompareMemory((const BYTE *)pvDest + ibOffset, (const BYTE *)pvSource + ibOffset, cbBuffer - ibOffset);
}


/***************************************************************************
 *
 *  InitStruct
 *
 *  Description:
 *      Initializes a structure.  It's assumed that the first SIZE_T of the
 *      structure should contain the structure's size.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      SIZE_T [in]: buffer size.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

RTAPI void RTCALLTYPE InitStruct(LPVOID pvDest, DWORD cbBuffer)
{
    *(LPDWORD)pvDest = cbBuffer;
    ZeroMemoryOffset(pvDest, cbBuffer, sizeof(DWORD));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\rtfast.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rtfast.h
 *  Content:    New versions of C runtime functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/27/98     dereks  Created
 *
 ***************************************************************************/

#pragma optimize("", off)
#pragma warning(push)
#pragma warning(disable:4731)


/***************************************************************************
 *
 *  FillMemory
 *
 *  Description:
 *      Fills a buffer with a given byte pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      DWORD [in]: buffer size.
 *      BYTE [in]: byte pattern.
 *
 *  Returns:  
 *      (VOID)
 *
 ***************************************************************************/

RTAPI VOID RTCALLTYPE FastFillMemory(LPVOID pvDest, DWORD cbBuffer, BYTE bFill)
{
    __asm 
    {
        mov     eax, dword ptr bFill        // Fill eax with the dword 
        and     eax, 000000FFh              // version of the fill pattern

        test    eax, eax                    // If the pattern is zero, we
        jz      ZeroPattern                 // can skip some steps

        mov     ebx, eax                    // Propagate what's in al to 
        shl     ebx, 8                      // the rest of eax
        or      eax, ebx
        shl     ebx, 8
        or      eax, ebx
        shl     ebx, 8
        or      eax, ebx

    ZeroPattern:
        mov     esi, pvDest                 // esi = pvDest
        mov     ecx, cbBuffer               // ecx = cbBuffer

    ByteHead:
        test    ecx, ecx                    // Is the counter at 0?
        jz      End

        test    esi, 00000003h              // Is esi 32-bit aligned?
        jz      DwordHead

        mov     byte ptr [esi], al          // Copy al into esi
        
        inc     esi                         // Move pointers
        dec     ecx

        jmp     ByteHead                    // Loop

    DwordHead:
        cmp     ecx, 4                      // Is the counter < 4?
        jl      ByteTail

        test    esi, 0000001Fh              // Is esi 32-byte aligned?
        jz      BigLoop

        mov     dword ptr [esi], eax        // Copy eax into esi
        
        add     esi, 4                      // Move pointers
        sub     ecx, 4

        jmp     DwordHead                   // Loop
    
    BigLoop:
        cmp     ecx, 32                     // Is the counter <= 32?
        jle     DwordTail

        mov     ebx, dword ptr [esi+32]     // Prime the cache
        
        mov     dword ptr [esi+4], eax      // Copy eax into esi to esi+32
        mov     dword ptr [esi+8], eax
        mov     dword ptr [esi+12], eax
        mov     dword ptr [esi+16], eax
        mov     dword ptr [esi+20], eax
        mov     dword ptr [esi+24], eax
        mov     dword ptr [esi+28], eax
        mov     dword ptr [esi], eax        

        add     esi, 32                     // Move pointers
        sub     ecx, 32

        jmp     BigLoop                     // Loop

    DwordTail:
        cmp     ecx, 4                      // Is the counter < 4?
        jl      ByteTail

        mov     dword ptr [esi], eax        // Copy eax into esi
        
        add     esi, 4                      // Move pointers
        sub     ecx, 4

        jmp     DwordTail                   // Loop

    ByteTail:
        test    ecx, ecx                    // Is the counter at 0?
        jz      End

        mov     byte ptr [esi], al          // Copy al into esi
        
        inc     esi                         // Move pointers
        dec     ecx

        jmp     ByteTail                    // Loop

    End:
    }
}


/***************************************************************************
 *
 *  FillMemoryDword
 *
 *  Description:
 *      Fills a buffer with a given DWORD pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      DWORD [in]: buffer size.
 *      DWORD [in]: pattern.
 *
 *  Returns:  
 *      (VOID)
 *
 ***************************************************************************/

RTAPI VOID RTCALLTYPE FastFillMemoryDword(LPVOID pvDest, DWORD cbBuffer, DWORD dwFill)
{
    __asm 
    {
        mov     eax, dwFill                 // eax = dwFill
        mov     esi, pvDest                 // esi = pvDest
        mov     ecx, cbBuffer               // ecx = cbBuffer

    DwordHead:
        cmp     ecx, 4                      // Is the counter < 4?
        jl      End

        test    esi, 0000001Fh              // Is esi 32-byte aligned?
        jz      BigLoop

        mov     dword ptr [esi], eax        // Copy eax into esi
        
        add     esi, 4                      // Move pointers
        sub     ecx, 4

        jmp     DwordHead                   // Loop
    
    BigLoop:
        cmp     ecx, 32                     // Is the counter <= 32?
        jle     DwordTail

        mov     ebx, dword ptr [esi+32]     // Prime the cache
        
        mov     dword ptr [esi+4], eax      // Copy eax into esi to esi+32
        mov     dword ptr [esi+8], eax
        mov     dword ptr [esi+12], eax
        mov     dword ptr [esi+16], eax
        mov     dword ptr [esi+20], eax
        mov     dword ptr [esi+24], eax
        mov     dword ptr [esi+28], eax
        mov     dword ptr [esi], eax        

        add     esi, 32                     // Move pointers
        sub     ecx, 32

        jmp     BigLoop                     // Loop

    DwordTail:
        cmp     ecx, 4                      // Is the counter < 4?
        jl      End

        mov     dword ptr [esi], eax        // Copy eax into esi
        
        add     esi, 4                      // Move pointers
        sub     ecx, 4

        jmp     DwordTail                   // Loop

    End:
    }
}


/***************************************************************************
 *
 *  CopyMemory
 *
 *  Description:
 *      Copies one buffer over another of equal size.
 *
 *  Arguments:
 *      LPVOID [in]: destination buffer pointer.
 *      LPVOID [in]: source buffer pointer.
 *      DWORD [in]: buffer size.
 *
 *  Returns:  
 *      (VOID)
 *
 ***************************************************************************/

RTAPI VOID RTCALLTYPE FastCopyMemory(LPVOID pvDest, LPCVOID pvSource, DWORD cbBuffer)
{
    __asm 
    {
        push    ebp
        
        mov     esi, pvDest                 // esi = pvDest
        mov     edi, pvSource               // edi = pvSource
        mov     ebp, cbBuffer               // ebp = cbBuffer

    ByteHead:
        test    ebp, ebp                    // Is the counter at 0?
        jz      End

        test    esi, 00000003h              // Is esi 32-bit aligned?
        jz      DwordHead

        test    edi, 00000003h              // Is edi 32-bit aligned?
        jz      DwordHead

        mov     al, byte ptr [edi]          // Copy edi into esi
        mov     byte ptr [esi], al
        
        inc     esi                         // Move pointers
        inc     edi
        dec     ebp

        jmp     ByteHead                    // Loop

    DwordHead:
        cmp     ebp, 4                      // Is the counter < 4?
        jl      ByteTail

        test    esi, 0000001Fh              // Is esi 32-byte aligned?
        jz      BigLoop

        test    edi, 0000001Fh              // Is edi 32-byte aligned?
        jz      BigLoop

        mov     eax, dword ptr [edi]        // Copy eax into esi
        mov     dword ptr [esi], eax
        
        add     esi, 4                      // Move pointers
        add     edi, 4
        sub     ebp, 4

        jmp     DwordHead                   // Loop
    
    BigLoop:
        cmp     ebp, 32                     // Is the counter < 32?
        jl      DwordTail

        mov     eax, dword ptr [edi]        // Copy edi to edi+16 into esi to esi+16
        mov     ebx, dword ptr [edi+4]
        mov     ecx, dword ptr [edi+8]
        mov     edx, dword ptr [edi+12]

        mov     dword ptr [esi], eax
        mov     dword ptr [esi+4], ebx
        mov     dword ptr [esi+8], ecx
        mov     dword ptr [esi+12], edx
        
        mov     eax, dword ptr [edi+16]     // Copy edi+16 to edi+32 into esi+16 to esi+32
        mov     ebx, dword ptr [edi+20]
        mov     ecx, dword ptr [edi+24]
        mov     edx, dword ptr [edi+28]

        mov     dword ptr [esi+16], eax
        mov     dword ptr [esi+20], ebx
        mov     dword ptr [esi+24], ecx
        mov     dword ptr [esi+28], edx
        
        add     esi, 32                     // Move pointers
        add     edi, 32
        sub     ebp, 32

        jmp     BigLoop                     // Loop

    DwordTail:
        cmp     ebp, 4                      // Is the counter < 4?
        jl      ByteTail

        mov     eax, dword ptr [edi]        // Copy edi into esi
        mov     dword ptr [esi], eax
        
        add     esi, 4                      // Move pointers
        add     edi, 4
        sub     ebp, 4

        jmp     DwordTail                   // Loop

    ByteTail:
        test    ebp, ebp                    // Is the counter at 0?
        jz      End

        mov     al, byte ptr [edi]          // Copy edi into esi
        mov     byte ptr [esi], al
        
        inc     esi                         // Move pointers
        inc     edi
        dec     ebp

        jmp     ByteTail                    // Loop

    End:
        pop     ebp
    }
}


/***************************************************************************
 *
 *  CompareMemory
 *
 *  Description:
 *      Compares one buffer to another of equal size.
 *
 *  Arguments:
 *      LPVOID [in]: destination buffer pointer.
 *      LPVOID [in]: source buffer pointer.
 *      DWORD [in]: buffer size.
 *
 *  Returns:  
 *      BOOL: TRUE if the buffers are equal.
 *
 ***************************************************************************/

RTAPI BOOL RTCALLTYPE FastCompareMemory(LPCVOID pvDest, LPCVOID pvSource, DWORD cbBuffer)
{
    BOOL                    fCompare;
    
    __asm 
    {
        push    ebp
        
        mov     esi, pvDest                 // esi = pvDest
        mov     edi, pvSource               // edi = pvSource
        mov     ebp, cbBuffer               // ebp = cbBuffer

    ByteHead:
        test    ebp, ebp                    // Is the counter at 0?
        jz      Equal

        test    esi, 00000003h              // Is esi 32-bit aligned?
        jz      DwordHead

        test    edi, 00000003h              // Is edi 32-bit aligned?
        jz      DwordHead

        mov     al, byte ptr [edi]          // Compare edi to esi
        cmp     byte ptr [esi], al
        jne     NotEqual
        
        inc     esi                         // Move pointers
        inc     edi
        dec     ebp

        jmp     ByteHead                    // Loop

    DwordHead:
        cmp     ebp, 4                      // Is the counter < 4?
        jl      ByteTail

        test    esi, 0000001Fh              // Is esi 32-byte aligned?
        jz      BigLoop

        test    edi, 0000001Fh              // Is edi 32-byte aligned?
        jz      BigLoop

        mov     eax, dword ptr [edi]        // Compare edi to esi
        cmp     dword ptr [esi], eax
        jne     NotEqual
        
        add     esi, 4                      // Move pointers
        add     edi, 4
        sub     ebp, 4

        jmp     DwordHead                   // Loop
    
    BigLoop:
        cmp     ebp, 32                     // Is the counter < 32?
        jl      DwordTail

        mov     eax, dword ptr [edi]        // Compare edi to edi+16 to esi to esi+16
        mov     ebx, dword ptr [edi+4]
        mov     ecx, dword ptr [edi+8]
        mov     edx, dword ptr [edi+12]

        cmp     dword ptr [esi], eax
        jne     NotEqual
        cmp     dword ptr [esi+4], ebx
        jne     NotEqual
        cmp     dword ptr [esi+8], ecx
        jne     NotEqual
        cmp     dword ptr [esi+12], edx
        jne     NotEqual
        
        mov     eax, dword ptr [edi+16]     // Compare edi+16 to edi+32 to esi+16 to esi+32
        mov     ebx, dword ptr [edi+20]
        mov     ecx, dword ptr [edi+24]
        mov     edx, dword ptr [edi+28]

        cmp     dword ptr [esi+16], eax
        jne     NotEqual
        cmp     dword ptr [esi+20], ebx
        jne     NotEqual
        cmp     dword ptr [esi+24], ecx
        jne     NotEqual
        cmp     dword ptr [esi+28], edx
        jne     NotEqual
        
        add     esi, 32                     // Move pointers
        add     edi, 32
        sub     ebp, 32

        jmp     BigLoop                     // Loop

    DwordTail:
        cmp     ebp, 4                      // Is the counter < 4?
        jl      ByteTail

        mov     eax, dword ptr [edi]        // Compare edi to esi
        cmp     dword ptr [esi], eax
        jne     NotEqual
        
        add     esi, 4                      // Move pointers
        add     edi, 4
        sub     ebp, 4

        jmp     DwordTail                   // Loop

    ByteTail:
        test    ebp, ebp                    // Is the counter at 0?
        jz      Equal

        mov     al, byte ptr [edi]          // Compare edi into esi
        cmp     byte ptr [esi], al
        jne     NotEqual
        
        inc     esi                         // Move pointers
        inc     edi
        dec     ebp

        jmp     ByteTail                    // Loop

    Equal:
        mov     eax, TRUE
        jmp     End      
                         
    NotEqual:
        mov     eax, FALSE

    End:
        pop     ebp

        mov     fCompare, eax
    }

    return fCompare;
}

#pragma warning(pop)
#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\rtslow.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rtslow.h
 *  Content:    New versions of C runtime functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/17/97    dereks  Created
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  FillMemory
 *
 *  Description:
 *      Fills a buffer with a given byte pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      SIZE_T [in]: buffer size.
 *      BYTE [in]: byte pattern.
 *
 *  Returns:  
 *      (VOID)
 *
 ***************************************************************************/

RTAPI VOID RTCALLTYPE SlowFillMemory(LPVOID pvDest, SIZE_T cbBuffer, BYTE bFill)
{
    PSIZE_T                 pdwBuffer;
    LPBYTE                  pbBuffer;
    SIZE_T                  dwFill;
    UINT                    i;

    for(i = 0, dwFill = bFill; i < sizeof(SIZE_T) - 1; i++)
    {
        dwFill <<= 8;
        dwFill |= bFill;
    }
    
    pdwBuffer = (PSIZE_T)pvDest;
    
    while(cbBuffer >= sizeof(*pdwBuffer))
    {
        *pdwBuffer++ = dwFill;
        cbBuffer -= sizeof(*pdwBuffer);
    }

    pbBuffer = (LPBYTE)pdwBuffer;

    while(cbBuffer)
    {
        *pbBuffer++ = bFill;
        cbBuffer--;
    }
}


/***************************************************************************
 *
 *  FillMemoryDword
 *
 *  Description:
 *      Fills a buffer with a given dword pattern.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *      SIZE_T [in]: buffer size.
 *      DWORD [in]: pattern.
 *
 *  Returns:  
 *      (VOID)
 *
 ***************************************************************************/

RTAPI VOID RTCALLTYPE SlowFillMemoryDword(LPVOID pvDest, SIZE_T cbBuffer, DWORD dwFill)
{
    LPDWORD                 pdwBuffer;

    pdwBuffer = (LPDWORD)pvDest;
    
    while(cbBuffer >= sizeof(*pdwBuffer))
    {
        *pdwBuffer++ = dwFill;
        cbBuffer -= sizeof(*pdwBuffer);
    }
}


/***************************************************************************
 *
 *  CopyMemory
 *
 *  Description:
 *      Copies one buffer over another of equal size.
 *
 *  Arguments:
 *      LPVOID [in]: destination buffer pointer.
 *      LPVOID [in]: source buffer pointer.
 *      SIZE_T [in]: buffer size.
 *
 *  Returns:  
 *      (VOID)
 *
 ***************************************************************************/

RTAPI VOID RTCALLTYPE SlowCopyMemory(LPVOID pvDest, LPCVOID pvSource, SIZE_T cbBuffer)
{
    PSIZE_T                 pdwDest;
    const SIZE_T *          pdwSource;
    LPBYTE                  pbDest;
    const BYTE *            pbSource;

    pdwDest = (PSIZE_T)pvDest;
    pdwSource = (PSIZE_T)pvSource;
    
    while(cbBuffer >= sizeof(*pdwDest))
    {
        *pdwDest++ = *pdwSource++;
        cbBuffer -= sizeof(*pdwDest);
    }

    pbDest = (LPBYTE)pdwDest;
    pbSource = (LPBYTE)pdwSource;
    
    while(cbBuffer)
    {
        *pbDest++ = *pbSource++;
        cbBuffer--;
    }
}


/***************************************************************************
 *
 *  CompareMemory
 *
 *  Description:
 *      Compares one buffer to another of equal size.
 *
 *  Arguments:
 *      LPVOID [in]: destination buffer pointer.
 *      LPVOID [in]: source buffer pointer.
 *      SIZE_T [in]: buffer size.
 *
 *  Returns:  
 *      BOOL: TRUE if the buffers are equal.
 *
 ***************************************************************************/

RTAPI BOOL RTCALLTYPE SlowCompareMemory(LPCVOID pvDest, LPCVOID pvSource, SIZE_T cbBuffer)
{
    const SIZE_T *          pdwDest;
    const SIZE_T *          pdwSource;
    const BYTE *            pbDest;
    const BYTE *            pbSource;

    pdwDest = (PSIZE_T)pvDest;
    pdwSource = (PSIZE_T)pvSource;
    
    while(cbBuffer >= sizeof(*pdwDest))
    {
        if(*pdwDest++ != *pdwSource++)
        {
            return FALSE;
        }

        cbBuffer -= sizeof(*pdwDest);
    }

    pbDest = (LPBYTE)pdwDest;
    pbSource = (LPBYTE)pdwSource;
    
    while(cbBuffer)
    {
        if(*pbDest++ != *pbSource++)
        {
            return FALSE;
        }

        cbBuffer--;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\runtime.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       runtime.cpp
 *  Content:    New versions of C++ runtime functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/17/97    dereks  Created
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  operator new
 *
 *  Description:
 *      Overrides the global new operator.
 *
 *  Arguments:
 *      SIZE_T [in]: buffer size.
 *
 *  Returns:
 *      LPVOID: pointer to new memory block.
 *
 ***************************************************************************/

#ifdef DEBUG
__inline LPVOID __cdecl operator new(size_t cbBuffer, LPCTSTR pszFile, UINT nLine, LPCTSTR pszClass)
#else // DEBUG
__inline LPVOID __cdecl operator new(size_t cbBuffer)
#endif // DEBUG
{
    LPVOID p;

#if defined(DEBUG) && defined(Not_VxD)
    ASSERT(cbBuffer);
    p = MemAlloc(cbBuffer, pszFile, nLine, pszClass);
#else
    p = MemAlloc(cbBuffer);
#endif

    return p;
}


/***************************************************************************
 *
 *  operator delete
 *
 *  Description:
 *      Overrides the global delete operator.
 *
 *  Arguments:
 *      LPVOID [in]: memory block.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

__inline void __cdecl operator delete(LPVOID p)
{

#ifdef Not_VxD
    ASSERT(p);
#endif // Not_VxD

    MemFree(p);
}

#if _MSC_VER >= 1200

__inline void __cdecl operator delete(LPVOID p, LPCTSTR pszFile, UINT nLine, LPCTSTR pszClass)
{

#ifdef Not_VxD
    ASSERT(p);
#endif // Not_VxD

    MemFree(p);
}

#endif


/***************************************************************************
 *
 *  _purecall
 *
 *  Description:
 *      Override the CRT's __purecall() function.  This would be called if
 *      dsound had a bug and called one of its own pure virtual functions.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      int: undefined.
 *
 ***************************************************************************/

#ifdef Not_VxD
__inline int __cdecl _purecall(void)
{
    DPF(DPFLVL_ERROR, "This function should never be called");
    ASSERT(FALSE);
    return 0;
}
#endif Not_VxD


/***************************************************************************
 *
 *  __delete
 *
 *  Description:
 *      A function template used by our DELETE() macro to call the delete
 *      operator "safely".  This template generates 62 instantiations at
 *      last count, and it's pointless overhead since C++ guarantees that
 *      "delete 0" is safe.  FIXME: get rid of this as soon as convenient.
 *
 *  Arguments:
 *      void * [in]: pointer to memory block.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

template<class T> void __delete(T *p)
{
    if(p)
    {
        delete p;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\sources.inc ===
#############################################################################
# Copyright (C) Microsoft Corporation 2000
#############################################################################

!ifndef DXROOT
DXROOT = ..\..\..
!endif

!include $(DXROOT)\project.mk
!include ..\..\buildmode.inc

MAJORCOMP = windows
MINORCOMP = directx

TARGETNAME = dsound
TARGETTYPE = DYNLINK
TARGETPATH = $(_OBJ_DIR)
TARGETPATHLIB = $(_OBJ_DIR)
PASS1_PUBLISH = {$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}
NTTARGETFILE0 = misc

USE_MAPSYM = 1
LARGE_ADDRESS_AWARE = 1

C_DEFINES = $(C_DEFINES) -D_WIN32 -DWHISTLER -DNot_VxD # -DPROFILEREMIXING

!if defined(USE_ICECAP) || defined(USE_ICECAP4)
LINKER_FLAGS = /debugtype:fixup
!endif

!if !$(FREEBUILD)

MSC_OPTIMIZATION = $(MSC_OPTIMIZATION) /Od

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

# We always want the .ASM dump files:
# Careful - generating .ASM files in $(O) causes "build -z" not to rebuild anything!
# Using .COD files (e.g. with /FAcs) or putting them elsewhere might help.
# Commented out for now:
# MSC_OPTIMIZATION = $(MSC_OPTIMIZATION) /FAs /Fa$(O)/

INCLUDES = $(PROJECT_INC_PATH);\
           ..\..\dsvxd;\
           $(DXROOT)\inc;\
           $(DXROOT)\misc;\
           $(DXROOT)\dxg\dd\ddraw\ddhelp;\
           $(DXROOT)\dxg\dd\ddraw\main;\
           $(BASEDIR)\public\sdk\inc;\
           $(BASEDIR)\public\internal\drivers\inc;\
           $(BASEDIR)\public\sdk\amovie\inc

LINKLIBS = $(SDK_LIB_PATH)\dmoguids.lib $(SDK_LIB_PATH)\strmbase.lib

SOURCES = debug.c \
          decibels.c \
          dllmain.cpp \
          ds3d.cpp \
          multi3d.cpp \
          dsadmin.cpp \
          dsaphack.c \
          dsapi.cpp \
          dsbnotes.cpp \
          dsbuf.cpp \
          dscap.cpp \
          dscom.cpp \
          dsfd.cpp \
          dsmemmgr.c \
          dsobj.cpp \
          dsound.rc \
          dsprvobj.cpp \
          dsvalid.c \
          dxcrt.c \
          dynaload.c \
          emvad.cpp \
          filter.c \
          grace.cpp \
          grsource.cpp \
          grsub.cpp \
          iirlut.cpp \
          kshlp.cpp \
          ksvad.cpp \
          kscap.cpp \
          ks3d.cpp \
          misc.c \
          mix.cpp \
          mxvad.cpp \
          pnphlp.cpp \
          pset.cpp \
          reghlp.c \
          rfcircvec.cpp \
          synch.cpp \
          vad.cpp \
          vector.c \
          verify.cpp \
          vmaxcoef.cpp \
          effects.cpp \
          capteff.cpp \
          dssink.cpp \
          dsbufcfg.cpp \
          dmstrm.cpp \
          ksuserw.cpp \
          streamer.cpp \
          dsclock.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\streamer.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        streamer.h
 *  Content:     Declaration of class CStreamingThread.
 *  Description: Used to pull audio from sinks and/or perform FX processing.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 02/01/00  duganp   Created
 *
 ***************************************************************************/

#ifndef __STREAMER_H__
#define __STREAMER_H__

#ifdef DEBUG
// #define DEBUG_TIMING  // Uncomment this for some fun timing traces
#endif

#ifdef DEBUG_TIMING
#define DPF_TIMING DPF
#else
#pragma warning(disable:4002)
#define DPF_TIMING()
#endif

// Some constants which determine dsound's basic timing parameters.
// These influence effects processing and streaming from dmusic.

// The streaming thread's initial wake interval in milliseconds:
#define INITIAL_WAKE_INTERVAL   30

// How many milliseconds ahead of the write cursor we stay initially:
#define INITIAL_WRITEAHEAD      100

// Standard duration of mixin/sinkin buffers in milliseconds:
// FIXME: does David's code have some hardcoded assumption about
// this size?  It only seems to work with size == 1000.
#define INTERNAL_BUFFER_LENGTH  1000


#ifdef __cplusplus

// Forward declarations
class CStreamingThread;
class CDirectSoundSink;
class CDirectSoundSecondaryBuffer;
class CEffectChain;

//
// CStreamingThread lifetime management functions
//

CStreamingThread* GetStreamingThread();     // Obtain this process's CStreamingThread, creating it if necessary
void FreeStreamingThread(DWORD dwProcId);   // Free the CStreamingThread object belonging to process dwProcId

//
// CStreamingThread: singleton object which contains and manages the thread
// responsible for periodic processing of our three types of client objects:
// DirectSound sinks, MIXIN buffers and effects chains.
//

class CStreamingThread : private CThread
{
    friend CStreamingThread* GetStreamingThread();          // Creates CStreamingThread objects
    friend void FreeStreamingThread(DWORD dwProcId);        // Deletes them

private:
    CList<CDirectSoundSink*>            m_lstSinkClient;    // List of DirectSoundSink clients
    CList<CDirectSoundSecondaryBuffer*> m_lstMixClient;     // List of MIXIN buffer clients
    CList<CEffectChain*>                m_lstFxClient;      // List of FX-processing clients
    DWORD                               m_dwInterval;       // Thread wake interval in ms
    DWORD                               m_dwLastProcTime;   // When ProcessAudio() was last called in ms
#ifdef DEBUG_TIMING
    DWORD                               m_dwTickCount;      // Used for thread timing log messages
#endif
    DWORD                               m_dwWriteAhead;     // How far ahead of the write cursor to stay in ms
    HANDLE                              m_hWakeNow;         // Event used to force instant wakeup
    int                                 m_nCallCount;       // Number of times we've called ProcessAudio

private:
    // Construction/destruction
    CStreamingThread();
    ~CStreamingThread();
    HRESULT Initialize();
    void MaybeTerminate();

public:
    // Client registration methods
    HRESULT RegisterSink(CDirectSoundSink*);
    HRESULT RegisterMixBuffer(CDirectSoundSecondaryBuffer*);
    HRESULT RegisterFxChain(CEffectChain*);
    void UnregisterSink(CDirectSoundSink*);
    void UnregisterMixBuffer(CDirectSoundSecondaryBuffer*);
    void UnregisterFxChain(CEffectChain*);

    // Thread control methods
    void SetWakePeriod(DWORD dw) {m_dwInterval = dw;}
    void SetWriteAhead(DWORD dw) {m_dwWriteAhead = dw;}
    DWORD GetWakePeriod() {return m_dwInterval;}
    DWORD GetWriteAhead() {return m_dwWriteAhead;}
    HRESULT WakeUpNow();  // Force immediate processing

private:
    // The worker thread procedure and its minions
    HRESULT ThreadProc();
    HRESULT ProcessAudio(REFERENCE_TIME);
    BOOL IsThreadRunning() {return m_hThread != 0;}
};

#endif // __cplusplus
#endif // __STREAMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\runtime.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       runtime.h
 *  Content:    New versions of C runtime functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/17/97    dereks  Created
 *
 ***************************************************************************/

#ifndef __RUNTIME_H__
#define __RUNTIME_H__

#undef FillMemory
#undef CopyMemory
#undef CompareMemory
#undef ZeroMemory
#undef DELETE

// We have BYTE, WORD and DWORD, but no QWORD?
typedef unsigned __int64 QWORD, *LPQWORD;

// Boundaries of numeric types
#define MAX_CHAR        ((CHAR)0x7F)
#define MIN_CHAR        ((CHAR)-0x7F)

#define MAX_UCHAR       ((UCHAR)0xFF)
#define MIN_UCHAR       ((UCHAR)0)

#define MAX_SHORT       ((SHORT)0x7FFF)
#define MIN_SHORT       ((SHORT)-0x7FFF)

#define MAX_USHORT      ((USHORT)0xFFFF)
#define MIN_USHORT      ((USHORT)0)

#define MAX_INT         ((INT)0x7FFFFFFF)
#define MIN_INT         ((INT)-0x7FFFFFFF)

#define MAX_UINT        ((UINT)0xFFFFFFFF)
#define MIN_UINT        ((UINT)0)

#define MAX_LONG        MAX_INT
#define MIN_LONG        MIN_INT

#define MAX_ULONG       MAX_UINT
#define MIN_ULONG       MIN_UINT

#define MAX_INT64       ((INT64)0x7FFFFFFFFFFFFFFF)
#define MIN_INT64       ((INT64)-0x7FFFFFFFFFFFFFFF)

#define MAX_UINT64      ((UINT64)0xFFFFFFFFFFFFFFFF)
#define MIN_UINT64      ((UINT64)0)

#define MAX_LONGLONG    MAX_INT64
#define MIN_LONGLONG    MIN_INT64

#define MAX_ULONGLONG   MAX_UINT64
#define MIN_ULONGLONG   MIN_UINT64

#define MAX_BYTE        MAX_UCHAR
#define MIN_BYTE        MIN_UCHAR

#define MAX_WORD        MAX_USHORT
#define MIN_WORD        MIN_USHORT

#define MAX_DWORD       MAX_ULONG
#define MIN_DWORD       MIN_ULONG

#define MAX_QWORD       MAX_UINT64
#define MIN_QWORD       MIN_UINT64

#define NUMERIC_CAST(val, type) \
            ((type)min(MAX_##type, max(MIN_##type, val)))

// Sundown
#ifdef WIN64

#pragma warning(disable:4311)   // type cast truncation

#ifndef __midl

__inline unsigned long PtrDiffToUlong(__int64 n64)
{
    return((unsigned long)n64);
}

__inline long PtrDiffToLong(__int64 n64)
{
    return((long)n64);
}

__inline int PtrDiffToInt(__int64 n64)
{
    return((int)n64);
}

#endif // __midl

#pragma warning(3:4311)   // type cast truncation

#else // WIN64

#define PtrDiffToUlong(n64) \
            ((unsigned long)(n64))

#define PtrDiffToLong(n64) \
            ((long)(n64))

#define PtrDiffToInt(n64) \
            ((int)(n64))

#endif // WIN64

#ifdef __cplusplus

#ifdef DEBUG

#define NEW(type) \
            new(TEXT(__FILE__), __LINE__, TEXT(#type)) type

#else // DEBUG

#define NEW(type) \
            new type

#endif // DEBUG

#define DELETE(p) \
            __delete(p), (p) = NULL

#define NEW_HR(p, type) \
            HRFROMP(p = NEW(type))

#endif // __cplusplus

#ifdef USE_INLINE_ASM
#define USE_FAST_RUNTIME
#endif // USE_INLINE_ASM

#ifdef Not_VxD
#define USE_INTRINSICS
#endif // Not_VxD

#define RTAPI static
#define RTCALLTYPE __cdecl

#ifdef USE_FAST_RUNTIME
#include "rtfast.c"
#endif // USE_FAST_RUNTIME

#include "rtslow.c"

#ifndef DEBUG
#undef RTAPI
#define RTAPI __inline
#endif // DEBUG

#include "runtime.c"

#ifdef __cplusplus
#include "runtime.cpp"
#endif // __cplusplus

#endif // __RUNTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\streamer.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        streamer.cpp
 *  Content:     Implementation of class CStreamingThread.
 *  Description: This file contains the thread used by dsound to pull audio
 *               from streaming sources and/or perform FX processing on it.
 *
 *               The following types of object register with us, and we call
 *               them back periodically to do their respective processing:
 *               - CDirectSoundSink: stream data from an IDirectSoundSource.
 *               - CDirectSoundSecondaryBuffer (MIXIN buffers): write silence
 *                 to them in preparation for Send effects writing to them.
 *               - CEffectChain objects: process FX associated with a buffer.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 02/01/00  duganp   Created
 *
 ***************************************************************************/

#include "dsoundi.h"

#ifdef SHARED // Shared dsound.dll (Win9x)

    // Static list of streaming/FX threads (one per dsound process).
    static CList<CStreamingThread*>* g_plstStreamingThreads;

#else // Non-shared dsound.dll (WinNT)

    // A single streaming/FX thread for the current process
    static CStreamingThread* g_pStreamingThread = NULL;

#endif


/***************************************************************************
 *
 *  GetStreamingThread
 *
 *  Description:
 *      Creates a new streaming CStreamingThread object for this process
 *      if none yet exists, and returns a pointer to it.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      CStreamingThread*: pointer to the streaming thread object.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetStreamingThread"

CStreamingThread* GetStreamingThread()
{
    DPF_ENTER();

    CStreamingThread* pStreamer = NULL;

#ifdef SHARED

    if (!g_plstStreamingThreads)
        g_plstStreamingThreads = NEW(CList<CStreamingThread*>);

    // Win9x case - look up streaming object by process ID
    DWORD dwProcId = GetCurrentProcessId();
    CNode<CStreamingThread*> *pStreamerNode;

    for (pStreamerNode = g_plstStreamingThreads->GetListHead(); pStreamerNode && !pStreamer; pStreamerNode = pStreamerNode->m_pNext)
        if (pStreamerNode->m_data->GetOwningProcess() == dwProcId)
            pStreamer = pStreamerNode->m_data;

    if (!pStreamer)
        if (pStreamer = NEW(CStreamingThread))
            if (!g_plstStreamingThreads->AddNodeToList(pStreamer))
                delete pStreamer;

#else // !SHARED

    // WinNT case - much simpler, as usual
    if (!g_pStreamingThread)
        g_pStreamingThread = NEW(CStreamingThread);
    pStreamer = g_pStreamingThread;

#endif // SHARED

    DPF_LEAVE(pStreamer);
    return pStreamer;
}


/***************************************************************************
 *
 *  FreeStreamingThread
 *
 *  Description:
 *      Frees this process's CStreamingThread - called from DllProcessDetach.
 *
 *  Arguments:
 *      DWORD [in]: Process ID of departing process.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FreeStreamingThread"

void FreeStreamingThread(DWORD dwProcessId)
{
    DPF_ENTER();

#ifdef SHARED

    if (g_plstStreamingThreads)
    {
        CNode<CStreamingThread*> *pStreamerNode;
        for (pStreamerNode = g_plstStreamingThreads->GetListHead(); pStreamerNode; pStreamerNode = pStreamerNode->m_pNext)
            if (pStreamerNode->m_data->GetOwningProcess() == dwProcessId)
            {
                delete pStreamerNode->m_data;
                g_plstStreamingThreads->RemoveNodeFromList(pStreamerNode);
                break;
            }
        if (g_plstStreamingThreads->GetNodeCount() == 0)
            DELETE(g_plstStreamingThreads);
    }

#else // !SHARED

    if (g_pStreamingThread)
        delete g_pStreamingThread;

#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CStreamingThread::CStreamingThread
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::CStreamingThread"

CStreamingThread::CStreamingThread() : CThread(FALSE, TEXT("Streaming"))
{
    DPF_ENTER();
    DPF_CONSTRUCT(CStreamingThread);

    // Initialize defaults
    m_dwInterval = INITIAL_WAKE_INTERVAL;
    m_dwWriteAhead = INITIAL_WRITEAHEAD;
    m_dwLastProcTime = MAX_DWORD;
    m_hWakeNow = INVALID_HANDLE_VALUE;
    m_nCallCount = 0;

    #ifdef DEBUG_TIMING  // Read some timing parameters from the registry
    HKEY hkey;
    if (SUCCEEDED(RhRegOpenPath(HKEY_CURRENT_USER, &hkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, TEXT("Streaming thread settings"))))
    {
        if (SUCCEEDED(RhRegGetBinaryValue(hkey, TEXT("Wake interval"), &m_dwInterval, sizeof m_dwInterval)))
            DPF(DPFLVL_INFO, "Read initial processing period %lu from registry", m_dwInterval);
        RhRegCloseKey(&hkey);
    }
    m_dwTickCount = MAX_DWORD;
    #endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CStreamingThread::~CStreamingThread
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::~CStreamingThread"

CStreamingThread::~CStreamingThread()
{
    DPF_ENTER();
    DPF_DESTRUCT(CStreamingThread);

    // Undo the effect of the previous call to timeBeginPeriod(1)
    timeEndPeriod(1); 

    // Check we have no pending clients
    ASSERT(m_lstSinkClient.GetNodeCount() == 0);
    ASSERT(m_lstMixClient.GetNodeCount() == 0);
    ASSERT(m_lstFxClient.GetNodeCount() == 0);

    // Check that we've already terminated the worker thread
    #ifdef WINNT
    ASSERT(!IsThreadRunning());
    #endif
    
    // On Win9x we can't make this assertion, because we may be being freed from
    // DllProcessDetach() in the DDHELP process, which can't terminate our thread.

    // Free resources
    CLOSE_HANDLE(m_hWakeNow);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CStreamingThread::Initialize
 *
 *  Description:
 *      Initializes the CStreamingThread object: creates the wakeup event
 *      and launches the thread itself.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::Initialize"

HRESULT CStreamingThread::Initialize()
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Ensure that we get 1-ms resolution from timeGetTime on NT
    timeBeginPeriod(1); 

    // Create the wakeup event, if it hasn't been created already -
    // FIXME: why are we coming more than once into this function?
    if (!IsValidHandleValue(m_hWakeNow))
    {
        m_hWakeNow = CreateGlobalEvent(NULL, FALSE);
        if (!IsValidHandleValue(m_hWakeNow))
            hr = DSERR_OUTOFMEMORY;
    }

    // Create the worker thread
    if (SUCCEEDED(hr))
        hr = CThread::Initialize();

    // Boost its priority
    if (SUCCEEDED(hr))
        if (!SetThreadPriority(THREAD_PRIORITY_TIME_CRITICAL))
            DPF(DPFLVL_ERROR, "Failed to boost thread priority (error %lu)!", GetLastError());

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CStreamingThread::RegisterSink
 *
 *  Description:
 *      Registers a sink object to be called back by us for processing.
 *
 *  Arguments:
 *      CDirectSoundSink* [in]: sink object to be registered.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::RegisterSink"

HRESULT CStreamingThread::RegisterSink(CDirectSoundSink* pSink)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (!IsThreadRunning())
        hr = Initialize();

    if (SUCCEEDED(hr))
    {
        ASSERT(!m_lstSinkClient.IsDataInList(pSink));
        hr = HRFROMP(m_lstSinkClient.AddNodeToList(pSink));
    }

    if (SUCCEEDED(hr))
        DPF(DPFLVL_MOREINFO, "Registered DirectSound sink at 0x%8.8lX", pSink);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CStreamingThread::RegisterMixBuffer
 *
 *  Description:
 *      Registers a MIXIN buffer to be called back by us for processing.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: buffer to be registered.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::RegisterMixBuffer"

HRESULT CStreamingThread::RegisterMixBuffer(CDirectSoundSecondaryBuffer* pBuffer)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    ASSERT(pBuffer->GetBufferType() & DSBCAPS_MIXIN);

    if (!IsThreadRunning())
        hr = Initialize();

    if (SUCCEEDED(hr))
    {
        ASSERT(!m_lstMixClient.IsDataInList(pBuffer));
        hr = HRFROMP(m_lstMixClient.AddNodeToList(pBuffer));
    }

    if (SUCCEEDED(hr))
        DPF(DPFLVL_MOREINFO, "Registered MIXIN buffer at 0x%p (owned by %s sink)", pBuffer,
            pBuffer->GetBufferType() & DSBCAPS_SINKIN ? TEXT("a") : TEXT("no"));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CStreamingThread::RegisterFxChain
 *
 *  Description:
 *      Registers an FX chain object to be called back by us for processing.
 *
 *  Arguments:
 *      CEffectChain* [in]: FX chain object to be registered.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::RegisterFxChain"

HRESULT CStreamingThread::RegisterFxChain(CEffectChain* pFxChain)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (!IsThreadRunning())
        hr = Initialize();

    if (SUCCEEDED(hr))
    {
        ASSERT(!m_lstFxClient.IsDataInList(pFxChain));
        hr = HRFROMP(m_lstFxClient.AddNodeToListHead(pFxChain));
    }

    // The SetFX() API forces apps to create send chains from the bottom up
    // (i.e. every destination is created before its send).  Hence, adding
    // nodes using AddNodeToListHEAD() here guarantees that sends will be
    // processed before their destinations.

    if (SUCCEEDED(hr))
        DPF(DPFLVL_MOREINFO, "Registered FX chain at 0x%p (associated to a %ssink buffer)", pFxChain,
            pFxChain->m_pDsBuffer->GetBufferType() & DSBCAPS_SINKIN ? TEXT("") : TEXT("non-"));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CStreamingThread::UnregisterSink
 *
 *  Description:
 *      Unregisters a previously registered sink object.
 *
 *  Arguments:
 *      CDirectSoundSink* [in]: sink object to be unregistered.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::UnregisterSink"

void CStreamingThread::UnregisterSink(CDirectSoundSink* pSink)
{
    DPF_ENTER();

    BOOL fSuccess = m_lstSinkClient.RemoveDataFromList(pSink);
    ASSERT(fSuccess);

    MaybeTerminate();

    DPF(DPFLVL_MOREINFO, "Unregistered DirectSound sink at 0x%p", pSink);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CStreamingThread::UnregisterMixBuffer
 *
 *  Description:
 *      Unregisters a previously registered MIXIN buffer.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: buffer to be unregistered.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::UnregisterMixBuffer"

void CStreamingThread::UnregisterMixBuffer(CDirectSoundSecondaryBuffer* pBuffer)
{
    DPF_ENTER();

    BOOL fSuccess = m_lstMixClient.RemoveDataFromList(pBuffer);
    ASSERT(fSuccess);

    MaybeTerminate();

    DPF(DPFLVL_MOREINFO, "Unregistered MIXIN buffer at 0x%p", pBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CStreamingThread::UnregisterFxChain
 *
 *  Description:
 *      Unregisters a previously registered FX chain object.
 *
 *  Arguments:
 *      CEffectChain* [in]: FX chain object to be unregistered.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::UnregisterFxChain"

void CStreamingThread::UnregisterFxChain(CEffectChain* pFxChain)
{
    DPF_ENTER();

    BOOL fSuccess = m_lstFxClient.RemoveDataFromList(pFxChain);
    ASSERT(fSuccess);

    MaybeTerminate();

    DPF(DPFLVL_MOREINFO, "Unregistered FX chain at 0x%p", pFxChain);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CStreamingThread::WakeUpNow
 *
 *  Description:
 *      Sets the wakeup event, so that we'll wake up and perform processing
 *      as soon as the DLL lock becomes available.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::WakeUpNow"

HRESULT CStreamingThread::WakeUpNow()
{
    #ifdef DEBUG_TIMING
    dprintf(DPFLVL_INFO, "Calling " DPF_FNAME);
    #endif

    HRESULT hr;
    DPF_ENTER();

    if (IsThreadRunning())
        hr = SetEvent(m_hWakeNow) ? DS_OK : WIN32ERRORtoHRESULT(GetLastError());
    else
        hr = DSERR_UNINITIALIZED;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CStreamingThread::ThreadProc
 *
 *  Description:
 *      Our thread procedure.  Handles timing calculations and calls
 *      ProcessAudio() to do the actual work.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::ThreadProc"

HRESULT CStreamingThread::ThreadProc()
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    DWORD dwSleep;  // Thread sleep period in milliseconds

    if (m_dwLastProcTime == MAX_DWORD)  // First time through
    {
        dwSleep = m_dwInterval;
    }
    else // Sleep until "last time we ran ProcessAudio() + m_dwInterval"
    {
        dwSleep = m_dwLastProcTime + m_dwInterval - timeGetTime();
        if (LONG(dwSleep) < STREAMING_MIN_PERIOD)
            dwSleep = STREAMING_MIN_PERIOD;  // Minimum sleep period, to allow other threads to run
    }

    #ifdef DEBUG_TIMING
    if (dwSleep == STREAMING_MIN_PERIOD)
        DPF(DPFLVL_MOREINFO, "Using minimum sleep (%d ms)!", STREAMING_MIN_PERIOD);
    m_dwTickCount = timeGetTime();
    #endif    

    // Sleep for dwSleep milliseconds, unless m_hWakeNow kicks us out of bed
    if (TpWaitObjectArray(dwSleep, 1, &m_hWakeNow, NULL))
    {
        #ifdef DEBUG_TIMING
        DWORD dwLastTickCount = m_dwTickCount;
        m_dwTickCount = timeGetTime();
        LONG lDelay = m_dwTickCount - dwLastTickCount - dwSleep;
        if (lDelay > 20 || lDelay < -20)
            DPF(DPFLVL_MOREINFO, "%s thread woke up %d ms %s", m_pszName, ABS(lDelay), lDelay > 0 ? TEXT("late") : TEXT("early"));
        #endif

        // This is where we grab the dsound mutex and lock out anyone else from
        // using any dsound API calls for a while
        if (TpEnterDllMutex())
        {
            DWORD dwProcTime = timeGetTime();

            #ifdef DEBUG_TIMING
            lDelay = dwProcTime - m_dwTickCount;
            if (lDelay > 20)
                DPF(DPFLVL_MOREINFO, "Took %d ms to get the DLL mutex", lDelay);
            #endif
        
            REFERENCE_TIME rtSliceSize;
            if (m_dwLastProcTime == MAX_DWORD)  // First time through
                rtSliceSize = MsToRefTime(INITIAL_WAKE_INTERVAL);
            else
                rtSliceSize = MsToRefTime((dwProcTime - m_dwLastProcTime) % INTERNAL_BUFFER_LENGTH);

            // DPF(DPFLVL_MOREINFO, "Processing a slice of %lu ms", dwProcTime - m_dwLastProcTime);

            // If dwProcTime-m_dwLastProcTime > INTERNAL_BUFFER_LENGTH,
            // we've probably been stopped in the debugger or otherwise
            // interrupted for over INTERNAL_BUFFER_LENGTH milliseconds.
            // Perhaps we should reinitialize everything in this case.

            // Only process if more than 1 ms has passed since the last run.
            // If we've woken up early because someone called WakeUpNow(),
            // too bad; ProcessAudio() requires a non-zero rtSliceSize.
            if (rtSliceSize)
            {
                m_dwLastProcTime = dwProcTime;
                hr = ProcessAudio(rtSliceSize);  // Do the actual work
            }
            #ifdef DEBUG_TIMING
            else DPF(DPFLVL_INFO, "0 ms since last run - skipping ProcessAudio()");
            #endif

            LEAVE_DLL_MUTEX();
        }

        #ifdef DEBUG_TIMING
        lDelay = timeGetTime() - m_dwLastProcTime;
        if (lDelay > 20)
            DPF(DPFLVL_MOREINFO, "%s thread spent %ld ms processing!", m_pszName, lDelay);
        #endif
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CStreamingThread::ProcessAudio
 *
 *  Description:
 *      Loops through all our registered client objects, invoking the
 *      appropriate processing for each.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: Amount of audio to process in reftime units.
 *                           This can be overriden by our sink client[s].
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStreamingThread::ProcessAudio"

HRESULT CStreamingThread::ProcessAudio(REFERENCE_TIME rtSliceSize)
{
    CNode<CDirectSoundSink*>* pSinkNode;            // For iterating through our sinks
    CNode<CEffectChain*>* pFxNode;                  // For iterating through our FX chains
    CNode<CDirectSoundSecondaryBuffer*>* pMixNode;  // For iterating through our MIXIN buffers
    CDirectSoundSecondaryBuffer* pBuf;              // For convenience below
    DWORD dwLatencyBoost = 0;
    HRESULT hr;
    DPF_ENTER();

    ASSERT(rtSliceSize > 0);

    if (m_nCallCount % 100 == 0)
        DPF(DPFLVL_MOREINFO, "%dth call: processing %d sinks, %d MIXIN buffers, %d FX chains", m_nCallCount,
            m_lstSinkClient.GetNodeCount(), m_lstMixClient.GetNodeCount(), m_lstFxClient.GetNodeCount());
    ++m_nCallCount;

    #ifdef DEBUG_TIMING
    DWORD dwBefore = timeGetTime();
    #endif

    //
    // First process the active sinks (this implicitly sets up the current processing
    // slices that we'll use in the FX processing stage below for all sink buffers)
    //

    for (pSinkNode = m_lstSinkClient.GetListHead(); pSinkNode; pSinkNode = pSinkNode->m_pNext)
    {
        hr = pSinkNode->m_data->ProcessSink();
        if (hr != DS_OK)
            DPF(FAILED(hr) ? DPFLVL_ERROR : DPFLVL_INFO, "ProcessSink() at %08X returned %s", pSinkNode->m_data, HRESULTtoSTRING(hr));
    }

    #ifdef DEBUG_TIMING
    DWORD dwAfter = timeGetTime();
    if (dwAfter-dwBefore > 10)
        DPF(DPFLVL_MOREINFO, "Took %d milliseconds to process sinks", dwAfter-dwBefore);
    dwBefore = dwAfter;
    #endif

    //
    // Update the current playing states and processing slices for all "interdependent"
    // buffers (i.e. MIXIN buffers and buffers with sends).  We don't touch the current
    // slice for SINKIN buffers, since these are handled independently by their sink.
    //

    for (pMixNode = m_lstMixClient.GetListHead(); pMixNode; pMixNode = pMixNode->m_pNext)
        if ((pBuf = pMixNode->m_data)->UpdatePlayState() == Playing && !(pBuf->GetBufferType() & DSBCAPS_SINKIN))
            pBuf->MoveCurrentSlice(RefTimeToBytes(rtSliceSize, pBuf->Format()));

    for (pFxNode = m_lstFxClient.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        if (!((pBuf = pFxNode->m_data->m_pDsBuffer)->GetBufferType() & DSBCAPS_MIXIN))
            if (pBuf->UpdatePlayState() == Playing && !(pBuf->GetBufferType() & DSBCAPS_SINKIN) && pFxNode->m_data->m_fHasSend)
                pBuf->MoveCurrentSlice(RefTimeToBytes(rtSliceSize, pBuf->Format()));

    // FIXME: these clunky separate loops argue for unifying MIXIN buffers with FX chains

    //
    // Set up the initial processing slices for any MIXIN buffers and effects chains
    // that have just started playing
    //

    for (pMixNode = m_lstMixClient.GetListHead(); pMixNode; pMixNode = pMixNode->m_pNext)
        pMixNode->m_data->SetInitialSlice(rtSliceSize);

    for (pFxNode = m_lstFxClient.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        pFxNode->m_data->SetInitialSlice(rtSliceSize);

    //
    // Finally process effects (including sends to MIXIN buffers)
    //

    for (pFxNode = m_lstFxClient.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
    {
        hr = pFxNode->m_data->ProcessFx(m_dwWriteAhead, &dwLatencyBoost);
        if (FAILED(hr))
            DPF(DPFLVL_ERROR, "ProcessFx() at %08X failed with %s", pFxNode->m_data, HRESULTtoSTRING(hr));
    }

    #ifdef DEBUG_TIMING
    dwAfter = timeGetTime();
    if (dwAfter - dwBefore > 10)
        DPF(DPFLVL_MOREINFO, "Took %d milliseconds to process effects", dwAfter-dwBefore);
    dwBefore = dwAfter;
    #endif

    //
    // Call CommitToDevice() on the active MIXIN buffers
    //

    for (pMixNode = m_lstMixClient.GetListHead(); pMixNode; pMixNode = pMixNode->m_pNext)
        if ((pBuf = pMixNode->m_data)->IsPlaying())
        {
            DWORD dwStartPos, dwEndPos;
            pBuf->GetCurrentSlice(&dwStartPos, &dwEndPos);
            if (dwStartPos != MAX_DWORD)  // Can happen with sink buffers
            {
                if (dwStartPos < dwEndPos)
                    hr = pBuf->CommitToDevice(dwStartPos, dwEndPos-dwStartPos);
                else // The wraparound case
                {
                    hr = pBuf->CommitToDevice(dwStartPos, pBuf->GetBufferSize()-dwStartPos);
                    if (SUCCEEDED(hr) && dwEndPos != 0)
                        hr = pBuf->CommitToDevice(0, dwEndPos);
                }
                if (FAILED(hr))
                    DPF(DPFLVL_ERROR, "CommitToDevice() at %08X failed with %s", pBuf, HRESULTtoSTRING(hr));
            }
        }

    // Change the latency time as requested by the most-starved client
    // FIXME: this should take into account the 'danger zone', not just actual glitching
    // FIXME: tweak the wakeup interval somehow too?
    #if 0
    if (dwLatencyBoost)
    {
        m_dwWriteAhead += dwLatencyBoost;
        DPF(DPFLVL_MOREINFO, "Boosting %s thread's writeahead by %lu ms (now %lu ms)",
            m_pszName, dwLatencyBoost, m_dwWriteAhead);
    }
    #endif

    // We should always return OK here, barring catastrophic failure -
    // returning a failure code would kill the streaming thread
    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  CStreamingThread::MaybeTerminate
 *
 *  Description:
 *      Terminates the thread if we have no more clients left.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

void CStreamingThread::MaybeTerminate()
{
    if (!m_lstSinkClient.GetNodeCount() && !m_lstMixClient.GetNodeCount() && !m_lstFxClient.GetNodeCount() &&
        GetCurrentProcessId() == GetOwningProcess())  // Only the owning process can terminate a thread
    {
        HRESULT hr = CThread::Terminate();
        ASSERT(SUCCEEDED(hr));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\synch.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       synch.cpp
 *  Content:    Synchronization objects.  The objects defined in this file
 *              allow us to synchronize threads across processes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  7/9/97      dereks  Created
 *
 ***************************************************************************/

#include "dsoundi.h"

#ifdef SHARED
extern "C" HANDLE WINAPI ConvertToGlobalHandle(HANDLE);
#endif // SHARED

// The dll global lock
CLock *g_pDllLock;


/***************************************************************************
 *
 *  GetLocalHandleCopy
 *
 *  Description:
 *      Duplicates a handle into the current process's address space.
 *
 *  Arguments:
 *      HANDLE [in]: handle to duplicate.
 *      DWORD [in]: id of the process that owns the handle.
 *      BOOL [in]: TRUE if the source handle should be closed.
 *
 *  Returns:
 *      HANDLE: local copy of the handle.  Be sure to use CloseHandle to
 *              free this when you're done.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetLocalHandleCopy"

HANDLE GetLocalHandleCopy(HANDLE hSource, DWORD dwOwnerProcessId, BOOL fCloseSource)
{
    const HANDLE            hCurrentProcess     = GetCurrentProcess();
    HANDLE                  hSourceProcess      = NULL;
    HANDLE                  hDest               = NULL;
    DWORD                   dwOptions           = DUPLICATE_SAME_ACCESS;

    ASSERT(hSource);

    if(fCloseSource)
    {
        dwOptions |= DUPLICATE_CLOSE_SOURCE;
    }

    if(dwOwnerProcessId == GetCurrentProcessId())
    {
        hSourceProcess = hCurrentProcess;
    }
    else
    {
        hSourceProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwOwnerProcessId);
        if(!IsValidHandleValue(hSourceProcess))
        {
            DPF(DPFLVL_ERROR, "OpenProcess failed with error %lu", GetLastError());
        }
    }

    if(hSourceProcess)
    {
        if(!DuplicateHandle(hSourceProcess, hSource, hCurrentProcess, &hDest, 0, FALSE, dwOptions))
        {
            DPF(DPFLVL_ERROR, "DuplicateHandle failed with error %lu", GetLastError());
            hDest = NULL;
        }
    }

    if(hCurrentProcess != hSourceProcess)
    {
        CLOSE_HANDLE(hSourceProcess);
    }

    return hDest;
}


/***************************************************************************
 *
 *  GetGlobalHandleCopy
 *
 *  Description:
 *      Duplicates a handle into the global address space.
 *
 *  Arguments:
 *      HANDLE [in]: handle to duplicate.
 *      DWORD [in]: id of the process that owns the handle.
 *      BOOL [in]: TRUE if the source handle should be closed.
 *
 *  Returns:
 *      HANDLE: global copy of the handle.  Be sure to use CloseHandle to
 *              free this when you're done.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetGlobalHandleCopy"

HANDLE GetGlobalHandleCopy(HANDLE hSource, DWORD dwOwnerPid, BOOL fCloseSource)
{
    HANDLE                  hDest;

    hDest = GetLocalHandleCopy(hSource, dwOwnerPid, fCloseSource);

    if(hDest)
    {
        if(!MakeHandleGlobal(&hDest))
        {
            CLOSE_HANDLE(hDest);
        }
    }

    return hDest;
}


/***************************************************************************
 *
 *  MakeHandleGlobal
 *
 *  Description:
 *      Converts a handle to global.
 *
 *  Arguments:
 *      LPHANDLE [in/out]: handle.
 *
 *  Returns:
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MakeHandleGlobal"

BOOL MakeHandleGlobal(LPHANDLE phSource)
{

#ifdef SHARED

    HANDLE                  hDest;
    BOOL                    fSuccess;

    hDest = ConvertToGlobalHandle(*phSource);
    fSuccess = IsValidHandleValue(hDest);

    if(fSuccess)
    {
        *phSource = hDest;
    }
    else
    {
        DPF(DPFLVL_ERROR, "ConvertToGlobalHandle failed with error %lu", GetLastError());
    }

    return fSuccess;

#else // SHARED

    return TRUE;

#endif // SHARED

}


/***************************************************************************
 *
 *  MapHandle
 *
 *  Description:
 *      Maps a handle into the current process's address space.
 *
 *  Arguments:
 *      HANDLE [in]: handle to duplicate.
 *      LPDWORD [in/out]: id of the process that owns the handle.
 *
 *  Returns:
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MapHandle"

BOOL MapHandle(LPHANDLE phSource, LPDWORD pdwOwnerPid)
{
    BOOL                    fSuccess    = TRUE;
    HANDLE                  hDest;

    hDest = GetLocalHandleCopy(*phSource, *pdwOwnerPid, TRUE);

    if(hDest)
    {
        *phSource = hDest;
        *pdwOwnerPid = GetCurrentProcessId();
    }
    else
    {
        fSuccess = FALSE;
    }

    return fSuccess;
}


/***************************************************************************
 *
 *  WaitObjectArray
 *
 *  Description:
 *      Replacement for WaitForSingleObject and WaitForMultipleObjects.
 *
 *  Arguments:
 *      DWORD [in]: count of objects.
 *      DWORD [in]: timeout in ms.
 *      BOOL [in]: TRUE to wait for all objects to be signalled, FALSE to
 *                 return when any of the objects are signalled.
 *      LPHANDLE [in]: object array.
 *
 *  Returns:
 *      DWORD: See WaitForSingleObject/WaitForMultipleObjects.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaitObjectArray"

DWORD WaitObjectArray(DWORD dwCount, DWORD dwTimeout, BOOL fWaitAll, const HANDLE *ahObjects)
{

#ifdef WIN95

    const DWORD             dwEnterTime     = GetTickCount();
    DWORD                   dwDifference;

#endif // WIN95

    DWORD                   dwWait;

#if defined(WIN95) || defined(DEBUG)

    DWORD                   i;

#endif // defined(WIN95) || defined(DEBUG)

#ifdef DEBUG

    // Make sure one of our handles really is invalid
    for(i = 0; i < dwCount; i++)
    {
        ASSERT(IsValidHandleValue(ahObjects[i]));
    }

#endif // DEBUG

#ifdef WIN95

    // This is a Windows 95 bug -- we may have gotten kicked for no reason.
    // If that was the case, we still have valid handles (we think), the OS
    // just goofed up.  So, validate the handles and if they are valid, just
    // return to waiting.  See MANBUGS #3340 for a better explanation.
    while(TRUE)
    {

#endif // WIN95

        // Attempt to wait
        dwWait = WaitForMultipleObjects(dwCount, ahObjects, fWaitAll, dwTimeout);

#ifdef WIN95

        if(WAIT_FAILED == dwWait && ERROR_INVALID_HANDLE == GetLastError())
        {
            // Make sure one of our handles really is invalid
            for(i = 0; i < dwCount; i++)
            {
                if(!IsValidHandle(ahObjects[i]))
                {
                    ASSERT(FALSE);
                    break;
                }
            }

            if(i < dwCount)
            {
                break;
            }
            else
            {
                DPF(DPFLVL_INFO, "Mommy!  Kernel kicked me for no reason!");
                ASSERT(FALSE);
            }

            // Make sure the timeout hasn't elapsed
            if(INFINITE != dwTimeout)
            {
                dwDifference = GetTickCount() - dwEnterTime;

                if(dwDifference >= dwTimeout)
                {
                    // Timeout has elapsed
                    break;
                }
                else
                {
                    // Timeout has not elapsed.  Decrement and go back to
                    // sleep.
                    dwTimeout -= dwDifference;
                }
            }
        }
        else
        {
            break;
        }
    }

#endif // WIN95

    return dwWait;
}


/***************************************************************************
 *
 *  WaitObjectList
 *
 *  Description:
 *      Replacement for WaitForSingleObject and WaitForMultipleObjects.
 *
 *  Arguments:
 *      DWORD [in]: count of objects.
 *      DWORD [in]: timeout in ms.
 *      BOOL [in]: TRUE to wait for all objects to be signalled, FALSE to
 *                 return when any of the objects are signalled.
 *      ... [in]: objects.
 *
 *  Returns:
 *      DWORD: See WaitForSingleObject/WaitForMultipleObjects.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaitObjectList"

DWORD WaitObjectList(DWORD dwCount, DWORD dwTimeout, BOOL fWaitAll, ...)
{
    HANDLE                  ahObjects[MAXIMUM_WAIT_OBJECTS];
    va_list                 va;
    DWORD                   i;

    // Note: we can only handle 64 handles at a time in this
    // function.  Use WaitObjectArray for anything bigger.
    ASSERT(dwCount <= NUMELMS(ahObjects));

    va_start(va, fWaitAll);

    for(i = 0; i < dwCount; i++)
    {
        ahObjects[i] = va_arg(va, HANDLE);
    }

    va_end(va);

    return WaitObjectArray(dwCount, dwTimeout, fWaitAll, ahObjects);
}


/***************************************************************************
 *
 *  CreateGlobalEvent
 *
 *  Description:
 *      Creates a global event.
 *
 *  Arguments:
 *      LPCTSTR [in]: event name.
 *      BOOL [in]: TRUE for a manual reset event.
 *
 *  Returns:
 *      HANDLE: event handle.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateGlobalEvent"

HANDLE CreateGlobalEvent(LPCTSTR pszName, BOOL fManualReset)
{
    HANDLE                  hEvent;

    hEvent = CreateEvent(NULL, fManualReset, FALSE, pszName);

    if(hEvent)
    {
        if(!MakeHandleGlobal(&hEvent))
        {
            CLOSE_HANDLE(hEvent);
        }
    }

    return hEvent;
}


/***************************************************************************
 *
 *  CreateGlobalMutex
 *
 *  Description:
 *      Creates a global mutex.
 *
 *  Arguments:
 *      LPCTSTR [in]: mutex name.
 *
 *  Returns:
 *      HANDLE: mutex handle.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateGlobalMutex"

HANDLE CreateGlobalMutex(LPCTSTR pszName)
{
    HANDLE                  hMutex;

    hMutex = CreateMutex(NULL, FALSE, pszName);

    if(hMutex)
    {
        if(!MakeHandleGlobal(&hMutex))
        {
            CLOSE_HANDLE(hMutex);
        }
    }

    return hMutex;
}


/***************************************************************************
 *
 *  CreateWorkerThread
 *
 *  Description:
 *      Creates a worker thread.
 *
 *  Arguments:
 *      LPTHREAD_START_ROUTINE [in]: pointer to thread function.
 *      BOOL [in]: TRUE to create the thread in the helper process's space.
 *      LPVOID [in]: context argument to be passed to thread function.
 *      LPHANDLE [out]: receives thread handle.
 *      LPDWORD [out]: receives thread id.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateWorkerThread"

HRESULT CreateWorkerThread(LPTHREAD_START_ROUTINE pfnThreadProc, BOOL fHelperProcess, LPVOID pvContext, LPHANDLE phThread, LPDWORD pdwThreadId)
{
    LPDWORD                 pdwLocalThreadId;
    HANDLE                  hThread;
    HRESULT                 hr;

    DPF_ENTER();

    pdwLocalThreadId = MEMALLOC(DWORD);
    hr = HRFROMP(pdwLocalThreadId);

    if(SUCCEEDED(hr))
    {

#ifdef SHARED

        if(fHelperProcess && GetCurrentProcessId() != dwHelperPid)
        {
            hThread = HelperCreateDSFocusThread(pfnThreadProc, pvContext, 0, pdwLocalThreadId);
        }
        else

#endif // SHARED

        {
            hThread = CreateThread(NULL, 0, pfnThreadProc, pvContext, 0, pdwLocalThreadId);
        }

        hr = HRFROMP(hThread);
    }

    if(SUCCEEDED(hr) && phThread)
    {
        *phThread = hThread;
    }

    if(SUCCEEDED(hr) && pdwThreadId)
    {
        *pdwThreadId = *pdwLocalThreadId;
    }

    MEMFREE(pdwLocalThreadId);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CloseThread
 *
 *  Description:
 *      Signals a thread to close.
 *
 *  Arguments:
 *      HANDLE [in]: thread handle.
 *      HANDLE [in]: thread terminate event.
 *      DWORD [in]: thread owning process id.
 *
 *  Returns:
 *      DWORD: thread exit code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CloseThread"

DWORD CloseThread(HANDLE hThread, HANDLE hTerminate, DWORD dwProcessId)
{
    DWORD                   dwExitCode      = -1;
    DWORD                   dwWait;

    DPF_ENTER();

    SetEvent(hTerminate);

    MapHandle(&hThread, &dwProcessId);

    dwWait = WaitObject(INFINITE, hThread);
    ASSERT(WAIT_OBJECT_0 == dwWait);

    GetExitCodeThread(hThread, &dwExitCode);

    CLOSE_HANDLE(hThread);

    DPF_LEAVE(dwExitCode);

    return dwExitCode;
}


/***************************************************************************
 *
 *  GetCurrentProcessActual
 *
 *  Description:
 *      Gets an actual process handle for the current process.
 *      GetCurrentProcess returns a pseudohandle.  The handle returned from
 *      this function must be closed.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HANDLE: process handle.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetCurrentProcessActual"

HANDLE GetCurrentProcessActual(void)
{
    return GetLocalHandleCopy(GetCurrentProcess(), GetCurrentProcessId(), FALSE);
}


/***************************************************************************
 *
 *  GetCurrentThreadActual
 *
 *  Description:
 *      Gets an actual thread handle for the current thread.
 *      GetCurrentThread returns a pseudohandle.  The handle returned from
 *      this function must be closed.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HANDLE: thread handle.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetCurrentThreadActual"

HANDLE GetCurrentThreadActual(void)
{
    return GetLocalHandleCopy(GetCurrentThread(), GetCurrentProcessId(), FALSE);
}


#ifdef DEAD_CODE

/***************************************************************************
 *
 *  CCriticalSectionLock
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#ifdef WINNT

#undef DPF_FNAME
#define DPF_FNAME "CCriticalSectionLock::CCriticalSectionLock"

CCriticalSectionLock::CCriticalSectionLock(void)
{
    InitializeCriticalSection(&m_cs);
}

#endif // WINNT


/***************************************************************************
 *
 *  ~CCriticalSectionLock
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#ifdef WINNT

#undef DPF_FNAME
#define DPF_FNAME "CCriticalSectionLock::~CCriticalSectionLock"

CCriticalSectionLock::~CCriticalSectionLock(void)
{
    DeleteCriticalSection(&m_cs);
}

#endif // WINNT


/***************************************************************************
 *
 *  TryLock
 *
 *  Description:
 *      Tries to take the lock.  If the lock is taken, returns failure.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if the lock was successfully taken.
 *
 ***************************************************************************/

#ifdef WINNT

#undef DPF_FNAME
#define DPF_FNAME "CCriticalSectionLock::TryLock"

BOOL CCriticalSectionLock::TryLock(void)
{
    return TryEnterCriticalSection(&m_cs);
}

#endif // WINNT


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Takes the lock.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#ifdef WINNT

#undef DPF_FNAME
#define DPF_FNAME "CCriticalSectionLock::Lock"

void CCriticalSectionLock::Lock(void)
{
    EnterCriticalSection(&m_cs);
}

#endif // WINNT


/***************************************************************************
 *
 *  LockOrEvent
 *
 *  Description:
 *      Takes the lock if the event is not signalled.
 *
 *  Arguments:
 *      HANDLE [in]: event handle.
 *
 *  Returns:
 *      BOOL: TRUE if the lock was taken.
 *
 ***************************************************************************/

#ifdef WINNT

#undef DPF_FNAME
#define DPF_FNAME "CCriticalSectionLock::LockOrEvent"

BOOL CCriticalSectionLock::LockOrEvent(HANDLE hEvent)
{
    BOOL                    fLock;
    DWORD                   dwWait;

    while(!(fLock = TryEnterCriticalSection(&m_cs)))
    {
        dwWait = WaitObject(0, hEvent);
        ASSERT(WAIT_OBJECT_0 == dwWait || WAIT_TIMEOUT == dwWait);

        if(WAIT_OBJECT_0 == dwWait)
        {
            break;
        }
    }

    return fLock;
}

#endif // WINNT


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Releases the lock.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#ifdef WINNT

#undef DPF_FNAME
#define DPF_FNAME "CCriticalSectionLock::Unlock"

void CCriticalSectionLock::Unlock(void)
{
    LeaveCriticalSection(&m_cs);
}

#endif // WINNT
#endif // DEAD_CODE


/***************************************************************************
 *
 *  CMutexLock
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      LPCTSTR [in]: mutex name.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMutexLock::CMutexLock"

CMutexLock::CMutexLock(LPCTSTR pszName)
{
    m_hMutex = NULL;

    if(pszName)
    {
        m_pszName = MEMALLOC_A_COPY(TCHAR, lstrlen(pszName) + 1, pszName);
    }
    else
    {
        m_pszName = NULL;
    }
}


/***************************************************************************
 *
 *  ~CMutexLock
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMutexLock::~CMutexLock"

CMutexLock::~CMutexLock(void)
{
    CLOSE_HANDLE(m_hMutex);
    MEMFREE(m_pszName);
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMutexLock::Initialize"

HRESULT CMutexLock::Initialize(void)
{
    m_hMutex = CreateGlobalMutex(m_pszName);

    return IsValidHandleValue(m_hMutex) ? DS_OK : DSERR_OUTOFMEMORY;
}


/***************************************************************************
 *
 *  TryLock
 *
 *  Description:
 *      Tries to take the lock.  If the lock is taken, returns failure.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if the lock was successfully taken.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMutexLock::TryLock"

BOOL CMutexLock::TryLock(void)
{
    DWORD                   dwWait;

    dwWait = WaitObject(0, m_hMutex);
    ASSERT(WAIT_OBJECT_0 == dwWait || WAIT_TIMEOUT == dwWait || WAIT_ABANDONED == dwWait);

    return WAIT_OBJECT_0 == dwWait || WAIT_ABANDONED == dwWait;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Takes the lock.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMutexLock::Lock"

void CMutexLock::Lock(void)
{
    DWORD                   dwWait;

    dwWait = WaitObject(INFINITE, m_hMutex);
    ASSERT(WAIT_OBJECT_0 == dwWait || WAIT_ABANDONED == dwWait);
}


/***************************************************************************
 *
 *  LockOrEvent
 *
 *  Description:
 *      Takes the lock if the event is not signalled.
 *
 *  Arguments:
 *      HANDLE [in]: event handle.
 *
 *  Returns:
 *      BOOL: TRUE if the lock was taken.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMutexLock::LockOrEvent"

BOOL CMutexLock::LockOrEvent(HANDLE hEvent)
{
    const HANDLE            ahHandles[] = { m_hMutex, hEvent };
    const UINT              cHandles    = NUMELMS(ahHandles);
    DWORD                   dwWait;

    dwWait = WaitObjectArray(cHandles, INFINITE, FALSE, ahHandles);
    ASSERT(WAIT_OBJECT_0 == dwWait || WAIT_OBJECT_0 + 1 == dwWait || WAIT_ABANDONED == dwWait);

    return WAIT_OBJECT_0 == dwWait || WAIT_ABANDONED == dwWait;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Releases the lock.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMutexLock::Unlock"

void CMutexLock::Unlock(void)
{
    ReleaseMutex(m_hMutex);
}


/***************************************************************************
 *
 *  CManualLock
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CManualLock::CManualLock"

CManualLock::CManualLock(void)
{
    // The manual lock object must live in shared memory.  Otherwise,
    // cross-process synchronization won't work.
    ASSERT(IN_SHARED_MEMORY(this));

    m_fLockLock = FALSE;
    m_dwThreadId = 0;
    m_cRecursion = 0;

#ifdef RDEBUG

    m_hThread = NULL;

#endif // RDEBUG

    m_hUnlockSignal = CreateGlobalEvent(NULL, TRUE);
    ASSERT(IsValidHandleValue(m_hUnlockSignal));

    m_fNeedUnlockSignal = FALSE;
}


/***************************************************************************
 *
 *  ~CManualLock
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CManualLock::~CManualLock"

CManualLock::~CManualLock(void)
{

#ifdef RDEBUG

    CLOSE_HANDLE(m_hThread);

#endif // SHARED

    CLOSE_HANDLE(m_hUnlockSignal);
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CManualLock::Initialize"

HRESULT CManualLock::Initialize(void)
{
    m_hUnlockSignal = CreateGlobalEvent(NULL, TRUE);

    return IsValidHandleValue(m_hUnlockSignal) ? DS_OK : DSERR_OUTOFMEMORY;
}


/***************************************************************************
 *
 *  TryLock
 *
 *  Description:
 *      Tries to take the lock.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if the lock was successfully taken.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CManualLock::TryLock"

BOOL CManualLock::TryLock(void)
{
    const DWORD             dwThreadId  = GetCurrentThreadId();
    BOOL                    fLock       = TRUE;

    // Lock the lock
    while(INTERLOCKED_EXCHANGE(m_fLockLock, TRUE))
    {
        SPIN_SLEEP();
    }

    // Who owns the lock?
    ASSERT(m_cRecursion >= 0);
    ASSERT(m_cRecursion < MAX_LONG);

    if(dwThreadId == m_dwThreadId)
    {
        // We already own the lock.  Increment the recursion count.
        m_cRecursion++;
    }
    else if(m_cRecursion < 1)
    {
        // The owning thread has no active references.
        TakeLock(dwThreadId);
    }

#ifdef RDEBUG

    else if(WAIT_TIMEOUT != WaitObject(0, m_hThread))
    {
        // The owning thread handle is either invalid or signalled
        DPF(DPFLVL_ERROR, "Thread 0x%8.8lX terminated without releasing the lock at 0x%8.8lX!", m_dwThreadId, this);
        ASSERT(FALSE);

        TakeLock(dwThreadId);
    }

#endif // RDEBUG

    else
    {
        // Someone has a valid hold on the lock
        ResetEvent(m_hUnlockSignal);
        m_fNeedUnlockSignal = TRUE;
        fLock = FALSE;
    }

    // Unlock the lock
    INTERLOCKED_EXCHANGE(m_fLockLock, FALSE);

    return fLock;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Takes the lock.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CManualLock::Lock"

void CManualLock::Lock(void)
{
    const HANDLE            ahHandles[] =
    {
        m_hUnlockSignal,

#ifdef RDEBUG

        m_hThread

#endif // RDEBUG

    };

    const UINT              cHandles    = NUMELMS(ahHandles);
    DWORD                   dwWait;

    // Try to take the lock
    while(!TryLock())
    {
        // Wait for the lock to be freed
        dwWait = WaitObjectArray(cHandles, INFINITE, FALSE, ahHandles);
        ASSERT(dwWait >= WAIT_OBJECT_0 && dwWait < WAIT_OBJECT_0 + cHandles);
    }
}


/***************************************************************************
 *
 *  LockOrEvent
 *
 *  Description:
 *      Takes the lock if the event is not signalled.
 *
 *  Arguments:
 *      HANDLE [in]: event handle.
 *
 *  Returns:
 *      BOOL: TRUE if the lock was taken.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CManualLock::LockOrEvent"

BOOL CManualLock::LockOrEvent(HANDLE hEvent)
{
    const HANDLE            ahHandles[] =
    {
        hEvent,
        m_hUnlockSignal,

#ifdef RDEBUG

        m_hThread

#endif // RDEBUG

    };

    const UINT              cHandles    = NUMELMS(ahHandles);
    BOOL                    fLock;
    DWORD                   dwWait;

    // Try to take the lock
    while(!(fLock = TryLock()))
    {
        // Wait for the lock to be freed or hEvent to be signalled
        dwWait = WaitObjectArray(cHandles, INFINITE, FALSE, ahHandles);
        ASSERT(dwWait >= WAIT_OBJECT_0 && dwWait < WAIT_OBJECT_0 + cHandles);

        if(WAIT_OBJECT_0 == dwWait)
        {
            break;
        }
    }

    return fLock;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Releases the lock.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CManualLock::Unlock"

void CManualLock::Unlock(void)
{
    // Lock the lock
    while(INTERLOCKED_EXCHANGE(m_fLockLock, TRUE))
    {
        SPIN_SLEEP();
    }

    // Decrement the recursion count
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    ASSERT(m_cRecursion > 0);

    // Signal that the lock is free
    if(!--m_cRecursion && m_fNeedUnlockSignal)
    {
        m_fNeedUnlockSignal = FALSE;
        SetEvent(m_hUnlockSignal);
    }

    // Unlock the lock
    INTERLOCKED_EXCHANGE(m_fLockLock, FALSE);
}


/***************************************************************************
 *
 *  TakeLock
 *
 *  Description:
 *      Takes the lock.  This function is only called internally.
 *
 *  Arguments:
 *      DWORD [in]: owning thread id.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CManualLock::TakeLock"

inline void CManualLock::TakeLock(DWORD dwThreadId)
{
    // Take over the lock
    m_dwThreadId = dwThreadId;
    m_cRecursion = 1;

#ifdef RDEBUG

    CLOSE_HANDLE(m_hThread);

    m_hThread = GetCurrentThreadActual();

    MakeHandleGlobal(&m_hThread);

#endif // RDEBUG

}


/***************************************************************************
 *
 *  CCallbackEvent
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CCallbackEventPool * [in]: owning pool.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEvent::CCallbackEvent"

CCallbackEvent::CCallbackEvent(CCallbackEventPool *pPool)
    : CEvent(NULL, TRUE)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CCallbackEvent);

    // Initialize defaults
    m_pPool = pPool;
    m_pfnCallback = NULL;
    m_pvCallbackContext = NULL;
    m_fAllocated = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CCallbackEvent
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEvent::~CCallbackEvent"

CCallbackEvent::~CCallbackEvent(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CCallbackEvent);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Allocate
 *
 *  Description:
 *      Allocates or frees the event.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to allocate, FALSE to free.
 *      LPFNEVENTPOOLCALLBACK [in]: callback function pointer.
 *      LPVOID [in]: context argument to pass to callback function.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEvent::Allocate"

void CCallbackEvent::Allocate(BOOL fAlloc, LPFNEVENTPOOLCALLBACK pfnCallback, LPVOID pvCallbackContext)
{
    DPF_ENTER();

    ASSERT(fAlloc != m_fAllocated);

    m_fAllocated = fAlloc;
    m_pfnCallback = pfnCallback;
    m_pvCallbackContext = pvCallbackContext;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  OnEventSignal
 *
 *  Description:
 *      Handles pool event signals.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEvent::OnEventSignal"

void CCallbackEvent::OnEventSignal(void)
{
    DPF_ENTER();

    // Make sure this event is allocated
    if(m_fAllocated)
    {
        // Make sure some other thread hasn't already reset the event.  We
        // have a potential race condition where one thread may lock the
        // pool, set the event, reset the event and unlock the pool.  This
        // will cause the pool's worker thread to see the event as signalled,
        // then block on the lock.  By the time the pool is able to take
        // it's own lock, the event has been reset.  Callers can rely on
        // this functionality to synchronously wait on the event without
        // fear of the worker thread calling them back.
        if(WAIT_OBJECT_0 == Wait(0))
        {
            // Call the callback function.  This function is responsible
            // for resetting the event.
            m_pfnCallback(this, m_pvCallbackContext);
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCallbackEventPool
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEventPool::CCallbackEventPool"

CCallbackEventPool::CCallbackEventPool(BOOL fHelperProcess)
    : CThread(fHelperProcess, TEXT("Callback event pool")),
      m_cTotalEvents(MAXIMUM_WAIT_OBJECTS - m_cThreadEvents)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CCallbackEventPool);

    // Initialize defaults
    m_pahEvents = NULL;
    m_cInUseEvents = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CCallbackEventPool
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEventPool::~CCallbackEventPool"

CCallbackEventPool::~CCallbackEventPool(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CCallbackEventPool);

    // Terminate the worker thread
    CThread::Terminate();

    // Free memory
    MEMFREE(m_pahEvents);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEventPool::Initialize"

HRESULT CCallbackEventPool::Initialize(void)
{
    HRESULT                     hr          = DS_OK;
    CCallbackEvent *            pEvent;
    CNode<CCallbackEvent *> *   pNode;
    UINT                        uIndex;

    DPF_ENTER();

    // Allocate the event table
    m_pahEvents = MEMALLOC_A(HANDLE, m_cTotalEvents);
    hr = HRFROMP(m_pahEvents);

    for(uIndex = 0; uIndex < m_cTotalEvents && SUCCEEDED(hr); uIndex++)
    {
        pEvent = NEW(CCallbackEvent(this));
        hr = HRFROMP(pEvent);

        if(SUCCEEDED(hr))
        {
            m_pahEvents[uIndex] = pEvent->GetEventHandle();
        }

        if(SUCCEEDED(hr))
        {
            pNode = m_lstEvents.AddNodeToList(pEvent);
            hr = HRFROMP(pNode);
        }

        RELEASE(pEvent);
    }

    // Create the worker thread
    if(SUCCEEDED(hr))
    {
        hr = CThread::Initialize();
    }

    // Boost its priority
    if (SUCCEEDED(hr))
        if (FAILED(SetThreadPriority(THREAD_PRIORITY_TIME_CRITICAL)))
            DPF(DPFLVL_ERROR, "Failed to boost thread priority (error %lu)!", GetLastError());

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AllocEvent
 *
 *  Description:
 *      Allocates an event from the pool.
 *
 *  Arguments:
 *      LPFNEVENTPOOLCALLBACK [in]: callback function pointer.
 *      LPVOID [in]: context argument to pass to callback function.
 *      CCallbackEvent ** [out]: receives callback event pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.  If no more events are
 *               available, DSERR_OUTOFMEMORY.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEventPool::AllocEvent"

HRESULT CCallbackEventPool::AllocEvent(LPFNEVENTPOOLCALLBACK pfnCallback, LPVOID pvCallbackContext, CCallbackEvent **ppEvent)
{
    HRESULT                     hr      = DS_OK;
    CNode<CCallbackEvent *> *   pNode;

    DPF_ENTER();

    // Are there any free events?
    if(!GetFreeEventCount())
    {
        ASSERT(GetFreeEventCount());
        hr = DSERR_OUTOFMEMORY;
    }

    // Find the first free event in the pool
    if(SUCCEEDED(hr))
    {
        for(pNode = m_lstEvents.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(!pNode->m_data->m_fAllocated)
            {
                break;
            }
        }

        ASSERT(pNode);
    }

    // Set up the pool entry
    if(SUCCEEDED(hr))
    {
        ASSERT(WAIT_TIMEOUT == pNode->m_data->Wait(0));

        pNode->m_data->Allocate(TRUE, pfnCallback, pvCallbackContext);
        m_cInUseEvents++;
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppEvent = pNode->m_data;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeEvent
 *
 *  Description:
 *      Frees an event previously allocated from the pool.
 *
 *  Arguments:
 *      CCallbackEvent * [in]: event.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEventPool::FreeEvent"

HRESULT CCallbackEventPool::FreeEvent(CCallbackEvent *pEvent)
{
    DPF_ENTER();

    ASSERT(this == pEvent->m_pPool);
    ASSERT(pEvent->m_fAllocated);

    // Mark the event as free
    pEvent->Allocate(FALSE, NULL, NULL);
    m_cInUseEvents--;

    // Make sure the event is reset so the worker thread will ignore it
    pEvent->Reset();

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  ThreadProc
 *
 *  Description:
 *      Event pool worker thread proc.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCallbackEventPool::ThreadProc"

HRESULT CCallbackEventPool::ThreadProc(void)
{
    BOOL                        fContinue;
    DWORD                       dwWait;
    UINT                        nIndex;
    CNode<CCallbackEvent *> *   pNode;

    DPF_ENTER();

    // Wait for some event to be signalled
    fContinue = TpWaitObjectArray(INFINITE, m_cTotalEvents, m_pahEvents, &dwWait);

    if(fContinue)
    {
        nIndex = dwWait - WAIT_OBJECT_0;

        if(nIndex < m_cTotalEvents)
        {
            // One of the pool's events was signalled
            fContinue = TpEnterDllMutex();

            if(fContinue)
            {
                pNode = m_lstEvents.GetNodeByIndex(nIndex);
                pNode->m_data->OnEventSignal();

                LEAVE_DLL_MUTEX();
            }
        }
        else
        {
            // Something bad happened
            ASSERT(FALSE);
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  CMultipleCallbackEventPool
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to create the thread in the helper process's
 *                 context.
 *      UINT [in]: number of pools to always keep around.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultipleCallbackEventPool::CMultipleCallbackEventPool"

CMultipleCallbackEventPool::CMultipleCallbackEventPool(BOOL fHelperProcess, UINT uReqPoolCount)
    : CCallbackEventPool(fHelperProcess), m_fHelperProcess(fHelperProcess), m_uReqPoolCount(uReqPoolCount)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CMultipleCallbackEventPool);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CMultipleCallbackEventPool
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultipleCallbackEventPool::~CMultipleCallbackEventPool"

CMultipleCallbackEventPool::~CMultipleCallbackEventPool(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CMultipleCallbackEventPool);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultipleCallbackEventPool::Initialize"

HRESULT CMultipleCallbackEventPool::Initialize(void)
{
    HRESULT                 hr  = DS_OK;
    UINT                    i;

    DPF_ENTER();

    // Create the required number of pools
    for(i = 0; i < m_uReqPoolCount && SUCCEEDED(hr); i++)
    {
        hr = CreatePool(NULL);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AllocEvent
 *
 *  Description:
 *      Allocates an event from the pool.
 *
 *  Arguments:
 *      LPFNEVENTPOOLCALLBACK [in]: callback function pointer.
 *      LPVOID [in]: context argument to pass to callback function.
 *      CCallbackEvent ** [out]: receives pointer to the event within the
 *                               pool
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.  If no more events are
 *               available, DSERR_OUTOFMEMORY.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultipleCallbackEventPool::AllocEvent"

HRESULT CMultipleCallbackEventPool::AllocEvent(LPFNEVENTPOOLCALLBACK pfnCallback, LPVOID pvCallbackContext, CCallbackEvent **ppEvent)
{
    HRESULT                         hr      = DS_OK;
    CCallbackEventPool *            pPool   = NULL;
    CNode<CCallbackEventPool *> *   pNode;

    DPF_ENTER();

    // Find a free pool
    for(pNode = m_lstPools.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        if(pNode->m_data->GetFreeEventCount())
        {
            pPool = pNode->m_data;
            break;
        }
    }

    // If there are no free pools, create a new one
    if(!pPool)
    {
        hr = CreatePool(&pPool);
    }

    // Allocate the event
    if(SUCCEEDED(hr))
    {
        hr = pPool->AllocEvent(pfnCallback, pvCallbackContext, ppEvent);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeEvent
 *
 *  Description:
 *      Frees an event previously allocated from the pool.
 *
 *  Arguments:
 *      CCallbackEvent * [in]: event.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultipleCallbackEventPool::FreeEvent"

HRESULT CMultipleCallbackEventPool::FreeEvent(CCallbackEvent *pEvent)
{
    CCallbackEventPool *    pPool;
    HRESULT                 hr;

    DPF_ENTER();

    // Free the event
    pPool = pEvent->m_pPool;
    hr = pPool->FreeEvent(pEvent);

    // The code below is removed because there's a possibility that
    // the thread we're trying to terminate in FreePool is the same
    // as the thread we're calling on.

#if 0

    // Can we free this pool?
    if(SUCCEEDED(hr))
    {
        if(pPool->GetFreeEventCount() == pPool->GetTotalEventCount())
        {
            if(m_lstPools.GetNodeCount() > m_uReqPoolCount)
            {
                hr = FreePool(pPool);
            }
        }
    }

#endif

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePool
 *
 *  Description:
 *      Creates a new pool.
 *
 *  Arguments:
 *      CCallbackEventPool ** [out]: receives pool pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultipleCallbackEventPool::CreatePool"

HRESULT CMultipleCallbackEventPool::CreatePool(CCallbackEventPool **ppPool)
{
    CCallbackEventPool *            pPool   = NULL;
    CNode<CCallbackEventPool *> *   pNode   = NULL;
    HRESULT                         hr;

    DPF_ENTER();

    DPF(DPFLVL_INFO, "Creating callback event pool number %lu", m_lstPools.GetNodeCount());

    // Create the pool
    pPool = NEW(CCallbackEventPool(m_fHelperProcess));
    hr = HRFROMP(pPool);

    if(SUCCEEDED(hr))
    {
        hr = pPool->Initialize();
    }

    // Add the pool to the list
    if(SUCCEEDED(hr))
    {
        pNode = m_lstPools.AddNodeToList(pPool);
        hr = HRFROMP(pNode);
    }

    // Success
    if(SUCCEEDED(hr) && ppPool)
    {
        *ppPool = pPool;
    }

    // Clean up
    RELEASE(pPool);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreePool
 *
 *  Description:
 *      Frees a pool.
 *
 *  Arguments:
 *      CCallbackEventPool * [in]: pool pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMultipleCallbackEventPool::FreePool"

HRESULT CMultipleCallbackEventPool::FreePool(CCallbackEventPool *pPool)
{
    DPF_ENTER();

    m_lstPools.RemoveDataFromList(pPool);

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  CSharedMemoryBlock
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSharedMemoryBlock::CSharedMemoryBlock"

const CSharedMemoryBlock::m_fLock = TRUE;

CSharedMemoryBlock::CSharedMemoryBlock(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CSharedMemoryBlock);

    // Initialize defaults
    m_plck = NULL;
    m_hFileMappingObject = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CSharedMemoryBlock
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSharedMemoryBlock::~CSharedMemoryBlock"

CSharedMemoryBlock::~CSharedMemoryBlock(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CSharedMemoryBlock);

    // Close the file mapping object
    CLOSE_HANDLE(m_hFileMappingObject);

    // Release the lock
    DELETE(m_plck);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: protection flags.
 *      QWORD [in]: maximum file size.
 *      LPCTSTR [in]: object name.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSharedMemoryBlock::Initialize"

HRESULT CSharedMemoryBlock::Initialize(DWORD flProtect, QWORD qwMaxFileSize, LPCTSTR pszName)
{
    const LPCTSTR           pszLockExt  = TEXT(" (lock)");
    LPTSTR                  pszLockName = NULL;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    // Create the lock object
    if(m_fLock)
    {
        if(pszName)
        {
            pszLockName = MEMALLOC_A(TCHAR, lstrlen(pszName) + lstrlen(pszLockExt) + 1);
            hr = HRFROMP(pszLockName);

            if(SUCCEEDED(hr))
            {
                lstrcpy(pszLockName, pszName);
                lstrcat(pszLockName, pszLockExt);
            }
        }

        if(SUCCEEDED(hr))
        {
            m_plck = NEW(CMutexLock(pszLockName));
            hr = HRFROMP(m_plck);
        }

        if(SUCCEEDED(hr))
        {
            hr = m_plck->Initialize();
        }

        if(FAILED(hr))
        {
            DELETE(m_plck);
        }

        MEMFREE(pszLockName);
    }

    Lock();

    // Does the mapping object already exist?
    if(SUCCEEDED(hr))
    {
        m_hFileMappingObject = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, pszName);
    }

    // If not, create a new one
    if(SUCCEEDED(hr) && !IsValidHandleValue(m_hFileMappingObject))
    {
        // Adjust the size of the file mapping object to allow for us to
        // write the current size.
        qwMaxFileSize += sizeof(DWORD);

        // Create the file mapping object
        m_hFileMappingObject = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, flProtect, (DWORD)((qwMaxFileSize >> 32) & 0x00000000FFFFFFFF), (DWORD)qwMaxFileSize, pszName);

        if(!IsValidHandleValue(m_hFileMappingObject))
        {
            DPF(DPFLVL_ERROR, "CreateFileMapping failed with error %lu", GetLastError());
            hr = GetLastErrorToHRESULT();
        }

        // Set the file size
        if(SUCCEEDED(hr))
        {
            hr = Write(NULL, 0);
        }
    }

    if(SUCCEEDED(hr))
    {
        if(!MakeHandleGlobal(&m_hFileMappingObject))
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    Unlock();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Read
 *
 *  Description:
 *      Reads the object.
 *
 *  Arguments:
 *      LPVOID * [out]: receives pointer to memory location.  The caller is
 *                      responsible for freeing this memory.
 *      LPDWORD [out]: receives size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSharedMemoryBlock::Read"

HRESULT CSharedMemoryBlock::Read(LPVOID *ppv, LPDWORD pcb)
{
    LPVOID                  pvMap   = NULL;
    LPVOID                  pvRead  = NULL;
    HRESULT                 hr      = DS_OK;
    DWORD                   dwSize;

    DPF_ENTER();

    Lock();

    // Map the first DWORD of the file into memory.  This first DWORD
    // contains the file size.
    pvMap = MapViewOfFile(m_hFileMappingObject, FILE_MAP_READ, 0, 0, sizeof(dwSize));

    if(!pvMap)
    {
        DPF(DPFLVL_ERROR, "MapViewOfFile failed with %lu", GetLastError());
        hr = GetLastErrorToHRESULT();
    }

    if(SUCCEEDED(hr))
    {
        dwSize = *(LPDWORD)pvMap;
    }

    if(pvMap)
    {
        UnmapViewOfFile(pvMap);
    }

    // Map the rest of the file into memory
    if(SUCCEEDED(hr) && dwSize)
    {
        pvMap = MapViewOfFile(m_hFileMappingObject, FILE_MAP_READ, 0, 0, sizeof(dwSize) + dwSize);

        if(!pvMap)
        {
            DPF(DPFLVL_ERROR, "MapViewOfFile failed with %lu", GetLastError());
            hr = GetLastErrorToHRESULT();
        }

        // Allocate a buffer for the rest of the data
        if(SUCCEEDED(hr))
        {
            pvRead = MEMALLOC_A(BYTE, dwSize);
            hr = HRFROMP(pvRead);
        }

        if(SUCCEEDED(hr))
        {
            CopyMemory(pvRead, (LPDWORD)pvMap + 1, dwSize);
        }

        if(pvMap)
        {
            UnmapViewOfFile(pvMap);
        }
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppv = pvRead;
        *pcb = dwSize;
    }

    Unlock();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Write
 *
 *  Description:
 *      Writes the object.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to new data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSharedMemoryBlock::Write"

HRESULT CSharedMemoryBlock::Write(LPVOID pv, DWORD cb)
{
    LPVOID                  pvMap   = NULL;
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    Lock();

    // Map the file into memory, adjusting the size by sizeof(DWORD)
    pvMap = MapViewOfFile(m_hFileMappingObject, FILE_MAP_WRITE, 0, 0, cb + sizeof(DWORD));

    if(!pvMap)
    {
        DPF(DPFLVL_ERROR, "MapViewOfFile failed with %lu", GetLastError());
        hr = GetLastErrorToHRESULT();
    }
    else
    {
        // Write the file size
        *(LPDWORD)pvMap = cb;

        // Write the rest of the data
        CopyMemory((LPDWORD)pvMap + 1, pv, cb);

        // Clean up
        UnmapViewOfFile(pvMap);
    }

    Unlock();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CThread
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to create the thread in the helper process's
 *                 context.
 *      LPCTSTR [in]: thread name.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::CThread"

const UINT CThread::m_cThreadEvents = 1;

CThread::CThread
(
    BOOL                    fHelperProcess,
    LPCTSTR                 pszName
)
    : m_fHelperProcess(fHelperProcess), m_pszName(pszName)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CThread);

    m_hThread = NULL;
    m_dwThreadProcessId = 0;
    m_dwThreadId = 0;
    m_hTerminate = NULL;
    m_hInitialize = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CThread
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::~CThread"

CThread::~CThread
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CThread);

    ASSERT(!m_hThread);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPVOID [in]: context argument.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::Initialize"

HRESULT
CThread::Initialize
(
    void
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(!m_hThread);

    // Create the synchronization events
    m_hTerminate = CreateGlobalEvent(NULL, TRUE);
    hr = HRFROMP(m_hTerminate);

    if(SUCCEEDED(hr))
    {
        m_hInitialize = CreateGlobalEvent(NULL, TRUE);
        hr = HRFROMP(m_hInitialize);
    }

    // Create the thread
    if(SUCCEEDED(hr))
    {
        hr = CreateWorkerThread(ThreadStartRoutine, m_fHelperProcess, this, &m_hThread, NULL);
    }

    // Wait for the initialize event to be signalled
    if(SUCCEEDED(hr))
    {
        WaitObject(INFINITE, m_hInitialize);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Terminate
 *
 *  Description:
 *      Terminates the thread.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::Terminate"

HRESULT
CThread::Terminate
(
    void
)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwWait;

    DPF_ENTER();

    ASSERT(GetCurrentThreadId() != m_dwThreadId);

    // Make sure the thread handle is valid
    if(IsValidHandleValue(m_hThread))
    {
        MapHandle(&m_hThread, &m_dwThreadProcessId);

        dwWait = WaitObject(0, m_hThread);
        ASSERT(WAIT_TIMEOUT == dwWait || WAIT_OBJECT_0 == dwWait);

        if(WAIT_TIMEOUT != dwWait)
        {
            CLOSE_HANDLE(m_hThread);
        }
    }

    // Terminate the thread
    if(IsValidHandleValue(m_hThread))
    {
        hr = CloseThread(m_hThread, m_hTerminate, m_dwThreadProcessId);
    }

    if(SUCCEEDED(hr))
    {
        m_hThread = NULL;
        m_dwThreadId = 0;
    }

    // Free the synchronization events
    CLOSE_HANDLE(m_hTerminate);
    CLOSE_HANDLE(m_hInitialize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  ThreadInit
 *
 *  Description:
 *      Thread initialization routine.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::ThreadInit"

HRESULT
CThread::ThreadInit
(
    void
)
{
    DPF_ENTER();

    if(m_pszName)
    {
        DPF(DPFLVL_INFO, "%s worker thread has joined the party", m_pszName);
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  ThreadLoop
 *
 *  Description:
 *      Main thread loop.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::ThreadLoop"

HRESULT
CThread::ThreadLoop
(
    void
)
{
    HRESULT                 hr          = DS_OK;
    DWORD                   dwWait;

    DPF_ENTER();

    while(SUCCEEDED(hr))
    {
        dwWait = WaitObject(0, m_hTerminate);
        ASSERT(WAIT_OBJECT_0 == dwWait || WAIT_TIMEOUT == dwWait);

        if(WAIT_OBJECT_0 == dwWait)
        {
            break;
        }

        hr = ThreadProc();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  ThreadExit
 *
 *  Description:
 *      Thread cleanup routine.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::ThreadExit"

HRESULT
CThread::ThreadExit
(
    void
)
{
    DPF_ENTER();

    if(m_pszName)
    {
        DPF(DPFLVL_INFO, "%s worker thread is Audi 5000", m_pszName);
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  TpEnterDllMutex
 *
 *  Description:
 *      Attempts to take the DLL mutex.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if the thread should continue processing.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::TpEnterDllMutex"

BOOL
CThread::TpEnterDllMutex
(
    void
)
{
    BOOL                    fContinue   = TRUE;

    DPF_ENTER();

    // Any functions that are called from the worker thread must first
    // check for m_hTerminate before taking the DLL mutex.  This is
    // because of a long list of deadlock circumstances that we could
    // end up in.  Don't ask questions.
    if(GetCurrentThreadId() == m_dwThreadId)
    {
        fContinue = ENTER_DLL_MUTEX_OR_EVENT(m_hTerminate);
    }
    else
    {
        ENTER_DLL_MUTEX();
    }

    DPF_LEAVE(fContinue);

    return fContinue;
}


/***************************************************************************
 *
 *  TpWaitObjectArray
 *
 *  Description:
 *      Waits for objects while in the context of the thread proc.
 *
 *  Arguments:
 *      DWORD [in]: timeout.
 *      DWORD [in]: event count.
 *      LPHANDLE [in]: handle array.
 *      LPDWORD [out]: receives return from WaitObjectArray.
 *
 *  Returns:
 *      BOOL: TRUE if the thread should continue processing.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::TpWaitObjectArray"

BOOL
CThread::TpWaitObjectArray
(
    DWORD                   dwTimeout,
    DWORD                   cEvents,
    const HANDLE *          ahEvents,
    LPDWORD                 pdwWait
)
{
    BOOL                    fContinue                           = TRUE;
    HANDLE                  ahWaitEvents[MAXIMUM_WAIT_OBJECTS];
    DWORD                   dwWait;
    UINT                    i;

    DPF_ENTER();

    if(GetCurrentThreadId() == m_dwThreadId)
    {
        // We're in the context of the worker thread.  We need to make sure
        // we wait on all the events *plus* the thread terminate event.
        ahWaitEvents[0] = m_hTerminate;

        for(i = 0; i < cEvents; i++)
        {
            ahWaitEvents[i + 1] = ahEvents[i];
        }

        dwWait = WaitObjectArray(cEvents + 1, dwTimeout, FALSE, ahWaitEvents);
        ASSERT(WAIT_FAILED != dwWait);

        if(WAIT_OBJECT_0 == dwWait)
        {
            // Terminate event was signalled
            fContinue = FALSE;
        }
        else if(pdwWait)
        {
            *pdwWait = dwWait;

            // Fix up the wait value so that it doesn't include the terminate
            // event.
            if(*pdwWait >= WAIT_OBJECT_0 + 1 && *pdwWait < WAIT_OBJECT_0 + 1 + cEvents)
            {
                *pdwWait -= 1;
            }
        }
    }
    else
    {
        if (cEvents)
        {
            dwWait = WaitObjectArray(cEvents, dwTimeout, FALSE, ahEvents);

            if(pdwWait)
            {
                *pdwWait = dwWait;
            }
        }
        else
        {
            // Attempt to use 0-object wait as a timeout
            Sleep(dwTimeout);

            if (pdwWait)
            {
                *pdwWait = WAIT_TIMEOUT;
            }
        }
    }

    DPF_LEAVE(fContinue);

    return fContinue;
}


/***************************************************************************
 *
 *  ThreadStartRoutine
 *
 *  Description:
 *      Thread entry point.
 *
 *  Arguments:
 *      LPVOID [in]: thread context.
 *
 *  Returns:
 *      DWORD: thread exit code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::ThreadStartRoutine"

DWORD WINAPI
CThread::ThreadStartRoutine
(
    LPVOID                  pvContext
)
{
    CThread *               pThis   = (CThread *)pvContext;
    HRESULT                 hr;

    DPF_ENTER();

    hr = pThis->PrivateThreadProc();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  PrivateThreadProc
 *
 *  Description:
 *      Thread entry point.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CThread::PrivateThreadProc"

HRESULT
CThread::PrivateThreadProc
(
    void
)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Save the worker thread process and thread id
    m_dwThreadProcessId = GetCurrentProcessId();
    m_dwThreadId = GetCurrentThreadId();

    // Call the thread's initialization routine
    hr = ThreadInit();

    // Signal that initialization is complete
    if(SUCCEEDED(hr))
    {
        SetEvent(m_hInitialize);
    }

    // Enter the thread loop
    if(SUCCEEDED(hr))
    {
        hr = ThreadLoop();
    }

    // Call the thread cleanup routine
    if(SUCCEEDED(hr))
    {
        hr = ThreadExit();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\synch.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       synch.h
 *  Content:    Synchronization objects.  The objects defined in this file
 *              allow us to synchronize threads across processes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/13/97     dereks  Created
 *
 ***************************************************************************/

#ifndef __SYNCH_H__
#define __SYNCH_H__

// Interlocked helper macros
#define INTERLOCKED_EXCHANGE(a, b) \
            InterlockedExchange((LPLONG)&(a), (LONG)(b))

#define INTERLOCKED_INCREMENT(a) \
            InterlockedIncrement((LPLONG)&(a))

#define INTERLOCKED_DECREMENT(a) \
            InterlockedDecrement((LPLONG)&(a))

// Blind spinning is bad.  Even (especially) on NT, it can bring the system
// to it's knees.
#define SPIN_SLEEP() \
            Sleep(10)

#ifdef __cplusplus

// The preferred lock type
#define CPreferredLock      CMutexLock

// Lock base class
class CLock
{
public:
    inline CLock(void) { }
    inline virtual ~CLock(void) { }

public:
    // Creation
    virtual HRESULT Initialize(void) = 0;

    // Lock use
    virtual BOOL TryLock(void) = 0;
    virtual BOOL LockOrEvent(HANDLE) = 0;
    virtual void Lock(void) = 0;
    virtual void Unlock(void) = 0;
};

#ifdef DEAD_CODE
#ifdef WINNT

// Critical section lock
class CCriticalSectionLock
    : public CLock
{
protected:
    CRITICAL_SECTION        m_cs;

public:
    CCriticalSectionLock(void);
    virtual ~CCriticalSectionLock(void);

public:
    // Creation
    virtual HRESULT Initialize(void);

    // Lock use
    virtual BOOL TryLock(void);
    virtual void Lock(void);
    virtual BOOL LockOrEvent(HANDLE);
    virtual void Unlock(void);
};

inline HRESULT CCriticalSectionLock::Initialize(void)
{
    return DS_OK;
}

#endif // WINNT
#endif // DEAD_CODE

// Mutex lock
class CMutexLock
    : public CLock
{
protected:
    HANDLE                  m_hMutex;
    LPTSTR                  m_pszName;

public:
    CMutexLock(LPCTSTR pszName = NULL);
    virtual ~CMutexLock(void);

public:
    // Creation
    virtual HRESULT Initialize(void);

    // Lock use
    virtual BOOL TryLock(void);
    virtual void Lock(void);
    virtual BOOL LockOrEvent(HANDLE);
    virtual void Unlock(void);
};

// Manual lock
class CManualLock
    : public CLock
{
protected:
    BOOL                    m_fLockLock;
    DWORD                   m_dwThreadId;
    LONG                    m_cRecursion;

#ifdef RDEBUG

    HANDLE                  m_hThread;

#endif // RDEBUG

private:
    HANDLE                  m_hUnlockSignal;
    BOOL                    m_fNeedUnlockSignal;

public:
    CManualLock(void);
    virtual ~CManualLock(void);

public:
    // Creation
    virtual HRESULT Initialize(void);

    // Lock use
    virtual BOOL TryLock(void);
    virtual void Lock(void);
    virtual BOOL LockOrEvent(HANDLE);
    virtual void Unlock(void);

protected:
    void TakeLock(DWORD);
};

// Event wrapper object
class CEvent
    : public CDsBasicRuntime
{
protected:
    HANDLE              m_hEvent;

public:
    CEvent(LPCTSTR = NULL, BOOL = FALSE);
    CEvent(HANDLE, DWORD, BOOL);
    virtual ~CEvent(void);

public:
    virtual DWORD Wait(DWORD);
    virtual BOOL Set(void);
    virtual BOOL Reset(void);
    virtual HANDLE GetEventHandle(void);
};

// Thread object
class CThread
{
protected:
    static const UINT       m_cThreadEvents;            // Count of events used by the thread
    const BOOL              m_fHelperProcess;           // Create thread in helper process?
    const LPCTSTR           m_pszName;                  // Thread name
    HANDLE                  m_hThread;                  // Thread handle
    DWORD                   m_dwThreadProcessId;        // Thread owner process id
    DWORD                   m_dwThreadId;               // Thread id
    HANDLE                  m_hTerminate;               // Terminate event
    HANDLE                  m_hInitialize;              // Initialization event

public:
    CThread(BOOL, LPCTSTR = NULL);
    virtual ~CThread(void);

public:
    virtual HRESULT Initialize(void);
    virtual HRESULT Terminate(void);

    DWORD GetOwningProcess() {return m_dwThreadProcessId;}
    BOOL SetThreadPriority(int nPri) {return ::SetThreadPriority(m_hThread, nPri);}

protected:
    // Thread processes
    virtual HRESULT ThreadInit(void);
    virtual HRESULT ThreadLoop(void);
    virtual HRESULT ThreadProc(void) = 0;
    virtual HRESULT ThreadExit(void);

    // Thread synchronization
    virtual BOOL TpEnterDllMutex(void);
    virtual BOOL TpWaitObjectArray(DWORD, DWORD, const HANDLE *, LPDWORD);

private:
    static DWORD WINAPI ThreadStartRoutine(LPVOID);
    virtual HRESULT PrivateThreadProc(void);
};

// Callback event callback function
typedef void (CALLBACK *LPFNEVENTPOOLCALLBACK)(class CCallbackEvent *, LPVOID);

// Callback event
class CCallbackEvent
    : public CEvent
{
    friend class CCallbackEventPool;
    friend class CMultipleCallbackEventPool;

protected:
    CCallbackEventPool *    m_pPool;                // Owning event pool
    LPFNEVENTPOOLCALLBACK   m_pfnCallback;          // Callback function for when the event is signalled
    LPVOID                  m_pvCallbackContext;    // Context argument to pass to the callback function
    BOOL                    m_fAllocated;           // Is this event currently allocated?

public:
    CCallbackEvent(CCallbackEventPool *);
    virtual ~CCallbackEvent(void);

protected:
    virtual void Allocate(BOOL, LPFNEVENTPOOLCALLBACK, LPVOID);
    virtual void OnEventSignal(void);
};

// Callback event pool object
class CCallbackEventPool
    : public CDsBasicRuntime, private CThread
{
    friend class CCallbackEvent;

protected:
    const UINT                  m_cTotalEvents;         // The total number of events in the queue
    CObjectList<CCallbackEvent> m_lstEvents;            // The event table
    LPHANDLE                    m_pahEvents;            // The event table (part 2)
    UINT                        m_cInUseEvents;         // The number of events in use

public:
    CCallbackEventPool(BOOL);
    virtual ~CCallbackEventPool(void);

public:
    // Creation
    virtual HRESULT Initialize(void);

    // Event allocation
    virtual HRESULT AllocEvent(LPFNEVENTPOOLCALLBACK, LPVOID, CCallbackEvent **);
    virtual HRESULT FreeEvent(CCallbackEvent *);

    // Pool status
    virtual UINT GetTotalEventCount(void);
    virtual UINT GetFreeEventCount(void);

private:
    // The worker thread proc
    virtual HRESULT ThreadProc(void);
};

inline UINT CCallbackEventPool::GetTotalEventCount(void)
{
    return m_cTotalEvents;
}

inline UINT CCallbackEventPool::GetFreeEventCount(void)
{
    ASSERT(m_cTotalEvents >= m_cInUseEvents);
    return m_cTotalEvents - m_cInUseEvents;
}

// Event pool manager
class CMultipleCallbackEventPool
    : public CCallbackEventPool
{
private:
    const BOOL                      m_fHelperProcess;       // Create threads in the helper process?
    const UINT                      m_uReqPoolCount;        // List of required pools
    CObjectList<CCallbackEventPool> m_lstPools;             // List of event pools

public:
    CMultipleCallbackEventPool(BOOL, UINT);
    virtual ~CMultipleCallbackEventPool(void);

public:
    // Creation
    virtual HRESULT Initialize(void);

    // Event allocation
    virtual HRESULT AllocEvent(LPFNEVENTPOOLCALLBACK, LPVOID, CCallbackEvent **);
    virtual HRESULT FreeEvent(CCallbackEvent *);

private:
    // Pool creation
    virtual HRESULT CreatePool(CCallbackEventPool **);
    virtual HRESULT FreePool(CCallbackEventPool *);
};

// Wrapper class for objects that use a callback event
class CUsesCallbackEvent
{
public:
    CUsesCallbackEvent(void);
    virtual ~CUsesCallbackEvent(void);

protected:
    virtual HRESULT AllocCallbackEvent(CCallbackEventPool *, CCallbackEvent **);
    virtual void EventSignalCallback(CCallbackEvent *) = 0;

private:
    static void CALLBACK EventSignalCallbackStatic(CCallbackEvent *, LPVOID);
};

// Shared memory object
class CSharedMemoryBlock
    : public CDsBasicRuntime
{
private:
    static const BOOL       m_fLock;                // Should the lock be used?
    CLock *                 m_plck;                 // Lock object
    HANDLE                  m_hFileMappingObject;   // File mapping object handle

public:
    CSharedMemoryBlock(void);
    virtual ~CSharedMemoryBlock(void);

public:
    // Creation
    virtual HRESULT Initialize(DWORD, QWORD, LPCTSTR);

    // Data
    virtual HRESULT Read(LPVOID *, LPDWORD);
    virtual HRESULT Write(LPVOID, DWORD);

public:
    virtual void Lock(void);
    virtual void Unlock(void);
};

inline void CSharedMemoryBlock::Lock(void)
{
    if(m_plck)
    {
        m_plck->Lock();
    }
}

inline void CSharedMemoryBlock::Unlock(void)
{
    if(m_plck)
    {
        m_plck->Unlock();
    }
}

// DLL mutex helpers
extern CLock *              g_pDllLock;

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "EnterDllMutex"

inline void EnterDllMutex(LPCTSTR file, UINT line)
{
    const DWORD             dwThreadId  = GetCurrentThreadId();

    ASSERT(g_pDllLock);

    if(!g_pDllLock->TryLock())
    {
        DWORD dwStart, dwEnd;

        dwStart = timeGetTime();

        g_pDllLock->Lock();

        dwEnd = timeGetTime();

        DPF(DPFLVL_LOCK, "Thread 0x%8.8lX waited %lu ms for the DLL lock", dwThreadId, dwEnd - dwStart);
    }

    DPF(DPFLVL_LOCK, "DLL lock taken by 0x%8.8lX from %s, line %lu", dwThreadId, file, line);
}

#undef DPF_FNAME
#define DPF_FNAME "EnterDllMutexOrEvent"

inline BOOL EnterDllMutexOrEvent(HANDLE hEvent, LPCTSTR file, UINT line)
{
    const DWORD             dwThreadId  = GetCurrentThreadId();
    BOOL                    fLock;
    
    ASSERT(g_pDllLock);
    ASSERT(IsValidHandleValue(hEvent));

    if(!(fLock = g_pDllLock->TryLock()))
    {
        DWORD dwStart, dwEnd;

        dwStart = timeGetTime();

        fLock = g_pDllLock->LockOrEvent(hEvent);

        dwEnd = timeGetTime();

        if(fLock)
        {
            DPF(DPFLVL_LOCK, "Thread 0x%8.8lX waited %lu ms for the DLL lock", dwThreadId, dwEnd - dwStart);
        }
    }

    if(fLock)
    {
        DPF(DPFLVL_LOCK, "DLL lock taken by 0x%8.8lX from %s, line %lu", dwThreadId, file, line);
    }

    return fLock;
}

#undef DPF_FNAME
#define DPF_FNAME "LeaveDllMutex"

inline void LeaveDllMutex(LPCTSTR file, UINT line)
{
    const DWORD             dwThreadId  = GetCurrentThreadId();

    ASSERT(g_pDllLock);
    g_pDllLock->Unlock();

    DPF(DPFLVL_LOCK, "DLL lock released by 0x%8.8lX from %s, line %lu", dwThreadId, file, line);
}

#define ENTER_DLL_MUTEX() \
            ::EnterDllMutex(TEXT(__FILE__), __LINE__)

#define ENTER_DLL_MUTEX_OR_EVENT(h) \
            ::EnterDllMutexOrEvent(h, TEXT(__FILE__), __LINE__)

#define LEAVE_DLL_MUTEX() \
            ::LeaveDllMutex(TEXT(__FILE__), __LINE__)

#else // DEBUG

#define ENTER_DLL_MUTEX() \
            g_pDllLock->Lock()

#define ENTER_DLL_MUTEX_OR_EVENT(h) \
            g_pDllLock->LockOrEvent(h)

#define LEAVE_DLL_MUTEX() \
            g_pDllLock->Unlock()

#endif // DEBUG

#endif // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Generic synchronization helpers
extern HANDLE GetLocalHandleCopy(HANDLE, DWORD, BOOL);
extern HANDLE GetGlobalHandleCopy(HANDLE, DWORD, BOOL);
extern BOOL MakeHandleGlobal(LPHANDLE);
extern BOOL MapHandle(LPHANDLE, LPDWORD);
extern DWORD WaitObjectArray(DWORD, DWORD, BOOL, const HANDLE *);
extern DWORD WaitObjectList(DWORD, DWORD, BOOL, ...);
extern HANDLE CreateGlobalEvent(LPCTSTR, BOOL);
extern HANDLE CreateGlobalMutex(LPCTSTR);
extern HRESULT CreateWorkerThread(LPTHREAD_START_ROUTINE, BOOL, LPVOID, LPHANDLE, LPDWORD);
extern DWORD CloseThread(HANDLE, HANDLE, DWORD);
extern HANDLE GetCurrentProcessActual(void);
extern HANDLE GetCurrentThreadActual(void);

__inline DWORD WaitObject(DWORD dwTimeout, HANDLE hObject)
{
    return WaitObjectArray(1, dwTimeout, FALSE, &hObject);
}

__inline void __CloseHandle(HANDLE h)
{
    if(IsValidHandleValue(h))
    {
        CloseHandle(h);
    }
}

#define CLOSE_HANDLE(h) \
            __CloseHandle(h), (h) = NULL

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __SYNCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\tlist.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tlist.cpp
 *  Content:    Linked-list template classes.  There's some seriously
 *              magical C++ stuff in here, so be forewarned all of you C
 *              programmers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/12/97     dereks  Created.
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  CNode
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CNode * [in]: previous node pointer.
 *      type& [in]: node data.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CNode::CNode"

template <class type> CNode<type>::CNode(CNode<type> *pPrev, const type& data)
{
    CNode<type> *           pNext   = NULL;

    DPF_ENTER();
    DPF_CONSTRUCT(CList);
    
    if(pPrev)
    {
        pNext = pPrev->m_pNext;
    }
    
    m_pPrev = pPrev;
    m_pNext = pNext;

    if(m_pPrev)
    {
        ASSERT(m_pPrev->m_pNext == m_pNext);
        m_pPrev->m_pNext = this;
    }

    if(pNext)
    {
        ASSERT(m_pNext->m_pPrev == m_pPrev);
        m_pNext->m_pPrev = this;
    }

    CopyMemory(&m_data, &data, sizeof(type));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CNode
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CNode::~CNode"

template <class type> CNode<type>::~CNode(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CNode);
    
    if(m_pPrev)
    {
        ASSERT(this == m_pPrev->m_pNext);
        m_pPrev->m_pNext = m_pNext;
    }

    if(m_pNext)
    {
        ASSERT(this == m_pNext->m_pPrev);
        m_pNext->m_pPrev = m_pPrev;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CList
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::CList"

template <class type> CList<type>::CList(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CList);
    
    m_pHead = NULL;
    m_pTail = NULL;
    m_uCount = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CList
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::~CList"

template <class type> CList<type>::~CList(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CList);
    
    RemoveAllNodesFromList();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  AddNodeToList
 *
 *  Description:
 *      Adds a node to the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: new node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::AddNodeToList"

template <class type> CNode<type> *CList<type>::AddNodeToList(const type& data)
{
    return InsertNodeIntoList(m_pTail, data);
}


/***************************************************************************
 *
 *  AddNodeToListHead
 *
 *  Description:
 *      Adds a node to the head of the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: new node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::AddNodeToListHead"

template <class type> CNode<type> *CList<type>::AddNodeToListHead(const type& data)
{
    CNode<type> *       pNode;

    AssertValid();

    pNode = NEW(CNode<type>(NULL, data));

    if(pNode)
    {
        if(m_uCount)
        {
            pNode->m_pNext = m_pHead;
            m_pHead->m_pPrev = pNode;
            m_pHead = pNode;
        }
        else
        {
            m_pHead = m_pTail = pNode;
        }

        m_uCount++;
    }

    return pNode;
}


/***************************************************************************
 *
 *  InsertNodeIntoList
 *
 *  Description:
 *      Inserts a new node into a specific point in the list.
 *
 *  Arguments:
 *      CNode * [in]: node to insert the new one after.
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: new node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::InsertNodeIntoList"

template <class type> CNode<type> *CList<type>::InsertNodeIntoList(CNode<type> *pPrev, const type& data)
{
    CNode<type> *       pNode;

    AssertValid();

    pNode = NEW(CNode<type>(pPrev, data));

    if(pNode)
    {
        if(m_uCount)
        {
            if(m_pTail == pNode->m_pPrev)
            {
                m_pTail = pNode;
            }
        }
        else
        {
            m_pHead = m_pTail = pNode;
        }

        m_uCount++;
    }

    return pNode;
}


/***************************************************************************
 *
 *  RemoveNodeFromList
 *
 *  Description:
 *      Removes a node from the list.
 *
 *  Arguments:
 *      CNode * [in]: node pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::RemoveNodeFromList"

template <class type> void CList<type>::RemoveNodeFromList(CNode<type> *pNode)
{
    AssertValid();

#ifdef DEBUG

    CNode<type> *pSearchNode;

    for(pSearchNode = m_pHead; pSearchNode; pSearchNode = pSearchNode->m_pNext)
    {
        if(pSearchNode == pNode)
        {
            break;
        }
    }

    ASSERT(pSearchNode == pNode);

#endif // DEBUG

    if(pNode == m_pHead)
    {
        m_pHead = m_pHead->m_pNext;
    }

    if(pNode == m_pTail)
    {
        m_pTail = m_pTail->m_pPrev;
    }
    
    DELETE(pNode);
    m_uCount--;
}


/***************************************************************************
 *
 *  RemoveAllNodesFromList
 *
 *  Description:
 *      Removes all nodes from the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::RemoveAllNodesFromList"

template <class type> void CList<type>::RemoveAllNodesFromList(void)
{
    while(m_pHead)
    {
        RemoveNodeFromList(m_pHead);
    }

    AssertValid();
}


/***************************************************************************
 *
 *  RemoveDataFromList
 *
 *  Description:
 *      Removes a node from the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::RemoveDataFromList"

template <class type> BOOL CList<type>::RemoveDataFromList(const type& data)
{
    CNode<type> *       pNode;

    pNode = IsDataInList(data);

    if(pNode)
    {
        RemoveNodeFromList(pNode);
    }

    return MAKEBOOL(pNode);
}


/***************************************************************************
 *
 *  IsDataInList
 *
 *  Description:
 *      Determines if a piece of data appears in the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::IsDataInList"

template <class type> CNode<type> *CList<type>::IsDataInList(const type& data)
{
    CNode<type> *       pNode;

    for(pNode = m_pHead; pNode; pNode = pNode->m_pNext)
    {
        if(CompareMemory(&data, &pNode->m_data, sizeof(type)))
        {
            break;
        }
    }

    return pNode;
}


/***************************************************************************
 *
 *  GetListHead
 *
 *  Description:
 *      Gets the first node in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      CNode *: list head pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::GetListHead"

template <class type> CNode<type> *CList<type>::GetListHead(void)
{ 
    return m_pHead;
}


/***************************************************************************
 *
 *  GetListTail
 *
 *  Description:
 *      Gets the last node in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      CNode *: list tail pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::GetListTail"

template <class type> CNode<type> *CList<type>::GetListTail(void)
{ 
    return m_pTail;
}


/***************************************************************************
 *
 *  GetNodeCount
 *
 *  Description:
 *      Gets the count of nodes in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      UINT: count of nodes in the list.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::GetNodeCount"

template <class type> UINT CList<type>::GetNodeCount(void)
{ 
    return m_uCount; 
}


/***************************************************************************
 *
 *  GetNodeByIndex
 *
 *  Description:
 *      Gets a node by it's index in the list.
 *
 *  Arguments:
 *      UINT [in]: node index.
 *
 *  Returns:  
 *      CNode *: node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::GetNodeByIndex"

template <class type> CNode<type> *CList<type>::GetNodeByIndex(UINT uIndex)
{
    CNode<type> *           pNode;

    for(pNode = m_pHead; pNode; pNode = pNode->m_pNext)
    {
        if(0 == uIndex--)
        {
            break;
        }
    }

    return pNode;
}


/***************************************************************************
 *
 *  AssertValid
 *
 *  Description:
 *      Asserts that the object is valid.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CList::AssertValid"

template <class type> void CList<type>::AssertValid(void)
{
    ASSERT((!m_pHead && !m_pTail && !m_uCount) || (m_pHead && m_pTail && m_uCount));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\tlist.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tlist.h
 *  Content:    Linked-list template classes.  There's some seriously
 *              magical C++ stuff in here, so be forewarned all of you C
 *              programmers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/12/97     dereks  Created.
 *
 ***************************************************************************/

#ifndef __TLIST_H__
#define __TLIST_H__

#ifdef __cplusplus

template <class type> class CNode
{
public:
    CNode<type> *       m_pPrev;        // Previous node in the list
    CNode<type> *       m_pNext;        // Next node in the list
    type                m_data;         // Node data

public:
    CNode(CNode<type> *, const type&);
    virtual ~CNode(void);
};

template <class type> class CList
{
private:
    CNode<type> *       m_pHead;        // Pointer to the head of the list
    CNode<type> *       m_pTail;        // Pointer to the tail of the list
    UINT                m_uCount;       // Count of nodes in the list

public:
    CList(void);
    virtual ~CList(void);

public:
    // Node creation, removal
    virtual CNode<type> *AddNodeToList(const type&);
    virtual CNode<type> *AddNodeToListHead(const type&);
    virtual CNode<type> *InsertNodeIntoList(CNode<type> *, const type&);
    virtual void RemoveNodeFromList(CNode<type> *);
    virtual void RemoveAllNodesFromList(void);
    
    // Node manipulation by data
    virtual BOOL RemoveDataFromList(const type&);
    virtual CNode<type> *IsDataInList(const type&);
    virtual CNode<type> *GetNodeByIndex(UINT);
    
    // Basic list information
    virtual CNode<type> *GetListHead(void);
    virtual CNode<type> *GetListTail(void);
    virtual UINT GetNodeCount(void);

protected:
    virtual void AssertValid(void);
};

#endif // __cplusplus

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\threed.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       threed.h
 *  Content:    3D helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *     ?        dannymi Created.
 *
 ***************************************************************************/

#ifndef __THREED_H__
#define __THREED_H__

#define MAX_ROLLOFFFACTOR	10.0f
#define MAX_DOPPLERFACTOR	10.0f
#define DEFAULT_MINDISTANCE	1.0f
// !!! this is not actually infinite
#define DEFAULT_MAXDISTANCE	1000000000.0f
#define DEFAULT_CONEANGLE	360
#define DEFAULT_CONEOUTSIDEVOLUME 0

// how does overall volume change based on position?
#define GAIN_FRONT	.9f
#define GAIN_REAR	.6f
#define GAIN_IPSI	1.f
#define GAIN_CONTRA	.2f
#define GAIN_UP		.8f
#define GAIN_DOWN	.5f

// how does dry/wet mix change based on position?
#define SHADOW_FRONT	1.f
#define SHADOW_REAR	.5f
#define SHADOW_IPSI	1.f
#define SHADOW_CONTRA	.2f
#define SHADOW_UP	.8f
#define SHADOW_DOWN	.2f

// !!! Make this user-definable?
#define SHADOW_CONE	.5f	// max wet/dry mix when outside cone

typedef struct tagHRP
{
    D3DVALUE            rho;
    D3DVALUE            theta;
    D3DVALUE            phi;
} HRP, *LPHRP;

typedef struct tagSPHERICALHRP
{
    D3DVALUE            pitch;
    D3DVALUE            yaw;
    D3DVALUE            roll;
} SPHERICALHRP, *LPSPHERICALHRP;

typedef const D3DVECTOR& REFD3DVECTOR;

#endif // __THREED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\unicode.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       unicode.h
 *  Content:    Windows Unicode API wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/7/98      dereks  Created.
 *
 ***************************************************************************/

#ifndef __UNICODE_H__
#define __UNICODE_H__

#ifndef WIN95
#error unicode.h included w/o WIN95 defined
#endif // WIN95

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// MMSYSTEM.H
#define waveOutGetDevCapsW _waveOutGetDevCapsW
extern MMRESULT WINAPI _waveOutGetDevCapsW(UINT, LPWAVEOUTCAPSW, UINT);

#define mmioOpenW _mmioOpenW
extern HMMIO WINAPI _mmioOpenW(LPWSTR, LPMMIOINFO, DWORD);

// WINBASE.H
#define lstrcatA strcat
#define lstrcatW wcscat

#define lstrcpyA strcpy
#define lstrcpyW wcscpy

#define lstrcpynA strncpy
#define lstrcpynW wcsncpy

#define lstrlenA strlen
#define lstrlenW wcslen

#define lstrcmpA strcmp
#define lstrcmpW _wcscmp

#define lstrcmpiA _stricmp
#define lstrcmpiW _wcsicmp

#define CreateFileW _CreateFileW
extern HANDLE WINAPI _CreateFileW(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);

#define GetWindowsDirectoryW _GetWindowsDirectoryW
extern UINT WINAPI _GetWindowsDirectoryW(LPWSTR, UINT);

#define FindResourceW _FindResourceW
extern HRSRC WINAPI _FindResourceW(HINSTANCE, LPCWSTR, LPCWSTR);

// WINREG.H
#define RegQueryValueExW _RegQueryValueExW
extern LONG APIENTRY _RegQueryValueExW(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __UNICODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\unicode.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       unicode.c
 *  Content:    Windows unicode API wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/7/98      dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"

#ifndef WIN95
#error unicode.c being built w/o WIN95 defined
#endif // WIN95


/***************************************************************************
 *
 *  _waveOutGetDevCapsW
 *
 *  Description:
 *      Wrapper for waveOutGetDevCapsW.
 *
 *  Arguments:
 *      UINT [in]: waveOut device id.
 *      LPWAVEOUTCAPSW [out]: receives device caps.
 *      UINT [in]: size of above structure.
 *
 *  Returns:  
 *      MMRESULT: MMSYSTEM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "_waveOutGetDevCapsW"

MMRESULT WINAPI _waveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc)
{
    WAVEOUTCAPSA            woca;
    MMRESULT                mmr;

    DPF_ENTER();

    ASSERT(cbwoc >= sizeof(*pwoc));
    
    // Call the ANSI version
    mmr = waveOutGetDevCapsA(uDeviceID, &woca, sizeof(woca));

    // Convert to Unicode
    if(MMSYSERR_NOERROR == mmr)
    {
        pwoc->wMid = woca.wMid;
        pwoc->wPid = woca.wPid;
        pwoc->vDriverVersion = woca.vDriverVersion;
        pwoc->dwFormats = woca.dwFormats;
        pwoc->wChannels = woca.wChannels;
        pwoc->wReserved1 = woca.wReserved1;
        pwoc->dwSupport = woca.dwSupport;

        AnsiToUnicode(woca.szPname, pwoc->szPname, NUMELMS(pwoc->szPname));
    }

    DPF_LEAVE(mmr);

    return mmr;
}


/***************************************************************************
 *
 *  _CreateFileW
 *
 *  Description:
 *      Wrapper for CreateFileW.
 *
 *  Arguments:
 *      LPCWSTR [in]: file or device name.
 *      DWORD [in]: desired access.
 *      DWORD [in]: share mode.
 *      LPSECURITY_ATTRIBUTES [in]: security attributes.
 *      DWORD [in]: Creation distribution.
 *      DWORD [in]: Flags and attributes.
 *      HANDLE [in]: Template file
 *
 *  Returns:  
 *      HANDLE: file or device handle, or NULL on error.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "_CreateFileW"

HANDLE WINAPI _CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
    LPSTR                   lpFileNameA;
    HANDLE                  hFile;

    DPF_ENTER();

    // Get the ANSI version of the filename
    lpFileNameA = UnicodeToAnsiAlloc(lpFileName);

    // Call the ANSI version
    if(lpFileNameA)
    {
        hFile = CreateFileA(lpFileNameA, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile);
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        hFile = NULL;
    }

    // Clean up
    MEMFREE(lpFileNameA);

    DPF_LEAVE(hFile);

    return hFile;
}


/***************************************************************************
 *
 *  _RegQueryValueExW
 *
 *  Description:
 *      Wrapper for RegQueryValueExW.
 *
 *  Arguments:
 *      HKEY [in]: parent key.
 *      LPCWSTR [in]: subkey name.
 *      LPDWORD [in]: reserved, must be NULL.
 *      LPDWORD [out]: receives value type.
 *      LPBYTE [out]: receives value data.
 *      LPDWORD [in/out]: size of above buffer.
 *
 *  Returns:  
 *      LONG: WIN32 error code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "_RegQueryValueExW"

LONG APIENTRY _RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    LONG                    lr              = ERROR_SUCCESS;
    LPBYTE                  lpDataA         = NULL;
    LPSTR                   lpValueNameA;
    DWORD                   dwRegType;
    DWORD                   cbDataA;
    LPDWORD                 lpcbDataA;

    DPF_ENTER();

    if(lpData)
    {
        ASSERT(lpcbData);
    }
    
    // Get the ANSI version of the value name
    lpValueNameA = UnicodeToAnsiAlloc(lpValueName);
    
    if(!lpValueNameA)
    {
        lr = ERROR_OUTOFMEMORY;
    }

    // Get the value type
    if(ERROR_SUCCESS == lr)
    {
        lr = RegQueryValueExA(hKey, lpValueNameA, NULL, &dwRegType, NULL, NULL);
    }

    // If the value type is REG_SZ or REG_EXPAND_SZ, we'll call the ANSI version
    // of RegQueryValueEx and convert the returned string to Unicode.  We can't
    // currently handle REG_MULTI_SZ.
    if(ERROR_SUCCESS == lr)
    {
        ASSERT(REG_MULTI_SZ != dwRegType);
            
        if(REG_SZ == dwRegType || REG_EXPAND_SZ == dwRegType)
        {
            if(lpcbData)
            {
                cbDataA = *lpcbData / sizeof(WCHAR);
            }
            else
            {
                cbDataA = 0;
            }

            if(lpData && cbDataA)
            {
                lpDataA = MEMALLOC_A(BYTE, cbDataA);
        
                if(!lpDataA)
                {
                    lr = ERROR_OUTOFMEMORY;
                }
            }
            else
            {
                lpDataA = NULL;
            }

            lpcbDataA = &cbDataA;
        }
        else
        {
            lpDataA = lpData;
            lpcbDataA = lpcbData;
        }
    }

    if(ERROR_SUCCESS == lr)
    {
        lr = RegQueryValueExA(hKey, lpValueNameA, lpReserved, lpType, lpDataA, lpcbDataA);
    }

    if(ERROR_SUCCESS == lr)
    {
        if(REG_SZ == dwRegType || REG_EXPAND_SZ == dwRegType)
        {
            if(lpData)
            {
                AnsiToUnicode(lpDataA, (LPWSTR)lpData, *lpcbData / sizeof(WCHAR));
            }

            if(lpcbData)
            {
                *lpcbData = cbDataA * sizeof(WCHAR);
            }
        }
    }

    if(lpDataA != lpData)
    {
        MEMFREE(lpDataA);
    }

    MEMFREE(lpValueNameA);

    DPF_LEAVE(lr);

    return lr;
}


/***************************************************************************
 *
 *  _GetWindowsDirectoryW
 *
 *  Description:
 *      Wrapper for GetWindowsDirectoryW.
 *
 *  Arguments:
 *      LPWSTR [out]: receives windows directory path.
 *      UINT [in]: size of above buffer, in characters.
 *
 *  Returns:  
 *      UINT: number of bytes copies, or 0 on error.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "_GetWindowsDirectoryW"

UINT WINAPI _GetWindowsDirectoryW(LPWSTR pszPath, UINT ccPath)
{
    CHAR                    szPathA[MAX_PATH];
    UINT                    ccCopied;

    DPF_ENTER();

    ccCopied = GetWindowsDirectoryA(szPathA, MAX_PATH);

    if(ccCopied)
    {
        AnsiToUnicode(szPathA, pszPath, ccPath);
    }

    DPF_LEAVE(ccCopied);

    return ccCopied;
}


/***************************************************************************
 *
 *  _FindResourceW
 *
 *  Description:
 *      Wrapper for FindResourceW.
 *
 *  Arguments:
 *      HINSTANCE [in]: resource instance handle.
 *      LPCWSTR [in]: resource identifier.
 *      LPCWSTR [in]: resource type.
 *
 *  Returns:  
 *      HRSRC: resource handle.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "_FindResourceW"

HRSRC WINAPI _FindResourceW(HINSTANCE hInst, LPCWSTR pszResource, LPCWSTR pszType)
{
    LPSTR                   pszResourceA    = NULL;
    LPSTR                   pszTypeA        = NULL;
    HRSRC                   hrsrc           = NULL;
    DWORD                   dwError         = ERROR_SUCCESS;

    DPF_ENTER();
    
    if(HIWORD(pszResource))
    {
        pszResourceA = UnicodeToAnsiAlloc(pszResource);

        if(!pszResourceA)
        {
            SetLastError(dwError = ERROR_OUTOFMEMORY);
        }
    }
    else
    {
        pszResourceA = (LPSTR)pszResource;
    }

    if(ERROR_SUCCESS == dwError)
    {
        if(HIWORD(pszType))
        {
            pszTypeA = UnicodeToAnsiAlloc(pszType);

            if(!pszTypeA)
            {
                SetLastError(dwError = ERROR_OUTOFMEMORY);
            }
        }
        else
        {
            pszTypeA = (LPSTR)pszType;
        }
    }

    if(ERROR_SUCCESS == dwError)
    {
        hrsrc = FindResourceA(hInst, pszResourceA, pszTypeA);
    }

    if(pszResourceA != (LPSTR)pszResource)
    {
        MEMFREE(pszResourceA);
    }

    if(pszTypeA != (LPSTR)pszType)
    {
        MEMFREE(pszTypeA);
    }

    DPF_LEAVE(hrsrc);

    return hrsrc;
}


/***************************************************************************
 *
 *  _mmioOpenW
 *
 *  Description:
 *      Wrapper for mmioOpen.  Note that only the file name parameter is
 *      converted.
 *
 *  Arguments:
 *      LPSTR [in]: file name.
 *      LPMMIOINFO [in]: MMIO info.
 *      DWORD [in]: open flags.
 *
 *  Returns:  
 *      HMMIO: MMIO file handle.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "_mmioOpenW"

HMMIO WINAPI _mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen)
{
    LPSTR                   pszFileNameA;
    HMMIO                   hmmio;

    DPF_ENTER();

    // Get the ANSI version of the filename
    pszFileNameA = UnicodeToAnsiAlloc(pszFileName);

    // Call the ANSI version
    if(pszFileNameA)
    {
        hmmio = mmioOpenA(pszFileNameA, pmmioinfo, fdwOpen);
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        hmmio = NULL;
    }

    // Clean up
    MEMFREE(pszFileNameA);

    DPF_LEAVE(hmmio);

    return hmmio;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vad.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vad.cpp
 *  Content:    Virtual audio device.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/13/97     dereks  Created
 *  4/20/99     duganp  Added registry-settable default S/W 3D algorithms
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <tchar.h>  // For _TUCHAR and  _tcsicmp()

// To get specific logging of the mixer API stuff, uncomment this line:
// #define DPF_MIXER DPF
#pragma warning(disable:4002)
#define DPF_MIXER()

#ifdef WINNT

// Defined in ists.cpp and used to check for Terminal Services on NT:
extern BOOL IsRedirectedTSAudio(void);

// Defined in onwow64.cpp and used to check whether we're running on WOW64:
#ifdef WIN64
#define OnWow64() FALSE
#else
extern BOOL OnWow64(void);
#endif

#endif // WINNT

// Device enumeration order
static const VADDEVICETYPE g_avdtDeviceTypes[] =
{
    VAD_DEVICETYPE_KSRENDER,
#ifndef NOVXD
    VAD_DEVICETYPE_VXDRENDER,
#endif
    VAD_DEVICETYPE_EMULATEDRENDER,
#ifndef NOKS
    VAD_DEVICETYPE_KSCAPTURE,
    VAD_DEVICETYPE_EMULATEDCAPTURE,
#endif
};

// Table of valid 3D algorithms used in CRenderDevice::Initialize below
static struct Soft3dAlgorithm
{
    LPCTSTR pszName;
    LPCGUID pGuid;
} g_3dAlgList[] =
{
    {TEXT("No virtualization"), &DS3DALG_NO_VIRTUALIZATION},
    {TEXT("ITD"), &DS3DALG_ITD},
    {TEXT("Light HRTF"), &DS3DALG_HRTF_LIGHT},
    {TEXT("Full HRTF"), &DS3DALG_HRTF_FULL}
};


/***************************************************************************
 *
 *  CVirtualAudioDeviceManager
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::CVirtualAudioDeviceManager"

CVirtualAudioDeviceManager::CVirtualAudioDeviceManager(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CVirtualAudioDeviceManager);

    m_vdtDrivers = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CVirtualAudioDeviceManager
 *
 *  Description:
 *      Object denstructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::~CVirtualAudioDeviceManager"

CVirtualAudioDeviceManager::~CVirtualAudioDeviceManager(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CVirtualAudioDeviceManager);

    FreeStaticDriverList();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumDevices
 *
 *  Description:
 *      Creates one of each type of audio device.  Note that the objects
 *      are only created; the device is not initialized yet.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type(s).
 *      CList * [in/out]: list object.  A pointer to each device will be
 *                        added as a node in this list.  Remember to delete
 *                        each device before freeing the list.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::EnumDevices"

HRESULT CVirtualAudioDeviceManager::EnumDevices
(
    VADDEVICETYPE           vdtDeviceType,
    CObjectList<CDevice> *  plst
)
{
    HRESULT                     hr      = DS_OK;
    CDevice *                   pDevice = NULL;
    UINT                        i;

    DPF_ENTER();

    for(i = 0; i < NUMELMS(g_avdtDeviceTypes); i++)
    {
        if(vdtDeviceType & g_avdtDeviceTypes[i])
        {
            switch(g_avdtDeviceTypes[i])
            {
                case VAD_DEVICETYPE_EMULATEDRENDER:
                    pDevice = NEW(CEmRenderDevice);
                    break;

                case VAD_DEVICETYPE_EMULATEDCAPTURE:
                    pDevice = NEW(CEmCaptureDevice);
                    break;

#ifndef NOVXD
                case VAD_DEVICETYPE_VXDRENDER:
                    pDevice = NEW(CVxdRenderDevice);
                    break;
#endif // NOVXD

#ifndef NOKS
                case VAD_DEVICETYPE_KSRENDER:
                    pDevice = NEW(CKsRenderDevice);
                    break;

                case VAD_DEVICETYPE_KSCAPTURE:
                    pDevice = NEW(CKsCaptureDevice);
                    break;
#endif // NOKS
            }

            hr = HRFROMP(pDevice);
            if (SUCCEEDED(hr))
            {
                hr = HRFROMP(plst->AddNodeToList(pDevice));
                RELEASE(pDevice);
            }
            if (FAILED(hr))
            {
                break;
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnumDrivers
 *
 *  Description:
 *      Enumerates all drivers for a specific device type.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type(s).
 *      DWORD [in]: flags.
 *      CList * [in/out]: list object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::EnumDrivers"

HRESULT CVirtualAudioDeviceManager::EnumDrivers
(
    VADDEVICETYPE                       vdtDeviceType,
    DWORD                               dwFlags,
    CObjectList<CDeviceDescription> *   plst
)
{
    CNode<CStaticDriver *> *            pNode;
    HRESULT                             hr;

    DPF_ENTER();

    ASSERT(!plst->GetNodeCount());

    // Initialize the static driver list
    hr = InitStaticDriverList(vdtDeviceType);

    // Find all drivers in the list that match this device type
    if(SUCCEEDED(hr))
    {
        for(pNode = m_lstDrivers.GetListHead(); pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
        {
            if(vdtDeviceType & pNode->m_data->m_pDeviceDescription->m_vdtDeviceType)
            {
                hr = HRFROMP(plst->AddNodeToList(pNode->m_data->m_pDeviceDescription));
            }
        }
    }

    // Handle flags
    if(SUCCEEDED(hr) && (dwFlags & VAD_ENUMDRIVERS_ORDER))
    {
        SortDriverList(vdtDeviceType, plst);
    }

    if(SUCCEEDED(hr) && (dwFlags & VAD_ENUMDRIVERS_REMOVEPROHIBITEDDRIVERS))
    {
        RemoveProhibitedDrivers(vdtDeviceType, plst);
    }

    if(SUCCEEDED(hr) && (dwFlags & VAD_ENUMDRIVERS_REMOVEDUPLICATEWAVEDEVICES))
    {
        RemoveDuplicateWaveDevices(plst);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDeviceDescription
 *
 *  Description:
 *      Retrieves the driver description based on a device guid.
 *
 *  Arguments:
 *      GUID [in]: device GUID.
 *      CDeviceDescription * [out]: receives device description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::GetDeviceDescription"

HRESULT CVirtualAudioDeviceManager::GetDeviceDescription
(
    GUID                            guid,
    CDeviceDescription **           ppDesc
)
{
    HRESULT hr = DS_OK;
    CObjectList<CDeviceDescription> lstDrivers;
    CNode<CDeviceDescription*>* pNode;
    VADDEVICETYPE vdtDeviceType;

    DPF_ENTER();

    // If the given GUID is one of the special default device IDs,
    // map it to the corresponding "real" DirectSound device ID.
    GetDeviceIdFromDefaultId(&guid, &guid);

    // What type of device does this guid represent?
    vdtDeviceType = GetDriverDeviceType(guid);

    if(!vdtDeviceType)
    {
        hr = DSERR_NODRIVER;
    }

    // Build the driver list
    if(SUCCEEDED(hr))
    {
        hr = EnumDrivers(vdtDeviceType, 0, &lstDrivers);
    }

    // Find the driver in the list
    if(SUCCEEDED(hr))
    {
        for(pNode = lstDrivers.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(guid == pNode->m_data->m_guidDeviceId)
            {
                break;
            }
        }

        if(!pNode)
        {
            hr = DSERR_NODRIVER;
        }
    }

    // Success
    if(SUCCEEDED(hr) && ppDesc)
    {
        *ppDesc = ADDREF(pNode->m_data);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindOpenDevice
 *
 *  Description:
 *      Finds an open device based on a driver GUID.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *      LPGUID [in]: driver GUID.
 *      CDevice ** [out]: receives device pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::FindOpenDevice"

HRESULT CVirtualAudioDeviceManager::FindOpenDevice
(
    VADDEVICETYPE           vdtDeviceType,
    REFGUID                 guid,
    CDevice **              ppDevice
)
{
    const BOOL              fPreferred  = IS_NULL_GUID(&guid);
    HRESULT                 hr          = DS_OK;
    GUID                    guidLocal;
    CNode<CDevice *> *      pNode;

    DPF_ENTER();

    BuildValidGuid(&guid, &guidLocal);

    for(pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        if(vdtDeviceType & pNode->m_data->m_vdtDeviceType)
        {
            if(fPreferred)
            {
                hr = GetPreferredDeviceId(pNode->m_data->m_vdtDeviceType, &guidLocal);
            }

            // For as-yet-unfigured-out reasons, we occassionally find ourselves
            // with a NULL m_pDeviceDescription here.  Protect against that case.
            ASSERT(pNode->m_data->m_pDeviceDescription && "Millennium bug 120336 / Mars bug 3692");
            if(FAILED(hr) || (pNode->m_data->m_pDeviceDescription && pNode->m_data->m_pDeviceDescription->m_guidDeviceId == guidLocal))
            {
                break;
            }
        }
    }

    if(SUCCEEDED(hr) && !pNode)
    {
        hr = DSERR_NODRIVER;
    }

    if(SUCCEEDED(hr) && ppDevice)
    {
        *ppDevice = ADDREF(pNode->m_data);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenDevice
 *
 *  Description:
 *      Opens a device based on a driver GUID.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *      LPGUID [in]: driver GUID.
 *      CDevice ** [out]: receives device pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::OpenDevice"

HRESULT CVirtualAudioDeviceManager::OpenDevice
(
    VADDEVICETYPE                   vdtDeviceType,
    REFGUID                         guid,
    CDevice **                      ppDevice
)
{
    const BOOL                      fPreferred      = IS_NULL_GUID(&guid);
    DWORD                           dwFlags         = VAD_ENUMDRIVERS_ORDER;
    UINT                            uPreferredId    = WAVE_DEVICEID_NONE;
    DWORD                           dwMapperFlags   = 0;
    HRESULT                         hr              = DS_OK;
    CObjectList<CDeviceDescription> lstDrivers;
    CNode<CDeviceDescription *> *   pStart;
    CNode<CDeviceDescription *> *   pNode;

    DPF_ENTER();

    // Enumerate all drivers in the system.  If we're trying to open the
    // preferred device, remove all prohibited drivers from the list.
    // If the user asked for a specific GUID, we'll assume that they know
    // what they're doing.
    if(fPreferred)
    {
        dwFlags |= VAD_ENUMDRIVERS_REMOVEPROHIBITEDDRIVERS;
        hr = GetPreferredWaveDevice(IS_CAPTURE_VAD(vdtDeviceType), &uPreferredId, &dwMapperFlags);
    }

    if(SUCCEEDED(hr))
    {
        hr = EnumDrivers(vdtDeviceType, dwFlags, &lstDrivers);
    }

    // If we're looking for a specific device, set the device node pointer
    // to start there.  Otherwise, we can just start at the head of the list.
    if(SUCCEEDED(hr))
    {
        pStart = lstDrivers.GetListHead();

        if(!fPreferred)
            while(pStart)
            {
                if(guid == pStart->m_data->m_guidDeviceId)
                    break;
                pStart = pStart->m_pNext;
            }

        if(!pStart)
            hr = DSERR_NODRIVER;
    }

    // Start trying to open drivers.  Because the driver list is ordered
    // properly, we can just try to open each driver in the order it appears.
    if(SUCCEEDED(hr))
    {
        pNode = pStart;

        while(TRUE)
        {
            // Try to open the driver
            hr = OpenSpecificDevice(pNode->m_data, ppDevice);

            if(SUCCEEDED(hr))
                break;

            // If the app asked for a specific device, don't try any others
            if (!fPreferred)
                break;

            // Next driver, please.  If we hit the end of the list, just
            // wrap around.
            if(!(pNode = pNode->m_pNext))
                pNode = lstDrivers.GetListHead();

            if(pNode == pStart)
                break;

            // If we failed to open the driver, and the caller asked for the
            // preferred device, *and* the mapper says to use the preferred
            // device only, we're done.
            if(fPreferred && (dwMapperFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY)
                          && (pNode->m_data->m_uWaveDeviceId != uPreferredId))
                break;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenSpecificDevice
 *
 *  Description:
 *      Opens a device based on a driver GUID.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *      CDevice ** [out]: receives device pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::OpenSpecificDevice"

HRESULT CVirtualAudioDeviceManager::OpenSpecificDevice
(
    CDeviceDescription *    pDesc,
    CDevice **              ppDevice
)
{
    CObjectList<CDevice>    lstDevices;
    CNode<CDevice *> *      pNode;
    CDevice *               pDevice;
    HRESULT                 hr;

    DPF_ENTER();

    DPF(DPFLVL_INFO, "Attempting to open %s", (LPCTSTR)pDesc->m_strName);

    // Create a list of all devices corresponding to this type
    hr = EnumDevices(pDesc->m_vdtDeviceType, &lstDevices);

    // We should only get back one device per type
    if(SUCCEEDED(hr))
    {
        ASSERT(1 == lstDevices.GetNodeCount());

        pNode = lstDevices.GetListHead();
        pDevice = pNode->m_data;
    }

    // Interrupt any system events that might prevent us from opening
    // the device
    if(SUCCEEDED(hr) && (pDesc->m_vdtDeviceType & VAD_DEVICETYPE_WAVEOUTOPENMASK))
    {
        InterruptSystemEvent(pDesc->m_uWaveDeviceId);
    }

    // Attempt to open the device
    if(SUCCEEDED(hr))
    {
        hr = pDevice->Initialize(pDesc);
    }

    // Clean up
    if(SUCCEEDED(hr))
    {
        *ppDevice = ADDREF(pDevice);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDriverGuid
 *
 *  Description:
 *      Builds a driver GUID.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *      BYTE [in]: data.
 *      LPGUID [out]: receives GUID.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::GetDriverGuid"

void CVirtualAudioDeviceManager::GetDriverGuid
(
    VADDEVICETYPE           vdtDeviceType,
    BYTE                    bData,
    LPGUID                  pGuid
)
{
    DPF_ENTER();

    switch(vdtDeviceType)
    {
        case VAD_DEVICETYPE_EMULATEDRENDER:
            *pGuid = VADDRVID_EmulatedRenderBase;
            break;

        case VAD_DEVICETYPE_EMULATEDCAPTURE:
            *pGuid = VADDRVID_EmulatedCaptureBase;
            break;

        case VAD_DEVICETYPE_VXDRENDER:
            *pGuid = VADDRVID_VxdRenderBase;
            break;

        case VAD_DEVICETYPE_KSRENDER:
            *pGuid = VADDRVID_KsRenderBase;
            break;

        case VAD_DEVICETYPE_KSCAPTURE:
            *pGuid = VADDRVID_KsCaptureBase;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    switch(vdtDeviceType)
    {
        case VAD_DEVICETYPE_EMULATEDRENDER:
        case VAD_DEVICETYPE_EMULATEDCAPTURE:
        case VAD_DEVICETYPE_KSRENDER:
        case VAD_DEVICETYPE_KSCAPTURE:
            pGuid->Data4[7] = bData;
            break;

        case VAD_DEVICETYPE_VXDRENDER:
            pGuid->Data1 |= bData & 0x0F;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetDriverDataFromGuid
 *
 *  Description:
 *      Gets device-specific data from a driver GUID.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *      REFGUID [in]: driver GUID.
 *      LPBYTE [out]: receives data.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::GetDriverDataFromGuid"

void CVirtualAudioDeviceManager::GetDriverDataFromGuid
(
    VADDEVICETYPE           vdtDeviceType,
    REFGUID                 guid,
    LPBYTE                  pbData
)
{
    DPF_ENTER();

    switch(vdtDeviceType)
    {
        case VAD_DEVICETYPE_EMULATEDRENDER:
        case VAD_DEVICETYPE_EMULATEDCAPTURE:
        case VAD_DEVICETYPE_KSRENDER:
        case VAD_DEVICETYPE_KSCAPTURE:
            *pbData = guid.Data4[7];
            break;

        case VAD_DEVICETYPE_VXDRENDER:
            *pbData = (BYTE)(guid.Data1 & 0x0000000F);
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetDriverDeviceType
 *
 *  Description:
 *      Gets the VAD device type for a given driver GUID.
 *
 *  Arguments:
 *      REFGUID [in]: device guid.
 *
 *  Returns:
 *      VADDEVICETYPE: device type, or 0 on error.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::GetDriverDeviceType"

VADDEVICETYPE CVirtualAudioDeviceManager::GetDriverDeviceType
(
    REFGUID                 guid
)
{
    VADDEVICETYPE           vdtDeviceType         = 0;
    GUID                    guidComp;
    BYTE                    bData;
    UINT                    i;

    DPF_ENTER();

    for(i = 0; i < NUMELMS(g_avdtDeviceTypes) && !vdtDeviceType; i++)
    {
        GetDriverDataFromGuid(g_avdtDeviceTypes[i], guid, &bData);
        GetDriverGuid(g_avdtDeviceTypes[i], bData, &guidComp);

        if(guid == guidComp)
        {
            vdtDeviceType = g_avdtDeviceTypes[i];
        }
    }

    DPF_LEAVE(vdtDeviceType);
    return vdtDeviceType;
}


/***************************************************************************
 *
 *  GetPreferredDeviceId
 *
 *  Description:
 *      Gets the device-specific driver GUID for the preferred device.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *      LPGUID [out]: receives driver GUID.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::GetPreferredDeviceId"

HRESULT CVirtualAudioDeviceManager::GetPreferredDeviceId
(
    VADDEVICETYPE                       vdtDeviceType,
    LPGUID                              pGuid,
    DEFAULT_DEVICE_TYPE                 defaultType
)
{
    CObjectList<CDeviceDescription>     lstDrivers;
    CNode<CDeviceDescription *> *       pNode;
    UINT                                uDeviceId;
    HRESULT                             hr;

    DPF_ENTER();

    // Enumerate all drivers for this device
    hr = EnumDrivers(vdtDeviceType, VAD_ENUMDRIVERS_REMOVEPROHIBITEDDRIVERS, &lstDrivers);

    // Get the preferred waveOut or waveIn device id
    if(SUCCEEDED(hr))
    {
        hr = GetPreferredWaveDevice(IS_CAPTURE_VAD(vdtDeviceType), &uDeviceId, NULL, defaultType);
    }

    // Look for the corresponding driver
    if(SUCCEEDED(hr))
    {
        for(pNode = lstDrivers.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(uDeviceId == pNode->m_data->m_uWaveDeviceId)
            {
                break;
            }
        }

        if(!pNode)
        {
            DPF(DPFLVL_ERROR, "Can't find driver GUID matching preferred device id");
            hr = DSERR_NODRIVER;
        }
    }

    if(SUCCEEDED(hr))
    {
        *pGuid = pNode->m_data->m_guidDeviceId;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDeviceIdFromDefaultId
 *
 *  Description:
 *      If the given GUID is one of the special default device IDs,
 *      maps it to the corresponding "real" DirectSound device ID.
 *
 *  Arguments:
 *      LPCGUID [in]: a default device ID (as defined in dsound.h).
 *      LPGUID [out]: receives the corresponding device ID.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::GetDeviceIdFromDefaultId"

HRESULT CVirtualAudioDeviceManager::GetDeviceIdFromDefaultId
(
    LPCGUID                             pGuidSrc,
    LPGUID                              pGuidDest
)
{
    HRESULT                             hr = DSERR_NODRIVER;
    DPF_ENTER();

    if (CompareMemoryOffset(pGuidSrc, &DSDEVID_DefaultPlayback, sizeof *pGuidSrc, sizeof pGuidSrc->Data1))
    {
        // This is a default device ID; find out which one
        switch (pGuidSrc->Data1)
        {
            case 0xdef00000: // DSDEVID_DefaultPlayback
                hr = GetPreferredDeviceId(VAD_DEVICETYPE_RENDERMASK, pGuidDest, MAIN_DEFAULT);
                break;

            case 0xdef00001: // DSDEVID_DefaultCapture
                hr = GetPreferredDeviceId(VAD_DEVICETYPE_CAPTUREMASK, pGuidDest, MAIN_DEFAULT);
                break;

            case 0xdef00002: // DSDEVID_DefaultVoicePlayback
                hr = GetPreferredDeviceId(VAD_DEVICETYPE_RENDERMASK, pGuidDest, VOICE_DEFAULT);
                break;

            case 0xdef00003: // DSDEVID_DefaultVoiceCapture
                hr = GetPreferredDeviceId(VAD_DEVICETYPE_CAPTUREMASK, pGuidDest, VOICE_DEFAULT);
                break;

            default:
                DPF(DPFLVL_WARNING, "Unknown default device GUID");
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetAllowableDevices
 *
 *  Description:
 *      Fills a VADDEVICETYPE buffer with all allowable device types.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *      LPTSTR [in]: device interface.
 *
 *  Returns:
 *      VADDEVICETYPE: allowable devices.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::GetAllowableDevices"

VADDEVICETYPE CVirtualAudioDeviceManager::GetAllowableDevices
(
    VADDEVICETYPE           vdtDeviceType,
#ifdef WINNT
    LPCTSTR                 pszInterface
#else // WINNT
    DWORD                   dwDevnode
#endif // WINNT
)
{
    typedef struct
    {
        LPCTSTR             pszRegKey;
        VADDEVICETYPE       vdtDeviceType;
        LPCTSTR             pszDeviceType;
    } REGDEVGOO;

    const REGDEVGOO         rdg[] =
    {
        { REGSTR_WDM, VAD_DEVICETYPE_KSRENDER, TEXT("VAD_DEVICETYPE_KSRENDER") },
        { REGSTR_VXD, VAD_DEVICETYPE_VXDRENDER, TEXT("VAD_DEVICETYPE_VXDRENDER") },
        { REGSTR_EMULATED, VAD_DEVICETYPE_EMULATEDRENDER, TEXT("VAD_DEVICETYPE_EMULATEDRENDER") },
        { REGSTR_WDM, VAD_DEVICETYPE_KSCAPTURE, TEXT("VAD_DEVICETYPE_KSCAPTURE") },
        { REGSTR_EMULATED, VAD_DEVICETYPE_EMULATEDCAPTURE, TEXT("VAD_DEVICETYPE_EMULATEDCAPTURE") },
    };

    HKEY                    hkeyParent;
    HKEY                    hkey;
    BOOL                    fPresent;
    UINT                    i;
    HRESULT                 hr;

    DPF_ENTER();

    // If the caller is looking for specifically disabled devices,
    // remove globally disabled devices first.

#ifdef WINNT
    if(pszInterface)
#else // WINNT
    if(dwDevnode)
#endif // WINNT

    {
        vdtDeviceType = GetAllowableDevices(vdtDeviceType, NULL);
    }

#ifdef WINNT
    // If running in a Terminal Server session or in WOW64, force emulation:
    if(IsRedirectedTSAudio() || OnWow64())
    {
        vdtDeviceType &= VAD_DEVICETYPE_EMULATEDMASK;
    }
#endif // WINNT

    for(i = 0; i < NUMELMS(rdg) && vdtDeviceType; i++)
    {
        if(!(vdtDeviceType & rdg[i].vdtDeviceType))
        {
            continue;
        }

        fPresent = TRUE;

#ifdef WINNT
        hr = OpenPersistentDataKey(vdtDeviceType, pszInterface, &hkeyParent);
#else // WINNT
        hr = OpenPersistentDataKey(vdtDeviceType, dwDevnode, &hkeyParent);
#endif // WINNT

        if(SUCCEEDED(hr))
        {
            hr = RhRegOpenKey(hkeyParent, REGSTR_DEVICEPRESENCE, 0, &hkey);

            if(SUCCEEDED(hr))
            {
                RhRegGetBinaryValue(hkey, rdg[i].pszRegKey, &fPresent, sizeof fPresent);
                RhRegCloseKey(&hkey);
            }

            RhRegCloseKey(&hkeyParent);
        }

        if(!fPresent)
        {
#ifdef WINNT
            DPF(DPFLVL_INFO, "%s disabled for %s", rdg[i].pszDeviceType, pszInterface);
#else // WINNT
            DPF(DPFLVL_INFO, "%s disabled for 0x%8.8lX", rdg[i].pszDeviceType, dwDevnode);
#endif // WINNT
            vdtDeviceType &= ~rdg[i].vdtDeviceType;
        }
    }

    DPF_LEAVE(vdtDeviceType);

    return vdtDeviceType;
}


/***************************************************************************
 *
 *  GetPreferredWaveDevice
 *
 *  Description:
 *      Gets the preferred wave device.
 *
 *  Arguments:
 *      BOOL [in]: TRUE if capture.
 *      LPUINT [out]: receives preferred device id.
 *      LPDWORD [out]: receives flags.
 *      DEFAULT_DEVICE_TYPE [in]: specifies whether we want the main
 *                                default device or the voice device
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetPreferredWaveDevice"

HRESULT CVirtualAudioDeviceManager::GetPreferredWaveDevice
(
    BOOL fCapture,
    LPUINT puDeviceId,
    LPDWORD pdwFlags,
    DEFAULT_DEVICE_TYPE defaultType
)
{
    UINT                    uDeviceId;
    DWORD                   dwFlags;
    HRESULT                 hr = DSERR_GENERIC;
    BOOL                    fPreferredOnly;
    HRESULT                 hrTemp;

    DPF_ENTER();

    if (defaultType == VOICE_DEFAULT)
        hr = WaveMessage(WAVE_MAPPER, fCapture, DRVM_MAPPER_CONSOLEVOICECOM_GET, (DWORD_PTR)&uDeviceId, (DWORD_PTR)&dwFlags);

    if (FAILED(hr))
        hr = WaveMessage(WAVE_MAPPER, fCapture, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&uDeviceId, (DWORD_PTR)&dwFlags);

    if(FAILED(hr))
    {
        hrTemp = RhRegGetPreferredDevice(fCapture, NULL, 0, &uDeviceId, &fPreferredOnly);

        if(SUCCEEDED(hrTemp))
        {
            dwFlags = fPreferredOnly ? DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY : 0;
            hr = DS_OK;
        }
    }

    if(SUCCEEDED(hr) && puDeviceId)
    {
        *puDeviceId = uDeviceId;
    }

    if(SUCCEEDED(hr) && pdwFlags)
    {
        *pdwFlags = dwFlags;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  InitStaticDriverList
 *
 *  Description:
 *      Initializes the static driver list.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::InitStaticDriverList"

HRESULT CVirtualAudioDeviceManager::InitStaticDriverList
(
    VADDEVICETYPE                   vdtDeviceType
)
{
    HRESULT                         hr                  = DS_OK;
    CObjectList<CDevice>            lstDevices;
    CNode<CDevice *> *              pDeviceNode;
    CObjectList<CDeviceDescription> lstDrivers;
    CNode<CDeviceDescription *> *   pDriverNode;
    CStaticDriver *                 pStaticDriver;
    CNode<CStaticDriver *> *        pStaticDriverNode;

    DPF_ENTER();

#ifndef SHARED

    // Check for any PnP events that would require us to rebuild the list
    CheckMmPnpEvents();

#endif // SHARED

    // Mask off any types that have already been enumerated
    if(vdtDeviceType &= m_vdtDrivers ^ vdtDeviceType)
    {
        // Enumerate all devices
        hr = EnumDevices(vdtDeviceType, &lstDevices);

        // Enumerate all drivers
        for(pDeviceNode = lstDevices.GetListHead(); pDeviceNode && SUCCEEDED(hr); pDeviceNode = pDeviceNode->m_pNext)
        {
            pDeviceNode->m_data->EnumDrivers(&lstDrivers);
        }

        // Add each driver to the static driver list
        for(pDriverNode = lstDrivers.GetListHead(); pDriverNode && SUCCEEDED(hr); pDriverNode = pDriverNode->m_pNext)
        {
            pStaticDriver = NEW(CStaticDriver(pDriverNode->m_data));
            hr = HRFROMP(pStaticDriver);

            if(SUCCEEDED(hr))
            {
                pStaticDriverNode = m_lstDrivers.AddNodeToList(pStaticDriver);
                hr = HRFROMP(pStaticDriverNode);
            }

            RELEASE(pStaticDriver);
        }

        // Include this device type in the list of enumerated types
        if(SUCCEEDED(hr))
        {
            m_vdtDrivers |= vdtDeviceType;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FreeStaticDriverList
 *
 *  Description:
 *      Frees the static driver list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::FreeStaticDriverList"

void CVirtualAudioDeviceManager::FreeStaticDriverList(void)
{
    DPF_ENTER();

    m_lstDrivers.RemoveAllNodesFromList();
    m_vdtDrivers = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetDriverCertificationStatus
 *
 *  Description:
 *      Gets the certification status of a particular driver.
 *
 *  Arguments:
 *      CDevice * [in]: initialized device pointer.
 *      LPDWORD [out]: receives certification status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::GetDriverCertificationStatus"

HRESULT CVirtualAudioDeviceManager::GetDriverCertificationStatus
(
    CDevice *                   pDevice,
    LPDWORD                     pdwCertification
)
{
    DWORD                       dwCertification = VERIFY_UNCHECKED;
    CNode<CStaticDriver *> *    pNode;
    HRESULT                     hr;

    DPF_ENTER();

    // Initialize the static driver list
    hr = InitStaticDriverList(pDevice->m_vdtDeviceType);

    // Let's see if we've already checked certification for this driver.
    // (It's very slow - see NT Bug 405705 and Millenium bug 97114.)
    // We'll walk the static driver list until we find a match for the
    // device interface.
    if(SUCCEEDED(hr))
    {
        for(pNode = m_lstDrivers.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
#ifdef WINNT
            if(!pDevice->m_pDeviceDescription->m_strInterface.IsEmpty() && !pNode->m_data->m_pDeviceDescription->m_strInterface.IsEmpty() && !lstrcmpi(pDevice->m_pDeviceDescription->m_strInterface, pNode->m_data->m_pDeviceDescription->m_strInterface))
#else // WINNT
            if(pDevice->m_pDeviceDescription->m_dwDevnode && pDevice->m_pDeviceDescription->m_dwDevnode == pNode->m_data->m_pDeviceDescription->m_dwDevnode)
#endif // WINNT
            {
                break;
            }
        }

        ASSERT(pNode);
    }

    // Do we actually need to check certification?
    if(SUCCEEDED(hr) && pNode)
    {
        dwCertification = pNode->m_data->m_dwCertification;
    }

    // If so, go ahead and check it
    if(SUCCEEDED(hr) && VERIFY_UNCHECKED == dwCertification)
    {
        hr = pDevice->GetCertification(&dwCertification, TRUE);

        if(SUCCEEDED(hr))
        {
            switch(dwCertification)
            {
                case VERIFY_CERTIFIED:
                    RPF(DPFLVL_INFO, "Running on a certified driver");
                    break;

                case VERIFY_UNCERTIFIED:
                    RPF(DPFLVL_WARNING, "Running on an uncertified driver!");
                    break;

                default:
                    ASSERT(FALSE);
                    break;
            }
        }
        else if(DSERR_UNSUPPORTED == hr)
        {
            dwCertification = VERIFY_UNCERTIFIED;
            hr = DS_OK;
        }

        if(SUCCEEDED(hr) && pNode)
        {
            pNode->m_data->m_dwCertification = dwCertification;
        }
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *pdwCertification = dwCertification;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenPersistentDataKey
 *
 *  Description:
 *      Opens the persistent data key for a specific device.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *      LPTSTR [in]: device interface.
 *      PHKEY [out]: registry key handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::OpenPersistentDataKey"

HRESULT CVirtualAudioDeviceManager::OpenPersistentDataKey
(
    VADDEVICETYPE           vdtDeviceType,
#ifdef WINNT
    LPCTSTR                 pszInterface,
#else // WINNT
    DWORD                   dwDevnode,
#endif // WINNT
    PHKEY                   phkey
)
{
    HKEY                    hkeyParent  = NULL;
    DWORD                   dwFlags     = REGOPENPATH_ALLOWCREATE;
    HRESULT                 hr          = DSERR_GENERIC;

    DPF_ENTER();

    ASSERT(IS_VALID_VAD(vdtDeviceType));

    // Open the device-specific key

#ifdef WINNT
    if(pszInterface)
#else // WINNT
    if(dwDevnode)
#endif // WINNT

    {
#ifdef WINNT
        hr = OpenDevicePersistentDataKey(vdtDeviceType, pszInterface, &hkeyParent);
#else // WINNT
        hr = OpenDevicePersistentDataKey(vdtDeviceType, dwDevnode, &hkeyParent);
#endif // WINNT
    }

    // If we failed to open the device key, use the default key
    if(FAILED(hr))
    {

#ifdef WINNT
        if(pszInterface)
#else // WINNT
        if(dwDevnode)
#endif // WINNT

        {
            DPF(DPFLVL_WARNING, "Opening the default persistent key");
        }

        hr = OpenDefaultPersistentDataKey(&hkeyParent);
    }

    // Open the subkey
    if(SUCCEEDED(hr))
    {
        if(IS_RENDER_VAD(vdtDeviceType))
        {
            dwFlags |= REGOPENPATH_DIRECTSOUND;
        }

        if(IS_CAPTURE_VAD(vdtDeviceType))
        {
            dwFlags |= REGOPENPATH_DIRECTSOUNDCAPTURE;
        }

        hr = RhRegOpenPath(hkeyParent, phkey, dwFlags, 0);
    }

    // Clean up
    RhRegCloseKey(&hkeyParent);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenDevicePersistentDataKey
 *
 *  Description:
 *      Opens the persistent data key for a specific device.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *      LPTSTR [in]: device interface.
 *      PHKEY [out]: registry key handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::OpenDevicePersistentDataKey"

HRESULT CVirtualAudioDeviceManager::OpenDevicePersistentDataKey
(
    VADDEVICETYPE               vdtDeviceType,
#ifdef WINNT
    LPCTSTR                     pszInterface,
#else // WINNT
    DWORD                       dwDevnode,
#endif // WINNT
    PHKEY                       phkey
)
{
    CNode<CStaticDriver *> *    pNode;
    CPnpHelper *                pPnp;
    HRESULT                     hr;

#ifndef WINNT
    SP_DEVINFO_DATA             DeviceInfoData;
#endif // WINNT

    DPF_ENTER();

    ASSERT(IS_VALID_VAD(vdtDeviceType));

#ifdef WINNT
    ASSERT(pszInterface);
#else // WINNT
    ASSERT(dwDevnode);
#endif // WINNT

    // Initialize the static driver list
    hr = InitStaticDriverList(vdtDeviceType);

    if(SUCCEEDED(hr))
    {
        // Find the driver in the static driver list whose interface matches
        // this one
        for(pNode = m_lstDrivers.GetListHead(); pNode; pNode = pNode->m_pNext)
        {

#ifdef WINNT
            if(!pNode->m_data->m_pDeviceDescription->m_strInterface.IsEmpty() && !lstrcmpi(pszInterface, pNode->m_data->m_pDeviceDescription->m_strInterface))
#else // WINNT
            if(dwDevnode == pNode->m_data->m_pDeviceDescription->m_dwDevnode)
#endif // WINNT

            {
                break;
            }
        }

        if (pNode == NULL)
        {
            // This used to be an assert. However, PnP stress tests showed
            // that the device interface can be removed between the time
            // the static driver list is built and the time we look for
            // this device interface. So now we just return an error.
            //
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            // If the driver has an open key, just use that one.  Otherwise, we'll
            // have to open a new key and save it in the list.
            if(pNode->m_data->m_hkeyRoot)
            {
                // Duplicate the key
                hr = RhRegDuplicateKey(pNode->m_data->m_hkeyRoot, pNode->m_data->m_dwKeyOwnerProcessId, FALSE, phkey);
            }
            else
            {
                // Create the PnP helper object
                pPnp = NEW(CPnpHelper);
                hr = HRFROMP(pPnp);

                if(SUCCEEDED(hr))
                {
#ifdef WINNT
                    hr = pPnp->Initialize(KSCATEGORY_AUDIO, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
#else // WINNT
                    hr = pPnp->Initialize(GUID_NULL, DIGCF_PRESENT);
#endif // WINNT
                }

#ifndef WINNT
                // Get device info data
                if(SUCCEEDED(hr))
                {
                    hr = pPnp->FindDevice(dwDevnode, &DeviceInfoData);
                }
#endif // WINNT

                // Open the device registry key
                if(SUCCEEDED(hr))
                {
#ifdef WINNT
                    hr = pPnp->OpenDeviceInterfaceRegistryKey(pszInterface, KSCATEGORY_AUDIO, DIREG_DEV, TRUE, phkey);
#else // WINNT
                    hr = pPnp->OpenDeviceRegistryKey(&DeviceInfoData, DIREG_DEV, TRUE, phkey);
#endif // WINNT
                }

                // Tell the static driver about the key
                if(SUCCEEDED(hr))
                {
                    pNode->m_data->m_dwKeyOwnerProcessId = GetCurrentProcessId();
                    hr = RhRegDuplicateKey(*phkey, pNode->m_data->m_dwKeyOwnerProcessId, FALSE, &pNode->m_data->m_hkeyRoot);
                }

                // Clean up
                RELEASE(pPnp);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenDefaultPersistentDataKey
 *
 *  Description:
 *      Opens the default persistent data key.
 *
 *  Arguments:
 *      PHKEY [out]: registry key handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::OpenDefaultPersistentDataKey"

HRESULT CVirtualAudioDeviceManager::OpenDefaultPersistentDataKey
(
    PHKEY                   phkey
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = RhRegOpenPath(HKEY_LOCAL_MACHINE, phkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_ALLOWCREATE, 0);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  RemoveProhibitedDrivers
 *
 *  Description:
 *      Removes prohibited drivers from a device list.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: types of devices that appear in the list.
 *      CList * [in/out]: driver list.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::RemoveProhibitedDrivers"

void CVirtualAudioDeviceManager::RemoveProhibitedDrivers
(
    VADDEVICETYPE                       vdtDeviceType,
    CObjectList<CDeviceDescription> *   plst
)
{
    VADDEVICETYPE                       vdtValid;
    CNode<CDeviceDescription *> *       pNode;
    CNode<CDeviceDescription *> *       pNode2;

    DPF_ENTER();

    // Mask off any types that are globally disabled
    vdtValid = GetAllowableDevices(vdtDeviceType, NULL);

    for(pNode = plst->GetListHead(); pNode; pNode = pNode->m_pNext)
        if(!(pNode->m_data->m_vdtDeviceType & vdtValid))
            pNode->m_data->m_vdtDeviceType |= VAD_DEVICETYPE_PROHIBITED;

    // Mask off any types that are specifically disabled for each device
    pNode = plst->GetListHead();

    while(pNode)
    {
        if(!(pNode->m_data->m_vdtDeviceType & VAD_DEVICETYPE_PROHIBITED))
        {

#ifdef WINNT
            if(!pNode->m_data->m_strInterface.IsEmpty())
#else // WINNT
            if(pNode->m_data->m_dwDevnode)
#endif // WINNT

            {

#ifdef WINNT
                vdtValid = GetAllowableDevices(vdtDeviceType, pNode->m_data->m_strInterface);
#else // WINNT
                vdtValid = GetAllowableDevices(vdtDeviceType, pNode->m_data->m_dwDevnode);
#endif // WINNT

                pNode2 = pNode;

                while(pNode2)
                {
#ifdef WINNT
                    if(!lstrcmpi(pNode2->m_data->m_strInterface, pNode->m_data->m_strInterface))
#else // WINNT
                    if(pNode2->m_data->m_dwDevnode == pNode->m_data->m_dwDevnode)
#endif // WINNT
                    {
                        if(IS_RENDER_VAD(pNode2->m_data->m_vdtDeviceType) == IS_RENDER_VAD(pNode->m_data->m_vdtDeviceType))
                            if(!(pNode2->m_data->m_vdtDeviceType & vdtValid))
                                pNode2->m_data->m_vdtDeviceType |= VAD_DEVICETYPE_PROHIBITED;

                    }
                    pNode2 = pNode2->m_pNext;
                }
            }
        }

        pNode = pNode->m_pNext;
    }

    // Remove the prohibited drivers from the list
    pNode = plst->GetListHead();

    while(pNode)
    {
        pNode2 = pNode->m_pNext;

        if(pNode->m_data->m_vdtDeviceType & VAD_DEVICETYPE_PROHIBITED)
        {
            pNode->m_data->m_vdtDeviceType &= ~VAD_DEVICETYPE_PROHIBITED;
            plst->RemoveNodeFromList(pNode);
        }

        pNode = pNode2;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  RemoveDuplicateWaveDevices
 *
 *  Description:
 *      Removes duplicate wave devices from a driver list.
 *
 *  Arguments:
 *      CList * [in/out]: driver list.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::RemoveDuplicateWaveDevices"

void CVirtualAudioDeviceManager::RemoveDuplicateWaveDevices
(
    CObjectList<CDeviceDescription> *   plst
)
{
    CNode<CDeviceDescription *> *       pNode[3];

    DPF_ENTER();

    pNode[0] = plst->GetListHead();

    while(pNode[0])
    {
        pNode[1] = pNode[0]->m_pNext;

        while(pNode[1])
        {
            pNode[2] = pNode[1]->m_pNext;

            if(IS_RENDER_VAD(pNode[0]->m_data->m_vdtDeviceType) == IS_RENDER_VAD(pNode[1]->m_data->m_vdtDeviceType))
            {
                if(WAVE_DEVICEID_NONE != pNode[0]->m_data->m_uWaveDeviceId)
                {
                    if(pNode[0]->m_data->m_uWaveDeviceId == pNode[1]->m_data->m_uWaveDeviceId)
                    {
                        plst->RemoveNodeFromList(pNode[1]);
                    }
                }
            }

            pNode[1] = pNode[2];
        }

        pNode[0] = pNode[0]->m_pNext;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SortDriverList
 *
 *  Description:
 *      Sorts the driver list.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type(s).
 *      CList * [in/out]: list object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::SortDriverList"

void CVirtualAudioDeviceManager::SortDriverList
(
    VADDEVICETYPE                       vdtDeviceType,
    CObjectList<CDeviceDescription> *   plst
)
{
    UINT                                uPreferredId[2] = { WAVE_DEVICEID_NONE, WAVE_DEVICEID_NONE };
    CNode<CDeviceDescription *> *       pNode;
    CNode<CDeviceDescription *> *       pCheckNode;

    DPF_ENTER();

    // Reorder the list so that the preferred device appears first, then
    // by wave device id, then by device type.
    if(IS_RENDER_VAD(vdtDeviceType))
    {
        GetPreferredWaveDevice(FALSE, &uPreferredId[0], NULL);
    }

    if(IS_CAPTURE_VAD(vdtDeviceType))
    {
        GetPreferredWaveDevice(TRUE, &uPreferredId[1], NULL);
    }

    pNode = plst->GetListHead();

    while(pNode && pNode->m_pNext)
    {
        if(SortDriverListCallback(uPreferredId, pNode->m_data, pNode->m_pNext->m_data) > 0)
        {
            pCheckNode = plst->InsertNodeIntoList(pNode->m_pNext, pNode->m_data);
            ASSERT(pCheckNode != NULL);
            plst->RemoveNodeFromList(pNode);
            pNode = plst->GetListHead();
        }
        else
        {
            pNode = pNode->m_pNext;
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SortDriverListCallback
 *
 *  Description:
 *      Sort routine for SortDriverList.
 *
 *  Arguments:
 *      const UINT * [in]: array of preferred device id's.
 *      CDeviceDescription * [in]: driver 1.
 *      CDeviceDescription * [in]: driver 2.
 *
 *  Returns:
 *      INT: 0 if the nodes are the same.  Negative if driver 1 should be
 *           first in the list, positive if driver 2 should be first.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::SortDriverListCallback"

INT CVirtualAudioDeviceManager::SortDriverListCallback
(
    const UINT *            puPreferredId,
    CDeviceDescription *    p1,
    CDeviceDescription *    p2
)
{
    INT                     n   = 0;
    UINT                    i1  = 0;
    UINT                    i2  = 0;

    DPF_ENTER();

    if(IS_CAPTURE_VAD(p1->m_vdtDeviceType) == IS_CAPTURE_VAD(p2->m_vdtDeviceType))
    {
        if(WAVE_DEVICEID_NONE != puPreferredId[IS_CAPTURE_VAD(p1->m_vdtDeviceType)])
        {
            if(p1->m_uWaveDeviceId == puPreferredId[IS_CAPTURE_VAD(p1->m_vdtDeviceType)])
            {
                if(p2->m_uWaveDeviceId != puPreferredId[IS_CAPTURE_VAD(p1->m_vdtDeviceType)])
                {
                    n = -1;
                }
            }
            else
            {
                if(p2->m_uWaveDeviceId == puPreferredId[IS_CAPTURE_VAD(p1->m_vdtDeviceType)])
                {
                    n = 1;
                }
            }
        }
    }

    if(!n)
    {
        if(IS_CAPTURE_VAD(p1->m_vdtDeviceType) == IS_CAPTURE_VAD(p2->m_vdtDeviceType))
        {
            n = p1->m_uWaveDeviceId - p2->m_uWaveDeviceId;
        }
    }

    if(!n)
    {
        for(i1 = 0; i1 < NUMELMS(g_avdtDeviceTypes); i1++)
        {
            if(g_avdtDeviceTypes[i1] == p1->m_vdtDeviceType)
            {
                break;
            }
        }

        for(i2 = 0; i2 < NUMELMS(g_avdtDeviceTypes); i2++)
        {
            if(g_avdtDeviceTypes[i2] == p2->m_vdtDeviceType)
            {
                break;
            }
        }

        n = i1 - i2;
    }

    DPF_LEAVE(n);

    return n;
}


#ifndef SHARED

/***************************************************************************
 *
 *  GetPnpMappingName, m_pszPnpMapping
 *
 *  Description:
 *      GetPnpMappingName() is an auxilliary function used to obtain the
 *      correct name on this platform for the PnP info file mapping object,
 *      and store it in m_pszPnpMapping for use by CheckMmPnpEvents below.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      LPCTSTR: Name of the file mapping object.
 *
 ***************************************************************************/

static const LPCTSTR GetPnpMappingName(void)
{
    if (GetWindowsVersion() >= WIN_XP)
        return TEXT("Global\\mmGlobalPnpInfo");
    else
        return TEXT("mmGlobalPnpInfo");
}

const LPCTSTR CVirtualAudioDeviceManager::m_pszPnpMapping = GetPnpMappingName();


/***************************************************************************
 *
 *  CheckMmPnpEvents
 *
 *  Description:
 *      Checks WINMM for any PnP events that would require us to rebuild
 *      the static driver list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVirtualAudioDeviceManager::CheckMmPnpEvents"

void CVirtualAudioDeviceManager::CheckMmPnpEvents(void)
{
    typedef struct _MMPNPINFO
    {
        DWORD                       cbSize;
        LONG                        cPnpEvents;
    } MMPNPINFO, *PMMPNPINFO;

    static LONG                     cPnpEvents      = 0;
    HANDLE                          hFileMapping;
    PMMPNPINFO                      pMmPnpInfo;

    DPF_ENTER();

    // Check for any PnP events that would require us to rebuild the list
    hFileMapping = OpenFileMapping(FILE_MAP_READ, FALSE, m_pszPnpMapping);

    if(IsValidHandleValue(hFileMapping))
    {
        pMmPnpInfo = (PMMPNPINFO)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, sizeof *pMmPnpInfo);

        if(pMmPnpInfo)
        {
            ASSERT(sizeof *pMmPnpInfo <= pMmPnpInfo->cbSize);

            if(cPnpEvents != pMmPnpInfo->cPnpEvents)
            {
                FreeStaticDriverList();
                cPnpEvents = pMmPnpInfo->cPnpEvents;
            }

            UnmapViewOfFile(pMmPnpInfo);
        }

        CLOSE_HANDLE(hFileMapping);
    }

    DPF_LEAVE_VOID();
}

#endif // SHARED


/***************************************************************************
 *
 *  CStaticDriver
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStaticDriver::CStaticDriver"

CStaticDriver::CStaticDriver(CDeviceDescription *pDeviceDescription)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CStaticDriver);

    // Initialize defaults
    m_pDeviceDescription = ADDREF(pDeviceDescription);
    m_hkeyRoot = NULL;
    m_dwCertification = VERIFY_UNCHECKED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CStaticDriver
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStaticDriver::~CStaticDriver"

CStaticDriver::~CStaticDriver(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CStaticDriver);

    RELEASE(m_pDeviceDescription);

    RhRegCloseKey(&m_hkeyRoot);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDevice::CDevice"

CDevice::CDevice
(
    VADDEVICETYPE vdtDeviceType
)
    : m_vdtDeviceType(vdtDeviceType)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDevice);

    ASSERT(IS_VALID_VAD(vdtDeviceType));
    ASSERT(IS_SINGLE_VAD(vdtDeviceType));

    m_pDeviceDescription = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDevice
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDevice::~CDevice"

CDevice::~CDevice(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDevice);

    g_pVadMgr->m_lstDevices.RemoveDataFromList(this);

    RELEASE(m_pDeviceDescription);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDevice::Initialize"

HRESULT CDevice::Initialize(CDeviceDescription *pDesc)
{
    DPF_ENTER();

    ASSERT(m_vdtDeviceType == pDesc->m_vdtDeviceType);

    m_pDeviceDescription = ADDREF(pDesc);
    ASSERT(m_pDeviceDescription != NULL);

    // Add this object to the parent's list
    HRESULT hr = HRFROMP(g_pVadMgr->m_lstDevices.AddNodeToList(this));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDriverVersion
 *
 *  Description:
 *      Gets the driver version number.
 *
 *  Arguments:
 *      LPLARGE_INTEGER [out]: receives driver version.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDevice::GetDriverVersion"

HRESULT CDevice::GetDriverVersion(LARGE_INTEGER *pliVersion)
{
    HRESULT                 hr                  = DS_OK;
    TCHAR                   szPath[MAX_PATH];
    VS_FIXEDFILEINFO        ffi;

    DPF_ENTER();

    if(m_pDeviceDescription->m_strPath.IsEmpty())
    {
        hr = DSERR_GENERIC;
    }

    // Determine the driver directory
    if(SUCCEEDED(hr))
    {
        if(IS_KS_VAD(m_vdtDeviceType))
        {
            if(!GetWindowsDirectory(szPath, NUMELMS(szPath)))
            {
                hr = DSERR_GENERIC;
            }

            if(SUCCEEDED(hr))
            {
                if(TEXT('\\') != szPath[lstrlen(szPath) - 1])
                {
                    lstrcat(szPath, TEXT("\\"));
                }

                lstrcat(szPath, TEXT("System32\\Drivers\\"));
            }
        }
        else if(IS_VXD_VAD(m_vdtDeviceType))
        {
            if(!GetSystemDirectory(szPath, NUMELMS(szPath)))
            {
                hr = DSERR_GENERIC;
            }

            if(SUCCEEDED(hr))
            {
                if(TEXT('\\') != szPath[lstrlen(szPath) - 1])
                {
                    lstrcat(szPath, TEXT("\\"));
                }
            }
        }
        else
        {
            hr = DSERR_GENERIC;
        }
    }

    // Build the full driver path
    if(SUCCEEDED(hr))
    {
        if(lstrlen(szPath) + lstrlen(m_pDeviceDescription->m_strPath) >= NUMELMS(szPath))
        {
            hr = DSERR_GENERIC;
        }
    }

    if(SUCCEEDED(hr))
    {
        lstrcat(szPath, m_pDeviceDescription->m_strPath);
    }

    // Get the driver file information
    if(SUCCEEDED(hr))
    {
        hr = GetFixedFileInformation(szPath, &ffi);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        pliVersion->LowPart = ffi.dwFileVersionLS;
        pliVersion->HighPart = ffi.dwFileVersionMS;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CRenderDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderDevice::CRenderDevice"

CRenderDevice::CRenderDevice(VADDEVICETYPE vdtDeviceType)
    : CDevice(vdtDeviceType)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CRenderDevice);

    // Make sure this is a valid render device type
    ASSERT(IS_RENDER_VAD(vdtDeviceType));

    // Initialize defaults
    m_dwSupport = 0;
    m_dwAccelerationFlags = DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CRenderDevice
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderDevice::~CRenderDevice"

CRenderDevice::~CRenderDevice(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CRenderDevice);

    ASSERT(!m_lstPrimaryBuffers.GetNodeCount());
    ASSERT(!m_lstSecondaryBuffers.GetNodeCount());

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderDevice::Initialize"

HRESULT CRenderDevice::Initialize(CDeviceDescription *pDesc)
{
    HRESULT                 hr;
    WAVEOUTCAPS             woc;
    MMRESULT                mmr;

    DPF_ENTER();

    // Initialize the base class
    hr = CDevice::Initialize(pDesc);

    // Get waveOut device caps
    mmr = waveOutGetDevCaps(pDesc->m_uWaveDeviceId, &woc, sizeof woc);
    if (MMSYSERR_NOERROR == mmr)
    {
        m_dwSupport = woc.dwSupport;
    }

    // Get default software 3D algorithm from registry
    HKEY hkey = 0;
    TCHAR szAlgName[100];  // Long enough for any algorithm name or raw GUID
    m_guidDflt3dAlgorithm = &DS3DALG_NO_VIRTUALIZATION;  // The default algorithm
    GUID guidTmp = GUID_NULL;

    if (SUCCEEDED(RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkey, 0, 1, REGSTR_GLOBAL_CONFIG)) &&
        SUCCEEDED(RhRegGetStringValue(hkey, REGSTR_DFLT_3D_ALGORITHM, szAlgName, sizeof szAlgName)))
    {
        // Strip braces from szAlgName; UuidFromString() can't handle them
        int startPos = 0;
        for (int c=0; c < sizeof szAlgName && szAlgName[c]; ++c)
            if (szAlgName[c] == '{')
                startPos = c+1;
            else if (szAlgName[c] == '}')
                szAlgName[c] = '\0';
        if (UuidFromString((_TUCHAR*)(szAlgName+startPos), &guidTmp) == RPC_S_OK)
        {
            DPF(DPFLVL_MOREINFO, "Got 3D algorithm GUID " DPF_GUID_STRING, DPF_GUID_VAL(guidTmp));
        }
        for (DWORD i=0; i < sizeof g_3dAlgList / sizeof *g_3dAlgList; ++i)
            // The algorithm can be specified either by name or by GUID:
            if (!_tcsicmp(szAlgName, g_3dAlgList[i].pszName) ||
                guidTmp == *g_3dAlgList[i].pGuid)
            {
                m_guidDflt3dAlgorithm = g_3dAlgList[i].pGuid;
                DPF(DPFLVL_MOREINFO, "Setting default S/W 3D algorithm to \"%s\"", g_3dAlgList[i].pszName);
                break;
            }
        RhRegCloseKey(&hkey);
        DPF(DPFLVL_MOREINFO, "Default S/W 3D algorithm GUID: " DPF_GUID_STRING, DPF_GUID_VAL(*m_guidDflt3dAlgorithm));
    }
    else
    {
        DPF(DPFLVL_MOREINFO, "No default S/W 3D algorithm in the registry");
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetGlobalAttenuation
 *
 *  Description:
 *      Gets the attenuation for each channel on the device.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [out]: receives attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderDevice::GetGlobalAttenuation"

HRESULT CRenderDevice::GetGlobalAttenuation(PDSVOLUMEPAN pdsvp)
{
    LONG                    lLeft;
    LONG                    lRight;
    HRESULT                 hr;

    DPF_ENTER();

    hr = GetWaveOutVolume(m_pDeviceDescription->m_uWaveDeviceId, m_dwSupport, &lLeft, &lRight);

    if(SUCCEEDED(hr))
    {
        AttenuationToVolumePan(lLeft, lRight, &pdsvp->lVolume, &pdsvp->lPan);
        FillDsVolumePan(pdsvp->lVolume, pdsvp->lPan, pdsvp);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetGlobalAttenuation
 *
 *  Description:
 *      Sets the attenuation for each channel on the device.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderDevice::SetGlobalAttenuation"

HRESULT CRenderDevice::SetGlobalAttenuation
(
    PDSVOLUMEPAN            pdsvp
)
{
    LONG                    lLeft;
    LONG                    lRight;
    HRESULT                 hr;

    DPF_ENTER();

    VolumePanToAttenuation(pdsvp->lVolume, pdsvp->lPan, &lLeft, &lRight);

    hr = SetWaveOutVolume(m_pDeviceDescription->m_uWaveDeviceId, m_dwSupport, lLeft, lRight);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetVolumePanCaps
 *
 *  Description:
 *      Gets volume/pan capabilities for the device.
 *
 *  Arguments:
 *      LPDWORD [in]: receives volume/pan caps flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderDevice::GetVolumePanCaps"

HRESULT CRenderDevice::GetVolumePanCaps
(
    LPDWORD                 pdwFlags
)
{
    DPF_ENTER();

    *pdwFlags = 0;

    if(WAVE_DEVICEID_NONE != m_pDeviceDescription->m_uWaveDeviceId)
    {
        if(m_dwSupport & WAVECAPS_VOLUME)
        {
            *pdwFlags |= DSBCAPS_CTRLVOLUME;
        }

        if(m_dwSupport & WAVECAPS_LRVOLUME)
        {
            *pdwFlags |= DSBCAPS_CTRLPAN;
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  CRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CRenderDevice * [in]: parent device.
 *      LPVOID [in]: instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderWaveBuffer::CRenderWaveBuffer"

CRenderWaveBuffer::CRenderWaveBuffer
(
    CRenderDevice *         pDevice,
    LPVOID                  pvInstance
)
    : m_pvInstance(pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CRenderWaveBuffer);

    // Initialize defaults
    m_pDevice = pDevice;
    m_pSysMemBuffer = NULL;

    ZeroMemory(&m_vrbd, sizeof m_vrbd);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CRenderWaveBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderWaveBuffer::~CRenderWaveBuffer"

CRenderWaveBuffer::~CRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CRenderWaveBuffer);

    // Free the system memory buffer
    RELEASE(m_pSysMemBuffer);

    // Free the format
    MEMFREE(m_vrbd.pwfxFormat);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      CRenderWaveBuffer * [in]: buffer to duplicate from.  This parameter
 *                                should be NULL to initialize a new buffer.
 *      CSysMemBuffer * [in]: system memory buffer to use.  If this parameter
 *                            is NULL, a new one will be created.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderWaveBuffer::Initialize"

HRESULT CRenderWaveBuffer::Initialize
(
    LPCVADRBUFFERDESC       pDesc,
    CRenderWaveBuffer *     pSource,
    CSysMemBuffer *         pSysMemBuffer
)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    // If we're being reinitialized with the same CSysMemBuffer,
    // don't release and addref. This can cause final release if
    // we're not careful.
    //
    BOOL fSameSysMemBuffer = (m_pSysMemBuffer && m_pSysMemBuffer == pSysMemBuffer);

    if (!fSameSysMemBuffer)
    {
        RELEASE(m_pSysMemBuffer);
    }

    MEMFREE(m_vrbd.pwfxFormat);

    // Save a copy of the buffer description
    if(!pDesc)
    {
        ASSERT(pSource);
        pDesc = &pSource->m_vrbd;
    }

    CopyMemory(&m_vrbd, pDesc, sizeof *pDesc);

    if(m_vrbd.pwfxFormat)
    {
        m_vrbd.pwfxFormat = CopyWfxAlloc(m_vrbd.pwfxFormat);
        hr = HRFROMP(m_vrbd.pwfxFormat);
    }

    // Initialize the system memory buffer.  All buffers get system memory that
    // they lock and unlock, regardless of the actual buffer implementation.
    if(SUCCEEDED(hr))
    {
        if(pSource)
        {
            pSysMemBuffer = pSource->m_pSysMemBuffer;
        }

        if(pSysMemBuffer)
        {
            ASSERT(pSysMemBuffer->GetSize() == m_vrbd.dwBufferBytes);

            if (!fSameSysMemBuffer)
            {
                m_pSysMemBuffer = ADDREF(pSysMemBuffer);
            }
        }
        else if(m_vrbd.dwBufferBytes)
        {
            m_pSysMemBuffer = NEW(CSysMemBuffer);
            hr = HRFROMP(m_pSysMemBuffer);

            if(SUCCEEDED(hr))
            {
                hr = m_pSysMemBuffer->Initialize(m_vrbd.dwBufferBytes);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Gets capabilities for the device.
 *
 *  Arguments:
 *      LPVADRBUFFERCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderWaveBuffer::GetCaps"

HRESULT CRenderWaveBuffer::GetCaps(LPVADRBUFFERCAPS pCaps)
{
    DPF_ENTER();

    if(!(m_vrbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        ASSERT(LXOR(m_vrbd.dwFlags & DSBCAPS_LOCSOFTWARE, m_vrbd.dwFlags & DSBCAPS_LOCHARDWARE));
    }

    pCaps->dwFlags = m_vrbd.dwFlags;
    pCaps->dwBufferBytes = m_pSysMemBuffer ? m_pSysMemBuffer->GetSize() : 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks a region of the buffer.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the buffer to lock from.
 *      DWORD [in]: size, in bytes, of the region to lock.
 *      LPVOID * [out]: receives pointer to region 1 of the lock.
 *      LPDWORD [out]: receives size of above region.
 *      LPVOID * [out]: receives pointer to region 2 of the lock.
 *      LPDWORD [out]: receives size of above region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderWaveBuffer::Lock"

HRESULT CRenderWaveBuffer::Lock
(
    DWORD                   ibLock,
    DWORD                   cbLock,
    LPVOID *                ppv1,
    LPDWORD                 pcb1,
    LPVOID *                ppv2,
    LPDWORD                 pcb2
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pSysMemBuffer);

    hr = m_pSysMemBuffer->LockRegion(this, ibLock, cbLock, ppv1, pcb1, ppv2, pcb2);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks a region of the buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to region 1 of the lock.
 *      DWORD [in]: size of above region.
 *      LPVOID [in]: pointer to region 2 of the lock.
 *      DWORD [in]: size of above region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderWaveBuffer::Unlock"

HRESULT CRenderWaveBuffer::Unlock
(
    LPVOID                  pv1,
    DWORD                   cb1,
    LPVOID                  pv2,
    DWORD                   cb2
)
{
    DWORD                   ibLock;
    DWORD                   cbLock;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pSysMemBuffer);

    hr = m_pSysMemBuffer->UnlockRegion(this, pv1, cb1, pv2, cb2);

    if(SUCCEEDED(hr))
    {
        ASSERT((LPBYTE)pv1 >= m_pSysMemBuffer->GetWriteBuffer());
        ASSERT((LPBYTE)pv1 + cb1 <= m_pSysMemBuffer->GetWriteBuffer() + m_pSysMemBuffer->GetSize());

        ibLock = PtrDiffToUlong((LPBYTE)pv1 - m_pSysMemBuffer->GetWriteBuffer());
        cbLock = cb1;
    }

    if(SUCCEEDED(hr) && pv2 && cb2)
    {
        ASSERT((LPBYTE)pv2 == m_pSysMemBuffer->GetWriteBuffer());
        ASSERT((LPBYTE)pv2 + cbLock + cb2 <= m_pSysMemBuffer->GetWriteBuffer() + m_pSysMemBuffer->GetSize());

        cbLock += cb2;
    }

    if(SUCCEEDED(hr))
    {
        hr = CommitToDevice(ibLock, cbLock);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OverrideLocks
 *
 *  Description:
 *      Cancels any open locks on the buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRenderWaveBuffer::OverrideLocks"

HRESULT CRenderWaveBuffer::OverrideLocks(void)
{
    DPF_ENTER();

    ASSERT(m_pSysMemBuffer);

    m_pSysMemBuffer->OverrideLocks(this);

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  CPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CRenderDevice * [in]: parent device.
 *      LPVOID [in]: instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPrimaryRenderWaveBuffer::CPrimaryRenderWaveBuffer"

CPrimaryRenderWaveBuffer::CPrimaryRenderWaveBuffer
(
    CRenderDevice *         pDevice,
    LPVOID                  pvInstance
)
    : CRenderWaveBuffer(pDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CPrimaryRenderWaveBuffer);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPrimaryRenderWaveBuffer::~CPrimaryRenderWaveBuffer"

CPrimaryRenderWaveBuffer::~CPrimaryRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CPrimaryRenderWaveBuffer);

    // Remove this object from the parent's list
    m_pDevice->m_lstPrimaryBuffers.RemoveDataFromList(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      CRenderWaveBuffer * [in]: buffer to duplicate from.  This parameter
 *                                should be NULL to initialize a new buffer.
 *      CSysMemBuffer * [in]: system memory buffer to use.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPrimaryRenderWaveBuffer::Initialize"

HRESULT CPrimaryRenderWaveBuffer::Initialize
(
    LPCVADRBUFFERDESC       pDesc,
    CRenderWaveBuffer *     pSource,
    CSysMemBuffer *         pSysMemBuffer
)
{
    DPF_ENTER();

    HRESULT hr = CRenderWaveBuffer::Initialize(pDesc, pSource, pSysMemBuffer);

    if (SUCCEEDED(hr))
    {
        // Add this object to the parent's list
        hr = HRFROMP(m_pDevice->m_lstPrimaryBuffers.AddNodeToList(this));
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}



/***************************************************************************
 *
 *  CSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CRenderDevice * [in]: parent device.
 *      LPVOID [in]: instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSecondaryRenderWaveBuffer::CSecondaryRenderWaveBuffer"

CSecondaryRenderWaveBuffer::CSecondaryRenderWaveBuffer
(
    CRenderDevice *         pDevice,
    LPVOID                  pvInstance
)
    : CRenderWaveBuffer(pDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CSecondaryRenderWaveBuffer);

    // Initialize defaults
    m_hrSuccessCode = DS_OK;
    m_pOwningSink = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSecondaryRenderWaveBuffer::~CSecondaryRenderWaveBuffer"

CSecondaryRenderWaveBuffer::~CSecondaryRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CSecondaryRenderWaveBuffer);

    // Remove this object from the parent's list
    m_pDevice->m_lstSecondaryBuffers.RemoveDataFromList(this);
    RELEASE(m_pOwningSink);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      CSecondaryRenderWaveBuffer * [in]: buffer to duplicate from, or
 *                                         NULL to initialize a new buffer.
 *      CSysMemBuffer * [in]: system memory buffer to use.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSecondaryRenderWaveBuffer::Initialize"

HRESULT CSecondaryRenderWaveBuffer::Initialize(LPCVADRBUFFERDESC pDesc, CSecondaryRenderWaveBuffer *pSource, CSysMemBuffer *pSysMemBuffer)
{
    DPF_ENTER();

    HRESULT hr = CRenderWaveBuffer::Initialize(pDesc, pSource, pSysMemBuffer);

    // Add this object to the parent's list
    if (SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pDevice->m_lstSecondaryBuffers.AddNodeToList(this));
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CreatePan3dObject
 *
 *  Description:
 *      Creates a stereo pan 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer frequency.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSecondaryRenderWaveBuffer::CreatePan3dObject"

HRESULT CSecondaryRenderWaveBuffer::CreatePan3dObject
(
    C3dListener *           p3dListener,
    BOOL                    fMute3dAtMaxDistance,
    DWORD                   dwFrequency,
    C3dObject **            pp3dObject
)
{
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    CPan3dObject *          pPan3dObject;
    HRESULT                 hr;
    DPF_ENTER();

    pPan3dObject = NEW(CPan3dObject(p3dListener, fMute3dAtMaxDistance, fDopplerEnabled, dwFrequency, this));
    hr = HRFROMP(pPan3dObject);

    if(SUCCEEDED(hr))
    {
        hr = pPan3dObject->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = pPan3dObject;
    }
    else
    {
        RELEASE(pPan3dObject);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetOwningSink
 *
 *  Description:
 *      Sets the buffer's owning CDirectSoundSink object.
 *
 *  Arguments:
 *      CDirectSoundSink* [in]: The new owning CDirectSoundSink object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSecondaryRenderWaveBuffer::SetOwningSink"

void CSecondaryRenderWaveBuffer::SetOwningSink(CDirectSoundSink* pOwningSink)
{
    DPF_ENTER();

    CHECK_WRITE_PTR(pOwningSink);

    ASSERT(m_vrbd.dwFlags & DSBCAPS_SINKIN);
    ASSERT(m_pOwningSink == NULL);
    CHECK_WRITE_PTR(pOwningSink);

    m_pOwningSink = pOwningSink;
    m_pOwningSink->AddRef();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetBufferFrequency
 *
 *  Description:
 *      Sets the buffer's sample rate.
 *
 *  Arguments:
 *      DWORD [in}: New sample rate in Hz.
 *      BOOL [in]: Whether to clamp to the driver's supported frequency
 *                 range if the call fails on a hardware buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSecondaryRenderWaveBuffer::SetBufferFrequency"

HRESULT CSecondaryRenderWaveBuffer::SetBufferFrequency(DWORD dwFrequency, BOOL fClamp)
{
    HRESULT hr;
    DPF_ENTER();

    if (HasSink())
    {
        hr = m_pOwningSink->SetBufferFrequency(this, dwFrequency);
    }
    else
    {
        hr = SetFrequency(dwFrequency, fClamp);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

/***************************************************************************
 *
 *  CSysMemBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::CSysMemBuffer"

const DWORD CSysMemBuffer::m_cbExtra = 8;

CSysMemBuffer::CSysMemBuffer(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CSysMemBuffer);

    // Initialize defaults
    m_cbAudioBuffers = 0;
    m_pbPreFxBuffer = NULL;
    m_pbPostFxBuffer = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CSysMemBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::~CSysMemBuffer"

CSysMemBuffer::~CSysMemBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CSysMemBuffer);

    if(m_lstLocks.GetNodeCount())
    {
        RPF(DPFLVL_WARNING, "Buffer still contains active locks");
    }

    if(m_pbPreFxBuffer)
    {
        m_pbPreFxBuffer -= m_cbExtra;
        MEMFREE(m_pbPreFxBuffer);
    }

    if(m_pbPostFxBuffer)
    {
        m_pbPostFxBuffer -= m_cbExtra;
        MEMFREE(m_pbPostFxBuffer);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      DWORD [in]: number of bytes to allocate.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::Initialize"

HRESULT CSysMemBuffer::Initialize(DWORD cbBuffer)
{
    DPF_ENTER();

    ASSERT(cbBuffer > 0);

    m_cbAudioBuffers = cbBuffer;

    HRESULT hr = MEMALLOC_A_HR(m_pbPostFxBuffer, BYTE, m_cbAudioBuffers + m_cbExtra);

    if (SUCCEEDED(hr))
        m_pbPostFxBuffer += m_cbExtra;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  LockRegion
 *
 *  Description:
 *      Locks a region of the buffer memory to allow for writing.
 *
 *  Arguments:
 *      LPVOID [in]: lock ownership identifier.
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins. This parameter is ignored if
 *                  DSBLOCK_FROMWRITECURSOR is specified in the dwFlags
 *                  parameter.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     lplpvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the lplpvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr2 parameter. If
 *                     lplpvAudioPtr2 is NULL, this value will be 0.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::LockRegion"

HRESULT CSysMemBuffer::LockRegion
(
    LPVOID                  pvIdentifier,
    DWORD                   dwPosition,
    DWORD                   dwSize,
    LPVOID *                ppvPtr1,
    LPDWORD                 pdwSize1,
    LPVOID *                ppvPtr2,
    LPDWORD                 pdwSize2
)
{
    LOCKCIRCULARBUFFER      lcb;
    HRESULT                 hr;
    UINT                    i;

    DPF_ENTER();

    // Calculate the region to lock
    lcb.pHwBuffer = NULL;
    lcb.pvBuffer = GetWriteBuffer();
    lcb.cbBuffer = m_cbAudioBuffers;
    lcb.ibRegion = dwPosition;
    lcb.cbRegion = dwSize;

    hr = LockCircularBuffer(&lcb);

    // Lock the region(s)
    for(i = 0; i < 2 && pvIdentifier && SUCCEEDED(hr); i++)
    {
        if(lcb.pvLock[i])
        {
            hr = TrackLock(pvIdentifier, lcb.pvLock[i], lcb.cbLock[i]);
        }
    }

    // Success
    if(SUCCEEDED(hr) && ppvPtr1)
    {
        *ppvPtr1 = lcb.pvLock[0];
    }

    if(SUCCEEDED(hr) && pdwSize1)
    {
        *pdwSize1 = lcb.cbLock[0];
    }

    if(SUCCEEDED(hr) && ppvPtr2)
    {
        *ppvPtr2 = lcb.pvLock[1];
    }

    if(SUCCEEDED(hr) && pdwSize2)
    {
        *pdwSize2 = lcb.cbLock[1];
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  UnlockRegion
 *
 *  Description:
 *      Unlocks a region of the buffer.
 *
 *  Arguments:
 *      LPVOID [in]: lock owner identifier.
 *      LPCVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPCVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::UnlockRegion"

HRESULT CSysMemBuffer::UnlockRegion
(
    LPVOID                  pvIdentifier,
    LPCVOID                 pvPtr1,
    DWORD                   dwSize1,
    LPCVOID                 pvPtr2,
    DWORD                   dwSize2
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Unlock the region(s)
    if(pvIdentifier && pvPtr1)
    {
        hr = UntrackLock(pvIdentifier, pvPtr1);
    }

    if(SUCCEEDED(hr) && pvIdentifier && pvPtr2)
    {
        hr = UntrackLock(pvIdentifier, pvPtr2);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  TrackLock
 *
 *  Description:
 *      Tracks which regions of the buffer are locked.
 *
 *  Arguments:
 *      LPVOID [in]: instance identifier.
 *      LPVOID [in]: lock pointer.
 *      DWORD [in]: lock size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::TrackLock"

HRESULT CSysMemBuffer::TrackLock(LPVOID pvIdentifier, LPVOID pvLock, DWORD cbLock)
{
    HRESULT                 hr      = DS_OK;
    CNode<LOCKREGION> *     pNode;
    LOCKREGION              lr;

    DPF_ENTER();

    ASSERT(pvIdentifier);
    ASSERT(pvLock);
    ASSERT(cbLock);

    lr.pvIdentifier = pvIdentifier;
    lr.pvLock = pvLock;
    lr.cbLock = cbLock;

    // COMPATCOMPAT: Previous versions of DirectSound did not track who
    // had what region of a buffer locked.  This meant that different threads
    // could lock the same portion of the buffer.  In this version, we trap
    // this and return failure.

    // Make sure the region isn't already locked
    for(pNode = m_lstLocks.GetListHead(); pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
    {
        if(DoRegionsOverlap(&lr, &pNode->m_data))
        {
            RPF(DPFLVL_ERROR, "The specified region is already locked");
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Lock the region(s)
    if(SUCCEEDED(hr))
    {
        pNode = m_lstLocks.AddNodeToList(lr);
        hr = HRFROMP(pNode);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  UntrackLock
 *
 *  Description:
 *      Tracks which regions of the buffer are locked.
 *
 *  Arguments:
 *      LPVOID [in]: instance identifier.
 *      LPCVOID [in]: lock pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::UntrackLock"

HRESULT CSysMemBuffer::UntrackLock
(
    LPVOID                  pvIdentifier,
    LPCVOID                 pvLock
)
{
    HRESULT                 hr      = DSERR_INVALIDPARAM;
    CNode<LOCKREGION> *     pNode;
    CNode<LOCKREGION> *     pNext;

    DPF_ENTER();

    ASSERT(pvIdentifier);
    ASSERT(pvLock);

    // Find the lock in the list and remove it
    pNode = m_lstLocks.GetListHead();

    while(pNode)
    {
        pNext = pNode->m_pNext;

        if(pvIdentifier == pNode->m_data.pvIdentifier && pvLock == pNode->m_data.pvLock)
        {
            m_lstLocks.RemoveNodeFromList(pNode);
            hr = DS_OK;

            break;
        }

        pNode = pNext;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OverrideLocks
 *
 *  Description:
 *      Removes all locks.
 *
 *  Arguments:
 *      LPVOID [in]: lock owner identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::OverrideLocks"

void CSysMemBuffer::OverrideLocks(LPVOID pvIdentifier)
{
    CNode<LOCKREGION> *     pNode;
    CNode<LOCKREGION> *     pNext;

    DPF_ENTER();

    ASSERT(pvIdentifier);

    // Find all locks owned by the given identifier and remove them
    pNode = m_lstLocks.GetListHead();

    while(pNode)
    {
        pNext = pNode->m_pNext;
        if(pvIdentifier == pNode->m_data.pvIdentifier)
            m_lstLocks.RemoveNodeFromList(pNode);
        pNode = pNext;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  WriteSilence
 *
 *  Description:
 *      [MISSING]
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::WriteSilence"

void CSysMemBuffer::WriteSilence(WORD wBits, DWORD dwStartPos, DWORD dwEndPos)
{
    DPF_ENTER();

    if (dwEndPos > dwStartPos)
    {
        ::FillSilence(GetWriteBuffer() + dwStartPos, dwEndPos - dwStartPos, wBits);
    }
    else // The wraparound case
    {
        ::FillSilence(GetWriteBuffer() + dwStartPos, GetSize() - dwStartPos, wBits);
        ::FillSilence(GetWriteBuffer(), dwEndPos, wBits);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  AllocateFxBuffer
 *
 *  Description:
 *      Allocate the mirror buffer used for effects processing.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::AllocateFxBuffer"

HRESULT CSysMemBuffer::AllocateFxBuffer(void)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_pbPreFxBuffer == NULL)
    {
        hr = MEMALLOC_A_HR(m_pbPreFxBuffer, BYTE, m_cbAudioBuffers + m_cbExtra);

        if (SUCCEEDED(hr))
        {
            m_pbPreFxBuffer += m_cbExtra;

            // This is now our write buffer; copy current audio data into it
            CopyMemory(m_pbPreFxBuffer, m_pbPostFxBuffer, m_cbAudioBuffers);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FreeFxBuffer
 *
 *  Description:
 *      Free the mirror buffer used for effects processing.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSysMemBuffer::FreeFxBuffer"

void CSysMemBuffer::FreeFxBuffer(void)
{
    DPF_ENTER();

    if (m_pbPreFxBuffer != NULL)
    {
        // Preserve the audio data from m_pbPreFxBuffer before freeing it
        CopyMemory(m_pbPostFxBuffer, m_pbPreFxBuffer, m_cbAudioBuffers);

        m_pbPreFxBuffer -= m_cbExtra;
        MEMFREE(m_pbPreFxBuffer);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCaptureDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      VADDEVICETYPE [in]: device type.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureDevice::CCaptureDevice"

CCaptureDevice::CCaptureDevice(VADDEVICETYPE vdtDeviceType)
    : CDevice(vdtDeviceType)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CCaptureDevice);

    ASSERT(IS_CAPTURE_VAD(vdtDeviceType));

    // Initialize defaults
    m_fAcquiredVolCtrl = FALSE;
    m_dwRangeMin = 0;
    m_dwRangeSize = 0xFFFF;
    m_pmxMuxFlags = NULL;
    m_pfMicValue = NULL;
    ZeroMemory(&m_mxcdMasterVol,  sizeof m_mxcdMasterVol);
    ZeroMemory(&m_mxcdMasterMute, sizeof m_mxcdMasterMute);
    ZeroMemory(&m_mxcdMasterMux,  sizeof m_mxcdMasterMux);
    ZeroMemory(&m_mxcdMicVol,     sizeof m_mxcdMicVol);
    ZeroMemory(&m_mxcdMicMute,    sizeof m_mxcdMicMute);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CCaptureDevice
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureDevice::~CCaptureDevice"

CCaptureDevice::~CCaptureDevice(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CCaptureDevice);

    if (m_hMixer)
    {
        MMRESULT mmr = mixerClose(m_hMixer);
        ASSERT(MMSYSERR_NOERROR == mmr);
        // Note: this assert *will* fire if the app didn't release its capture object
        // and we're releasing it in FreeOrphanedObjects.  It's harmless in this case,
        // since the app is going away and its WinMM handles will be freed anyway.
    }

    MEMFREE(m_pmxMuxFlags);
    ASSERT(!m_lstBuffers.GetNodeCount());

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureDevice::Initialize"

HRESULT CCaptureDevice::Initialize(CDeviceDescription *pDesc)
{
    HRESULT hr;
    DPF_ENTER();

    // Initialize the base class
    hr = CDevice::Initialize(pDesc);

    if (SUCCEEDED(hr))
    {
        AcquireVolCtrl();
        // We can ignore the result code, because if AcquireVolCtrl()
        // fails HasVolCtrl() will always return DSERR_CONTROLUNAVAIL
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  AcquireVolCtrl
 *
 *  Description:
 *      This function puts the mixer API through contortions in an effort
 *      to figure out the "mixer lines" required to control the recording
 *      level on the microphone line, if present.
 *
 *      The mixer API's view of a card's audio lines and controls depends
 *      on the capabilities of the card itself.  (Even with WDM drivers;
 *      wdmaud.sys implements the mixer API for them by mapping the WDM
 *      driver's topology to a corresponding mixer-line topology.)
 *
 *      Here are the assumptions we make about this mixer topology:
 *
 *      * There is a line of type MIXERLINE_COMPONENTTYPE_DST_WAVEIN which
 *        represents "the final source for the waveform-audio input (ADC)".
 *        We'll refer to this as the "master line".
 *
 *      * There is at least one source line connected to the master line
 *        of type MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE.  We'll use the
 *        first one found, and refer to is as the "mic line".
 *
 *      * The master line may have a MIXERCONTROL_CONTROLTYPE_MUX control
 *        which selects from the recording sources connected to it.
 *
 *      * Either of the two lines may have a MIXERCONTROL_CONTROLTYPE_MUTE
 *        control.
 *
 *      * At least one of the lines has a MIXERCONTROL_CONTROLTYPE_VOLUME
 *        control.
 *
 *      If all of these assumptions are met, we return DS_OK and save all
 *      the information required to control the recording level(s) later.
 *      As far as I know, all WDM drivers meet these requirements, and so
 *      do most "legacy" drivers - except perhaps some that fail to use
 *      MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE to identify the mic line.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureDevice::AcquireVolCtrl"

HRESULT CCaptureDevice::AcquireVolCtrl(void)
{
    DPF_ENTER();

    // Set up the master waveIn destination mixer line
    MIXERLINE mxMastLine;
    ZeroMemory(&mxMastLine, sizeof mxMastLine);
    mxMastLine.cbStruct = sizeof mxMastLine;
    mxMastLine.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

    // Set up the microphone source line
    MIXERLINE mxMicLine;
    ZeroMemory(&mxMicLine, sizeof mxMicLine);

    // Set up the mixer-line control structure
    MIXERCONTROL mxCtrl;
    ZeroMemory(&mxCtrl, sizeof mxCtrl);
    mxCtrl.cbStruct = sizeof mxCtrl;

    // Set up the 1-element array of controls
    MIXERLINECONTROLS mxLineCtrls;
    ZeroMemory(&mxLineCtrls, sizeof mxLineCtrls);
    mxLineCtrls.cbStruct = sizeof mxLineCtrls;
    mxLineCtrls.cControls = 1;
    mxLineCtrls.cbmxctrl = sizeof mxCtrl;
    mxLineCtrls.pamxctrl = &mxCtrl;

    // Set up the control details structures
    m_mxcdMasterVol.cbDetails = sizeof m_mxVolume;
    m_mxcdMasterVol.paDetails = &m_mxVolume;
    m_mxcdMasterVol.cChannels = 1;
    m_mxcdMasterMute.cbDetails = sizeof m_mxMute;
    m_mxcdMasterMute.paDetails = &m_mxMute;
    m_mxcdMasterMute.cChannels = 1;
    m_mxcdMicVol.cbDetails = sizeof m_mxVolume;
    m_mxcdMicVol.paDetails = &m_mxVolume;
    m_mxcdMicVol.cChannels = 1;
    m_mxcdMicMute.cbDetails = sizeof m_mxMute;
    m_mxcdMicMute.paDetails = &m_mxMute;
    m_mxcdMicMute.cChannels = 1;

    // Open the mixer device corresponding to the waveIn device ID
    MMRESULT mmr = mixerOpen(&m_hMixer, m_pDeviceDescription->m_uWaveDeviceId, 0, 0, MIXER_OBJECTF_WAVEIN);
    if (mmr != MMSYSERR_NOERROR)
    {
        m_hMixer = NULL;
        m_fAcquiredVolCtrl = FALSE;
    }
    else  // Success
    {
        // Find the master recording destination line
        mmr = mixerGetLineInfo((HMIXEROBJ)m_hMixer, &mxMastLine, MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_COMPONENTTYPE);
        if (mmr == MMSYSERR_NOERROR)
        {
            DPF_MIXER(DPFLVL_INFO, "Found the master recording mixer line");
            // Look for a volume fader control on the master line
            mxLineCtrls.dwLineID = mxMastLine.dwLineID;
            mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
            mmr = mixerGetLineControls((HMIXEROBJ)m_hMixer, &mxLineCtrls, MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE);
            if (mmr == MMSYSERR_NOERROR)
            {
                // Found it - use the cbStruct field to flag success
                DPF_MIXER(DPFLVL_INFO, "Found a volume fader on the master line");
                m_mxcdMasterVol.cbStruct = sizeof m_mxcdMasterVol;
                m_mxcdMasterVol.dwControlID = mxCtrl.dwControlID;
                m_dwRangeMin = mxCtrl.Bounds.dwMinimum;
                m_dwRangeSize = mxCtrl.Bounds.dwMaximum - mxCtrl.Bounds.dwMinimum;
                mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &m_mxcdMasterVol, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
            }
            if (mmr != MMSYSERR_NOERROR)
                m_mxcdMasterVol.cbStruct = 0;

            // Look for a mute control on the master line
            mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
            mmr = mixerGetLineControls((HMIXEROBJ)m_hMixer, &mxLineCtrls, MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE);
            if (mmr == MMSYSERR_NOERROR)
            {
                DPF_MIXER(DPFLVL_INFO, "Found a mute control on the master line");
                m_mxcdMasterMute.cbStruct = sizeof m_mxcdMasterMute;
                m_mxcdMasterMute.dwControlID = mxCtrl.dwControlID;
                mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &m_mxcdMasterMute, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
            }
            if (mmr != MMSYSERR_NOERROR)
                m_mxcdMasterMute.cbStruct = 0;

            // Look for the microphone source line
            mxMicLine.cbStruct = sizeof mxMicLine;
            mxMicLine.dwDestination = mxMastLine.dwDestination;
            for (UINT i=0; i < mxMastLine.cConnections; ++i)
            {
                mxMicLine.dwSource = i;
                mmr = mixerGetLineInfo((HMIXEROBJ)m_hMixer, &mxMicLine, MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_SOURCE);
                if (mmr != MMSYSERR_NOERROR || mxMicLine.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE)
                    break;
            }
            if (mxMicLine.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE)
            {
                DPF_MIXER(DPFLVL_INFO, "Found a microphone mixer line");
                // Look for a volume fader control on the mic line
                mxLineCtrls.dwLineID = mxMicLine.dwLineID;
                mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
                mmr = mixerGetLineControls((HMIXEROBJ)m_hMixer, &mxLineCtrls, MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE);
                if (mmr == MMSYSERR_NOERROR)
                {
                    DPF_MIXER(DPFLVL_INFO, "Found a volume fader on the mic line");
                    m_mxcdMicVol.cbStruct = sizeof m_mxcdMicVol;
                    m_mxcdMicVol.dwControlID = mxCtrl.dwControlID;
                    m_dwRangeMin = mxCtrl.Bounds.dwMinimum;
                    m_dwRangeSize = mxCtrl.Bounds.dwMaximum - mxCtrl.Bounds.dwMinimum;
                    mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &m_mxcdMicVol, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
                }
                if (mmr != MMSYSERR_NOERROR)
                    m_mxcdMicVol.cbStruct = 0;

                // Look for a mute control on the mic line
                mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
                mmr = mixerGetLineControls((HMIXEROBJ)m_hMixer, &mxLineCtrls, MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE);
                if (mmr == MMSYSERR_NOERROR)
                {
                    DPF_MIXER(DPFLVL_INFO, "Found a mute control on the mic line");
                    m_mxcdMicMute.cbStruct = sizeof m_mxcdMicMute;
                    m_mxcdMicMute.dwControlID = mxCtrl.dwControlID;
                    mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &m_mxcdMicMute, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
                }
                if (mmr != MMSYSERR_NOERROR)
                    m_mxcdMicMute.cbStruct = 0;

                // Look for a MUX or MIXER control on the master line
                mxLineCtrls.dwLineID = mxMastLine.dwLineID;
                mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUX;
                m_fMasterMuxIsMux = TRUE;
                mmr = mixerGetLineControls((HMIXEROBJ)m_hMixer, &mxLineCtrls, MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE);
                if (mmr != MMSYSERR_NOERROR)
                {
                    mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MIXER;
                    m_fMasterMuxIsMux = FALSE;
                    mmr = mixerGetLineControls((HMIXEROBJ)m_hMixer, &mxLineCtrls, MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE);
                }
                if (mmr == MMSYSERR_NOERROR)
                {
                    DPF_MIXER(DPFLVL_INFO, "Found an item list control on the master line");
                    m_mxcdMasterMux.cbStruct = sizeof m_mxcdMasterMux;
                    m_mxcdMasterMux.dwControlID = mxCtrl.dwControlID;
                    m_mxcdMasterMux.cMultipleItems = mxCtrl.cMultipleItems;

                    // We save the cChannels value, because some evil VxD drivers (read: Aureal
                    // Vortex) will set it to 0 in the call to mixerGetControlDetails() below
                    int nChannels = (mxCtrl.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) ? 1 : mxMastLine.cChannels;
                    m_mxcdMasterMux.cChannels = nChannels;

                    // Get the MUX or MIXER list items
                    m_mxcdMasterMux.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
                    MIXERCONTROLDETAILS_LISTTEXT *pList = (PMIXERCONTROLDETAILS_LISTTEXT) MEMALLOC_A(BYTE, m_mxcdMasterMux.cbDetails * m_mxcdMasterMux.cChannels * mxCtrl.cMultipleItems);
                    if (pList != NULL)
                    {
                        m_mxcdMasterMux.paDetails = pList;
                        mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &m_mxcdMasterMux, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_LISTTEXT);
                        if (mmr == MMSYSERR_NOERROR)
                        {
                            DPF_MIXER(DPFLVL_INFO, "Got the list controls's LISTTEXT details");
                            // Get the MUX or MIXER list values
                            m_mxcdMasterMux.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
                            m_mxcdMasterMux.cChannels = nChannels;
                            m_pmxMuxFlags = (PMIXERCONTROLDETAILS_BOOLEAN) MEMALLOC_A(BYTE, m_mxcdMasterMux.cbDetails * m_mxcdMasterMux.cChannels * mxCtrl.cMultipleItems);
                            if (m_pmxMuxFlags != NULL)
                            {
                                m_mxcdMasterMux.paDetails = m_pmxMuxFlags;
                                mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &m_mxcdMasterMux, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
                                if (mmr == MMSYSERR_NOERROR)  // Enable the item corresponding to the mic line
                                {
                                    DPF_MIXER(DPFLVL_INFO, "Got the list controls's VALUE details");
                                    for (UINT i=0; i < mxCtrl.cMultipleItems; ++i)
                                    {
                                        if (pList[i].dwParam1 == mxMicLine.dwLineID)
                                            m_pfMicValue = &m_pmxMuxFlags[i].fValue;
                                        else if (mxLineCtrls.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX)
                                            m_pmxMuxFlags[i].fValue = FALSE;
                                        DPF_MIXER(DPFLVL_INFO, "Set list item %d to %d", i, pList[i].dwParam1 == mxMicLine.dwLineID);
                                    }
                                }
                            }
                        }
                        MEMFREE(pList);
                    }
                    if (!m_pmxMuxFlags || !m_pfMicValue || mmr != MMSYSERR_NOERROR)
                        m_mxcdMasterMux.cbStruct = 0;
                }
            }
        }

        // To be able to control the recording level, we minimally require
        // a volume fader on the master line or one on the microphone line:
        m_fAcquiredVolCtrl = m_mxcdMasterVol.cbStruct || m_mxcdMicVol.cbStruct;

        // Close mixer handle if we haven't found it useful
        if (!m_fAcquiredVolCtrl)
        {
            mmr = mixerClose(m_hMixer);
            ASSERT(MMSYSERR_NOERROR == mmr);
            m_hMixer = NULL;
        }
    }

    HRESULT hr = m_fAcquiredVolCtrl ? DS_OK : DSERR_CONTROLUNAVAIL;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the master recording level for this capture device.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureDevice::SetVolume"

HRESULT CCaptureDevice::SetVolume(LONG lVolume)
{
    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code
    DPF_ENTER();

    // Set the master recording level control if available
    if (m_mxcdMasterVol.cbStruct)
    {
        // Convert the DSBVOLUME level to an amplification factor from 0 to 0xFFFF
        m_mxVolume.dwValue = DBToAmpFactor(lVolume);

        // Adjust range if necessary
        if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
            m_mxVolume.dwValue = DWORD(m_dwRangeMin + m_dwRangeSize*double(m_mxVolume.dwValue)/0xFFFF);

        mmr = mixerSetControlDetails(HMIXEROBJ(m_hMixer), &m_mxcdMasterVol, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Gets the master recording level for this capture device.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureDevice::GetVolume"

HRESULT CCaptureDevice::GetVolume(LPLONG plVolume)
{
    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code
    DPF_ENTER();

    ASSERT(plVolume != NULL);

    // Get the master recording level if available
    if (m_mxcdMasterVol.cbStruct != 0)
    {
        mmr = mixerGetControlDetails(HMIXEROBJ(m_hMixer), &m_mxcdMasterVol, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
        if (mmr == MMSYSERR_NOERROR)
        {
            ASSERT(m_mxVolume.dwValue >= m_dwRangeMin && m_mxVolume.dwValue <= m_dwRangeMin + m_dwRangeSize);

            // Adjust range if necessary
            if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
                m_mxVolume.dwValue = DWORD(double(m_mxVolume.dwValue-m_dwRangeMin) / m_dwRangeSize * 0xFFFF);

            // Convert the amplification factor to a DSBVOLUME level
            *plVolume = AmpFactorToDB(m_mxVolume.dwValue);
        }
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetMicVolume
 *
 *  Description:
 *      Sets the microphone recording level for this capture device.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureDevice::SetMicVolume"

HRESULT CCaptureDevice::SetMicVolume(LONG lVolume)
{
    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code
    DPF_ENTER();

    // Set the microphone recording level control if available
    if (m_mxcdMicVol.cbStruct)
    {
        // Convert the DSBVOLUME level to an amplification factor from 0 to 0xFFFF
        m_mxVolume.dwValue = DBToAmpFactor(lVolume);

        // Adjust range if necessary
        if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
            m_mxVolume.dwValue = DWORD(m_dwRangeMin + m_dwRangeSize*double(m_mxVolume.dwValue)/0xFFFF);

        mmr = mixerSetControlDetails(HMIXEROBJ(m_hMixer), &m_mxcdMicVol, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetMicVolume
 *
 *  Description:
 *      Gets the microphone recording level for this capture device.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureDevice::GetMicVolume"

HRESULT CCaptureDevice::GetMicVolume(LPLONG plVolume)
{
    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code
    DPF_ENTER();

    ASSERT(plVolume != NULL);

    // Get the microphone recording level if available
    if (m_mxcdMicVol.cbStruct != 0)
    {
        mmr = mixerGetControlDetails(HMIXEROBJ(m_hMixer), &m_mxcdMicVol, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
        if (mmr == MMSYSERR_NOERROR)
        {
            ASSERT(m_mxVolume.dwValue >= m_dwRangeMin && m_mxVolume.dwValue <= m_dwRangeMin + m_dwRangeSize);

            // Adjust range if necessary
            if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
                m_mxVolume.dwValue = DWORD(double(m_mxVolume.dwValue-m_dwRangeMin) / m_dwRangeSize * 0xFFFF);

            // Convert the amplification factor to a DSBVOLUME level
            *plVolume = AmpFactorToDB(m_mxVolume.dwValue);
        }
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnableMic
 *
 *  Description:
 *      Enables/disables the microphone line on this capture device.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable the microphone, FALSE to disable it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureDevice::EnableMic"

HRESULT CCaptureDevice::EnableMic(BOOL fEnable)
{
    HMIXEROBJ hMixObj = HMIXEROBJ(m_hMixer);
    MMRESULT mmr = MMSYSERR_NOERROR;
    HRESULT hr;
    DPF_ENTER();

    // Check for presence of microphone controls
    if (!m_mxcdMasterMux.cbStruct && !m_mxcdMasterMute.cbStruct && !m_mxcdMicMute.cbStruct)
    {
        // We cannot do anything to enable the microphone line
        hr = DSERR_UNSUPPORTED;
    }
    else
    {
        // Select the microphone on the Mux control, if available
        if (m_mxcdMasterMux.cbStruct && !(m_fMasterMuxIsMux && !fEnable))
        {
            *m_pfMicValue = fEnable;
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMasterMux, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
        }

        // Mute/unmute the lines, if mute controls are available
        m_mxMute.fValue = !fEnable;
        if (m_mxcdMasterMute.cbStruct && mmr == MMSYSERR_NOERROR)
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMasterMute, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);
        if (m_mxcdMicMute.cbStruct && mmr == MMSYSERR_NOERROR)
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMicMute, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);

        MIXERCONTROLDETAILS_UNSIGNED mxOldVol = m_mxVolume;

        if (!fEnable)
            m_mxVolume.dwValue = 0;

        if (m_mxcdMasterVol.cbStruct && mmr == MMSYSERR_NOERROR)
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMasterVol, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);

        if (m_mxcdMicVol.cbStruct && mmr == MMSYSERR_NOERROR)
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMicVol, MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE);

        m_mxVolume = mxOldVol;
        hr = MMRESULTtoHRESULT(mmr);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CCaptureWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CCaptureDevice* [in]: parent device.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureWaveBuffer::CCaptureWaveBuffer"

CCaptureWaveBuffer::CCaptureWaveBuffer(CCaptureDevice *pDevice)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CCaptureWaveBuffer);

    // Initialize defaults
    m_pDevice = pDevice;
    m_pSysMemBuffer = NULL;
    m_dwFlags = 0;
    m_hEventFocus = NULL;
    m_fYieldedFocus = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CCaptureWaveBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureWaveBuffer::~CCaptureWaveBuffer"

CCaptureWaveBuffer::~CCaptureWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CCaptureWaveBuffer);

    // Remove this object from the parent's list
    m_pDevice->m_lstBuffers.RemoveDataFromList(this);

    // Free the system memory buffer
    RELEASE(m_pSysMemBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in] : size of buffer in bytes
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureWaveBuffer::Initialize"

HRESULT CCaptureWaveBuffer::Initialize(DWORD dwBufferBytes)
{
    DPF_ENTER();

    // Add this object to the parent's list
    HRESULT hr = HRFROMP(m_pDevice->m_lstBuffers.AddNodeToList(this));

    // Allocate the system memory buffer
    if(SUCCEEDED(hr))
    {
        m_pSysMemBuffer = NEW(CSysMemBuffer);
        hr = HRFROMP(m_pSysMemBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pSysMemBuffer->Initialize(dwBufferBytes);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks a region of the buffer memory to allow for reading.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the above pointer.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the above pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureWaveBuffer::Lock"

HRESULT CCaptureWaveBuffer::Lock(DWORD ibLock, DWORD cbLock,
                                 LPVOID *ppv1, LPDWORD pcb1,
                                 LPVOID *ppv2, LPDWORD pcb2)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pSysMemBuffer->LockRegion(this, ibLock, cbLock, ppv1, pcb1, ppv2, pcb2);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks a region of the buffer.
 *
 *  Arguments:
 *      LPCVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPCVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureWaveBuffer::Unlock"

HRESULT CCaptureWaveBuffer::Unlock(LPCVOID pv1, DWORD cb1,
                                   LPCVOID pv2, DWORD cb2)
{
    DPF_ENTER();

    HRESULT hr = m_pSysMemBuffer->UnlockRegion(this, pv1, cb1, pv2, cb2);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vector.c ===
//--------------------------------------------------------------------------;
//
//  File: vector.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//	All the vector goop
//
//  History:
//	02/07/96    DannyMi started it off
//	02/13/96    DannyMi it actually works
//
//--------------------------------------------------------------------------;

#include <math.h>
#include "dsoundi.h"

#undef DPF
#define DPF

// table lookup for sin to 1 degree accuracy
//
static FLOAT QSIN1[91] = {
0.000000f, 0.017452f, 0.034899f, 0.052336f, 0.069756f, 0.087156f, 0.104528f,
0.121869f, 0.139173f, 0.156434f, 0.173648f, 0.190809f, 0.207912f, 0.224951f,
0.241922f, 0.258819f, 0.275637f, 0.292372f, 0.309017f, 0.325568f, 0.342020f,
0.358368f, 0.374607f, 0.390731f, 0.406737f, 0.422618f, 0.438371f, 0.453990f,
0.469472f, 0.484810f, 0.500000f, 0.515038f, 0.529919f, 0.544639f, 0.559193f,
0.573576f, 0.587785f, 0.601815f, 0.615661f, 0.629320f, 0.642788f, 0.656059f,
0.669131f, 0.681998f, 0.694658f, 0.707107f, 0.719340f, 0.731354f, 0.743145f,
0.754710f, 0.766044f, 0.777146f, 0.788011f, 0.798636f, 0.809017f, 0.819152f,
0.829038f, 0.838671f, 0.848048f, 0.857167f, 0.866025f, 0.874620f, 0.882948f,
0.891007f, 0.898794f, 0.906308f, 0.913545f, 0.920505f, 0.927184f, 0.933580f,
0.939693f, 0.945519f, 0.951057f, 0.956305f, 0.961262f, 0.965926f, 0.970296f,
0.974370f, 0.978148f, 0.981627f, 0.984808f, 0.987688f, 0.990268f, 0.992546f,
0.994522f, 0.996195f, 0.997564f, 0.998630f, 0.999391f, 0.999848f, 1.f };

// table lookup for inverse sin from 0 to .9 in .01 steps
//
static FLOAT QASIN1[91] = {
0.000000f, 0.010000f, 0.020001f, 0.030005f, 0.040011f, 0.050021f, 0.060036f,
0.070057f, 0.080086f, 0.090122f, 0.100167f, 0.110223f, 0.120290f, 0.130369f,
0.140461f, 0.150568f, 0.160691f, 0.170830f, 0.180986f, 0.191162f, 0.201358f,
0.211575f, 0.221814f, 0.232078f, 0.242366f, 0.252680f, 0.263022f, 0.273393f,
0.283794f, 0.294227f, 0.304693f, 0.315193f, 0.325729f, 0.336304f, 0.346917f,
0.357571f, 0.368268f, 0.379009f, 0.389796f, 0.400632f, 0.411517f, 0.422454f,
0.433445f, 0.444493f, 0.455599f, 0.466765f, 0.477995f, 0.489291f, 0.500655f,
0.512090f, 0.523599f, 0.535185f, 0.546851f, 0.558601f, 0.570437f, 0.582364f,
0.594386f, 0.606506f, 0.618729f, 0.631059f, 0.643501f, 0.656061f, 0.668743f,
0.681553f, 0.694498f, 0.707584f, 0.720819f, 0.734209f, 0.747763f, 0.761489f,
0.775397f, 0.789498f, 0.803802f, 0.818322f, 0.833070f, 0.848062f, 0.863313f,
0.878841f, 0.894666f, 0.910809f, 0.927295f, 0.944152f, 0.961411f, 0.979108f,
0.997283f, 1.015985f, 1.035270f, 1.055202f, 1.075862f, 1.097345f, 1.119770f };

// table lookup for inverse sin from .9 to 1 in .001 steps
//
static FLOAT QASIN2[101] = {
1.119770f, 1.122069f, 1.124380f, 1.126702f, 1.129035f, 1.131380f, 1.133736f,
1.136105f, 1.138485f, 1.140878f, 1.143284f, 1.145702f, 1.148134f, 1.150578f,
1.153036f, 1.155508f, 1.157994f, 1.160493f, 1.163008f, 1.165537f, 1.168080f,
1.170640f, 1.173215f, 1.175805f, 1.178412f, 1.181036f, 1.183676f, 1.186333f,
1.189008f, 1.191701f, 1.194413f, 1.197143f, 1.199892f, 1.202661f, 1.205450f,
1.208259f, 1.211089f, 1.213941f, 1.216815f, 1.219711f, 1.222630f, 1.225573f,
1.228541f, 1.231533f, 1.234551f, 1.237595f, 1.240666f, 1.243765f, 1.246892f,
1.250049f, 1.253236f, 1.256454f, 1.259705f, 1.262988f, 1.266306f, 1.269660f,
1.273050f, 1.276478f, 1.279945f, 1.283452f, 1.287002f, 1.290596f, 1.294235f,
1.297921f, 1.301657f, 1.305443f, 1.309284f, 1.313180f, 1.317135f, 1.321151f,
1.325231f, 1.329379f, 1.333597f, 1.337891f, 1.342264f, 1.346721f, 1.351267f,
1.355907f, 1.360648f, 1.365497f, 1.370461f, 1.375550f, 1.380774f, 1.386143f,
1.391672f, 1.397374f, 1.403268f, 1.409376f, 1.415722f, 1.422336f, 1.429257f,
1.436531f, 1.444221f, 1.452406f, 1.461197f, 1.470755f, 1.481324f, 1.493317f,
1.507540f, 1.526071f, 1.570796f };

#if 0
// table lookup for inverse cos from 0 to .1 in .001 steps (not used)
//
static FLOAT QACOS1[101] = {
1.570796, 1.569796, 1.568796, 1.567796, 1.566796, 1.565796, 1.564796, 1.563796,
1.562796, 1.561796, 1.560796, 1.559796, 1.558796, 1.557796, 1.556796, 1.555796,
1.554796, 1.553796, 1.552795, 1.551795, 1.550795, 1.549795, 1.548795, 1.547794,
1.546794, 1.545794, 1.544793, 1.543793, 1.542793, 1.541792, 1.540792, 1.539791,
1.538791, 1.537790, 1.536790, 1.535789, 1.534789, 1.533788, 1.532787, 1.531786,
1.530786, 1.529785, 1.528784, 1.527783, 1.526782, 1.525781, 1.524780, 1.523779,
1.522778, 1.521777, 1.520775, 1.519774, 1.518773, 1.517771, 1.516770, 1.515769,
1.514767, 1.513765, 1.512764, 1.511762, 1.510760, 1.509758, 1.508757, 1.507755,
1.506753, 1.505750, 1.504748, 1.503746, 1.502744, 1.501741, 1.500739, 1.499737,
1.498734, 1.497731, 1.496729, 1.495726, 1.494723, 1.493720, 1.492717, 1.491714,
1.490711, 1.489707, 1.488704, 1.487701, 1.486697, 1.485694, 1.484690, 1.483686,
1.482682, 1.481678, 1.480674, 1.479670, 1.478666, 1.477662, 1.476657, 1.475653,
1.474648, 1.473644, 1.472639, 1.471634, 1.470629 };

// table lookup for inverse cos from .1 to 1 in .01 steps (not used)
//
static FLOAT QACOS2[91] = {
1.470629, 1.460573, 1.450506, 1.440427, 1.430335, 1.420228, 1.410106, 1.399967,
1.389810, 1.379634, 1.369438, 1.359221, 1.348982, 1.338719, 1.328430, 1.318116,
1.307774, 1.297403, 1.287002, 1.276569, 1.266104, 1.255603, 1.245067, 1.234493,
1.223879, 1.213225, 1.202528, 1.191787, 1.181000, 1.170165, 1.159279, 1.148342,
1.137351, 1.126304, 1.115198, 1.104031, 1.092801, 1.081506, 1.070142, 1.058707,
1.047198, 1.035612, 1.023945, 1.012196, 1.000359, 0.988432, 0.976411, 0.964290,
0.952068, 0.939737, 0.927295, 0.914736, 0.902054, 0.889243, 0.876298, 0.863212,
0.849978, 0.836588, 0.823034, 0.809307, 0.795399, 0.781298, 0.766994, 0.752474,
0.737726, 0.722734, 0.707483, 0.691955, 0.676131, 0.659987, 0.643501, 0.626644,
0.609385, 0.591689, 0.573513, 0.554811, 0.535527, 0.515594, 0.494934, 0.473451,
0.451027, 0.427512, 0.402716, 0.376383, 0.348166, 0.317560, 0.283794, 0.245566,
0.200335, 0.141539, 0 };
#endif


// Table lookup for sin to one degree accuracy.
//
FLOAT _inline QSIN(FLOAT a)
{
    while (a < 0)
	a += PI_TIMES_TWO;
    while (a > PI_TIMES_TWO)
	a -= PI_TIMES_TWO;

    if (a > THREE_PI_OVER_TWO)
        return -1 * QSIN1[(int)((PI_OVER_TWO - (a - THREE_PI_OVER_TWO)) *
								C180_OVER_PI)];
    else if (a > PI)
        return -1 * QSIN1[(int)((a - PI) * C180_OVER_PI)];
    else if (a > PI_OVER_TWO)
        return QSIN1[(int)((PI_OVER_TWO - (a - PI_OVER_TWO)) * C180_OVER_PI)];
    else
        return QSIN1[(int)(a * C180_OVER_PI)];
}


// Table lookup for cos to one degree accuracy.
//
FLOAT _inline QCOS(FLOAT a)
{
    while (a < 0)
	a += PI_TIMES_TWO;
    while (a > PI_TIMES_TWO)
	a -= PI_TIMES_TWO;

    if (a > THREE_PI_OVER_TWO)
        return QSIN1[90 -
		(int)((PI_OVER_TWO - (a - THREE_PI_OVER_TWO)) * C180_OVER_PI)];
    else if (a > PI)
        return -1 * QSIN1[90 - (int)((a - PI) * C180_OVER_PI)];
    else if (a > PI_OVER_TWO)
        return -1 * QSIN1[90 - (int)((PI_OVER_TWO - (a - PI_OVER_TWO)) *
								C180_OVER_PI)];
    else
        return QSIN1[90 - (int)(a * C180_OVER_PI)];
}


// Table lookup for inverse sin to one degree accuracy.
// This is trickier than sin because to do it with one table requires 6,600
// entries.  So we use one table for 0-.9, and another table for .9-1
//
FLOAT _inline QASIN(FLOAT a)
{
    FLOAT r;
    BOOL fNeg = a < 0;

    if (fNeg)
	a *= -1.f;
 
    if (a > 1.f)
	// well, at least we won't crash
	return PI_OVER_TWO;

    if (a < .9f)
	r = QASIN1[(int)((a + .005) * 100)];
    else
	r = QASIN2[(int)((a - .9 + .0005) * 1000)];

    return fNeg ? r * -1.f : r;
}


#if 0
// Table lookup for inverse cos to one degree accuracy.
// This is trickier than cos because to do it with one table requires 6,600
// entries.  So we use one table for 0-.1, and another table for .1-1
//
FLOAT _inline QACOS(FLOAT a)
{
    FLOAT r;
    BOOL fNeg = a < 0;

    if (fNeg)
	a *= -1.;
 
    if (a > 1)
	// well, at least we won't crash
	return 0;

    if (a < .1)
	r = QACOS1[(int)((a + .0005) * 1000)];
    else
	r = QACOS2[(int)((a - .1 + .005) * 100)];

    return fNeg ? (PI - r) : r;
}
#endif


BOOL IsEmptyVector(D3DVECTOR* lpv)
{
    return (lpv == NULL) || (lpv->x == 0 && lpv->y == 0 && lpv->z == 0);
}


BOOL IsEqualVector(D3DVECTOR* lpv1, D3DVECTOR* lpv2)
{
    if (lpv1 == NULL || lpv2 == NULL)
	return FALSE;

    return lpv1->x == lpv2->x && lpv1->y == lpv2->y &&
							lpv1->z == lpv2->z;
}

void CheckVector(D3DVECTOR* lpv) 
{
    double                      dMagnitude;
    double                      dTemp;
    double                      x;
    double                      y;
    double                      z;

    DPF_ENTER();

    x = lpv->x; 
    y = lpv->y; 
    z = lpv->z; 
   
    dTemp = x*x + y*y + z*z;
                 
    dMagnitude = sqrt(dTemp);

    if (dMagnitude > FLT_MAX) 
    {
        dTemp = 0.99*FLT_MAX / dMagnitude;
        lpv->x *= (FLOAT)dTemp;
        lpv->y *= (FLOAT)dTemp;
        lpv->z *= (FLOAT)dTemp;
    }

    DPF_LEAVE_VOID();
}

FLOAT MagnitudeVector(D3DVECTOR* lpv)
{
    double                      dMagnitude;
    double                      dTemp;
    double                      x;
    double                      y;
    double                      z;

    if (lpv == NULL)
	return 0.f;

    // !!! costly

    x = lpv->x; 
    y = lpv->y; 
    z = lpv->z; 
   
    dTemp = x*x + y*y + z*z;
                 
    dMagnitude = sqrt(dTemp);

    return (FLOAT)dMagnitude;
}


BOOL NormalizeVector(D3DVECTOR* lpv)
{
    FLOAT l;

    if (lpv == NULL)
	return FALSE;

    l = MagnitudeVector(lpv);
    if (l == 0)
	return FALSE;
    else {
        l = 1 / l;	// divide is slow
	lpv->x *= l;
	lpv->y *= l;
	lpv->z *= l;
    }
	
    return TRUE;
}


FLOAT DotProduct(D3DVECTOR* lpv1, D3DVECTOR* lpv2)
{
    if (lpv1 == NULL || lpv2 == NULL)
	return 0.f;

    return lpv1->x*lpv2->x + lpv1->y*lpv2->y + lpv1->z*lpv2->z;
}


BOOL CrossProduct(D3DVECTOR* lpvX, D3DVECTOR* lpv1, D3DVECTOR* lpv2)
{
    if (lpvX == NULL || lpv1 == NULL || lpv2 == NULL)
	return FALSE;

    lpvX->x = lpv1->y * lpv2->z - lpv1->z * lpv2->y;
    lpvX->y = lpv1->z * lpv2->x - lpv1->x * lpv2->z;
    lpvX->z = lpv1->x * lpv2->y - lpv1->y * lpv2->x;

    return !(lpvX->x == 0 && lpvX->y == 0 && lpvX->z == 0);
}


// This function will make Top orthogonal to Front, by taking an orthogonal
// vector to both, and taking an orthogonal vector to that new vector and
// front.  Then top will be normalized
//
BOOL MakeOrthogonal(D3DVECTOR* lpvFront, D3DVECTOR* lpvTop)
{
    D3DVECTOR vN;

    // !!! What if they are already orthogonal

    if (CrossProduct(&vN, lpvFront, lpvTop) == FALSE)
	return FALSE;

    // don't do this backwards, or top will end up flipped
    if (CrossProduct(lpvTop, &vN, lpvFront) == FALSE)
	return FALSE;

    // Stop co-efficients from going bezerk.  We need r eventually, anyway,
    // so we'll do it now and assume top is always normalized
    NormalizeVector(lpvTop);

    return TRUE;
}


// computes A + B
//
BOOL AddVector(D3DVECTOR* lpvResult, D3DVECTOR* lpvA, D3DVECTOR* lpvB)
{
    if (lpvResult == NULL || lpvA == NULL || lpvB == NULL)
	return FALSE;

    lpvResult->x = lpvA->x + lpvB->x;
    lpvResult->y = lpvA->y + lpvB->y;
    lpvResult->z = lpvA->z + lpvB->z;

    return TRUE;
}


// computes A - B
//
BOOL SubtractVector(D3DVECTOR* lpvResult, D3DVECTOR* lpvA, D3DVECTOR* lpvB)
{
    if (lpvResult == NULL || lpvA == NULL || lpvB == NULL)
	return FALSE;

    lpvResult->x = lpvA->x - lpvB->x;
    lpvResult->y = lpvA->y - lpvB->y;
    lpvResult->z = lpvA->z - lpvB->z;

    return TRUE;
}


// translate a vector to spherical co-ordinates:
// r = sqrt(x^2 + y^2 + z^2)
// theta = atan(y/x) (0 <= theta < 2*pi)
// phi = asin(z/r) (-pi/2 <= phi <= pi/2)
//
BOOL CartesianToSpherical
(
    FLOAT *pR, 
    FLOAT *pTHETA, 
    FLOAT *pPHI, 
    D3DVECTOR* lpv
)
{
    if (lpv == NULL)
	return FALSE;

    if (lpv->x == 0 && lpv->y == 0 && lpv->z == 0) {
	*pR = 0.f; *pTHETA = 0.f; *pPHI = 0.f;
	return TRUE;
    }

    // !!! costly
    *pR = MagnitudeVector(lpv);

    // FLOATing point quirk?
    if (*pR == 0) {
	*pR = 0.f; *pTHETA = 0.f; *pPHI = 0.f;
	return TRUE;
    }

    *pPHI = QASIN(lpv->z / *pR);

    if (lpv->x == 0) {
	*pTHETA = (lpv->y >= 0) ? PI_OVER_TWO : NEG_PI_OVER_TWO;
    } else {
	// !!! costly
        *pTHETA = (FLOAT)atan2(lpv->y, lpv->x);
    }
    if (*pTHETA < 0)
	*pTHETA += PI_TIMES_TWO;

    DPF(3, "Cartesian: %d.%d, %d.%d, %d.%d   becomes",
	(int)lpv->x, (int)((lpv->x * 100) - (int)lpv->x * 100),
	(int)lpv->y, (int)((lpv->y * 100) - (int)lpv->y * 100),
	(int)lpv->z, (int)((lpv->z * 100) - (int)lpv->z * 100));
    DPF(3, "Spherical:  r=%d.%d  theta=%d.%d  phi=%d.%d",
	(int)*pR, (int)((*pR * 100) - (int)*pR * 100),
	(int)*pTHETA, (int)((*pTHETA * 100) - (int)*pTHETA * 100),
	(int)*pPHI, (int)((*pPHI * 100) - (int)*pPHI * 100));

    return TRUE;
}

// translate a vector to spherical co-ordinates:
// r = sqrt(x^2 + y^2 + z^2)
// theta = atan(x/z) (0 <= theta < 2*pi)
// phi = asin(y/r) (-pi/2 <= phi <= pi/2)
//
BOOL CartesianToAzimuthElevation
(
    FLOAT *pR, 
    FLOAT *pAZIMUTH, 
    FLOAT *pELEVATION, 
    D3DVECTOR* lpv
)
{
    if (lpv == NULL)
	return FALSE;

    if (lpv->x == 0 && lpv->y == 0 && lpv->z == 0) {
	*pR = 0.f; *pAZIMUTH = 0.f; *pELEVATION = 0.f;
	return TRUE;
    }

    // !!! costly
    *pR = MagnitudeVector(lpv);

    // FLOATing point quirk?
    if (*pR == 0) {
	*pR = 0.f; *pAZIMUTH = 0.f; *pELEVATION = 0.f;
	return TRUE;
    }

    *pELEVATION = QASIN(lpv->y / *pR);

    if (lpv->z != 0) {
	// !!! costly
        *pAZIMUTH = (FLOAT)atan2(lpv->x, lpv->z);
    } else {
        if(lpv->x > 0.0f)
        {
            *pAZIMUTH = PI_OVER_TWO;
        }
        else if(lpv->x < 0.0f)
        {
            *pAZIMUTH = NEG_PI_OVER_TWO;
        }
        else
        {
            *pAZIMUTH = 0.0f;
        }

    }

//   if (*pAZIMUTH < 0)
//	*pAZIMUTH += PI_TIMES_TWO;

    DPF(3, "Cartesian: %d.%d, %d.%d, %d.%d   becomes",
	(int)lpv->x, (int)((lpv->x * 100) - (int)lpv->x * 100),
	(int)lpv->y, (int)((lpv->y * 100) - (int)lpv->y * 100),
	(int)lpv->z, (int)((lpv->z * 100) - (int)lpv->z * 100));
    DPF(3, "Spherical:  r=%d.%d  theta=%d.%d  phi=%d.%d",
	(int)*pR, (int)((*pR * 100) - (int)*pR * 100),
	(int)*pAZIMUTH, (int)((*pAZIMUTH * 100) - (int)*pAZIMUTH * 100),
	(int)*pELEVATION, (int)((*pELEVATION * 100) - (int)*pELEVATION * 100));

    return TRUE;
}


// rotate cartesian vector around z-axis by rot radians
//
void ZRotate(D3DVECTOR* lpvOut, D3DVECTOR* lpvIn, FLOAT rot)
{
    FLOAT sin_rot, cos_rot;

    sin_rot = QSIN(rot);
    cos_rot = QCOS(rot);

    lpvOut->x = lpvIn->x * cos_rot - lpvIn->y * sin_rot;
    lpvOut->y = lpvIn->x * sin_rot + lpvIn->y * cos_rot;
    lpvOut->z = lpvIn->z;

    DPF(3, "ZRotate %d.%d, %d.%d, %d.%d  by  %d.%d rad",
	(int)lpvIn->x, (int)((lpvIn->x * 100) - (int)lpvIn->x * 100),
	(int)lpvIn->y, (int)((lpvIn->y * 100) - (int)lpvIn->y * 100),
	(int)lpvIn->z, (int)((lpvIn->z * 100) - (int)lpvIn->z * 100),
	(int)rot, (int)((rot * 100) - (int)rot * 100));
    DPF(4, "becomes %d.%d, %d.%d, %d.%d",
	(int)lpvOut->x, (int)((lpvOut->x * 100) - (int)lpvOut->x * 100),
	(int)lpvOut->y, (int)((lpvOut->y * 100) - (int)lpvOut->y * 100),
	(int)lpvOut->z, (int)((lpvOut->z * 100) - (int)lpvOut->z * 100));
}


// rotate cartesian vector around x-axis by rot radians
//
void XRotate(D3DVECTOR* lpvOut, D3DVECTOR* lpvIn, FLOAT rot)
{
    FLOAT sin_rot, cos_rot;

    sin_rot = QSIN(rot);
    cos_rot = QCOS(rot);

    lpvOut->x = lpvIn->x;
    lpvOut->y = lpvIn->y * cos_rot - lpvIn->z * sin_rot;
    lpvOut->z = lpvIn->y * sin_rot + lpvIn->z * cos_rot;

    DPF(3, "XRotate %d.%d, %d.%d, %d.%d  by  %d.%d rad",
	(int)lpvIn->x, (int)((lpvIn->x * 100) - (int)lpvIn->x * 100),
	(int)lpvIn->y, (int)((lpvIn->y * 100) - (int)lpvIn->y * 100),
	(int)lpvIn->z, (int)((lpvIn->z * 100) - (int)lpvIn->z * 100),
	(int)rot, (int)((rot * 100) - (int)rot * 100));
    DPF(4, "becomes %d.%d, %d.%d, %d.%d",
	(int)lpvOut->x, (int)((lpvOut->x * 100) - (int)lpvOut->x * 100),
	(int)lpvOut->y, (int)((lpvOut->y * 100) - (int)lpvOut->y * 100),
	(int)lpvOut->z, (int)((lpvOut->z * 100) - (int)lpvOut->z * 100));
}


// rotate cartesian vector around y-axis by rot radians
//
void YRotate(D3DVECTOR* lpvOut, D3DVECTOR* lpvIn, FLOAT rot)
{
    FLOAT sin_rot, cos_rot;

    sin_rot = QSIN(rot);
    cos_rot = QCOS(rot);

    lpvOut->x = lpvIn->x * cos_rot + lpvIn->z * sin_rot;
    lpvOut->y = lpvIn->y;
    lpvOut->z = lpvIn->z * cos_rot - lpvIn->x * sin_rot;

    DPF(3, "YRotate %d.%d, %d.%d, %d.%d  by  %d.%d rad",
	(int)lpvIn->x, (int)((lpvIn->x * 100) - (int)lpvIn->x * 100),
	(int)lpvIn->y, (int)((lpvIn->y * 100) - (int)lpvIn->y * 100),
	(int)lpvIn->z, (int)((lpvIn->z * 100) - (int)lpvIn->z * 100),
	(int)rot, (int)((rot * 100) - (int)rot * 100));
    DPF(4, "becomes %d.%d, %d.%d, %d.%d",
	(int)lpvOut->x, (int)((lpvOut->x * 100) - (int)lpvOut->x * 100),
	(int)lpvOut->y, (int)((lpvOut->y * 100) - (int)lpvOut->y * 100),
	(int)lpvOut->z, (int)((lpvOut->z * 100) - (int)lpvOut->z * 100));
}


// given the head's front and top orientation vectors, calculate the angles
// of rotation that represents around the x, y and z axes.
// This is all relative to an orientation where you are looking along the
// + z-axis, the x-axis goes + to your right, and your head is going up
// the + y-axis (left-handed co-ordinate system)
// 
// We do this by basically undoing the orientation we are given, and turning
// it back into the identity orientation.  We start with figuring out the 
// z-rot that will stand the top vector upright (theta=PI/2).  This is done
// by taking the current top theta and subtracting PI/2, because a positive
// z-rotation is defined as increasing the value of theta, (eg. if the top's
// theta is currently PI, that represents a positive PI/2 z-rotation)
// That number represents how we rotate the identity orientation to get
// our given orientation, so we use the opposite rotation to undo that
// roatation and end up with new front and top vectors with the top vector
// standing upright (theta=PI/2)
// We don't have to rotate the TOP vector by the opposite rotation (only the
// front vector) because a z-rotation doesn't change the phi value of a vector,
// and that's the only thing we need to know next about the top vector, so
// why waste time rotating it?
// So, next, we want to fix the phi value of the top vector to point it
// straight up into the sky (not just with theta=PI/2).  This is an x-rotation.
// Since we know the top's theta is already PI/2 (from the last rotation),
// this tells us that the y-value of the top vector is positive, which means
// that phi values of the top vector get bigger as you apply a positive
// x-rotation.  So the x-rotation value is just the phi of the original top
// vector (still the same value since doing a z-rot didn't affect the phi).
// (eg. if phi =-PI/2, that means the identity top vector had a -PI/2
// x-rot applied to it to become like the given orientation.
// So now we rotate the top and front vectors by the opposite of this
// rotation to undo them and end up with top and front vectors where the top
// vector points straight up like the identity top vector, and only the
// front is not where it belongs. Only, again, we don't actually rotate 
// the top vector by the opposite, only the front vector, because we don't
// care about it anymore, we know it's going to end up pointing straight up
// (we designed it this way).  So the only thing left is to get the front
// vector pointing forward like it's supposed to, which requires a y-rot.
// The tricky part is that if x<0, increasing phi of the front vector is
// a positive y-rot, and if x>=0, increasing phi of the front vector is a
// negative y-rot
// Now, in general, if I apply an x-rot, a y-rot, and z-rot in that order
// to my listener's orientation, I need to apply the opposite z-rot,
// opposite y-rot, and opposite x-rot on the object in space to get the
// head relative position (do everything backwards).
// Well, since we did a z-rot, x-rot, and y-rot in that order to undo
// the orientation to make it the identity vector, that's the same as
// doing y, x, then z to the idenity vector to get the new orientation.
// So what I'm trying to say is, when it comes time to move the object
// in space, we'll do it by doing opposite-z, opposite-x, then opposite-y
// (in that order).
//
void GetRotations(FLOAT *pX, FLOAT *pY, FLOAT *pZ, D3DVECTOR* lpvFront, D3DVECTOR* lpvTop)
{
    FLOAT r, theta, phi;
    D3DVECTOR vFront1, vFront2;

    CartesianToSpherical(&r, &theta, &phi, lpvTop);

    // First, find what z-rotation would move the top vector from the identity
    // value of PI/2 to whatever it is now.
    // Bigger theta means positive z-rotation
    *pZ = theta - PI_OVER_TWO;

    // Now put the orientation vectors through the opposite rotation to
    // undo it and basically stand the top vector back up.  Don't bother
    // to "undo" the top vector, since we only care about the new phi, and
    // phi won't change by z-rotating it
    ZRotate(&vFront1, lpvFront, *pZ * -1);

    // Now find what x-rotation would move the top vector from sticking
    // straight up (phi=0) to whatever it was given
    // Bigger phi is in the direction of positive rotation for y>0 (which it is,
    // as constructed by our last rotation)
    *pX = phi;

    // Now put the orientation vectors through the opposite x-rotation to
    // undo it and basically stand the top vector straight up.  Don't bother
    // to "undo" the top vector, since we don't care about it anymore.  The
    // only thing left to do after this is fix the front vector.
    XRotate(&vFront2, &vFront1, *pX * -1);

    // Now find out what y-rot our front vector has been put through.
    // our identity orientation is front phi = pi/2 (left handed co-ord system)
    // I'm counting on top being normalized
    // phi is in the direction of negative rotation if x is positive, and
    // positive rotation if x is negative.
    if (vFront2.x >= 0)
        *pY = PI_OVER_TWO - QASIN(vFront2.z);
    else
        *pY = QASIN(vFront2.z) - PI_OVER_TWO;
}


// Given an object's position in 3D cartesian coordinates, and the listener's
// position, and rotation angles showing the orientation of the listener's
// head, calculate the vector describing the object's position relative to
// the listener.
// We are assuming that the head was rotating first in y, then x, then z,
// so to move the object, we will put it through the opposite z, then x,
// then y rotations.
// !!! Pass in sin and cos of each angle so it isn't recomputed each time? 
// (This is called with the same angles every time a position changes until
// the orientation changes)
//
BOOL GetHeadRelativeVector
(
    D3DVECTOR* lpvHRP, 
    D3DVECTOR* lpvObjectPos, 
    D3DVECTOR* lpvHeadPos, 
    FLOAT x, 
    FLOAT y, 
    FLOAT z
)
{
    D3DVECTOR vObj1, vObj2;

    if (lpvHRP == NULL || lpvObjectPos == NULL || lpvHeadPos == NULL)
	return FALSE;

    // get the head relative position assuming a listener looking forward
    // and standing right side up
    SubtractVector(lpvHRP, lpvObjectPos, lpvHeadPos);

    // The object occupies the same point as the listener.  We're done!
    if (lpvHRP->x == 0 && lpvHRP->y == 0 && lpvHRP->z == 0)
	return TRUE;

    // Head was rotated first in y, then x, then z.  So put the object through
    // the opposite rotations in the opposite order.
    ZRotate(&vObj1, lpvHRP, z * -1);
    XRotate(&vObj2, &vObj1, x * -1);
    YRotate(lpvHRP, &vObj2, y * -1);

    return TRUE;
}


// How much later, in seconds, will the sound reach the right ear than the left?
// Negative means it will reach the right ear first.
// Assumes the object position is head relative.
// 'scale' is how many metres per unit of the vector
//
BOOL GetTimeDelay(FLOAT *pdelay, D3DVECTOR* lpvPosition, FLOAT scale)
{
    FLOAT rL, rR;
    double x, y, z;
    double dTemp;
    double dTemp2;
    FLOAT fMagnitude;

    if (lpvPosition == NULL)
	return FALSE;

    fMagnitude = MagnitudeVector( lpvPosition );

    dTemp = (double)fMagnitude;
    dTemp *= (double)scale; 
    dTemp *= 1000.0;

    if ( dTemp < FLT_MAX ) 
    {
        dTemp2 = scale * 1000.0;
        // scale everything in millimetres
        x = (double)lpvPosition->x * dTemp2;
        y = (double)lpvPosition->y * dTemp2;
        z = (double)lpvPosition->z * dTemp2;
    }
    else
    {
        dTemp2 = FLT_MAX / dTemp;
        // scale everything in millimetres
        x = (double)lpvPosition->x * dTemp2;
        y = (double)lpvPosition->y * dTemp2;
        z = (double)lpvPosition->z * dTemp2;
    }

    // assume the listener's head is 12cm in diameter, with the left ear at 
    // x = -60mm and the right ear at x = 60mm
    // !!! costly
    rL = (FLOAT)sqrt((x + 60) * (x + 60) + y * y + z * z);
    rR = (FLOAT)sqrt((x - 60) * (x - 60) + y * y + z * z);
    *pdelay = (rR - rL) * (1 / SPEEDOFSOUND);
    
    DPF(3, "The time delay between ears is %dms", (int)(*pdelay * 1000));

    return TRUE;
}


// Get the relative velocity of two objects (positive meaning your moving
// towards each other).
// Basically, you want the component of the difference of the velocity
// vectors on the difference of the position vectors,
// or   |v| cos(theta)   which is just   (p . v) / |p|
// Positive means that the object is moving away from you
//
BOOL GetRelativeVelocity(
    FLOAT *lpVelRel, 
    D3DVECTOR* lpvObjPos, 
    D3DVECTOR* lpvObjVel, 
    D3DVECTOR* lpvHeadPos, 
    D3DVECTOR* lpvHeadVel)
{
    D3DVECTOR vPos, vVel;

    if (lpVelRel == NULL)
	return FALSE;

    SubtractVector(&vPos, lpvObjPos, lpvHeadPos);
    SubtractVector(&vVel, lpvObjVel, lpvHeadVel);
    if (IsEmptyVector(&vPos))
        *lpVelRel = 0.f;
    else
        *lpVelRel = DotProduct(&vPos, &vVel) / MagnitudeVector(&vPos);

    return TRUE;
}


// Get the Doppler shift.  We need the original frequency, and the relative
// velocity between you and the object (positive meaning that the object is
// moving away from you) and we'll give you the perceived frequency
// How, you ask?   f(perceived) = f(original) * v(sound) / (v(sound) + v(rel))
// The velocity vector should be in milliseconds per second.
BOOL GetDopplerShift(FLOAT *lpFreqDoppler, FLOAT FreqOrig, FLOAT VelRel)
{
    if (lpFreqDoppler == NULL)
	return FALSE;

    // !!! Don't ever let the frequency shift be by more than a factor of 2?
    if (VelRel > SPEEDOFSOUND / 2.f)
	VelRel = SPEEDOFSOUND / 2.f;
    if (VelRel < SPEEDOFSOUND / -2.f)
	VelRel = SPEEDOFSOUND / -2.f;

    *lpFreqDoppler = FreqOrig * SPEEDOFSOUND / (SPEEDOFSOUND + VelRel);

    DPF(3, "Doppler change %dHz by %dmm/sec to %dHz", (int)FreqOrig,
				(int)VelRel, (int)*lpFreqDoppler);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vector.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef __VECTOR_H__
#define __VECTOR_H__

#define PI 3.141592653589793238f
#define PI_TIMES_TWO 6.28318530718f
#define PI_OVER_TWO 1.570796326795f
#define THREE_PI_OVER_TWO 4.712388980385f
#define NEG_PI_OVER_TWO -1.570796326795f
#define C180_OVER_PI 57.29577951308f
#define PI_OVER_360 0.008726646259972f
#define TWO_OVER_PI 0.6366197723676f
#define SPEEDOFSOUND 359660.f	// mm/sec

#define SET_VECTOR(v, a, b, c)	(v).x = a, (v).y = b, (v).z = c
#define SET_EMPTY_VECTOR(v)     SET_VECTOR(v, 0.0f, 0.0f, 0.0f)
#define COPY_VECTOR(va, vb)     (va).x = (vb).x, (va).y = (vb).y, (va).z = (vb).z

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern void CheckVector(D3DVECTOR* lpv);
extern FLOAT MagnitudeVector(D3DVECTOR* lpv);
extern BOOL IsEmptyVector(D3DVECTOR* lpv);
extern BOOL IsEqualVector(D3DVECTOR* lpv1, D3DVECTOR* lpv2);
extern BOOL NormalizeVector(D3DVECTOR* lpv);
extern FLOAT DotProduct(D3DVECTOR* lpv1, D3DVECTOR* lpv2);
extern BOOL CrossProduct(D3DVECTOR* lpvX, D3DVECTOR* lpv1, D3DVECTOR* lpv2);
extern BOOL MakeOrthogonal(D3DVECTOR* lpvFront, D3DVECTOR* lpvTop);
extern BOOL AddVector(D3DVECTOR* lpvResult, D3DVECTOR* lpvA, D3DVECTOR* lpvB);
extern BOOL SubtractVector(D3DVECTOR* lpvResult, D3DVECTOR* lpvA, D3DVECTOR* lpvB);
extern BOOL CartesianToSpherical(FLOAT* pR, FLOAT* pTHETA, FLOAT* pPHI, D3DVECTOR* lpv);
extern BOOL CartesianToAzimuthElevation(FLOAT* pR, FLOAT* pAZIMUTH, FLOAT* pELEVATION, D3DVECTOR* lpv);
extern void GetRotations(FLOAT* pX, FLOAT* pY, FLOAT* pZ, D3DVECTOR* lpvHeadTop, D3DVECTOR* lpvHeadFront);
extern BOOL GetHeadRelativeVector(D3DVECTOR* lpvHRP, D3DVECTOR* lpvObjectPos, D3DVECTOR* lpvHeadPos, FLOAT x, FLOAT y, FLOAT z);
extern BOOL GetTimeDelay(FLOAT* pdelay, D3DVECTOR* lpvPosition, FLOAT scale);
extern BOOL GetRelativeVelocity(FLOAT* lpVelRel, D3DVECTOR* lpvObjPos, D3DVECTOR* lpvObjVel, D3DVECTOR* lpvHeadPos, D3DVECTOR* lpvHeadVel);
extern BOOL GetDopplerShift(FLOAT* lpFreqDoppler, FLOAT FreqOrig, FLOAT VelRel);

// from our special c-runtime code
extern double _stdcall pow2(double);
extern double _stdcall fylog2x(double, double);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __VECTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vad.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vad.h
 *  Content:    Virtual Audio Device base classes
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/1/97      dereks  Created
 * 4/20/99      duganp  Added registry-settable default S/W 3D algorithms
 * 8/24/99      duganp  Support for FX processing
 *
 ***************************************************************************/

#ifndef __VAD_H__
#define __VAD_H__


// Device types
typedef DWORD VADDEVICETYPE, *LPVADDEVICETYPE;

#define VAD_DEVICETYPE_EMULATEDRENDER   0x00000001
#define VAD_DEVICETYPE_VXDRENDER        0x00000002
#define VAD_DEVICETYPE_KSRENDER         0x00000004
#define VAD_DEVICETYPE_EMULATEDCAPTURE  0x00000008
#define VAD_DEVICETYPE_KSCAPTURE        0x00000010

#define VAD_DEVICETYPE_VALIDMASK        0x0000001F
#define VAD_DEVICETYPE_EMULATEDMASK     0x00000009
#define VAD_DEVICETYPE_VXDMASK          0x00000002
#define VAD_DEVICETYPE_KSMASK           0x00000014
#define VAD_DEVICETYPE_RENDERMASK       0x00000007
#define VAD_DEVICETYPE_CAPTUREMASK      0x00000018

#define VAD_DEVICETYPE_WAVEOUTOPENMASK  0x00000003

// Special type used by RemoveProhibitedDrivers()
#define VAD_DEVICETYPE_PROHIBITED       0x80000000

// Buffer states
#define VAD_BUFFERSTATE_STOPPED         0x00000000  // The buffer is stopped
#define VAD_BUFFERSTATE_STARTED         0x00000001  // The buffer is running
#define VAD_BUFFERSTATE_LOOPING         0x00000002  // The buffer is looping (but not necessarily started)
#define VAD_BUFFERSTATE_WHENIDLE        0x00000004  // The buffer is flagged as "play when idle" or "stop when idle"
#define VAD_BUFFERSTATE_INFOCUS         0x00000008  // The buffer has focus
#define VAD_BUFFERSTATE_OUTOFFOCUS      0x00000010  // The buffer does not have focus
#define VAD_BUFFERSTATE_LOSTCONSOLE     0x00000020  // Another TS session has acquired the console
#define VAD_BUFFERSTATE_SUSPEND         0x80000000  // The buffer is suspended, or resumed

#define VAD_FOCUSFLAGS      (VAD_BUFFERSTATE_OUTOFFOCUS | VAD_BUFFERSTATE_INFOCUS | VAD_BUFFERSTATE_LOSTCONSOLE)
#define VAD_SETSTATE_MASK   (VAD_FOCUSFLAGS | VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING)

// Helper macros

#define IS_VALID_VAD(vdt) \
            MAKEBOOL(((VADDEVICETYPE)(vdt)) & VAD_DEVICETYPE_VALIDMASK)

#define IS_EMULATED_VAD(vdt) \
            MAKEBOOL(((VADDEVICETYPE)(vdt)) & VAD_DEVICETYPE_EMULATEDMASK)

#define IS_VXD_VAD(vdt) \
            MAKEBOOL(((VADDEVICETYPE)(vdt)) & VAD_DEVICETYPE_VXDMASK)

#define IS_KS_VAD(vdt) \
            MAKEBOOL(((VADDEVICETYPE)(vdt)) & VAD_DEVICETYPE_KSMASK)

#define IS_RENDER_VAD(vdt) \
            MAKEBOOL(((VADDEVICETYPE)(vdt)) & VAD_DEVICETYPE_RENDERMASK)

#define IS_CAPTURE_VAD(vdt) \
            MAKEBOOL(((VADDEVICETYPE)(vdt)) & VAD_DEVICETYPE_CAPTUREMASK)

__inline BOOL IS_SINGLE_VAD(VADDEVICETYPE vdt)
{
    UINT                    i;

    for(i = 0; i < sizeof(VADDEVICETYPE) * 8; i++)
    {
        if(vdt & (1 << i))
        {
            if(vdt != (VADDEVICETYPE)(1 << i))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


#ifdef __cplusplus

// Device class GUIDs
DEFINE_GUID(VADDRVID_EmulatedRenderBase, 0xc2ad1800, 0xb243, 0x11ce, 0xa8, 0xa4, 0x00, 0xaa, 0x00, 0x6c, 0x45, 0x00);
DEFINE_GUID(VADDRVID_EmulatedCaptureBase, 0xbdf35a00, 0xb9ac, 0x11d0, 0xa6, 0x19, 0x00, 0xaa, 0x00, 0xa7, 0xc0, 0x00);
DEFINE_GUID(VADDRVID_VxdRenderBase, 0x3d0b92c0, 0xabfc, 0x11ce, 0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c);
DEFINE_GUID(VADDRVID_KsRenderBase, 0xbd6dd71a, 0x3deb, 0x11d1, 0xb1, 0x71, 0x0, 0xc0, 0x4f, 0xc2, 0x00, 0x00);
DEFINE_GUID(VADDRVID_KsCaptureBase, 0xbd6dd71b, 0x3deb, 0x11d1, 0xb1, 0x71, 0x0, 0xc0, 0x4f, 0xc2, 0x00, 0x00);

// Memory buffer lock region
typedef struct tagLOCKREGION
{
    LPCVOID             pvIdentifier;           // Lock owner identifier
    LPCVOID             pvLock;                 // Byte index of lock
    DWORD               cbLock;                 // Size of locked region
} LOCKREGION, *LPLOCKREGION;

// EnumDrivers flags
#define VAD_ENUMDRIVERS_ORDER                       0x00000001
#define VAD_ENUMDRIVERS_REMOVEPROHIBITEDDRIVERS     0x00000002
#define VAD_ENUMDRIVERS_REMOVEDUPLICATEWAVEDEVICES  0x00000004

// Flags for different types of default devices (new in DX7.1)
enum DEFAULT_DEVICE_TYPE
{
    MAIN_DEFAULT,
    VOICE_DEFAULT
};

// Render buffer description
typedef struct tagVADRBUFFERDESC
{
    DWORD               dwFlags;
    DWORD               dwBufferBytes;
    LPWAVEFORMATEX      pwfxFormat;
    GUID                guid3dAlgorithm;
} VADRBUFFERDESC, *LPVADRBUFFERDESC;

typedef const VADRBUFFERDESC *LPCVADRBUFFERDESC;

// Render buffer capabilities
typedef struct tagVADRBUFFERCAPS
{
    DWORD               dwFlags;
    DWORD               dwBufferBytes;
} VADRBUFFERCAPS, *LPVADRBUFFERCAPS;

typedef const VADRBUFFERCAPS *LPCVADRBUFFERCAPS;

// Forward declarations
class CDeviceDescription;
class CStaticDriver;
class CDevice;
class CRenderDevice;
class CPrimaryRenderWaveBuffer;
class CSecondaryRenderWaveBuffer;
class CRenderWaveStream;
class CCaptureDevice;
class CCaptureWaveBuffer;
class CPropertySet;
class CSysMemBuffer;
class CHwMemBuffer;
class C3dListener;
class C3dObject;
class CCaptureEffectChain;
class CDirectSoundSink;


// Virtual audio device manager
class CVirtualAudioDeviceManager : public CDsBasicRuntime
{
    friend class CDevice;

private:
    CList<CDevice *>            m_lstDevices;    // Open device list
    CObjectList<CStaticDriver>  m_lstDrivers;    // Static driver list
    VADDEVICETYPE               m_vdtDrivers;    // Types in the static driver list

#ifndef SHARED
    static const LPCTSTR        m_pszPnpMapping; // Name of PnP info file mapping object
#endif

public:
    CVirtualAudioDeviceManager(void);
    ~CVirtualAudioDeviceManager(void);

    // Device/driver management
    HRESULT EnumDevices(VADDEVICETYPE, CObjectList<CDevice> *);
    HRESULT EnumDrivers(VADDEVICETYPE, DWORD, CObjectList<CDeviceDescription> *);
    HRESULT GetDeviceDescription(GUID, CDeviceDescription **);
    HRESULT FindOpenDevice(VADDEVICETYPE, REFGUID, CDevice **);
    HRESULT OpenDevice(VADDEVICETYPE, REFGUID, CDevice **);
    static void GetDriverGuid(VADDEVICETYPE, BYTE, LPGUID);
    static void GetDriverDataFromGuid(VADDEVICETYPE, REFGUID, LPBYTE);
    static VADDEVICETYPE GetDriverDeviceType(REFGUID);
    HRESULT GetPreferredDeviceId(VADDEVICETYPE, LPGUID, DEFAULT_DEVICE_TYPE =MAIN_DEFAULT);
    HRESULT GetDeviceIdFromDefaultId(LPCGUID, LPGUID);
#ifdef WINNT
    VADDEVICETYPE GetAllowableDevices(VADDEVICETYPE, LPCTSTR);
#else // WINNT
    VADDEVICETYPE GetAllowableDevices(VADDEVICETYPE, DWORD);
#endif // WINNT
    HRESULT GetPreferredWaveDevice(BOOL, LPUINT, LPDWORD, DEFAULT_DEVICE_TYPE =MAIN_DEFAULT);

    // Static driver list
    HRESULT InitStaticDriverList(VADDEVICETYPE);
    void FreeStaticDriverList(void);
    HRESULT GetDriverCertificationStatus(CDevice *, LPDWORD);

#ifdef WINNT
    HRESULT OpenPersistentDataKey(VADDEVICETYPE, LPCTSTR, PHKEY);
#else // WINNT
    HRESULT OpenPersistentDataKey(VADDEVICETYPE, DWORD, PHKEY);
#endif // WINNT

private:
    void RemoveProhibitedDrivers(VADDEVICETYPE, CObjectList<CDeviceDescription> *);
    void RemoveDuplicateWaveDevices(CObjectList<CDeviceDescription> *);
    void SortDriverList(VADDEVICETYPE, CObjectList<CDeviceDescription> *);

#ifdef WINNT
    HRESULT OpenDevicePersistentDataKey(VADDEVICETYPE, LPCTSTR, PHKEY);
#else // WINNT
    HRESULT OpenDevicePersistentDataKey(VADDEVICETYPE, DWORD, PHKEY);
#endif // WINNT
    HRESULT OpenDefaultPersistentDataKey(PHKEY);
    INT SortDriverListCallback(const UINT *, CDeviceDescription *, CDeviceDescription *);
    HRESULT OpenSpecificDevice(CDeviceDescription *, CDevice **);

#ifndef SHARED
    void CheckMmPnpEvents(void);
#endif // SHARED

};


// The static driver object
class CStaticDriver : public CDsBasicRuntime
{
    friend class CVirtualAudioDeviceManager;

protected:
    CDeviceDescription *    m_pDeviceDescription;   // Device description
    HKEY                    m_hkeyRoot;             // Root device registry key
    DWORD                   m_dwKeyOwnerProcessId;  // Process that opened the device registry key
    DWORD                   m_dwCertification;      // Certification status

public:
    CStaticDriver(CDeviceDescription *);
    virtual ~CStaticDriver(void);
};


// Base class for all audio devices
class CDevice : public CDsBasicRuntime
{
public:
    const VADDEVICETYPE     m_vdtDeviceType;        // Device type
    CDeviceDescription *    m_pDeviceDescription;   // Device description

#if 0
    BOOL                    m_fIncludeNs;           // Flag which includes NS in stack
    GUID                    m_guidNsInstance;       // Instance GUID of NS implementation
    DWORD                   m_dwNsFlags;            // NS creation flags
    BOOL                    m_fIncludeAgc;          // Flag which includes AGC in stack;
    GUID                    m_guidAgcInstance;      // Instance GUID of AGC implementation
    DWORD                   m_dwAgcFlags;           // AGC creation flags
#endif

public:
    CDevice(VADDEVICETYPE);
    virtual ~CDevice(void);

public:
    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *) = 0;

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCertification(LPDWORD, BOOL) = 0;

    // Driver properties
    virtual HRESULT GetDriverVersion(LARGE_INTEGER *);

};


// Base class for all audio rendering devices
class CRenderDevice : public CDevice
{
    friend class CPrimaryRenderWaveBuffer;
    friend class CSecondaryRenderWaveBuffer;

public:
    CList<CPrimaryRenderWaveBuffer *>   m_lstPrimaryBuffers;            // Primary buffers owned by this device
    CList<CSecondaryRenderWaveBuffer *> m_lstSecondaryBuffers;          // Secondary buffers owned by this device
    DWORD                               m_dwSupport;                    // Device suport for volume/pan
    DWORD                               m_dwAccelerationFlags;          // Device acceleration flags

private:
    LPCGUID                             m_guidDflt3dAlgorithm;          // Default S/W 3D algorithm to use if we                                                                   // have to fall back to software playback

public:
    CRenderDevice(VADDEVICETYPE);
    virtual ~CRenderDevice(void);

public:
    // Creation
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCaps(LPDSCAPS) = 0;
    virtual HRESULT GetVolumePanCaps(LPDWORD);

    // Device properties
    virtual HRESULT GetGlobalFormat(LPWAVEFORMATEX, LPDWORD) = 0;
    virtual HRESULT SetGlobalFormat(LPCWAVEFORMATEX) = 0;
    virtual HRESULT GetGlobalAttenuation(PDSVOLUMEPAN);
    virtual HRESULT SetGlobalAttenuation(PDSVOLUMEPAN);
    virtual HRESULT SetSrcQuality(DIRECTSOUNDMIXER_SRCQUALITY) = 0;
    virtual HRESULT GetAccelerationFlags(LPDWORD pdwFlags) {*pdwFlags = m_dwAccelerationFlags; return DS_OK;}
    virtual HRESULT SetAccelerationFlags(DWORD dwFlags) {m_dwAccelerationFlags = dwFlags; return DS_OK;}
    virtual HRESULT SetSpeakerConfig(DWORD) {return DS_OK;}
    LPCGUID GetDefault3dAlgorithm() {return m_guidDflt3dAlgorithm;}

    // Buffer management
    virtual HRESULT CreatePrimaryBuffer(DWORD, LPVOID, CPrimaryRenderWaveBuffer **) = 0;
    virtual HRESULT CreateSecondaryBuffer(LPCVADRBUFFERDESC, LPVOID, CSecondaryRenderWaveBuffer **) = 0;

    // AEC
    virtual HRESULT IncludeAEC(BOOL fEnable, REFGUID, DWORD) {return fEnable ? DSERR_UNSUPPORTED : DS_OK;}
};


// Base class for all wave rendering buffers
class CRenderWaveBuffer : public CDsBasicRuntime
{
public:
    const LPVOID    m_pvInstance;       // Instance identifier
    CRenderDevice * m_pDevice;          // Parent device
    CSysMemBuffer * m_pSysMemBuffer;    // System memory buffer for audio data
    VADRBUFFERDESC  m_vrbd;             // Buffer description

public:
    CRenderWaveBuffer(CRenderDevice *, LPVOID);
    virtual ~CRenderWaveBuffer(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCVADRBUFFERDESC, CRenderWaveBuffer * = NULL, CSysMemBuffer * = NULL);

    // Buffer capabilities
    virtual HRESULT GetCaps(LPVADRBUFFERCAPS);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT OverrideLocks(void);
    virtual HRESULT CommitToDevice(DWORD, DWORD) = 0;

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **) = 0;
};


// Base class for primary wave rendering buffers
class CPrimaryRenderWaveBuffer : public CRenderWaveBuffer
{
public:
    CPrimaryRenderWaveBuffer(CRenderDevice *, LPVOID);
    virtual ~CPrimaryRenderWaveBuffer(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCVADRBUFFERDESC, CRenderWaveBuffer *, CSysMemBuffer * =NULL);

    // Access rights
    virtual HRESULT RequestWriteAccess(BOOL) = 0;

    // Buffer control
    virtual HRESULT GetState(LPDWORD) = 0;
    virtual HRESULT SetState(DWORD) = 0;
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD) = 0;

    // Owned objects
    virtual HRESULT Create3dListener(C3dListener **) = 0;
};


// Base class for secondary wave rendering buffers
class CSecondaryRenderWaveBuffer : public CRenderWaveBuffer
{
public:
    CSecondaryRenderWaveBuffer(CRenderDevice *, LPVOID);
    virtual ~CSecondaryRenderWaveBuffer(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCVADRBUFFERDESC, CSecondaryRenderWaveBuffer *, CSysMemBuffer * =NULL);

    // Resource allocation
    virtual HRESULT AcquireResources(DWORD) {return DS_OK;}
    virtual HRESULT StealResources(CSecondaryRenderWaveBuffer *) {return DSERR_UNSUPPORTED;}
    virtual HRESULT FreeResources(void) {return DS_OK;}

    // Buffer creation
    virtual HRESULT Duplicate(CSecondaryRenderWaveBuffer **) = 0;

    // Buffer control
    virtual HRESULT GetState(LPDWORD) = 0;
    virtual HRESULT SetState(DWORD) = 0;
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD) = 0;
    virtual HRESULT SetCursorPosition(DWORD) = 0;

    // Buffer properties
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN) = 0;
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetChannelAttenuations(LONG, DWORD, const DWORD*, const LONG*) =0; // {BREAK(); return DSERR_GENERIC;}
#endif
    virtual HRESULT SetFrequency(DWORD, BOOL fClamp =FALSE) = 0;
    virtual HRESULT SetMute(BOOL) = 0;

    // Buffer position notifications
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY) = 0;

    // Owned objects
    virtual HRESULT Create3dObject(C3dListener *, C3dObject **) = 0;

    // For modifying the final success code returned to the app
    HRESULT SpecialSuccessCode(void) {return m_hrSuccessCode;}
    HRESULT m_hrSuccessCode;
    // This is usually DS_OK, but gets set to DS_NO_VIRTUALIZATION if we replace
    // an unsupported 3D algorithm with the No Virtualization (Pan3D) algorithm

protected:
    // Owned objects
    virtual HRESULT CreatePan3dObject(C3dListener *, BOOL, DWORD, C3dObject **);

public:
    // Stuff to support Doppler on sink buffers;
    void SetOwningSink(CDirectSoundSink *);
    HRESULT SetBufferFrequency(DWORD, BOOL fClamp =FALSE);

protected:
    // Owning sink object
    CDirectSoundSink * m_pOwningSink;
    BOOL HasSink(void) {return m_pOwningSink != NULL;};
};


// Base class for all audio capturing devices
class CCaptureDevice : public CDevice
{
public:
    CList<CCaptureWaveBuffer *> m_lstBuffers;       // Buffers owned by this device

public:
    CCaptureDevice(VADDEVICETYPE);
    virtual ~CCaptureDevice();

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device caps
    virtual HRESULT GetCaps(LPDSCCAPS) = 0;

    // Device recording level control
    HRESULT GetVolume(LPLONG);
    HRESULT SetVolume(LONG);
    HRESULT GetMicVolume(LPLONG);
    HRESULT SetMicVolume(LONG);
    HRESULT EnableMic(BOOL);
    HRESULT HasVolCtrl() {return m_fAcquiredVolCtrl ? DS_OK : DSERR_CONTROLUNAVAIL;}

    // Buffer management
    virtual HRESULT CreateBuffer(DWORD, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *, LPVOID, CCaptureWaveBuffer **) = 0;
    virtual void AddBufferToList(CCaptureWaveBuffer *pBuffer) {m_lstBuffers.AddNodeToList(pBuffer);}
    virtual void RemoveBufferFromList(CCaptureWaveBuffer *pBuffer) {m_lstBuffers.RemoveDataFromList(pBuffer);}

private:
    // For recording level control
    HRESULT AcquireVolCtrl(void);

    HMIXER m_hMixer;
    BOOL m_fAcquiredVolCtrl;
    BOOL m_fMasterMuxIsMux;
    MIXERCONTROLDETAILS m_mxcdMasterVol;
    MIXERCONTROLDETAILS m_mxcdMasterMute;
    MIXERCONTROLDETAILS m_mxcdMasterMux;
    MIXERCONTROLDETAILS m_mxcdMicVol;
    MIXERCONTROLDETAILS m_mxcdMicMute;
    MIXERCONTROLDETAILS_UNSIGNED m_mxVolume;
    MIXERCONTROLDETAILS_BOOLEAN m_mxMute;
    MIXERCONTROLDETAILS_BOOLEAN* m_pmxMuxFlags;
    LONG* m_pfMicValue;
    DWORD m_dwRangeMin;
    DWORD m_dwRangeSize;
};


// Base class for wave capturing buffers
class CCaptureWaveBuffer : public CDsBasicRuntime
{
    friend class CDirectSoundCaptureBuffer;
    friend class CDirectSoundAdministrator;

protected:
    CCaptureDevice *    m_pDevice;          // Parent device
    CSysMemBuffer *     m_pSysMemBuffer;    // System memory buffer
    DWORD               m_dwFlags;          // Current buffer flags
    HANDLE              m_hEventFocus;      // Event for focus change notifications
    DWORD               m_fYieldedFocus;     // Has YieldFocus() been called?

public:
    CCaptureWaveBuffer(CCaptureDevice *);
    virtual ~CCaptureWaveBuffer();

public:
    // Initialization
    virtual HRESULT Initialize(DWORD);

    // Buffer capabilities
    virtual HRESULT GetCaps(LPDSCBCAPS) = 0;

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD);
    virtual HRESULT Unlock(LPCVOID, DWORD, LPCVOID, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD) = 0;
    virtual HRESULT SetState(DWORD) = 0;
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD) = 0;
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY) = 0;

    // Added for DirectX 8.0 effects support
    HRESULT GetEffectInterface(REFGUID, DWORD, REFGUID, LPVOID *);
};


// Utility system memory buffer object
class CSysMemBuffer : public CDsBasicRuntime
{
private:
    static const DWORD  m_cbExtra;          // Extra amount of memory to allocate
    CList<LOCKREGION>   m_lstLocks;         // List of locks on the memory buffer
    DWORD               m_cbAudioBuffers;   // Size of the audio data buffer(s)
    LPBYTE              m_pbPreFxBuffer;    // Audio data prior to FX processing
    LPBYTE              m_pbPostFxBuffer;   // Audio data after FX processing

public:
    CSysMemBuffer(void);
    ~CSysMemBuffer(void);

public:
    // Initialization
    HRESULT Initialize(DWORD);

    // Buffer data
    HRESULT LockRegion(LPVOID, DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD);
    HRESULT UnlockRegion(LPVOID, LPCVOID, DWORD, LPCVOID, DWORD);
    void OverrideLocks(LPVOID);
    void WriteSilence(WORD, DWORD, DWORD);

    // Effects buffer control
    HRESULT AllocateFxBuffer(void);
    void FreeFxBuffer(void);

    // Buffer properties
    DWORD GetSize(void)          {return m_cbAudioBuffers;}
    UINT GetLockCount()          {return m_lstLocks.GetNodeCount();}

    // We replaced "GetBuffer" with these two methods which obtain either the
    // buffer for locking/writing, or the buffer which actually gets played;
    // these are one and the same, unless the buffer has an effects chain.
    LPBYTE GetWriteBuffer(void)  {return m_pbPreFxBuffer ? m_pbPreFxBuffer : m_pbPostFxBuffer;}
    LPBYTE GetPlayBuffer(void)   {return m_pbPostFxBuffer;}

    // These methods are used by the effects processing code to obtain the
    // buffers it needs, while checking that the FX buffer is there.
    LPBYTE GetPreFxBuffer(void)  {ASSERT(m_pbPreFxBuffer); return m_pbPreFxBuffer;}
    LPBYTE GetPostFxBuffer(void) {ASSERT(m_pbPreFxBuffer); return m_pbPostFxBuffer;}

private:
    HRESULT TrackLock(LPVOID, LPVOID, DWORD);
    HRESULT UntrackLock(LPVOID, LPCVOID);
    BOOL DoRegionsOverlap(LPLOCKREGION, LPLOCKREGION);
};

inline BOOL CSysMemBuffer::DoRegionsOverlap(LPLOCKREGION plr1, LPLOCKREGION plr2)
{
    return CircularBufferRegionsIntersect(m_cbAudioBuffers,
            PtrDiffToInt((LPBYTE)plr1->pvLock - GetWriteBuffer()), plr1->cbLock,
            PtrDiffToInt((LPBYTE)plr2->pvLock - GetWriteBuffer()), plr2->cbLock);
}

extern CVirtualAudioDeviceManager *g_pVadMgr;

#endif // __cplusplus

#endif // __VAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\verify.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       verify.h
 *  Content:    File certification verification.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/19/97    dereks  Created.
 *
 ***************************************************************************/

#ifndef __VERIFY_H__
#define __VERIFY_H__

#define VERIFY_UNCHECKED        0x00000000
#define VERIFY_UNCERTIFIED      0x00000001
#define VERIFY_CERTIFIED        0x00000002

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern BOOL GetDriverCertificationStatus(PCTSTR);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __VERIFY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vmanpset.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vmanpset.h
 *  Content:    Voice Manager property sets.
//@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/15/98    dereks  Created.
//@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __VMANPSET_H__
#define __VMANPSET_H__

#ifdef	__cplusplus
extern "C" {
#endif // __cplusplus

typedef enum 
{
    DSPROPERTY_VMANAGER_MODE = 0,
    DSPROPERTY_VMANAGER_PRIORITY,
    DSPROPERTY_VMANAGER_STATE
} DSPROPERTY_VMANAGER;

typedef enum 
{
    DSPROPERTY_VMANAGER_MODE_DEFAULT = 0,
    DSPROPERTY_VMANAGER_MODE_AUTO,
    DSPROPERTY_VMANAGER_MODE_REPORT,
    DSPROPERTY_VMANAGER_MODE_USER
} VmMode;
//@@BEGIN_MSINTERNAL
#define DSPROPERTY_VMANAGER_MODE_FIRST DSPROPERTY_VMANAGER_MODE_DEFAULT
#define DSPROPERTY_VMANAGER_MODE_LAST DSPROPERTY_VMANAGER_MODE_USER
//@@END_MSINTERNAL

typedef enum 
{
    DSPROPERTY_VMANAGER_STATE_PLAYING3DHW = 0,
    DSPROPERTY_VMANAGER_STATE_SILENT,
    DSPROPERTY_VMANAGER_STATE_BUMPED,
    DSPROPERTY_VMANAGER_STATE_PLAYFAILED
} VmState;

// Voice Manager property set identifier {62A69BAE-DF9D-11d1-99A6-00C04FC99D46}
DEFINE_GUID(DSPROPSETID_VoiceManager, 0x62a69bae, 0xdf9d, 0x11d1, 0x99, 0xa6, 0x0, 0xc0, 0x4f, 0xc9, 0x9d, 0x46);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __VMANPSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vmaxcoef.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vmaxintcoeffs.h
 *  Content:    
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/


#if !defined(VMAXINTCOEFFS_HEADER)
#define VMAXINTCOEFFS_HEADER
#pragma once

// ---------------------------------------------------------------------------
// Enumerations

// Canonical coefficient types
enum ECanonicalCoeffType {
	tagCanonicalB,
	tagCanonicalA,
	ecanonicalcoefftypeCount
};

// Biquad coefficients
enum EBiquadCoeffType {
	tagBiquadB2,
	tagBiquadB1,
	tagBiquadB0,
	tagBiquadA2,
	tagBiquadA1,
	ebiquadcoefftypeCount
};

// ---------------------------------------------------------------------------
// Defines

#define NumBiquadsToNumCanonicalCoeffs(expr) (4 * expr + 1)
#define NumBiquadsToNumCanonicalCoeffsHalf(expr) (2 * expr + 1)

#ifdef NOKS
// Coefficient formats
typedef enum {
	FLOAT_COEFF,
	SHORT_COEFF,
	KSDS3D_COEFF_COUNT
} KSDS3D_HRTF_COEFF_FORMAT;

// HRTF filter quality levels
typedef enum {
	FULL_FILTER,
	LIGHT_FILTER,
	KSDS3D_FILTER_QUALITY_COUNT
} KSDS3D_HRTF_FILTER_QUALITY;

// Filter methods
typedef enum {
	DIRECT_FORM,
	CASCADE_FORM,
	KSDS3D_FILTER_METHOD_COUNT
} KSDS3D_HRTF_FILTER_METHOD;

typedef struct {
    KSDS3D_HRTF_FILTER_METHOD    FilterMethod;
    KSDS3D_HRTF_COEFF_FORMAT     CoeffFormat;
} KSDS3D_HRTF_FILTER_FORMAT_MSG, *PKSDS3D_HRTF_FILTER_FORMAT_MSG;

#endif

#ifdef __cplusplus

// ---------------------------------------------------------------------------
// Constants

// Azimuth
#define CuiMaxAzimuthBins       36
#define Cd3dvalAzimuthRange     180.0f
#define Cd3dvalMinAzimuth       -Cd3dvalAzimuthRange
#define Cd3dvalMaxAzimuth       Cd3dvalAzimuthRange

// Elevation
#define CuiNumElevationBins     13
#define Cd3dvalMinElevationData -40.0f
#define Cd3dvalMaxElevationData 80.0f
#define Cd3dvalElevationResolution ((Cd3dvalMaxElevationData - Cd3dvalMinElevationData) / (CuiNumElevationBins - 1))
#define Cd3dvalElevationRange   90.0f
#define Cd3dvalMinElevation     -Cd3dvalElevationRange
#define Cd3dvalMaxElevation     Cd3dvalElevationRange

// Total number of biquad coefficients
// MIGHT CHANGE IF COEFFICIENTS CHANGE
#define CuiTotalBiquadCoeffs    302890  

// Maximum number of biquads in fixed-point filter
// MIGHT CHANGE IF COEFFICIENTS CHANGE
#define CbyMaxBiquads 4

// Maximum magnitude of a biquad coefficient
#define CfMaxBiquadCoeffMagnitude   1.0f

// Maximum magnitude of a canonical coefficient
#define CfMaxCanonicalCoeffMagnitude    50.0f

// ---------------------------------------------------------------------------
// External data

// Floating-point biquad coefficients
extern const FLOAT CafBiquadCoeffs[CuiTotalBiquadCoeffs];

// Floating-point biquad coefficient offset offsets
extern const DWORD CaadwBiquadCoeffOffsetOffset[KSDS3D_FILTER_QUALITY_COUNT][espeakerconfigCount];

// Floating-point biquad coefficient offsets
extern const WORD CaaaaawBiquadCoeffOffset[KSDS3D_FILTER_QUALITY_COUNT][espeakerconfigCount][esamplerateCount][CuiNumElevationBins][CuiMaxAzimuthBins];

// Number of floating-point biquad coefficients
extern const BYTE CaaaaaabyNumBiquadCoeffs[KSDS3D_FILTER_QUALITY_COUNT][espeakerconfigCount][esamplerateCount][efilterCount][CuiNumElevationBins][CuiMaxAzimuthBins];

// Overlap buffer lengths
extern const size_t CaastFilterOverlapLength[KSDS3D_FILTER_QUALITY_COUNT][esamplerateCount];
extern const size_t CaastFilterMuteLength[KSDS3D_FILTER_QUALITY_COUNT][esamplerateCount];
extern const size_t CastOutputOverlapLength[esamplerateCount];

// Number of azimuth bins
extern const UINT CauiNumAzimuthBins[CuiNumElevationBins];

#endif // __cplusplus

// ---------------------------------------------------------------------------
// Global helper functions

UINT NumBiquadsToNumBiquadCoeffs(const UINT CuiNumBiquads);
UINT NumBiquadCoeffsToNumBiquads(const UINT CuiNumBiquadCoeffs);
UINT NumBiquadCoeffsToNumCanonicalCoeffs(const UINT CuiNumBiquadCoeffs);
UINT NumCanonicalCoeffsToHalf(const UINT CuiNumCanonicalCoeffs);
SHORT FloatBiquadCoeffToShortBiquadCoeff(const FLOAT CfBiquadCoeff);

// ---------------------------------------------------------------------------
// Include inline definitions inline in release version

#if !defined(_DEBUG)
#include "vmaxcoef.inl"
#endif

#endif

// End of VMAXCOEF.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\verify.cpp ===
//--------------------------------------------------------------------------;
//
//  File: Verify.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract: Functions to verify driver certification.
//
//
//  Contents:
//      dl_WinVerifyTrust()
//      dl_CryptCATAdminReleaseContext()
//      dl_CryptCATAdminReleaseCatalogContext()
//      dl_CryptCATCatalogInfoFromContext()
//      dl_CryptCATAdminEnumCatalogFromHash()
//      dl_CryptCATAdminAcquireContext()
//      dl_CryptCATAdminCalcHashFromFileHandle()
//      dl_SetupScanFileQueue()
//      dl_SetupDiOpenDeviceInfo()
//      dl_SetupDiSetSelectedDriver()
//      dl_SetupDiGetDeviceRegistryProperty()
//      dl_SetupDiGetDeviceInstallParams()
//      dl_SetupDiSetDeviceInstallParams()
//      dl_SetupDiGetDeviceInstanceId()
//      dl_SetupDiGetClassDevs()
//      dl_SetupDiCallClassInstaller()
//      dl_SetupCloseFileQueue()
//      dl_SetupOpenFileQueue()
//      dl_SetupDiBuildDriverInfoList()
//      dl_SetupDiOpenDevRegKey()
//      dl_SetupDiEnumDeviceInfo()
//      dl_SetupDiCreateDeviceInfoList()
//      dl_SetupDiDestroyDeviceInfoList()
//      CertifyDynaLoad()
//      CertifyDynaFree()
//      TrustCheckDriverFileNoCatalog()
//      TrustCheckDriverFile()
//      enumFile()
//      GetDriverCertificationStatus()
//
//  History:
//      10/29/97    Fwong       Created.
//      02/19/98    Fwong       Added 'AlsoInstall' support.
//
//--------------------------------------------------------------------------;

#define  USE_SP_DRVINFO_DATA_V1 1
#include "dsoundi.h"
#include <wincrypt.h>
#include <wintrust.h>
#include <setupapi.h>
#include <mscat.h>
#include <regstr.h>
#include <softpub.h>
#include "verify.h"

//==========================================================================;
//
//                               Types...
//
//==========================================================================;

#define FILELISTSIZE    4096

typedef struct INFFILELIST_tag
{
    UINT    uCount;     //  Number of files.
    UINT    uMaxLen;    //  Length of longest string (in characters).
    UINT    uOffset;    //  Offset into szFile field to write next string.
    UINT    cTotal;     //  Size (in characters) of all the strings.
    UINT    cSize;      //  Size (in characters) of the szFile buffer.
    LPTSTR  pszFile;    //  List of zero terminated strings.
} INFFILELIST;
typedef INFFILELIST *PINFFILELIST;

typedef LONG (WINAPI * PFN00)(HWND ,GUID*, LPVOID);
typedef BOOL (WINAPI * PFN01)(HCATADMIN ,DWORD);
#ifdef WIN95
typedef BOOL (WINAPI * PFN02)(HCATADMIN, CATALOG_INFO*, DWORD);
typedef BOOL (WINAPI * PFN03)(CATALOG_INFO*, CATALOG_INFO*, DWORD);
typedef CATALOG_INFO* (WINAPI * PFN04)(HCATADMIN, BYTE*, DWORD, DWORD, CATALOG_INFO **);
#else  // WIN95
typedef BOOL (WINAPI * PFN02)(HCATADMIN, HCATINFO, DWORD);
typedef BOOL (WINAPI * PFN03)(HCATINFO, CATALOG_INFO*, DWORD);
typedef HCATINFO (WINAPI * PFN04)(HCATADMIN, BYTE*, DWORD, DWORD, HCATINFO*);
#endif // WIN95
typedef BOOL (WINAPI * PFN05)(HCATADMIN*, const GUID*, DWORD);
typedef BOOL (WINAPI * PFN06)(HANDLE, DWORD*, BYTE*, DWORD);
typedef BOOL (WINAPI * PFN07)(HSPFILEQ, DWORD, HWND, PSP_FILE_CALLBACK, PVOID, PDWORD);
typedef BOOL (WINAPI * PFN08)(HDEVINFO, PCTSTR, HWND, DWORD, PSP_DEVINFO_DATA);
typedef BOOL (WINAPI * PFN09)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DRVINFO_DATA);
typedef BOOL (WINAPI * PFN10)(HDEVINFO, PSP_DEVINFO_DATA, DWORD, PDWORD, PBYTE, DWORD, PDWORD);
typedef BOOL (WINAPI * PFN11)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS);
typedef BOOL (WINAPI * PFN12)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS);
typedef BOOL (WINAPI * PFN13)(HDEVINFO, PSP_DEVINFO_DATA, PTSTR, DWORD, PDWORD);
typedef HDEVINFO (WINAPI * PFN14)(LPGUID, PCTSTR, HWND, DWORD);
typedef HINF (WINAPI * PFN15)(PCTSTR, PCTSTR, DWORD, PUINT);
typedef BOOL (WINAPI * PFN16)(HINF, HINF, HSPFILEQ, PCTSTR, PCTSTR, UINT);
typedef BOOL (WINAPI * PFN17)(DI_FUNCTION, HDEVINFO, PSP_DEVINFO_DATA);
typedef BOOL (WINAPI * PFN18)(HSPFILEQ);
typedef HSPFILEQ (WINAPI * PFN19)(VOID);
typedef BOOL (WINAPI * PFN20)(HDEVINFO, PSP_DEVINFO_DATA, DWORD);
typedef HKEY (WINAPI * PFN21)(HDEVINFO, PSP_DEVINFO_DATA, DWORD, DWORD, DWORD, REGSAM);
typedef BOOL (WINAPI * PFN22)(HDEVINFO, DWORD, PSP_DEVINFO_DATA);
typedef HDEVINFO (WINAPI * PFN23)(LPGUID, HWND);
typedef BOOL (WINAPI * PFN24)(HDEVINFO);
typedef VOID (WINAPI * PFN25)(HINF);
//  Added for NT 5.0
typedef BOOL (WINAPI * PFN26)(HDEVINFO, PSP_DEVINFO_DATA, GUID*, DWORD, PSP_DEVICE_INTERFACE_DATA);
typedef BOOL (WINAPI * PFN27)(HDEVINFO, PSP_DEVICE_INTERFACE_DATA, PSP_DEVICE_INTERFACE_DETAIL_DATA, DWORD, PDWORD, PSP_DEVINFO_DATA);
typedef BOOL (WINAPI * PFN28)(PCCERT_CONTEXT);

typedef struct CERTIFYDYNALOADINFO_tag
{
    HMODULE     hWinTrust;
    HMODULE     hMSCat;
    HMODULE     hSetupAPI;
    HMODULE     hCrypt32;
    PFN00       pfnWinVerifyTrust;
    PFN01       pfnCryptCATAdminReleaseContext;
    PFN02       pfnCryptCATAdminReleaseCatalogContext;
    PFN03       pfnCryptCATCatalogInfoFromContext;
    PFN04       pfnCryptCATAdminEnumCatalogFromHash;
    PFN05       pfnCryptCATAdminAcquireContext;
    PFN06       pfnCryptCATAdminCalcHashFromFileHandle;
    PFN07       pfnSetupScanFileQueue;
    PFN08       pfnSetupDiOpenDeviceInfo;
    PFN09       pfnSetupDiSetSelectedDriver;
    PFN10       pfnSetupDiGetDeviceRegistryProperty;
    PFN11       pfnSetupDiGetDeviceInstallParams;
    PFN12       pfnSetupDiSetDeviceInstallParams;
    PFN13       pfnSetupDiGetDeviceInstanceId;
    PFN14       pfnSetupDiGetClassDevs;
    PFN15       pfnSetupOpenInfFile;
    PFN16       pfnSetupInstallFilesFromInfSection;
    PFN17       pfnSetupDiCallClassInstaller;
    PFN18       pfnSetupCloseFileQueue;
    PFN19       pfnSetupOpenFileQueue;
    PFN20       pfnSetupDiBuildDriverInfoList;
    PFN21       pfnSetupDiOpenDevRegKey;
    PFN22       pfnSetupDiEnumDeviceInfo;
    PFN23       pfnSetupDiCreateDeviceInfoList;
    PFN24       pfnSetupDiDestroyDeviceInfoList;
    PFN25       pfnSetupCloseInfFile;
    PFN26       pfnSetupDiEnumDeviceInterfaces;
    PFN27       pfnSetupDiGetDeviceInterfaceDetail;
    PFN28       pfnCertFreeCertificateContext;
} CERTIFYDYNALOADINFO;

//==========================================================================;
//
//                              Globals...
//
//==========================================================================;

static CERTIFYDYNALOADINFO cdli;

//==========================================================================;
//
//                       Dyna-Loaded functions...
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LONG dl_WinVerifyTrust
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HWND hWnd: Same as API.
//
//      GUID *pgActionID: Same as API.
//
//      LPVOID pWVTData: Same as API.
//
//  Return (LONG): Same as API.
//
//  History:
//      12/08/97    Fwong   Doing dynalinks.
//
//--------------------------------------------------------------------------;

LONG dl_WinVerifyTrust
(
    HWND    hWnd,
    GUID    *pgActionID,
    LPVOID  pWVTData
)
{
    if(NULL == cdli.pfnWinVerifyTrust)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return (cdli.pfnWinVerifyTrust)(hWnd, pgActionID, pWVTData);

} // dl_WinVerifyTrust()


//--------------------------------------------------------------------------;
//
//  BOOL dl_CryptCATAdminReleaseContext
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HCATADMIN hCatAdmin: Same as API.
//
//      DWORD dwFlags: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_CryptCATAdminReleaseContext
(
    HCATADMIN   hCatAdmin,
    DWORD       dwFlags
)
{
    if(NULL == cdli.pfnCryptCATAdminReleaseContext)
    {
        return FALSE;
    }

    return (cdli.pfnCryptCATAdminReleaseContext)(hCatAdmin, dwFlags);

} // dl_CryptCATAdminReleaseContext()

#ifdef WIN95

//--------------------------------------------------------------------------;
//
//  BOOL dl_CryptCATAdminReleaseCatalogContext
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HCATADMIN hCatAdmin: Same as API.
//
//      CATALOG_INFO *pCatContext: Same as API.
//
//      DWORD dwFlags: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_CryptCATAdminReleaseCatalogContext
(
    HCATADMIN       hCatAdmin,
    CATALOG_INFO *pCatContext,
    DWORD           dwFlags
)
{
    if(NULL == cdli.pfnCryptCATAdminReleaseCatalogContext)
    {
        return FALSE;
    }

    return (cdli.pfnCryptCATAdminReleaseCatalogContext)(hCatAdmin, pCatContext, dwFlags);

} // dl_CryptCATAdminReleaseCatalogContext()


//--------------------------------------------------------------------------;
//
//  BOOL dl_CryptCATCatalogInfoFromContext
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      CATALOG_INFO *pCatContext: Same as API.
//
//      CATALOG_INFO *psCatInfo: Same as API.
//
//      DWORD dwFlags: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_CryptCATCatalogInfoFromContext
(
    CATALOG_INFO *pCatContext,
    CATALOG_INFO    *psCatInfo,
    DWORD           dwFlags
)
{
    if(NULL == cdli.pfnCryptCATCatalogInfoFromContext)
    {
        return FALSE;
    }

    return (cdli.pfnCryptCATCatalogInfoFromContext)(
        pCatContext,
        psCatInfo,
        dwFlags);

} // dl_CryptCATCatalogInfoFromContext()


//--------------------------------------------------------------------------;
//
//  CATALOG_INFO* dl_CryptCATAdminEnumCatalogFromHash
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HCATADMIN hCatAdmin: Same as API.
//
//      BYTE *pbHash: Same as API.
//
//      DWORD cbHash: Same as API.
//
//      DWORD dwFlags: Same as API.
//
//      CATALOG_INFO **ppPrevContext: Same as API.
//
//  Return (CATALOG_INFO): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

CATALOG_INFO * dl_CryptCATAdminEnumCatalogFromHash
(
    HCATADMIN       hCatAdmin,
    BYTE            *pbHash,
    DWORD           cbHash,
    DWORD           dwFlags,
    CATALOG_INFO **ppPrevContext
)
{
    if(NULL == cdli.pfnCryptCATAdminEnumCatalogFromHash)
    {
        return NULL;
    }

    return (cdli.pfnCryptCATAdminEnumCatalogFromHash)(
        hCatAdmin,
        pbHash,
        cbHash,
        dwFlags,
        ppPrevContext);

} // dl_CryptCATAdminEnumCatalogFromHash()

#else // WIN95

//--------------------------------------------------------------------------;
//
//  BOOL dl_CryptCATAdminReleaseCatalogContext
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HCATADMIN hCatAdmin: Same as API.
//
//      HCATINFO hCatInfo: Same as API.
//
//      DWORD dwFlags: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_CryptCATAdminReleaseCatalogContext
(
    HCATADMIN       hCatAdmin,
    HCATINFO        hCatInfo,
    DWORD           dwFlags
)
{
    if(NULL == cdli.pfnCryptCATAdminReleaseCatalogContext)
    {
        return FALSE;
    }

    return (cdli.pfnCryptCATAdminReleaseCatalogContext)(hCatAdmin, hCatInfo, dwFlags);

} // dl_CryptCATAdminReleaseCatalogContext()


//--------------------------------------------------------------------------;
//
//  BOOL dl_CryptCATCatalogInfoFromContext
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HCATINFO hCatInfo: Same as API.
//
//      CATALOG_INFO *psCatInfo: Same as API.
//
//      DWORD dwFlags: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_CryptCATCatalogInfoFromContext
(
    HCATINFO        hCatInfo,
    CATALOG_INFO    *psCatInfo,
    DWORD           dwFlags
)
{
    if(NULL == cdli.pfnCryptCATCatalogInfoFromContext)
    {
        return FALSE;
    }

    return (cdli.pfnCryptCATCatalogInfoFromContext)(
        hCatInfo,
        psCatInfo,
        dwFlags);

} // dl_CryptCATCatalogInfoFromContext()


//--------------------------------------------------------------------------;
//
//  HCATINFO dl_CryptCATAdminEnumCatalogFromHash
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HCATADMIN hCatAdmin: Same as API.
//
//      BYTE *pbHash: Same as API.
//
//      DWORD cbHash: Same as API.
//
//      DWORD dwFlags: Same as API.
//
//      HCATINFO *phCatInfo: Same as API.
//
//  Return (HCATINFO): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

HCATINFO dl_CryptCATAdminEnumCatalogFromHash
(
    HCATADMIN       hCatAdmin,
    BYTE            *pbHash,
    DWORD           cbHash,
    DWORD           dwFlags,
    HCATINFO        *phCatInfo
)
{
    if(NULL == cdli.pfnCryptCATAdminEnumCatalogFromHash)
    {
        return NULL;
    }

    return (cdli.pfnCryptCATAdminEnumCatalogFromHash)(
        hCatAdmin,
        pbHash,
        cbHash,
        dwFlags,
        phCatInfo);

} // dl_CryptCATAdminEnumCatalogFromHash()

#endif  //  WIN95
                         
//--------------------------------------------------------------------------;
//
//  BOOL dl_CryptCATAdminAcquireContext
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HCATADMIN *phCatAdmin: Same as API.
//
//      const GUID *pgSubsystem: Same as API.
//
//      DWORD dwFlags: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_CryptCATAdminAcquireContext
(
    HCATADMIN   *phCatAdmin,
    const GUID  *pgSubsystem,
    DWORD       dwFlags
)
{
    if(NULL == cdli.pfnCryptCATAdminAcquireContext)
    {
        return FALSE;
    }

    return (cdli.pfnCryptCATAdminAcquireContext)(
        phCatAdmin,
        pgSubsystem,
        dwFlags);

} // dl_CryptCATAdminAcquireContext()


//--------------------------------------------------------------------------;
//
//  BOOL dl_CryptCATAdminCalcHashFromFileHandle
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HANDLE hFile: Same as API.
//
//      DWORD *pcbHash: Same as API.
//
//      BYTE *pbHash: Same as API.
//
//      DWORD dwFlags: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_CryptCATAdminCalcHashFromFileHandle
(
    HANDLE  hFile,
    DWORD   *pcbHash,
    BYTE    *pbHash,
    DWORD   dwFlags
)
{
    if(NULL == cdli.pfnCryptCATAdminCalcHashFromFileHandle)
    {
        return FALSE;
    }

    return (cdli.pfnCryptCATAdminCalcHashFromFileHandle)(
        hFile,
        pcbHash,
        pbHash,
        dwFlags);

} // dl_CryptCATAdminCalcHashFromFileHandle()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupScanFileQueue
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HSPFILEQ FileQueue: Same as API.
//
//      DWORD Flags: Same as API.
//
//      HWND Window: Same as API.
//
//      PSP_FILE_CALLBACK CallbackRoutine: Same as API.
//
//      PVOID CallbackContext: Same as API.
//
//      PDWORD Result: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupScanFileQueue
(
    HSPFILEQ            FileQueue,
    DWORD               Flags,
    HWND                Window,
    PSP_FILE_CALLBACK   CallbackRoutine,
    PVOID               CallbackContext,
    PDWORD              Result
)
{
    if(NULL == cdli.pfnSetupScanFileQueue)
    {
        return FALSE;
    }

    return (cdli.pfnSetupScanFileQueue)(
        FileQueue,
        Flags,
        Window,
        CallbackRoutine,
        CallbackContext,
        Result);

} // dl_SetupScanFileQueue()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiOpenDeviceInfo
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      LPTSTR DeviceInstanceId: Same as API.
//
//      HWND hWndParent: Same as API.
//
//      DWORD OpenFlags: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiOpenDeviceInfo
(
    HDEVINFO            DeviceInfoSet,
    LPTSTR              DeviceInstanceId,
    HWND                hWndParent,
    DWORD               OpenFlags,
    PSP_DEVINFO_DATA    DeviceInfoData
)
{
    if(NULL == cdli.pfnSetupDiOpenDeviceInfo)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiOpenDeviceInfo)(
        DeviceInfoSet,
        DeviceInstanceId,
        hWndParent,
        OpenFlags,
        DeviceInfoData);

} // dl_SetupDiOpenDeviceInfo()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiSetSelectedDriver
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//      PSP_DRVINFO_DATA DriverInfoData: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiSetSelectedDriver
(
    HDEVINFO            DeviceInfoSet,
    PSP_DEVINFO_DATA    DeviceInfoData,
    PSP_DRVINFO_DATA    DriverInfoData
)
{
    if(NULL == cdli.pfnSetupDiSetSelectedDriver)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiSetSelectedDriver)(
        DeviceInfoSet,
        DeviceInfoData,
        DriverInfoData);

} // dl_SetupDiSetSelectedDriver()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiGetDeviceRegistryProperty
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//      DWORD Property: Same as API.
//
//      PDWORD PropertyRegDataType: Same as API.
//
//      PBYTE PropertyBuffer: Same as API.
//
//      DWORD PropertyBufferSize: Same as API.
//
//      PDWORD RequiredSize: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiGetDeviceRegistryProperty
(
    HDEVINFO            DeviceInfoSet,
    PSP_DEVINFO_DATA    DeviceInfoData,
    DWORD               Property,
    PDWORD              PropertyRegDataType,
    PBYTE               PropertyBuffer,
    DWORD               PropertyBufferSize,
    PDWORD              RequiredSize
)
{
    if(NULL == cdli.pfnSetupDiGetDeviceRegistryProperty)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiGetDeviceRegistryProperty)(
        DeviceInfoSet,
        DeviceInfoData,
        Property,
        PropertyRegDataType,
        PropertyBuffer,
        PropertyBufferSize,
        RequiredSize);

} // dl_SetupDiGetDeviceRegistryProperty()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiGetDeviceInstallParams
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//      PSP_DEVINSTALL_PARAMS DeviceInstallParams: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiGetDeviceInstallParams
(
    HDEVINFO                DeviceInfoSet,
    PSP_DEVINFO_DATA        DeviceInfoData,
    PSP_DEVINSTALL_PARAMS   DeviceInstallParams
)
{
    if(NULL == cdli.pfnSetupDiGetDeviceInstallParams)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiGetDeviceInstallParams)(
        DeviceInfoSet,
        DeviceInfoData,
        DeviceInstallParams);

} // dl_SetupDiGetDeviceInstallParams()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiSetDeviceInstallParams
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//      PSP_DEVINSTALL_PARAMS DeviceInstallParams: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiSetDeviceInstallParams
(
    HDEVINFO                DeviceInfoSet,
    PSP_DEVINFO_DATA        DeviceInfoData,
    PSP_DEVINSTALL_PARAMS   DeviceInstallParams
)
{
    if(NULL == cdli.pfnSetupDiSetDeviceInstallParams)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiSetDeviceInstallParams)(
        DeviceInfoSet,
        DeviceInfoData,
        DeviceInstallParams);

} // dl_SetupDiSetDeviceInstallParams()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiGetDeviceInstanceId
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//      PSTR DeviceInstanceId: Same as API.
//
//      DWORD DeviceInstanceIdSize: Same as API.
//
//      PDWORD RequiredSize: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiGetDeviceInstanceId
(
    HDEVINFO            DeviceInfoSet,
    PSP_DEVINFO_DATA    DeviceInfoData,
    PTSTR               DeviceInstanceId,
    DWORD               DeviceInstanceIdSize,
    PDWORD              RequiredSize
)
{
    if(NULL == cdli.pfnSetupDiGetDeviceInstanceId)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiGetDeviceInstanceId)(
        DeviceInfoSet,
        DeviceInfoData,
        DeviceInstanceId,
        DeviceInstanceIdSize,
        RequiredSize);

} // dl_SetupDiGetDeviceInstanceId()


//--------------------------------------------------------------------------;
//
//  HDEVINFO dl_SetupDiGetClassDevs
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      LPGUID ClassGuid: Same as API.
//
//      LPTSTR Enumerator: Same as API.
//
//      HWND hwndParent: Same as API.
//
//      DWORD Flags: Same as API.
//
//  Return (HDEVINFO): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

HDEVINFO dl_SetupDiGetClassDevs
(
    LPGUID  ClassGuid,
    LPTSTR Enumerator,
    HWND    hwndParent,
    DWORD   Flags
)
{
    if(NULL == cdli.pfnSetupDiGetClassDevs)
    {
        return INVALID_HANDLE_VALUE;
    }

    return (cdli.pfnSetupDiGetClassDevs)(
        ClassGuid,
        Enumerator,
        hwndParent,
        Flags);

} // dl_SetupDiGetClassDevs()


//--------------------------------------------------------------------------;
//
//  HINF dl_SetupOpenInfFile
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      PCSTR pszFileName:  Same as API.
//
//      PCSTR pszInfClass:  Same as API.
//
//      DWORD InfStyle:  Same as API.
//
//      PUINT ErrorLine:  Same as API.
//
//  Return (HINF):  Same as API.
//
//  History:
//      02/19/98    Fwong       Adding check for 'AlsoInstall'
//
//--------------------------------------------------------------------------;

HINF dl_SetupOpenInfFile
(
    PCTSTR  pszFileName,
    PCTSTR  pszInfClass,
    DWORD   InfStyle,
    PUINT   ErrorLine
)
{
    if(NULL == cdli.pfnSetupOpenInfFile)
    {
        return INVALID_HANDLE_VALUE;
    }

    return (cdli.pfnSetupOpenInfFile)(
        pszFileName,
        pszInfClass,
        InfStyle,
        ErrorLine);
} // dl_SetupOpenInfFile()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupInstallFilesFromInfSection
//
//  Description:
//      Dynalink version of the API.
//
//  Arguments:
//      HINF InfHandle:  Same as API.
//
//      HINF LayoutInfHandle:  Same as API.
//
//      HSPFILEQ FileQueue:  Same as API.
//
//      PCSTR SectionName:  Same as API.
//
//      PCSTR SourceRootPath:  Same as API.
//
//      UINT CopyFlags:  Same as API.
//
//  Return (BOOL):  Same as API.
//
//  History:
//      02/19/98    Fwong       Adding check for 'AlsoInstall'
//
//--------------------------------------------------------------------------;

BOOL dl_SetupInstallFilesFromInfSection
(
    HINF        InfHandle,
    HINF        LayoutInfHandle,
    HSPFILEQ    FileQueue,
    PCTSTR      SectionName,
    PCTSTR      SourceRootPath,
    UINT        CopyFlags
)
{
    if(NULL == cdli.pfnSetupInstallFilesFromInfSection)
    {
        return FALSE;
    }

    return (cdli.pfnSetupInstallFilesFromInfSection)(
        InfHandle,
        LayoutInfHandle,
        FileQueue,
        SectionName,
        SourceRootPath,
        CopyFlags);

} // dl_SetupInstallFilesFromInfSection()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiCallClassInstaller
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      DI_FUNCTION InstallFunction: Same as API.
//
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiCallClassInstaller
(
    DI_FUNCTION         InstallFunction,
    HDEVINFO            DeviceInfoSet,
    PSP_DEVINFO_DATA    DeviceInfoData
)
{
    if(NULL == cdli.pfnSetupDiCallClassInstaller)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiCallClassInstaller)(
        InstallFunction,
        DeviceInfoSet,
        DeviceInfoData);

} // dl_SetupDiCallClassInstaller()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupCloseFileQueue
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HSPFILEQ QueueHandle: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupCloseFileQueue
(
    HSPFILEQ    QueueHandle
)
{
    if(NULL == cdli.pfnSetupCloseFileQueue)
    {
        return FALSE;
    }

    return (BOOL)(cdli.pfnSetupCloseFileQueue)((HSPFILEQ)QueueHandle);
} // dl_SetupCloseFileQueue()


//--------------------------------------------------------------------------;
//
//  HSPFILEQ dl_SetupOpenFileQueue
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      None.
//
//  Return (HSPFILEQ): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

HSPFILEQ dl_SetupOpenFileQueue
(
    VOID
)
{
    if(NULL == cdli.pfnSetupOpenFileQueue)
    {
        return INVALID_HANDLE_VALUE;
    }

    return (cdli.pfnSetupOpenFileQueue)();

} // dl_SetupOpenFileQueue()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiBuildDriverInfoList
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//      DWORD DriverType: Same as API.
//
//  Return (BOOL):
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiBuildDriverInfoList
(
    HDEVINFO            DeviceInfoSet,
    PSP_DEVINFO_DATA    DeviceInfoData,
    DWORD               DriverType
)
{
    if(NULL == cdli.pfnSetupDiBuildDriverInfoList)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiBuildDriverInfoList)(
        DeviceInfoSet,
        DeviceInfoData,
        DriverType);

} // dl_SetupDiBuildDriverInfoList()


//--------------------------------------------------------------------------;
//
//  HKEY dl_SetupDiOpenDevRegKey
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//      DWORD Scope: Same as API.
//
//      DWORD HwProfile: Same as API.
//
//      DWORD KeyType: Same as API.
//
//      REGSAM samDesired: Same as API.
//
//  Return (HKEY): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

HKEY dl_SetupDiOpenDevRegKey
(
    HDEVINFO         DeviceInfoSet,
    PSP_DEVINFO_DATA DeviceInfoData,
    DWORD            Scope,
    DWORD            HwProfile,
    DWORD            KeyType,
    REGSAM           samDesired
)
{
    if(NULL == cdli.pfnSetupDiOpenDevRegKey)
    {
        return (HKEY)INVALID_HANDLE_VALUE;
    }

    return (cdli.pfnSetupDiOpenDevRegKey)(
        DeviceInfoSet,
        DeviceInfoData,
        Scope,
        HwProfile,
        KeyType,
        samDesired);

} // dl_SetupDiOpenDevRegKey()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiEnumDeviceInfo
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      DWORD MemberIndex: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/08/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiEnumDeviceInfo
(
    HDEVINFO            DeviceInfoSet,
    DWORD               MemberIndex,
    PSP_DEVINFO_DATA    DeviceInfoData
)
{
    if(NULL == cdli.pfnSetupDiEnumDeviceInfo)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiEnumDeviceInfo)(
        DeviceInfoSet,
        MemberIndex,
        DeviceInfoData);

} // dl_SetupDiEnumDeviceInfo()


//--------------------------------------------------------------------------;
//
//  HDEVINFO dl_SetupDiCreateDeviceInfoList
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      LPGUID ClassGuid: Same as API.
//
//      HWND hWndParent: Same as API.
//
//  Return (HDEVINFO): Same as API.
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

HDEVINFO dl_SetupDiCreateDeviceInfoList
(
    LPGUID  ClassGuid,
    HWND    hWndParent
)
{
    if(NULL == cdli.pfnSetupDiCreateDeviceInfoList)
    {
        return INVALID_HANDLE_VALUE;
    }

    return (cdli.pfnSetupDiCreateDeviceInfoList)(ClassGuid, hWndParent);

} // dl_SetupDiCreateDeviceInfoList()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiDestroyDeviceInfoList
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      IN HDEVINFO DeviceInfoSet: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/22/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiDestroyDeviceInfoList
(
    IN HDEVINFO DeviceInfoSet
)
{
    if(NULL == cdli.pfnSetupDiDestroyDeviceInfoList)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiDestroyDeviceInfoList)(DeviceInfoSet);
} // dl_SetupDiDestroyDeviceInfoList()


//--------------------------------------------------------------------------;
//
//  VOID dl_SetupCloseInfFile
//
//  Description:
//      Dynalink version of API.
//
//  Arguments:
//      HINF InfHandle:  Same as API.
//
//  Return (VOID): none.
//
//  History:
//      02/19/98    Fwong       Adding check for 'AlsoInstall'
//
//--------------------------------------------------------------------------;

VOID dl_SetupCloseInfFile
(
    HINF    InfHandle
)
{
    if(NULL == cdli.pfnSetupCloseInfFile)
    {
        return;
    }

    (cdli.pfnSetupCloseInfFile)(InfHandle);

} // dl_SetupCloseInfFile()


//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiEnumDeviceInterfaces
//
//  Description:
//      Dynalink version of the API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//      CONST GUID *InterfaceClassGuid: Same as API.
//
//      DWORD MemberIndex: Same as API.
//
//      PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      12/06/98    Fwong       Adding support for NT 5.
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiEnumDeviceInterfaces
(
    HDEVINFO                    DeviceInfoSet,
    PSP_DEVINFO_DATA            DeviceInfoData,
    GUID                       *InterfaceClassGuid,
    DWORD                       MemberIndex,
    PSP_DEVICE_INTERFACE_DATA   DeviceInterfaceData
)
{
    if(NULL == cdli.pfnSetupDiEnumDeviceInterfaces)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiEnumDeviceInterfaces)(
        DeviceInfoSet,
        DeviceInfoData,
        InterfaceClassGuid,
        MemberIndex,
        DeviceInterfaceData);

} // dl_SetupDiEnumDeviceInterfaces()

//--------------------------------------------------------------------------;
//
//  BOOL dl_SetupDiGetDeviceInterfaceDetail
//
//  Description:
//      Dynalink version of the API.
//
//  Arguments:
//      HDEVINFO DeviceInfoSet: Same as API.
//
//      PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData: Same as API.
//
//      PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData:
//          Same as API.
//
//      DWORD DeviceInterfaceDetailDataSize: Same as API.
//
//      PDWORD RequiredSize: Same as API.
//
//      PSP_DEVINFO_DATA DeviceInfoData: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      09/14/99    Fwong       Actually this was done much earlier.
//
//--------------------------------------------------------------------------;

BOOL dl_SetupDiGetDeviceInterfaceDetail
(
    HDEVINFO                            DeviceInfoSet,
    PSP_DEVICE_INTERFACE_DATA           DeviceInterfaceData,
    PSP_DEVICE_INTERFACE_DETAIL_DATA    DeviceInterfaceDetailData,
    DWORD                               DeviceInterfaceDetailDataSize,
    PDWORD                              RequiredSize,
    PSP_DEVINFO_DATA                    DeviceInfoData
)
{
    if(NULL == cdli.pfnSetupDiGetDeviceInterfaceDetail)
    {
        return FALSE;
    }

    return (cdli.pfnSetupDiGetDeviceInterfaceDetail)(
        DeviceInfoSet,
        DeviceInterfaceData,
        DeviceInterfaceDetailData,
        DeviceInterfaceDetailDataSize,
        RequiredSize,
        DeviceInfoData);

} // dl_SetupDiGetDeviceInterfaceDetail()

//--------------------------------------------------------------------------;
//
//  BOOL dl_CertFreeCertificateContext
//
//  Description:
//      Dynalink version of the API.
//
//  Arguments:
//      PCCERT_CONTEXT pCertContext: Same as API.
//
//  Return (BOOL): Same as API.
//
//  History:
//      09/14/99    Fwong       Adding API to fix memory leak.
//
//--------------------------------------------------------------------------;

BOOL dl_CertFreeCertificateContext
(
    PCCERT_CONTEXT  pCertContext
)
{
    if (NULL == cdli.pfnCertFreeCertificateContext)
    {
        return FALSE;
    }

    return (cdli.pfnCertFreeCertificateContext)(pCertContext);

} // dl_CertFreeCertificateContext()


//--------------------------------------------------------------------------;
//
//  BOOL CertifyDynaLoad
//
//  Description:
//      Dynalink the API's needed for certification.
//
//  Arguments:
//      None.
//
//  Return (BOOL): TRUE if successful, FALSE otherwise.
//
//  History:
//      12/08/97    Fwong       Dynalinking 
//      09/15/99    Fwong       Updated to fix memory leak
//
//--------------------------------------------------------------------------;

BOOL CertifyDynaLoad
(
    void
)
{
    TCHAR   szSystemDir[MAX_PATH];
    LPTSTR  pszWrite;

    if(0 == GetSystemDirectory(szSystemDir, MAX_PATH))
    {
        //  Couldn't get the Window system dir?!
        return FALSE;
    }

    lstrcat(szSystemDir, TEXT("\\"));
    pszWrite = &(szSystemDir[lstrlen(szSystemDir)]);

    //
    //  Doing WinTrust API's...
    //

    lstrcpy(pszWrite, TEXT("WINTRUST.DLL"));

    cdli.hWinTrust = LoadLibrary(szSystemDir);

    if(NULL == cdli.hWinTrust)
    {
        //  Couldn't load wintrust.dll
        return FALSE;
    }

    cdli.pfnWinVerifyTrust = (PFN00)GetProcAddress(
        cdli.hWinTrust,
        "WinVerifyTrust");

    if(NULL == cdli.pfnWinVerifyTrust)
    {
        //  Couldn't get proc address.
        FreeLibrary(cdli.hWinTrust);
        return FALSE;
    }

    //
    //  Doing MSCAT32 API's..
    //

    lstrcpy(pszWrite, TEXT("MSCAT32.DLL"));

    cdli.hMSCat = LoadLibrary(szSystemDir);

    if(NULL == cdli.hMSCat)
    {
        //  Couldn't load mscat32.dll

        FreeLibrary(cdli.hWinTrust);
        return FALSE;
    }

    cdli.pfnCryptCATAdminReleaseContext = (PFN01)GetProcAddress(
        cdli.hMSCat,
        "CryptCATAdminReleaseContext");

    cdli.pfnCryptCATAdminReleaseCatalogContext = (PFN02)GetProcAddress(
        cdli.hMSCat,
        "CryptCATAdminReleaseCatalogContext");

    cdli.pfnCryptCATCatalogInfoFromContext = (PFN03)GetProcAddress(
        cdli.hMSCat,
        "CryptCATCatalogInfoFromContext");

    cdli.pfnCryptCATAdminEnumCatalogFromHash = (PFN04)GetProcAddress(
        cdli.hMSCat,
        "CryptCATAdminEnumCatalogFromHash");

    cdli.pfnCryptCATAdminAcquireContext = (PFN05)GetProcAddress(
        cdli.hMSCat,
        "CryptCATAdminAcquireContext");

    cdli.pfnCryptCATAdminCalcHashFromFileHandle = (PFN06)GetProcAddress(
        cdli.hMSCat,
        "CryptCATAdminCalcHashFromFileHandle");

    if ((NULL == cdli.pfnCryptCATAdminReleaseContext) ||
        (NULL == cdli.pfnCryptCATAdminReleaseCatalogContext) ||
        (NULL == cdli.pfnCryptCATCatalogInfoFromContext) ||
        (NULL == cdli.pfnCryptCATAdminEnumCatalogFromHash) ||
        (NULL == cdli.pfnCryptCATAdminCalcHashFromFileHandle) ||
        (NULL == cdli.pfnCryptCATAdminAcquireContext))
    {
        //  Couldn't get proc address.

        FreeLibrary(cdli.hMSCat);
        FreeLibrary(cdli.hWinTrust);
        return FALSE;
    }

    //
    //  Doing SetupAPI API's..
    //

    lstrcpy(pszWrite, TEXT("SETUPAPI.DLL"));

    cdli.hSetupAPI = LoadLibrary(szSystemDir);

    if(NULL == cdli.hSetupAPI)
    {
        //  Couldn't load SetupAPI.dll

        FreeLibrary(cdli.hMSCat);
        FreeLibrary(cdli.hWinTrust);
        return FALSE;
    }

#ifndef UNICODE

    //
    //  Dynaloading the ANSI API's...
    //

    cdli.pfnSetupScanFileQueue = (PFN07)GetProcAddress(
        cdli.hSetupAPI,
        "SetupScanFileQueueA");

    cdli.pfnSetupDiOpenDeviceInfo = (PFN08)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiOpenDeviceInfoA");

    cdli.pfnSetupDiSetSelectedDriver = (PFN09)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiSetSelectedDriverA");

    cdli.pfnSetupDiGetDeviceRegistryProperty = (PFN10)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetDeviceRegistryPropertyA");

    cdli.pfnSetupDiGetDeviceInstallParams = (PFN11)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetDeviceInstallParamsA");

    cdli.pfnSetupDiSetDeviceInstallParams = (PFN12)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiSetDeviceInstallParamsA");

    cdli.pfnSetupDiGetDeviceInstanceId = (PFN13)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetDeviceInstanceIdA");

    cdli.pfnSetupDiGetClassDevs = (PFN14)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetClassDevsA");

    cdli.pfnSetupOpenInfFile = (PFN15)GetProcAddress(
        cdli.hSetupAPI,
        "SetupOpenInfFileA");

    cdli.pfnSetupInstallFilesFromInfSection = (PFN16)GetProcAddress(
        cdli.hSetupAPI,
        "SetupInstallFilesFromInfSectionA");

    cdli.pfnSetupDiGetDeviceInterfaceDetail = (PFN27)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetDeviceInterfaceDetailA");

#else // UNICODE

    //
    //  Dynaloading the UNICODE API's...
    //

    cdli.pfnSetupScanFileQueue = (PFN07)GetProcAddress(
        cdli.hSetupAPI,
        "SetupScanFileQueueW");

    cdli.pfnSetupDiOpenDeviceInfo = (PFN08)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiOpenDeviceInfoW");

    cdli.pfnSetupDiSetSelectedDriver = (PFN09)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiSetSelectedDriverW");

    cdli.pfnSetupDiGetDeviceRegistryProperty = (PFN10)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetDeviceRegistryPropertyW");

    cdli.pfnSetupDiGetDeviceInstallParams = (PFN11)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetDeviceInstallParamsW");

    cdli.pfnSetupDiSetDeviceInstallParams = (PFN12)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiSetDeviceInstallParamsW");

    cdli.pfnSetupDiGetDeviceInstanceId = (PFN13)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetDeviceInstanceIdW");

    cdli.pfnSetupDiGetClassDevs = (PFN14)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetClassDevsW");

    cdli.pfnSetupOpenInfFile = (PFN15)GetProcAddress(
        cdli.hSetupAPI,
        "SetupOpenInfFileW");

    cdli.pfnSetupInstallFilesFromInfSection = (PFN16)GetProcAddress(
        cdli.hSetupAPI,
        "SetupInstallFilesFromInfSectionW");

    cdli.pfnSetupDiGetDeviceInterfaceDetail = (PFN27)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiGetDeviceInterfaceDetailW");

#endif // UNICODE

    cdli.pfnSetupDiCallClassInstaller = (PFN17)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiCallClassInstaller");

    cdli.pfnSetupCloseFileQueue = (PFN18)GetProcAddress(
        cdli.hSetupAPI,
        "SetupCloseFileQueue");

    cdli.pfnSetupOpenFileQueue = (PFN19)GetProcAddress(
        cdli.hSetupAPI,
        "SetupOpenFileQueue");

    cdli.pfnSetupDiBuildDriverInfoList = (PFN20)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiBuildDriverInfoList");

    cdli.pfnSetupDiOpenDevRegKey = (PFN21)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiOpenDevRegKey");

    cdli.pfnSetupDiEnumDeviceInfo = (PFN22)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiEnumDeviceInfo");

    cdli.pfnSetupDiCreateDeviceInfoList = (PFN23)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiCreateDeviceInfoList");

    cdli.pfnSetupDiDestroyDeviceInfoList = (PFN24)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiDestroyDeviceInfoList");

    cdli.pfnSetupCloseInfFile = (PFN25)GetProcAddress(
        cdli.hSetupAPI,
        "SetupCloseInfFile");

    cdli.pfnSetupDiEnumDeviceInterfaces = (PFN26)GetProcAddress(
        cdli.hSetupAPI,
        "SetupDiEnumDeviceInterfaces");

    if ((NULL == cdli.pfnSetupScanFileQueue) ||
        (NULL == cdli.pfnSetupDiOpenDeviceInfo) ||
        (NULL == cdli.pfnSetupDiSetSelectedDriver) ||
        (NULL == cdli.pfnSetupDiGetDeviceRegistryProperty) ||
        (NULL == cdli.pfnSetupDiGetDeviceInstallParams) ||
        (NULL == cdli.pfnSetupDiSetDeviceInstallParams) ||
        (NULL == cdli.pfnSetupDiGetDeviceInstanceId) ||
        (NULL == cdli.pfnSetupDiGetClassDevs) ||
        (NULL == cdli.pfnSetupOpenInfFile) ||
        (NULL == cdli.pfnSetupInstallFilesFromInfSection) ||
        (NULL == cdli.pfnSetupDiCallClassInstaller) ||
        (NULL == cdli.pfnSetupCloseFileQueue) ||
        (NULL == cdli.pfnSetupOpenFileQueue) ||
        (NULL == cdli.pfnSetupDiBuildDriverInfoList) ||
        (NULL == cdli.pfnSetupDiOpenDevRegKey) ||
        (NULL == cdli.pfnSetupDiEnumDeviceInfo) ||
        (NULL == cdli.pfnSetupDiCreateDeviceInfoList) ||
        (NULL == cdli.pfnSetupDiDestroyDeviceInfoList) ||
        (NULL == cdli.pfnSetupCloseInfFile) ||
        (NULL == cdli.pfnSetupDiEnumDeviceInterfaces) ||
        (NULL == cdli.pfnSetupDiGetDeviceInterfaceDetail))
    {
        //  Couldn't get proc address.

        FreeLibrary(cdli.hSetupAPI);
        FreeLibrary(cdli.hMSCat);
        FreeLibrary(cdli.hWinTrust);
        return FALSE;
    }

    //
    //  Doing Crypt32 API's...
    //

    lstrcpy(pszWrite, TEXT("CRYPT32.DLL"));

    cdli.hCrypt32 = LoadLibrary(szSystemDir);

    if(NULL == cdli.hCrypt32)
    {
        //  Couldn't load crypt32.dll

        return FALSE;
    }

    cdli.pfnCertFreeCertificateContext = (PFN28)GetProcAddress(
        cdli.hCrypt32,
        "CertFreeCertificateContext");

    if(NULL == cdli.pfnCertFreeCertificateContext)
    {
        //  Couldn't get proc address.

        FreeLibrary(cdli.hCrypt32);
        FreeLibrary(cdli.hSetupAPI);
        FreeLibrary(cdli.hMSCat);
        FreeLibrary(cdli.hWinTrust);
        return FALSE;
    }

    return TRUE;
} // CertifyDynaLoad()


//--------------------------------------------------------------------------;
//
//  void CertifyDynaFree
//
//  Description:
//      Frees all the dynalinked API's
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      12/08/97    Fwong       Dynalinking.
//      09/15/99    Fwong       Updated to fix memory leak
//
//--------------------------------------------------------------------------;

void CertifyDynaFree
(
    void
)
{
    if(NULL != cdli.hWinTrust)
    {
        FreeLibrary(cdli.hWinTrust);
    }

    if(NULL != cdli.hMSCat)
    {
        FreeLibrary(cdli.hMSCat);
    }

    if(NULL != cdli.hSetupAPI)
    {
        FreeLibrary(cdli.hSetupAPI);
    }

    if(NULL != cdli.hCrypt32)
    {
        FreeLibrary(cdli.hCrypt32);
    }

    ZeroMemory(&cdli, sizeof(CERTIFYDYNALOADINFO));
} // CertifyDynaFree()


//--------------------------------------------------------------------------;
//
//  BOOL TrustCheckDriverFileNoCatalog
//
//  Description:
//      Checks the driver file in question without the catalog file.
//      This is less reliable than the check with the catalog file.
//
//  Arguments:
//      WCHAR *pwszDrvFile: Driver file.
//
//  Return (BOOL):
//
//  History:
//      11/13/97    Fwong
//
//--------------------------------------------------------------------------;

BOOL WINAPI TrustCheckDriverFileNoCatalog
(
    WCHAR   *pwszDrvFile
)
{
    GUID                    gDriverSigning = DRIVER_ACTION_VERIFY;
    DRIVER_VER_INFO         dvi;
    WINTRUST_DATA           wtd;
    WINTRUST_FILE_INFO      wtfi;
    HRESULT                 hr;
    OSVERSIONINFO           OSVer;

    ZeroMemory(&wtd, sizeof(WINTRUST_DATA));
    wtd.cbStruct            = sizeof(WINTRUST_DATA);
    wtd.dwUIChoice          = WTD_UI_NONE;
    wtd.fdwRevocationChecks = WTD_REVOKE_NONE;
    wtd.dwUnionChoice       = WTD_CHOICE_FILE;
    wtd.pFile               = &wtfi;
    wtd.pPolicyCallbackData = (LPVOID)&dvi;

    ZeroMemory(&wtfi, sizeof(WINTRUST_FILE_INFO));
    wtfi.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    wtfi.pcwszFilePath = pwszDrvFile;

    ZeroMemory(&dvi, sizeof(DRIVER_VER_INFO));
    dvi.cbStruct = sizeof(DRIVER_VER_INFO);
    
    ZeroMemory(&OSVer, sizeof(OSVERSIONINFO));
    OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
    if (GetVersionEx(&OSVer))
    {
        dvi.dwPlatform = OSVer.dwPlatformId;
        dvi.dwVersion  = OSVer.dwMajorVersion;
        
        dvi.sOSVersionLow.dwMajor  = OSVer.dwMajorVersion;
        dvi.sOSVersionLow.dwMinor  = OSVer.dwMinorVersion;
        dvi.sOSVersionHigh.dwMajor = OSVer.dwMajorVersion;
        dvi.sOSVersionHigh.dwMinor = OSVer.dwMinorVersion;
    }

    hr = dl_WinVerifyTrust(NULL, &gDriverSigning, &wtd);
    
    if (NULL != dvi.pcSignerCertContext)
    {
        dl_CertFreeCertificateContext(dvi.pcSignerCertContext);
        dvi.pcSignerCertContext = NULL;
    }

    return SUCCEEDED(hr);
} // TrustCheckDriverFileNoCatalog()


//--------------------------------------------------------------------------;
//
//  BOOL TrustCheckDriverFile
//
//  Description:
//      Checks whether the particular file name is certified.
//
//  Arguments:
//      WCHAR *pwszDrvFile:
//
//  Return (BOOL):  TRUE if driver file is certified, FALSE otherwise.
//
//  History:
//      10/17/97    PBerkman        Created.
//      11/12/97    Fwong           API removed; re-structured.
//
//--------------------------------------------------------------------------;

BOOL WINAPI TrustCheckDriverFile
(
    WCHAR   *pwszDrvFile
)
{
    GUID                    gDriverSigning = DRIVER_ACTION_VERIFY;
    HCATADMIN               hCatAdmin;
    HANDLE                  hFile;
    HRESULT                 hr;
    CATALOG_INFO            CatalogInfo;
    DWORD                   cbHash;
    BYTE                    *pHash;
#ifdef WIN95
    CATALOG_INFO         *hCatInfo, *hCatInfoPrev;
#else  // WIN95
    HCATINFO                hCatInfo, hCatInfoPrev;
#endif // WIN95
    WCHAR                   *pwszBaseName;
    WINTRUST_DATA           sWTD;
    WINTRUST_CATALOG_INFO   sWTCI;
    DRIVER_VER_INFO         VerInfo;
    OSVERSIONINFO           OSVer;

    if (!(pwszDrvFile))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pwszBaseName = pwszDrvFile + lstrlenW(pwszDrvFile) - 1;

    while(pwszBaseName > pwszDrvFile && L'\\' != *pwszBaseName)
    {
        pwszBaseName--;
    }

    if(pwszBaseName > pwszDrvFile)
    {
        pwszBaseName++;
    }

    if (!(pwszBaseName))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hr = E_NOTIMPL;

    if (!(dl_CryptCATAdminAcquireContext(&hCatAdmin, &gDriverSigning, 0)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hFile = CreateFileW(
        pwszDrvFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if(INVALID_HANDLE_VALUE == hFile)
    {
        dl_CryptCATAdminReleaseContext(hCatAdmin, 0);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cbHash = 100;
    pHash  = MEMALLOC_A(BYTE, cbHash);

    if(NULL == pHash)
    {
        dl_CryptCATAdminReleaseContext(hCatAdmin, 0);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (!(dl_CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, pHash, 0)))
    {
        if (ERROR_NOT_ENOUGH_MEMORY != GetLastError())
        {
            MEMFREE(pHash);
            CloseHandle(hFile);
            dl_CryptCATAdminReleaseContext(hCatAdmin, 0);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        //  The hash buffer not large enough?!

        MEMFREE(pHash);

        //  cbHash set to new value by CryptCATAdminCalcHashFromFileHandle

        pHash = MEMALLOC_A(BYTE, cbHash);

        if (NULL == pHash)
        {
            CloseHandle(hFile);
            dl_CryptCATAdminReleaseContext(hCatAdmin, 0);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (!(dl_CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, pHash, 0)))
        {
            //  No excuse now...

            MEMFREE(pHash);
            CloseHandle(hFile);
            dl_CryptCATAdminReleaseContext(hCatAdmin, 0);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    CatalogInfo.cbStruct = sizeof(CATALOG_INFO);

    for (hCatInfoPrev = NULL;;hCatInfo = hCatInfoPrev)
    {
        hCatInfo = dl_CryptCATAdminEnumCatalogFromHash(
                hCatAdmin,
                pHash,
                cbHash,
                0,
                &hCatInfoPrev);

        if (NULL == hCatInfo)
        {
            CloseHandle(hFile);
            MEMFREE(pHash);
            dl_CryptCATAdminReleaseContext(hCatAdmin, 0);

            //  We can't seem to get a catalog context, so let's try to check
            //  the driver w/out a catalog file.

            if(TrustCheckDriverFileNoCatalog(pwszDrvFile))
            {
                return TRUE;
            }

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        CatalogInfo.wszCatalogFile[0] = 0;

        if (!(dl_CryptCATCatalogInfoFromContext(hCatInfo, &CatalogInfo, 0)))
        {
            CloseHandle(hFile);
            MEMFREE(pHash);
            dl_CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
            dl_CryptCATAdminReleaseContext(hCatAdmin, 0);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ZeroMemory(&sWTD, sizeof(WINTRUST_DATA));
        sWTD.cbStruct            = sizeof(WINTRUST_DATA);
        sWTD.dwUIChoice          = WTD_UI_NONE;
        sWTD.fdwRevocationChecks = WTD_REVOKE_NONE;
        sWTD.dwUnionChoice       = WTD_CHOICE_CATALOG;
        sWTD.dwStateAction       = WTD_STATEACTION_AUTO_CACHE;
        sWTD.pPolicyCallbackData = (LPVOID)&VerInfo;
        sWTD.pCatalog            = &sWTCI;

        ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
        VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

        ZeroMemory(&sWTCI, sizeof(WINTRUST_CATALOG_INFO));
        sWTCI.cbStruct              = sizeof(WINTRUST_CATALOG_INFO);
        sWTCI.pcwszCatalogFilePath  = CatalogInfo.wszCatalogFile;
        sWTCI.pcwszMemberTag        = pwszBaseName;
        sWTCI.pcwszMemberFilePath   = pwszDrvFile;
        sWTCI.hMemberFile           = hFile;

#ifndef WIN95
        sWTCI.pbCalculatedFileHash  = pHash;
        sWTCI.cbCalculatedFileHash  = cbHash;
#endif

        ZeroMemory(&OSVer, sizeof(OSVERSIONINFO));
        OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
        if (GetVersionEx(&OSVer))
        {
            VerInfo.dwPlatform = OSVer.dwPlatformId;
            VerInfo.dwVersion  = OSVer.dwMajorVersion;
            
            VerInfo.sOSVersionLow.dwMajor  = OSVer.dwMajorVersion;
            VerInfo.sOSVersionLow.dwMinor  = OSVer.dwMinorVersion;
            VerInfo.sOSVersionHigh.dwMajor = OSVer.dwMajorVersion;
            VerInfo.sOSVersionHigh.dwMinor = OSVer.dwMinorVersion;
        }

        hr = dl_WinVerifyTrust(NULL, &gDriverSigning, &sWTD);

        if (NULL != VerInfo.pcSignerCertContext)
        {
            dl_CertFreeCertificateContext(VerInfo.pcSignerCertContext);
            VerInfo.pcSignerCertContext = NULL;
        }

        if (hr == ERROR_SUCCESS)
        {
            CloseHandle(hFile);
            MEMFREE(pHash);
            dl_CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
            dl_CryptCATAdminReleaseContext(hCatAdmin, 0);
            return TRUE;
        }

        if (NULL == hCatInfoPrev)
        {
            CloseHandle(hFile);
            MEMFREE(pHash);
            dl_CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
            dl_CryptCATAdminReleaseContext(hCatAdmin, 0);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    CloseHandle(hFile);
    MEMFREE(pHash);
    dl_CryptCATAdminReleaseContext(hCatAdmin, 0);
    return FALSE;
} // TrustCheckDriverFile()


//--------------------------------------------------------------------------;
//
//  UINT enumFile
//
//  Description:
//      Enum function for SetupScanFileQueue.
//
//  Arguments:
//      PVOID pContext: Defined when calling SetupScanFileQueue.
//
//      UINT uNotification: Type of notification.
//
//      UINT uParam1: Notification dependent.
//
//      UINT uParam2: Notification dependent.
//
//  Return (UINT): Returns NO_ERROR to continue enumerating.
//
//  History:
//      10/29/97    Fwong       Support function for SetupScanFileQueue
//
//--------------------------------------------------------------------------;

UINT CALLBACK enumFile
(
    PVOID    pContext,
    UINT     uNotification,
    UINT_PTR uParam1,
    UINT_PTR uParam2
)
{
    PINFFILELIST    pInfFileList = (PINFFILELIST)pContext;
    PTCHAR          pszFile = (PTCHAR)uParam1;
    UINT            uLen;

    switch (uNotification)
    {
        case SPFILENOTIFY_QUEUESCAN:
            //  Note: Adding +1 for zero terminator.

            uLen = lstrlen(pszFile) + 1;
            
            pInfFileList->uCount++;
            pInfFileList->cTotal += uLen;
            pInfFileList->uMaxLen = max(uLen, pInfFileList->uMaxLen);

            if(pInfFileList->cSize < (pInfFileList->uOffset + uLen + 1))
            {
                //  We are basically marking the buffer as "full"...

                pInfFileList->uOffset = pInfFileList->cSize;
                break;
            }

            lstrcpy(
                (LPTSTR)&(pInfFileList->pszFile[pInfFileList->uOffset]),
                pszFile);

            pInfFileList->uOffset += uLen;
            pInfFileList->pszFile[pInfFileList->uOffset] = 0;
            break;

        default:
            break;
    }

    return NO_ERROR;
} // enumFile()


//--------------------------------------------------------------------------;
//
//  void GetFullInfPath
//
//  Description:
//      Gets the full path to an .inf file.  This will be either:
//          [WINDOWS]\INF or [WINDOWS]\INF\OTHER.
//
//  WARNING!!!:  This will write over the current contents of the buffer.
//
//  Arguments:
//      LPTSTR pszInf: Pointer to the base inf file AND destination for
//                     full path.
//
//  Return (void):
//
//  History:
//      10/29/97    Fwong       Ported from AndyRaf.
//
//--------------------------------------------------------------------------;

void GetFullInfPath
(
    LPTSTR  pszInf
)
{
    HANDLE      hFile;
    TCHAR       szFullPath[MAX_PATH];
    TCHAR       szWinPath[MAX_PATH];

    if (!pszInf) return;
    if (!GetWindowsDirectory(szWinPath, NUMELMS(szWinPath))) return;

    //  Assuming the [WINDOWS]\INF directory...

    lstrcpy(szFullPath, szWinPath);
    lstrcat(szFullPath, TEXT("\\INF\\"));
    lstrcat(szFullPath, pszInf);

    //  Checking if it exists...

    hFile = CreateFile(
                szFullPath,
                0,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        lstrcpy(szFullPath, szWinPath);
        lstrcat(szFullPath, TEXT("\\INF\\OTHER\\"));
        lstrcat(szFullPath, pszInf);

        hFile = CreateFile(
                    szFullPath,
                    0,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

        if(INVALID_HANDLE_VALUE == hFile)
        {
            return;
        }

        CloseHandle(hFile);
    }
    else
    {
        CloseHandle(hFile);
    }

    lstrcpy(pszInf, szFullPath);
} // GetFullInfPath()


//--------------------------------------------------------------------------;
//
//  BOOL CertifyFilesFromQueue
//
//  Description:
//      Given a handle to a file queue, verify all the files in the queue
//      are certified.
//
//  Arguments:
//      HSPFILEQ hFileQ: Handle to queue.
//
//  Return (BOOL): TRUE if all certified, FALSE otherwise
//
//  History:
//      02/19/98    Fwong       Adding check for 'AlsoInstall'
//
//--------------------------------------------------------------------------;

BOOL CertifyFilesFromQueue
(
    HSPFILEQ    hFileQ
)
{
    INFFILELIST InfFileList;
    ULONG       ii;
    BOOL        fSuccess;
    LPTSTR      pszFile;
    
    ii = FILELISTSIZE * sizeof(TCHAR);

    InfFileList.uCount  = 0;
    InfFileList.uMaxLen = 0;
    InfFileList.uOffset = 0;
    InfFileList.cTotal  = 0;
    InfFileList.cSize   = ii / sizeof(TCHAR);
    InfFileList.pszFile = MEMALLOC_A(TCHAR, ii);

    if(NULL == InfFileList.pszFile)
    {
        return FALSE;
    }

    //  Creates the file list.

    fSuccess = dl_SetupScanFileQueue(
                hFileQ,
                SPQ_SCAN_USE_CALLBACK,
                NULL,
                enumFile,
                &(InfFileList),
                &ii);

    if(0 == InfFileList.uCount)
    {
        //  In the case that this is simply a registry add and NO FILES,
        //  we succeed.

        MEMFREE(InfFileList.pszFile);
        return TRUE;
    }

    if(InfFileList.uOffset == InfFileList.cSize)
    {
        //  Not enough memory.

        ii = sizeof(TCHAR) * (InfFileList.cTotal + 1);

        MEMFREE(InfFileList.pszFile);
        InfFileList.pszFile = MEMALLOC_A(TCHAR, ii);

        if(NULL == InfFileList.pszFile)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        InfFileList.uCount  = 0;
        InfFileList.uMaxLen = 0;
        InfFileList.uOffset = 0;
        InfFileList.cSize   = InfFileList.cTotal + 1;
        InfFileList.cTotal  = 0;

        fSuccess = dl_SetupScanFileQueue(
                    hFileQ,
                    SPQ_SCAN_USE_CALLBACK,
                    NULL,
                    enumFile,
                    &(InfFileList),
                    &ii);
    }

    if(!fSuccess)
    {
        MEMFREE(InfFileList.pszFile);
        return FALSE;
    }

    //  Walks the file list.
    //  Zero terminated strings with double termination at the end.

#ifndef UNICODE

    {
        WCHAR   *pszWide;
        UINT    uLen;

        pszWide = MEMALLOC_A(WCHAR, sizeof(WCHAR) * InfFileList.uMaxLen + 1);

        if(NULL == pszWide)
        {
            MEMFREE(InfFileList.pszFile);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        pszFile = InfFileList.pszFile;
        for(ii = InfFileList.uCount; ii; ii--)
        {
            uLen = lstrlen(pszFile);

            CharLowerBuff(pszFile, uLen);
            AnsiToUnicode(pszFile, pszWide, uLen + 1);
            fSuccess = TrustCheckDriverFile(pszWide);

            if(!fSuccess)
            {
                //  if any driver file fails, the driver is not certified.

                MEMFREE(pszWide);
                MEMFREE(InfFileList.pszFile);
                SetLastError(ERROR_BAD_DEVICE);
                return FALSE;
            }

            pszFile = &(pszFile[lstrlen(pszFile) + 1]);
        }

        MEMFREE(pszWide);
    }

#else  // UNICODE
    
    pszFile = InfFileList.pszFile;

    for(ii = InfFileList.uCount; ii; ii--)
    {
        CharLowerBuff(pszFile, lstrlen(pszFile));
        fSuccess = TrustCheckDriverFile(pszFile);
         
        if(!fSuccess)
        {
            //  if any driver file fails, the driver is not certified.

            MEMFREE(InfFileList.pszFile);
            SetLastError(ERROR_BAD_DEVICE);
            return FALSE;
        }

        pszFile = &(pszFile[lstrlen(pszFile) + 1]);
    }

#endif // UNICODE

    MEMFREE(InfFileList.pszFile);
    return TRUE;
} // CertifyFilesFromQueue()


//--------------------------------------------------------------------------;
//
//  BOOL CertifyInfSection
//
//  Description:
//      Certifies all files in a section in an .inf file are certified.
//
//  Arguments:
//      LPTSTR pszInf: Full pathed name to .inf file.
//
//      LPTSTR pszSection: Name of section.
//
//  Return (BOOL): TRUE if certified, FALSE otherwise.
//
//  History:
//      02/19/98    Fwong       Adding check for 'AlsoInstall'
//
//--------------------------------------------------------------------------;

BOOL CertifyInfSection
(
    LPTSTR  pszInf,
    LPTSTR  pszSection
)
{
    HINF        hInf;
    HSPFILEQ    hFileQ;
    BOOL        fSuccess;

    hInf = dl_SetupOpenInfFile(pszInf, NULL, INF_STYLE_WIN4, NULL);

    if(INVALID_HANDLE_VALUE == hInf)
    {
        return FALSE;
    }

    hFileQ = dl_SetupOpenFileQueue();

    if(INVALID_HANDLE_VALUE == hFileQ)
    {
        dl_SetupCloseInfFile(hInf);
        return FALSE;
    }

    //  Creates the file queue

    fSuccess = dl_SetupInstallFilesFromInfSection(
                hInf,
                NULL,
                hFileQ,
                pszSection,
                NULL,
                0);

    if(!fSuccess)
    {
        dl_SetupCloseFileQueue(hFileQ);
        dl_SetupCloseInfFile(hInf);
        return FALSE;
    }

    //  Checks the file queue.

    fSuccess = CertifyFilesFromQueue(hFileQ);

    dl_SetupCloseFileQueue(hFileQ);
    dl_SetupCloseInfFile(hInf);
    return fSuccess;
} // CertifyInfSection()


//--------------------------------------------------------------------------;
//
//  BOOL GetDriverCertificationAlsoInstall
//
//  Description:
//      Checking the 'AlsoInstall' section.
//
//  Arguments:
//      LPTSTR pszInf: Full-path name of the .inf for the device
//
//      LPTSTR pszSection: Name of the section for the device
//
//  Return (BOOL): TRUE if certified, FALSE otherwise
//
//  History:
//      02/19/98    Fwong       Adding check for 'AlsoInstall'
//
//--------------------------------------------------------------------------;

BOOL GetDriverCertificationAlsoInstall
(
    LPTSTR  pszInf,
    LPTSTR  pszSection
)
{
    TCHAR   szAlso[MAX_PATH];
    LPTSTR  pszStart, pszEnd;
    TCHAR   szNewInf[MAX_PATH];
    TCHAR   szNewSection[MAX_PATH];
    UINT    ii;

    ii = GetPrivateProfileString(
            pszSection,
            TEXT("AlsoInstall"),
            TEXT(""),
            szAlso,
            sizeof(szAlso)/sizeof(szAlso[0]),
            pszInf);

    if(0 == ii)
    {
        //  No 'AlsoInstall' entry.  Bolt!

        return TRUE;
    }

    // Read the line after AlsoInstall= in the driver's install section
    // e.g. AlsoInstall = Section1(Inf1.inf), Section2, Section3(Inf3.inf)

    pszEnd = &(szAlso[0]);

    for(;0 != *pszEnd;)
    {
        //  Parsing each entry.

        pszStart = pszEnd;

        //  Looking for separator/terminator.

        for(;(0 != *pszEnd) && (',' != *pszEnd); pszEnd++);

        //  If separator, we terminate THAT entry.

        if(',' == *pszEnd)
        {
            *pszEnd++ = 0;
        }

        //  Nuking leading spaces and copying.

        for(;' ' == *pszStart; pszStart++);
        lstrcpy(szNewSection, pszStart);

        //  Looking for .inf name if it exists.

        pszStart = &szNewSection[0];
        szNewInf[0] = 0;
        for(;(0 != *pszStart) && ('(' != *pszStart); pszStart++);

        if('(' == *pszStart)
        {
            //  inf entry exists.

            //  Terminating the section name.

            *pszStart++ = 0;

            //  Nuking the leading spaces and copying.
            for(;' ' == *pszStart; pszStart++);
            lstrcpy(szNewInf, pszStart);

            //  Nuking the trailing ')'.
            pszStart  = &(szNewInf[lstrlen(szNewInf) - 1]);
            for(;')' != *pszStart; pszStart--);
            *pszStart-- = 0;

            //  Nuking trailing spaces between end of .inf and ')'
            for(;' ' == *pszStart;)
            {
                *pszStart-- = 0;
            }

            //  Force to full pathed name.
            GetFullInfPath(szNewInf);
        }
        else
        {
            //  No .inf entry, use current .inf.

            lstrcpy(szNewInf, pszInf);
        }

        //  Nuking trailing spaces from section name.
        pszStart = &(szNewSection[lstrlen(szNewSection) - 1]);
        for(;' ' == *pszStart;)
        {
            *pszStart-- = 0;
        }

        //  Check files in .inf section.

        if(FALSE == CertifyInfSection(szNewInf, szNewSection))
        {
            return FALSE;
        }
    }

    return TRUE;
} // GetDriverCertificationAlsoInstall()


//--------------------------------------------------------------------------;
//
//  BOOL GetDriverCertificationStatus
//
//  Description:
//      Gets the certification status of the given driver (DevNode).
//
//  Arguments:
//      DWORD DevNode: DevNode for the driver.
//
//  Return (BOOL): TRUE if certified, otherwise FALSE and the error can be
//                 retrieved with a call to GetLastError().
//
//  History:
//      10/29/97    Fwong       Adding support.
//      12/22/97    Fwong       Modifying to check "Needs" section.
//      02/19/98    Fwong       Modifying to check "AlsoInstall" section.
//      07/06/00    AlanLu      Prefix Bug -- check memory allocation.
//
//--------------------------------------------------------------------------;

BOOL GetDriverCertificationStatus
(
    PCTSTR   pszDeviceInterface
)
{
    HDEVINFO                            hDevInfo;
    SP_DEVINFO_DATA                     DevInfoData;
    SP_DRVINFO_DATA                     DrvInfoData;
    SP_DEVICE_INTERFACE_DATA            did;
    SP_DEVINSTALL_PARAMS                InstParams;
    HKEY                                hKeyDev;
    HSPFILEQ                            hFileQ;
    DWORD                               ii, dw, dwType, cbSize;
    BOOL                                fSuccess;
    GUID                                guidClass = KSCATEGORY_AUDIO;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pdidd;
    TCHAR                               szSection[MAX_PATH];
    TCHAR                               szDevInst[MAX_PATH];

    cbSize = 300 * sizeof(TCHAR) + sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
    pdidd  = MEMALLOC_A(SP_DEVICE_INTERFACE_DETAIL_DATA, cbSize);

    if (pdidd == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    pdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

    ZeroMemory(&cdli, sizeof(CERTIFYDYNALOADINFO));
    if(!CertifyDynaLoad())
    {
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hDevInfo = dl_SetupDiGetClassDevs(
                &guidClass,
                NULL,
                NULL,
                DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (INVALID_HANDLE_VALUE == hDevInfo)
    {
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ZeroMemory(&did, sizeof(did));
    did.cbSize = sizeof(did);

    ZeroMemory(&DevInfoData, sizeof(SP_DEVINFO_DATA));
    DevInfoData.cbSize    = sizeof(SP_DEVINFO_DATA);
    DevInfoData.ClassGuid = KSCATEGORY_AUDIO;

    //  Enumerating all devices until match is found.

    for (ii = 0; ; ii++)
    {
        fSuccess = dl_SetupDiEnumDeviceInterfaces(
            hDevInfo,
            NULL,
            &guidClass,
            ii,
            &did);

        if (!fSuccess)
        {
            break;
        }

        fSuccess = dl_SetupDiGetDeviceInterfaceDetail(
            hDevInfo,
            &did,
            pdidd,
            cbSize,
            &dw,
            &DevInfoData);

        if (!fSuccess)
        {
            break;
        }

        if (0 == lstrcmpi(pdidd->DevicePath, pszDeviceInterface))
        {
            //  Just being paranoid and making sure the case of the
            //  string matches

            fSuccess = TRUE;
            break;
        }
    }

    if (!fSuccess)
    {
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //  Need device instance ID to open device info.

    if(!dl_SetupDiGetDeviceInstanceId(
        hDevInfo,
        &DevInfoData,
        szDevInst,
        (sizeof(szDevInst)/sizeof(szDevInst[0])),
        NULL))
    {
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    dl_SetupDiDestroyDeviceInfoList(hDevInfo);

    //  Creating a device info list and open up device info element for
    //  a device within that set.

    hDevInfo = dl_SetupDiCreateDeviceInfoList(NULL, NULL);

    if(INVALID_HANDLE_VALUE == hDevInfo)
    {
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ZeroMemory(&DevInfoData, sizeof(SP_DEVINFO_DATA));
    DevInfoData.cbSize     = sizeof(SP_DEVINFO_DATA);

    if(!dl_SetupDiOpenDeviceInfo(
        hDevInfo,
        szDevInst,
        NULL,
        0,
        &DevInfoData))
    {
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    ZeroMemory(&InstParams, sizeof(SP_DEVINSTALL_PARAMS));
    InstParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    //  Getting current settings, we'll be modifying some fields.

    if(!dl_SetupDiGetDeviceInstallParams(hDevInfo, &DevInfoData, &InstParams))
    {
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hKeyDev = dl_SetupDiOpenDevRegKey(
        hDevInfo,
        &DevInfoData,
        DICS_FLAG_GLOBAL,
        0,
        DIREG_DRV,
        KEY_ALL_ACCESS);

    if(INVALID_HANDLE_VALUE == hKeyDev)
    {
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //  Getting INF path and setting bit that says that we'll be using a
    //  single inf (vs directory).

    cbSize = sizeof(InstParams.DriverPath);
    ii = RegQueryValueEx(
        hKeyDev,
        REGSTR_VAL_INFPATH,
        NULL,
        &dwType,
        (LPBYTE)InstParams.DriverPath,
        &cbSize);

    if(ERROR_SUCCESS != ii)
    {
        RegCloseKey(hKeyDev);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    GetFullInfPath(InstParams.DriverPath);

    cbSize = sizeof(szSection);
    ii = RegQueryValueEx(
        hKeyDev,
        REGSTR_VAL_INFSECTION,
        NULL,
        &dwType,
        (LPBYTE)szSection,
        &cbSize);

    if(ERROR_SUCCESS != ii)
    {
        RegCloseKey(hKeyDev);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //  Checking the 'AlsoInstall' section

    if(FALSE == GetDriverCertificationAlsoInstall(
        InstParams.DriverPath,
        szSection))
    {
        //  Failed the check through 'AlsoInstall' section.

        RegCloseKey(hKeyDev);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        return FALSE;
    }

    InstParams.Flags |= DI_ENUMSINGLEINF;

    if(!dl_SetupDiSetDeviceInstallParams(hDevInfo, &DevInfoData, &InstParams))
    {
        RegCloseKey(hKeyDev);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //  Building class driver info list.

    if(!dl_SetupDiBuildDriverInfoList(hDevInfo, &DevInfoData, SPDIT_CLASSDRIVER))
    {
        RegCloseKey(hKeyDev);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //  Filling out DrvInfoData structure.

    ZeroMemory(&DrvInfoData, sizeof(DrvInfoData));

    cbSize = sizeof(DrvInfoData.ProviderName);
    ii = RegQueryValueEx(
        hKeyDev,
        REGSTR_VAL_PROVIDER_NAME,
        NULL,
        &dwType,
        (LPBYTE)DrvInfoData.ProviderName,
        &cbSize);

    if(ERROR_SUCCESS != ii)
    {
        DrvInfoData.ProviderName[0] = (TCHAR)(0);
    }

    if(!dl_SetupDiGetDeviceRegistryProperty(
        hDevInfo,
        &DevInfoData,
        SPDRP_MFG,
        NULL,
        (PBYTE)DrvInfoData.MfgName,
        sizeof(DrvInfoData.MfgName),
        NULL))
    {
        RegCloseKey(hKeyDev);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(!dl_SetupDiGetDeviceRegistryProperty(
        hDevInfo,
        &DevInfoData,
        SPDRP_DEVICEDESC,
        NULL,
        (PBYTE)DrvInfoData.Description,
        sizeof(DrvInfoData.Description),
        NULL))
    {
        RegCloseKey(hKeyDev);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DrvInfoData.cbSize     = sizeof(SP_DRVINFO_DATA);
    DrvInfoData.DriverType = SPDIT_CLASSDRIVER;
    DrvInfoData.Reserved   = 0;

    // Search for the driver and select it if found

    if(!dl_SetupDiSetSelectedDriver(hDevInfo, &DevInfoData, &DrvInfoData))
    {
        RegCloseKey(hKeyDev);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RegCloseKey(hKeyDev);

    //  Setting up file queue.

    hFileQ = dl_SetupOpenFileQueue();

    if(INVALID_HANDLE_VALUE == hFileQ)
    {
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ZeroMemory(&InstParams, sizeof(SP_DEVINSTALL_PARAMS));
    InstParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    //  Setting up a user-supplied queue and setting the bit to signify

    if(!dl_SetupDiGetDeviceInstallParams(hDevInfo, &DevInfoData, &InstParams))
    {
        dl_SetupCloseFileQueue(hFileQ);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        SetLastError(ERROR_INVALID_PARAMETER);
        MEMFREE(pdidd);
        return FALSE;
    }

    //  Adding options...

    InstParams.Flags     |= DI_NOVCP;
    InstParams.FileQueue  = hFileQ;

    if(!dl_SetupDiSetDeviceInstallParams(hDevInfo, &DevInfoData, &InstParams))
    {
        dl_SetupCloseFileQueue(hFileQ);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //  This fills up the queue.

    if(!dl_SetupDiCallClassInstaller(
            DIF_INSTALLDEVICEFILES,
            hDevInfo,
            &DevInfoData))
    {
        dl_SetupCloseFileQueue(hFileQ);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
     }
 
     //
     //  Removing options.  If we don't do this before closing the file queue
     //  and destroying the device info list, we get memory leaks in setupapi.
     //
 
     InstParams.Flags     &= (~DI_NOVCP);
     InstParams.FileQueue  = NULL;
 
     if(!dl_SetupDiSetDeviceInstallParams(hDevInfo, &DevInfoData, &InstParams))
     {
        dl_SetupCloseFileQueue(hFileQ);
        dl_SetupDiDestroyDeviceInfoList(hDevInfo);
        CertifyDynaFree();
        MEMFREE(pdidd);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //  Checks the files in the queue

    fSuccess = CertifyFilesFromQueue(hFileQ);

    dl_SetupCloseFileQueue(hFileQ);
    dl_SetupDiDestroyDeviceInfoList(hDevInfo);
    CertifyDynaFree();
    MEMFREE(pdidd);

    return fSuccess;
} // GetDriverCertificationStatus()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vmaxhead.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vmaxintheader.h
 *  Content:    
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/

#if !defined(VMAXINTHEADER_HEADER)
#define VMAXINTHEADER_HEADER
#pragma once

// ---------------------------------------------------------------------------
// Enumerations

// Output channel tags
enum EChannel {
	tagLeft,
	tagRight,
	echannelCount
};

// Filter tags, used as alias for EChannel tags
enum EFilter {
	tagDelta,
	tagSigma,
	efilterCount
};

// Parameters
enum EParameter {
	tagAzimuth,
	tagElevation,
	tagDistance,
	eparameterCount
};

// Properties
enum EProperty {
	tagValue,
	tagMinimum,
	tagMaximum,
	tagResolution,
	epropertyCount
};

// Localization modes
enum ELocalizationMode {
	tagNoLocalization,
	tagStereo,
	tagVMAx,
	tagOldDS3DHEL,
	elocalizationmodeCount
};

// Loudspeaker configurations
enum ESpeakerConfig {
	tagSpeakers10Degrees,
	tagSpeakers20Degrees,
	tagHeadphones,
	espeakerconfigCount
};

// Sample rates
enum ESampleRate {
	tag8000Hz,
	tag11025Hz,
	tag16000Hz,
	tag22050Hz,
	tag32000Hz,
	tag44100Hz,
	tag48000Hz,
	esamplerateCount
};

// Filter methods
enum EFilterMethod {
	tagCanonical,
	tagJackson,
	efiltermethodCount
};

// DirectSound cooperative levels
enum ECoopLevel {
	tagNormal,
	tagPriority,
	tagExclusive,
	ecooplevelCount
};

// DirectSound speaker configurations
enum EDSSpeakerConfig {
	tagDSHeadphones,
	tagDSSpeakers5Degrees,
	tagDSSpeakers10Degrees,
	tagDSSpeakers20Degrees,
	edsspeakerconfigCount
};

#endif

// End of VMAXINTHEADER.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vxdvad.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vxdvad.h
 *  Content:    VxD Virtual Audio Device class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/23/97     dereks  Created
 *
 ***************************************************************************/

#ifndef __VXDVAD_H__
#define __VXDVAD_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define VIDMEMONLY
//#include "ddheap.h"
#include "dmemmgr.h"

#ifdef __cplusplus
}
#endif // __cplusplus

#ifdef __cplusplus

typedef struct tagDYNALOAD_DDRAW
{
    DYNALOAD Header;

    LPVMEMHEAP (WINAPI *VidMemInit)        (DWORD, FLATPTR, FLATPTR, DWORD, DWORD);
    void       (WINAPI *VidMemFini)        (LPVMEMHEAP);
    DWORD      (WINAPI *VidMemAmountFree)  (LPVMEMHEAP);
    DWORD      (WINAPI *VidMemLargestFree) (LPVMEMHEAP);
    FLATPTR    (WINAPI *VidMemAlloc)       (LPVMEMHEAP, DWORD, DWORD);
    void       (WINAPI *VidMemFree)        (LPVMEMHEAP, FLATPTR);
} DYNALOAD_DDRAW, *LPDYNALOAD_DDRAW;

// Forward declaration
class CVxdMemBuffer;

// The Vxd Audio Device class
class CVxdRenderDevice : public CMxRenderDevice, private CUsesEnumStandardFormats
{
    friend class CVxdPrimaryRenderWaveBuffer;
    friend class CVxdSecondaryRenderWaveBuffer;
    friend class CHybridSecondaryRenderWaveBuffer;

private:
    DYNALOAD_DDRAW                  m_dlDDraw;

protected:
    CVxdPropertySet *               m_pPropertySet;                 // Property set object
    CVxdPrimaryRenderWaveBuffer *   m_pWritePrimaryBuffer;          // Primary buffer with write access
    DSDRIVERDESC                    m_dsdd;                         // Vxd driver description
    HANDLE                          m_hHal;                         // Driver handle
    HANDLE                          m_hHwBuffer;                    // Primary buffer handle
    LPBYTE                          m_pbHwBuffer;                   // Primary buffer memory
    DWORD                           m_cbHwBuffer;                   // Size of above buffer
    LPVMEMHEAP                      m_pDriverHeap;                  // Driver memory heap
    HWAVEOUT                        m_hwo;                          // waveOut device handle
    LARGE_INTEGER                   m_liDriverVersion;              // Driver version number

public:
    CVxdRenderDevice(void);
    virtual ~CVxdRenderDevice(void);

    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Creation
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCaps(LPDSCAPS);
    virtual HRESULT GetCertification(LPDWORD, BOOL);

    // Buffer management
    virtual HRESULT CreatePrimaryBuffer(DWORD, LPVOID, CPrimaryRenderWaveBuffer **);
    virtual HRESULT CreateSecondaryBuffer(LPCVADRBUFFERDESC, LPVOID, CSecondaryRenderWaveBuffer **);
    virtual HRESULT CreateVxdSecondaryBuffer(LPCVADRBUFFERDESC, LPVOID, CSysMemBuffer *, CVxdSecondaryRenderWaveBuffer **);

protected:
    virtual HRESULT LockMixerDestination(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD);
    virtual HRESULT UnlockMixerDestination(LPVOID, DWORD, LPVOID, DWORD);

private:
    HRESULT AcquireDDraw(void);
    void ReleaseDDraw(void);
    BOOL EnumStandardFormatsCallback(LPCWAVEFORMATEX);
    BOOL CanMixInRing0(void);
};

// VxD property set object
class CVxdPropertySet : public CPropertySet
{
private:
    LPVOID                  m_pDsDriverPropertySet; // Driver property set object
    LPVOID                  m_pvInstance;           // Instance identifier

public:
    CVxdPropertySet(LPVOID);
    virtual ~CVxdPropertySet(void);

    // Initialization
    virtual HRESULT Initialize(HANDLE);

    // Property support
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG);
    virtual HRESULT QuerySetSupport(REFGUID);

    // Property data
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);
    virtual HRESULT GetDsProperty(REFGUID, ULONG, LPVOID, ULONG);
    virtual HRESULT SetDsProperty(REFGUID, ULONG, LPVOID, ULONG);
};

inline HRESULT CVxdPropertySet::GetDsProperty(REFGUID guid, ULONG ulId, LPVOID pvData, ULONG cbData)
{
    return GetProperty(guid, ulId, NULL, 0, pvData, &cbData);
}

inline HRESULT CVxdPropertySet::SetDsProperty(REFGUID guid, ULONG ulId, LPVOID pvData, ULONG cbData)
{
    return SetProperty(guid, ulId, NULL, 0, pvData, cbData);
}

// VxD 3D listener
class CVxd3dListener : public C3dListener
{
    friend class CVxd3dListener;

protected:
    CVxdPropertySet *           m_pPropertySet;         // Property set object
    BOOL                        m_fAllocated;           // Is the hardware listener allocated?

public:
    CVxd3dListener(CVxdPropertySet *);
    virtual ~CVxd3dListener(void);

    // Initialization
    virtual HRESULT Initialize(void);

    // Commiting deferred data
    virtual HRESULT CommitDeferred(void);

    // Listener/world properties
    virtual HRESULT SetDistanceFactor(FLOAT, BOOL);
    virtual HRESULT SetDopplerFactor(FLOAT, BOOL);
    virtual HRESULT SetRolloffFactor(FLOAT, BOOL);
    virtual HRESULT SetOrientation(REFD3DVECTOR, REFD3DVECTOR, BOOL);
    virtual HRESULT SetPosition(REFD3DVECTOR, BOOL);
    virtual HRESULT SetVelocity(REFD3DVECTOR, BOOL);
    virtual HRESULT SetAllParameters(LPCDS3DLISTENER, BOOL);

    // Speaker configuration
    virtual HRESULT SetSpeakerConfig(DWORD);

    // Listener location
    virtual DWORD GetListenerLocation(void);
};

inline DWORD CVxd3dListener::GetListenerLocation(void)
{
    return C3dListener::GetListenerLocation() | DSBCAPS_LOCHARDWARE;
}

// VxD 3D object
class CVxd3dObject : public C3dObject
{
protected:
    CVxdPropertySet *           m_pPropertySet;         // Property set object

public:
    CVxd3dObject(CVxd3dListener *, CVxdPropertySet *, BOOL);
    virtual ~CVxd3dObject(void);

    // Initialization
    virtual HRESULT Initialize(void);

    // Commiting deferred data
    virtual HRESULT CommitDeferred(void);

    // Object properties
    virtual HRESULT SetConeAngles(DWORD, DWORD, BOOL);
    virtual HRESULT SetConeOrientation(REFD3DVECTOR, BOOL);
    virtual HRESULT SetConeOutsideVolume(LONG, BOOL);
    virtual HRESULT SetMaxDistance(FLOAT, BOOL);
    virtual HRESULT SetMinDistance(FLOAT, BOOL);
    virtual HRESULT SetMode(DWORD, BOOL);
    virtual HRESULT SetPosition(REFD3DVECTOR, BOOL);
    virtual HRESULT SetVelocity(REFD3DVECTOR, BOOL);
    virtual HRESULT SetAllParameters(LPCDS3DBUFFER, BOOL);

    // Buffer recalc
    virtual HRESULT Recalc(DWORD, DWORD);

    // Object location
    virtual DWORD GetObjectLocation(void);
};

inline DWORD CVxd3dObject::GetObjectLocation(void)
{
    return DSBCAPS_LOCHARDWARE;
}

// VxD primary buffer
class CVxdPrimaryRenderWaveBuffer : public CPrimaryRenderWaveBuffer
{
private:
    CVxdRenderDevice *  m_pVxdDevice;           // Parent device

public:
    CVxdPrimaryRenderWaveBuffer(CVxdRenderDevice *, LPVOID);
    virtual ~CVxdPrimaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(DWORD);

    // Access rights
    virtual HRESULT RequestWriteAccess(BOOL);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dListener(C3dListener **);
};

// VxD/Emulated wrapper secondary buffer
class CHybridSecondaryRenderWaveBuffer : public CSecondaryRenderWaveBuffer
{
private:
    CVxdRenderDevice *              m_pVxdDevice;       // Parent device
    CSecondaryRenderWaveBuffer *    m_pBuffer;          // The real buffer
    LONG                            m_lVolume;          // Buffer volume
    LONG                            m_lPan;             // Buffer pan
    BOOL                            m_fMute;            // Buffer mute state
    DWORD                           m_dwPositionCache;  // Position cache

public:
    CHybridSecondaryRenderWaveBuffer(CVxdRenderDevice *, LPVOID);
    virtual ~CHybridSecondaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(LPCVADRBUFFERDESC, CHybridSecondaryRenderWaveBuffer *);

    // Resource allocation
    virtual HRESULT AcquireResources(DWORD);
    virtual HRESULT DuplicateResources(CHybridSecondaryRenderWaveBuffer *);
    virtual HRESULT StealResources(CSecondaryRenderWaveBuffer *);
    virtual HRESULT FreeResources(void);

    // Buffer creation
    virtual HRESULT Duplicate(CSecondaryRenderWaveBuffer **);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCursorPosition(DWORD);

    // Buffer properties
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN);
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetChannelAttenuations(LONG, DWORD, const DWORD*,  const LONG*);
#endif // FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetFrequency(DWORD, BOOL fClamp =FALSE);
    virtual HRESULT SetMute(BOOL);

    // Buffer position notifications
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dObject(C3dListener *, C3dObject **);

private:
    virtual HRESULT AcquireHardwareResources(void);
    virtual HRESULT AcquireSoftwareResources(void);
    virtual HRESULT HandleResourceAcquisition(void);
    virtual BOOL HasAcquiredResources(void);
};

inline HRESULT CHybridSecondaryRenderWaveBuffer::StealResources(CSecondaryRenderWaveBuffer *)
{
    return DSERR_UNSUPPORTED;
}

inline BOOL CHybridSecondaryRenderWaveBuffer::HasAcquiredResources(void)
{
    return MAKEBOOL(m_pBuffer);
}

// VxD secondary buffer
class CVxdSecondaryRenderWaveBuffer : public CSecondaryRenderWaveBuffer
{
private:
    CVxdRenderDevice *  m_pVxdDevice;           // Parent device
    CVxdPropertySet *   m_pPropertySet;         // Property set object
    CVxdMemBuffer *     m_pHwMemBuffer;         // Hardware memory buffer
    HANDLE              m_hHwBuffer;            // Hardware buffer handle
    LPBYTE              m_pbHwBuffer;           // Hardware buffer memory
    DWORD               m_cbHwBuffer;           // Size of above buffer
    DWORD               m_dwState;              // Current buffer state
    DSVOLUMEPAN         m_dsvp;                 // Current attenuation levels
    BOOL                m_fMute;                // Current buffer mute state

public:
    CVxdSecondaryRenderWaveBuffer(CVxdRenderDevice *, LPVOID);
    virtual ~CVxdSecondaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(LPCVADRBUFFERDESC, CVxdSecondaryRenderWaveBuffer *, CSysMemBuffer *);

    // Buffer creation
    virtual HRESULT Duplicate(CSecondaryRenderWaveBuffer **);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCursorPosition(DWORD);

    // Buffer properties
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN);
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetChannelAttenuations(LONG, DWORD, const DWORD*,  const LONG*);
#endif // FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetFrequency(DWORD, BOOL fClamp =FALSE);
    virtual HRESULT SetMute(BOOL);

    // Buffer position notifications
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dObject(C3dListener *, C3dObject **);
};

// Utility hardware memory buffer object
class CVxdMemBuffer : public CDsBasicRuntime
{
private:
    LPVMEMHEAP          m_pHeap;                // Hardware memory heap
    DWORD               m_dwAllocExtra;         // Number of extra bytes to allocate
    DWORD               m_dwBuffer;             // Hardware memory buffer address
    DWORD               m_cbBuffer;             // Hardware memory buffer size
    LPDYNALOAD_DDRAW    m_pDlDDraw;             // Pointer to DDRAW function table

public:
    CVxdMemBuffer(LPVMEMHEAP, DWORD, LPDYNALOAD_DDRAW);
    virtual ~CVxdMemBuffer(void);

    // Initialization
    virtual HRESULT Initialize(DWORD);

    // Buffer properties
    virtual LPVMEMHEAP GetHeap(void);
    virtual DWORD GetAllocExtra(void);
    virtual DWORD GetAddress(void);
    virtual DWORD GetSize(void);
};

inline CVxdMemBuffer::CVxdMemBuffer(LPVMEMHEAP pHeap, DWORD dwAllocExtra, LPDYNALOAD_DDRAW pDlDDraw)
{
    m_pHeap = pHeap;
    m_dwAllocExtra = dwAllocExtra;
    m_dwBuffer = 0;
    m_cbBuffer = 0;
    m_pDlDDraw = pDlDDraw;
}

inline CVxdMemBuffer::~CVxdMemBuffer(void)
{
    if(m_dwBuffer)
    {
        // Just in case any CVxdMemBuffers outlive their creator:
        ASSERT(m_pDlDDraw->VidMemFree != NULL);
        m_pDlDDraw->VidMemFree(m_pHeap, m_dwBuffer);
    }
}

inline HRESULT CVxdMemBuffer::Initialize(DWORD cbBuffer)
{
    HRESULT                 hr  = DS_OK;

    m_cbBuffer = cbBuffer;

    if(m_pHeap)
    {
        m_dwBuffer = m_pDlDDraw->VidMemAlloc(m_pHeap, cbBuffer + m_dwAllocExtra, 1);
        hr = HRFROMP(m_dwBuffer);
    }

    return hr;
}

inline LPVMEMHEAP CVxdMemBuffer::GetHeap(void)
{
    return m_pHeap;
}

inline DWORD CVxdMemBuffer::GetAllocExtra(void)
{
    return m_dwAllocExtra;
}

inline DWORD CVxdMemBuffer::GetAddress(void)
{
    return m_dwBuffer;
}

inline DWORD CVxdMemBuffer::GetSize(void)
{
    return m_cbBuffer;
}

#endif // __cplusplus

#endif // __VXDVAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\winmain.cpp ===
/* Figure out why we need this */
void __stdcall wWinMain(int,int,int,int)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vmaxcoef.inl ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vmaxintcoeffs.h
 *  Content:    
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/

#if !defined(VMAXINTCOEFFS_INLINE)
#define VMAXINTCOEFFS_INLINE
#pragma once

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

#if !defined(_DEBUG)
#define INLINE _inline
#else
#define INLINE
#endif

// ---------------------------------------------------------------------------
// Global helper functions

// Convert number of biquads to corresponding number of biquad coefficients
INLINE UINT NumBiquadsToNumBiquadCoeffs(const UINT CuiNumBiquads)
{
	return CuiNumBiquads * ebiquadcoefftypeCount;
}

// Convert number of biquad coefficients to corresponding number of biquads
INLINE UINT NumBiquadCoeffsToNumBiquads(const UINT CuiNumBiquadCoeffs)
{
	return CuiNumBiquadCoeffs / ebiquadcoefftypeCount;
}

// Convert number of canonical coefficients to number of A or B coefficients in canonical filter (filter half)
INLINE UINT NumCanonicalCoeffsToHalf(const UINT CuiNumCanonicalCoeffs)
{
	return (CuiNumCanonicalCoeffs + 1) / ecanonicalcoefftypeCount;
}

#ifndef BUILD_LUT
// Convert floating-point biquad coefficient to SHORT biquad coefficient (by scaling)
INLINE SHORT FloatBiquadCoeffToShortBiquadCoeff(const float CfBiquadCoeff)
{
	return (SHORT)(MAX_SHORT * CfBiquadCoeff);
}
#endif // BUILD_LUT

#endif

// End of VMAXINTCOEFFS.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\vxdvad.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vxdvad.cpp
 *  Content:    VxD Virtual Audio Device class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/23/97     dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifdef NOVXD
#error vxdvad.cpp being built with NOVXD defined.
#endif

#include "dsoundi.h"
#include "dsvxd.h"

// Property set helper macros
#define GetDsPropertyQuick(set, id, data) \
            GetDsProperty(set, id, (LPVOID)(data), sizeof(*(data)))

#define SetDsPropertyQuick(set, id, data) \
            SetDsProperty(set, id, (LPVOID)(data), sizeof(*(data)))


/***************************************************************************
 *
 *  CVxdRenderDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::CVxdRenderDevice"

CVxdRenderDevice::CVxdRenderDevice(void)
    : CMxRenderDevice(VAD_DEVICETYPE_VXDRENDER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CVxdRenderDevice);

    // Initialize defaults
    m_pPropertySet = NULL;
    m_pWritePrimaryBuffer = NULL;
    m_hHal = NULL;
    m_hHwBuffer = NULL;
    m_pbHwBuffer = NULL;
    m_cbHwBuffer = DEF_PRIMARY_SIZE;
    m_pDriverHeap = NULL;
    m_hwo = NULL;
    m_liDriverVersion.QuadPart = 0;

    // DDRAW.DLL dynaload function table
    ZeroMemory(&m_dlDDraw, sizeof m_dlDDraw);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CVxdRenderDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::~CVxdRenderDevice"

CVxdRenderDevice::~CVxdRenderDevice(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CVxdRenderDevice);

    // Free the mixer
    FreeMixer();

    // Free the property set object
    if(m_pPropertySet)
    {
        ABSOLUTE_RELEASE(m_pPropertySet);
    }

    // Free the hardware primary buffer
    if(m_hHwBuffer)
    {
        VxdBufferRelease(m_hHwBuffer);
    }

    // Free the driver heap
    if(m_pDriverHeap && m_dsdd.dwHeapType & DSDHEAP_CREATEHEAP)
    {
        m_dlDDraw.VidMemFini(m_pDriverHeap);
    }

    // Close the driver
    if(m_hHal)
    {
        VxdDrvClose(m_hHal);
    }

    // Close the waveOut device
    if(m_hwo)
    {
        CloseWaveOut(&m_hwo);
    }

    // Free the DDRAW.DLL library
    ReleaseDDraw();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumDrivers
 *
 *  Description:
 *      Creates a list of driver GUIDs that can be used to initialize this
 *      device.
 *
 *  Arguments:
 *      CList* [in/out]: CList object that will be filled with DSDRVENUMDESC
 *                       structures.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::EnumDrivers"

HRESULT CVxdRenderDevice::EnumDrivers(CObjectList<CDeviceDescription> *plstDrivers)
{
    CDeviceDescription *    pDesc           = NULL;
    LPGUID                  pguidLast       = NULL;
    HRESULT                 hr, hrTemp;
    GUID                    guidLast;
    GUID                    guidThis;
    DSDRIVERDESC            dsdd;

    DPF_ENTER();

    // Make sure ddraw.dll is loaded
    hr = AcquireDDraw();

    // Make sure dsound.vxd is loaded
    if(SUCCEEDED(hr) && !g_hDsVxd)
    {
        DPF(DPFLVL_ERROR, "DSOUND.VXD not loaded");
        hr = DSERR_NODRIVER;
    }

    // Enumerate all VxD drivers
    while(SUCCEEDED(hr))
    {
        // Get the next driver description.  If we failed to get the
        // driver desc, it's probably just because there's no more drivers.
        hrTemp = VxdDrvGetNextDriverDesc(pguidLast, &guidThis, &dsdd);

        if(FAILED(hrTemp))
        {
            break;
        }

        // Create the device description object and add it to the
        // list
        pDesc = NEW(CDeviceDescription(m_vdtDeviceType, guidThis));
        hr = HRFROMP(pDesc);

        if(SUCCEEDED(hr))
        {
            pDesc->m_strName = dsdd.szDesc;
            pDesc->m_strPath = dsdd.szDrvname;
            pDesc->m_dwDevnode = dsdd.dnDevNode;

            GetWaveDeviceIdFromDevnode(dsdd.dnDevNode, FALSE, &pDesc->m_uWaveDeviceId);

            hr = HRFROMP(plstDrivers->AddNodeToList(pDesc));
        }

        RELEASE(pDesc);

        // Go on to the next device
        if(SUCCEEDED(hr))
        {
            guidLast = guidThis;
            pguidLast = &guidLast;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      LPCDSDRVENUMDESC [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::Initialize"

HRESULT CVxdRenderDevice::Initialize(CDeviceDescription *pDesc)
{
    LPWAVEFORMATEX          pwfxFormat  = NULL;
    HRESULT                 hr, hrTemp;

    DPF_ENTER();

    // Initialize the base class
    hr = CMxRenderDevice::Initialize(pDesc);

    // Make sure dsound.vxd is loaded
    if(SUCCEEDED(hr) && !g_hDsVxd)
    {
        DPF(DPFLVL_ERROR, "DSOUND.VXD not loaded");
        hr = DSERR_NODRIVER;
    }

    // Make sure ddraw.dll is loaded
    if(SUCCEEDED(hr))
    {
        hr = AcquireDDraw();
    }

    // Save the driver description
    if(SUCCEEDED(hr))
    {
        hr = VxdDrvGetDesc(pDesc->m_guidDeviceId, &m_dsdd);

        if(SUCCEEDED(hr))
        {
            DPF(DPFLVL_MOREINFO, "dwFlags = 0x%8.8lX", m_dsdd.dwFlags);
            DPF(DPFLVL_MOREINFO, "szDesc = %s", m_dsdd.szDesc);
            DPF(DPFLVL_MOREINFO, "szDrvname = %s", m_dsdd.szDrvname);
            DPF(DPFLVL_MOREINFO, "dnDevNode = 0x%8.8lX", m_dsdd.dnDevNode);
            DPF(DPFLVL_MOREINFO, "wVxdId = %u", m_dsdd.wVxdId);
            DPF(DPFLVL_MOREINFO, "wReserved = %u", m_dsdd.wReserved);
            DPF(DPFLVL_MOREINFO, "ulDeviceNum = %lu", m_dsdd.ulDeviceNum);
            DPF(DPFLVL_MOREINFO, "dwHeapType = %lu", m_dsdd.dwHeapType);
            DPF(DPFLVL_MOREINFO, "pvDirectDrawHeap = 0x%p", m_dsdd.pvDirectDrawHeap);
            DPF(DPFLVL_MOREINFO, "dwMemStartAddress = 0x%8.8lX", m_dsdd.dwMemStartAddress);
            DPF(DPFLVL_MOREINFO, "dwMemEndAddress = 0x%8.8lX", m_dsdd.dwMemEndAddress);
            DPF(DPFLVL_MOREINFO, "dwMemAllocExtra = %lu", m_dsdd.dwMemAllocExtra);
            DPF(DPFLVL_MOREINFO, "pvReserved1 = 0x%p", m_dsdd.pvReserved1);
            DPF(DPFLVL_MOREINFO, "pvReserved2 = 0x%p", m_dsdd.pvReserved2);
        }
        else
        {
            DPF(DPFLVL_ERROR, "Unable to get driver description");
        }
    }

    if(SUCCEEDED(hr) && (m_dsdd.dwFlags & DSDDESC_DOMMSYSTEMSETFORMAT))
    {
        ASSERT(m_dsdd.dwFlags & DSDDESC_DOMMSYSTEMOPEN);
        m_dsdd.dwFlags |= DSDDESC_DOMMSYSTEMOPEN;
    }

    // Get the driver version number
    if(SUCCEEDED(hr))
    {
        GetDriverVersion(&m_liDriverVersion);
    }

    // Get the default format
    if(SUCCEEDED(hr))
    {
        pwfxFormat = AllocDefWfx();
        hr = HRFROMP(pwfxFormat);
    }

    // Spin through standard formats, looking for one that works.  Within
    // OpenDriverCallback, we'll open the the waveOut device, open the driver,
    // initialize on-card memory and create the primary buffer.  OpenDriverCallback
    // expects m_dsded.guid to be initialized before calling, so set that
    // up while we're at it.
    if(SUCCEEDED(hr))
    {
        if(!EnumStandardFormats(pwfxFormat, pwfxFormat))
        {
            // If no formats work at all, the device is probably allocated
            hr = DSERR_ALLOCATED;
        }
    }

    // Create the primary buffer property set object.  Note that this property
    // set object does not have any instance data associated with it, and so
    // can only be used for global properties (i.e. speaker config).
    if(SUCCEEDED(hr) && !(m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWPROPSETS))
    {
        m_pPropertySet = NEW(CVxdPropertySet(NULL));
        hr = HRFROMP(m_pPropertySet);
    }

    if(SUCCEEDED(hr) && m_pPropertySet)
    {
        hrTemp = m_pPropertySet->Initialize(m_hHwBuffer);

        // We only need to keep the property set around if the driver supports
        // DSPROPSETID_DirectSoundSpeakerConfig.  Each primary buffer object
        // will create it's own property set object.
        if(SUCCEEDED(hrTemp))
        {
            hrTemp = m_pPropertySet->QuerySetSupport(DSPROPSETID_DirectSoundSpeakerConfig);
        }

        // If we failed, that's ok.  We just won't support hardware property
        // sets on the device.
        if(FAILED(hrTemp))
        {
            RELEASE(m_pPropertySet);
        }
    }

    // Clean up
    MEMFREE(pwfxFormat);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  AcquireDDraw
 *
 *  Description:
 *      Initializes the DDRAW function table if necessary.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::AcquireDDraw"

HRESULT CVxdRenderDevice::AcquireDDraw(void)
{
    const LPCSTR apszFunctions[] =
    {
        "VidMemInit",
        "VidMemFini",
        "VidMemAmountFree",
        "VidMemLargestFree",
        "VidMemAlloc",
        "VidMemFree"
    };

    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_dlDDraw.Header.dwSize == 0)
    {
        m_dlDDraw.Header.dwSize = sizeof m_dlDDraw;
        if (!InitDynaLoadTable(TEXT("ddraw.dll"), apszFunctions, NUMELMS(apszFunctions), &m_dlDDraw.Header))
        {
            RPF(DPFLVL_ERROR, "Failed to load DDRAW.DLL");
            hr = DSERR_GENERIC;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  ReleaseDDraw
 *
 *  Description:
 *      Releases the DDRAW.DLL library if necessary.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::ReleaseDDraw"

void CVxdRenderDevice::ReleaseDDraw(void)
{
    DPF_ENTER();

    if (m_dlDDraw.Header.dwSize != 0)
    {
        FreeDynaLoadTable(&m_dlDDraw.Header);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCAPS structure with the capabilities of the device.
 *
 *  Arguments:
 *      LPDSCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::GetCaps"

HRESULT CVxdRenderDevice::GetCaps(LPDSCAPS pCaps)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    ASSERT(sizeof(*pCaps) == pCaps->dwSize);

    // Get driver caps
    ZeroMemoryOffset(pCaps, pCaps->dwSize, sizeof(pCaps->dwSize));

    hr = VxdDrvGetCaps(m_hHal, (PDSDRIVERCAPS)((LPBYTE)pCaps + sizeof(pCaps->dwSize)));

    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "VxdDrvGetCaps failed with %s", HRESULTtoSTRING(hr));
    }

    // Mask off invalid flags
    if(SUCCEEDED(hr))
    {
        pCaps->dwFlags &= DSCAPS_VALIDDRIVERFLAGS;
    }

    // Fill in memory values
    if(SUCCEEDED(hr) && m_pDriverHeap)
    {
        pCaps->dwFreeHwMemBytes = m_dlDDraw.VidMemAmountFree(m_pDriverHeap);
        pCaps->dwMaxContigFreeHwMemBytes = m_dlDDraw.VidMemLargestFree(m_pDriverHeap);
    }

    // Handle acceleration flags
    if(SUCCEEDED(hr) && (m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS))
    {
        pCaps->dwMaxHwMixingAllBuffers = 0;
        pCaps->dwMaxHwMixingStaticBuffers = 0;
        pCaps->dwMaxHwMixingStreamingBuffers = 0;
        pCaps->dwFreeHwMixingAllBuffers = 0;
        pCaps->dwFreeHwMixingStaticBuffers = 0;
        pCaps->dwFreeHwMixingStreamingBuffers = 0;
    }

    if(SUCCEEDED(hr) && ((m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS) || (m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D)))
    {
        pCaps->dwMaxHw3DAllBuffers = 0;
        pCaps->dwMaxHw3DStaticBuffers = 0;
        pCaps->dwMaxHw3DStreamingBuffers = 0;
        pCaps->dwFreeHw3DAllBuffers = 0;
        pCaps->dwFreeHw3DStaticBuffers = 0;
        pCaps->dwFreeHw3DStreamingBuffers = 0;
    }

    // Fill in the driver version
    if(SUCCEEDED(hr))
    {
        pCaps->dwReserved1 = m_liDriverVersion.LowPart;
        pCaps->dwReserved2 = m_liDriverVersion.HighPart;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCertification
 *
 *  Description:
 *      Returns the certification status of the driver.
 *
 *  Arguments:
 *      LPDWORD [out]: receives certification status.
 *      BOOL [in]: whether we're called by GetCaps, ignored for vxd's
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::GetCertification"

HRESULT CVxdRenderDevice::GetCertification(LPDWORD pdwCertification, BOOL)
{
    DWORD                   dwSum;
    LPSTR                   psz;

    DPF_ENTER();

    // Figure out if we're running on a certified driver.  Sum of driver
    // filename chars + DSCAPS_FILENAMECOOKIE mod DSCAPS_FILENAMEMODVALUE
    // must equal dsDrvDesc.wReserved.
    for(psz = m_dsdd.szDrvname, dwSum = DSCAPS_FILENAMECOOKIE; *psz; psz++)
    {
        dwSum += *psz;
    }

    *pdwCertification = (dwSum % DSCAPS_FILENAMEMODVALUE == m_dsdd.wReserved) ? VERIFY_CERTIFIED : VERIFY_UNCERTIFIED;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  CreatePrimaryBuffer
 *
 *  Description:
 *      Creates a primary buffer object.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      LPVOID [in]: buffer instace identifier.
 *      CPrimaryRenderWaveBuffer ** [out]: receives pointer to primary buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::CreatePrimaryBuffer"

HRESULT CVxdRenderDevice::CreatePrimaryBuffer(DWORD dwFlags, LPVOID pvInstance, CPrimaryRenderWaveBuffer **ppBuffer)
{
    CVxdPrimaryRenderWaveBuffer *   pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    pBuffer = NEW(CVxdPrimaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateSecondaryBuffer
 *
 *  Description:
 *      Creates a secondary wave buffer.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      LPVOID [in]: instance identifier.
 *      CSecondaryRenderWaveBuffer ** [out]: receives pointer to new wave
 *                                           buffer.  Use Release to free
 *                                           this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::CreateSecondaryBuffer"

HRESULT CVxdRenderDevice::CreateSecondaryBuffer(LPCVADRBUFFERDESC pDesc, LPVOID pvInstance, CSecondaryRenderWaveBuffer **ppBuffer)
{
    CHybridSecondaryRenderWaveBuffer *  pBuffer = NULL;
    HRESULT                             hr;

    DPF_ENTER();

    pBuffer = NEW(CHybridSecondaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(pDesc, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateVxdSecondaryBuffer
 *
 *  Description:
 *      Creates a secondary wave buffer.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      LPVOID [in]: instance identifier.
 *      CSecondaryRenderWaveBuffer ** [out]: receives pointer to new wave
 *                                           buffer.  Use Release to free
 *                                           this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::CreateVxdSecondaryBuffer"

HRESULT CVxdRenderDevice::CreateVxdSecondaryBuffer(LPCVADRBUFFERDESC pDesc, LPVOID pvInstance, CSysMemBuffer *pSysMemBuffer, CVxdSecondaryRenderWaveBuffer **ppBuffer)
{
    CVxdSecondaryRenderWaveBuffer * pBuffer = NULL;
    HRESULT                         hr;

    DPF_ENTER();

    pBuffer = NEW(CVxdSecondaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(pDesc, NULL, pSysMemBuffer);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  LockMixerDestination
 *
 *  Description:
 *      Locks the mixer destination for writes.
 *
 *  Arguments:
 *      DWORD [in]: starting position.
 *      DWORD [in]: amount to lock.
 *      LPVOID * [out]: receives first lock pointer.
 *      LPDWORD [out]: receives first lock size.
 *      LPVOID * [out]: receives second lock pointer.
 *      LPDWORD [out]: receives second lock size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::LockMixerDestination"

HRESULT CVxdRenderDevice::LockMixerDestination(DWORD ibLock, DWORD cbLock, LPVOID *ppv1, LPDWORD pcb1, LPVOID *ppv2, LPDWORD pcb2)
{
    LOCKCIRCULARBUFFER      lcb;
    HRESULT                 hr;

    DPF_ENTER();

    lcb.pHwBuffer = m_hHwBuffer;
    lcb.pvBuffer = m_pbHwBuffer;
    lcb.cbBuffer = m_cbHwBuffer;
    lcb.fPrimary = TRUE;
    lcb.fdwDriverDesc = m_dsdd.dwFlags;
    lcb.ibRegion = ibLock;
    lcb.cbRegion = min(cbLock, m_cbHwBuffer);

    hr = LockCircularBuffer(&lcb);

    if(SUCCEEDED(hr) && ppv1)
    {
        *ppv1 = lcb.pvLock[0];
    }

    if(SUCCEEDED(hr) && pcb1)
    {
        *pcb1 = lcb.cbLock[0];
    }

    if(SUCCEEDED(hr) && ppv2)
    {
        *ppv2 = lcb.pvLock[1];
    }

    if(SUCCEEDED(hr) && pcb2)
    {
        *pcb2 = lcb.cbLock[1];
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UnlockMixerDestination
 *
 *  Description:
 *      Unlocks the mixer destination for writes.
 *
 *  Arguments:
 *      LPVOID [in]: first lock pointer.
 *      DWORD [in]: first lock size.
 *      LPVOID [in]: second lock pointer.
 *      DWORD [in]: second lock size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::UnlockMixerDestination"

HRESULT CVxdRenderDevice::UnlockMixerDestination(LPVOID pv1, DWORD cb1, LPVOID pv2, DWORD cb2)
{
    LOCKCIRCULARBUFFER      lcb;
    HRESULT                 hr;

    DPF_ENTER();

    lcb.pHwBuffer = m_hHwBuffer;
    lcb.pvBuffer = m_pbHwBuffer;
    lcb.cbBuffer = m_cbHwBuffer;
    lcb.fPrimary = TRUE;
    lcb.fdwDriverDesc = m_dsdd.dwFlags;

    lcb.pvLock[0] = pv1;
    lcb.cbLock[0] = cb1;

    lcb.pvLock[1] = pv2;
    lcb.cbLock[1] = cb2;

    hr = UnlockCircularBuffer(&lcb);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EnumStandardFormatsCallback
 *
 *  Description:
 *      Callback function for EnumStandardFormats used when calling
 *      CVxdRenderDevice::Initialize.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *
 *  Returns:
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::EnumStandardFormatsCallback"

BOOL CVxdRenderDevice::EnumStandardFormatsCallback(LPCWAVEFORMATEX pwfx)
{
    CMixDest *              pMixDest    = NULL;
    CNaGrDest *             pNaGrDest   = NULL;
    CThDest *               pThDest     = NULL;
    HRESULT                 hr          = DS_OK;
    NAGRDESTDATA            ngdd;

    DPF_ENTER();

    // Open the waveOut device
    if(m_dsdd.dwFlags & DSDDESC_DOMMSYSTEMOPEN)
    {
        hr = OpenWaveOut(&m_hwo, m_pDeviceDescription->m_uWaveDeviceId, pwfx);
    }

    // Open the driver
    if(SUCCEEDED(hr))
    {
        hr = VxdDrvOpen(m_pDeviceDescription->m_guidDeviceId, &m_hHal);

        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "Unable to open driver");
        }
    }

    // Handle on-card memory management
    if(SUCCEEDED(hr))
    {
        if(m_dsdd.dwHeapType & DSDHEAP_USEDIRECTDRAWHEAP)
        {
            m_pDriverHeap = (LPVMEMHEAP)m_dsdd.pvDirectDrawHeap;
        }
        else if(m_dsdd.dwHeapType & DSDHEAP_CREATEHEAP)
        {
            m_pDriverHeap = m_dlDDraw.VidMemInit(VMEMHEAP_LINEAR, m_dsdd.dwMemStartAddress, m_dsdd.dwMemEndAddress, 0, 0);

            if(!m_pDriverHeap)
            {
                DPF(DPFLVL_ERROR, "Unable to initialize device memory heap");
                hr = DSERR_OUTOFMEMORY;
            }
        }
    }

    // Create the primary hardware buffer.  The buffer size is initialized to
    // DEF_PRIMARY_SIZE, giving the driver a hint as to how big we'd like
    // the buffer to be.
    if(SUCCEEDED(hr))
    {
        m_cbHwBuffer = DEF_PRIMARY_SIZE;
        m_pbHwBuffer = NULL;
        m_hHwBuffer = NULL;

        hr = VxdDrvCreateSoundBuffer(m_hHal, (LPWAVEFORMATEX)pwfx, DSBCAPS_PRIMARYBUFFER, 0, &m_cbHwBuffer, &m_pbHwBuffer, &m_hHwBuffer);

        if(SUCCEEDED(hr))
        {
            ASSERT(m_cbHwBuffer && m_pbHwBuffer && m_hHwBuffer);
        }
        else
        {
            DPF(DPFLVL_ERROR, "Unable to create hardware primary buffer (%s)", HRESULTtoSTRING(hr));
        }
    }

    // Create the mixer destination
    if(SUCCEEDED(hr))
    {
        ngdd.pBuffer = m_pbHwBuffer;
        ngdd.cbBuffer = m_cbHwBuffer;
        ngdd.hBuffer = m_hHwBuffer;
        ngdd.phwo = &m_hwo;
        ngdd.uDeviceId = m_pDeviceDescription->m_uWaveDeviceId;
        ngdd.fdwDriverDesc = m_dsdd.dwFlags;

        hr = DSERR_GENERIC;

        if(!(m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NORING0MIX) && CanMixInRing0())
        {
            pThDest = NEW(CThDest(&ngdd));
            hr = HRFROMP(pThDest);

            if(SUCCEEDED(hr))
            {
                hr = pThDest->New();
            }

            if(SUCCEEDED(hr))
            {
                DPF(DPFLVL_INFO, "Mixing in ring 0");
                pMixDest = pThDest;
            }
            else
            {
                pThDest->Terminate();
                DELETE(pThDest);
            }
        }

        if(FAILED(hr))
        {
            pNaGrDest = NEW(CNaGrDest(&ngdd));
            hr = HRFROMP(pNaGrDest);

            if(SUCCEEDED(hr))
            {
                DPF(DPFLVL_INFO, "Mixing in ring 3");
                pMixDest = pNaGrDest;
            }
            else
            {
                pNaGrDest->Terminate();
                DELETE(pNaGrDest);
            }
        }

        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "Unable to create mixer destination object");
        }
    }

    // Create the mixer
    if(SUCCEEDED(hr))
    {
        hr = CreateMixer(pMixDest, pwfx);
    }

    // Clean up
    if(FAILED(hr))
    {
        // Free the hardware primary buffer
        if(m_hHwBuffer)
        {
            VxdBufferRelease(m_hHwBuffer);
            m_hHwBuffer = NULL;
        }

        // Free the driver heap
        if(m_pDriverHeap)
        {
            if(m_dsdd.dwHeapType & DSDHEAP_CREATEHEAP)
            {
                m_dlDDraw.VidMemFini(m_pDriverHeap);
            }

            m_pDriverHeap = NULL;
        }

        // Close the driver
        if(m_hHal)
        {
            VxdDrvClose(m_hHal);
            m_hHal = NULL;
        }

        // Close the waveOut device
        if(m_hwo)
        {
            CloseWaveOut(&m_hwo);
        }
    }

    DPF_LEAVE(FAILED(hr));

    return FAILED(hr);
}


/***************************************************************************
 *
 *  CanMixInRing0
 *
 *  Description:
 *      Determines if the device should mix in ring 0 or ring 3.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE to mix in ring 0.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdRenderDevice::CanMixInRing0"

BOOL CVxdRenderDevice::CanMixInRing0(void)
{
    BOOL                    fRing0              = FALSE;
    DWORD                   dwPageFileVersion   = 0;
    DWORD                   dwMaxSize           = 0;
    DWORD                   dwPagerType         = 0;
    LONG                    lVmcpdMajorVersion  = 0;
    LONG                    lVmcpdMinorVersion  = 0;
    LONG                    lLevel              = 0;

    DPF_ENTER();

    // We have to mix in ring 3 if any of the following are true:
    //  - Paging through DOS
    //  - A floating point coprocessor is not installed
    //  - VMCPD < version 4.02
    VxdGetPagefileVersion(&dwPageFileVersion, &dwMaxSize, &dwPagerType);
    VxdGetVmcpdVersion(&lVmcpdMajorVersion, &lVmcpdMinorVersion, &lLevel);

    if(0 == dwPageFileVersion || dwPagerType < 2)
    {
        DPF(DPFLVL_INFO, "Paging through DOS");
    }
    else if(lVmcpdMajorVersion < 4 || (4 == lVmcpdMajorVersion && lVmcpdMinorVersion < 2))
    {
        DPF(DPFLVL_INFO, "VMCPD version is %ld.%2.2ld - too low to mix in ring 0", lVmcpdMajorVersion, lVmcpdMinorVersion);
    }
    else if(lLevel < 3)
    {
        DPF(DPFLVL_INFO, "VMCPD coprocessor level is %ld - too low to mix in ring 0", lLevel);
    }
    else
    {
        fRing0 = TRUE;
    }

    DPF_LEAVE(fRing0);

    return fRing0;
}


/***************************************************************************
 *
 *  CVxdPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CVxdRenderDevice * [in]: pointer to the parent object.
 *      LPVOID [in]: buffer instace identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::CVxdPrimaryRenderWaveBuffer"

CVxdPrimaryRenderWaveBuffer::CVxdPrimaryRenderWaveBuffer(CVxdRenderDevice *pVxdDevice, LPVOID pvInstance)
    : CPrimaryRenderWaveBuffer(pVxdDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CVxdPrimaryRenderWaveBuffer);

    // Initialize defaults
    m_pVxdDevice = pVxdDevice;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CVxdPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::~CVxdPrimaryRenderWaveBuffer"

CVxdPrimaryRenderWaveBuffer::~CVxdPrimaryRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CVxdPrimaryRenderWaveBuffer);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::Initialize"

HRESULT CVxdPrimaryRenderWaveBuffer::Initialize(DWORD dwFlags)
{
    HRESULT                 hr      = DS_OK;
    VADRBUFFERDESC          vrbd;

    DPF_ENTER();

    // Check for unsupported flags
    if(dwFlags & DSBCAPS_LOCSOFTWARE)
    {
        RPF(DPFLVL_ERROR, "Specified LOCSOFTWARE on a hardware primary buffer");
        hr = DSERR_INVALIDCALL;
    }

    // Initialize the base class
    if(SUCCEEDED(hr))
    {
        ZeroMemory(&vrbd, sizeof(vrbd));

        vrbd.dwFlags = dwFlags | DSBCAPS_LOCHARDWARE;
        vrbd.dwBufferBytes = m_pVxdDevice->m_cbHwBuffer;
        vrbd.pwfxFormat = m_pVxdDevice->m_pwfxFormat;

        hr = CPrimaryRenderWaveBuffer::Initialize(&vrbd, NULL);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RequestWriteAccess
 *
 *  Description:
 *      Requests write access to the primary buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to request primary access, FALSE to relenquish it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::RequestWriteAccess"

HRESULT CVxdPrimaryRenderWaveBuffer::RequestWriteAccess(BOOL fRequest)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fRequest)
    {
        if(this != m_pVxdDevice->m_pWritePrimaryBuffer)
        {
            // Make sure no-one else has primary access
            if(m_pVxdDevice->m_pWritePrimaryBuffer)
            {
                RPF(DPFLVL_ERROR, "WRITEPRIMARY access already granted");
                hr = DSERR_OTHERAPPHASPRIO;
            }

            // Assign ownership
            if(SUCCEEDED(hr))
            {
                DPF(DPFLVL_INFO, "WRITEPRIMARY access granted to 0x%p", this);
                m_pVxdDevice->m_pWritePrimaryBuffer = this;
            }
        }
    }
    else
    {
        if(this == m_pVxdDevice->m_pWritePrimaryBuffer)
        {
            // Release ownership
            DPF(DPFLVL_INFO, "WRITEPRIMARY access released by 0x%p", this);
            m_pVxdDevice->m_pWritePrimaryBuffer = NULL;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks a region of the buffer.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the buffer to lock from.
 *      DWORD [in]: size, in bytes, of the region to lock.
 *      LPVOID * [out]: receives pointer to region 1 of the lock.
 *      LPDWORD [out]: receives size of above region.
 *      LPVOID * [out]: receives pointer to region 2 of the lock.
 *      LPDWORD [out]: receives size of above region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::Lock"

HRESULT CVxdPrimaryRenderWaveBuffer::Lock(DWORD ibLock, DWORD cbLock, LPVOID *ppv1, LPDWORD pcb1, LPVOID *ppv2, LPDWORD pcb2)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pVxdDevice->LockMixerDestination(ibLock, cbLock, ppv1, pcb1, ppv2, pcb2);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks a region of the buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to region 1 of the lock.
 *      DWORD [in]: size of above region.
 *      LPVOID [in]: pointer to region 2 of the lock.
 *      DWORD [in]: size of above region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::Unlock"

HRESULT CVxdPrimaryRenderWaveBuffer::Unlock(LPVOID pv1, DWORD cb1, LPVOID pv2, DWORD cb2)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pVxdDevice->UnlockMixerDestination(pv1, cb1, pv2, cb2);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::CommitToDevice"

HRESULT CVxdPrimaryRenderWaveBuffer::CommitToDevice(DWORD ibCommit, DWORD cbCommit)
{
    LPVOID                  pvLock[2];
    DWORD                   cbLock[2];
    LPBYTE                  pbBuffer;
    HRESULT                 hr;

    DPF_ENTER();

    pbBuffer = m_pSysMemBuffer->GetPlayBuffer();

    hr = Lock(ibCommit, cbCommit, &pvLock[0], &cbLock[0], &pvLock[1], &cbLock[1]);

    if(SUCCEEDED(hr) && pvLock[0] && cbLock[0])
    {
        CopyMemory(pvLock[0], pbBuffer + ibCommit, cbLock[0]);
    }

    if(SUCCEEDED(hr) && pvLock[1] && cbLock[1])
    {
        CopyMemory(pvLock[1], pbBuffer, cbLock[1]);
    }

    if(SUCCEEDED(hr))
    {
        hr = Unlock(pvLock[0], cbLock[0], pvLock[1], cbLock[1]);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::GetState"

HRESULT CVxdPrimaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();

    *pdwState = m_pVxdDevice->m_dwMixerState;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::SetState"

HRESULT CVxdPrimaryRenderWaveBuffer::SetState(DWORD dwState)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pVxdDevice->SetMixerState(dwState);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::GetCursorPosition"

HRESULT CVxdPrimaryRenderWaveBuffer::GetCursorPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = VxdBufferGetPosition(m_pVxdDevice->m_hHwBuffer, pdwPlay, pdwWrite);

    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "VxdBufferGetPosition failed with %s", HRESULTtoSTRING(hr));
    }
    else if (m_pVxdDevice->m_dwMixerState & VAD_BUFFERSTATE_STARTED)
    {
        *pdwWrite = PadHardwareWriteCursor(*pdwWrite, m_pVxdDevice->m_cbHwBuffer, m_pVxdDevice->m_pwfxFormat);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePropertySet
 *
 *  Description:
 *      Creates the property set object.
 *
 *  Arguments:
 *      CPropertySet ** [out]: receives pointer to the property set object.
 *                             The caller is responsible for freeing this
 *                             object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::CreatePropertySet"

HRESULT CVxdPrimaryRenderWaveBuffer::CreatePropertySet(CPropertySet **ppPropertySet)
{
    CVxdPropertySet *       pPropertySet    = NULL;
    HRESULT                 hr              = DS_OK;

    DPF_ENTER();

    if(m_pVxdDevice->m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWPROPSETS)
    {
        RPF(DPFLVL_ERROR, "Tried to create a property set object with hardware property sets disabled");
        hr = DSERR_UNSUPPORTED;
    }

    if(SUCCEEDED(hr))
    {
        pPropertySet = NEW(CVxdPropertySet(m_pvInstance));
        hr = HRFROMP(pPropertySet);
    }

    if(SUCCEEDED(hr))
    {
        hr = pPropertySet->Initialize(m_pVxdDevice->m_hHwBuffer);
    }

    if(SUCCEEDED(hr))
    {
        *ppPropertySet = pPropertySet;
    }
    else
    {
        RELEASE(pPropertySet);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Create3dListener
 *
 *  Description:
 *      Creates the 3D listener.
 *
 *  Arguments:
 *      C3dListener ** [out]: receives pointer to the 3D listener object.
 *                            The caller is responsible for freeing this
 *                            object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdPrimaryRenderWaveBuffer::Create3dListener"

HRESULT CVxdPrimaryRenderWaveBuffer::Create3dListener(C3dListener **pp3dListener)
{
    CVxd3dListener *        pVxd3dListener  = NULL;
    C3dListener *           p3dListener     = NULL;
    CVxdPropertySet *       pPropertySet    = NULL;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_vrbd.dwFlags & DSBCAPS_CTRL3D);

    pPropertySet = NEW(CVxdPropertySet(m_pvInstance));
    hr = HRFROMP(pPropertySet);

    if(SUCCEEDED(hr))
    {
        hr = pPropertySet->Initialize(m_pVxdDevice->m_hHwBuffer);
    }

    if(FAILED(hr))
    {
        RELEASE(pPropertySet);
    }
    else
    {
        hr = pPropertySet->QuerySetSupport(DSPROPSETID_DirectSound3DListener);
    }

    if(SUCCEEDED(hr))
    {
        pVxd3dListener = NEW(CVxd3dListener(pPropertySet));
        hr = HRFROMP(pVxd3dListener);

        if(SUCCEEDED(hr))
        {
            hr = pVxd3dListener->Initialize();
        }

        if(SUCCEEDED(hr))
        {
            DPF(DPFLVL_INFO, "3D listener lives in HARDWARE");
            p3dListener = pVxd3dListener;
        }
        else
        {
            RELEASE(pVxd3dListener);
        }
    }
    else
    {
        p3dListener = NEW(C3dListener);
        hr = HRFROMP(p3dListener);

        if(SUCCEEDED(hr))
        {
            DPF(DPFLVL_INFO, "3D listener lives in SOFTWARE");
        }
        else
        {
            RELEASE(p3dListener);
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(p3dListener);
        *pp3dListener = p3dListener;
    }

    RELEASE(pPropertySet);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CHybridSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CVxdRenderDevice * [in]: pointer to the parent device.
 *      LPVOID [in]: buffer instace identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::CHybridSecondaryRenderWaveBuffer"

CHybridSecondaryRenderWaveBuffer::CHybridSecondaryRenderWaveBuffer(CVxdRenderDevice *pVxdDevice, LPVOID pvInstance)
    : CSecondaryRenderWaveBuffer(pVxdDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CHybridSecondaryRenderWaveBuffer);

    // Initialize defaults
    m_pVxdDevice = pVxdDevice;
    m_pBuffer = NULL;
    m_lVolume = DSBVOLUME_MAX;
    m_lPan = DSBPAN_CENTER;
    m_fMute = FALSE;
    m_dwPositionCache = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CHybridSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::~CHybridSecondaryRenderWaveBuffer"

CHybridSecondaryRenderWaveBuffer::~CHybridSecondaryRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CHybridSecondaryRenderWaveBuffer);

    // Free resources
    RELEASE(m_pBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      CSecondaryRenderWaveBuffer * [in]: pointer to the buffer to duplicate
 *                                         from, or NULL to initialize as a
 *                                         new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::Initialize"

HRESULT CHybridSecondaryRenderWaveBuffer::Initialize(LPCVADRBUFFERDESC pDesc, CHybridSecondaryRenderWaveBuffer *pSource)
{
    DWORD                   dwLocationFlags;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(LXOR(pDesc, pSource));

    // Initialize the base class
    hr = CSecondaryRenderWaveBuffer::Initialize(pDesc, pSource);

    // Mask off the location flags since they're not used here (only in AcquireResources)
    dwLocationFlags = m_vrbd.dwFlags & DSBCAPS_LOCMASK;
    m_vrbd.dwFlags &= ~DSBCAPS_LOCMASK;

    // Set up the default buffer properties
    if(SUCCEEDED(hr) && pSource)
    {
        m_lVolume = pSource->m_lVolume;
        m_lPan = pSource->m_lPan;
        m_fMute = pSource->m_fMute;
    }

    // Acquire resources
    if(SUCCEEDED(hr) && !(m_vrbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        if(pSource)
        {
            hr = DuplicateResources(pSource);
        }
        else
        {
            hr = AcquireResources(dwLocationFlags);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquires hardware resources for the buffer.
 *
 *  Arguments:
 *      DWORD [in]: location flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::AcquireResources"

HRESULT CHybridSecondaryRenderWaveBuffer::AcquireResources(DWORD dwLocationFlags)
{
    HRESULT                 hr  = DSERR_INVALIDCALL;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());

    // Try to acquire hardware resources
    if(!(dwLocationFlags & DSBCAPS_LOCSOFTWARE))
    {
        hr = AcquireHardwareResources();
    }

    // Try to acquire software resources
    if(FAILED(hr) && !(dwLocationFlags & DSBCAPS_LOCHARDWARE))
    {
        hr = AcquireSoftwareResources();
    }

    // Handle the resource acquisition
    if(SUCCEEDED(hr))
    {
        hr = HandleResourceAcquisition();
    }

    // Clean up
    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Failed to acquire resources");
        FreeResources();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  DuplicateResources
 *
 *  Description:
 *      Acquires hardware resources for the buffer.
 *
 *  Arguments:
 *      CHybridSecondaryRenderWaveBuffer * [in]: source buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::DuplicateResources"

HRESULT CHybridSecondaryRenderWaveBuffer::DuplicateResources(CHybridSecondaryRenderWaveBuffer *pSource)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());
    ASSERT(pSource->HasAcquiredResources());

    // Duplicate resources
    hr = pSource->m_pBuffer->Duplicate(&m_pBuffer);

    // Handle the resource acquisition
    if(SUCCEEDED(hr))
    {
        hr = HandleResourceAcquisition();
    }

    // Clean up
    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Failed to duplicate resources");
        FreeResources();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireHardwareResources
 *
 *  Description:
 *      Acquires hardware resources for the buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::AcquireHardwareResources"

HRESULT CHybridSecondaryRenderWaveBuffer::AcquireHardwareResources(void)
{
    CVxdSecondaryRenderWaveBuffer * pVxdBuffer;
    VADRBUFFERDESC                  vrbd;
    HRESULT                         hr;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());

    CopyMemory(&vrbd, &m_vrbd, sizeof(m_vrbd));

    vrbd.guid3dAlgorithm = GUID_NULL;

    hr = m_pVxdDevice->CreateVxdSecondaryBuffer(&vrbd, m_pvInstance, m_pSysMemBuffer, &pVxdBuffer);

    // If we failed to create a 3D hardware buffer, and the app specified DS3DALG_NO_VIRTUALIZATION,
    // try to create a 2D hardware buffer with the No Virtualization (Pan 3D) control.
    if(FAILED(hr) && (m_vrbd.dwFlags & DSBCAPS_CTRL3D) && (DS3DALG_NO_VIRTUALIZATION == m_vrbd.guid3dAlgorithm))
    {
        vrbd.dwFlags &= ~DSBCAPS_CTRL3D;
        vrbd.dwFlags |= DSBCAPS_CTRLNOVIRT;
        hr = m_pVxdDevice->CreateVxdSecondaryBuffer(&vrbd, m_pvInstance, m_pSysMemBuffer, &pVxdBuffer);
    }

    if(SUCCEEDED(hr))
    {
        m_pBuffer = pVxdBuffer;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireSoftwareResources
 *
 *  Description:
 *      Acquires software resources for the buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::AcquireSoftwareResources"

HRESULT CHybridSecondaryRenderWaveBuffer::AcquireSoftwareResources(void)
{
    CEmSecondaryRenderWaveBuffer *  pEmBuffer;
    VADRBUFFERDESC                  vrbd;
    HRESULT                         hr;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());

    // Always add DSBCAPS_GETCURRENTPOSITION2 because emulated secondary buffers
    // over VxD drivers should always return the proper position values- i.e.,
    // GetPosition1 applies only to emulation over wave APIs.
    CopyMemory(&vrbd, &m_vrbd, sizeof(m_vrbd));

    vrbd.dwFlags |= DSBCAPS_GETCURRENTPOSITION2;

    hr = m_pVxdDevice->CreateEmulatedSecondaryBuffer(&vrbd, m_pvInstance, m_pSysMemBuffer, &pEmBuffer);

    if(SUCCEEDED(hr))
    {
        m_pBuffer = pEmBuffer;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  HandleResourceAcquisition
 *
 *  Description:
 *      Handles the acquistion of hardware resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::HandleResourceAcquisition"

HRESULT CHybridSecondaryRenderWaveBuffer::HandleResourceAcquisition(void)
{
    BOOL                    fFound;
    DSVOLUMEPAN             dsvp;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(HasAcquiredResources());

    // Remove the real buffer from the parent's list
    fFound = m_pDevice->m_lstSecondaryBuffers.RemoveDataFromList(m_pBuffer);
    ASSERT(fFound);

    // Save the buffer location
    m_vrbd.dwFlags |= m_pBuffer->m_vrbd.dwFlags & DSBCAPS_LOCMASK;

    // Set attenuation levels
    FillDsVolumePan(m_lVolume, m_lPan, &dsvp);

    hr = SetAttenuation(&dsvp);

    // Set mute.  We have to set mute after setting volume because
    // SetMute may change the current buffer volume.
    if(SUCCEEDED(hr))
    {
        hr = SetMute(m_fMute);
    }

    // Set frequency
    if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        hr = SetFrequency(m_vrbd.pwfxFormat->nSamplesPerSec);
    }

    // Set the buffer position
    if(SUCCEEDED(hr))
    {
        hr = SetCursorPosition(m_dwPositionCache);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has acquired resources", this);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeResources
 *
 *  Description:
 *      Frees the all hardware resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::FreeResources"

HRESULT
CHybridSecondaryRenderWaveBuffer::FreeResources
(
    void
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Save the cursor position
    if(HasAcquiredResources())
    {
        hr = m_pBuffer->GetCursorPosition(&m_dwPositionCache, NULL);
    }

    // Release the real buffer
    if(SUCCEEDED(hr))
    {
        RELEASE(m_pBuffer);
    }

    // Remove the location flag
    if(SUCCEEDED(hr))
    {
        m_vrbd.dwFlags &= ~DSBCAPS_LOCMASK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Duplicate
 *
 *  Description:
 *      Duplicates the buffer.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer ** [out]: receives duplicate buffer.  Use
 *                                           Release to free this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::Duplicate"

HRESULT CHybridSecondaryRenderWaveBuffer::Duplicate(CSecondaryRenderWaveBuffer **ppBuffer)
{
    CHybridSecondaryRenderWaveBuffer *  pBuffer = NULL;
    HRESULT                             hr      = DS_OK;

    DPF_ENTER();

    pBuffer = NEW(CHybridSecondaryRenderWaveBuffer(m_pVxdDevice, m_pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(NULL, this);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks a region of the buffer.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the buffer to lock from.
 *      DWORD [in]: size, in bytes, of the region to lock.
 *      LPVOID * [out]: receives pointer to region 1 of the lock.
 *      LPDWORD [out]: receives size of above region.
 *      LPVOID * [out]: receives pointer to region 2 of the lock.
 *      LPDWORD [out]: receives size of above region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::Lock"

HRESULT CHybridSecondaryRenderWaveBuffer::Lock(DWORD ibLock, DWORD cbLock, LPVOID *ppv1, LPDWORD pcb1, LPVOID *ppv2, LPDWORD pcb2)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->Lock(ibLock, cbLock, ppv1, pcb1, ppv2, pcb2);
    }
    else
    {
        hr = CRenderWaveBuffer::Lock(ibLock, cbLock, ppv1, pcb1, ppv2, pcb2);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks a region of the buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to region 1 of the lock.
 *      DWORD [in]: size of above region.
 *      LPVOID [in]: pointer to region 2 of the lock.
 *      DWORD [in]: size of above region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::Unlock"

HRESULT CHybridSecondaryRenderWaveBuffer::Unlock(LPVOID pv1, DWORD cb1, LPVOID pv2, DWORD cb2)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->Unlock(pv1, cb1, pv2, cb2);
    }
    else
    {
        hr = CRenderWaveBuffer::Unlock(pv1, cb1, pv2, cb2);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::CommitToDevice"

HRESULT CHybridSecondaryRenderWaveBuffer::CommitToDevice(DWORD ibCommit, DWORD cbCommit)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->CommitToDevice(ibCommit, cbCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::GetState"

HRESULT CHybridSecondaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    HRESULT                     hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->GetState(pdwState);
    }
    else
    {
        *pdwState = VAD_BUFFERSTATE_STOPPED;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::SetState"

HRESULT CHybridSecondaryRenderWaveBuffer::SetState(DWORD dwState)
{
    HRESULT hr = DSERR_INVALIDCALL;
    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->SetState(dwState);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Retrieves the current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the play position.
 *      LPDWORD [out]: receives the write position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::GetCursorPosition"

HRESULT CHybridSecondaryRenderWaveBuffer::GetCursorPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                     hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->GetCursorPosition(pdwPlay, pdwWrite);
    }
    else
    {
        if(pdwPlay)
        {
            *pdwPlay = m_dwPositionCache;
        }

        if(pdwWrite)
        {
            *pdwWrite = m_dwPositionCache;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCursorPosition
 *
 *  Description:
 *      Sets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::SetCursorPosition"

HRESULT CHybridSecondaryRenderWaveBuffer::SetCursorPosition(DWORD dwPlay)
{
    HRESULT                     hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->SetCursorPosition(dwPlay);
    }
    else
    {
        m_dwPositionCache = dwPlay;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the buffer frequency.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *      BOOL [in]: whether to clamp to the driver's supported frequency
 *                 range if the call fails.  Ignored in this class.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::SetFrequency"

HRESULT CHybridSecondaryRenderWaveBuffer::SetFrequency(DWORD dwFrequency, BOOL)
{
    HRESULT                     hr  = DS_OK;

    DPF_ENTER();

    ASSERT(m_vrbd.dwFlags & DSBCAPS_CTRLFREQUENCY);

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->SetFrequency(dwFrequency);
    }

    if(SUCCEEDED(hr))
    {
        m_vrbd.pwfxFormat->nSamplesPerSec = dwFrequency;
        m_vrbd.pwfxFormat->nAvgBytesPerSec = dwFrequency * m_vrbd.pwfxFormat->nBlockAlign;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Sets the attenuation for each channel.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::SetAttenuation"

HRESULT CHybridSecondaryRenderWaveBuffer::SetAttenuation(PDSVOLUMEPAN pdsvp)
{
    HRESULT                     hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->SetAttenuation(pdsvp);
    }

    if(SUCCEEDED(hr))
    {
        m_lVolume = pdsvp->lVolume;
        m_lPan = pdsvp->lPan;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#ifdef FUTURE_MULTIPAN_SUPPORT
/***************************************************************************
 *
 *  SetChannelAttenuations
 *
 *  Description:
 *      Sets the multichannel attenuation for a given buffer.
 *
 *  Arguments:
 *      TBD.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::SetChannelAttenuations"

HRESULT CHybridSecondaryRenderWaveBuffer::SetChannelAttenuations(LONG lVolume, DWORD dwChannelCount, const DWORD* pdwChannels, const LONG* plChannelVolumes)
{
    HRESULT                     hr   = DS_OK;
    LONG                        lPan;

    DPF_ENTER();

    if (dwChannelCount == 0)
    {
        // SetChannelVolume() has not been called yet; use center panning
        ASSERT(!pdwChannels && !plChannelVolumes);  // Sanity checking
        lPan = 0;
    }
    else
    {
        // Calculate a global LR pan value based on the channel volumes
        lPan = MultiChannelToStereoPan(dwChannelCount, pdwChannels, plChannelVolumes);
    }

    if (HasAcquiredResources())
    {
        DSVOLUMEPAN dsvp;
        FillDsVolumePan(lVolume, lPan, &dsvp);
        hr = m_pBuffer->SetAttenuation(&dsvp);
    }

    if (SUCCEEDED(hr))
    {
        m_lVolume = lVolume;
        m_lPan = lPan;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // FUTURE_MULTIPAN_SUPPORT


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Mutes or unmutes the buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to mute the buffer, FALSE to restore it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::SetMute"

HRESULT CHybridSecondaryRenderWaveBuffer::SetMute(BOOL fMute)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->SetMute(fMute);
    }

    if(SUCCEEDED(hr))
    {
        m_fMute = fMute;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::SetNotificationPositions"

HRESULT CHybridSecondaryRenderWaveBuffer::SetNotificationPositions(DWORD dwCount, LPCDSBPOSITIONNOTIFY paNotes)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Only software buffers support notification positions, so we can
    // go ahead and acquire them now.
    if(!HasAcquiredResources())
    {
        hr = AcquireResources(DSBCAPS_LOCSOFTWARE);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pBuffer->SetNotificationPositions(dwCount, paNotes);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePropertySet
 *
 *  Description:
 *      Creates the property set object.
 *
 *  Arguments:
 *      CPropertySet ** [out]: receives pointer to the property set object.
 *                             The caller is responsible for freeing this
 *                             object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::CreatePropertySet"

HRESULT CHybridSecondaryRenderWaveBuffer::CreatePropertySet(CPropertySet **ppPropertySet)
{
    HRESULT                 hr  = DSERR_INVALIDCALL;

    DPF_ENTER();

    ASSERT(HasAcquiredResources());

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->CreatePropertySet(ppPropertySet);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Create3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHybridSecondaryRenderWaveBuffer::Create3dObject"

HRESULT CHybridSecondaryRenderWaveBuffer::Create3dObject(C3dListener *p3dListener, C3dObject **pp3dObject)
{
    HRESULT                 hr  = DSERR_INVALIDCALL;

    DPF_ENTER();

    ASSERT(HasAcquiredResources());

    if(HasAcquiredResources())
    {
        hr = m_pBuffer->Create3dObject(p3dListener, pp3dObject);

        // Create3dObject() may have set m_pBuffer's SuccessCode to DS_NO_VIRTUALIZATION
        // if it had to replace the 3D alg with Pan3D.  Make sure we pick up the change:
        m_hrSuccessCode = m_pBuffer->m_hrSuccessCode;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CVxdSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CVxdRenderDevice * [in]: pointer to the parent device.
 *      LPVOID [in]: buffer instace identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdSecondaryRenderWaveBuffer::CVxdSecondaryRenderWaveBuffer"

CVxdSecondaryRenderWaveBuffer::CVxdSecondaryRenderWaveBuffer(CVxdRenderDevice *pVxdDevice, LPVOID pvInstance)
    : CSecondaryRenderWaveBuffer(pVxdDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CVxdSecondaryRenderWaveBuffer);

    // Initialize defaults
    m_pVxdDevice = pVxdDevice;
    m_pPropertySet = NULL;
    m_pHwMemBuffer = NULL;
    m_pbHwBuffer = NULL;
    m_hHwBuffer = NULL;
    m_dwState = VAD_BUFFERSTATE_STOPPED;
    m_fMute = FALSE;

    FillDsVolumePan(DSBVOLUME_MAX, DSBPAN_CENTER, &m_dsvp);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CVxdSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdSecondaryRenderWaveBuffer::~CVxdSecondaryRenderWaveBuffer"

CVxdSecondaryRenderWaveBuffer::~CVxdSecondaryRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CVxdSecondaryRenderWaveBuffer);

    // Free the property set
    RELEASE(m_pPropertySet);

    // Free the HW buffer
    if(m_hHwBuffer)
    {
        VxdBufferRelease(m_hHwBuffer);
    }

    // Free hardware memory
    RELEASE(m_pHwMemBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      CVxdSecondaryRenderWaveBuffer * [in]: pointer to the buffer to duplicate
 *                                      from, or NULL to initialize as a
 *                                      new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdSecondaryRenderWaveBuffer::Initialize"

HRESULT CVxdSecondaryRenderWaveBuffer::Initialize(LPCVADRBUFFERDESC pDesc, CVxdSecondaryRenderWaveBuffer *pSource, CSysMemBuffer *pSysMemBuffer)
{
    DSCAPS                  dsc;
    DWORD                   dwFree;
    HRESULT                 hr;

    DPF_ENTER();

    // Get device caps
    InitStruct(&dsc, sizeof(dsc));

    hr = m_pVxdDevice->GetCaps(&dsc);

    // Validate the buffer description
    if(SUCCEEDED(hr) && !pSource)
    {
        if(pDesc->dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY)
        {
            RPF(DPFLVL_WARNING, "VxD hardware buffers don't support CTRLPOSITIONNOTIFY");
            hr = DSERR_CONTROLUNAVAIL;
        }

        if(SUCCEEDED(hr) && (m_pVxdDevice->m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS))
        {
            hr = DSERR_INVALIDCALL;
        }

        if(SUCCEEDED(hr) && (pDesc->dwFlags & DSBCAPS_CTRL3D) && (m_pVxdDevice->m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D))
        {
            hr = DSERR_INVALIDCALL;
        }

        if(SUCCEEDED(hr) && (pDesc->pwfxFormat->nSamplesPerSec < dsc.dwMinSecondarySampleRate || pDesc->pwfxFormat->nSamplesPerSec > dsc.dwMaxSecondarySampleRate))
        {
            RPF(DPFLVL_ERROR, "Specified invalid frequency (%lu) for this device (%lu to %lu)", pDesc->pwfxFormat->nSamplesPerSec, dsc.dwMinSecondarySampleRate, dsc.dwMaxSecondarySampleRate);
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Initialize the base class
    if(SUCCEEDED(hr))
    {
        hr = CSecondaryRenderWaveBuffer::Initialize(pDesc, pSource, pSysMemBuffer);
    }

    // Add LOCHARDWARE and CTRLVOLUME to the flags.  CTRLVOLUME is required
    // to mute the buffer.
    if(SUCCEEDED(hr))
    {
        m_vrbd.dwFlags |= DSBCAPS_LOCHARDWARE | DSBCAPS_CTRLVOLUME;
    }

    // If the caller wants a static buffer, we'll mix into any HW buffer
    // we can get, otherwise it must be a streaming buffer.
    if(SUCCEEDED(hr))
    {
        if(m_vrbd.dwFlags & DSBCAPS_STATIC)
        {
            if(m_vrbd.dwFlags & DSBCAPS_CTRL3D)
            {
                dwFree = dsc.dwFreeHw3DAllBuffers;
            }
            else
            {
                dwFree = dsc.dwFreeHwMixingAllBuffers;
            }
        }
        else
        {
            if(m_vrbd.dwFlags & DSBCAPS_CTRL3D)
            {
                dwFree = dsc.dwFreeHw3DStreamingBuffers;
            }
            else
            {
                dwFree = dsc.dwFreeHwMixingStreamingBuffers;
            }
        }

        if(!dwFree)
        {
            RPF(DPFLVL_ERROR, "Driver reports no free hardware buffers");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Save buffer properties
    if(SUCCEEDED(hr))
    {
        if(pSource)
        {
            m_pbHwBuffer = pSource->m_pbHwBuffer;
            m_cbHwBuffer = pSource->m_cbHwBuffer;
        }
        else
        {
            m_cbHwBuffer = m_vrbd.dwBufferBytes;

            if(m_pVxdDevice->m_dsdd.dwFlags & DSDDESC_USESYSTEMMEMORY)
            {
                m_pbHwBuffer = m_pSysMemBuffer->GetPlayBuffer();
            }
            else
            {
                m_pbHwBuffer = NULL;
            }
        }
    }

    // Initialize the HW memory buffer
    if(SUCCEEDED(hr))
    {
        if(pSource)
        {
            m_pHwMemBuffer = ADDREF(pSource->m_pHwMemBuffer);
        }
        else
        {
            m_pHwMemBuffer = NEW(CVxdMemBuffer(m_pVxdDevice->m_pDriverHeap, m_pVxdDevice->m_dsdd.dwMemAllocExtra, &m_pVxdDevice->m_dlDDraw));
            hr = HRFROMP(m_pHwMemBuffer);

            if(SUCCEEDED(hr))
            {
                hr = m_pHwMemBuffer->Initialize(m_cbHwBuffer);
            }
        }
    }

    // Create the HW buffer
    if(SUCCEEDED(hr))
    {
        if(pSource)
        {
            hr = VxdDrvDuplicateSoundBuffer(m_pVxdDevice->m_hHal, pSource->m_hHwBuffer, &m_hHwBuffer);

            if(FAILED(hr))
            {
                DPF(DPFLVL_ERROR, "VxdDrvDuplicateSoundBuffer failed with %s", HRESULTtoSTRING(hr));
            }
        }
        else
        {
            hr = VxdDrvCreateSoundBuffer(m_pVxdDevice->m_hHal, m_vrbd.pwfxFormat, m_vrbd.dwFlags & DSBCAPS_DRIVERFLAGSMASK, m_pHwMemBuffer->GetAddress(), &m_cbHwBuffer, &m_pbHwBuffer, &m_hHwBuffer);

            if(FAILED(hr))
            {
                DPF(DPFLVL_ERROR, "VxdDrvCreateSoundBuffer failed with %s", HRESULTtoSTRING(hr));
            }
        }
    }

    // Create the property set we're going to use for 3D
    if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_CTRL3D))
    {
        m_pPropertySet = NEW(CVxdPropertySet(m_pvInstance));
        hr = HRFROMP(m_pPropertySet);

        if(SUCCEEDED(hr))
        {
            hr = m_pPropertySet->Initialize(m_hHwBuffer);
        }

        if(FAILED(hr))
        {
            RELEASE(m_pPropertySet);
        }
        else
        {
            hr = m_pPropertySet->QuerySetSupport(DSPROPSETID_DirectSound3DBuffer);

            if(FAILED(hr))
            {
                DPF(DPFLVL_ERROR, "Driver does not support DSPROPSETID_DirectSound3DBuffer");
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Duplicate
 *
 *  Description:
 *      Duplicates the buffer.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer ** [out]: receives duplicate buffer.  Use
 *                                           Release to free this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdSecondaryRenderWaveBuffer::Duplicate"

HRESULT CVxdSecondaryRenderWaveBuffer::Duplicate(CSecondaryRenderWaveBuffer **ppBuffer)
{
    CVxdSecondaryRenderWaveBuffer * pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    pBuffer = NEW(CVxdSecondaryRenderWaveBuffer(m_pVxdDevice, m_pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(NULL, this, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks a region of the buffer.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the buffer to lock from.
 *      DWORD [in]: size, in bytes, of the region to lock.
 *      LPVOID * [out]: receives pointer to region 1 of the lock.
 *      LPDWORD [out]: receives size of above region.
 *      LPVOID * [out]: receives pointer to region 2 of the lock.
 *      LPDWORD [out]: receives size of above region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdSecondaryRenderWaveBuffer::Lock"

HRESULT CVxdSecondaryRenderWaveBuffer::Lock(DWORD ibLock, DWORD cbLock, LPVOID *ppv1, LPDWORD pcb1, LPVOID *ppv2, LPDWORD pcb2)
{
    LOCKCIRCULARBUFFER      lcb;
    HRESULT                 hr;

    DPF_ENTER();

    // Note hack: we've overridden Lock and Unlock because some pesky apps
    // lock the buffer, write to it and start playing, without ever unlocking
    // it.  This means that our system memory buffer may never see any of the
    // application's data (unless the driver specifies USESYSTEMMEMORY).

    // This hack falls by the wayside for our new DX8 buffer types - i.e.,
    // MIXIN buffers, sink buffers and buffers with effects.

    lcb.pHwBuffer = m_hHwBuffer;
    lcb.pvBuffer = m_pbHwBuffer;
    lcb.cbBuffer = m_cbHwBuffer;
    lcb.fPrimary = FALSE;
    lcb.fdwDriverDesc = m_pVxdDevice->m_dsdd.dwFlags;
    lcb.ibRegion = ibLock;
    lcb.cbRegion = cbLock;

    hr = LockCircularBuffer(&lcb);

    if(SUCCEEDED(hr) && ppv1)
    {
        *ppv1 = lcb.pvLock[0];
    }

    if(SUCCEEDED(hr) && pcb1)
    {
        *pcb1 = lcb.cbLock[0];
    }

    if(SUCCEEDED(hr) && ppv2)
    {
        *ppv2 = lcb.pvLock[1];
    }

    if(SUCCEEDED(hr) && pcb2)
    {
        *pcb2 = lcb.cbLock[1];
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks a region of the buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to region 1 of the lock.
 *      DWORD [in]: size of above region.
 *      LPVOID [in]: pointer to region 2 of the lock.
 *      DWORD [in]: size of above region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVxdSecondaryRenderWaveBuffer::Unlock"

HRESULT CVxdSecondaryRenderWaveBuffer::Unlock(LPVOID pv1, DWORD cb1, LPVOID pv2, DWORD cb2)
{
    LOCKCIRCULARBUFFER      lcb;
    HRESULT                 hr;

    DPF_ENTER();

    lcb.pHwBuffer = m_hHwBuffer;
    lcb.pvBuffer = m_pbHwBuffer;
    lcb.cbBuffer = m_cbHwBuff