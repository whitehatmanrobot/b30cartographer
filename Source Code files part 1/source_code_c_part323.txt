 for Future use
} HPP_PCI_CONFIG_RANGE, *PHPP_PCI_CONFIG_RANGE;

typedef struct _hpp_device_info
{
   PCI_DESC                sPciDescriptor; // Bus Number, Dev/Func #
   ULONG                   ulReserved [4]; // Reserved for Future use.

   UCHAR                         ucBaseAddrVerifyCount;   //Number of base address register lengths to verify
   ULONG                         ulBaseAddrLength[6];     //Base address lengths for each device
                                                               //the hot plug service verifys the new length on a powered on
                                                               //board to be <= what is saved here by the driver at init
                                                               //The verify is done on each device that has a non-zero count
                                                               //from length[0] to length[count-1]
   ULONG                   ulNumberOfRanges;// Number of ranges for this device
   HPP_PCI_CONFIG_RANGE    sPciConfigRangeDesc [16];
   void *                  pPciConfigSave [16];//used by RCMC service to save config values
                                                          //not for driver's use.
} HPP_DEVICE_INFO, *PHPP_DEVICE_INFO;

typedef struct _hpp_pci_config_map              // Get          Set
{                                               // --------------------
   ULONG           ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID     sControllerID;          // Input        N/A

   ULONG           ulPciConfigMapVersion;  // Output       N/A
   ULONG           ulReserved [4];         // N/A          N/A

   ULONG           ulNumberOfPciDevices;   // Output       N/A
   HPP_DEVICE_INFO sDeviceInfo [3];        // Output       N/A
} HPP_PCI_CONFIG_MAP, *PHPP_PCI_CONFIG_MAP;




//----------------------------------------------------------------------
// Structure Name:      HPP Stop RCMC Service
//
// Description:         Called by an application to request the driver
//                      issue the 'Stop Service' IOCTL to the RCMC.
//
//                      IOCTL:          HPP_IOCTL_STOP_RCMC_OFFSET
//
//---------------------------------------------------------------------

typedef struct  _hpp_stop_service               // Get          Set
{                                               // ---------------------
   ULONG           ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID     sControllerID;          // N/A          Input
   ULONG           ulHppSecuritySignature; // N/A          Input
} HPP_STOP_RCMC, *PHPP_STOP_RCMC;



//----------------------------------------------------------------------
// Structure Name:      HPP Run Diagnostics
//
// Description:         Called by the HPP Service to start diagnostics
//                      on the given controller.
//
//                      The service will request the diags to begin
//                          and expect the driver to return immediately with
//                          SUCCESS if the diags are supported or with
//                          HPP_DIAGS_NOT_SUPPORTED  if diags are not supported.
//
//                          Once the diags are completed, the drivers will 
//                          send an event via Sysmgmt to inform the service
//                          of the outcome of the diags.
//
//                      IOCTL:     #define HPP_IOCTL_RUN_DIAGS_OFFSET              0x08    //              X

//
//---------------------------------------------------------------------

//
// List of modes of diags to run.
//

typedef enum    _hpp_diag_mode
{
   HPPDT_ON_LINE,          // 0
   HPPDT_OFF_LINE,               // 1
} E_HPP_DIAG_MODE;


typedef struct _hpp_start_diags                     // Get          Set
{                                                   // -------------------
   ULONG                   ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID             sControllerID;          // Input        Input
   E_HPP_DIAG_MODE             eDiagMode;              // Input        Input
} HPP_RUN_DIAGS, *PHPP_RUN_DIAGS;



//----------------------------------------------------------------------
// Structure Name:     SetOIDValue
//
// Description:   
//
//           NT's miniport architecture doesn't allow
//           an application to issue a 'Set' request
//           to the driver. This is a very nice and
//           needed functionality.  Therefore we have
//           implemented this jumbo hack.
//           This OID is a 'Get' OID, but it calls the
//           'Set' handler within the driver.  Therefore
//           it will work with whatever OID we support via
//           sets.
//
//           
//---------------------------------------------------------------------

typedef struct _set_oid_value
{
   ULONG     Signature;          
   ULONG     OID;
   PVOID     InformationBuffer;
   ULONG     InformationBufferLength;
   PULONG    BytesRead;
   PULONG    BytesNeeded;
} SET_OID_VALUE, *PSET_OID_VALUE;

//
// 'Security' signature used for the 'Set' OID.  Since this
// is accessed through the 'Get' handler, we don't just want
// anyone using it.
//

#define OID_SECURITY_SIGNATURE                  0x504D4450
#define HPP_OID_BASE_ADDRESS_DEFAULT          0xff020400
#define OID_NETFLEX3_SET_OID_VALUE_RELATIVE          0xff020316
#define NETFLEX3_OID_SECURITY_SIGNATURE         0x504D4450


#pragma pack()
#endif                  /* End of #ifndef _HPPIF3P_H_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\hppifevt.h ===
/**********************************************************************
// Compaq Confidential

  Author:       Compaq Computer Corporation.
        Systems Engineering -- System Software Development (NT Dev)
        Copyright 1996-98 Compaq Computer Corporation.
        All rights reserved.

  Date:         1 August 1996 

  File:         HPPIFEVT.H  - Generic Hot Plug Event Structures

  Purpose:      This file contains all the event specific information
                  necessary to interface to a hot plug device driver.
                
                  This file details the data structures and Application Programming 
                Interfaces (APIs) for PCI Hot Plug support running in a Windows 
                NT 4.0 server.  These data structures and APIs are used between 
                the Adapter Card drivers and the PCI Hot Plug Service for NT 4.0.  
                These files are considered vital to maintaining the Compatibility 
                of the PCI Hot Plug Functionality.

  Created:  11/4/97         mib       Split off of hppif3p

  Verison: 1.0
***********************************************************************/

#ifndef _HPPIFEVT_H_
#define _HPPIFEVT_H_


#pragma pack(1)

//**********************************************************************
//              EVENT MESSAGE DEFINITIONS 
//**********************************************************************


//====================================================================
//                      CPQRCMC EVENT TYPES
//====================================================================
//
//  CPQRCMC event types are used when passing events to
//    the CPQRCMC Service.
//  Events passed from drivers to the service are sent by passing
//  the events via the call back address provided in the rcmc Info 
//  struct. The driver Id from the same structure should be used 
//  for the sender id
    
//Event ID's

//   00-FF  RESERVED BY COMPAQ
#define HR_DD_STATUS_CHANGE_EVENT        0x20     
#define HR_DD_DEVICE_STATUS_EVENT        0x21
#define HR_DD_LOG_EVENT                  0x30   


#ifndef _HR_H_

//====================================================================
//            SUPPORT STRUCTURES AND DEFINES FOR MESSAGING
//====================================================================

#define HR_MAX_EVENTS         16
#define HR_EVENT_DATA_SIZE    64 

//
//  HR event types are used when passing events to the CPQRCMC Service.  
//   
#define HR_CPQRCMC_COMMAND_EXIT_EVENT    0x01    


typedef struct _HREvent {
   ULONG                 ulEventId;    // @field . 
   ULONG                 ulSenderId;   // @field .
   
   union {                               
       ULONG   ulData1;          // @field .
       
       struct {
               UCHAR  ucEventSeverity;        //@field .
               UCHAR  ucRes;                  //@field .
               USHORT usEventDataLength;      //@field .
       };     
   };        
    
   union {                        
       ULONG   ulData2;          // @field .
       
       struct {
               USHORT  usEventClass;          //@field .
               USHORT  usEventCode;           //@field .
       };     
   };        
   
   UCHAR     ulEventData[HR_EVENT_DATA_SIZE];   // @field .
   
} HR_EVENT, *PHR_EVENT;

#endif _HR_H_



/* Eventlog revision supported by this file (bHdrRev in the header structure) */

#define EVT_LOG_REVISION         0x01

/* Time stamp of event (creation or last update) */

typedef struct _evtTimeStamp
{
   BYTE     bCentury;            /* hi-order two digits of year (19 of 1996) */
   BYTE     bYear;               /* lo-order two digits of year (96 of 1996) */
   BYTE     bMonth;              /* one-based month number (1-12) */
   BYTE     bDay;                /* one-based day number (1-31) */
   BYTE     bHour;               /* zero-based hour (0-23) */
   BYTE     bMinute;             /* zero-based minute (0-59) */
} EVT_TIME_STAMP, *PEVT_TIME_STAMP;


/* Eventlog severity codes */

#define EVT_STAT_INFO            0x02     /* Status or informational message */
#define EVT_STAT_POPUP           0x03     /* Status with popup on LCD */
#define EVT_STAT_REPAIRED        0x06     /* Degraded or worse cond repaired */
#define EVT_STAT_CAUTION         0x09     /* Component in degraded condition */
#define EVT_STAT_FAILED          0x0F     /* Failed with loss of functionality */
#define EVT_STAT_CRITICAL        EVT_STAT_FAILED /* Same as Failed */

/* Chassis type defines */
#define EVT_CHASSIS_SYSTEM          0x01
#define EVT_CHASSIS_EXTERN_STORAGE  0x02
#define EVT_CHASSIS_INTERN_STORAGE  0x03

typedef struct _evtChassis
{
   UCHAR     bType;               /* Chassis Type (System==1; Extern==2) */
   UCHAR    bId;                 /* Chassis id */
                                 /*   for type 1 - chassis id (0 is system) */
                                 /*   for type 2 or 3 - adapter slot */
   UCHAR    bPort;               /* Chassis port or bus number */
} EVT_CHASSIS, *PEVT_CHASSIS;


/* Eventlog Header -- common to all event log entries */

typedef struct _evtLogHdr
{
   WORD     wEvtLength;          /* Length of event including header */
   DWORD    dwEvtNumber;         /* Unique event number (can wrap) */
   BYTE     bHdrRev;             /* Header version (see EVT_LOG_REVISION) */
   BYTE     bSeverity;           /* Event severity code */
   WORD     wClass;              /* Event class or sub-system */
   WORD     wCode;               /* Event code for event in the class */
   EVT_TIME_STAMP InitTime;      /* Time of initial event */
   EVT_TIME_STAMP UpdateTime;    /* Time of last update */
   DWORD    dwCount;             /* Occurrence count (at least 1) */
} EVT_HEADER, *PEVT_HEADER;


#define EVT_CLASS_EXPANSION_SLOT    0x09
   #define EVT_SLOT_SWITCH_OPEN        0x01
   #define EVT_SLOT_SWITCH_CLOSED      0x02
   #define EVT_SLOT_POWER_ON           0x03
   #define EVT_SLOT_POWER_OFF          0x04
   #define EVT_SLOT_FATAL_POWER_FAULT  0x05
   #define EVT_SLOT_POWER_UP_FAULT     0x06
   #define EVT_SLOT_POWER_LOSS         0x07
   #define EVT_SLOT_CANNOT_CONFIG      0x08
   #define EVT_SLOT_BOARD_FAILURE      0x09

/* Eventlog Expansion Slot structs */

typedef struct _evtExpansionSlot
{
   EVT_CHASSIS Chassis;          /* Standard chassis info */
   BYTE     bSlot;               /* 0 is embedded */
} EVT_EXPANSION_SLOT, *PEVT_EXPANSION_SLOT;

#define EVT_HOT_PLUG_BUS   EVT_EXPANSION_SLOT
#define PEVT_HOT_PLUG_BUS  PEVT_EXPANSION_SLOT

#define EVT_SLOT_WRONG_TYPE         0x01
#define EVT_SLOT_WRONG_REVISION     0x02
#define EVT_SLOT_GENERAL_FAULT      0x03
#define EVT_SLOT_OUT_OF_RESOURCES   0x04

typedef struct _evtExpansionSlotConfigErr
{
   EVT_CHASSIS Chassis;          /* Standard chassis info */
   BYTE     bSlot;               /* 0 is embedded */
   BYTE     bError;              /* Board configuration error */
} EVT_EXPANSION_SLOT_CONFIG_ERR, *PEVT_EXPANSION_SLOT_CONFIG_ERR;


#define EVT_NETWORK_ADAPTER         0x11
   #define EVT_NIC_ADAPTER_CHECK       0x01
   #define EVT_NIC_LINK_DOWN           0x02
   #define EVT_NIC_XMIT_TIMEOUT        0x03
   
typedef struct _evtNicError
{
   EVT_CHASSIS Chassis;          /* Standard chassis info */
   UCHAR    bSlot;               /* Slot number */
   CHAR     cChassisName[1];     /* Chassis name; '\0' if undefined */
} EVT_NIC_ERROR, *PEVT_NIC_ERROR;

/* Eventlog free form data union */

typedef union _evtFreeForm
{
   EVT_NIC_ERROR                    NicErr;
} EVT_FREE_FORM, *PEVT_FREE_FORM;


/* Eventlog Entry */

typedef struct _evtLogEntry
{
   EVT_HEADER        Hdr;        /* Common header */
   EVT_FREE_FORM     Data;       /* Free form entry specific */
} EVT_LOG_ENTRY, *PEVT_LOG_ENTRY;





#pragma pack()
#endif                  /* End of #ifndef _HPPIF3P_H_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\i21554.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/I21554.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures
  specific to the Intel 21554 PCI to PCI Bridge

Reference Documents:

  21554 PCI-to-PCI Bridge for Embedded Applications
    Hardware Reference Manual - September 1998

--*/

#ifndef __I21554_H__
#define __I21554_H__

/*+
Configuration Space Address Map
-*/

typedef struct I21554_Primary_Interface_Config_s
               I21554_Primary_Interface_Config_t;

struct I21554_Primary_Interface_Config_s
       {
         os_bit32 DeviceID_VendorID;
         os_bit32 PrimaryStatus_PrimaryCommand;
         os_bit32 PrimaryClassCode_RevID;
         os_bit32 BIST_HeaderType_PrimaryMLT_PrimaryCLS;
         os_bit32 Primary_CSR_and_Downstream_Memory_0_BAR;
         os_bit32 Primary_CSR_IO_BAR;
         os_bit32 Downstream_IO_or_Memory_1_BAR;
         os_bit32 Downstream_Memory_2_BAR;
         os_bit32 Downstream_Memory_3_BAR;
         os_bit32 Upper_32_Bits_Downstream_Memory_3_BAR;
         os_bit32 reserved_1;
         os_bit32 SubsystemID_SubsystemVendorID;
         os_bit32 Primary_Expansion_ROM_Base_Address;
         os_bit32 reserved_CapabilitiesPointer;
         os_bit32 reserved_2;
         os_bit32 PrimaryMaxLat_PrimaryMinGnt_PrimaryInterruptPin_PrimaryInterruptLine;
       };

typedef struct I21554_Secondary_Interface_Config_s
               I21554_Secondary_Interface_Config_t;

struct I21554_Secondary_Interface_Config_s
       {
         os_bit32 DeviceID_VendorID;
         os_bit32 SecondaryStatus_SecondaryCommand;
         os_bit32 SecondaryClassCode_RevID;
         os_bit32 BIST_HeaderType_SecondaryMLT_SecondaryCLS;
         os_bit32 Secondary_CSR_Memory_BAR;
         os_bit32 Secondary_CSR_IO_BAR;
         os_bit32 Upstream_IO_or_Memory_0_BAR;
         os_bit32 Upstream_Memory_1_BAR;
         os_bit32 Upstream_Memory_2_BAR;
         os_bit32 reserved_1;
         os_bit32 reserved_2;
         os_bit32 SubsystemID_SubsystemVendorID;
         os_bit32 reserved_3;
         os_bit32 reserved_CapabilitiesPointer;
         os_bit32 reserved_4;
         os_bit32 SecondaryMaxLat_SecondaryMinGnt_SecondaryInterruptPin_SecondaryInterruptLine;
       };

typedef struct I21554_Device_Specific_Config_s
               I21554_Device_Specific_Config_t;

struct I21554_Device_Specific_Config_s
       {
         os_bit32 Downstream_Configuration_Address;
         os_bit32 Downstream_Configuration_Data;
         os_bit32 Upstream_Configuration_Address;
         os_bit32 Upstream_Configuration_Data;
         os_bit32 ConfigurationControlAndStatus_ConfigurationOwnBits;
         os_bit32 Downstream_Memory_0_Translated_Base;
         os_bit32 Downstream_IO_or_Memory_1_Translated_Base;
         os_bit32 Downstream_Memory_2_Translated_Base;
         os_bit32 Downstream_Memory_3_Translated_Base;
         os_bit32 Upstream_IO_or_Memory_0_Translated_Base;
         os_bit32 Upstream_Memory_1_Translated_Base;
         os_bit32 Downstream_Memory_0_Setup_Register;
         os_bit32 Downstream_IO_or_Memory_1_Setup_Register;
         os_bit32 Downstream_Memory_2_Setup_Register;
         os_bit32 Downstream_Memory_3_Setup_Register;
         os_bit32 Upper_32_Bits_Downstream_Memory_3_Setup_Register;
         os_bit32 Primary_Expansion_ROM_Setup_Register;
         os_bit32 Upstream_IO_or_Memory_0_Setup_Register;
         os_bit32 Upstream_Memory_1_Setup_Register;
         os_bit32 ChipControl1_ChipControl0;
         os_bit32 ArbiterControl_ChipStatus;
         os_bit32 reserved_SecondarySERRDisables_PrimarySERRDisables;
         os_bit32 Reset_Control;
         os_bit32 PowerManagementCapabilities_NextItemPtr_CapabilityID;
         os_bit32 PMData_PMCSRBSE_PowerManagementCSR;
         os_bit32 VPDAddress_NextItemPtr_CapabilityID;
         os_bit32 VPD_Data;
         os_bit32 reserved_HostSwapControl_NextItemPtr_CapabilityID;
         os_bit8  reserved[0x100-0x0F0];
       };

typedef struct I21554_Primary_Config_s
               I21554_Primary_Config_t;

struct I21554_Primary_Config_s
       {
         I21554_Primary_Interface_Config_t   Primary_Interface;
         I21554_Secondary_Interface_Config_t Secondary_Interface;
         I21554_Device_Specific_Config_t     Device_Specific;
       };

typedef struct I21554_Secondary_Config_s
               I21554_Secondary_Config_t;

struct I21554_Secondary_Config_s
       {
         I21554_Secondary_Interface_Config_t Secondary_Interface;
         I21554_Primary_Interface_Config_t   Primary_Interface;
         I21554_Device_Specific_Config_t     Device_Specific;
       };

#define I21554_Config_VendorID_MASK                                                      (os_bit32)0x0000FFFF
#define I21554_Config_VendorID_Intel                                                     (os_bit32)0x00001011

#define I21554_Config_DeviceID_MASK                                                      (os_bit32)0xFFFF0000
#define I21554_Config_DeviceID_21554                                                     (os_bit32)0x00460000

#define I21554_Config_Command_MASK                                                       (os_bit32)0x0000FFFF
#define I21554_Config_Command_IO_Space_Enable                                            (os_bit32)0x00000001
#define I21554_Config_Command_Memory_Space_Enable                                        (os_bit32)0x00000002
#define I21554_Config_Command_Master_Enable                                              (os_bit32)0x00000004
#define I21554_Config_Command_Special_Cycle_Enable                                       (os_bit32)0x00000008
#define I21554_Config_Command_Memory_Write_and_Invalidate_Enable                         (os_bit32)0x00000010
#define I21554_Config_Command_VGA_Snoop_Enable                                           (os_bit32)0x00000020
#define I21554_Config_Command_Parity_Error_Response                                      (os_bit32)0x00000040
#define I21554_Config_Command_Wait_Cycle_Control                                         (os_bit32)0x00000080
#define I21554_Config_Command_SERR_Enable                                                (os_bit32)0x00000100
#define I21554_Config_Fast_Back_to_Back_Enable                                           (os_bit32)0x00000200

#define I21554_Config_Status_MASK                                                        (os_bit32)0xFFFF0000

#define I21554_Config_Status_ECP_Support                                                 (os_bit32)0x00100000
#define I21554_Config_Status_66_MHz_Capable                                              (os_bit32)0x00200000
#define I21554_Config_Status_Fast_Back_to_Back_Capable                                   (os_bit32)0x00800000
#define I21554_Config_Status_Data_Parity_Detected                                        (os_bit32)0x01000000

#define I21554_Config_Status_DEVSEL_timing_MASK                                          (os_bit32)0x06000000
#define I21554_Config_Status_DEVSEL_timing_SHIFT                                         (os_bit32)0x19

#define I21554_Config_Status_Signaled_Target_Abort                                       (os_bit32)0x08000000
#define I21554_Config_Status_Received_Target_Abort                                       (os_bit32)0x10000000
#define I21554_Config_Status_Received_Master_Abort                                       (os_bit32)0x20000000
#define I21554_Config_Status_Signaled_System_Error                                       (os_bit32)0x40000000
#define I21554_Config_Status_Detected_Parity_Error                                       (os_bit32)0x80000000

#define I21554_Config_RevID_MASK                                                         (os_bit32)0x000000FF
#define I21554_Config_RevID_SHIFT                                                        (os_bit32)0x00

#define I21554_Config_ClassCode_MASK                                                     (os_bit32)0xFFFFFF00

#define I21554_Config_ClassCode_BaseClassCode_MASK                                       (os_bit32)0xFF000000
#define I21554_Config_ClassCode_BaseClassCode_SHIFT                                      (os_bit32)0x18
#define I21554_Config_ClassCode_BaseClassCode_Bridge                                     (os_bit32)0x06

#define I21554_Config_ClassCode_SubClassCode_MASK                                        (os_bit32)0x00FF0000
#define I21554_Config_ClassCode_SubClassCode_SHIFT                                       (os_bit32)0x10
#define I21554_Config_ClassCode_SubClassCode_Other                                       (os_bit32)0x80

#define I21554_Config_ClassCode_ProgIF_MASK                                              (os_bit32)0x0000FF00
#define I21554_Config_ClassCode_ProgIF_SHIFT                                             (os_bit32)0x08
#define I21554_Config_ClassCode_ProgIF_Reads_as_zero                                     (os_bit32)0x00

#define I21554_Config_CLS_MASK                                                           (os_bit32)0x000000FF
#define I21554_Config_CLS_SHIFT                                                          (os_bit32)0x00

#define I21554_Config_MLT_MASK                                                           (os_bit32)0x0000FF00
#define I21554_Config_MLT_SHIFT                                                          (os_bit32)0x08

#define I21554_Config_HeaderType_MASK                                                    (os_bit32)0x00FF0000
#define I21554_Config_HeaderType_Type_0                                                  (os_bit32)0x00000000

#define I21554_Config_BIST_MASK                                                          (os_bit32)0xFF000000

#define I21554_Config_BIST_Completion_Code_MASK                                          (os_bit32)0x0F000000
#define I21554_Config_BIST_Completion_Code_Passed                                        (os_bit32)0x00000000

#define I21554_Config_BIST_Self_Test                                                     (os_bit32)0x40000000

#define I21554_Config_BIST_BiST_Supported                                                (os_bit32)0x80000000

#define I21554_Config_BAR_Space_Indicator_MASK                                           (os_bit32)0x00000001
#define I21554_Config_BAR_Space_Indicator_Memory                                         (os_bit32)0x00000000
#define I21554_Config_BAR_Space_Indicator_IO                                             (os_bit32)0x00000001

#define I21554_Config_Memory_BAR_Type_MASK                                               (os_bit32)0x00000006
#define I21554_Config_Memory_BAR_Type_20_bit                                             (os_bit32)0x00000002
#define I21554_Config_Memory_BAR_Type_32_bit                                             (os_bit32)0x00000000
#define I21554_Config_Memory_BAR_Type_64_bit                                             (os_bit32)0x00000004

#define I21554_Config_Memory_BAR_Prefetchable                                            (os_bit32)0x00000008

#define I21554_Config_BAR_Base_Address_MASK                                              (os_bit32)0xFFFFFFF0
#define I21554_Config_BAR_Base_Address_SHIFT                                             (os_bit32)0x00

#define I21554_Config_SubsystemVendorID_MASK                                             (os_bit32)0x0000FFFF
#define I21554_Config_SubsystemID_MASK                                                   (os_bit32)0xFFFF0000

#define I21554_Config_Expansion_ROM_Enable                                               (os_bit32)0x00000001

#define I21554_Config_Expansion_ROM_Base_Address_MASK                                    (os_bit32)0xFFFFF000
#define I21554_Config_Expansion_ROM_Base_Address_SHIFT                                   (os_bit32)0x00

#define I21554_Config_CapabilitiesPointer_MASK                                           (os_bit32)0x000000FF
#define I21554_Config_CapabilitiesPointer_SHIFT                                          (os_bit32)0x00

#define I21554_Config_InterruptLine_MASK                                                 (os_bit32)0x000000FF
#define I21554_Config_InterruptLine_SHIFT                                                (os_bit32)0x00

#define I21554_Config_InterruptPin_MASK                                                  (os_bit32)0x0000FF00
#define I21554_Config_InterruptPin_SHIFT                                                 (os_bit32)0x08

#define I21554_Config_MinGnt_MASK                                                        (os_bit32)0x00FF0000
#define I21554_Config_MinGnt_SHIFT                                                       (os_bit32)0x10

#define I21554_Config_MaxLat_MASK                                                        (os_bit32)0xFF000000
#define I21554_Config_MaxLat_SHIFT                                                       (os_bit32)0x18

#define I21554_Config_ConfigurationOwnBits_MASK                                          (os_bit32)0x0000FFFF
#define I21554_Config_ConfigurationOwnBits_Downstream_Own_Bit                            (os_bit32)0x00000001
#define I21554_Config_ConfigurationOwnBits_Upstream_Own_Bit                              (os_bit32)0x00000100

#define I21554_Config_ConfigurationControlAndStatus_MASK                                 (os_bit32)0xFFFF0000
#define I21554_Config_ConfigurationControlAndStatus_Downstream_Own_Status                (os_bit32)0x00010000
#define I21554_Config_ConfigurationControlAndStatus_Downstream_Control                   (os_bit32)0x00020000
#define I21554_Config_ConfigurationControlAndStatus_Upstream_Own_Status                  (os_bit32)0x01000000
#define I21554_Config_ConfigurationControlAndStatus_Upstream_Control                     (os_bit32)0x02000000

#define I21554_Config_Memory_or_IO_Setup_Indicator_MASK                                  (os_bit32)0x00000001
#define I21554_Config_Memory_or_IO_Setup_Space_Indicator_Memory                          (os_bit32)0x00000000
#define I21554_Config_Memory_or_IO_Setup_Space_Indicator_IO                              (os_bit32)0x00000001

#define I21554_Config_Memory_Setup_Type_MASK                                             (os_bit32)0x00000006
#define I21554_Config_Memory_Setup_Type_20_bit                                           (os_bit32)0x00000002
#define I21554_Config_Memory_Setup_Type_32_bit                                           (os_bit32)0x00000000
#define I21554_Config_Memory_Setup_Type_64_bit                                           (os_bit32)0x00000004

#define I21554_Config_Memory_Setup_Prefetchable                                          (os_bit32)0x00000008

#define I21554_Config_Memory_or_IO_Setup_Size_MASK                                       (os_bit32)0x7FFFFFC0
#define I21554_Config_Memory_or_IO_Setup_Size_SHIFT                                      (os_bit32)0x00

#define I21554_Config_Memory_or_IO_Setup_BAR_Enable                                      (os_bit32)0x80000000

#define I21554_Config_Upper_32_Bits_Downstream_Memory_3_Setup_Size_MASK                  (os_bit32)0x7FFFFFFF
#define I21554_Config_Upper_32_Bits_Downstream_Memory_3_Setup_Size_SHIFT                 (os_bit32)0x00
#define I21554_Config_Upper_32_Bits_Downstream_Memory_3_Setup_BAR_Enable                 (os_bit32)0x80000000

#define I21554_Config_Primary_Expansion_ROM_Setup_Size_MASK                              (os_bit32)0x00FFF000
#define I21554_Config_Primary_Expansion_ROM_Setup_Size_SHIFT                             (os_bit32)0x00FFF000
#define I21554_Config_Primary_Expansion_ROM_Setup_BAR_Enable                             (os_bit32)0x01000000

#define I21554_Config_ChipControl0_MASK                                                  (os_bit32)0x0000FFFF

#define I21554_Config_ChipControl0_Master_Abort_Mode                                     (os_bit32)0x00000001
#define I21554_Config_ChipControl0_Memory_Write_Disconnect_Control                       (os_bit32)0x00000002

#define I21554_Config_ChipControl0_Primary_Master_Timeout_MASK                           (os_bit32)0x00000004
#define I21554_Config_ChipControl0_Primary_Master_Timeout_32768_clocks                   (os_bit32)0x00000000
#define I21554_Config_ChipControl0_Primary_Master_Timeout_1024_clocks                    (os_bit32)0x00000004

#define I21554_Config_ChipControl0_Secondary_Master_Timeout_MASK                         (os_bit32)0x00000008
#define I21554_Config_ChipControl0_Secondary_Master_Timeout_32768_clocks                 (os_bit32)0x00000000
#define I21554_Config_ChipControl0_Secondary_Master_Timeout_1024_clocks                  (os_bit32)0x00000008

#define I21554_Config_ChipControl0_Primary_Master_Timeout_Disable                        (os_bit32)0x00000010
#define I21554_Config_ChipControl0_Secondary_Master_Timeout_Disable                      (os_bit32)0x00000020
#define I21554_Config_ChipControl0_Delayed_Transaction_Order_Control                     (os_bit32)0x00000040
#define I21554_Config_ChipControl0_SERR_Forward_Enable                                   (os_bit32)0x00000080
#define I21554_Config_ChipControl0_Upstream_DAC_Prefetch_Disable                         (os_bit32)0x00000100
#define I21554_Config_ChipControl0_Multiple_Device_Enable                                (os_bit32)0x00000200
#define I21554_Config_ChipControl0_Primary_Access_Lockout                                (os_bit32)0x00000400
#define I21554_Config_ChipControl0_Secondary_Clock_Disable                               (os_bit32)0x00000800

#define I21554_Config_ChipControl0_VGA_Mode_MASK                                         (os_bit32)0x0000C000
#define I21554_Config_ChipControl0_VGA_Mode_Neither_Forwarded                            (os_bit32)0x00000000
#define I21554_Config_ChipControl0_VGA_Mode_Primary_Forwarded                            (os_bit32)0x00004000
#define I21554_Config_ChipControl0_VGA_Mode_Secondary_Forwarded                          (os_bit32)0x00008000

#define I21554_Config_ChipControl1_MASK                                                  (os_bit32)0xFFFF0000

#define I21554_Config_ChipControl1_Primary_Posted_Write_Threshold_MASK                   (os_bit32)0x00010000
#define I21554_Config_ChipControl1_Primary_Posted_Write_Threshold_Full_Cache_Line        (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Primary_Posted_Write_Threshold_Half_Cache_Line        (os_bit32)0x00010000

#define I21554_Config_ChipControl1_Secondary_Posted_Write_Threshold_MASK                 (os_bit32)0x00020000
#define I21554_Config_ChipControl1_Secondary_Posted_Write_Threshold_Full_Cache_Line      (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Secondary_Posted_Write_Threshold_Half_Cache_Line      (os_bit32)0x00020000

#define I21554_Config_ChipControl1_Primary_Delayed_Read_Threshold_MASK                   (os_bit32)0x000C0000
#define I21554_Config_ChipControl1_Primary_Delayed_Read_Threshold_8_DWords               (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Primary_Delayed_Read_Threshold_Mixture                (os_bit32)0x00080000
#define I21554_Config_ChipControl1_Primary_Delayed_Read_Threshold_Cache_Line             (os_bit32)0x000C0000

#define I21554_Config_ChipControl1_Secondary_Delayed_Read_Threshold_MASK                 (os_bit32)0x00300000
#define I21554_Config_ChipControl1_Secondary_Delayed_Read_Threshold_8_DWords             (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Secondary_Delayed_Read_Threshold_Mixture              (os_bit32)0x00200000
#define I21554_Config_ChipControl1_Secondary_Delayed_Read_Threshold_Cache_Line           (os_bit32)0x00300000

#define I21554_Config_ChipControl1_Subtractive_Decode_Enable_MASK                        (os_bit32)0x00C00000
#define I21554_Config_ChipControl1_Subtractive_Decode_Off                                (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Subtractive_Decode_IO_on_Primary                      (os_bit32)0x00400000
#define I21554_Config_ChipControl1_Subtractive_Decode_IO_on_Secondary                    (os_bit32)0x00800000

#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_MASK                      (os_bit32)0x0F000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_Disable                   (os_bit32)0x00000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_256B                      (os_bit32)0x01000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_512B                      (os_bit32)0x02000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_1KB                       (os_bit32)0x03000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_2KB                       (os_bit32)0x04000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_4KB                       (os_bit32)0x05000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_8KB                       (os_bit32)0x06000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_16KB                      (os_bit32)0x07000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_32KB                      (os_bit32)0x08000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_64KB                      (os_bit32)0x09000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_128KB                     (os_bit32)0x0A000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_256KB                     (os_bit32)0x0B000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_512KB                     (os_bit32)0x0C000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_1MB                       (os_bit32)0x0D000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_2MB                       (os_bit32)0x0E000000
#define I21554_Config_ChipControl1_Upstream_Memory_2_Page_Size_4MB                       (os_bit32)0x0F000000

#define I21554_Config_ChipControl1_I2O_ENA                                               (os_bit32)0x10000000

#define I21554_Config_ChipControl1_I20_SIZE_MASK                                         (os_bit32)0xE0000000
#define I21554_Config_ChipControl1_I20_SIZE_256_entries                                  (os_bit32)0x00000000
#define I21554_Config_ChipControl1_I20_SIZE_512_entries                                  (os_bit32)0x20000000
#define I21554_Config_ChipControl1_I20_SIZE_1K_entries                                   (os_bit32)0x40000000
#define I21554_Config_ChipControl1_I20_SIZE_2K_entries                                   (os_bit32)0x60000000
#define I21554_Config_ChipControl1_I20_SIZE_4K_entries                                   (os_bit32)0x80000000
#define I21554_Config_ChipControl1_I20_SIZE_8K_entries                                   (os_bit32)0xA0000000
#define I21554_Config_ChipControl1_I20_SIZE_16K_entries                                  (os_bit32)0xC0000000
#define I21554_Config_ChipControl1_I20_SIZE_32K_entries                                  (os_bit32)0xE0000000

#define I21554_Config_ChipStatus_MASK                                                    (os_bit32)0x0000FFFF
#define I21554_Config_ChipStatus_Downstream_Delayed_Transaction_Master_TimeOut           (os_bit32)0x00000001
#define I21554_Config_ChipStatus_Downstream_Delayed_Read_Transaction_Discarded           (os_bit32)0x00000002
#define I21554_Config_ChipStatus_Downstream_Delayed_Write_Transaction_Discarded          (os_bit32)0x00000004
#define I21554_Config_ChipStatus_Downstream_Posted_Write_Data_Discarded                  (os_bit32)0x00000008
#define I21554_Config_ChipStatus_Upstream_Delayed_Transaction_Master_TimeOut             (os_bit32)0x00000100
#define I21554_Config_ChipStatus_Upstream_Delayed_Read_Transaction_Discarded             (os_bit32)0x00000200
#define I21554_Config_ChipStatus_Upstream_Delayed_Write_Transaction_Discarded            (os_bit32)0x00000400
#define I21554_Config_ChipStatus_Upstream_Posted_Write_Data_Discarded                    (os_bit32)0x00000800

#define I21554_Config_ArbiterControl_MASK                                                (os_bit32)0x03FF0000

#define I21554_Config_PrimarySERRDisables_MASK                                           (os_bit32)0x000000FF
#define I21554_Config_PrimarySERRDisables_Downstream_Delayed_Transaction_Master_TimeOut  (os_bit32)0x00000001
#define I21554_Config_PrimarySERRDisables_Downstream_Delayed_Read_Transaction_Discarded  (os_bit32)0x00000002
#define I21554_Config_PrimarySERRDisables_Downstream_Delayed_Write_Transaction_Discarded (os_bit32)0x00000004
#define I21554_Config_PrimarySERRDisables_Downstream_Posted_Write_Data_Discarded         (os_bit32)0x00000008
#define I21554_Config_PrimarySERRDisables_Target_Abort_during_Downstream_Posted_Write    (os_bit32)0x00000010
#define I21554_Config_PrimarySERRDisables_Master_Abort_during_Downstream_Posted_Write    (os_bit32)0x00000020
#define I21554_Config_PrimarySERRDisables_Downstream_Posted_Write_Parity_Error           (os_bit32)0x00000040

#define I21554_Config_SecondarySERRDisables_MASK                                         (os_bit32)0x0000FF00
#define I21554_Config_SecondarySERRDisables_Upstream_Delayed_Transaction_Master_TimeOut  (os_bit32)0x00000100
#define I21554_Config_SecondarySERRDisables_Upstream_Delayed_Read_Transaction_Discarded  (os_bit32)0x00000200
#define I21554_Config_SecondarySERRDisables_Upstream_Delayed_Write_Transaction_Discarded (os_bit32)0x00000400
#define I21554_Config_SecondarySERRDisables_Upstream_Posted_Write_Data_Discarded         (os_bit32)0x00000800
#define I21554_Config_SecondarySERRDisables_Target_Abort_during_Upstream_Posted_Write    (os_bit32)0x00001000
#define I21554_Config_SecondarySERRDisables_Master_Abort_during_Upstream_Posted_Write    (os_bit32)0x00002000
#define I21554_Config_SecondarySERRDisables_Upstream_Posted_Write_Parity_Error           (os_bit32)0x00004000

#define I21554_Config_Reset_Control_Secondary_Reset                                      (os_bit32)0x00000001
#define I21554_Config_Reset_Control_Chip_Reset                                           (os_bit32)0x00000002
#define I21554_Config_Reset_Control_Subsystem_Status                                     (os_bit32)0x00000004
#define I21554_Config_Reset_Control_I_stat_Status                                        (os_bit32)0x00000008

#define I21554_Config_CapabilityID_MASK                                                  (os_bit32)0x000000FF
#define I21554_Config_CapabilityID_PM_ECP                                                (os_bit32)0x00000001
#define I21554_Config_CapabilityID_VPD                                                   (os_bit32)0x00000003
#define I21554_Config_CapabilityID_HS_ECP                                                (os_bit32)0x00000006

#define I21554_Config_NextItemPtr_MASK                                                   (os_bit32)0x0000FF00
#define I21554_Config_NextItemPtr_SHIFT                                                  (os_bit32)0x08

#define I21554_Config_PowerManagementCapabilities_MASK                                   (os_bit32)0xFFFF0000

#define I21554_Config_PowerManagementCapabilities_PM_Version_MASK                        (os_bit32)0x00070000
#define I21554_Config_PowerManagementCapabilities_PM_Version_1_0                         (os_bit32)0x00010000

#define I21554_Config_PowerManagementCapabilities_PME_Clock                              (os_bit32)0x00080000
#define I21554_Config_PowerManagementCapabilities_APS                                    (os_bit32)0x00100000
#define I21554_Config_PowerManagementCapabilities_DSI                                    (os_bit32)0x00200000
#define I21554_Config_PowerManagementCapabilities_D1_Support                             (os_bit32)0x02000000
#define I21554_Config_PowerManagementCapabilities_D2_Support                             (os_bit32)0x04000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D0                   (os_bit32)0x08000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D1                   (os_bit32)0x10000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D2                   (os_bit32)0x20000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D3_Hot               (os_bit32)0x40000000
#define I21554_Config_PowerManagementCapabilities_PME_Asserted_From_D3_Cold              (os_bit32)0x80000000

#define I21554_Config_PowerManagementCSR_MASK                                            (os_bit32)0x0000FFFF

#define I21554_Config_PowerManagementCSR_PWR_State_MASK                                  (os_bit32)0x00000003
#define I21554_Config_PowerManagementCSR_PWR_State_D0                                    (os_bit32)0x00000000
#define I21554_Config_PowerManagementCSR_PWR_State_D1                                    (os_bit32)0x00000001
#define I21554_Config_PowerManagementCSR_PWR_State_D2                                    (os_bit32)0x00000002
#define I21554_Config_PowerManagementCSR_PWR_State_D3                                    (os_bit32)0x00000003

#define I21554_Config_PowerManagementCSR_DYN_DATA                                        (os_bit32)0x00000010

#define I21554_Config_PowerManagementCSR_PME_EN                                          (os_bit32)0x00000100

#define I21554_Config_PowerManagementCSR_DATA_SEL                                        (os_bit32)0x00001E00

#define I21554_Config_PowerManagementCSR_Data_Scale_MASK                                 (os_bit32)0x00006000
#define I21554_Config_PowerManagementCSR_Data_Scale_SHIFT                                (os_bit32)0x0D

#define I21554_Config_PowerManagementCSR_PME_Status                                      (os_bit32)0x00008000

#define I21554_Config_PMCSRBSE_MASK                                                      (os_bit32)0x00FF0000
#define I21554_Config_PMCSRBSE_SHIFT                                                     (os_bit32)0x10

#define I21554_Config_PMData_MASK                                                        (os_bit32)0xFF000000
#define I21554_Config_PMData_SHIFT                                                       (os_bit32)0x18

#define I21554_Config_VPDAddress_MASK                                                    (os_bit32)0xFFFF0000

#define I21554_Config_VPDAddress_Addr_MASK                                               (os_bit32)0x01FF0000
#define I21554_Config_VPDAddress_Addr_SHIFT                                              (os_bit32)0x10

#define I21554_Config_VPDAddress_Flag                                                    (os_bit32)0x80000000

#define I21554_Config_HostSwapControl_MASK                                               (os_bit32)0x00FF0000
#define I21554_Config_HostSwapControl_ENUM_MASK                                          (os_bit32)0x00020000
#define I21554_Config_HostSwapControl_LED_On                                             (os_bit32)0x00080000
#define I21554_Config_HostSwapControl_REM_STAT                                           (os_bit32)0x00400000
#define I21554_Config_HostSwapControl_INS_STAT                                           (os_bit32)0x00800000

/*+
CSR Address Map
-*/

typedef struct I21554_CSR_s
               I21554_CSR_t;

struct I21554_CSR_s
       {
         os_bit32 Downstream_Configuration_Address;
         os_bit32 Downstream_Configuration_Data;
         os_bit32 Upstream_Configuration_Address;
         os_bit32 Upstream_Configuration_Data;
         os_bit32 ConfigurationControlAndStatus_ConfigurationOwnBits;
         os_bit32 Downstream_IO_Address;
         os_bit32 Downstream_IO_Data;
         os_bit32 Upstream_IO_Address;
         os_bit32 Upstream_IO_Data;
         os_bit32 IOControlAndStatus_IOOwnBits;
         os_bit32 reserved_LookupTableOffset;
         os_bit32 Lookup_Table_Data;
         os_bit32 I2O_Outbound_Post_List_Status;
         os_bit32 I2O_Outbound_Post_List_Interrupt_Mask;
         os_bit32 I2O_Inbound_Post_List_Status;
         os_bit32 I2O_Inbound_Post_List_Interrupt_Mask;
         os_bit32 I2O_Inbound_Queue;
         os_bit32 I2O_Outbound_Queue;
         os_bit32 I2O_Inbound_Free_List_Head_Pointer;
         os_bit32 I2O_Inbound_Post_List_Tail_Pointer;
         os_bit32 I2O_Outbound_Free_List_Tail_Pointer;
         os_bit32 I2O_Outbound_Post_List_Head_Pointer;
         os_bit32 I2O_Inbound_Post_List_Counter;
         os_bit32 I2O_Inbound_Free_List_Counter;
         os_bit32 I2O_Outbound_Post_List_Counter;
         os_bit32 I2O_Outbound_Free_List_Counter;
         os_bit32 Downstream_Memory_0_Translated_Base;
         os_bit32 Downstream_IO_or_Memory_1_Translated_Base;
         os_bit32 Downstream_Memory_2_Translated_Base;
         os_bit32 Downstream_Memory_3_Translated_Base;
         os_bit32 Upstream_IO_or_Memory_0_Translated_Base;
         os_bit32 Upstream_Memory_1_Translated_Base;
         os_bit32 ChipStatusCSR_reserved;
         os_bit32 ChipClearIRQMaskRegister_ChipSetIRQMaskRegister;
         os_bit32 Upstream_Page_Boundary_IRQ_0_Register;
         os_bit32 Upstream_Page_Boundary_IRQ_1_Register;
         os_bit32 Upstream_Page_Boundary_IRQ_Mask_0_Register;
         os_bit32 Upstream_Page_Boundary_IRQ_Mask_1_Register;
         os_bit32 SecondaryClearIRQ_PrimaryClearIRQ;
         os_bit32 SecondarySetIRQ_PrimarySetIRQ;
         os_bit32 SecondaryClearIRQMask_PrimaryClearIRQMask;
         os_bit32 SecondarySetIRQMask_PrimarySetIRQMask;
         os_bit32 Scratchpad_0;
         os_bit32 Scratchpad_1;
         os_bit32 Scratchpad_2;
         os_bit32 Scratchpad_3;
         os_bit32 Scratchpad_4;
         os_bit32 Scratchpad_5;
         os_bit32 Scratchpad_6;
         os_bit32 Scratchpad_7;
         os_bit32 reserved_ROMData_ROMSetup;
         os_bit32 ROMControl_ROMAddress;
         os_bit8  reserved_1[0x0100-0x00D0];
         os_bit8  Upstream_Memory_2_Lookup_Table[0x0200-0x0100];
         os_bit8  reserved_2[0x1000-0x0200];
       };

#define I21554_CSR_ConfigurationOwnBits_MASK                                             (os_bit32)0x0000FFFF
#define I21554_CSR_ConfigurationOwnBits_Downstream_IO_Own_Bit                            (os_bit32)0x00000001
#define I21554_CSR_ConfigurationOwnBits_Upstream_IO_Own_Bit                              (os_bit32)0x00000100

#define I21554_CSR_ConfigurationControlAndStatus_MASK                                    (os_bit32)0xFFFF0000
#define I21554_CSR_ConfigurationControlAndStatus_Downstream_IO_Own_Bit_Status            (os_bit32)0x00010000
#define I21554_CSR_ConfigurationControlAndStatus_Downstream_IO_Control                   (os_bit32)0x00020000
#define I21554_CSR_ConfigurationControlAndStatus_Upstream_IO_Own_Bit_Status              (os_bit32)0x01000000
#define I21554_CSR_ConfigurationControlAndStatus_Upstream_IO_Control                     (os_bit32)0x02000000

#define I21554_CSR_IOOwnBits_MASK                                                        (os_bit32)0x0000FFFF
#define I21554_CSR_IOOwnBits_Downstream_IO_Own_Bit                                       (os_bit32)0x00000001
#define I21554_CSR_IOOwnBits_Upstream_IO_Own_Bit                                         (os_bit32)0x00000100

#define I21554_CSR_IOControlAndStatus_MASK                                               (os_bit32)0xFFFF0000
#define I21554_CSR_IOControlAndStatus_Downstream_IO_Own_Bit_Status                       (os_bit32)0x00010000
#define I21554_CSR_IOControlAndStatus_Downstream_IO_Control                              (os_bit32)0x00020000
#define I21554_CSR_IOControlAndStatus_Upstream_IO_Own_Bit_Status                         (os_bit32)0x01000000
#define I21554_CSR_IOControlAndStatus_Upstream_IO_Control                                (os_bit32)0x02000000

#define I21554_CSR_LookupTableOffset_MASK                                                (os_bit32)0x000000FF
#define I21554_CSR_LookupTableOffset_SHIFT                                               (os_bit32)0x00

#define I21554_CSR_Lookup_Table_Data_Valid_Bit                                           (os_bit32)0x00000001
#define I21554_CSR_Lookup_Table_Data_Prefetchable                                        (os_bit32)0x00000008
#define I21554_CSR_Lookup_Table_Data_Translated_Base_MASK                                (os_bit32)0xFFFFFF00

#define I21554_CSR_I2O_Outbound_Post_List_Status_MASK                                    (os_bit32)0x00000008
#define I21554_CSR_I2O_Outbound_Post_List_Status_Empty                                   (os_bit32)0x00000000
#define I21554_CSR_I2O_Outbound_Post_List_Status_Not_Empty                               (os_bit32)0x00000008

#define I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask                                 (os_bit32)0x00000008

#define I21554_CSR_I2O_Inbound_Post_List_Status_MASK                                     (os_bit32)0x00000008
#define I21554_CSR_I2O_Inbound_Post_List_Status_Empty                                    (os_bit32)0x00000000
#define I21554_CSR_I2O_Inbound_Post_List_Status_Not_Empty                                (os_bit32)0x00000008

#define I21554_CSR_I2O_Inbound_Post_List_Interrupt_Mask                                  (os_bit32)0x00000008

#define I21554_CSR_I2O_Inbound_Free_List_Head_Pointer_MASK                               (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Inbound_Free_List_Head_Pointer_SHIFT                              (os_bit32)0x00

#define I21554_CSR_I2O_Inbound_Post_List_Tail_Pointer_MASK                               (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Inbound_Post_List_Tail_Pointer_SHIFT                              (os_bit32)0x00

#define I21554_CSR_I2O_Outbound_Free_List_Tail_Pointer_MASK                              (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Outbound_Free_List_Tail_Pointer_SHIFT                             (os_bit32)0x00

#define I21554_CSR_I2O_Outbound_Free_List_Tail_Pointer_MASK                              (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Outbound_Free_List_Tail_Pointer_SHIFT                             (os_bit32)0x00

#define I21554_CSR_I2O_Outbound_Post_List_Head_Pointer_MASK                              (os_bit32)0xFFFFFFFC
#define I21554_CSR_I2O_Outbound_Post_List_Head_Pointer_SHIFT                             (os_bit32)0x00

#define I21554_CSR_I2O_Inbound_Post_List_Counter_MASK                                    (os_bit32)0x0000FFFF

#define I21554_CSR_I2O_Inbound_Post_List_Counter_Set_or_Decrement_MASK                   (os_bit32)0x80000000
#define I21554_CSR_I2O_Inbound_Post_List_Counter_Set                                     (os_bit32)0x80000000
#define I21554_CSR_I2O_Inbound_Post_List_Counter_Decrement                               (os_bit32)0x00000000

#define I21554_CSR_I2O_Inbound_Free_List_Counter_MASK                                    (os_bit32)0x0000FFFF

#define I21554_CSR_I2O_Inbound_Free_List_Counter_Set_or_Increment_MASK                   (os_bit32)0x80000000
#define I21554_CSR_I2O_Inbound_Free_List_Counter_Set                                     (os_bit32)0x80000000
#define I21554_CSR_I2O_Inbound_Free_List_Counter_Increment                               (os_bit32)0x00000000

#define I21554_CSR_I2O_Outbound_Post_List_Counter_MASK                                   (os_bit32)0x0000FFFF

#define I21554_CSR_I2O_Outbound_Post_List_Counter_Set_or_Increment_MASK                  (os_bit32)0x80000000
#define I21554_CSR_I2O_Outbound_Post_List_Counter_Set                                    (os_bit32)0x80000000
#define I21554_CSR_I2O_Outbound_Post_List_Counter_Increment                              (os_bit32)0x00000000

#define I21554_CSR_I2O_Outbound_Free_List_Counter_MASK                                   (os_bit32)0x0000FFFF

#define I21554_CSR_I2O_Outbound_Free_List_Counter_Set_or_Decrement_MASK                  (os_bit32)0x80000000
#define I21554_CSR_I2O_Outbound_Free_List_Counter_Set                                    (os_bit32)0x80000000
#define I21554_CSR_I2O_Outbound_Free_List_Counter_Decrement                              (os_bit32)0x00000000

#define I21554_CSR_ChipStatusCSR_MASK                                                    (os_bit32)0xFFFF0000
#define I21554_CSR_ChipStatusCSR_PM_D0                                                   (os_bit32)0x00010000
#define I21554_CSR_ChipStatusCSR_Subsystem_Event                                         (os_bit32)0x00020000

#define I21554_CSR_ChipSetIRQMaskRegister_MASK                                           (os_bit32)0x0000FFFF
#define I21554_CSR_ChipSetIRQMaskRegister_Set_D0M                                        (os_bit32)0x00000001
#define I21554_CSR_ChipSetIRQMaskRegister_Set_Sstat                                      (os_bit32)0x00000002

#define I21554_CSR_ChipClearIRQMaskRegister_MASK                                         (os_bit32)0xFFFF0000
#define I21554_CSR_ChipClearIRQMaskRegister_Clr_D0M                                      (os_bit32)0x00010000
#define I21554_CSR_ChipClearIRQMaskRegister_Clr_Sstat                                    (os_bit32)0x00020000

#define I21554_CSR_PrimaryClearIRQ_MASK                                                  (os_bit32)0x0000FFFF
#define I21554_CSR_PrimaryClearIRQ_SHIFT                                                 (os_bit32)0x00

#define I21554_CSR_SecondaryClearIRQ_MASK                                                (os_bit32)0xFFFF0000
#define I21554_CSR_SecondaryClearIRQ_SHIFT                                               (os_bit32)0x10

#define I21554_CSR_PrimarySetIRQ_MASK                                                    (os_bit32)0x0000FFFF
#define I21554_CSR_PrimarySetIRQ_SHIFT                                                   (os_bit32)0x00

#define I21554_CSR_SecondarySetIRQ_MASK                                                  (os_bit32)0xFFFF0000
#define I21554_CSR_SecondarySetIRQ_SHIFT                                                 (os_bit32)0x10

#define I21554_CSR_PrimaryClearIRQMask_MASK                                              (os_bit32)0x0000FFFF
#define I21554_CSR_PrimaryClearIRQMask_SHIFT                                             (os_bit32)0x00

#define I21554_CSR_SecondaryClearIRQMask_MASK                                            (os_bit32)0xFFFF0000
#define I21554_CSR_SecondaryClearIRQMask_SHIFT                                           (os_bit32)0x10

#define I21554_CSR_PrimarySetIRQMask_MASK                                                (os_bit32)0x0000FFFF
#define I21554_CSR_PrimarySetIRQMask_SHIFT                                               (os_bit32)0x00

#define I21554_CSR_SecondarySetIRQMask_MASK                                              (os_bit32)0xFFFF0000
#define I21554_CSR_SecondarySetIRQMask_SHIFT                                             (os_bit32)0x10

#define I21554_CSR_ROMSetup_MASK                                                         (os_bit32)0x0000FFFF

#define I21554_CSR_ROMSetup_Access_Time_MASK                                             (os_bit32)0x00000003
#define I21554_CSR_ROMSetup_Access_Time_8_clocks                                         (os_bit32)0x00000000
#define I21554_CSR_ROMSetup_Access_Time_16_clocks                                        (os_bit32)0x00000001
#define I21554_CSR_ROMSetup_Access_Time_64_clocks                                        (os_bit32)0x00000002
#define I21554_CSR_ROMSetup_Access_Time_256_clocks                                       (os_bit32)0x00000003

#define I21554_CSR_ROMSetup_Strobe_Mask_MASK                                             (os_bit32)0x0000FF00
#define I21554_CSR_ROMSetup_Strobe_Mask_8_clocks                                         (os_bit32)0x00000000
#define I21554_CSR_ROMSetup_Strobe_Mask_16_clocks                                        (os_bit32)0x00000100
#define I21554_CSR_ROMSetup_Strobe_Mask_64_clocks                                        (os_bit32)0x00000200
#define I21554_CSR_ROMSetup_Strobe_Mask_256_clocks                                       (os_bit32)0x00000300

#define I21554_CSR_ROMData_MASK                                                          (os_bit32)0x00FF0000
#define I21554_CSR_ROMData_SHIFT                                                         (os_bit32)0x10

#define I21554_CSR_ROMAddress_MASK                                                       (os_bit32)0x00FFFFFF

#define I21554_CSR_ROMAddress_Byte_Address_MASK                                          (os_bit32)0x000001FF

#define I21554_CSR_ROMAddress_Sub_Opcode_MASK                                            (os_bit32)0x00000180
#define I21554_CSR_ROMAddress_Sub_Opcode_Write_Disable                                   (os_bit32)0x00000000
#define I21554_CSR_ROMAddress_Sub_Opcode_Write_All                                       (os_bit32)0x00000080
#define I21554_CSR_ROMAddress_Sub_Opcode_Erase_All                                       (os_bit32)0x00000100
#define I21554_CSR_ROMAddress_Sub_Opcode_Write_Enable                                    (os_bit32)0x00000180

#define I21554_CSR_ROMAddress_Opcode_MASK                                                (os_bit32)0x00000600
#define I21554_CSR_ROMAddress_Opcode_Do_Sub_Opcode                                       (os_bit32)0x00000000
#define I21554_CSR_ROMAddress_Opcode_Write                                               (os_bit32)0x00000200
#define I21554_CSR_ROMAddress_Opcode_Read                                                (os_bit32)0x00000400
#define I21554_CSR_ROMAddress_Opcode_Erase                                               (os_bit32)0x00000600

#define I21554_CSR_ROMControl_MASK                                                       (os_bit32)0xFF000000
#define I21554_CSR_ROMControl_Serial_ROM_Start_Busy                                      (os_bit32)0x01000000
#define I21554_CSR_ROMControl_Parallel_ROM_Start_Busy                                    (os_bit32)0x02000000
#define I21554_CSR_ROMControl_Read_Write_Control                                         (os_bit32)0x04000000
#define I21554_CSR_ROMControl_SROM_POLL                                                  (os_bit32)0x08000000

#endif /* __I21554_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\ip.c ===
/*++

Purpose:

  This file implements IP specific services for the FC Layer.

--*/
#ifdef _DvrArch_1_30_

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"
#include "../h/ipstate.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/ip.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "ipstate.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "ip.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */



void fiFillInIPFrameHeader_OffCard(
                                     PktThread_t *PktThread,
                                     os_bit32     D_ID
                                   )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t    *hpRoot       = PktThread->thread_hdr.hpRoot;
    DevThread_t *DevThread    = PktThread->Device;
    CThread_t   *CThread      = CThread_ptr(hpRoot);
    FCHS_t      *IP_Header    = PktThread->Pkt_CMND_Ptr;
    os_bit32     R_CTL__D_ID;
    os_bit32     S_ID = 0;
    os_bit32     TYPE__F_CTL;
    os_bit32     OX_ID__RX_ID;

    S_ID = fiComputeCThread_S_ID(CThread);

    R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                   | FC_Frame_Header_R_CTL_Lo_Unsolicited_Data
                   | D_ID                                             );

    TYPE__F_CTL = (  FC_Frame_Header_TYPE_8802_2_LLC_SNAP
                   | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                   | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                   | (DevThread->NewIPExchange ? FC_Frame_Header_F_CTL_First_Sequence : 0 )
                   | FC_Frame_Header_F_CTL_End_Sequence);

    OX_ID__RX_ID = (  (DevThread->IP_X_ID << FCHS_OX_ID_SHIFT)
                    | (0xFFFF             << FCHS_RX_ID_SHIFT));

    IP_Header->MBZ1                                        = 0;
    IP_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp = FCHS_SOF_SOFi3
                                                           | FCHS_EOF_EOFn
                                                           | FCHS_CLS
							   | 1 << FCHS_LCr_SHIFT;
    IP_Header->R_CTL__D_ID                                 = R_CTL__D_ID;
    IP_Header->CS_CTL__S_ID                                = S_ID;
    IP_Header->TYPE__F_CTL                                 = TYPE__F_CTL;
    IP_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_Network_Header;
    IP_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    IP_Header->RO                                          = 0;

    fiLogDebugString(
                      hpRoot,
                      PktStateLogConsoleLevel,
                      " <<< IPData -- 0x%06X -> 0x%06X >>>",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      S_ID,
                      D_ID,
                      0,0,0,0,0,0
                    );

#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiFillInIPNetworkHeader_OffCard(
                                      PktThread_t *PktThread
                                    )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t  *hpRoot                  = PktThread->thread_hdr.hpRoot;
    CThread_t *CThread                 = CThread_ptr(hpRoot);
    os_bit8   *pNetwork_Header         = (os_bit8 *) PktThread->Pkt_CMND_Ptr + sizeof(FCHS_t);
    os_bit32   Bit8_Index;

/*+
Fill in Network Destination Address
-*/
    for (Bit8_Index = 0; Bit8_Index < sizeof(FC_N_Port_Name_t); Bit8_Index++)
        *pNetwork_Header++ = PktThread->Device->DevInfo.PortWWN[Bit8_Index];

/*+
Fill in Network Source Address
-*/
    for (Bit8_Index = 0; Bit8_Index < sizeof(FC_N_Port_Name_t); Bit8_Index++)
        *pNetwork_Header++ = CThread->ChanInfo.PortWWN[Bit8_Index];

#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiFillInIPData(
                         PktThread_t *PktThread
                       )
{
    if (CThread_ptr(PktThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.Pkt_CMND.memLoc == inCardRam)
    {
        return fiFillInIPData_OnCard( PktThread );
    }
    else /* CThread_ptr(PktThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.Pkt_CMND.memLoc == inDmaMemory */
    {
        return fiFillInIPData_OffCard( PktThread );
    }
}

os_bit32 fiFillInIPData_OnCard(
                               PktThread_t *PktThread
                              )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    return (os_bit32)0;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInIPData_OffCard(
                                 PktThread_t *PktThread
                               )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t             *pCThread     = CThread_ptr(PktThread->thread_hdr.hpRoot);
    DevThread_t           *pDevThread   = PktThread->Device;
    FCHS_t                *IP_Header    = PktThread->Pkt_CMND_Ptr;
    os_bit8               *IP_Payload   = (os_bit8 *)IP_Header + sizeof(FCHS_t) + 2 * sizeof(FC_N_Port_Name_t);
    os_bit32               D_ID=0;

/*+
Fill in IP Frame Header
-*/
    if (pDevThread == (DevThread_t *)pCThread->IP)
        D_ID = fiComputeBroadcast_D_ID( pCThread ); 
    else
        D_ID = fiComputeDevThread_D_ID( pDevThread ); 

    fiFillInIPFrameHeader_OffCard(
                                   PktThread,
                                   D_ID
                                 );
/*+
Fill in IP Network Header
-*/
    fiFillInIPNetworkHeader_OffCard(
                                     PktThread
                                   );
/*+
Fill in IP Device Data Payload
-*/
    osFcNetGetData((void* )IP_Payload, (void *) PktThread->osData, PktThread->DataLength);

/*+
Return length of IP Data Frame (including FCHS, Network Header and Payload)
-*/

    return sizeof(FCHS_t) + 2 * sizeof(FC_N_Port_Name_t) + PktThread->DataLength;
#endif /* __MemMap_Force_On_Card__ was not defined */
}



osGLOBAL os_bit32 fiIPProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t  SFQConsIndex,
                                  os_bit32        Frame_Length,
                                  fi_thread__t    **Thread_to_return
                                )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inCardRam)
    {
        return fiIPProcessSFQ_OnCard(
                                      hpRoot,
                                      SFQConsIndex,
                                      Frame_Length,
                                      Thread_to_return
                                    );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inDmaMemory */
    {
        return fiIPProcessSFQ_OffCard(
                                       hpRoot,
                                       SFQConsIndex,
                                       Frame_Length,
                                       Thread_to_return
                                     );
    }
}


osGLOBAL os_bit32 fiIPProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t  SFQConsIndex,
                                         os_bit32        Frame_Length,
                                         fi_thread__t    **Thread_to_return
                                       )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    return fiIP_Cmd_Status_Confused;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}


osGLOBAL os_bit32 fiIPProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t  SFQConsIndex,
                                          os_bit32        Frame_Length,
                                          fi_thread__t    **Thread_to_return
                                        )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    FCHS_t                     *FCHS                       = (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                                                        + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize));
    os_bit8                    *Payload                    = (os_bit8 *)FCHS + sizeof(FCHS_t);
    os_bit32                    Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    os_bit8                    *Payload_Wrapped            = (os_bit8 *)Payload - SFQ_MemoryDescriptor->objectSize;
    os_bit32                    R_CTL__D_ID                = FCHS->R_CTL__D_ID;
    os_bit32                    TYPE__F_CTL                = FCHS->TYPE__F_CTL;

    *Thread_to_return = (fi_thread__t *)agNULL;

    /* Note the assumption is that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */
    if ( (R_CTL__D_ID & FC_Frame_Header_R_CTL_Lo_MASK) ==
                    (FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame |
	            FC_Frame_Header_R_CTL_Lo_Unsolicited_Data)
            && (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_8802_2_LLC_SNAP )
    {
        fiIPProcess_Incoming_OffCard(
                                      hpRoot,
                                      Frame_Length,
                                      FCHS,
                                      Payload,
                                      Payload_Wrap_Offset,
                                      Payload_Wrapped
                                    );

        return fiIP_Cmd_Status_Incoming;
    }

    return fiIP_Cmd_Status_Confused;

#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiIPProcess_Incoming_OffCard(
                                   agRoot_t *hpRoot,
                                   os_bit32  Frame_Length,
                                   FCHS_t   *FCHS,
                                   os_bit8  *Payload,
                                   os_bit32  Payload_Wrap_Offset,
                                   os_bit8  *Payload_Wrapped
                                 )
{
    os_bit32                    D_ID                       = FCHS->R_CTL__D_ID & FC_Frame_Header_D_ID_MASK;
    os_bit32                    S_ID                       = FCHS->CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK;
    IPThread_t                 *IPThread                   = CThread_ptr(hpRoot)->IP;
    void                       *osData;

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLog_ERROR_Level,
                      "fiIP_Incoming S_ID = %06X D_ID = %06X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      S_ID,
                      D_ID,
                      0,0,0,0,0,0
                    );

    fiListDequeueFromHead( &osData, &IPThread->IncomingBufferLink );

    osFcNetPutData( Payload, Payload_Wrap_Offset, Payload_Wrapped, osData, Frame_Length - sizeof(FCHS_t) );

    IPThread->osData = osData;

    fiSendEvent( &(IPThread->thread_hdr), IPEventIncoming );
}

#endif /* _DvrArch_1_30_ was defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\ip.h ===
/*++

Purpose:

  This file defines the macros, types, and data structures used by ../C/IP.C

--*/

#ifndef __IP_H__
#define __IP_H__

#ifdef _DvrArch_1_30_

#define fiComputeBroadcast_D_ID(CThread)            \
    (   CThread->ChanInfo.CurrentAddress.Domain     \
     || CThread->ChanInfo.CurrentAddress.Area   ?   \
       FC_Well_Known_Port_ID_Broadcast_Alias_ID :   \
       FC_Broadcast_Replicate_AL_PA               )
       

void fiFillInIPFrameHeader_OffCard(
                                    PktThread_t *PktThread,
                                    os_bit32       D_ID
                                  );

void fiFillInIPNetworkHeader_OffCard(
                                      PktThread_t *PktThread
                                    );

os_bit32 fiFillInIPData(
                         PktThread_t *PktThread
                       );

os_bit32 fiFillInIPData_OnCard(
                                PktThread_t *PktThread
                              );

os_bit32 fiFillInIPData_OffCard(
                                 PktThread_t *PktThread
                               );

#define fiIP_Cmd_Status_Incoming         0x00000030
#define fiIP_Cmd_Status_Confused         0xFFFFFFFF 

osGLOBAL os_bit32 fiIPProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t  SFQConsIndex,
                                  os_bit32        Frame_Length,
                                  fi_thread__t    **Thread_to_return
                                );

osGLOBAL os_bit32 fiIPProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t  SFQConsIndex,
                                         os_bit32        Frame_Length,
                                         fi_thread__t    **Thread_to_return
                                       );

osGLOBAL os_bit32 fiIPProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t  SFQConsIndex,
                                          os_bit32        Frame_Length,
                                          fi_thread__t    **Thread_to_return
                                        );

osGLOBAL void fiIPProcess_Incoming_OffCard(
                                            agRoot_t *hpRoot,
                                            os_bit32  Frame_Length,
                                            FCHS_t   *FCHS,
                                            os_bit8  *Payload,
                                            os_bit32  Payload_Wrap_Offset,
                                            os_bit8  *Payload_Wrapped
                                          );
#endif /* _DvrArch_1_30_ was defined */
#endif /*  __IP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\ioctl.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    Ioctl.c

Abstract:

    Ioctl Handler

Author:

    

Revision History:

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/ioctl.c $

Revision History:

    $Revision: 8 $
    $Date: 11/10/00 5:51p $
    $Modtime:: $

Note: See Agilent's IOCTL specification for further detail
--*/

#include "buildop.h"
#include "osflags.h"
#include "hhba5100.ver"

#ifdef _SAN_IOCTL_
#include "sanioctl.h"
#endif

#ifdef _FCCI_SUPPORT
ULONG FCCIIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN    *LinkResetPerformed,
    BOOLEAN    *DeviceResetPerformed,
    UCHAR       *srb_status,
    UCHAR       *PathId, 
    UCHAR       *TargetId
    );
#endif

void
HPFillDriverInfo(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDriverInformation_t *hpFcDriverInfo,
    UCHAR *status
    )
{
    osStringCopy(hpFcDriverInfo->DriverName, DRIVER_NAME, MAX_HP_FC_DRIVER_NAME_SIZE);
    osStringCopy(hpFcDriverInfo->DriverDescription, DRIVER_DESCRIPTION,
            MAX_HP_FC_DRIVER_DESC_SIZE);
    hpFcDriverInfo->MajorRev = DRIVER_MAJOR_REV;
    hpFcDriverInfo->MinorRev = DRIVER_MINOR_REV;
}

void
HPFillCardConfig(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcCardConfiguration_t *hpFcCardConfig,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agFCChanInfo_t  chanInfo;
    agRoot_t        *hpRoot=&pCard->hpRoot;

    fcGetChannelInfo (hpRoot, &chanInfo);

    hpFcCardConfig->PCIBusNumber = (UCHAR)pCard->SystemIoBusNumber;
    hpFcCardConfig->PCIDeviceNumber = (UCHAR)pCard->SlotNumber;
    hpFcCardConfig->PCIFunctionNumber = 0;
    hpFcCardConfig->PCIBaseAddress0 = 0;        /* Reserved field in Tachlite */
    hpFcCardConfig->PCIBaseAddress0Size = 0;    /* Reserved field in Tachlite */

#if defined(HP_NT50)
   //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress1 = PtrToUlong(pCard->IoLBase);
#else
    hpFcCardConfig->PCIBaseAddress1 = (ULONG)(pCard->IoLBase);
#endif

    hpFcCardConfig->PCIBaseAddress1Size = 256;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress2 = PtrToUlong(pCard->IoUpBase);
#else
    hpFcCardConfig->PCIBaseAddress2 = (ULONG)(pCard->IoUpBase);
#endif
    
    hpFcCardConfig->PCIBaseAddress2Size = 256;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress3 = PtrToUlong(pCard->MemIoBase);
#else    
    hpFcCardConfig->PCIBaseAddress3 = (ULONG)(pCard->MemIoBase);
#endif

    hpFcCardConfig->PCIBaseAddress3Size = 512;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress4 = PtrToUlong(pCard->RamBase);
#else
    hpFcCardConfig->PCIBaseAddress4 = (ULONG)(pCard->RamBase);
#endif    
   
    hpFcCardConfig->PCIBaseAddress4Size = pCard->RamLength;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIBaseAddress5 = PtrToUlong(pCard->RomBase);
#else 
    hpFcCardConfig->PCIBaseAddress5 = (ULONG)(pCard->RomBase);
#endif
    
    hpFcCardConfig->PCIBaseAddress5Size = pCard->RomLength;

#if defined(HP_NT50)
    //WIN64 compliant
    hpFcCardConfig->PCIRomBaseAddress = PtrToUlong(pCard->AltRomBase);
#else
    hpFcCardConfig->PCIRomBaseAddress = (ULONG)(pCard->AltRomBase);
#endif
    
    hpFcCardConfig->PCIRomSize = pCard->AltRomLength;
    osCopy(hpFcCardConfig->NodeName, chanInfo.NodeWWN, 8);
    osCopy(hpFcCardConfig->PortName, chanInfo.PortWWN, 8);
    hpFcCardConfig->Topology = HP_FC_PRIVATE_LOOP;
    hpFcCardConfig->HardAddress = chanInfo.HardAddress.AL_PA;
    hpFcCardConfig->NportId = (ULONG) chanInfo.CurrentAddress.AL_PA;

}

void
HPFillDeviceConfig(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceConfiguration_t *hpFcDeviceConfig,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{   
    agFCDev_t hpFcDev;
    agFCDevInfo_t hpFcDevInfo;
    UCHAR PathId, TargetId, Lun;
    agRoot_t * hpRoot=&pCard->hpRoot;
    PLU_EXTENSION pLunExt = NULL; /* added for YAM21 support */
    LUN tempLun;                        /* added for FCP Lun data */
    PLUN ptempLun = &tempLun;

    PathId = hpFcDeviceConfig->DeviceAddress.PathId;
    TargetId = hpFcDeviceConfig->DeviceAddress.TargetId;
    Lun = hpFcDeviceConfig->DeviceAddress.Lun;
   
    /* Grab the Lun Extension, to be used in MapToHandle */
    pLunExt = ScsiPortGetLogicalUnit(pCard,
                                        PathId,
                                        TargetId,
                                        Lun );
                                        
    hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, pLunExt);
    if (hpFcDev != NULL) 
    {
        fcGetDeviceInfo(hpRoot, hpFcDev, &hpFcDevInfo);
        osCopy(hpFcDeviceConfig->NodeName, hpFcDevInfo.NodeWWN, 8);
        osCopy(hpFcDeviceConfig->PortName, hpFcDevInfo.PortWWN, 8);
        hpFcDeviceConfig->HardAddress = hpFcDevInfo.HardAddress.AL_PA;
        hpFcDeviceConfig->NportId = hpFcDevInfo.CurrentAddress.AL_PA;
        hpFcDeviceConfig->Present = (os_bit8)hpFcDevInfo.Present;
        hpFcDeviceConfig->LoggedIn = (os_bit8)hpFcDevInfo.LoggedIn;
        hpFcDeviceConfig->ClassOfService = hpFcDevInfo.ClassOfService;
        hpFcDeviceConfig->MaxFrameSize = hpFcDevInfo.MaxFrameSize;
        /*fill common parameters*/
        hpFcDeviceConfig->CmnParams.FC_PH_Version__BB_Credit =
          hpFcDevInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit;
        hpFcDeviceConfig->CmnParams.Common_Features__BB_Recv_Data_Field_Size =
          hpFcDevInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size;
        hpFcDeviceConfig->CmnParams.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category =
          hpFcDevInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category;
        hpFcDeviceConfig->CmnParams.E_D_TOV = hpFcDevInfo.N_Port_Common_Parms.E_D_TOV;
        /*fill class1 parameters*/
        hpFcDeviceConfig->Class1Params.Class_Validity__Service_Options__Initiator_Control_Flags =
          hpFcDevInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags;
        hpFcDeviceConfig->Class1Params.Recipient_Control_Flags__Receive_Data_Size =
          hpFcDevInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size;
        hpFcDeviceConfig->Class1Params.Concurrent_Sequences__EE_Credit =
          hpFcDevInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit;
        hpFcDeviceConfig->Class1Params.Open_Sequences_per_Exchange =
          hpFcDevInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange;
        /*fill class2 parameters*/
        hpFcDeviceConfig->Class2Params.Class_Validity__Service_Options__Initiator_Control_Flags =
          hpFcDevInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags;
        hpFcDeviceConfig->Class2Params.Recipient_Control_Flags__Receive_Data_Size =
          hpFcDevInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size;
        hpFcDeviceConfig->Class2Params.Concurrent_Sequences__EE_Credit =
          hpFcDevInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit;
        hpFcDeviceConfig->Class2Params.Open_Sequences_per_Exchange =
          hpFcDevInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange;
        /*fill class3 parameters*/
        hpFcDeviceConfig->Class3Params.Class_Validity__Service_Options__Initiator_Control_Flags =
          hpFcDevInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags;
        hpFcDeviceConfig->Class3Params.Recipient_Control_Flags__Receive_Data_Size =
          hpFcDevInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size;
        hpFcDeviceConfig->Class3Params.Concurrent_Sequences__EE_Credit =
          hpFcDevInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit;
        hpFcDeviceConfig->Class3Params.Open_Sequences_per_Exchange =
          hpFcDevInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange;
          
        /* Get the FCP lun data */
       
        memset(ptempLun, 0, sizeof(LUN));
        #ifdef YAM2_1
        if(pLunExt)
        {
            switch(pLunExt->Mode)
            {
                case PA_DEVICE_TRY_MODE_VS:
                    SET_VS_LUN(ptempLun, PathId, TargetId, Lun)
                    break;
         
                case PA_DEVICE_TRY_MODE_LU:
                    SET_LU_LUN(ptempLun, PathId, TargetId, Lun)
                    break;
            
                case PA_DEVICE_TRY_MODE_PA:
                    SET_PA_LUN(ptempLun, PathId, TargetId, Lun)
                    break;
            } // end switch
        } // end if ( pLunExt )
        memcpy(&(hpFcDeviceConfig->Lun), ptempLun, sizeof(LUN)); 
        #endif
    }
    else 
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}

void
HPFillLinkStat(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcLinkStatistics_t *hpFcLinkStat,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    hpFcLinkStat->ResetCount = pCard->External_ResetCount + pCard->Internal_ResetCount;
    hpFcLinkStat->LinkDownCount = hpFcLinkStat->ResetCount + pCard->LIPCount;
    hpFcLinkStat->LinkState = (pCard->LinkState == LS_LINK_UP) ? TRUE : FALSE;
}
 
void
HPFillDevStat(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceStatistics_t *hpFcDevStat,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agFCDev_t hpFcDev;
    agFCDevInfo_t hpFcDevInfo;
    UCHAR PathId, TargetId, Lun;
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    PathId = hpFcDevStat->DeviceAddress.PathId;
    TargetId = hpFcDevStat->DeviceAddress.TargetId;
    Lun = hpFcDevStat->DeviceAddress.Lun;
    hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, NULL);
    if (hpFcDev != NULL) 
    {
        fcGetDeviceInfo(hpRoot, hpFcDev, &hpFcDevInfo);
        hpFcDevStat->LoginRetries = hpFcDevInfo.LoginRetries;
        hpFcDevStat->ReadsRequested = hpFcDevInfo.ReadsRequested;
        hpFcDevStat->ReadsCompleted = hpFcDevInfo.ReadsCompleted;
        hpFcDevStat->ReadsFailed = hpFcDevInfo.ReadFailures;
        hpFcDevStat->BytesReadUpper32 = hpFcDevInfo.BytesReadUpper32;
        hpFcDevStat->BytesReadLower32 = hpFcDevInfo.BytesReadLower32;
        hpFcDevStat->WritesRequested = hpFcDevInfo.WritesRequested;
        hpFcDevStat->WritesCompleted = hpFcDevInfo.WritesCompleted;
        hpFcDevStat->WritesFailed = hpFcDevInfo.WriteFailures;
        hpFcDevStat->BytesWrittenUpper32 = hpFcDevInfo.BytesWrittenUpper32;
        hpFcDevStat->BytesWrittenLower32 = hpFcDevInfo.BytesWrittenLower32;
        hpFcDevStat->NonRWRequested = hpFcDevInfo.NonRWRequested;
        hpFcDevStat->NonRWCompleted = hpFcDevInfo.NonRWCompleted;
        hpFcDevStat->NonRWFailures = hpFcDevInfo.NonRWFailures;
    }
    else 
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}

void
HPDoLinkReset(
    PSRB_IO_CONTROL srbIoCtl,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    pCard->State |= CS_DURING_RESET_ADAPTER;
    pCard->External_ResetCount++;
 
    fcResetChannel (hpRoot, fcSyncReset);
 
    ScsiPortNotification(ResetDetected, pCard, NULL);
 
    pCard->State &= ~CS_DURING_RESET_ADAPTER;
  
}

void
HPDoDevReset(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceReset_t *hpFcDevReset,
    PCARD_EXTENSION pCard,
    UCHAR *PathId,
    UCHAR *TargetId,
    UCHAR *status
    )
{   
    agRoot_t * hpRoot=&pCard->hpRoot;
    agFCDev_t hpFcDev;
    ULONG ResetStatus;
    UCHAR Lun;
 
    *PathId = hpFcDevReset->DeviceAddress.PathId;
    *TargetId = hpFcDevReset->DeviceAddress.TargetId;
    Lun = hpFcDevReset->DeviceAddress.Lun;
    hpFcDev = MapToHandle(pCard, *PathId, *TargetId, Lun, NULL);
    if (hpFcDev == NULL ||
       (ResetStatus = fcResetDevice(hpRoot, hpFcDev, fcHardReset)) != fcResetSuccess) 
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}

void
HPDoRegRead(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcRegRead_t *hpFcRegRead,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    if (hpFcRegRead->RegOffset <= 0x1ff) 
    {
        hpFcRegRead->RegData = osChipMemReadBit32(
                                                 hpRoot,
                                                 hpFcRegRead->RegOffset
                                                );
    }
    else 
    {
       srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}

void
HPDoRegWrite(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcRegWrite_t *hpFcRegWrite,
    PCARD_EXTENSION pCard,
    UCHAR *status
    )
{
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    if (hpFcRegWrite->RegOffset <= 0x1ff) 
    {
        osChipMemWriteBit32(
                           hpRoot,
                           hpFcRegWrite->RegOffset,
                           hpFcRegWrite->RegData
                           );
    }
    else 
    {
       srbIoCtl->ReturnCode = HP_FC_RTN_FAILED;
    }
}



ULONG HPIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN     *LinkResetPerformed,
    BOOLEAN     *DeviceResetPerformed,
    UCHAR    *srb_status,
    UCHAR    *PathId, 
    UCHAR    *TargetId
    )
{
    agRoot_t * phpRoot      =   &pCard->hpRoot;
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
    PSRB_IO_CONTROL srbIoCtl;
    UCHAR status;
//  PSRB_IO_CONTROL srbIoCtl;
// ULONG    done = FALSE;
//   UCHAR    srbPathId = Srb->PathId;
//   UCHAR    srbTargetId = Srb->TargetId;
//   UCHAR    srbLun = Srb->Lun;

    status = *srb_status;
    srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    
    switch (srbIoCtl->ControlCode) 
    {
        case HP_FC_IOCTL_GET_DRIVER_INFO : 
        {
            hpFcDriverInformation_t *hpFcDriverInfo;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                               sizeof(hpFcDriverInformation_t))) &&
                                              (srbIoCtl->Length >= sizeof(hpFcDriverInformation_t))) 
            {
                hpFcDriverInfo = (hpFcDriverInformation_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillDriverInfo(srbIoCtl, hpFcDriverInfo, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_GET_CARD_CONFIG : 
        {
            hpFcCardConfiguration_t *hpFcCardConfig;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                               sizeof(hpFcCardConfiguration_t))) &&
                        (srbIoCtl->Length >= sizeof(hpFcCardConfiguration_t))) 
            {
                hpFcCardConfig = (hpFcCardConfiguration_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillCardConfig(srbIoCtl, hpFcCardConfig, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_GET_DEVICE_CONFIG : 
        {
            hpFcDeviceConfiguration_t *hpFcDeviceConfig;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                           sizeof(hpFcDeviceConfiguration_t))) &&
                       (srbIoCtl->Length >= sizeof(hpFcDeviceConfiguration_t))) 
            {
                hpFcDeviceConfig = (hpFcDeviceConfiguration_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillDeviceConfig(srbIoCtl, hpFcDeviceConfig, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_GET_LINK_STATISTICS : 
        {
            hpFcLinkStatistics_t *hpFcLinkStat;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                                     sizeof(hpFcLinkStatistics_t))) &&
                   (srbIoCtl->Length >= sizeof(hpFcLinkStatistics_t))) 
            {
                hpFcLinkStat = (hpFcLinkStatistics_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillLinkStat(srbIoCtl, hpFcLinkStat, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_GET_DEVICE_STATISTICS : 
        {
            hpFcDeviceStatistics_t *hpFcDevStat;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                              sizeof(hpFcDeviceStatistics_t))) &&
                   (srbIoCtl->Length >= sizeof(hpFcDeviceStatistics_t))) 
            {
                hpFcDevStat = (hpFcDeviceStatistics_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPFillDevStat(srbIoCtl, hpFcDevStat, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_LINK_RESET : 
        {
            HPDoLinkReset(srbIoCtl, pCard, &status);
            *LinkResetPerformed = TRUE;
            break;
        }

        case HP_FC_IOCTL_DEVICE_RESET : 
        {
            hpFcDeviceReset_t *hpFcDevReset;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                                sizeof(hpFcDeviceReset_t))) &&
                   (srbIoCtl->Length >= sizeof(hpFcDeviceReset_t))) 
            {
                hpFcDevReset = (hpFcDeviceReset_t *)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPDoDevReset(
                    srbIoCtl,
                    hpFcDevReset,
                    pCard,
                    PathId,
                    TargetId,
                    &status
                    );
                *DeviceResetPerformed = TRUE;
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_REG_READ : 
        {
            hpFcRegRead_t *hpFcRegRead;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                                     sizeof(hpFcRegRead_t))) &&
                    (srbIoCtl->Length >= sizeof(hpFcRegRead_t))) 
            {
                hpFcRegRead = (hpFcRegRead_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPDoRegRead(srbIoCtl, hpFcRegRead, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        case HP_FC_IOCTL_REG_WRITE : 
        {
            hpFcRegWrite_t *hpFcRegWrite;

            if ((Srb->DataTransferLength >= (sizeof(SRB_IO_CONTROL) +
                                                     sizeof(hpFcRegWrite_t))) &&
                    (srbIoCtl->Length >= sizeof(hpFcRegWrite_t))) 
            {
                hpFcRegWrite = (hpFcRegWrite_t *) (((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                HPDoRegWrite(srbIoCtl, hpFcRegWrite, pCard, &status);
            }
            else 
            {
                srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER;
            }
            break;
        }

        default :
            osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIo: MiniportIOCtl not supported\n"));
            srbIoCtl->ReturnCode = HP_FC_RTN_BAD_CTL_CODE;
    } // end IOCTL switch
           
    *srb_status = status;
    return 0;
           
}



ULONG DoIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    agRoot_t * phpRoot      =   &pCard->hpRoot;
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
    SCSI_NOTIFICATION_TYPE  notify_type = NextRequest;
    UCHAR status;
    PSRB_IO_CONTROL srbIoCtl;
    BOOLEAN LinkResetPerformed = FALSE;
    BOOLEAN DeviceResetPerformed = FALSE;
    UCHAR PathId, TargetId;
    ULONG    done = FALSE;
    UCHAR    srbPathId = Srb->PathId;
    UCHAR    srbTargetId = Srb->TargetId;
    UCHAR    srbLun = Srb->Lun;
 
    status = SRB_STATUS_SUCCESS;
    if (Srb->DataTransferLength < sizeof(SRB_IO_CONTROL)) 
    {
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIO: MiniportIOCtl insufficient DataTransferLength\n"));

        pSrbExt->SRB_State = RS_COMPLETE;
        status = SRB_STATUS_INVALID_REQUEST;
        done = TRUE;
    }   
       
    if (done == FALSE)
    {
        srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
 
        /* Agilent Standard IOCTL */      
        if (osMemCompare(srbIoCtl->Signature, HP_FC_IOCTL_SIGNATURE, sizeof(srbIoCtl->Signature)) == TRUE) 
        {
            srbIoCtl->ReturnCode = HP_FC_RTN_OK;
            HPIoctl(pCard, Srb, &LinkResetPerformed, &DeviceResetPerformed, &status, &PathId, &TargetId);
            done = TRUE;
        } //Signature matched

        /* FCCI Standard IOCTL */      
        #ifdef _FCCI_SUPPORT
        if (osMemCompare(srbIoCtl->Signature, FCCI_SIGNATURE, sizeof(srbIoCtl->Signature)) == TRUE) 
        {
            srbIoCtl->ReturnCode = HP_FC_RTN_OK;
            FCCIIoctl(pCard, Srb, &LinkResetPerformed, &DeviceResetPerformed, &status, &PathId, &TargetId);
            done = TRUE;
        } //Signature matched
        #endif
      
        /* Agilent SAN IOCTL */     
        #ifdef _SAN_IOCTL_
        if (osMemCompare(srbIoCtl->Signature, AG_SAN_IOCTL_SIGNATURE, sizeof(srbIoCtl->Signature)) == TRUE) 
        {
            srbIoCtl->ReturnCode = HP_FC_RTN_OK;
            AgSANIoctl(pCard, Srb, &LinkResetPerformed, &DeviceResetPerformed, &status, &PathId, &TargetId);
            done = TRUE;
        } //Signature matched
        #endif
      
        /* Add additional IOCTL signature here */
      
        /* None of the signatures is found, reort error */
        if (done == FALSE)
        {
            osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIo: MiniportIOCtl not supported:%s != %s\n",
                srbIoCtl->Signature, HP_FC_IOCTL_SIGNATURE));

            osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIO: MiniportIOCtl not supported\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            status = SRB_STATUS_INVALID_REQUEST;
        }
    } //end case SRB_FUNCTION_IO_CONTROL

    Srb->SrbStatus = status;
    pSrbExt->SRB_State = RS_COMPLETE;

    ScsiPortNotification(notify_type,
                                 pCard,
                                 srbPathId,
                                 srbTargetId,
                                 srbLun);

    ScsiPortNotification(RequestComplete,
                             pCard,
                             Srb);

    if (LinkResetPerformed == TRUE) 
    {
        doPostResetProcessing (pCard);
    }
    if (DeviceResetPerformed == TRUE) 
    {
        completeRequests (pCard, PathId, TargetId, SRB_STATUS_BUS_RESET);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\ipstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/IPState.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/19/00 9:10a   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/IPState.C

--*/

#ifndef __IPState_H__
#define __IPState_H__

#define IPStateConfused                 0
#define IPStateIdle                     1
#define IPStateReportLinkStatus         2
#define IPStateOutgoingComplete         3
#define IPStateIncoming                 4

#define IPStateMAXState                 IPStateIncoming

#define IPEventConfused                 0
#define IPEventReportLinkStatus         1
#define IPEventOutgoingComplete         2
#define IPEventIncoming                 3
#define IPEventDone                     4

#define IPEventMAXEvent                 IPEventDone

STATE_PROTO(IPActionConfused);
STATE_PROTO(IPActionIdle);
STATE_PROTO(IPActionReportLinkStatus);
STATE_PROTO(IPActionOutgoingComplete);
STATE_PROTO(IPActionIncoming);
STATE_PROTO(IPActionDone);

stateTransitionMatrix_t IPStateTransitionMatrix;
stateActionScalar_t IPStateActionScalar;

#endif /*  __IPState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\ipstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/IPState.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 8/16/00 4:43p   $

Purpose:

  This file implements the FC Layer State Machine for the single IP Thread.
  This thread is responsible for managing NDIS-client Queues (both directions).

--*/
#ifdef _DvrArch_1_30_

#include <stdio.h>
#include <stdlib.h>


#include "../h/globals.h"
#include "../h/state.h"
#include "../h/fcstruct.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"

/* <<<<<<<<<<<< Testing >>>>>>>>> */
#include "../h/sfstate.h"

#include "../h/ipstate.h"
#include "../h/pktstate.h"
#include "../h/queue.h"
#include "../h/ip.h"

stateTransitionMatrix_t IPStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...            */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 1 IPEventReportLinkStatus                             */
    0,IPStateReportLinkStatus,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 2 IPEventOutgoingComplete                             */
    0,IPStateOutgoingComplete,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 3 IPEventIncoming                                     */
    0,IPStateIncoming,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 4 IPEventDone                                         */
    0,0,IPStateIdle,IPStateIdle,IPStateIdle, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 5                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 20                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 30                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

stateTransitionMatrix_t copiedIPStateTransitionMatrix;

stateActionScalar_t IPStateActionScalar = {
    &IPActionConfused,
    &IPActionIdle,
    &IPActionReportLinkStatus,
    &IPActionOutgoingComplete,
    &IPActionIncoming,
    &IPActionConfused
    };

stateActionScalar_t copiedIPStateActionScalar;

#ifdef USESTATEMACROS

IPSTATE_FUNCTION_TERMINATE(IPActionConfused);

#endif /* USESTATEMACROS */

#define testIPCompareBase 0x00000110


/* IPStateConfused 0  */
extern void IPActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    fiLogString(thread->hpRoot,
                    "IPActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    IPStateLogErrorLevel,
                    "In %s - State = %d",
                    "IPActionConfused",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull( eventRecord );
}

extern void IPActionIdle( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiSetEventRecordNull(eventRecord);
}

extern void IPActionReportLinkStatus( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t       *hpRoot      = thread->hpRoot;
    IPThread_t     *pIPThread  = (IPThread_t *) thread;

    fiLogDebugString(hpRoot,
                    IPStateLogErrorLevel,
                    "In %s - State = %d",
                    "IPActionReportLinkStatus",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    if (pIPThread->LinkStatus.osData != agNULL &&
            pIPThread->LinkStatus.LastReported != pIPThread->LinkStatus.MostRecent)
    {
        osFcNetIoctlCompleted( hpRoot, pIPThread->LinkStatus.osData, pIPThread->LinkStatus.MostRecent );

        pIPThread->LinkStatus.LastReported = pIPThread->LinkStatus.MostRecent;
        pIPThread->LinkStatus.osData = agNULL;
    }

    fiSetEventRecord( eventRecord, thread, IPEventDone );
}

extern void IPActionOutgoingComplete( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        *hpRoot      = thread->hpRoot;
    PktThread_t     *pPktThread  = ((IPThread_t *)thread)->CompletedPkt;

    fiLogDebugString(hpRoot,
                    IPStateLogErrorLevel,
                    "In %s - State = %d",
                    "IPActionOutgoingComplete",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiListDequeueThis(pPktThread);

    PktThreadFree( hpRoot, pPktThread );

    osFcNetIoctlCompleted( hpRoot, pPktThread->osData, pPktThread->status );

    fiSetEventRecord( eventRecord, thread, IPEventDone );
}

extern void IPActionIncoming( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t       *hpRoot      = thread->hpRoot;
    IPThread_t     *pIPThread  = (IPThread_t *) thread;

    fiLogDebugString(hpRoot,
                    IPStateLogErrorLevel,
                    "In %s - State = %d",
                    "IPActionIncoming",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    osFcNetIoctlCompleted( hpRoot, pIPThread->osData, FC_CMND_STATUS_SUCCESS );

    fiSetEventRecord( eventRecord, thread, IPEventDone );
}

#endif /* _DvrArch_1_30_ was defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\isr.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    ISR.c

Abstract:

    This is the Interrupt service routine for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only
 
Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/ISR.C $
 
Revision History:

    $Revision: 9 $
    $Date: 3/30/01 3:28p $
    $Modtime:: 3/30/01 3:27p           $
 
--*/

#include "buildop.h"
#include "osflags.h"

#ifdef _DEBUG_EVENTLOG_
BOOLEAN LogScsiError(agRoot_t            *hpRoot,
                     PSCSI_REQUEST_BLOCK pSrb ,
                     agFcpRspHdr_t  * pResponseHeader,
                     ULONG           hpIOInfoLen);
#endif

extern ULONG gCrashDumping;

#if defined(_DEBUG_STALL_ISSUE_) && defined(i386)       //+++++++++++++++++++++++++
void _DebugStall_(IN PCARD_EXTENSION pCard)
{
    ULONG   x;
    for (x=0; x < STALL_COUNT_MAX;x++)
    {
        if ( pCard->StallData[x].Address && pCard->StallData[x].MicroSec)
            osDEBUGPRINT((ALWAYS_PRINT,"HPFibreInterrupt: _DebugStall_ %d mis at %x\n",
                pCard->StallData[x].MicroSec,
                pCard->StallData[x].Address));
    }
    return;
}
#endif

BOOLEAN
HPFibreInterrupt(
    IN PCARD_EXTENSION pCard
    )

/*++

Routine Description:

    This is the interrupt service routine for the HBA. It reads the
    interrupt register and the IMQ indices to determine if the adapter
    is indeed the source of the interrupt and clears the interrupt at
    the device.

Arguments:

    CardExtension - HBA miniport driver's adapter data storage
 
Return Value:

    TRUE  - if interrupt handled by this routine
    FALSE - if a spurious interrupt occured

/--*/

{
    agRoot_t * hpRoot=&pCard->hpRoot;
 
    pCard->State |= CS_DURING_ISR;
 
    // pCard->Perf_ptr->inOsIsr      = get_hi_time_stamp();
 
    osDEBUGPRINT((DMOD,"IN HPFibreInterrupt  pCard %lx osData %lx fcData %lx\n", pCard,hpRoot->osData,hpRoot->fcData ));
 
    // pCard->Perf_ptr->inFcIsr      = get_hi_time_stamp();
 
    if(!fcInterruptHandler( hpRoot ))
    {
        osDEBUGPRINT((DMOD,"Not my interrupt pCard %lx\n", pCard ));
        pCard->State &= ~CS_DURING_ISR;
        return(FALSE); // Not my interrupt
    }
   
    pCard->Number_interrupts++;

    // pCard->Perf_ptr->outFcIsr     = get_hi_time_stamp();
    // pCard->Perf_ptr->inFcDIsr     = get_hi_time_stamp();

    #if defined(_DEBUG_STALL_ISSUE_) && defined(i386)       //+++++++++++++++++++++++++
    memset( pCard->StallData, 0, sizeof(pCard->StallData) );
    pCard->StallCount=0;
    #endif                                                  //-------------------------
    
    fcDelayedInterruptHandler( hpRoot  );

    if (pCard->LinkState == LS_LINK_UP && pCard->AdapterQ.Head)
        Startio (pCard);

    // pCard->Perf_ptr->outFcDIsr    = get_hi_time_stamp();
    // pCard->Perf_ptr->outOsIsr     = get_hi_time_stamp();
    
    #if defined(_DEBUG_STALL_ISSUE_) && defined(i386)       //++++++++++++++++++++++++++
    if (pCard->StallCount > 450*1000)
    {
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreInterrupt: osStallThread total in ISR %d ms\n",pCard->StallCount));
        _DebugStall_(pCard);
    }
    #endif                                                  //--------------------------

    pCard->State &= ~CS_DURING_ISR;
    return TRUE;

} // end HPFibreInterrupt()



/*++

Routine Description:

    This is a callback from FC layer to indicate IO completion
 
Arguments:

    hpRoot      - HBA miniport driver's adapter data storage
    hpIORequest - Agilent IO request structure
    hpIOStatus  - IO status
    hpIOInfoLen - the length of available FC status payload

Return Value:

    none
 
/--*/

osGLOBAL void osIOCompleted(
    agRoot_t      *hpRoot,
    agIORequest_t *phpIORequest,
    os_bit32       hpIOStatus,
    os_bit32       hpIOInfoLen
    )
{
    PCARD_EXTENSION pCard = NULL;
    PSRB_EXTENSION pSrbExt = NULL;
    PSCSI_REQUEST_BLOCK pSrb = NULL;
    PLU_EXTENSION plunExtension = NULL;
   
    #ifdef YAM2_1
    PA_DEVICE                  *dev;
    BOOLEAN                    cmdTypeInquiry=FALSE;
    ULONG                      srbDataLength;
    #endif
    agFcpRspHdr_t * pFcResponse=NULL;
    pCard   = (PCARD_EXTENSION)hpRoot->osData;
 
    pCard->State |= CS_DURING_OSCOMPLETE;
    
    #ifdef _DEBUG_LOSE_IOS_
    if(pCard->Srb_IO_Count > (1024*60) && !(pCard->Srb_IO_Count % 1024  ))
    {
        osDEBUGPRINT((ALWAYS_PRINT,"Losing this IO Request !!!! %lx Count %x  SrbExt %lx\n",
                            phpIORequest,
                            pCard->Srb_IO_Count,
                            phpIORequest->osData ));
        return;
    }

    osDEBUGPRINT((DMOD,"IN osIOCompleted hpRoot %lx Request %lx  Status %x len %x\n", hpRoot, phpIORequest, hpIOStatus,hpIOInfoLen));

    #endif // _DEBUG_LOSE_IOS_

    // get the SRBextension 
    pSrbExt = hpObjectBase(SRB_EXTENSION,hpIORequest,phpIORequest);
    pSrbExt->SRB_State = RS_COMPLETE;

    if( ! phpIORequest->osData )
    {
        osDEBUGPRINT((ALWAYS_PRINT,"phpIORequest->osData is NULL  GOODBYE !\n" ));
        return;
    }

    phpIORequest->osData = NULL;
    pSrb = pSrbExt->pSrb;
    // PERF pSrbExt->Perf_ptr->inOsIOC      = get_hi_time_stamp();
 
    if( phpIORequest != &pSrbExt->hpIORequest)
    {
        osDEBUGPRINT((ALWAYS_PRINT,"phpIORequest %lx != &pSrbExt->hpIORequest %xlx\n",
        phpIORequest, &pSrbExt->hpIORequest ));
    }



    // get the lu extension
    plunExtension = pSrbExt->pLunExt;

    osDEBUGPRINT((DMOD,"pSrb %lx pFcResponse %lx LUext %lx\n", pSrb, pFcResponse, plunExtension  ));
 
    osDEBUGPRINT((DMOD,"osIOCompleted: CDB %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x pCDB %lx\n",
                 pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                 pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], &pSrb->Cdb[0] ));
    osDEBUGPRINT((DMOD, "osIOCompleted: hpIOStatus = %d, PathId = %d, TargetId %d, Lun = %d\n",
                 hpIOStatus, pSrb->PathId, pSrb->TargetId, pSrb->Lun));
 
    // if we are in the crashdump path
    // then we will copy back the buffer before further
    // processing..
    if(gCrashDumping)
    {
        if(pSrb->Cdb[0] == 0x2a)
        {
            if(pSrbExt->orgDataBuffer)
            {
                // we would have made a local copy
                pSrb->DataBuffer = pSrbExt->orgDataBuffer;
                // re-init pointers..
                pSrbExt->orgDataBuffer = NULL;
                osZero(pCard->localDataBuffer, ( 8 * 1024 ));
            }
        }
    }

    // get the IO status
    switch(hpIOStatus)
    {
        case osIOSuccess:

            #ifdef _DEBUG_REPORT_LUNS_
            {
                if ((pSrb->Cdb[0] == 0xa0) && (hpIOInfoLen == 0)) 
                {
                    PrintReportLunData(pSrb);
                }
            }
            #endif
            pSrb->SrbStatus = SRB_STATUS_SUCCESS;

            // check for inquiry commands
            if ((pSrb->Cdb[0] == SCSIOP_INQUIRY) && (hpIOInfoLen == 0)) 
            {
                #ifndef YAM2_1
                if (pSrb->DataTransferLength >= 1)
                    plunExtension->deviceType = (*((UCHAR *)(pSrb->DataBuffer))) & 0x1f;

                if ((pSrb->PathId < 4) && (pSrb->Lun == 0) && (pSrb->DataTransferLength >= 32))
                    RegisterIfSpecialDev (pCard, pSrb->PathId, pSrb->TargetId, pSrb->DataBuffer);
                #else
                // handle any devices that requires special attention
                    RegisterIfSpecialDev (pCard, pSrb->PathId, pSrb->TargetId, pSrb->DataBuffer);
                cmdTypeInquiry = TRUE;
                #endif               
                    
                #ifdef _DEBUG_EVENTLOG_
                #ifndef YAM2_1
                {
                if (MapToHandle(pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun, NULL))
                {
                    osCopy(plunExtension->InquiryData, pSrb->DataBuffer, MIN(pSrb->DataTransferLength, 36) );
                    plunExtension->InquiryData[36] = 0; 
                    fcGetDeviceInfo (hpRoot, plunExtension->phandle, &plunExtension->devinfo );
                    if (!osMemCompare(plunExtension->devinfo.NodeWWN, plunExtension->WWN, 8) )
                    {
                        LogEvent(pCard, NULL, HPFC_MSG_SHOWDEVICENAME, NULL, 0,
                            "%02x%02x%02x%02x %02x%02x%02x%02x (%s)",
                            plunExtension->devinfo.NodeWWN[0],plunExtension->devinfo.NodeWWN[1],
                            plunExtension->devinfo.NodeWWN[2],plunExtension->devinfo.NodeWWN[3],
                            plunExtension->devinfo.NodeWWN[4],plunExtension->devinfo.NodeWWN[5],
                            plunExtension->devinfo.NodeWWN[6],plunExtension->devinfo.NodeWWN[7],
                            plunExtension->InquiryData+8);
                        osCopy(plunExtension->WWN, plunExtension->devinfo.NodeWWN, 8);
                    }
                }
                }
                #endif
                #endif
            }

            if (hpIOInfoLen == 0)
            {
                #ifdef YAM2_1
            
                if (TryOtherAddressingMode(pCard, phpIORequest, pSrbExt, DONT_CHECK_STATUS))
                {
                    return;
                }
                else
                {
                }

                /* now count the number of LUNs */
            
                if ( (cmdTypeInquiry == TRUE) && ( (*(char*)pSrb->DataBuffer) & 0x1f) != 0x1f )
                {
                    SetLunCount(pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun);
                  
                    #ifdef _DEBUG_EVENTLOG_
                    dev = pCard->Dev->PaDevice + plunExtension->PaDeviceIndex;
                    if ( ! (plunExtension->LogFlags & PA_DEVICE_ALREADY_LOGGED) )
                    {
                        UCHAR    msg[24];
                        USHORT   *sPtr;
                     
                        osCopy(dev->DevInfo.InquiryData, pSrb->DataBuffer, MIN(pSrb->DataTransferLength, 36) );
                        dev->DevInfo.InquiryData[36] = 0; 
                     
                        osCopy(msg, dev->DevInfo.NodeWWN, 8);
                        msg[8] = pSrb->PathId;
                        msg[9] = pSrb->TargetId;
                        msg[10] = pSrb->Lun;
                        msg[11] = (UCHAR)dev->ModeFlag;                    
                  
                        sPtr = (USHORT *)&msg[12];
                        *sPtr = dev->Index.Pa.FcDeviceIndex;
                  
                        /* unused */
                        msg[14] = 0xaa;
                        msg[15] = 0xaa;
                  
                        osCopy(&msg[16], dev->DevInfo.InquiryData, 8);
                  
                        LogEvent(pCard, NULL, HPFC_MSG_SHOWDEVICENAME, (ULONG*)msg, sizeof(msg)/sizeof(ULONG),
                            "%d:%d:%d (%s)",
                            pSrb->PathId,
                            pSrb->TargetId,
                            pSrb->Lun,
                            dev->DevInfo.InquiryData+8);
                         plunExtension->LogFlags |= PA_DEVICE_ALREADY_LOGGED;
                    }
                    #endif
                }
                #endif
                break;
            }
            // +++++ fall thru.

        case osIOOverUnder:
            #ifdef YAM2_1
            if (pSrb->Cdb[0] == SCSIOP_INQUIRY)  
            cmdTypeInquiry = TRUE;
            #endif
        
        case osIOFailed:
            #ifdef YAM2_1
            srbDataLength = pSrb->DataTransferLength;
            #endif
   
            // Map error sets directly....
            // SrbStatus and ScsiStatus
            // SenseInfoBuffer and SenseInfoBufferLength
            // DataTransferLength
            // Log error as per A.4.11
            osDEBUGPRINT((DMOD,"osIOFailed pSrb %lx pFcResponse %lx LUext %lx Len %x CDB %02x\n", pSrb, pFcResponse, plunExtension, hpIOInfoLen, pSrb->Cdb[0]    ));

            if(hpIOInfoLen)
            {
                // Our response buffer size is only HP_FC_RESPONSE_BUFFER_LEN (128) bytes.
                if (hpIOInfoLen > HP_FC_RESPONSE_BUFFER_LEN)
                    hpIOInfoLen = HP_FC_RESPONSE_BUFFER_LEN;

                pFcResponse = (agFcpRspHdr_t * )&pCard->Response_Buffer[0];


                fcIOInfoReadBlock( hpRoot,
                    phpIORequest,
                    0,
                    pFcResponse,
                    hpIOInfoLen
                    );
               }

            if(Map_FC_ScsiError( pSrbExt->phpRoot,
                              &pSrbExt->hpIORequest,
                              pFcResponse,
                              hpIOInfoLen,
                              pSrb ))
            {
                osDEBUGPRINT((DMOD,"Map Error SRB Status %02x scsi status %02x\n", pSrb->SrbStatus, pSrb->ScsiStatus ));
            }

            #ifdef YAM2_1
            if (TryOtherAddressingMode(pCard,phpIORequest, pSrbExt, CHECK_STATUS))
            {
                pSrb->DataTransferLength = srbDataLength;       /* restore the length, MAP_FC_ScsisError modifies this field */
//              ModifyModeBeforeStartIO (plunExtension, &pSrbExt->hpRequestBody);
                return;
            }
            else
            {
//          osDEBUGPRINT((ALWAYS_PRINT,"TryOtherAddressingMode: no need to resend 2\n"));
            }
        
            if ( (cmdTypeInquiry == TRUE) && ( (*(char*)pSrb->DataBuffer) & 0x1f) != 0x1f )
            {
                SetLunCount(pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun);
              
                #ifdef _DEBUG_EVENTLOG_
                dev = pCard->Dev->PaDevice + plunExtension->PaDeviceIndex;
                if ( ! (plunExtension->LogFlags & PA_DEVICE_ALREADY_LOGGED) )
                {
                    UCHAR    msg[24];
                    USHORT   *sPtr;
                 
                    osCopy(dev->DevInfo.InquiryData, pSrb->DataBuffer, MIN(pSrb->DataTransferLength, 36) );
                    dev->DevInfo.InquiryData[36] = 0; 
                 
                    osCopy(msg, dev->DevInfo.NodeWWN, 8);
                    msg[8] = pSrb->PathId;
                    msg[9] = pSrb->TargetId;
                    msg[10] = pSrb->Lun;
                    msg[11] = (UCHAR)dev->ModeFlag;                    
              
                    sPtr = (USHORT *)&msg[12];
                    *sPtr = dev->Index.Pa.FcDeviceIndex;
              
                    /* unused */
                    msg[14] = 0xaa;
                    msg[15] = 0xaa;
              
                    osCopy(&msg[16], dev->DevInfo.InquiryData, 8);
              
                    LogEvent(pCard, NULL, HPFC_MSG_SHOWDEVICENAME, (ULONG*)msg, sizeof(msg)/sizeof(ULONG),
                        "%d:%d:%d (%s)",
                        pSrb->PathId,
                        pSrb->TargetId,
                        pSrb->Lun,
                        dev->DevInfo.InquiryData+8);
                    plunExtension->LogFlags |= PA_DEVICE_ALREADY_LOGGED;
                }
                #endif
            }
            #endif
        
            //
            // MUX replies to Inquiry commands sent to non existing targets (behind the MUX)
            // with GOOD fcp status but residue set to fcp data length.
            // Looks like port driver can't deal with this well.
            // To work-around this problem here we convert the SrbStatus to selection timeout.
            //
            if ((pSrb->Cdb[0] == SCSIOP_INQUIRY) && 
                (pSrb->SrbStatus == SRB_STATUS_DATA_OVERRUN) && (pSrb->DataTransferLength == 0))
                pSrb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;

            if (( (pSrb->SrbStatus == SRB_STATUS_SUCCESS) ||
                (pSrb->SrbStatus == SRB_STATUS_DATA_OVERRUN)) &&
                (pSrb->Cdb[0] == SCSIOP_INQUIRY)) 
            {
                if (pSrb->DataTransferLength >= 1)
                    plunExtension->deviceType = (*((UCHAR *)(pSrb->DataBuffer))) & 0x1f;

                #ifndef YAM2_1
                if ((pSrb->PathId < 4) && (pSrb->Lun == 0) && (pSrb->DataTransferLength >= 32))
                    RegisterIfSpecialDev (pCard, pSrb->PathId, pSrb->TargetId, pSrb->DataBuffer);
                #else
                    RegisterIfSpecialDev (pCard, pSrb->PathId, pSrb->TargetId, pSrb->DataBuffer);
                #endif
            }

            #ifndef DONT_RETRY_IOS
            if((SRB_STATUS(pSrb->SrbStatus) == SRB_STATUS_ERROR) && 
                (pSrb->ScsiStatus == SCSISTAT_BUSY || pSrb->ScsiStatus == SCSISTAT_QUEUE_FULL) && (RetrySrbOK(pSrb) == TRUE)) 
            {
                phpIORequest->osData = pSrbExt;
                pSrbExt->SRB_State =  RS_WAITING;
                osDEBUGPRINT((ALWAYS_PRINT,"Keeping SCSI status Busy/QueueFull Srb on RetryQ: %08x on pCard: %08x \n", pSrb, pCard));
           
                // Clear status before retrying.
                pSrb->SrbStatus = SRB_STATUS_SUCCESS;
                pSrb->ScsiStatus = SCSISTAT_GOOD;

                SrbEnqueueHead (&pCard->RetryQ, pSrb);
                return;
            }
            #endif //DONT_RETRY_IOS

            #if DBG > 2
            if( pSrbExt->SRB_State & RS_TIMEOUT )
                osDEBUGPRINT((ALWAYS_PRINT,"Failed Completion for a TIMEOUT IO %lx State %08x\n", phpIORequest, pSrbExt->SRB_State  ));
            #endif

            #ifdef _DEBUG_EVENTLOG_
            LogScsiError( pSrbExt->phpRoot,
                              pSrb,
                      pFcResponse,
                       hpIOInfoLen);

            #endif    
            break;
            
        case osIOAborted:
            osDEBUGPRINT((ALWAYS_PRINT,"osIOCompleted() - %s\n", "osIOAborted" ));
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IO_ABORTED , 
                    NULL, 
                    0, 
                    NULL);
            #endif

            if (pSrbExt->SRB_State ==  RS_TO_BE_ABORTED)
            {
                pSrb->SrbStatus = SRB_STATUS_ABORTED;

            }
            else 
                if(RetrySrbOK(pSrb) == TRUE)
                {
                    phpIORequest->osData = pSrbExt;
                    pSrbExt->SRB_State =  RS_WAITING;
                    osDEBUGPRINT((ALWAYS_PRINT,"Keeping osIOAborted Srb on RetryQ: %08x on pCard: %08x \n", pSrb, pCard));
              
                    // Clear status before retrying.
                    pSrb->SrbStatus = SRB_STATUS_SUCCESS;
                    pSrb->ScsiStatus = SCSISTAT_GOOD;

                    SrbEnqueueHead (&pCard->RetryQ, pSrb);
                    return;
                }
                else
                {
                    pSrb->SrbStatus = SRB_STATUS_ABORTED;
                }
        
           
            break;
            
        case osIOAbortFailed:
            osDEBUGPRINT((ALWAYS_PRINT,"osIOCompleted() - %s\n", "osIOAbortfailed" ));
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IO_ABORTED , 
                    NULL, 
                    0, 
                    NULL);
              #endif
            pSrb->SrbStatus = SRB_STATUS_ABORTED;
            break;

        case osIODevReset:
            #ifdef DONT_RETRY_IOS                                                    
            pSrb->SrbStatus = SRB_STATUS_BUS_RESET;
            pSrb->ScsiStatus = 0;
            #else
        
            if ((pCard->State & CS_DURING_RESET_ADAPTER) || (RetrySrbOK(pSrb) == FALSE))
            {
                pSrb->SrbStatus = SRB_STATUS_BUS_RESET;
                pSrb->ScsiStatus = 0;
            }
            else
            {
                phpIORequest->osData = pSrbExt;

                pSrbExt->SRB_State =  RS_WAITING;
                osDEBUGPRINT((ALWAYS_PRINT,"Retrying Srb: %08x on pCard: %08x \n", pSrb, pCard));
                SrbEnqueueHead (&pCard->AdapterQ, pSrb);
                return;
            }
            #endif
            break;
        
        case osIODevGone:
            osDEBUGPRINT((ALWAYS_PRINT,"osIOCompleted() - %s\n", 
                 (hpIOStatus == osIODevGone) ? "osIODevGone" : "osIOInfoBad" ));
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IOCOMPLETION_OTHER_ERROR , 
                    NULL, 
                    0, 
                    "%08x", hpIOStatus);
            #endif
            pSrb->SrbStatus = SRB_STATUS_NO_DEVICE;
            pSrb->ScsiStatus = 0;
            break;

        case osIOInfoBad:
            osDEBUGPRINT((ALWAYS_PRINT,"osIOCompleted() - %s\n", 
                 (hpIOStatus == osIODevGone) ? "osIODevGone" : "osIOInfoBad" ));
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IOCOMPLETION_OTHER_ERROR , 
                    NULL, 
                    0, 
                    "%08x", hpIOStatus);
            #endif
//            if(gCrashDumping)
//            {   
//                if (!pCard->CDResetCount)
//                {
//                    pCard->CDResetCount++;
//                    pSrb->SrbStatus = SRB_STATUS_BUS_RESET;
//                }
//                else
//                    pSrb->SrbStatus = SRB_STATUS_ERROR;
//            }
//           else
//                pSrb->SrbStatus = SRB_STATUS_ERROR;
            pSrb->SrbStatus = SRB_STATUS_ERROR;
            pSrb->ScsiStatus = 0;
            break;

        
        default:
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_IOCOMPLETION_OTHER_ERROR , 
                    NULL, 
                    0, 
                    "%08x", hpIOStatus);
            #endif
            osDEBUGPRINT((ALWAYS_PRINT,"osIO UNKNOWN Failed pSrb %lx pFcResponse %lx LUext %lx CDB %02x\n", pSrb, pFcResponse, plunExtension, pSrb->Cdb[0]  ));

            pSrb->SrbStatus = SRB_STATUS_NO_DEVICE;
            pSrb->ScsiStatus = 0;

    }

    plunExtension->OutstandingIOs--;
    // PERF if(plunExtension->OutstandingIOs < 0)
    // PERF Bad_Things_Happening

    // PERF if(!remove_Srbext( pCard,  pSrbExt))
    // PERF Bad_Things_Happening


    #ifdef DBGPRINT_IO         
    if (gDbgPrintIo & DBGPRINT_DONE )
    {
        static   count = 0;
        UCHAR    *uptr;
        ULONG    paDeviceIndex = 0;
      
        #ifdef YAM2_1
        paDeviceIndex = plunExtension->PaDeviceIndex;
        #endif

        osDEBUGPRINT((ALWAYS_PRINT, " Done(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Sta %x.%x FCP0 %02x%02x PAIx=%d FCHndl=%08x ",
                        count++,
                        pSrb->PathId,
                        pSrb->TargetId,
                        pSrb->Lun,
                        pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                        pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9],          
                        pSrb->SrbStatus,
                        pSrb->ScsiStatus,
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[0],
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[1],
                        paDeviceIndex,
                        pSrbExt->pLunExt->phandle));
        if (pSrb->DataTransferLength)
        {
            ULONG x,y;
            ULONG wordCount;
            uptr = (UCHAR *)pSrb->DataBuffer;
            wordCount = pSrb->DataTransferLength/4;
            osDEBUGPRINT((ALWAYS_PRINT, "DATA "));
            for (x=0,y=0; x < MIN(wordCount,4); x++ )
            {
                osDEBUGPRINT((ALWAYS_PRINT, "%02x%02x%02x%02x ", uptr[y],uptr[y+1],uptr[y+2],uptr[y+3]));
                y+=4;
            }
        }
         
        osDEBUGPRINT((ALWAYS_PRINT, "\n"));
      
    }
    #endif   

    pSrbExt->SRB_State = RS_COMPLETE;

    ScsiPortNotification(RequestComplete,
                         pCard,
                         pSrb);

    
    #ifdef DBG
    if ((pSrb->SrbStatus != SRB_STATUS_SUCCESS) && (pSrb->SrbStatus != SRB_STATUS_DATA_OVERRUN))
    {
        osDEBUGPRINT((ALWAYS_PRINT," (in osIOCompleted) Srb Status: %02x for Srb: %08x on Target: %02x\n", pSrb->SrbStatus, pSrb, pSrb->TargetId));
    }
    #endif
    osDEBUGPRINT((DLOW,"OUT osIOCompleted\n" ));

    pCard->State &= ~CS_DURING_OSCOMPLETE;

    // PERF pSrbExt->Perf_ptr->outOsIOC     = get_hi_time_stamp();
} // End osIOCompleted

/*++

Routine Description:

    Checks the inquiry data for any of the special device types like 
    MUX, EMC, HP "OPEN-"(Hitachi DF400) or DLT.
    If the device is any one of the special devices then the device is registered in
    pCard->specialDev[] if the device is not already registered.

Arguments:

    CardExtension  - HBA miniport driver's adapter data storage
    pathID         - SP path ID
    targetID       - SP target ID
    inquiryData    - Inquiry data

Return Value:

    none

/--*/

#ifndef YAM2_1
void
RegisterIfSpecialDev (PCARD_EXTENSION pCard, ULONG pathId, ULONG targetId, char *inquiryData)
{
    char *vendorId, *productId;
    USHORT  devType;
    USHORT  addrMode;
    ULONG   i;
    ULONG   slot;
    ULONG   inqDevType;

    vendorId = inquiryData + 8;
    productId = inquiryData + 16;
    inqDevType = (int)(*inquiryData) & 0x1f;

    if ( (  osMemCompare (vendorId, "CROSSRDS", 8) == TRUE &&
            osMemCompare (productId, "CP4400", 6) == TRUE) ||
         (  osMemCompare (vendorId, "HP      ", 8) == TRUE &&
            osMemCompare (productId, "HPA3308", 7) == TRUE)) 
    {
        // Device is a MUX
        devType = DEV_MUX;
        addrMode = LUN_ADDRESS;
    } 
    else 
        if ( (  osMemCompare (vendorId, "EMC     ", 8) == TRUE &&
                  osMemCompare (productId, "SYMMETRIX", 9) == TRUE) ||
               (  osMemCompare (vendorId, "HP      ", 8) == TRUE &&
                  osMemCompare (productId, "OPEN-", 5) == TRUE)      ||
               (  osMemCompare (vendorId, "HP      ", 8) == TRUE &&
                  osMemCompare (productId, "A5277A", 6) == TRUE) )
        {
            // 
            // Device is of type VOLUME Set, i.e. EMC array or HP's OEM version of the Hitachi DF4000
            //
            devType = DEV_VOLUMESET; // Formerly known as DEV_EMC
            addrMode = VOLUME_SET_ADDRESS;
        }  
        else 
            if (inqDevType == 0xc &&
                osMemCompare (vendorId, "COMPAQ  ", 8) == TRUE) 
            {
                // Device is a COMPAQ disk array
                devType = DEV_COMPAQ;
                addrMode = VOLUME_SET_ADDRESS;
            } 
            else
                devType = DEV_NONE;

    if (devType != DEV_NONE) 
    {
        slot = BUILD_SLOT(pathId, targetId);

        // Check if this device is already registered.
        for (i = 0; i < MAX_SPECIAL_DEVICES; i++) 
        {
            if (pCard->specialDev[i].devType != DEV_NONE &&
                pCard->specialDev[i].devHandleIndex == slot)
                // This device is already registered.
                return;
        }

        // Look for an empty slot in specialDev array
        for (i = 0; i < MAX_SPECIAL_DEVICES; i++) 
        {
            if (pCard->specialDev[i].devType == DEV_NONE)
                break;
        }
    
        if (i == MAX_SPECIAL_DEVICES) 
        {
            // There is no empty slot in specialDev array.
            // Look for a slot where no device is present curretly. It can
            // if there was a device present in the past and is currently
            // removed.
            for (i = 0; i < MAX_SPECIAL_DEVICES; i++) 
            {
                if (pCard->hpFCDev [pCard->specialDev[i].devHandleIndex] == NULL)
                    break;
            }
        }
    
        if (i < MAX_SPECIAL_DEVICES) 
        {
            pCard->specialDev[i].devType = devType;
            pCard->specialDev[i].addrMode = addrMode;
             pCard->specialDev[i].devHandleIndex = slot;
        }
    }
}
#else
void
RegisterIfSpecialDev (PCARD_EXTENSION pCard, ULONG pathId, ULONG targetId, char *inquiryData)
{
    char *vendorId, *productId;
    USHORT  devType;
    USHORT  addrMode;
    ULONG   i;
    ULONG   slot;
    ULONG   inqDevType;

    vendorId = inquiryData + 8;
    productId = inquiryData + 16;
    inqDevType = (int)(*inquiryData) & 0x1f;

    if ((osMemCompare (vendorId, "DGC     ", 8) == TRUE &&
       osMemCompare (productId, "RAID", 4) == TRUE) )
        inquiryData[3] |=0x10;
   
}

#endif
// This structure is not currently used.
UCHAR sense_buffer_data[24]={
//     0    1    2    3    4    5    6    7    8    9
    0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//    10   11   12   13   14   15   16   17   18   19
    0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//    20   21   22   23
    0x00,0x00,0x00,0x00 };



/*++

Routine Description:

    Decode FC Status payload to a corresponding NT status
   
Arguments:

    hpRoot            - HBA miniport driver's adapter data storage
    phpIORequest      - Agilent Common IO request structure
    pResponseHeader   - status payload
    hpIOInfoLen       - payload len
    Srb               - SRB



Return Value:

    TRUE
    FALSE

/--*/

BOOLEAN Map_FC_ScsiError( 
    agRoot_t             *hpRoot,
    agIORequest_t        *phpIORequest,
    agFcpRspHdr_t        *pResponseHeader,
    ULONG                hpIOInfoLen,
    PSCSI_REQUEST_BLOCK  Srb )
{
    UCHAR   valid_fields=0;
    ULONG   Sense_Length=0;
    ULONG   Rsp_Length=0;
    ULONG   Resid_Len=0;
    ULONG   tmp32=0;
    PULONG  ptmp32;
    PUCHAR  ptmp8;
    PUCHAR  psensebuffer=NULL;
    PUCHAR  prspbuffer=NULL;
    PSRB_EXTENSION   pSrbExt;
    PCARD_EXTENSION  pCard;
    ULONG   done = FALSE;

    pCard   = (PCARD_EXTENSION)hpRoot->osData;
    pSrbExt = Srb->SrbExtension;

    osDEBUGPRINT((DMOD,"IN Map_FC_ScsiError root %lx req %lx rsp %lx %x srb %lx\n",
                                   hpRoot, phpIORequest,pResponseHeader,hpIOInfoLen,pSrbExt ));

    // Sanity Check
    if (hpIOInfoLen >= sizeof(agFcpRspHdr_t)) 
    {
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Srb->ScsiStatus  = pResponseHeader->FcpStatus[osFCP_STATUS_SCSI_STATUS];

        #if DBG > 4
        ptmp32 = (PULONG)pResponseHeader;

        if(hpIOInfoLen > 32)
            osDEBUGPRINT((ALWAYS_PRINT,"Rsp %08x %08x %08x %08x %08x %08x %08x %08x\n",
                    *(ptmp32+ 0),*(ptmp32+ 1),*(ptmp32+ 2),*(ptmp32+ 3),
                    *(ptmp32+ 4),*(ptmp32+ 5),*(ptmp32+ 6),*(ptmp32+ 7) ));
        if(hpIOInfoLen > 55)
            osDEBUGPRINT((ALWAYS_PRINT,"Rsp %08x %08x %08x %08x %08x %08x\n",
                   *(ptmp32+ 8),*(ptmp32+ 9),*(ptmp32+10),*(ptmp32+11),
                   *(ptmp32+12), *(ptmp32+13)));
        if(hpIOInfoLen > 95)
            osDEBUGPRINT((ALWAYS_PRINT,"Rsp %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x\n",
                    *(ptmp32+14),*(ptmp32+15),*(ptmp32+16),*(ptmp32+17),*(ptmp32+18),
                    *(ptmp32+19),*(ptmp32+20),*(ptmp32+21),*(ptmp32+22),*(ptmp32+23)));
        #endif

        valid_fields = pResponseHeader->FcpStatus[osFCP_STATUS_VALID_FLAGS];
        prspbuffer  = &pResponseHeader->FcpRspLen[4]; // go one over

        // verify that the status is valid
        if (valid_fields & osFCP_RSP_LEN_VALID) 
        {
            ptmp32  = (PULONG)&pResponseHeader->FcpRspLen[0];
            Rsp_Length = SWAPDWORD(*ptmp32);
            osDEBUGPRINT((DMOD,"Rsp len valid Rsp %lx (%x) Length %08x\n", prspbuffer, *prspbuffer,Rsp_Length ));
            //
            // Check response code.
            // FcpRspLen[7] is response code.
            //
            if ((Rsp_Length >= 4) && (pResponseHeader->FcpRspLen[7] != 0)) 
            {
                Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                Srb->ScsiStatus = 0;
                done = TRUE;
            }
        }

        // verify that sense buffer is valid
        if ((done == FALSE) && (valid_fields & osFCP_SNS_LEN_VALID)) 
        {
            // status check condition
            if (Srb->ScsiStatus == 2) 
            {
                ptmp32  = (PULONG)&pResponseHeader->FcpSnsLen[0];
                Sense_Length = SWAPDWORD(*ptmp32);
                psensebuffer  = &pResponseHeader->FcpRspLen[4]; // go one over
                if( Rsp_Length ) 
                    psensebuffer += Rsp_Length;

                osDEBUGPRINT((ALWAYS_PRINT,"Sense length valid Sns %lx (%x) Length %08x\n",
                psensebuffer, *psensebuffer, Sense_Length  ));

                Srb->SrbStatus = SRB_STATUS_ERROR;
                done = TRUE;

                osDEBUGPRINT((DMOD,"FcResponse %lx Valid Flags %02x SCSI STATUS  %02x\n",
                            pResponseHeader,
                            pResponseHeader->FcpStatus[osFCP_STATUS_VALID_FLAGS],
                            pResponseHeader->FcpStatus[osFCP_STATUS_SCSI_STATUS]));

                tmp32 = hpIOInfoLen - sizeof(agFcpRspHdr_t) - Rsp_Length;

                if (tmp32 < Sense_Length)
                    Sense_Length = tmp32;

                if (Srb->SenseInfoBufferLength > Sense_Length)
                    Srb->SenseInfoBufferLength = (UCHAR) Sense_Length;

                osCopy (Srb->SenseInfoBuffer, (ULONG *)psensebuffer, Srb->SenseInfoBufferLength);

                // Set this flag only when we have a valid Sense buffer
                if((Srb->SenseInfoBuffer) && (Srb->SenseInfoBufferLength))
                {
                    Srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                }

                ptmp8  = (PUCHAR) psensebuffer;
                osDEBUGPRINT((ALWAYS_PRINT,"SENSE OS %02x %02x [SK %02x] %02x %02x %02x %02x %02x %02x %02x %02x %02x [ASC %02x ASCQ %02x] %02x %02x %02x %02x\n",
                    *(ptmp8+ 0),*(ptmp8+ 1),*(ptmp8+ 2),*(ptmp8+ 3),*(ptmp8+ 4),*(ptmp8+ 5),*(ptmp8+ 6),*(ptmp8+ 7),*(ptmp8+ 8),*(ptmp8+ 9),
                    *(ptmp8+10),*(ptmp8+11),*(ptmp8+12),*(ptmp8+13),*(ptmp8+14),*(ptmp8+15),*(ptmp8+16),*(ptmp8+17) ));

            } 
            else 
            {
                // unexpected status - SNS_LEN_VALID but not a check condition
                osDEBUGPRINT((ALWAYS_PRINT, "osFCP_SNS_LEN_VALID bit set but ScsiStatus != 2\n"));
                Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                Srb->ScsiStatus = 0;
                done = TRUE;
            }
        }

        if (done == FALSE &&
            Srb->ScsiStatus != SCSISTAT_GOOD &&
            Srb->ScsiStatus != SCSISTAT_CONDITION_MET &&
            Srb->ScsiStatus != SCSISTAT_INTERMEDIATE &&
            Srb->ScsiStatus != SCSISTAT_INTERMEDIATE_COND_MET) 
        {
            // good status and its variants
            Srb->SrbStatus = SRB_STATUS_ERROR;
            done = TRUE;
        }

        if ((done == FALSE) && (valid_fields & osFCP_RESID_UNDER)) 
        {
            // Underrun status
            Srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
            done = TRUE;
            ptmp32  = (PULONG)&pResponseHeader->FcpResId[0];
            Resid_Len = SWAPDWORD(*ptmp32);
            osDEBUGPRINT((ALWAYS_PRINT,"Map_FC_ScsiError: Data Overrun Srb->DataTransferLength=%08x new =%08x Residue=%08x\n", 
               Srb->DataTransferLength,
               Srb->DataTransferLength-Resid_Len,
               Resid_Len ));
            if (Resid_Len & 0x80000000)
            {
                // negative residue.... make sure that SP won't crash by setting it to zero data xferred...
                osDEBUGPRINT((ALWAYS_PRINT,"WARNING !!! Map_FC_ScsiError: Data Overrun negative length Srb->DataTransferLength=%08x Residue=%08x. Reporting 0 bytes xferred\n", 
                    Srb->DataTransferLength,
                    Resid_Len ));
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(pCard, (PVOID)pSrbExt, HPFC_MSG_NEGATIVE_DATA_UNDERRUN, NULL, 0, "%x",  Resid_Len);
                #endif  
                Srb->DataTransferLength = 0;
            }
            else
            {
                Srb->DataTransferLength -= Resid_Len;
            }
            osDEBUGPRINT((DMOD,"Residual UNDER Length %08x\n", Resid_Len ));
        }

        if ((done == FALSE) && (valid_fields & osFCP_RESID_OVER)) 
        {
            // Overrun status - treat it as good status
            osDEBUGPRINT((ALWAYS_PRINT,"Map_FC_ScsiError: data overrun.\n"));
            Srb->ScsiStatus = SCSISTAT_GOOD;

            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            done = TRUE;
        }


        osDEBUGPRINT((DHIGH,"scsi status %x psensebuffer %lx prspbuffer %lx\n",
                           Srb->ScsiStatus, psensebuffer, prspbuffer ));
    } 
    else 
    {
        // FC response payload is less than expected. Report no device
        Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        Srb->ScsiStatus = 0;
    }

    osDEBUGPRINT((DMOD,"SrbStatus %x ScsiStatus %x SrbFlags %x Data len %x Resid %x start %x Delta %x @ %x\n",
                                Srb->SrbStatus,
                                Srb->ScsiStatus,
                                Srb->SrbFlags,
                                Srb->DataTransferLength,
                                Resid_Len,
                                pSrbExt->SRB_StartTime,
                                osTimeStamp(0)-pSrbExt->SRB_StartTime,
                                osTimeStamp(0)));
    return(TRUE);
}

/*++

Routine Description:
    See if we can retry a failed IO request
   
Arguments:

    pSrb  - srb

Return Value:

    TRUE  - yes
    FALSE - no

--*/

int
RetrySrbOK (PSCSI_REQUEST_BLOCK pSrb)
{
    PSRB_EXTENSION pSrbExt = (PSRB_EXTENSION) pSrb->SrbExtension;
    PLU_EXTENSION  plunExtension;
    UCHAR          devType;

    if (pSrbExt)
        plunExtension = pSrbExt->pLunExt;
    else
    {
        osDEBUGPRINT((ALWAYS_PRINT,"%s %s NULL\n","RetrySrbOK", "plunExtension" ));
        return FALSE;
    }
   
    if(plunExtension != NULL )
    {
        devType= pSrbExt->pLunExt->deviceType;
    }
    else
    {
        osDEBUGPRINT((ALWAYS_PRINT,"%s %s NULL\n","RetrySrbOK", "pSrbExt->pLunExt" ));
        return FALSE;
    }

    if (devType == DIRECT_ACCESS_DEVICE ||
        devType == WRITE_ONCE_READ_MULTIPLE_DEVICE || 
        devType == READ_ONLY_DIRECT_ACCESS_DEVICE || 
        devType == OPTICAL_DEVICE) 
    {
    #ifdef MylexWolfpack
        if (pSrb->Cdb[0] == SCSIOP_READ || pSrb->Cdb[0] == SCSIOP_WRITE)
            return FALSE;
    #endif
        return TRUE;
    } 
    else
        // SEQUENTIAL_ACCESS_DEVICE, PRINTER_DEVICE, PROCESSOR_DEVICE
        // SCANNER_DEVICE, MEDIUM_CHANGER, COMMUNICATION_DEVICE
        return FALSE;
}

// for debugging purpose
#ifdef _DEBUG_EVENTLOG_

ULONG gSenseDecode[] =
{
    HPFC_MSG_IO_ERROR_S0,
    HPFC_MSG_IO_ERROR_S1,
    HPFC_MSG_IO_ERROR_S2,
    HPFC_MSG_IO_ERROR_S3,
    HPFC_MSG_IO_ERROR_S4,
    HPFC_MSG_IO_ERROR_S5,
    HPFC_MSG_IO_ERROR_S6,
    HPFC_MSG_IO_ERROR_S7,
    HPFC_MSG_IO_ERROR_S8,
    HPFC_MSG_IO_ERROR_S9,
    HPFC_MSG_IO_ERROR_SA,
    HPFC_MSG_IO_ERROR_SB,
    HPFC_MSG_IO_ERROR_SC,
    HPFC_MSG_IO_ERROR_SD,
    HPFC_MSG_IO_ERROR_SE,
    HPFC_MSG_IO_ERROR_SF
};

SRB_ERROR  gSrbDecode[] = 
    {
    {SRB_STATUS_PENDING,                   HPFC_MSG_IO_ERROR_SRBPENDING},
    {SRB_STATUS_SUCCESS,                   HPFC_MSG_IO_ERROR_SRBSUCCESS},
    {SRB_STATUS_ABORTED,                   HPFC_MSG_IO_ERROR_SRBABORTED},              
    {SRB_STATUS_ABORT_FAILED,              HPFC_MSG_IO_ERROR_SRBABORT_FAILED},         
    {SRB_STATUS_ERROR,                     HPFC_MSG_IO_ERROR_SRBERROR},                
    {SRB_STATUS_BUSY,                      HPFC_MSG_IO_ERROR_SRBBUSY},                 
    {SRB_STATUS_INVALID_REQUEST,           HPFC_MSG_IO_ERROR_SRBINVALID_REQUEST},
    {SRB_STATUS_INVALID_PATH_ID,           HPFC_MSG_IO_ERROR_SRBINVALID_PATH_ID},      
    {SRB_STATUS_NO_DEVICE,                 HPFC_MSG_IO_ERROR_SRBNO_DEVICE},            
    {SRB_STATUS_TIMEOUT,                   HPFC_MSG_IO_ERROR_SRBTIMEOUT},
    {SRB_STATUS_SELECTION_TIMEOUT,         HPFC_MSG_IO_ERROR_SRBSELECTION_TIMEOUT},    
    {SRB_STATUS_COMMAND_TIMEOUT,           HPFC_MSG_IO_ERROR_SRBCOMMAND_TIMEOUT},      
    {SRB_STATUS_MESSAGE_REJECTED,          HPFC_MSG_IO_ERROR_SRBMESSAGE_REJECTED},     
    {SRB_STATUS_BUS_RESET,                 HPFC_MSG_IO_ERROR_SRBBUS_RESET},            
    {SRB_STATUS_PARITY_ERROR,              HPFC_MSG_IO_ERROR_SRBPARITY_ERROR},         
    {SRB_STATUS_REQUEST_SENSE_FAILED,      HPFC_MSG_IO_ERROR_SRBREQUEST_SENSE_FAILED}, 
    {SRB_STATUS_NO_HBA,                    HPFC_MSG_IO_ERROR_SRBNO_HBA},               
    {SRB_STATUS_DATA_OVERRUN,              HPFC_MSG_IO_ERROR_SRBDATA_OVERRUN},         
    {SRB_STATUS_UNEXPECTED_BUS_FREE,       HPFC_MSG_IO_ERROR_SRBUNEXPECTED_BUS_FREE},
    {SRB_STATUS_PHASE_SEQUENCE_FAILURE,    HPFC_MSG_IO_ERROR_SRBPHASE_SEQUENCE_ERROR},
    {SRB_STATUS_BAD_SRB_BLOCK_LENGTH,      HPFC_MSG_IO_ERROR_SRBBAD_SRB_BLOCK_LENGTH},
    {SRB_STATUS_REQUEST_FLUSHED,           HPFC_MSG_IO_ERROR_SRBREQUEST_FLUSHED},
    {SRB_STATUS_INVALID_LUN,               HPFC_MSG_IO_ERROR_SRBINVALID_LUN},
    {SRB_STATUS_INVALID_TARGET_ID,         HPFC_MSG_IO_ERROR_SRBINVALID_TARGET_ID},
    {SRB_STATUS_BAD_FUNCTION,              HPFC_MSG_IO_ERROR_SRBBAD_FUNCTION},
    {SRB_STATUS_ERROR_RECOVERY,            HPFC_MSG_IO_ERROR_SRBERROR_RECOVERY},
    #ifdef HP_NT50
    {SRB_STATUS_NOT_POWERED,               HPFC_MSG_IO_ERROR_SRBNOT_POWERED},
    #endif
    {0xff,                                 HPFC_MSG_IO_ERROR_SRBUNDEFINED_ERROR}
   };

#endif

#ifdef _DEBUG_EVENTLOG_
extern ULONG gSenseDecode[];
extern SRB_ERROR  gSrbDecode[];

ULONG DecodeSrbError(UCHAR err)
{
    SRB_ERROR   *pSrbDecode = gSrbDecode;
   
    while(   !(pSrbDecode->SrbStatus == 0xff)  && 
            !(pSrbDecode->SrbStatus == err) )
       pSrbDecode++;
   
    return(pSrbDecode->LogCode);
   
   
}

BOOLEAN LogScsiError( agRoot_t            *hpRoot,
                      PSCSI_REQUEST_BLOCK pSrb ,
                  agFcpRspHdr_t  * pResponseHeader,
                  ULONG           hpIOInfoLen)
{
    PSRB_EXTENSION    pSrbExt;
    PCARD_EXTENSION   pCard;
    UCHAR             dumpdata[36];
    ULONG             level = HPFC_MSG_IO_ERROR ;
    ULONG             size = sizeof(dumpdata)/sizeof(LONG);
         
    #ifndef DBG  
    if( LogLevel == LOG_LEVEL_NONE ) 
        return (0);
    #endif
      
    pCard   = (PCARD_EXTENSION)hpRoot->osData;
    pSrbExt = pSrb->SrbExtension;
    
    osCopy (dumpdata,  pSrb->Cdb, 16);
    dumpdata[16] = pSrb->SrbStatus;
    dumpdata[17] = pSrb->ScsiStatus;
   
    dumpdata[18] = 0xfa;                /* not used */
    dumpdata[19] = 0xce;                /* not used */
   
   
    if (pSrb->ScsiStatus == 2)       /* check condition */
    {
        if (pSrb->SenseInfoBuffer)
        {
            osCopy (dumpdata+20, pSrb->SenseInfoBuffer, 
                (pSrb->SenseInfoBufferLength < 16) ? pSrb->SenseInfoBufferLength : 16 );
            level = gSenseDecode[ (*(((PCHAR)pSrb->SenseInfoBuffer )+2)) & 0xF ];
        }
        else
            osDEBUGPRINT((ALWAYS_PRINT,"LogScsiError: pSrb->SenseInfoBuffer NULL\n"));
    }
    else
    {
        level = DecodeSrbError(pSrb->SrbStatus);
        size = 20/sizeof(ULONG);         /* display the first 20 bytes */
    }
      
    LogEvent(   pCard, 
               (PVOID)pSrbExt, 
               level, 
               (LONG *)dumpdata, 
               size, 
               NULL);
      
    
    
    #if DBG > 0
    {
        ULONG x1,x2,x3,x4;
        PCHAR             pptr;
        pptr = (PCHAR)pSrb->SenseInfoBuffer;

        if( pResponseHeader)
        {
            x1=(ULONG)pResponseHeader->FcpStatus[0];
            x2=(ULONG)pResponseHeader->FcpStatus[1];
            x3=(ULONG)pResponseHeader->FcpStatus[2];
            x4=(ULONG)pResponseHeader->FcpStatus[3];
        }
        else
        {
            x1=x2=x3=x4=0;
        }

        osDEBUGPRINT((ALWAYS_PRINT,"LogScsiError: %d.%d.%d STA %d.%d (FCPSta %x.%02x.%02x.%02x.%02x) ",
            pSrb->PathId, pSrb->TargetId, pSrb->Lun,
            pSrb->SrbStatus, pSrb->ScsiStatus,
            hpIOInfoLen,
            x1,x2,x3,x4));

        osDEBUGPRINT((ALWAYS_PRINT,"CDB %02x%02x%02x%02x%02x %02x%02x%02x%02x%02x pCDB %lx ",
            pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
            pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], &pSrb->Cdb[0]));

        if (pptr)
            osDEBUGPRINT((ALWAYS_PRINT, "SNS %02x%02x[%02x]%02x %02x%02x%02x%02x %02x%02x%02x%02x [%02x][%02x]%02x%02x\n",
                pptr[0],pptr[1],pptr[2],pptr[3],pptr[4],
                pptr[5],pptr[6],pptr[7],pptr[8],pptr[9], 
                pptr[10],pptr[11],pptr[12],pptr[13],pptr[14],pptr[15] ));
    }
    #endif
    return(TRUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\linksvc.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/LinkSvc.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/14/00 5:53p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/LinkSvc.C

--*/

#ifndef __LinkSvc_H__
#define __LinkSvc_H__

/* SF_CMND_Type(SF_CMND_Class==SFThread_SF_CMND_Class_LinkSvc) Declarations */

#define SFThread_SF_CMND_LinkSvc_Type_ABTS      0x01
#define SFThread_SF_CMND_LinkSvc_Type_BA_RJT    0x02
#define SFThread_SF_CMND_LinkSvc_Type_LS_RJT    0x03
#define SFThread_SF_CMND_LinkSvc_Type_PLOGI     0x04
#define SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC 0x05
#define SFThread_SF_CMND_LinkSvc_Type_FLOGI     0x06
#define SFThread_SF_CMND_LinkSvc_Type_LOGO      0x07
#define SFThread_SF_CMND_LinkSvc_Type_ELS_ACC   0x08
#define SFThread_SF_CMND_LinkSvc_Type_RRQ       0x09
#define SFThread_SF_CMND_LinkSvc_Type_PRLI      0x0A
#define SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC  0x0B
#define SFThread_SF_CMND_LinkSvc_Type_PRLO      0x0C
#define SFThread_SF_CMND_LinkSvc_Type_ADISC     0x0D
#define SFThread_SF_CMND_LinkSvc_Type_SCR       0x0E
#define SFThread_SF_CMND_LinkSvc_Type_SRR       0x0F
#define SFThread_SF_CMND_LinkSvc_Type_REC       0x10
#define SFThread_SF_CMND_LinkSvc_Type_ADISC_ACC 0x11
#ifdef _DvrArch_1_30_
#define SFThread_SF_CMND_LinkSvc_Type_FARP_REQ   0x12
#define SFThread_SF_CMND_LinkSvc_Type_FARP_REPLY 0x13
#endif /* _DvrArch_1_30_ was defined */


/* SF_CMND_State(SF_CMND_Class==SFThread_SF_CMND_Class_LinkSvc,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_LinkSvc_State_Started  0x01
#define SFThread_SF_CMND_LinkSvc_State_Finished 0x02

/* SF_CMND_Status(SF_CMND_Class==SFThread_SF_CMND_Class_LinkSvc,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_LinkSvc_Status_Good 0x01
#define SFThread_SF_CMND_LinkSvc_Status_Bad  0x02

/* Function Prototypes */

osGLOBAL void fiLinkSvcInit(
                           agRoot_t *hpRoot
                         );

osGLOBAL os_bit32 fiFillInBA_RJT(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID,
                             os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                           );

osGLOBAL os_bit32 fiFillInBA_RJT_OnCard(
                                    SFThread_t *SFThread,
                                    os_bit32       D_ID,
                                    os_bit32       OX_ID,
                                    os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                                  );

osGLOBAL os_bit32 fiFillInBA_RJT_OffCard(
                                     SFThread_t *SFThread,
                                     os_bit32       D_ID,
                                     os_bit32       OX_ID,
                                     os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                                   );

osGLOBAL os_bit32 fiFillInABTS(
                           SFThread_t *SFThread
                         );

osGLOBAL os_bit32 fiFillInABTS_OnCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInABTS_OffCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL void fiLinkSvcProcess_ABTS_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_ABTS_Response_OffCard(
                                                    SFThread_t          *SFThread,
                                                    os_bit32                Frame_Length,
                                                    FCHS_t              *FCHS,
                                                    FC_BA_ACC_Payload_t *Payload,
                                                    os_bit32                Payload_Wrap_Offset,
                                                    FC_BA_ACC_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL void fiFillInELSFrameHeader_OnCard(
                                           SFThread_t *SFThread,
                                           os_bit32       D_ID,
                                           os_bit32       X_ID,
                                           os_bit32       F_CTL_Exchange_Context
                                         );

osGLOBAL void fiFillInELSFrameHeader_OffCard(
                                            SFThread_t *SFThread,
                                            os_bit32       D_ID,
                                            os_bit32       X_ID,
                                            os_bit32       F_CTL_Exchange_Context
                                          );

osGLOBAL os_bit32 fiFillInLS_RJT(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID,
                             os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                           );

osGLOBAL os_bit32 fiFillInLS_RJT_OnCard(
                                    SFThread_t *SFThread,
                                    os_bit32       D_ID,
                                    os_bit32       OX_ID,
                                    os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                                  );

osGLOBAL os_bit32 fiFillInLS_RJT_OffCard(
                                     SFThread_t *SFThread,
                                     os_bit32       D_ID,
                                     os_bit32       OX_ID,
                                     os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                                   );

osGLOBAL os_bit32 fiFillInPLOGI(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInPLOGI_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInPLOGI_OffCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL void fiLinkSvcProcess_PLOGI_Response_OnCard(
                                                    SFThread_t *SFThread,
                                                    os_bit32       Frame_Length,
                                                    os_bit32       Offset_to_FCHS,
                                                    os_bit32       Offset_to_Payload,
                                                    os_bit32       Payload_Wrap_Offset,
                                                    os_bit32       Offset_to_Payload_Wrapped
                                                  );

osGLOBAL void fiLinkSvcProcess_PLOGI_Response_OffCard(
                                                     SFThread_t                 *SFThread,
                                                     os_bit32                       Frame_Length,
                                                     FCHS_t                     *FCHS,
                                                     FC_ELS_ACC_PLOGI_Payload_t *Payload,
                                                     os_bit32                       Payload_Wrap_Offset,
                                                     FC_ELS_ACC_PLOGI_Payload_t *Payload_Wrapped
                                                   );

osGLOBAL os_bit32 fiLinkSvcProcess_PLOGI_Request_OnCard(
                                                    agRoot_t  *hpRoot,
                                                    X_ID_t     OX_ID,
                                                    os_bit32      Frame_Length,
                                                    os_bit32      Offset_to_FCHS,
                                                    os_bit32      Offset_to_Payload,
                                                    os_bit32      Payload_Wrap_Offset,
                                                    os_bit32      Offset_to_Payload_Wrapped,
                                                    fi_thread__t **Thread_to_return
                                                  );

osGLOBAL os_bit32 fiLinkSvcProcess_PLOGI_Request_OffCard(
                                                     agRoot_t                *hpRoot,
                                                     X_ID_t                   OX_ID,
                                                     os_bit32                    Frame_Length,
                                                     FCHS_t                  *FCHS,
                                                     FC_ELS_PLOGI_Payload_t  *Payload,
                                                     os_bit32                    Payload_Wrap_Offset,
                                                     FC_ELS_PLOGI_Payload_t  *Payload_Wrapped,
                                                     fi_thread__t               **Thread_to_return
                                                   );

osGLOBAL os_bit32 fiFillInPLOGI_ACC(
                                SFThread_t *SFThread,
                                os_bit32       D_ID,
                                os_bit32       OX_ID
                              );

osGLOBAL os_bit32 fiFillInPLOGI_ACC_OnCard(
                                       SFThread_t *SFThread,
                                       os_bit32       D_ID,
                                       os_bit32       OX_ID
                                     );

osGLOBAL os_bit32 fiFillInPLOGI_ACC_OffCard(
                                        SFThread_t *SFThread,
                                        os_bit32       D_ID,
                                        os_bit32       OX_ID
                                      );

osGLOBAL os_bit32 fiFillInFLOGI(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInFLOGI_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInFLOGI_OffCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL void fiLinkSvcProcess_FLOGI_Response_OnCard(
                                                    SFThread_t *SFThread,
                                                    os_bit32       Frame_Length,
                                                    os_bit32       Offset_to_FCHS,
                                                    os_bit32       Offset_to_Payload,
                                                    os_bit32       Payload_Wrap_Offset,
                                                    os_bit32       Offset_to_Payload_Wrapped
                                                  );

osGLOBAL void fiLinkSvcProcess_FLOGI_Response_OffCard(
                                                     SFThread_t                 *SFThread,
                                                     os_bit32                       Frame_Length,
                                                     FCHS_t                     *FCHS,
                                                     FC_ELS_ACC_FLOGI_Payload_t *Payload,
                                                     os_bit32                       Payload_Wrap_Offset,
                                                     FC_ELS_ACC_FLOGI_Payload_t *Payload_Wrapped
                                                   );

osGLOBAL os_bit32 fiFillInLOGO(
                           SFThread_t *SFThread
                         );

osGLOBAL os_bit32 fiFillInLOGO_OnCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInLOGO_OffCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL void fiLinkSvcProcess_LOGO_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_LOGO_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_GENERIC_ACC_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_GENERIC_ACC_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL os_bit32 fiFillInSRR(
                           SFThread_t *SFThread,
                           os_bit32    OXID,
                           os_bit32    RXID,
                           os_bit32    Relative_Offset,
                           os_bit32    R_CTL
                         );

osGLOBAL os_bit32 fiFillInSRR_OnCard(
                                  SFThread_t *SFThread,
                                  os_bit32      OXID,
                                  os_bit32      RXID,
                                  os_bit32      Relative_Offset,
                                  os_bit32      R_CTL
                                );

osGLOBAL os_bit32 fiFillInSRR_OffCard(
                                   SFThread_t *SFThread,
                                   os_bit32       OXID,
                                   os_bit32       RXID,
                                   os_bit32       Relative_Offset,
                                   os_bit32       R_CTL
                                 );

osGLOBAL void fiLinkSvcProcess_SRR_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_SRR_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_GENERIC_ACC_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_GENERIC_ACC_Payload_t *Payload_Wrapped
                                                  );
osGLOBAL os_bit32 fiFillInREC(
                           SFThread_t *SFThread,
                           os_bit32       OXID,
                           os_bit32       RXID
                         );

osGLOBAL os_bit32 fiFillInREC_OnCard(
                                  SFThread_t *SFThread,
                                  os_bit32     OXID,
                                  os_bit32     RXID
                                );

osGLOBAL os_bit32 fiFillInREC_OffCard(
                                   SFThread_t *SFThread,
                                   os_bit32    OXID,
                                   os_bit32    RXID
                                 );

osGLOBAL void fiLinkSvcProcess_REC_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_REC_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_REC_ACC_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_REC_ACC_Payload_t *Payload_Wrapped
                                                  );


osGLOBAL os_bit32 fiFillInELS_ACC(
                               SFThread_t *SFThread,
                               os_bit32       D_ID,
                               os_bit32       OX_ID
                             );

osGLOBAL os_bit32 fiFillInELS_ACC_OnCard(
                                      SFThread_t *SFThread,
                                      os_bit32       D_ID,
                                      os_bit32       OX_ID
                                    );

osGLOBAL os_bit32 fiFillInELS_ACC_OffCard(
                                       SFThread_t *SFThread,
                                       os_bit32       D_ID,
                                       os_bit32       OX_ID
                                     );

osGLOBAL void fiLinkSvcProcess_LILP_OnCard(
                                          agRoot_t *hpRoot,
                                          os_bit32     Frame_Length,
                                          os_bit32     Offset_to_FCHS,
                                          os_bit32     Offset_to_Payload,
                                          os_bit32     Payload_Wrap_Offset,
                                          os_bit32     Offset_to_Payload_Wrapped
                                        );

osGLOBAL void fiLinkSvcProcess_LILP_OffCard(
                                           agRoot_t                                     *hpRoot,
                                           os_bit32                                         Frame_Length,
                                           FCHS_t                                       *FCHS,
                                           FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *Payload,
                                           os_bit32                                         Payload_Wrap_Offset,
                                           FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *Payload_Wrapped
                                         );

osGLOBAL os_bit32 fiFillInRRQ(
                          SFThread_t *SFThread
                        );

osGLOBAL os_bit32 fiFillInRRQ_OnCard(
                                 SFThread_t *SFThread
                               );

osGLOBAL os_bit32 fiFillInRRQ_OffCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL void fiLinkSvcProcess_RRQ_Response_OnCard(
                                                  SFThread_t *SFThread,
                                                  os_bit32       Frame_Length,
                                                  os_bit32       Offset_to_FCHS,
                                                  os_bit32       Offset_to_Payload,
                                                  os_bit32       Payload_Wrap_Offset,
                                                  os_bit32       Offset_to_Payload_Wrapped
                                                );

osGLOBAL void fiLinkSvcProcess_RRQ_Response_OffCard(
                                                   SFThread_t               *SFThread,
                                                   os_bit32                     Frame_Length,
                                                   FCHS_t                   *FCHS,
                                                   FC_ELS_ACC_RRQ_Payload_t *Payload,
                                                   os_bit32                     Payload_Wrap_Offset,
                                                   FC_ELS_ACC_RRQ_Payload_t *Payload_Wrapped
                                                 );

osGLOBAL os_bit32 fiFillInPRLI(
                           SFThread_t *SFThread
                         );

osGLOBAL os_bit32 fiFillInPRLI_OnCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInPRLI_OffCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL void fiLinkSvcProcess_PRLI_Response_Either(
                                                   DevThread_t *DevThread
                                                 );

osGLOBAL void fiLinkSvcProcess_PRLI_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_PRLI_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_ACC_PRLI_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_ACC_PRLI_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL os_bit32 fiFillInPRLI_ACC(
                               SFThread_t *SFThread,
                               os_bit32       D_ID,
                               os_bit32       OX_ID
                             );

osGLOBAL os_bit32 fiFillInPRLI_ACC_OnCard(
                                      SFThread_t *SFThread,
                                      os_bit32       D_ID,
                                      os_bit32       OX_ID
                                    );

osGLOBAL os_bit32 fiFillInPRLI_ACC_OffCard(
                                       SFThread_t *SFThread,
                                       os_bit32       D_ID,
                                       os_bit32       OX_ID
                                     );

osGLOBAL os_bit32 fiFillInPRLO(
                           SFThread_t *SFThread
                         );

osGLOBAL os_bit32 fiFillInPRLO_OnCard(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInPRLO_OffCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL void fiLinkSvcProcess_PRLO_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_PRLO_Response_OffCard(
                                                    SFThread_t                *SFThread,
                                                    os_bit32                      Frame_Length,
                                                    FCHS_t                    *FCHS,
                                                    FC_ELS_ACC_PRLO_Payload_t *Payload,
                                                    os_bit32                      Payload_Wrap_Offset,
                                                    FC_ELS_ACC_PRLO_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL os_bit32 fiFillInADISC(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInADISC_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInADISC_OffCard(
                                    SFThread_t *SFThread
                                  );


osGLOBAL os_bit32 fiLinkSvcProcess_ADISC_Response_OnCard(
                                                    SFThread_t *SFThread,
                                                    os_bit32       Frame_Length,
                                                    os_bit32       Offset_to_FCHS,
                                                    os_bit32       Offset_to_Payload,
                                                    os_bit32       Payload_Wrap_Offset,
                                                    os_bit32       Offset_to_Payload_Wrapped
                                                  );

osGLOBAL os_bit32 fiLinkSvcProcess_ADISC_Response_OffCard(
                                                     SFThread_t                 *SFThread,
                                                     os_bit32                       Frame_Length,
                                                     FCHS_t                     *FCHS,
                                                     FC_ELS_ACC_ADISC_Payload_t *Payload,
                                                     os_bit32                       Payload_Wrap_Offset,
                                                     FC_ELS_ACC_ADISC_Payload_t *Payload_Wrapped
                                                   );

#ifdef _DvrArch_1_30_
os_bit32 fiFillInFARP_REQ_OffCard(
                                   SFThread_t *SFThread
                                 );

os_bit32 fiFillInFARP_REPLY_OffCard(
                                     SFThread_t *SFThread
                                   );

os_bit32 fiLinkSvcProcess_FARP_Request_OffCard(
                                                agRoot_t                    *hpRoot,
                                                X_ID_t                       OX_ID,
                                                os_bit32                     Frame_Length,
                                                FCHS_t                      *FCHS,
                                                FC_ELS_FARP_REQ_Payload_t   *Payload,
                                                os_bit32                     Payload_Wrap_Offset,
                                                FC_ELS_FARP_REQ_Payload_t   *Payload_Wrapped,
                                                fi_thread__t               **Thread_to_return
                                              );
void fiLinkSvcProcess_FARP_Response_OffCard(
                                             SFThread_t                  * SFThread,
                                             os_bit32                      Frame_Length,
                                             FCHS_t                      * FCHS,
                                             FC_ELS_FARP_REPLY_Payload_t * Payload,
                                             os_bit32                      Payload_Wrap_Offset,
                                             FC_ELS_FARP_REPLY_Payload_t * Payload_Wrapped
                                           );
#endif /* _DvrArch_1_30_ was defined */

osGLOBAL os_bit32 fiFillInADISC_ACC(
                            SFThread_t *SFThread,
                            os_bit32       D_ID,
                            os_bit32       OX_ID
                           );

osGLOBAL os_bit32 fiFillInADISC_ACC_OffCard(
                                   SFThread_t *SFThread,
                                   os_bit32       D_ID,
                                   os_bit32       OX_ID
                                  );
osGLOBAL os_bit32 fiFillInADISC_ACC_OnCard(
                                   SFThread_t *SFThread,
                                   os_bit32       D_ID,
                                   os_bit32       OX_ID
                                 );



osGLOBAL os_bit32 fiFillInSCR(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInSCR_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInSCR_OffCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL void fiLinkSvcProcess_SCR_Response_OnCard(
                                                    SFThread_t *SFThread,
                                                    os_bit32       Frame_Length,
                                                    os_bit32       Offset_to_FCHS,
                                                    os_bit32       Offset_to_Payload,
                                                    os_bit32       Payload_Wrap_Offset,
                                                    os_bit32       Offset_to_Payload_Wrapped
                                                  );

osGLOBAL void fiLinkSvcProcess_SCR_Response_OffCard(
                                                     SFThread_t                 *SFThread,
                                                     os_bit32                       Frame_Length,
                                                     FCHS_t                     *FCHS,
                                                     FC_ELS_ACC_SCR_Payload_t *Payload,
                                                     os_bit32                       Payload_Wrap_Offset,
                                                     FC_ELS_ACC_SCR_Payload_t *Payload_Wrapped
                                                   );


osGLOBAL void fiLinkSvcProcess_TargetRequest_OnCard(
                                                   agRoot_t *hpRoot,
                                                   os_bit32     Frame_Length,
                                                   os_bit32     Offset_to_FCHS,
                                                   os_bit32     Offset_to_Payload,
                                                   os_bit32     Payload_Wrap_Offset,
                                                   os_bit32     Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiLinkSvcProcess_TargetRequest_OffCard(
                                                    agRoot_t *hpRoot,
                                                    os_bit32     Frame_Length,
                                                    FCHS_t   *FCHS,
                                                    void     *Payload,
                                                    os_bit32     Payload_Wrap_Offset,
                                                    void     *Payload_Wrapped
                                                  );

#define fiLinkSvc_Cmd_Status_ACC              0x00000010
#define fiLinkSvc_Cmd_Status_RJT              0x00000011
#define fiLinkSvc_Cmd_Status_PLOGI_From_Self  0x00000012
#define fiLinkSvc_Cmd_Status_PLOGI_From_Twin  0x00000013
#define fiLinkSvc_Cmd_Status_PLOGI_From_Other 0x00000014
#define fiLinkSvc_Cmd_Status_TargetRequest    0x00000015
#define fiLinkSvc_Cmd_Status_Position_Map     0x00000016
#ifdef _DvrArch_1_30_
#define fiLinkSvc_Cmd_Status_FARP_From_Self   0x00000017
#define fiLinkSvc_Cmd_Status_FARP_From_Twin   0x00000018
#define fiLinkSvc_Cmd_Status_FARP_From_Other  0x00000019
#endif /* _DvrArch_1_30_ was defined */
#define fiLinkSvc_Cmd_Status_FC_Tape_XRDY     0x0000001A
#define fiLinkSvc_Cmd_Status_Confused         0xFFFFFFFF 

osGLOBAL os_bit32 fiLinkSvcProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                );

osGLOBAL os_bit32 fiLinkSvcProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t   SFQConsIndex,
                                         os_bit32            Frame_Length,
                                         fi_thread__t       **Thread_to_return
                                       );

osGLOBAL os_bit32 fiLinkSvcProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t   SFQConsIndex,
                                          os_bit32            Frame_Length,
                                          fi_thread__t       **Thread_to_return
                                        );


osGLOBAL os_bit32 fiFillInFAN(
                            SFThread_t *SFThread
                          );

osGLOBAL os_bit32 fiFillInFAN_OnCard(
                                   SFThread_t *SFThread
                                 );

osGLOBAL os_bit32 fiFillInFAN_OffCard(
                                    SFThread_t *SFThread
                                  );

#endif /* __LinkSvc_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\linksvc.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/LinkSvc.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/05/00 2:49p  $ (Last Modified)

Purpose:

  This file implements Link Services for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tgtstate.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/flashsvc.h"
#include "../h/fcmain.h"
#include "../h/cfunc.h"
#include "../h/queue.h"
#include "../h/linksvc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tgtstate.h"
#include "memmap.h"
#include "tlstruct.h"
#include "flashsvc.h"
#include "fcmain.h"
#include "cfunc.h"
#include "queue.h"
#include "linksvc.h"
#endif  /* _New_Header_file_Layout_ */

void fiLinkSvcInit(
                    agRoot_t *hpRoot
                  )
{
    CThread_t *CThread = CThread_ptr(hpRoot);
    os_bit32   DEVID      = CThread->DEVID;

/*+
Initialize ChanInfo with TachyonTL's Common and Class Parameters
-*/
#ifdef NAME_SERVICES

    if(!(CThread->InitAsNport || CThread->ConnectedToNportOrFPort))
    {
        CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit
            =   (FC_N_Port_Common_Parms_Version_FC_PH_2 << FC_N_Port_Common_Parms_Highest_Version_SHIFT)
              | (FC_N_Port_Common_Parms_Version_4_3 << FC_N_Port_Common_Parms_Lowest_Version_SHIFT)
              | (TachyonTL_BB_Credit << FC_N_Port_Common_Parms_BB_Credit_SHIFT);
    }

    else
    {
#endif  /* NAME_SERVICES */
    CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit
        =   (FC_N_Port_Common_Parms_Version_FC_PH_2 << FC_N_Port_Common_Parms_Highest_Version_SHIFT)
          | (FC_N_Port_Common_Parms_Version_4_3 << FC_N_Port_Common_Parms_Lowest_Version_SHIFT)
          | (TachyonTL_Nport_BB_Credit << FC_N_Port_Common_Parms_BB_Credit_SHIFT);
#ifdef NAME_SERVICES
    }
#endif /* NAME_SERVICES */

    if (CThread_ptr(hpRoot)->DEVID == ChipConfig_DEVID_TachyonXL2)
    {
        if( CThread->InitAsNport)
        {
            CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                  | FC_N_Port_Common_Parms_N_Port
                  | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management/* MacData  */ 
                  | (CFunc_MAX_XL2_Payload(hpRoot) << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);
        }
        else
        {
            CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                  | FC_N_Port_Common_Parms_N_Port
                  | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management
                  | (CFunc_MAX_XL2_Payload(hpRoot) << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);

        }
    }
    else
    {
        if( CThread->InitAsNport)
        {
            CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                  | FC_N_Port_Common_Parms_N_Port
                  | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management /* MacData */ 
                  | (TachyonTL_Max_Frame_Payload << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);
        }
        else
        {
            CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                  | FC_N_Port_Common_Parms_N_Port
                  | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management
                  | (TachyonTL_Max_Frame_Payload << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);
        }
    }

    CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
        =   (TachyonTL_Total_Concurrent_Sequences << FC_N_Port_Common_Parms_Total_Concurrent_Sequences_SHIFT)
          | TachyonTL_RO_Valid_by_Category;

    CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV = 0;

    CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags = 0;
    CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size               = 0;
    CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit                          = 0;
    CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange                              = 0;

    CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags = 0;
    CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size               = 0;
    CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit                          = 0;
    CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange                              = 0;

    CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
        =   FC_N_Port_Class_Parms_Class_Validity
          | FC_N_Port_Class_Parms_Sequential_Delivery_Requested
          | FC_N_Port_Class_Parms_X_ID_Reassignment_Not_Supported
          | FC_N_Port_Class_Parms_Initial_Process_Associator_Not_Supported;

    if (DEVID == ChipConfig_DEVID_TachyonXL2)
    {
        CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            =   FC_N_Port_Class_Parms_Only_Discard_Supported
              | FC_N_Port_Class_Parms_1_Category_per_Sequence
              | (CFunc_MAX_XL2_Payload(hpRoot) << FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT);
    }
    else
    {
        CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            =   FC_N_Port_Class_Parms_Only_Discard_Supported
              | FC_N_Port_Class_Parms_1_Category_per_Sequence
              | (TachyonTL_Max_Frame_Payload << FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT);
    }

    CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
        =   (TachyonTL_Total_Concurrent_Sequences << FC_N_Port_Class_Parms_Concurrent_Sequences_SHIFT)
          | (0 << FC_N_Port_Class_Parms_EE_Credit_SHIFT);

    CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange
        = (TachyonTL_Open_Sequences_per_Exchange << FC_N_Port_Class_Parms_Open_Sequences_per_Exchange_SHIFT);
}

os_bit32 fiFillInABTS(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInABTS_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInABTS_OffCard(
                                     SFThread
                                   );
    }
}

os_bit32 fiFillInABTS_OnCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot            = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread           = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread         = SFThread->parent.CDB;
    DevThread_t *DevThread         = CDBThread->Device;
    os_bit32        S_ID = 0;
    os_bit32        D_ID;
    X_ID_t       OX_ID;
    X_ID_t       RX_ID;
    os_bit32        ABTS_Frame_Offset = SFThread->SF_CMND_Offset;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ABTS;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;


    D_ID = fiComputeDevThread_D_ID(
                                    DevThread
                                  );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        OX_ID = CDBThread->X_ID | X_ID_Read;
        RX_ID = 0xFFFF;                      /* No way to know what the RX_ID value should be */
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        OX_ID = CDBThread->X_ID | X_ID_Write;

        if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inCardRam)
        {
            RX_ID = (os_bit16) ((osCardRamReadBit32(
                                         hpRoot,
                                         CDBThread->SEST_Offset + hpFieldOffset(
                                                                                 SEST_t,
                                                                                 IWE.MBZ5__RX_ID
                                                                               )
                                       ) & IWE_RX_ID_MASK) >> IWE_RX_ID_SHIFT);
        }
        else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inDmaMemory */
        {
            RX_ID = (CDBThread->SEST_Ptr->IWE.MBZ5__RX_ID & IWE_RX_ID_MASK) >> IWE_RX_ID_SHIFT;
        }
    }

/*+
Fill in ABTS Frame (there is no ABTS Frame Payload)
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            MBZ1
                                                          ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                          ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            R_CTL__D_ID
                                                          ),
                         (  FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame
                          | FC_Frame_Header_R_CTL_Lo_BLS_ABTS
                          | D_ID                                           )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            CS_CTL__S_ID
                                                          ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            TYPE__F_CTL
                                                          ),
                         (  FC_Frame_Header_TYPE_BLS
                          | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                          | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                          | FC_Frame_Header_F_CTL_First_Sequence
                          | FC_Frame_Header_F_CTL_End_Sequence
                          | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SEQ_ID__DF_CTL__SEQ_CNT
                                                          ),
                         (  FC_Frame_Header_SEQ_ID_MASK
                          | FC_Frame_Header_DF_CTL_No_Device_Header )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            OX_ID__RX_ID
                                                          ),
                         (  (OX_ID << FCHS_OX_ID_SHIFT)
                          | (RX_ID << FCHS_RX_ID_SHIFT)         )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ABTS_Frame_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            RO
                                                          ),
                         0
                       );

/*+
Return length of ABTS Frame (there is no ABTS Frame Payload)
-*/

    return sizeof(FCHS_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInABTS_OffCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    agRoot_t    *hpRoot     = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread    = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread  = SFThread->parent.CDB;
    DevThread_t *DevThread  = CDBThread->Device;
    os_bit32        S_ID = 0;
    os_bit32        D_ID;
    X_ID_t       OX_ID;
    X_ID_t       RX_ID;
    FCHS_t      *ABTS_Frame = SFThread->SF_CMND_Ptr;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ABTS;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;


    D_ID = fiComputeDevThread_D_ID(
                                    DevThread
                                  );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        OX_ID = CDBThread->X_ID | X_ID_Read;
        RX_ID = 0xFFFF;                      /* No way to know what the RX_ID value should be */
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        OX_ID = CDBThread->X_ID | X_ID_Write;

        if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inCardRam)
        {
            RX_ID = (os_bit16)((osCardRamReadBit32(
                                         hpRoot,
                                         CDBThread->SEST_Offset + hpFieldOffset(
                                                                                 SEST_t,
                                                                                 IWE.MBZ5__RX_ID
                                                                               )
                                       ) & IWE_RX_ID_MASK) >> IWE_RX_ID_SHIFT);
        }
        else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inDmaMemory */
        {
            RX_ID = (CDBThread->SEST_Ptr->IWE.MBZ5__RX_ID & IWE_RX_ID_MASK) >> IWE_RX_ID_SHIFT;
        }
    }

/*+
Fill in ABTS Frame (there is no ABTS Frame Payload)
-*/

    ABTS_Frame->MBZ1                                        = 0;
    ABTS_Frame->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                               | FCHS_EOF_EOFn
                                                               | FCHS_CLS;
    ABTS_Frame->R_CTL__D_ID                                 =   FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame
                                                               | FC_Frame_Header_R_CTL_Lo_BLS_ABTS
                                                               | D_ID;
    ABTS_Frame->CS_CTL__S_ID                                = S_ID;
    ABTS_Frame->TYPE__F_CTL                                 =   FC_Frame_Header_TYPE_BLS
                                                               | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                                               | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                               | FC_Frame_Header_F_CTL_First_Sequence
                                                               | FC_Frame_Header_F_CTL_End_Sequence
                                                               | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer;
    ABTS_Frame->SEQ_ID__DF_CTL__SEQ_CNT                     =   FC_Frame_Header_SEQ_ID_MASK
                                                               | FC_Frame_Header_DF_CTL_No_Device_Header;
    ABTS_Frame->OX_ID__RX_ID                                =   (OX_ID << FCHS_OX_ID_SHIFT)
                                                               | (RX_ID << FCHS_RX_ID_SHIFT);
    ABTS_Frame->RO                                          = 0;

/*+
Return length of ABTS Frame (there is no ABTS Frame Payload)
-*/

    return sizeof(FCHS_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_ABTS_Response_OnCard(
                                            SFThread_t *SFThread,
                                            os_bit32       Frame_Length,
                                            os_bit32       Offset_to_FCHS,
                                            os_bit32       Offset_to_Payload,
                                            os_bit32       Payload_Wrap_Offset,
                                            os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_ABTS_Response_OffCard(
                                             SFThread_t          *SFThread,
                                             os_bit32             Frame_Length,
                                             FCHS_t              *FCHS,
                                             FC_BA_ACC_Payload_t *Payload,
                                             os_bit32             Payload_Wrap_Offset,
                                             FC_BA_ACC_Payload_t *Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_On_Card__

    os_bit32           * RawPayLoad    = (os_bit32 *)Payload;

    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                      LinkSvcLog_ERROR_Level,
                      "%s %p %08X %08X %08X",
                      "ABTS_Response",(char *)agNULL,
                      RawPayLoad,(void *)agNULL,
                      hpSwapBit32( *RawPayLoad ),
                      hpSwapBit32(*(RawPayLoad+1)),
                      hpSwapBit32(*(RawPayLoad+2)),
                      0,0,0,0,0 );


#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInBA_RJT(
                      SFThread_t *SFThread,
                      os_bit32       D_ID,
                      os_bit32       OX_ID__RX_ID,
                      os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                    )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInBA_RJT_OnCard(
                                      SFThread,
                                      D_ID,
                                      OX_ID__RX_ID,
                                      Reason_Code__Reason_Explanation__Vendor_Unique
                                    );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInBA_RJT_OffCard(
                                       SFThread,
                                       D_ID,
                                       OX_ID__RX_ID,
                                       Reason_Code__Reason_Explanation__Vendor_Unique
                                     );
    }
}

os_bit32 fiFillInBA_RJT_OnCard(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID__RX_ID,
                             os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread               = CThread_ptr(hpRoot);
    os_bit32        S_ID = 0;
    os_bit32        BA_RJT_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        BA_RJT_Payload_Offset = BA_RJT_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_BA_RJT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

/*+
Fill in BA_RJT Frame Header
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               MBZ1
                                                             ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                             ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               R_CTL__D_ID
                                                             ),
                         (  FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame
                          | FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT
                          | D_ID                                           )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               CS_CTL__S_ID
                                                             ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               TYPE__F_CTL
                                                             ),
                         (  FC_Frame_Header_TYPE_BLS
                          | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                          | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                          | FC_Frame_Header_F_CTL_Last_Sequence
                          | FC_Frame_Header_F_CTL_End_Sequence)
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               SEQ_ID__DF_CTL__SEQ_CNT
                                                             ),
                         FC_Frame_Header_DF_CTL_No_Device_Header
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               OX_ID__RX_ID
                                                             ),
                         OX_ID__RX_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Header_Offset + hpFieldOffset(
                                                               FCHS_t,
                                                               RO
                                                             ),
                         0
                       );

/*+
Fill in BA_RJT Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         BA_RJT_Payload_Offset + hpFieldOffset(
                                                                FC_BA_RJT_Payload_t,
                                                                Reserved__Reason_Code__Reason_Explanation__Vendor_Unique
                                                              ),
                         hpSwapBit32( Reason_Code__Reason_Explanation__Vendor_Unique )
                       );

/*+
Return length of BA_RJT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_BA_RJT_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInBA_RJT_OffCard(
                              SFThread_t *SFThread,
                              os_bit32       D_ID,
                              os_bit32       OX_ID__RX_ID,
                              os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                            )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    agRoot_t            *hpRoot         = SFThread->thread_hdr.hpRoot;
    CThread_t           *CThread        = CThread_ptr(hpRoot);
    os_bit32                S_ID = 0;
    FCHS_t              *BA_RJT_Header  = SFThread->SF_CMND_Ptr;
    FC_BA_RJT_Payload_t *BA_RJT_Payload = (FC_BA_RJT_Payload_t *)((os_bit8 *)BA_RJT_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_BA_RJT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;


    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;



/*+
Fill in BA_RJT Frame Header
-*/

    BA_RJT_Header->MBZ1                                        = 0;
    BA_RJT_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                                  | FCHS_EOF_EOFn
                                                                  | FCHS_CLS;
    BA_RJT_Header->R_CTL__D_ID                                 =   FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame
                                                                  | FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT
                                                                  | D_ID;
    BA_RJT_Header->CS_CTL__S_ID                                = S_ID;
    BA_RJT_Header->TYPE__F_CTL                                 =   FC_Frame_Header_TYPE_BLS
                                                                  | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                                                  | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                                  | FC_Frame_Header_F_CTL_Last_Sequence
                                                                  | FC_Frame_Header_F_CTL_End_Sequence
                                                                  ;
    BA_RJT_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    BA_RJT_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    BA_RJT_Header->RO                                          = 0;

/*+
Fill in BA_RJT Frame Payload
-*/

    BA_RJT_Payload->Reserved__Reason_Code__Reason_Explanation__Vendor_Unique
        = hpSwapBit32( Reason_Code__Reason_Explanation__Vendor_Unique );

/*+
Return length of BA_RJT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_BA_RJT_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiFillInELSFrameHeader_OnCard(
                                    SFThread_t *SFThread,
                                    os_bit32       D_ID,
                                    os_bit32       X_ID,
                                    os_bit32       F_CTL_Exchange_Context
                                  )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t  *hpRoot            = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread           = CThread_ptr(hpRoot);
    os_bit32      ELS_Header_Offset = SFThread->SF_CMND_Offset;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID = 0;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;



    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_ELS
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Solicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_ELS
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            MBZ1
                                                          ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                          ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            R_CTL__D_ID
                                                          ),
                         R_CTL__D_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            CS_CTL__S_ID
                                                          ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            TYPE__F_CTL
                                                          ),
                         TYPE__F_CTL
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SEQ_ID__DF_CTL__SEQ_CNT
                                                          ),
                         FC_Frame_Header_DF_CTL_No_Device_Header
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            OX_ID__RX_ID
                                                          ),
                         OX_ID__RX_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            RO
                                                          ),
                         0
                       );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiFillInELSFrameHeader_OffCard(
                                     SFThread_t *SFThread,
                                     os_bit32       D_ID,
                                     os_bit32       X_ID,
                                     os_bit32       F_CTL_Exchange_Context
                                   )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t  *hpRoot       = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread      = CThread_ptr(hpRoot);
    FCHS_t    *ELS_Header   = SFThread->SF_CMND_Ptr;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID =0;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    S_ID = fiComputeCThread_S_ID(CThread);

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_ELS
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Solicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_ELS
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    ELS_Header->MBZ1                                        = 0;
    ELS_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                               | FCHS_EOF_EOFn
                                                               | FCHS_CLS;
    ELS_Header->R_CTL__D_ID                                 = R_CTL__D_ID;
    ELS_Header->CS_CTL__S_ID                                = S_ID;
    ELS_Header->TYPE__F_CTL                                 = TYPE__F_CTL;
    ELS_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    ELS_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    ELS_Header->RO                                          = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInLS_RJT(
                      SFThread_t *SFThread,
                      os_bit32       D_ID,
                      os_bit32       OX_ID,
                      os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                    )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInLS_RJT_OnCard(
                                      SFThread,
                                      D_ID,
                                      OX_ID,
                                      Reason_Code__Reason_Explanation__Vendor_Unique
                                    );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInLS_RJT_OffCard(
                                       SFThread,
                                       D_ID,
                                       OX_ID,
                                       Reason_Code__Reason_Explanation__Vendor_Unique
                                     );
    }
}

os_bit32 fiFillInLS_RJT_OnCard(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID,
                             os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                = SFThread->thread_hdr.hpRoot;
    os_bit32        LS_RJT_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        LS_RJT_Payload_Offset = LS_RJT_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_LS_RJT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in LS_RJT Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );

/*+
Fill in LS_RJT Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         LS_RJT_Payload_Offset + hpFieldOffset(
                                                                FC_ELS_LS_RJT_Payload_t,
                                                                ELS_Type
                                                              ),
                         hpSwapBit32( FC_ELS_Type_LS_RJT )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         LS_RJT_Payload_Offset + hpFieldOffset(
                                                                FC_ELS_LS_RJT_Payload_t,
                                                                Reason_Code__Reason_Explanation__Vendor_Unique
                                                              ),
                         hpSwapBit32( Reason_Code__Reason_Explanation__Vendor_Unique )
                       );

/*+
Return length of LS_RJT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_LS_RJT_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInLS_RJT_OffCard(
                              SFThread_t *SFThread,
                              os_bit32       D_ID,
                              os_bit32       OX_ID,
                              os_bit32       Reason_Code__Reason_Explanation__Vendor_Unique
                            )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    FCHS_t                  *LS_RJT_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_LS_RJT_Payload_t *LS_RJT_Payload = (FC_ELS_LS_RJT_Payload_t *)((os_bit8 *)LS_RJT_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_LS_RJT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in LS_RJT Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                  );

/*+
Fill in LS_RJT Frame Payload
-*/

    LS_RJT_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_LS_RJT );

    LS_RJT_Payload->Reason_Code__Reason_Explanation__Vendor_Unique
        = hpSwapBit32( Reason_Code__Reason_Explanation__Vendor_Unique );

/*+
Return length of LS_RJT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_LS_RJT_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInPLOGI(
                     SFThread_t *SFThread
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPLOGI_OnCard(
                                     SFThread
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPLOGI_OffCard(
                                      SFThread
                                    );
    }
}

os_bit32 fiFillInPLOGI_OnCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t               *hpRoot                  = SFThread->thread_hdr.hpRoot;
    CThread_t              *CThread                 = CThread_ptr(hpRoot);
    DevThread_t            *DevThread               = SFThread->parent.Device;
    os_bit32                   PLOGI_Header_Offset     = SFThread->SF_CMND_Offset;
    os_bit32                   PLOGI_Payload_Offset    = PLOGI_Header_Offset + sizeof(FCHS_t);
    FC_ELS_PLOGI_Payload_t *PLOGI_Payload_Dummy_Ptr = (FC_ELS_PLOGI_Payload_t *)agNULL;
    os_bit32                   Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PLOGI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    DevThread->DevInfo.Present    = agFALSE;
    DevThread->DevInfo.LoggedIn   = agFALSE;
    DevThread->DevInfo.DeviceType = agDevUnknown;

/*+
Fill in PLOGI Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in PLOGI Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               ELS_Type
                                                             ),
                         hpSwapBit32( FC_ELS_Type_PLOGI )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Common_Service_Parameters.E_D_TOV
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_PLOGI_Payload_t,
                                                                  N_Port_Name[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_PLOGI_Payload_t,
                                                                  Node_Name[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_PLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(PLOGI_Payload_Dummy_Ptr->Reserved);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_PLOGI_Payload_t,
                                                                  Reserved[Bit8_Index]
                                                                ),
                            0
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_PLOGI_Payload_t,
                                                                  Vendor_Version_Level[Bit8_Index]
                                                                ),
                            0
                          );
    }

/*+
Return length of PLOGI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_PLOGI_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPLOGI_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t              *CThread       = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t            *DevThread     = SFThread->parent.Device;
    FCHS_t                 *PLOGI_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_PLOGI_Payload_t *PLOGI_Payload = (FC_ELS_PLOGI_Payload_t *)((os_bit8 *)PLOGI_Header + sizeof(FCHS_t));
    os_bit32                Bit8_Index;
    os_bit32              * Payload       = (os_bit32 *)PLOGI_Payload;


    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PLOGI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    DevThread->DevInfo.Present    = agFALSE;
    DevThread->DevInfo.LoggedIn   = agFALSE;
    DevThread->DevInfo.DeviceType = agDevUnknown;

/*+
Fill in PLOGI Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in PLOGI Frame Payload
-*/

    PLOGI_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_PLOGI );
    PLOGI_Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit );

    PLOGI_Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size );

    PLOGI_Payload->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category );

    PLOGI_Payload->Common_Service_Parameters.E_D_TOV
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        PLOGI_Payload->N_Port_Name[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        PLOGI_Payload->Node_Name[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }

    PLOGI_Payload->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_Payload->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_Payload->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_Payload->Class_1_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange );

    PLOGI_Payload->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_Payload->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_Payload->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_Payload->Class_2_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange );

    PLOGI_Payload->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_Payload->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_Payload->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_Payload->Class_3_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(PLOGI_Payload->Reserved);
         Bit8_Index++)
    {
        PLOGI_Payload->Reserved[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        PLOGI_Payload->Vendor_Version_Level[Bit8_Index] = 0;
    }


    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload   %X ",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                sizeof(FC_ELS_PLOGI_Payload_t),
                0,0,0,0,0,0,0 );


    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload   0 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+0)),
                hpSwapBit32(*(Payload+1)),
                hpSwapBit32(*(Payload+2)),
                hpSwapBit32(*(Payload+3)),
                hpSwapBit32(*(Payload+4)),
                hpSwapBit32(*(Payload+5)),
                hpSwapBit32(*(Payload+6)),
                hpSwapBit32(*(Payload+7)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload   8 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+8)),
                hpSwapBit32(*(Payload+9)),
                hpSwapBit32(*(Payload+10)),
                hpSwapBit32(*(Payload+11)),
                hpSwapBit32(*(Payload+12)),
                hpSwapBit32(*(Payload+13)),
                hpSwapBit32(*(Payload+14)),
                hpSwapBit32(*(Payload+15)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload  16 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+16)),
                hpSwapBit32(*(Payload+17)),
                hpSwapBit32(*(Payload+18)),
                hpSwapBit32(*(Payload+19)),
                hpSwapBit32(*(Payload+20)),
                hpSwapBit32(*(Payload+21)),
                hpSwapBit32(*(Payload+22)),
                hpSwapBit32(*(Payload+23)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload  24 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+24)),
                hpSwapBit32(*(Payload+25)),
                hpSwapBit32(*(Payload+26)),
                hpSwapBit32(*(Payload+27)),
                hpSwapBit32(*(Payload+28)),
                hpSwapBit32(*(Payload+29)),
                hpSwapBit32(*(Payload+30)),
                hpSwapBit32(*(Payload+31)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload  32 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+32)),
                hpSwapBit32(*(Payload+33)),
                hpSwapBit32(*(Payload+34)),
                hpSwapBit32(*(Payload+35)),
                hpSwapBit32(*(Payload+36)),
                hpSwapBit32(*(Payload+37)),
                hpSwapBit32(*(Payload+38)),
                hpSwapBit32(*(Payload+39)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsolePLOGIPAYLOAD,
                "Plogi Payload  40 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+40)),
                hpSwapBit32(*(Payload+41)),
                hpSwapBit32(*(Payload+42)),
                hpSwapBit32(*(Payload+43)),
                hpSwapBit32(*(Payload+44)),
                hpSwapBit32(*(Payload+45)),
                hpSwapBit32(*(Payload+46)),
                hpSwapBit32(*(Payload+47)) );

/*+
Return length of PLOGI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_PLOGI_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

#ifdef _DvrArch_1_30_
os_bit32 fiFillInFARP_REQ_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                 *CThread       = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t               *DevThread     = SFThread->parent.Device;
    FCHS_t                    *FARP_REQ_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_FARP_REQ_Payload_t *FARP_REQ_Payload = (FC_ELS_FARP_REQ_Payload_t *)((os_bit8 *)FARP_REQ_Header + sizeof(FCHS_t));
    os_bit32                   Bit8_Index;
    os_bit32                   S_ID = 0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_FARP_REQ;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    DevThread->DevInfo.Present    = agFALSE;
    DevThread->DevInfo.LoggedIn   = agFALSE;
    DevThread->DevInfo.DeviceType = agDevUnknown;

/*+
Fill in FARP_REQ Frame Header
-*/
    S_ID = fiComputeCThread_S_ID( CThread );
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    /* (S_ID > 0xff ? FC_Well_Known_Port_ID_Broadcast_Alias_ID : 0xff), */
				    S_ID,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in FARP_REQ Frame Payload
-*/

    FARP_REQ_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_FARP_REQ );

    FARP_REQ_Payload->Match_Code_Requester_Port_ID =  hpSwapBit32( S_ID |
            FC_ELS_FARP_REQ_Match_Code_Points_Match_WW_PN << FC_ELS_FARP_REQ_Match_Code_Points_SHIFT);

    FARP_REQ_Payload->Flags_Responder_Port_ID = hpSwapBit32(
            (FC_ELS_FARP_REQ_Responder_Flags_Init_Plogi |
            FC_ELS_FARP_REQ_Responder_Flags_Init_Reply) << FC_ELS_FARP_REQ_Responder_Flags_SHIFT);

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        FARP_REQ_Payload->Port_Name_of_Requester[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
        FARP_REQ_Payload->Port_Name_of_Responder[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        FARP_REQ_Payload->Node_Name_of_Requester[Bit8_Index] = 0;
        FARP_REQ_Payload->Node_Name_of_Responder[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < 16;
         Bit8_Index++)
    {
        FARP_REQ_Payload->IP_Address_of_Requester[Bit8_Index] = 0;
        FARP_REQ_Payload->IP_Address_of_Responder[Bit8_Index] = 0;
    }

/*+
Return length of FARP_REQ Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_FARP_REQ_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiFillInFARP_REPLY_OffCard(
                                     SFThread_t *SFThread
                                   )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread         = CThread_ptr(SFThread->thread_hdr.hpRoot);
    TgtThread_t                *TgtThread       = SFThread->parent.Target;
    FCHS_t                     *TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
    FC_ELS_FARP_REQ_Payload_t  *TgtCmnd_Payload = (FC_ELS_FARP_REQ_Payload_t *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));
    FCHS_t                     *REPLY_Header    = SFThread->SF_CMND_Ptr;
    FC_ELS_FARP_REPLY_Payload_t *REPLY_Payload  = (FC_ELS_FARP_REPLY_Payload_t *)((os_bit8 *)REPLY_Header + sizeof(FCHS_t));
    os_bit32                    Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_FARP_REPLY;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in FARP_REPLY Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    TgtCmnd_FCHS->CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK,
                                    (TgtCmnd_FCHS->OX_ID__RX_ID & FC_Frame_Header_OX_ID_MASK)
				            >> FC_Frame_Header_OX_ID_SHIFT,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder |
                                    FC_Frame_Header_F_CTL_Last_Sequence
                                  );

/*+
Fill in FARP_REPLY Frame Payload
-*/

    REPLY_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_FARP_REPLY );

    REPLY_Payload->Match_Code_Requester_Port_ID = TgtCmnd_Payload->Match_Code_Requester_Port_ID;

    REPLY_Payload->Flags_Responder_Port_ID =   TgtCmnd_Payload->Flags_Responder_Port_ID
	                                          & FC_ELS_FARP_REQ_Responder_Flags_MASK
                                                  | hpSwapBit32(fiComputeCThread_S_ID(CThread));
    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        REPLY_Payload->Port_Name_of_Requester[Bit8_Index] = TgtCmnd_Payload->Port_Name_of_Requester[Bit8_Index];
        REPLY_Payload->Port_Name_of_Responder[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        REPLY_Payload->Node_Name_of_Requester[Bit8_Index] = 0;
        REPLY_Payload->Node_Name_of_Responder[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < 16;
         Bit8_Index++)
    {
        REPLY_Payload->IP_Address_of_Requester[Bit8_Index] = 0;
        REPLY_Payload->IP_Address_of_Responder[Bit8_Index] = 0;
    }
/*+
Return length of FARP_REPLY Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_FARP_REPLY_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}
#endif /* _DvrArch_1_30_ was defined */

void fiLinkSvcProcess_PLOGI_Response_OnCard(
                                             SFThread_t *SFThread,
                                             os_bit32       Frame_Length,
                                             os_bit32       Offset_to_FCHS,
                                             os_bit32       Offset_to_Payload,
                                             os_bit32       Payload_Wrap_Offset,
                                             os_bit32       Offset_to_Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t      *hpRoot     = SFThread->thread_hdr.hpRoot;
    agFCDevInfo_t *DevInfo    = &(SFThread->parent.Device->DevInfo);
    os_bit32          Bit8_Index;

    DevInfo->Present = agTRUE;

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.E_D_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.E_D_TOV
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.E_D_TOV
                                                               ) )
                                            ));
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,N_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->PortWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_PLOGI_Payload_t,
                                                                        N_Port_Name[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            DevInfo->PortWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_PLOGI_Payload_t,
                                                                                N_Port_Name[Bit8_Index]
                                                                              )
                                   );
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Node_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->NodeWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_PLOGI_Payload_t,
                                                                        Node_Name[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            DevInfo->NodeWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_PLOGI_Payload_t,
                                                                                Node_Name[Bit8_Index]
                                                                              )
                                   );
        }
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                               ) )
                                            ));
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_PLOGI_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                       Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_ELS_ACC_PLOGI_Payload_t *Payload,
                                              os_bit32                       Payload_Wrap_Offset,
                                              FC_ELS_ACC_PLOGI_Payload_t *Payload_Wrapped
                                            )
{
#ifndef __MemMap_Force_On_Card__
    agFCDevInfo_t *DevInfo    = &(SFThread->parent.Device->DevInfo);
    os_bit32          Bit8_Index;

    DevInfo->Present = agTRUE;

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
            = hpSwapBit32(Payload->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.E_D_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(Payload->Common_Service_Parameters.E_D_TOV);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.E_D_TOV);
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,N_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->PortWWN[Bit8_Index] = Payload->N_Port_Name[Bit8_Index];
        }
        else
        {
            DevInfo->PortWWN[Bit8_Index] = Payload_Wrapped->N_Port_Name[Bit8_Index];
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Node_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->NodeWWN[Bit8_Index] = Payload->Node_Name[Bit8_Index];
        }
        else
        {
            DevInfo->NodeWWN[Bit8_Index] = Payload_Wrapped->Node_Name[Bit8_Index];
        }
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_1_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_1_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Open_Sequences_per_Exchange);
    }
    else
    {
        DevInfo->N_Port_Class_1_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Open_Sequences_per_Exchange);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }
#ifdef __TACHYON_XL_CLASS2

        /* Channel Info sets the validity bits based on the FLOGI with the fabric. We need to make sure the device or the fabric does FLOGI */
        if (CThread->FlogiSucceeded)
        {
            DevThread->GoingClass2 = 
                (DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags & FC_N_Port_Class_Parms_Class_Validity &&
                 CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags & FC_F_Port_Class_Parms_Class_Validity) 
                                    ? agTRUE : agFALSE; 
        }
        else
        {
            DevThread->GoingClass2 =
                (DevInfo->N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags & FC_N_Port_Class_Parms_Class_Validity) 
                                    ? agTRUE : agFALSE; 
                
        } 
#endif

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_2_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_2_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Open_Sequences_per_Exchange);
    }
    else
    {
        DevInfo->N_Port_Class_2_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Open_Sequences_per_Exchange);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Class_3_Service_Parameters.Open_Sequences_per_Exchange)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Open_Sequences_per_Exchange);
    }
    else
    {
        DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Open_Sequences_per_Exchange);
    }

    SFThread->parent.Device->OtherAgilentHBA = agFALSE;

    if( Payload->N_Port_Name[0] == fiFlash_Card_WWN_0)
    { 
        if( Payload->N_Port_Name[1] == fiFlash_Card_WWN_1_HP)
        { 
            if( Payload->N_Port_Name[2] == fiFlash_Card_WWN_2_HP)
            { 
                if( Payload->N_Port_Name[3] == fiFlash_Card_WWN_3_HP)
                { 
                    SFThread->parent.Device->OtherAgilentHBA = agTRUE;
                }
            }
        }
        if( Payload->N_Port_Name[1] == fiFlash_Card_WWN_1_Agilent)
        { 
            if( Payload->N_Port_Name[2] == fiFlash_Card_WWN_2_Agilent)
            { 
                if( Payload->N_Port_Name[3] == fiFlash_Card_WWN_2_Agilent)
                { 
                    SFThread->parent.Device->OtherAgilentHBA = agTRUE;
                }
            }
        }

        if( Payload->N_Port_Name[1] == fiFlash_Card_WWN_1_Adaptec)
        { 
            if( Payload->N_Port_Name[2] == fiFlash_Card_WWN_2_Adaptec)
            { 
                if( Payload->N_Port_Name[3] == fiFlash_Card_WWN_3_Adaptec)
                { 
                    SFThread->parent.Device->OtherAgilentHBA = agTRUE;
                }
            }
        }
    }

    if( SFThread->parent.Device->OtherAgilentHBA )
    {
        fiLogString(SFThread->thread_hdr.hpRoot,
                        "%s Found %X",
                        "OtherAgilentHBA",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(SFThread->parent.Device),
                        0,0,0,0,0,0,0);
/*
        fiLogString(SFThread->thread_hdr.hpRoot,
                        "%s %02X %02X %02X %02X %02X %02X %02X %02X",
                        "Self",(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[0]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[1]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[2]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[3]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[4]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[5]), 
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[6]),
                        (os_bit32)(CThread_ptr(SFThread->thread_hdr.hpRoot)->DeviceSelf->DevInfo.PortWWN[7])
                        );
*/
        fiLogString(SFThread->thread_hdr.hpRoot,
                        "%s %02X %02X %02X %02X %02X %02X %02X %02X",
                        "Pay ",(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        (os_bit32)Payload->N_Port_Name[0], 
                        (os_bit32)Payload->N_Port_Name[1], 
                        (os_bit32)Payload->N_Port_Name[2], 
                        (os_bit32)Payload->N_Port_Name[3], 
                        (os_bit32)Payload->N_Port_Name[4], 
                        (os_bit32)Payload->N_Port_Name[5], 
                        (os_bit32)Payload->N_Port_Name[6], 
                        (os_bit32)Payload->N_Port_Name[7] 
                        );

    }

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Plogi Response Credit %08X BB %08X N %08X EDTOV %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit,
                DevInfo->N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size,
                DevInfo->N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category,
                DevInfo->N_Port_Common_Parms.E_D_TOV,
                0,0,0,0 );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Response Credit %08X BB %08X N %08X EDTOV %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Common_Parms.E_D_TOV,
                0,0,0,0 );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Plogi Response Class 3  %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                DevInfo->N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags,
                DevInfo->N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size,
                DevInfo->N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit,
                DevInfo->N_Port_Class_3_Parms.Open_Sequences_per_Exchange,
                0,0,0,0 );
 
    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Response Class 3  %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit,
                CThread_ptr(SFThread->thread_hdr.hpRoot)->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange,
                0,0,0,0 );


#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiLinkSvcProcess_PLOGI_Request_OnCard(
                                             agRoot_t  *hpRoot,
                                             X_ID_t     OX_ID,
                                             os_bit32      Frame_Length,
                                             os_bit32      Offset_to_FCHS,
                                             os_bit32      Offset_to_Payload,
                                             os_bit32      Payload_Wrap_Offset,
                                             os_bit32      Offset_to_Payload_Wrapped,
                                             fi_thread__t **Thread_to_return
                                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                       SFThread_X_ID_Offset      = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                       SFThread_X_ID_Max         = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    os_bit32                       D_ID;
    os_bit32                       S_ID;
    os_bit32                       Bit8_Index;

    D_ID = (osCardRamReadBit32(
                                hpRoot,
                                Offset_to_FCHS + hpFieldOffset(
                                                                FCHS_t,
                                                                R_CTL__D_ID
                                                              )
                              ) & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;

    S_ID = (osCardRamReadBit32(
                                hpRoot,
                                Offset_to_FCHS + hpFieldOffset(
                                                                FCHS_t,
                                                                CS_CTL__S_ID
                                                              )
                              ) & FCHS_S_ID_MASK) >> FCHS_S_ID_SHIFT;

    if (D_ID != S_ID)
    {
        /* Some other port is trying to PLOGI into us */

        *Thread_to_return = (fi_thread__t *)agNULL;

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvc_Cmd_Status_PLOGI_From_Other [S_ID = %06X] [D_ID = %06X]",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          S_ID,
                          D_ID,
                          0,0,0,0,0,0
                        );

        fiLinkSvcProcess_TargetRequest_OnCard(
                                               hpRoot,
                                               Frame_Length,
                                               Offset_to_FCHS,
                                               Offset_to_Payload,
                                               Payload_Wrap_Offset,
                                               Offset_to_Payload_Wrapped
                                             );

        return fiLinkSvc_Cmd_Status_PLOGI_From_Other;
    }

    /* Some port with our Port_ID is trying to PLOGI into us - is it us? */

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_PLOGI_Payload_t,N_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index]
                    != osCardRamReadBit8(
                                          hpRoot,
                                          Offset_to_Payload + hpFieldOffset(
                                                                             FC_ELS_PLOGI_Payload_t,
                                                                             N_Port_Name[Bit8_Index]
                                                                           )
                                        ))
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_PLOGI_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_PLOGI_From_Twin;
            }
        }
        else
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index]
                    != osCardRamReadBit8(
                                          hpRoot,
                                          Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                     FC_ELS_PLOGI_Payload_t,
                                                                                     N_Port_Name[Bit8_Index]
                                                                                   )
                                        ))
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_PLOGI_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_PLOGI_From_Twin;
            }
        }
    }

    /* PortWWN's matched, so this must be our own PLOGI attempt into ourself */

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_PLOGI_Request_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLogConsoleLevel,
                      "fiLinkSvc_Cmd_Status_PLOGI_From_Self",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    *Thread_to_return = (fi_thread__t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                     + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    return fiLinkSvc_Cmd_Status_PLOGI_From_Self;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiLinkSvcProcess_PLOGI_Request_OffCard(
                                              agRoot_t                *hpRoot,
                                              X_ID_t                   OX_ID,
                                              os_bit32                    Frame_Length,
                                              FCHS_t                  *FCHS,
                                              FC_ELS_PLOGI_Payload_t  *Payload,
                                              os_bit32                    Payload_Wrap_Offset,
                                              FC_ELS_PLOGI_Payload_t  *Payload_Wrapped,
                                              fi_thread__t               **Thread_to_return
                                            )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                       SFThread_X_ID_Offset      = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                       SFThread_X_ID_Max         = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    os_bit32                       D_ID                      = (FCHS->R_CTL__D_ID & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;
    os_bit32                       S_ID                      = (FCHS->CS_CTL__S_ID & FCHS_S_ID_MASK) >> FCHS_S_ID_SHIFT;
    os_bit32                       Bit8_Index;

    if (D_ID != S_ID)
    {
        /* Some other port is trying to PLOGI into us */

        *Thread_to_return = (fi_thread__t *)agNULL;

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvc_Cmd_Status_PLOGI_From_Other S_ID = %06X D_ID = %06X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          S_ID,
                          D_ID,
                          0,0,0,0,0,0
                        );

        fiLinkSvcProcess_TargetRequest_OffCard(
                                                hpRoot,
                                                Frame_Length,
                                                FCHS,
                                                (void *)Payload,
                                                Payload_Wrap_Offset,
                                                (void *)Payload_Wrapped
                                              );

        return fiLinkSvc_Cmd_Status_PLOGI_From_Other;
    }

    /* Some port with our Port_ID is trying to PLOGI into us - is it us? */

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_PLOGI_Payload_t,N_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index] != Payload->N_Port_Name[Bit8_Index])
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_PLOGI_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_PLOGI_From_Twin;
            }
        }
        else
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index] != Payload_Wrapped->N_Port_Name[Bit8_Index])
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_PLOGI_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_PLOGI_From_Twin;
            }
        }
    }

    /* PortWWN's matched, so this must be our own PLOGI attempt into ourself */

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvcProcess_PLOGI_Request_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLogConsoleLevel + 0xb,
                      "fiLinkSvc_Cmd_Status_PLOGI_From_Self",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    *Thread_to_return = (fi_thread__t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                     + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    return fiLinkSvc_Cmd_Status_PLOGI_From_Self;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

#ifdef _DvrArch_1_30_
os_bit32 fiLinkSvcProcess_FARP_Request_OffCard(
                                                agRoot_t                    *hpRoot,
                                                X_ID_t                       OX_ID,
                                                os_bit32                     Frame_Length,
                                                FCHS_t                      *FCHS,
                                                FC_ELS_FARP_REQ_Payload_t   *Payload,
                                                os_bit32                     Payload_Wrap_Offset,
                                                FC_ELS_FARP_REQ_Payload_t   *Payload_Wrapped,
                                                fi_thread__t               **Thread_to_return
                                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset      = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                    SFThread_X_ID_Max         = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    os_bit32                    S_ID                      = (FCHS->CS_CTL__S_ID & FCHS_S_ID_MASK) >> FCHS_S_ID_SHIFT;
    os_bit32                    D_ID                      = (FCHS->R_CTL__D_ID & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;
    os_bit32                    Bit8_Index;

    if (S_ID != (os_bit32) fiComputeCThread_S_ID(CThread))
    {
        /* Some other port is trying to FARP to us */

        *Thread_to_return = (fi_thread__t *)agNULL;

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvc_Cmd_Status_FARP_From_Other S_ID = %06X D_ID = %06X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          S_ID,
                          D_ID,
                          0,0,0,0,0,0
                        );

        fiLinkSvcProcess_TargetRequest_OffCard(
                                                hpRoot,
                                                Frame_Length,
                                                FCHS,
                                                (void *)Payload,
                                                Payload_Wrap_Offset,
                                                (void *)Payload_Wrapped
                                              );

        return fiLinkSvc_Cmd_Status_FARP_From_Other;
    }

    /* Some port with our Port_ID is trying to FARP to us - is it us? */

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_FARP_REQ_Payload_t,Port_Name_of_Requester[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index] != Payload->Port_Name_of_Requester[Bit8_Index])
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_FARP_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_FARP_From_Twin;
            }
        }
        else
        {
            if (CThread->ChanInfo.PortWWN[Bit8_Index] != Payload_Wrapped->Port_Name_of_Requester[Bit8_Index])
            {
                *Thread_to_return = (fi_thread__t *)agNULL;

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLog_ERROR_Level,
                                  "fiLinkSvc_Cmd_Status_FARP_From_Twin",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_FARP_From_Twin;
            }
        }
    }

    /* PortWWN's matched, so this must be our own FARP attempt to ourselves */

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "fiLinkSvcProcess_FARP_Request_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLogConsoleLevel + 0xb,
                      "fiLinkSvc_Cmd_Status_FARP_From_Self",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    *Thread_to_return = (fi_thread__t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                     + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    return fiLinkSvc_Cmd_Status_FARP_From_Self;
#endif /* __MemMap_Force_On_Card__ was not defined */
}
#endif /* _DvrArch_1_30_ was defined */

os_bit32 fiFillInPLOGI_ACC(
                         SFThread_t *SFThread,
                         os_bit32       D_ID,
                         os_bit32       OX_ID
                       )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPLOGI_ACC_OnCard(
                                         SFThread,
                                         D_ID,
                                         OX_ID
                                       );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPLOGI_ACC_OffCard(
                                          SFThread,
                                          D_ID,
                                          OX_ID
                                        );
    }
}

os_bit32 fiFillInPLOGI_ACC_OnCard(
                                SFThread_t *SFThread,
                                os_bit32       D_ID,
                                os_bit32       OX_ID
                              )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t                   *hpRoot                      = SFThread->thread_hdr.hpRoot;
    CThread_t                  *CThread                     = CThread_ptr(hpRoot);
    os_bit32                    PLOGI_ACC_Header_Offset     = SFThread->SF_CMND_Offset;
    os_bit32                    PLOGI_ACC_Payload_Offset    = PLOGI_ACC_Header_Offset + sizeof(FCHS_t);
    FC_ELS_ACC_PLOGI_Payload_t *PLOGI_ACC_Payload_Dummy_Ptr = (FC_ELS_ACC_PLOGI_Payload_t *)agNULL;
    os_bit32                    Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in PLOGI_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );

/*+
Fill in PLOGI_ACC Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   ELS_Type
                                                                 ),
                         hpSwapBit32( FC_ELS_Type_ACC )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Common_Service_Parameters.E_D_TOV
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                      FC_ELS_ACC_PLOGI_Payload_t,
                                                                      N_Port_Name[Bit8_Index]
                                                                    ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                      FC_ELS_ACC_PLOGI_Payload_t,
                                                                      Node_Name[Bit8_Index]
                                                                    ),
                            CThread->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_ACC_PLOGI_Payload_t,
                                                                   Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                                 ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(PLOGI_ACC_Payload_Dummy_Ptr->Reserved);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                      FC_ELS_ACC_PLOGI_Payload_t,
                                                                      Reserved[Bit8_Index]
                                                                    ),
                            0
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            PLOGI_ACC_Payload_Offset + hpFieldOffset(
                                                                      FC_ELS_ACC_PLOGI_Payload_t,
                                                                      Vendor_Version_Level[Bit8_Index]
                                                                    ),
                            0
                          );
    }

/*+
Return length of PLOGI_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ACC_PLOGI_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPLOGI_ACC_OffCard(
                                 SFThread_t *SFThread,
                                 os_bit32       D_ID,
                                 os_bit32       OX_ID
                               )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread           = CThread_ptr(SFThread->thread_hdr.hpRoot);
    FCHS_t                     *PLOGI_ACC_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_ACC_PLOGI_Payload_t *PLOGI_ACC_Payload = (FC_ELS_ACC_PLOGI_Payload_t *)((os_bit8 *)PLOGI_ACC_Header + sizeof(FCHS_t));
    os_bit32                       Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in PLOGI_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder |
                                    FC_Frame_Header_F_CTL_Last_Sequence
                                  );

/*+
Fill in PLOGI_ACC Frame Payload
-*/

    PLOGI_ACC_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_ACC );

    PLOGI_ACC_Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit );

    PLOGI_ACC_Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size );

    PLOGI_ACC_Payload->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category );

    PLOGI_ACC_Payload->Common_Service_Parameters.E_D_TOV
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        PLOGI_ACC_Payload->N_Port_Name[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        PLOGI_ACC_Payload->Node_Name[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }

    PLOGI_ACC_Payload->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_ACC_Payload->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_ACC_Payload->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_ACC_Payload->Class_1_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange );

    PLOGI_ACC_Payload->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_ACC_Payload->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_ACC_Payload->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_ACC_Payload->Class_2_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange );

    PLOGI_ACC_Payload->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    PLOGI_ACC_Payload->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size );

    PLOGI_ACC_Payload->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit );

    PLOGI_ACC_Payload->Class_3_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(PLOGI_ACC_Payload->Reserved);
         Bit8_Index++)
    {
        PLOGI_ACC_Payload->Reserved[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        PLOGI_ACC_Payload->Vendor_Version_Level[Bit8_Index] = 0;
    }

/*+
Return length of PLOGI_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ACC_PLOGI_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInFLOGI(
                     SFThread_t *SFThread
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInFLOGI_OnCard(
                                     SFThread
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInFLOGI_OffCard(
                                      SFThread
                                    );
    }
}

os_bit32 fiFillInFLOGI_OnCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t               *hpRoot                  = SFThread->thread_hdr.hpRoot;
    CThread_t              *CThread                 = CThread_ptr(hpRoot);
    os_bit32                   FLOGI_Header_Offset     = SFThread->SF_CMND_Offset;
    os_bit32                   FLOGI_Payload_Offset    = FLOGI_Header_Offset + sizeof(FCHS_t);
    FC_ELS_FLOGI_Payload_t *FLOGI_Payload_Dummy_Ptr = (FC_ELS_FLOGI_Payload_t *)agNULL;
    os_bit32                   Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_FLOGI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in FLOGI Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   FC_Well_Known_Port_ID_Fabric_F_Port,
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in FLOGI Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               ELS_Type
                                                             ),
                         hpSwapBit32( FC_ELS_Type_FLOGI )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category )
                       );

    /*McData switch enforces the parameter - reserved for NPORT */
    if(CThread->InitAsNport)
    {
        osCardRamWriteBit32(
                             hpRoot,
                             FLOGI_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_FLOGI_Payload_t,
                                                                   Common_Service_Parameters.E_D_TOV
                                                                 ),
                             0
                           );
    }
    else
    {
        osCardRamWriteBit32(
                             hpRoot,
                             FLOGI_Payload_Offset + hpFieldOffset(
                                                                   FC_ELS_FLOGI_Payload_t,
                                                                   Common_Service_Parameters.E_D_TOV
                                                                 ),
                             hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV )
                           );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_FLOGI_Payload_t,
                                                                  N_Port_Name[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_FLOGI_Payload_t,
                                                                  Node_Name[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_1_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_2_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FLOGI_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_FLOGI_Payload_t,
                                                               Class_3_Service_Parameters.Open_Sequences_per_Exchange
                                                             ),
                         hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FLOGI_Payload_Dummy_Ptr->Reserved);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_FLOGI_Payload_t,
                                                                  Reserved[Bit8_Index]
                                                                ),
                            0
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FLOGI_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_FLOGI_Payload_t,
                                                                  Vendor_Version_Level[Bit8_Index]
                                                                ),
                            0
                          );
    }

/*+
Return length of FLOGI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_FLOGI_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInFLOGI_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t              *CThread       = CThread_ptr(SFThread->thread_hdr.hpRoot);
    FCHS_t                 *FLOGI_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_FLOGI_Payload_t *FLOGI_Payload = (FC_ELS_FLOGI_Payload_t *)((os_bit8 *)FLOGI_Header + sizeof(FCHS_t));
    os_bit32                   Bit8_Index;

    os_bit32               * Payload= (os_bit32 *)FLOGI_Payload;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_FLOGI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in FLOGI Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    FC_Well_Known_Port_ID_Fabric_F_Port,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                        LinkSvcLogConsoleLevel,
                        "FCHS %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FLOGI_Header->MBZ1,
                        FLOGI_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FLOGI_Header->R_CTL__D_ID,
                        FLOGI_Header->CS_CTL__S_ID,
                        FLOGI_Header->TYPE__F_CTL,
                        FLOGI_Header->SEQ_ID__DF_CTL__SEQ_CNT,
                        FLOGI_Header->OX_ID__RX_ID,
                        FLOGI_Header->RO );

/*+
Fill in FLOGI Frame Payload
-*/

    FLOGI_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_FLOGI );

    FLOGI_Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit );

    FLOGI_Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size );

    FLOGI_Payload->Common_Service_Parameters.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category
        = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.N_Port_Total_Concurrent_Sequences__RO_by_Info_Category );

    /*McData switch enforces the parameter - reserved for NPORT */
    if(CThread->InitAsNport)
    {
        FLOGI_Payload->Common_Service_Parameters.E_D_TOV =0;
    }
    else
    {
        FLOGI_Payload->Common_Service_Parameters.E_D_TOV
            = hpSwapBit32( CThread->ChanInfo.N_Port_Common_Parms.E_D_TOV );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        FLOGI_Payload->N_Port_Name[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        FLOGI_Payload->Node_Name[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }

    FLOGI_Payload->Class_1_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    FLOGI_Payload->Class_1_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Recipient_Control_Flags__Receive_Data_Size );

    FLOGI_Payload->Class_1_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Concurrent_Sequences__EE_Credit );

    FLOGI_Payload->Class_1_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_1_Parms.Open_Sequences_per_Exchange );

    FLOGI_Payload->Class_2_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    FLOGI_Payload->Class_2_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size );

    FLOGI_Payload->Class_2_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Concurrent_Sequences__EE_Credit );

    FLOGI_Payload->Class_2_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_2_Parms.Open_Sequences_per_Exchange );

    FLOGI_Payload->Class_3_Service_Parameters.Class_Validity__Service_Options__Initiator_Control_Flags
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Class_Validity__Service_Options__Initiator_Control_Flags );

    FLOGI_Payload->Class_3_Service_Parameters.Recipient_Control_Flags__Receive_Data_Size
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size );

    FLOGI_Payload->Class_3_Service_Parameters.Concurrent_Sequences__EE_Credit
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Concurrent_Sequences__EE_Credit );

    FLOGI_Payload->Class_3_Service_Parameters.Open_Sequences_per_Exchange
        = hpSwapBit32( CThread->ChanInfo.N_Port_Class_3_Parms.Open_Sequences_per_Exchange );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FLOGI_Payload->Reserved);
         Bit8_Index++)
    {
        FLOGI_Payload->Reserved[Bit8_Index] = 0;
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Vendor_Version_Level_t);
         Bit8_Index++)
    {
        FLOGI_Payload->Vendor_Version_Level[Bit8_Index] = 0;
    }

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload   %X ",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                sizeof(FC_ELS_FLOGI_Payload_t),
                0,0,0,0,0,0,0 );


    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload   0 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+0)),
                hpSwapBit32(*(Payload+1)),
                hpSwapBit32(*(Payload+2)),
                hpSwapBit32(*(Payload+3)),
                hpSwapBit32(*(Payload+4)),
                hpSwapBit32(*(Payload+5)),
                hpSwapBit32(*(Payload+6)),
                hpSwapBit32(*(Payload+7)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload   8 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+8)),
                hpSwapBit32(*(Payload+9)),
                hpSwapBit32(*(Payload+10)),
                hpSwapBit32(*(Payload+11)),
                hpSwapBit32(*(Payload+12)),
                hpSwapBit32(*(Payload+13)),
                hpSwapBit32(*(Payload+14)),
                hpSwapBit32(*(Payload+15)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload  16 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+16)),
                hpSwapBit32(*(Payload+17)),
                hpSwapBit32(*(Payload+18)),
                hpSwapBit32(*(Payload+19)),
                hpSwapBit32(*(Payload+20)),
                hpSwapBit32(*(Payload+21)),
                hpSwapBit32(*(Payload+22)),
                hpSwapBit32(*(Payload+23)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload  24 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+24)),
                hpSwapBit32(*(Payload+25)),
                hpSwapBit32(*(Payload+26)),
                hpSwapBit32(*(Payload+27)),
                hpSwapBit32(*(Payload+28)),
                hpSwapBit32(*(Payload+29)),
                hpSwapBit32(*(Payload+30)),
                hpSwapBit32(*(Payload+31)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload  32 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+32)),
                hpSwapBit32(*(Payload+33)),
                hpSwapBit32(*(Payload+34)),
                hpSwapBit32(*(Payload+35)),
                hpSwapBit32(*(Payload+36)),
                hpSwapBit32(*(Payload+37)),
                hpSwapBit32(*(Payload+38)),
                hpSwapBit32(*(Payload+39)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Flogi Payload  40 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Payload+40)),
                hpSwapBit32(*(Payload+41)),
                hpSwapBit32(*(Payload+42)),
                hpSwapBit32(*(Payload+43)),
                hpSwapBit32(*(Payload+44)),
                hpSwapBit32(*(Payload+45)),
                hpSwapBit32(*(Payload+46)),
                hpSwapBit32(*(Payload+47)) );


/*+
Return length of FLOGI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_FLOGI_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_FLOGI_Response_OnCard(
                                             SFThread_t *SFThread,
                                             os_bit32       Frame_Length,
                                             os_bit32       Offset_to_FCHS,
                                             os_bit32       Offset_to_Payload,
                                             os_bit32       Payload_Wrap_Offset,
                                             os_bit32       Offset_to_Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t       *hpRoot     = SFThread->thread_hdr.hpRoot;
    CThread_t      *CThread    = CThread_ptr(hpRoot);
    agFCChanInfo_t *SelfInfo   = &(CThread->ChanInfo);
    os_bit32           My_ID;
    os_bit32           Bit8_Index;

/*+
Extract Full (24-bit) My_ID from D_ID of Frame Header and update My_ID register in TachyonTL
-*/

    My_ID = (osCardRamReadBit32(
                                 hpRoot,
                                 ( Offset_to_FCHS
                                   + hpFieldOffset(
                                                    FCHS_t,
                                                    R_CTL__D_ID
                                                  ) )
                               ) & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, My_ID );
/*
    if(D_ID  != 0 && D_ID != 0xff)
    {

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, D_ID);

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                ( D_ID <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ));


        Port_ID.Struct_Form.Domain = 0;
        Port_ID.Struct_Form.Area   = 0;
        Port_ID.Struct_Form.AL_PA  = (os_bit8)D_ID;

        pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

        pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                    Port_ID.Struct_Form.Domain,
                                                    Port_ID.Struct_Form.Area,
                                                    Port_ID.Struct_Form.AL_PA,
                                                   (FC_Port_Name_t *)(&pCThread->ChanInfo.PortWWN));

        fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
        fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

        pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)D_ID;
    }

*/
    SelfInfo->CurrentAddress.reserved = 0;
    SelfInfo->CurrentAddress.Domain = (My_ID & 0x00FF0000) >> 16;
    SelfInfo->CurrentAddress.Area   = (My_ID & 0x0000FF00) >>  8;
    SelfInfo->CurrentAddress.AL_PA  = (My_ID & 0x000000FF) >>  0;

/*+
Process FLOGI ACC Payload
-*/

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.R_A_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.R_A_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.R_A_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Common_Parms.R_A_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.R_A_TOV
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.E_D_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.E_D_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Common_Service_Parameters.E_D_TOV
                                                               ) )
                                            ));
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_F_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,F_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            CThread->F_Port_Name[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_FLOGI_Payload_t,
                                                                        F_Port_Name[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            CThread->F_Port_Name[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_FLOGI_Payload_t,
                                                                                F_Port_Name[Bit8_Index]
                                                                              )
                                   );
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Fabric_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Fabric_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            CThread->Fabric_Name[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_FLOGI_Payload_t,
                                                                        Fabric_Name[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            CThread->Fabric_Name[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_FLOGI_Payload_t,
                                                                                Fabric_Name[Bit8_Index]
                                                                              )
                                   );
        }
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_1_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_1_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_2_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_2_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Class_Validity__Service_Options
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Class_Validity__Service_Options
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Reserved_1
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Reserved_1
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Reserved_2
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.Reserved_2
                                                               ) )
                                            ));
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }
    else
    {
        CThread->F_Port_Class_3_Parms.CR_TOV
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_FLOGI_Payload_t,
                                                                 Class_3_Service_Parameters.CR_TOV
                                                               ) )
                                            ));
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_FLOGI_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                       Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_ELS_ACC_FLOGI_Payload_t *Payload,
                                              os_bit32                       Payload_Wrap_Offset,
                                              FC_ELS_ACC_FLOGI_Payload_t *Payload_Wrapped
                                            )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t       *hpRoot      = SFThread->thread_hdr.hpRoot;
    CThread_t      *CThread     = CThread_ptr(hpRoot);
    agFCChanInfo_t *SelfInfo    = &(CThread->ChanInfo);
	DevThread_t   * pDevThread  = CThread->DeviceSelf;
    os_bit32        My_ID;
    os_bit32        Bit8_Index;
    os_bit32        BB_Credit   = 0;
    os_bit32      * pPayload    = (os_bit32 *)Payload;


/*+
Extract Full (24-bit) My_ID from D_ID of Frame Header and update My_ID register in TachyonTL
-*/

    My_ID = (FCHS->R_CTL__D_ID & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, My_ID );

    SelfInfo->CurrentAddress.Domain = (My_ID & 0x00FF0000) >> 16;
    SelfInfo->CurrentAddress.Area   = (My_ID & 0x0000FF00) >>  8;
    SelfInfo->CurrentAddress.AL_PA  = (My_ID & 0x000000FF) >>  0;

	pDevThread->DevInfo.CurrentAddress.Domain = SelfInfo->CurrentAddress.Domain;
	pDevThread->DevInfo.CurrentAddress.Area   = SelfInfo->CurrentAddress.Area;
	pDevThread->DevInfo.CurrentAddress.AL_PA  = SelfInfo->CurrentAddress.AL_PA;


    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "SELF %p Setting Aquired ID My_ID %08X ComputeSID %08X Self %02X%02X%02X" ,
                (char *)agNULL,(char *)agNULL,
                CThread->DeviceSelf,(void *)agNULL,
                My_ID,
                fiComputeCThread_S_ID(CThread),
                pDevThread->DevInfo.CurrentAddress.Domain,
                pDevThread->DevInfo.CurrentAddress.Area,
                pDevThread->DevInfo.CurrentAddress.AL_PA ,
                0,0,0 );



/*+
Process FLOGI ACC Payload
-*/

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }
    else
    {
        CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(Payload->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size);
    }
    else
    {
        CThread->F_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.Common_Features__BB_Recv_Data_Field_Size);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.R_A_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.R_A_TOV
            = hpSwapBit32(Payload->Common_Service_Parameters.R_A_TOV);
    }
    else
    {
        CThread->F_Port_Common_Parms.R_A_TOV
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.R_A_TOV);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Common_Service_Parameters.E_D_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(Payload->Common_Service_Parameters.E_D_TOV);
    }
    else
    {
        CThread->F_Port_Common_Parms.E_D_TOV
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.E_D_TOV);
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_F_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,F_Port_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            CThread->F_Port_Name[Bit8_Index] = Payload->F_Port_Name[Bit8_Index];
        }
        else
        {
            CThread->F_Port_Name[Bit8_Index] = Payload_Wrapped->F_Port_Name[Bit8_Index];
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Fabric_Name[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            CThread->Fabric_Name[Bit8_Index] = Payload->Fabric_Name[Bit8_Index];
        }
        else
        {
            CThread->Fabric_Name[Bit8_Index] = Payload_Wrapped->Fabric_Name[Bit8_Index];
        }
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Class_Validity__Service_Options);
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Class_Validity__Service_Options);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Reserved_1
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Reserved_1);
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Reserved_1
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Reserved_1);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.Reserved_2
            = hpSwapBit32(Payload->Class_1_Service_Parameters.Reserved_2);
    }
    else
    {
        CThread->F_Port_Class_1_Parms.Reserved_2
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.Reserved_2);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_1_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_1_Parms.CR_TOV
            = hpSwapBit32(Payload->Class_1_Service_Parameters.CR_TOV);
    }
    else
    {
        CThread->F_Port_Class_1_Parms.CR_TOV
            = hpSwapBit32(Payload_Wrapped->Class_1_Service_Parameters.CR_TOV);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Class_Validity__Service_Options);
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Class_Validity__Service_Options);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Reserved_1
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Reserved_1);
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Reserved_1
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Reserved_1);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.Reserved_2
            = hpSwapBit32(Payload->Class_2_Service_Parameters.Reserved_2);
    }
    else
    {
        CThread->F_Port_Class_2_Parms.Reserved_2
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.Reserved_2);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_2_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_2_Parms.CR_TOV
            = hpSwapBit32(Payload->Class_2_Service_Parameters.CR_TOV);
    }
    else
    {
        CThread->F_Port_Class_2_Parms.CR_TOV
            = hpSwapBit32(Payload_Wrapped->Class_2_Service_Parameters.CR_TOV);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Class_Validity__Service_Options)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Class_Validity__Service_Options);
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Class_Validity__Service_Options
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Class_Validity__Service_Options);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Reserved_1)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Reserved_1
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Reserved_1);
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Reserved_1
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Reserved_1);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.Reserved_2)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.Reserved_2
            = hpSwapBit32(Payload->Class_3_Service_Parameters.Reserved_2);
    }
    else
    {
        CThread->F_Port_Class_3_Parms.Reserved_2
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.Reserved_2);
    }

    if ((hpFieldOffset(FC_ELS_ACC_FLOGI_Payload_t,Class_3_Service_Parameters.CR_TOV)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        CThread->F_Port_Class_3_Parms.CR_TOV
            = hpSwapBit32(Payload->Class_3_Service_Parameters.CR_TOV);
    }
    else
    {
        CThread->F_Port_Class_3_Parms.CR_TOV
            = hpSwapBit32(Payload_Wrapped->Class_3_Service_Parameters.CR_TOV);
    }
    /* Pull out switch credit */
    BB_Credit = CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit & FC_N_Port_Common_Parms_BB_Credit_MASK;
    /* Use lessor of TL credit and switch credit */
    BB_Credit = TachyonTL_Nport_BB_Credit < BB_Credit  ?  TachyonTL_Nport_BB_Credit : BB_Credit;
    CThread->AquiredCredit_Shifted = BB_CREDIT_SHIFTED( BB_Credit );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Setting Aquired credit Flogi %X  Calc %X Shifted %X" ,
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                CThread->F_Port_Common_Parms.FC_PH_Version__BB_Credit,
                BB_Credit,
                CThread->AquiredCredit_Shifted,
                0,0,0,0,0 );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload   0 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+0)),
                hpSwapBit32(*(pPayload+1)),
                hpSwapBit32(*(pPayload+2)),
                hpSwapBit32(*(pPayload+3)),
                hpSwapBit32(*(pPayload+4)),
                hpSwapBit32(*(pPayload+5)),
                hpSwapBit32(*(pPayload+6)),
                hpSwapBit32(*(pPayload+7)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload   8 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+8)),
                hpSwapBit32(*(pPayload+9)),
                hpSwapBit32(*(pPayload+10)),
                hpSwapBit32(*(pPayload+11)),
                hpSwapBit32(*(pPayload+12)),
                hpSwapBit32(*(pPayload+13)),
                hpSwapBit32(*(pPayload+14)),
                hpSwapBit32(*(pPayload+15)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload  16 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+16)),
                hpSwapBit32(*(pPayload+17)),
                hpSwapBit32(*(pPayload+18)),
                hpSwapBit32(*(pPayload+19)),
                hpSwapBit32(*(pPayload+20)),
                hpSwapBit32(*(pPayload+21)),
                hpSwapBit32(*(pPayload+22)),
                hpSwapBit32(*(pPayload+23)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload  24 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+24)),
                hpSwapBit32(*(pPayload+25)),
                hpSwapBit32(*(pPayload+26)),
                hpSwapBit32(*(pPayload+27)),
                hpSwapBit32(*(pPayload+28)),
                hpSwapBit32(*(pPayload+29)),
                hpSwapBit32(*(pPayload+30)),
                hpSwapBit32(*(pPayload+31)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload  32 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+32)),
                hpSwapBit32(*(pPayload+33)),
                hpSwapBit32(*(pPayload+34)),
                hpSwapBit32(*(pPayload+35)),
                hpSwapBit32(*(pPayload+36)),
                hpSwapBit32(*(pPayload+37)),
                hpSwapBit32(*(pPayload+38)),
                hpSwapBit32(*(pPayload+39)) );

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "Received Flogi Payload  40 %08X %08X %08X %08X %08X %08X %08X %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(pPayload+40)),
                hpSwapBit32(*(pPayload+41)),
                hpSwapBit32(*(pPayload+42)),
                hpSwapBit32(*(pPayload+43)),
                hpSwapBit32(*(pPayload+44)),
                hpSwapBit32(*(pPayload+45)),
                hpSwapBit32(*(pPayload+46)),
                hpSwapBit32(*(pPayload+47)) );


#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiFillInLOGO(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInLOGO_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInLOGO_OffCard(
                                     SFThread
                                   );
    }
}

os_bit32 fiFillInLOGO_OnCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    DevThread_t *DevThread           = SFThread->parent.Device;
    os_bit32        LOGO_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        LOGO_Payload_Offset = LOGO_Header_Offset + sizeof(FCHS_t);
    os_bit32        Bit8_Index;
    os_bit32        S_ID=0;
    os_bit32        D_ID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_LOGO;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in LOGO Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in LOGO Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         LOGO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_LOGO_Payload_t,
                                                              ELS_Type
                                                            ),
                         hpSwapBit32( FC_ELS_Type_LOGO )
                       );

    D_ID = fiComputeDevThread_D_ID(
                                                            DevThread
                                                          );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    osCardRamWriteBit32(
                         hpRoot,
                         LOGO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_LOGO_Payload_t,
                                                              N_Port_Identifier
                                                            ),
                         hpSwapBit32(S_ID)
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            LOGO_Payload_Offset + hpFieldOffset(
                                                                 FC_ELS_LOGO_Payload_t,
                                                                 Port_Name[Bit8_Index]
                                                               ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

/*+
Return length of LOGO Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_LOGO_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInLOGO_OffCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t             *CThread      = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t           *DevThread    = SFThread->parent.Device;
    FCHS_t                *LOGO_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_LOGO_Payload_t *LOGO_Payload = (FC_ELS_LOGO_Payload_t *)((os_bit8 *)LOGO_Header + sizeof(FCHS_t));
    os_bit32                  Bit8_Index;
    os_bit32                  S_ID=0;
    os_bit32                  D_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_LOGO;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in LOGO Frame Header
-*/

    D_ID =  fiComputeDevThread_D_ID( DevThread); 
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in LOGO Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;
    
    LOGO_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_LOGO );

    LOGO_Payload->N_Port_Identifier
        = hpSwapBit32(S_ID);

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Port_Name_t);
         Bit8_Index++)
    {
        LOGO_Payload->Port_Name[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

/*+
Return length of LOGO Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_LOGO_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_LOGO_Response_OnCard(
                                            SFThread_t *SFThread,
                                            os_bit32       Frame_Length,
                                            os_bit32       Offset_to_FCHS,
                                            os_bit32       Offset_to_Payload,
                                            os_bit32       Payload_Wrap_Offset,
                                            os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_LOGO_Response_OffCard(
                                             SFThread_t                     *SFThread,
                                             os_bit32                          Frame_Length,
                                             FCHS_t                         *FCHS,
                                             FC_ELS_GENERIC_ACC_Payload_t   *Payload,
                                             os_bit32                          Payload_Wrap_Offset,
                                             FC_ELS_GENERIC_ACC_Payload_t   *Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_On_Card__
#endif /* __MemMap_Force_On_Card__ was not defined */
}
 
os_bit32 fiFillInELS_ACC(
                        SFThread_t *SFThread,
                        os_bit32       D_ID,
                        os_bit32       OX_ID
                      )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInELS_ACC_OnCard(
                                        SFThread,
                                        D_ID,
                                        OX_ID
                                      );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInELS_ACC_OffCard(
                                         SFThread,
                                         D_ID,
                                         OX_ID
                                       );
    }
}

os_bit32 fiFillInELS_ACC_OnCard(
                               SFThread_t *SFThread,
                               os_bit32       D_ID,
                               os_bit32       OX_ID
                             )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                  = SFThread->thread_hdr.hpRoot;
    os_bit32        ELS_ACC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        ELS_ACC_Payload_Offset = ELS_ACC_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ELS_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in ELS_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );

/*+
Fill in ELS_ACC Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         ELS_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_GENERIC_ACC_Payload_t,
                                                                  ELS_Type
                                                                ),
                         hpSwapBit32(
                                      FC_ELS_Type_ACC
                                    )
                       );

/*+
Return length of ELS_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_GENERIC_ACC_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInELS_ACC_OffCard(
                                SFThread_t *SFThread,
                                os_bit32       D_ID,
                                os_bit32       OX_ID
                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    FCHS_t                    *ELS_ACC_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_GENERIC_ACC_Payload_t *ELS_ACC_Payload = (FC_ELS_GENERIC_ACC_Payload_t *)((os_bit8 *)ELS_ACC_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ELS_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in ELS_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                  );

/*+
Fill in ELS_ACC Frame Payload
-*/

    ELS_ACC_Payload->ELS_Type
        = hpSwapBit32(
                       FC_ELS_Type_ACC
                     );

/*+
Return length of ELS_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_GENERIC_ACC_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_LILP_OnCard(
                                   agRoot_t *hpRoot,
                                   os_bit32     Frame_Length,
                                   os_bit32     Offset_to_FCHS,
                                   os_bit32     Offset_to_Payload,
                                   os_bit32     Payload_Wrap_Offset,
                                   os_bit32     Offset_to_Payload_Wrapped
                                 )
{
#ifndef __MemMap_Force_Off_Card__
    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *LILP_Payload  = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    os_bit32                                         LILP_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                         LILP_Payload_To_Copy;
    os_bit32                                         Bit8_Index;

    if (LILP_Payload_Size < FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE)
    {
        LILP_Payload_To_Copy = LILP_Payload_Size;
    }
    else /* LILP_Payload_Size >= FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE */
    {
        LILP_Payload_To_Copy = FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE;
    }

    for (Bit8_Index = 0;
         Bit8_Index < LILP_Payload_To_Copy;
         Bit8_Index++)
    {
        if (Bit8_Index <= Payload_Wrap_Offset)
        {
            *((os_bit8 *)LILP_Payload + Bit8_Index)
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + Bit8_Index
                                   );
        }
        else /* Bit8_Index > Payload_Wrap_Offset */
        {
            *((os_bit8 *)LILP_Payload + Bit8_Index)
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + Bit8_Index
                                   );
        }
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_LILP_OffCard(
                                    agRoot_t                                     *hpRoot,
                                    os_bit32                                         Frame_Length,
                                    FCHS_t                                       *FCHS,
                                    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *Payload,
                                    os_bit32                                         Payload_Wrap_Offset,
                                    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *Payload_Wrapped
                                  )
{
#ifndef __MemMap_Force_On_Card__

    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t * LILP_Payload  = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    os_bit32                                       LILP_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                       LILP_Payload_To_Copy;
    os_bit32                                       Bit8_Index;

    if (LILP_Payload_Size < FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE)
    {
        LILP_Payload_To_Copy = LILP_Payload_Size;
    }
    else /* LILP_Payload_Size >= FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE */
    {
        LILP_Payload_To_Copy = FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE;
    }

    for (Bit8_Index = 0;
         Bit8_Index < LILP_Payload_To_Copy;
         Bit8_Index++)
    {
        if (Bit8_Index <= Payload_Wrap_Offset)
        {
            *((os_bit8 *)LILP_Payload + Bit8_Index) = *((os_bit8 *)Payload + Bit8_Index);
        }
        else /* Bit8_Index > Payload_Wrap_Offset */
        {
            *((os_bit8 *)LILP_Payload + Bit8_Index) = *((os_bit8 *)Payload_Wrapped + Bit8_Index);
        }
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInRRQ(
                   SFThread_t *SFThread
                 )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInRRQ_OnCard(
                                   SFThread
                                 );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInRRQ_OffCard(
                                    SFThread
                                  );
    }
}

os_bit32 fiFillInRRQ_OnCard(
                          SFThread_t *SFThread
                        )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot             = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread            = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread          = SFThread->parent.CDB;
    DevThread_t *DevThread          = CDBThread->Device;
    os_bit32        RRQ_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        RRQ_Payload_Offset = RRQ_Header_Offset + sizeof(FCHS_t);
    X_ID_t       Masked_OX_ID;
    os_bit32        D_ID;
    os_bit32        S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_RRQ;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        Masked_OX_ID = CDBThread->X_ID | X_ID_Read;
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        Masked_OX_ID = CDBThread->X_ID | X_ID_Write;
    }

/*+
Fill in RRQ Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in RRQ Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         RRQ_Payload_Offset + hpFieldOffset(
                                                             FC_ELS_RRQ_Payload_t,
                                                             ELS_Type
                                                           ),
                         hpSwapBit32( FC_ELS_Type_RRQ )
                       );

    D_ID    =   fiComputeDevThread_D_ID(DevThread);

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    osCardRamWriteBit32(
                         hpRoot,
                         RRQ_Payload_Offset + hpFieldOffset(
                                                             FC_ELS_RRQ_Payload_t,
                                                             Originator_S_ID
                                                           ),
                         hpSwapBit32(
                                      fiComputeCThread_S_ID(
                                                             CThread
                                                           )
                                    )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         RRQ_Payload_Offset + hpFieldOffset(
                                                             FC_ELS_RRQ_Payload_t,
                                                             OX_ID__RX_ID
                                                           ),
                         hpSwapBit32(
                                      (   (Masked_OX_ID << FC_ELS_RRQ_OX_ID_SHIFT)
                                        | (      0xFFFF << FC_ELS_RRQ_RX_ID_SHIFT) )
                                    )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         RRQ_Payload_Offset + hpFieldOffset(
                                                             FC_ELS_RRQ_Payload_t,
                                                             Association_Header.Validity_Bits
                                                           ),
                         hpSwapBit32( 0 )
                       );

/*+
Return length of RRQ Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_RRQ_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInRRQ_OffCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t            *CThread      = CThread_ptr(SFThread->thread_hdr.hpRoot);
    CDBThread_t          *CDBThread    = SFThread->parent.CDB;
    DevThread_t          *DevThread    = CDBThread->Device;
    FCHS_t               *RRQ_Header   = SFThread->SF_CMND_Ptr;
    FC_ELS_RRQ_Payload_t *RRQ_Payload  = (FC_ELS_RRQ_Payload_t *)((os_bit8 *)RRQ_Header + sizeof(FCHS_t));
    X_ID_t                Masked_OX_ID;
    os_bit32                 S_ID=0;
    os_bit32                 D_ID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_RRQ;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        Masked_OX_ID = CDBThread->X_ID | X_ID_Read;
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        Masked_OX_ID = CDBThread->X_ID | X_ID_Write;
    }

    D_ID =  fiComputeDevThread_D_ID( DevThread );
/*+
Fill in RRQ Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in RRQ Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    RRQ_Payload->ELS_Type
        = hpSwapBit32( FC_ELS_Type_RRQ );

    RRQ_Payload->Originator_S_ID
        = hpSwapBit32( S_ID
                     );

    RRQ_Payload->OX_ID__RX_ID
        = hpSwapBit32(
                       (   (Masked_OX_ID << FC_ELS_RRQ_OX_ID_SHIFT)
                         | (      0xFFFF << FC_ELS_RRQ_RX_ID_SHIFT) )
                     );

    RRQ_Payload->Association_Header.Validity_Bits
        = hpSwapBit32( 0 );

/*+
Return length of RRQ Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_RRQ_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_RRQ_Response_OnCard(
                                           SFThread_t *SFThread,
                                           os_bit32       Frame_Length,
                                           os_bit32       Offset_to_FCHS,
                                           os_bit32       Offset_to_Payload,
                                           os_bit32       Payload_Wrap_Offset,
                                           os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_RRQ_Response_OffCard(
                                            SFThread_t               *SFThread,
                                            os_bit32                     Frame_Length,
                                            FCHS_t                   *FCHS,
                                            FC_ELS_ACC_RRQ_Payload_t *Payload,
                                            os_bit32                     Payload_Wrap_Offset,
                                            FC_ELS_ACC_RRQ_Payload_t *Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_On_Card__
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInPRLI(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPRLI_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPRLI_OffCard(
                                     SFThread
                                   );
    }
}

os_bit32 fiFillInPRLI_OnCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    DevThread_t *DevThread           = SFThread->parent.Device;
    os_bit32        PRLI_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        PRLI_Payload_Offset = PRLI_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in PRLI Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in PRLI Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              ELS_Type__Page_Length__Payload_Length
                                                            ),
                         hpSwapBit32(   FC_ELS_Type_PRLI
                                     | (sizeof(FC_ELS_PRLI_Parm_Page_t) << FC_ELS_PRLI_Page_Length_SHIFT)
                                     | ((sizeof(os_bit32) + sizeof(FC_ELS_PRLI_Parm_Page_t)) << FC_ELS_PRLI_Payload_Length_SHIFT) )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              Parm_Page[0].Type__Type_Extension__Flags
                                                            ),
                         hpSwapBit32(   FC_ELS_PRLI_Parm_Type_SCSI_FCP
                                      | FC_ELS_PRLI_Parm_Establish_Image_Pair )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              Parm_Page[0].Originator_Process_Associator
                                                            ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              Parm_Page[0].Responder_Process_Associator
                                                            ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLI_Payload_t,
                                                              Parm_Page[0].Service_Parameters
                                                            ),
                         hpSwapBit32(   FC_ELS_PRLI_Parm_Initiator_Function
                                      | FC_ELS_PRLI_Parm_Read_XFER_RDY_Disabled )
                       );

/*+
Return length of PRLI Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_PRLI_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPRLI_OffCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    DevThread_t           *DevThread    = SFThread->parent.Device;
    FCHS_t                *PRLI_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_PRLI_Payload_t *PRLI_Payload = (FC_ELS_PRLI_Payload_t *)((os_bit8 *)PRLI_Header + sizeof(FCHS_t));
    os_bit32                 *pPayload      = (os_bit32   *)PRLI_Payload;
    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLI;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in PRLI Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in PRLI Frame Payload
-*/

    PRLI_Payload->ELS_Type__Page_Length__Payload_Length
        = hpSwapBit32(   FC_ELS_Type_PRLI
                       | (sizeof(FC_ELS_PRLI_Parm_Page_t) << FC_ELS_PRLI_Page_Length_SHIFT)
                       | ((sizeof(os_bit32) + sizeof(FC_ELS_PRLI_Parm_Page_t)) << FC_ELS_PRLI_Payload_Length_SHIFT) );

    PRLI_Payload->Parm_Page[0].Type__Type_Extension__Flags
        = hpSwapBit32(   FC_ELS_PRLI_Parm_Type_SCSI_FCP
                       | FC_ELS_PRLI_Parm_Establish_Image_Pair);

    PRLI_Payload->Parm_Page[0].Originator_Process_Associator = 0;

    PRLI_Payload->Parm_Page[0].Responder_Process_Associator  = 0;

    if(DevThread->PRLI_rejected)
    {
        PRLI_Payload->Parm_Page[0].Service_Parameters
            = hpSwapBit32(   FC_ELS_PRLI_Parm_Initiator_Function
                           | FC_ELS_PRLI_Parm_Read_XFER_RDY_Disabled );
    }
    else
    {
        PRLI_Payload->Parm_Page[0].Service_Parameters
            = hpSwapBit32(   FC_ELS_PRLI_Parm_Initiator_Function
                           | FC_ELS_PRLI_Parm_Read_XFER_RDY_Disabled 
                           | FC_ELS_PRLI_Parm_Confirmed_Completion_Allowed );
    }
/*+
Return length of PRLI Frame (including FCHS and Payload)
-*/

    fiLogDebugString(
                      SFThread->thread_hdr.hpRoot,
                      LinkSvcLog_ERROR_Level,
                      "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                      "Sent PRLI Payload",
                      (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      hpSwapBit32( *(pPayload+0)),
                      hpSwapBit32( *(pPayload+1)),
                      hpSwapBit32( *(pPayload+2)),
                      hpSwapBit32( *(pPayload+3)),
                      hpSwapBit32( *(pPayload+4)),
                      hpSwapBit32( *(pPayload+5)),
                      hpSwapBit32( *(pPayload+6)),
                      hpSwapBit32( *(pPayload+7)));


    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_PRLI_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_PRLI_Response_Either(
                                            DevThread_t *DevThread
                                          )
{
    CThread_t   *CThread           = CThread_ptr(DevThread->thread_hdr.hpRoot);
    os_bit32        FCHS_LCr;
    os_bit32        Receive_Data_Size;
    os_bit32        IWE_FL;
    FCHS_t      *FCHS              = &(DevThread->Template_FCHS);
    IRE_t       *IRE               = &(DevThread->Template_SEST_IRE);
    IWE_t       *IWE               = &(DevThread->Template_SEST_IWE);
    os_bit32    DEVID=CThread->DEVID;

    /* Fill in DevThread->Template_FCHS */
/*
    FCHS_LCr = ( ( ( (   DevThread->DevInfo.N_Port_Common_Parms.FC_PH_Version__BB_Credit
                       & FC_N_Port_Common_Parms_BB_Credit_MASK                           )
                     >> FC_N_Port_Common_Parms_BB_Credit_SHIFT                             )
                   << FCHS_LCr_SHIFT                                                         )
                 & FCHS_LCr_MASK                                                               );

*/
    FCHS_LCr = ( ( ( (   0
                       & FC_N_Port_Common_Parms_BB_Credit_MASK                           )
                     >> FC_N_Port_Common_Parms_BB_Credit_SHIFT                             )
                   << FCHS_LCr_SHIFT                                                         )
                 & FCHS_LCr_MASK                                                               );

    FCHS->MBZ1                                        = 0;

#ifdef __TACHYON_XL_CLASS2
    /* Depending on the device support of class 2, set the class 2 vs class 3 SOF */
    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp = (DevThread->GoingClass2) ? FCHS_SOF_SOFi2 : FCHS_SOF_SOFi3
                                                        | FCHS_EOF_EOFn
                                                        | FCHS_LCr;
#else

    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                        | FCHS_EOF_EOFn
                                                        | FCHS_LCr;
#endif

    FCHS->R_CTL__D_ID                                 =   FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                                                        | FC_Frame_Header_R_CTL_Lo_Unsolicited_Command
                                                        | fiComputeDevThread_D_ID(
                                                                                   DevThread
                                                                                 );
    if( (DevThread->DevInfo.CurrentAddress.Domain == 0) &&
        (DevThread->DevInfo.CurrentAddress.Area == 0) )
    {
        FCHS->CS_CTL__S_ID                            = CThread->ChanInfo.CurrentAddress.AL_PA;
    }
    else
    {
        FCHS->CS_CTL__S_ID                            = fiComputeCThread_S_ID(CThread);
    }

#ifdef __TACHYON_XL_CLASS2
   FCHS->TYPE__F_CTL                                 =  (DevThread->GoingClass2) ? 
                                                         FC_Frame_Header_F_CTL_ACK_Form_ACK_0_Required
                                                        | FC_Frame_Header_TYPE_SCSI_FCP
                                                        | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                                        | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                        | FC_Frame_Header_F_CTL_First_Sequence
                                                        | FC_Frame_Header_F_CTL_End_Sequence
                                                        | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer
                                                        | FC_Frame_Header_F_CTL_Relative_Offset_Present :
                                                        FC_Frame_Header_TYPE_SCSI_FCP
                                                        | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                                        | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                        | FC_Frame_Header_F_CTL_First_Sequence
                                                        | FC_Frame_Header_F_CTL_End_Sequence
                                                        | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer
                                                        | FC_Frame_Header_F_CTL_Relative_Offset_Present;
#else

    FCHS->TYPE__F_CTL                                 =   FC_Frame_Header_TYPE_SCSI_FCP
                                                        | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                                        | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                                                        | FC_Frame_Header_F_CTL_First_Sequence
                                                        | FC_Frame_Header_F_CTL_End_Sequence
                                                        | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer
                                                        | FC_Frame_Header_F_CTL_Relative_Offset_Present;
#endif

    FCHS->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    FCHS->OX_ID__RX_ID                                = (0xFFFF << FCHS_RX_ID_SHIFT);
    FCHS->RO                                          = 0;

    /* Fill in DevThread->Template_SEST_IRE */

    IRE->Bits_MBZ1_EQL_MBZ2                           =   IRE_VAL
                                                        | IRE_DIR
                                                        | IRE_INI
                                                        | IRE_DAT
                                                        | IRE_RSP;
    IRE->MBZ3                                         = 0;
    IRE->Remote_Node_ID__RSP_Len                      =   (DevThread->DevInfo.CurrentAddress.Domain << (IRE_Remote_Node_ID_SHIFT + 16))
                                                        | (DevThread->DevInfo.CurrentAddress.Area   << (IRE_Remote_Node_ID_SHIFT +  8))
                                                        | (DevThread->DevInfo.CurrentAddress.AL_PA  <<  IRE_Remote_Node_ID_SHIFT      )
                                                        | (CThread->Calculation.MemoryLayout.FCP_RESP.elementSize << IRE_RSP_Len_SHIFT);
    IRE->RSP_Addr                                     = 0;
    IRE->LOC__MBZ4__Buff_Off                          = IRE_LOC;
    IRE->Buff_Index__MBZ5                             = 0;
    IRE->Exp_RO                                       = 0;
    IRE->Byte_Count                                   = 0;
    IRE->MBZ6                                         = 0;
    IRE->Exp_Byte_Cnt                                 = 0;
    IRE->First_SG.U32_Len                             = 0;
    IRE->First_SG.L32                                 = 0;
    IRE->Second_SG.U32_Len                            = 0;
    IRE->Second_SG.L32                                = 0;
    IRE->Third_SG.U32_Len                             = 0;
    IRE->Third_SG.L32                                 = 0;

    /* Fill in DevThread->Template_SEST_IWE */

#ifdef __TACHYON_XL_CLASS2
    Receive_Data_Size = ( ( (DevThread->GoingClass2) ? DevThread->DevInfo.N_Port_Class_2_Parms.Recipient_Control_Flags__Receive_Data_Size
                            & FC_N_Port_Class_Parms_Receive_Data_Size_MASK : DevThread->DevInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
                            & FC_N_Port_Class_Parms_Receive_Data_Size_MASK                                       )
                          >> FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT                                         );
#else
    Receive_Data_Size = ( (   DevThread->DevInfo.N_Port_Class_3_Parms.Recipient_Control_Flags__Receive_Data_Size
                            & FC_N_Port_Class_Parms_Receive_Data_Size_MASK                                       )
                          >> FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT                                         );
#endif

    if ((DEVID == ChipConfig_DEVID_TachyonXL2) && Receive_Data_Size >= 2048)
    {
        IWE_FL = IWE_FL_2048_Bytes;

        fiLogDebugString(
                  DevThread->thread_hdr.hpRoot,
                  LinkSvcLogConsoleLevel,
                  "DEVID 0x%08X Setting IWE to be 2048 bytes",
                  (char *)agNULL,(char *)agNULL,
                  (void *)agNULL,(void *)agNULL,
                  (os_bit32)DEVID,
                  0,0,0,0,0,0,0
                );

        
    }
    else if (Receive_Data_Size >= 1024)
    {
        IWE_FL = IWE_FL_1024_Bytes;
    }
    else if (Receive_Data_Size >= 512)
    {
        IWE_FL = IWE_FL_512_Bytes;
    }
    else /* Receive_Data_Size >= 128 */
    {
        IWE_FL = IWE_FL_128_Bytes;
    }

    IWE->Bits__MBZ1__LNK__MBZ2__FL__MBZ3__Hdr_Len     =   IWE_VAL
                                                        | IWE_INI
                                                        | IWE_DAT
                                                        | IWE_RSP
                                                        | IWE_FL
                                                        | (sizeof(FCHS_t) << IWE_Hdr_Len_SHIFT);
    IWE->Hdr_Addr                                     = 0;
    IWE->Remote_Node_ID__RSP_Len                      =   (DevThread->DevInfo.CurrentAddress.Domain << (IRE_Remote_Node_ID_SHIFT + 16))
                                                        | (DevThread->DevInfo.CurrentAddress.Area   << (IRE_Remote_Node_ID_SHIFT +  8))
                                                        | (DevThread->DevInfo.CurrentAddress.AL_PA  <<  IRE_Remote_Node_ID_SHIFT      )
                                                        | (CThread->Calculation.MemoryLayout.FCP_RESP.elementSize << IRE_RSP_Len_SHIFT);
    IWE->RSP_Addr                                     = 0;
    IWE->LOC__0xF__MBZ4__Buff_Off                     = ( IWE_LOC | IWE_0xF_ALWAYS );
    IWE->Buff_Index__Link                             = IWE_Link_Initializer;
    IWE->MBZ5__RX_ID                                  = 0xFFFF << IWE_RX_ID_SHIFT;
    IWE->Data_Len                                     = 0;
    IWE->Exp_RO                                       = 0;
    IWE->Exp_Byte_Cnt                                 = 0;
    IWE->First_SG.U32_Len                             = 0;
    IWE->First_SG.L32                                 = 0;
    IWE->Second_SG.U32_Len                            = 0;
    IWE->Second_SG.L32                                = 0;
    IWE->Third_SG.U32_Len                             = 0;
    IWE->Third_SG.L32                                 = 0;
}

void fiLinkSvcProcess_PRLI_Response_OnCard(
                                            SFThread_t *SFThread,
                                            os_bit32       Frame_Length,
                                            os_bit32       Offset_to_FCHS,
                                            os_bit32       Offset_to_Payload,
                                            os_bit32       Payload_Wrap_Offset,
                                            os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t      *hpRoot                                = SFThread->thread_hdr.hpRoot;
    DevThread_t   *DevThread                             = SFThread->parent.Device;
    agFCDevInfo_t *DevInfo                               = &(DevThread->DevInfo);
    os_bit32          ELS_Type__Page_Length__Payload_Length;
    os_bit32          Type__Type_Extension__Flags;
    os_bit32          Service_Parameters;

    DevInfo->LoggedIn = agTRUE;

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,ELS_Type__Page_Length__Payload_Length)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        ELS_Type__Page_Length__Payload_Length
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 ELS_Type__Page_Length__Payload_Length
                                                               ) )
                                            ));
    }
    else
    {
        ELS_Type__Page_Length__Payload_Length
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 ELS_Type__Page_Length__Payload_Length
                                                               ) )
                                            ));
    }

    if (((ELS_Type__Page_Length__Payload_Length & FC_ELS_ACC_PRLI_Page_Length_MASK) >> FC_ELS_ACC_PRLI_Page_Length_SHIFT) != (sizeof(FC_ELS_PRLI_Parm_Page_t)))
    {
        return;
    }

    if (((ELS_Type__Page_Length__Payload_Length & FC_ELS_ACC_PRLI_Payload_Length_MASK) >> FC_ELS_ACC_PRLI_Payload_Length_SHIFT) != (sizeof(os_bit32) + sizeof(FC_ELS_PRLI_Parm_Page_t)))
    {
        return;
    }

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[0].Type__Type_Extension__Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Type__Type_Extension__Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 Parm_Page[0].Type__Type_Extension__Flags
                                                               ) )
                                            ));
    }
    else
    {
        Type__Type_Extension__Flags
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 Parm_Page[0].Type__Type_Extension__Flags
                                                               ) )
                                            ));
    }

    if ((Type__Type_Extension__Flags & FC_ELS_ACC_PRLI_Parm_Type_MASK) != FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP)
    {
        return;
    }

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[0].Service_Parameters)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Service_Parameters
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 Parm_Page[0].Service_Parameters
                                                               ) )
                                            ));
    }
    else
    {
        Service_Parameters
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PRLI_Payload_t,
                                                                 Parm_Page[0].Service_Parameters
                                                               ) )
                                            ));
    }

    if (Service_Parameters & FC_ELS_ACC_PRLI_Parm_Initiator_Function)
    {
        DevInfo->DeviceType |= agDevSCSIInitiator;
    }

    if (Service_Parameters & FC_ELS_ACC_PRLI_Parm_Target_Function)
    {
        DevInfo->DeviceType |= agDevSCSITarget;
    }

    if (Service_Parameters & FC_ELS_PRLI_Parm_Confirmed_Completion_Allowed)
    {
        DevThread->FC_TapeDevice = agTRUE;
    }
    else
    {
        DevThread->FC_TapeDevice = agFALSE;
    }




    fiLinkSvcProcess_PRLI_Response_Either(
                                           DevThread
                                         );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_PRLI_Response_OffCard(
                                             SFThread_t                *SFThread,
                                             os_bit32                      Frame_Length,
                                             FCHS_t                    *FCHS,
                                             FC_ELS_ACC_PRLI_Payload_t *Payload,
                                             os_bit32                      Payload_Wrap_Offset,
                                             FC_ELS_ACC_PRLI_Payload_t *Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t      *hpRoot                   = SFThread->thread_hdr.hpRoot;
    DevThread_t   *DevThread                = SFThread->parent.Device;
    agFCDevInfo_t *DevInfo                  = &(DevThread->DevInfo);
    os_bit32       ELS_Type__Page_Length__Payload_Length;
    os_bit32       Type__Type_Extension__Flags;
    os_bit32       Service_Parameters;
    os_bit32     * pPayload = (os_bit32 *)Payload;

    DevInfo->LoggedIn = agTRUE;

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,ELS_Type__Page_Length__Payload_Length)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        ELS_Type__Page_Length__Payload_Length
            = hpSwapBit32(Payload->ELS_Type__Page_Length__Payload_Length);
    }
    else
    {
        ELS_Type__Page_Length__Payload_Length
            = hpSwapBit32(Payload_Wrapped->ELS_Type__Page_Length__Payload_Length);
    }

    if (((ELS_Type__Page_Length__Payload_Length & FC_ELS_ACC_PRLI_Page_Length_MASK) >> FC_ELS_ACC_PRLI_Page_Length_SHIFT) != (sizeof(FC_ELS_PRLI_Parm_Page_t)))
    {
        return;
    }

    if (((ELS_Type__Page_Length__Payload_Length & FC_ELS_ACC_PRLI_Payload_Length_MASK) >> FC_ELS_ACC_PRLI_Payload_Length_SHIFT) != (sizeof(os_bit32) + sizeof(FC_ELS_PRLI_Parm_Page_t)))
    {
        return;
    }

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[0].Type__Type_Extension__Flags)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Type__Type_Extension__Flags
            = hpSwapBit32(Payload->Parm_Page[0].Type__Type_Extension__Flags);
    }
    else
    {
        Type__Type_Extension__Flags
            = hpSwapBit32(Payload_Wrapped->Parm_Page[0].Type__Type_Extension__Flags);
    }

    if ((Type__Type_Extension__Flags & FC_ELS_ACC_PRLI_Parm_Type_MASK) != FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP)
    {
        return;
    }

    if ((hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[0].Service_Parameters)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Service_Parameters
            = hpSwapBit32(Payload->Parm_Page[0].Service_Parameters);
    }
    else
    {
        Service_Parameters
            = hpSwapBit32(Payload_Wrapped->Parm_Page[0].Service_Parameters);
    }

    if (Service_Parameters & FC_ELS_ACC_PRLI_Parm_Initiator_Function)
    {
        DevInfo->DeviceType |= agDevSCSIInitiator;
    }

    if (Service_Parameters & FC_ELS_ACC_PRLI_Parm_Target_Function)
    {
        DevInfo->DeviceType |= agDevSCSITarget;
    }


    if (Service_Parameters & FC_ELS_PRLI_Parm_Confirmed_Completion_Allowed)
    {
        DevThread->FC_TapeDevice = agTRUE;
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "%s  agTRUE !!!!",
                          "FC_TapeDevice",
                          (char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0);

    }
    else
    {
        DevThread->FC_TapeDevice = agFALSE;
    }

/*   pPayload    +=  8; */

    fiLogDebugString(
                      hpRoot,
                      LinkSvcLog_ERROR_Level,
                      "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                      "PRLI Response Payload",
                      (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      hpSwapBit32( *(pPayload+0)),
                      hpSwapBit32( *(pPayload+1)),
                      hpSwapBit32( *(pPayload+2)),
                      hpSwapBit32( *(pPayload+3)),
                      hpSwapBit32( *(pPayload+4)),
                      hpSwapBit32( *(pPayload+5)),
                      hpSwapBit32( *(pPayload+6)),
                      hpSwapBit32( *(pPayload+7)));


    fiLinkSvcProcess_PRLI_Response_Either(
                                           DevThread
                                         );
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInPRLI_ACC(
                        SFThread_t *SFThread,
                        os_bit32       D_ID,
                        os_bit32       OX_ID
                      )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPRLI_ACC_OnCard(
                                        SFThread,
                                        D_ID,
                                        OX_ID
                                      );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPRLI_ACC_OffCard(
                                         SFThread,
                                         D_ID,
                                         OX_ID
                                       );
    }
}

os_bit32 fiFillInPRLI_ACC_OnCard(
                               SFThread_t *SFThread,
                               os_bit32       D_ID,
                               os_bit32       OX_ID
                             )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                  = SFThread->thread_hdr.hpRoot;
    os_bit32     PRLI_ACC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32     PRLI_ACC_Payload_Offset = PRLI_ACC_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in PRLI_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );

/*+
Fill in PRLI_ACC Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  ELS_Type__Page_Length__Payload_Length
                                                                ),
                         hpSwapBit32(   FC_ELS_Type_ACC
                                     | (sizeof(FC_ELS_ACC_PRLI_Parm_Page_t) << FC_ELS_ACC_PRLI_Page_Length_SHIFT)
                                     | ((sizeof(os_bit32) + sizeof(FC_ELS_ACC_PRLI_Parm_Page_t)) << FC_ELS_ACC_PRLI_Payload_Length_SHIFT) )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  Parm_Page[0].Type__Type_Extension__Flags
                                                                ),
                         hpSwapBit32(   FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP
                                      | FC_ELS_ACC_PRLI_Parm_Image_Pair_Established 
                                      | FC_ELS_ACC_PRLI_Parm_Flags_Response_Request_Executed )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  Parm_Page[0].Originator_Process_Associator
                                                                ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  Parm_Page[0].Responder_Process_Associator
                                                                ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLI_ACC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ACC_PRLI_Payload_t,
                                                                  Parm_Page[0].Service_Parameters
                                                                ),
                         hpSwapBit32(   FC_ELS_ACC_PRLI_Parm_Initiator_Function
                                      | FC_ELS_ACC_PRLI_Parm_Read_XFER_RDY_Disabled )
                       );

/*+
Return length of PRLI_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPRLI_ACC_OffCard(
                                SFThread_t *SFThread,
                                os_bit32       D_ID,
                                os_bit32       OX_ID
                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */

    FCHS_t                    *PRLI_ACC_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_ACC_PRLI_Payload_t *PRLI_ACC_Payload = (FC_ELS_ACC_PRLI_Payload_t *)((os_bit8 *)PRLI_ACC_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

/*+
Fill in PRLI_ACC Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder |
                                    FC_Frame_Header_F_CTL_Last_Sequence

                                  );

/*+
Fill in PRLI_ACC Frame Payload
-*/

    PRLI_ACC_Payload->ELS_Type__Page_Length__Payload_Length
        = hpSwapBit32(   FC_ELS_Type_ACC
                       | (sizeof(FC_ELS_ACC_PRLI_Parm_Page_t) << FC_ELS_ACC_PRLI_Page_Length_SHIFT)
                       | ((sizeof(os_bit32) + sizeof(FC_ELS_ACC_PRLI_Parm_Page_t)) << FC_ELS_ACC_PRLI_Payload_Length_SHIFT) );

    PRLI_ACC_Payload->Parm_Page[0].Type__Type_Extension__Flags
        = hpSwapBit32(   FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP
                       | FC_ELS_ACC_PRLI_Parm_Image_Pair_Established 
                       | FC_ELS_ACC_PRLI_Parm_Flags_Response_Request_Executed );

    PRLI_ACC_Payload->Parm_Page[0].Originator_Process_Associator = 0;

    PRLI_ACC_Payload->Parm_Page[0].Responder_Process_Associator  = 0;

    PRLI_ACC_Payload->Parm_Page[0].Service_Parameters
        = hpSwapBit32(   FC_ELS_ACC_PRLI_Parm_Initiator_Function
                       | FC_ELS_ACC_PRLI_Parm_Read_XFER_RDY_Disabled );

/*+
Return length of PRLI_ACC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_ACC_PRLI_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInPRLO(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInPRLO_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInPRLO_OffCard(
                                     SFThread
                                   );
    }
}

os_bit32 fiFillInPRLO_OnCard(
                           SFThread_t *SFThread
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    DevThread_t *DevThread           = SFThread->parent.Device;
    os_bit32        PRLO_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        PRLO_Payload_Offset = PRLO_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLO;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in PRLO Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in PRLO Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              ELS_Type__Page_Length__Payload_Length
                                                            ),
                         hpSwapBit32(   FC_ELS_Type_PRLO
                                     | (sizeof(FC_ELS_PRLO_Parm_Page_t) << FC_ELS_PRLO_Page_Length_SHIFT)
                                     | ((sizeof(os_bit32) + sizeof(FC_ELS_PRLO_Parm_Page_t)) << FC_ELS_PRLO_Payload_Length_SHIFT) )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              Parm_Page[0].Type__Type_Extension__Flags
                                                            ),
                         hpSwapBit32( FC_ELS_PRLI_Parm_Type_SCSI_FCP )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              Parm_Page[0].Originator_Process_Associator
                                                            ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              Parm_Page[0].Responder_Process_Associator
                                                            ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         PRLO_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_PRLO_Payload_t,
                                                              Parm_Page[0].Reserved
                                                            ),
                         0
                       );

/*+
Return length of PRLO Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_PRLO_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInPRLO_OffCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    DevThread_t           *DevThread    = SFThread->parent.Device;
    FCHS_t                *PRLO_Header  = SFThread->SF_CMND_Ptr;
    FC_ELS_PRLO_Payload_t *PRLO_Payload = (FC_ELS_PRLO_Payload_t *)((os_bit8 *)PRLO_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_PRLO;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in PRLO Frame Header
-*/

    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in PRLO Frame Payload
-*/

    PRLO_Payload->ELS_Type__Page_Length__Payload_Length
        = hpSwapBit32(   FC_ELS_Type_PRLO
                       | (sizeof(FC_ELS_PRLO_Parm_Page_t) << FC_ELS_PRLO_Page_Length_SHIFT)
                       | ((sizeof(os_bit32) + sizeof(FC_ELS_PRLO_Parm_Page_t)) << FC_ELS_PRLO_Payload_Length_SHIFT) );

    PRLO_Payload->Parm_Page[0].Type__Type_Extension__Flags
        = hpSwapBit32( FC_ELS_PRLO_Parm_Type_SCSI_FCP );

    PRLO_Payload->Parm_Page[0].Originator_Process_Associator = 0;

    PRLO_Payload->Parm_Page[0].Responder_Process_Associator  = 0;

    PRLO_Payload->Parm_Page[0].Reserved                      = 0;

/*+
Return length of PRLO Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + hpFieldOffset(FC_ELS_PRLO_Payload_t,Parm_Page[1]);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_PRLO_Response_OnCard(
                                            SFThread_t *SFThread,
                                            os_bit32       Frame_Length,
                                            os_bit32       Offset_to_FCHS,
                                            os_bit32       Offset_to_Payload,
                                            os_bit32       Payload_Wrap_Offset,
                                            os_bit32       Offset_to_Payload_Wrapped
                                          )
{
#ifndef __MemMap_Force_Off_Card__
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_PRLO_Response_OffCard(
                                             SFThread_t                *SFThread,
                                             os_bit32                      Frame_Length,
                                             FCHS_t                    *FCHS,
                                             FC_ELS_ACC_PRLO_Payload_t *Payload,
                                             os_bit32                      Payload_Wrap_Offset,
                                             FC_ELS_ACC_PRLO_Payload_t *Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_On_Card__
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInADISC(
                     SFThread_t *SFThread
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInADISC_OnCard(
                                     SFThread
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInADISC_OffCard(
                                      SFThread
                                    );
    }
}

os_bit32 fiFillInADISC_OnCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot               = SFThread->thread_hdr.hpRoot; /* NW BUG */
    DevThread_t *DevThread            = SFThread->parent.Device;
    os_bit32        ADISC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        ADISC_Payload_Offset = ADISC_Header_Offset + sizeof(FCHS_t);
    os_bit32        Bit8_Index;
    os_bit32        D_ID;
    os_bit32        S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ADISC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in ADISC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );
    D_ID = fiComputeDevThread_D_ID(
                                                            DevThread
                                                          );


/*+
Fill in ADISC Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread_ptr(hpRoot) );
    else
        S_ID =     CThread_ptr(hpRoot)->ChanInfo.CurrentAddress.AL_PA;
    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               ELS_Type
                                                             ),
                         hpSwapBit32( FC_ELS_Type_ADISC )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               Hard_Address_of_Originator
                                                             ),
                         hpSwapBit32(   (CThread_ptr(hpRoot)->ChanInfo.CurrentAddress.Domain << 16)
                                      | (CThread_ptr(hpRoot)->ChanInfo.CurrentAddress.Area   <<  8)
                                      | CThread_ptr(hpRoot)->ChanInfo.CurrentAddress.AL_PA          )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            ADISC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ADISC_Payload_t,
                                                                  Port_Name_of_Originator[Bit8_Index]
                                                                ),
                            CThread_ptr(hpRoot)->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            ADISC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ADISC_Payload_t,
                                                                  Node_Name_of_Originator[Bit8_Index]
                                                                ),
                            CThread_ptr(hpRoot)->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               N_Port_ID_of_Originator
                                                             ),
                         hpSwapBit32(S_ID )
                       );

/*+
Return length of ADISC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ADISC_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInADISC_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t              *CThread             = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t            *DevThread           = SFThread->parent.Device;
    FCHS_t                 *ADISC_Header        = SFThread->SF_CMND_Ptr;
    FC_ELS_ADISC_Payload_t *ADISC_Payload       = (FC_ELS_ADISC_Payload_t *)((os_bit8 *)ADISC_Header + sizeof(FCHS_t));
    os_bit32                   Bit8_Index;
    os_bit32                   S_ID=0;
    os_bit32                   D_ID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ADISC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in ADISC Frame Header
-*/

    D_ID  = fiComputeDevThread_D_ID(DevThread);
                                                           
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    fiComputeDevThread_D_ID(
                                                             DevThread
                                                           ),
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in ADISC Frame Payload
-*/

    ADISC_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_ADISC );

    ADISC_Payload->Hard_Address_of_Originator
        = hpSwapBit32(   (CThread->ChanInfo.CurrentAddress.Domain << 16)
                       | (CThread->ChanInfo.CurrentAddress.Area   <<  8)
                       |  CThread->ChanInfo.CurrentAddress.AL_PA         );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        ADISC_Payload->Port_Name_of_Originator[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        ADISC_Payload->Node_Name_of_Originator[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    ADISC_Payload->N_Port_ID_of_Originator
        = hpSwapBit32( S_ID
                     );

/*+
Return length of ADISC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ADISC_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiLinkSvcProcess_ADISC_Response_OnCard(
                                             SFThread_t *SFThread,
                                             os_bit32       Frame_Length,
                                             os_bit32       Offset_to_FCHS,
                                             os_bit32       Offset_to_Payload,
                                             os_bit32       Payload_Wrap_Offset,
                                             os_bit32       Offset_to_Payload_Wrapped
                                           )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t      *hpRoot                    = SFThread->thread_hdr.hpRoot;
    agFCDevInfo_t *DevInfo                   = &(SFThread->parent.Device->DevInfo);
    os_bit32          Hard_Address_of_Responder;
    os_bit32          Bit8_Index;

    if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Hard_Address_of_Responder)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Hard_Address_of_Responder
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_ADISC_Payload_t,
                                                                 Hard_Address_of_Responder
                                                               ) )
                                            ));
    }
    else
    {
        Hard_Address_of_Responder
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_ADISC_Payload_t,
                                                                 Hard_Address_of_Responder
                                                               ) )
                                            ));
    }

    DevInfo->HardAddress.Domain = (Hard_Address_of_Responder & 0x00FF0000) >> 16;
    DevInfo->HardAddress.Area   = (Hard_Address_of_Responder & 0x0000FF00) >>  8;
    DevInfo->HardAddress.AL_PA  = (Hard_Address_of_Responder & 0x000000FF);

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Port_Name_of_Responder[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->PortWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_ADISC_Payload_t,
                                                                        Port_Name_of_Responder[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            DevInfo->PortWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_ADISC_Payload_t,
                                                                                Port_Name_of_Responder[Bit8_Index]
                                                                              )
                                   );
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Node_Name_of_Responder[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            DevInfo->NodeWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload + hpFieldOffset(
                                                                        FC_ELS_ACC_ADISC_Payload_t,
                                                                        Node_Name_of_Responder[Bit8_Index]
                                                                      )
                                   );
        }
        else
        {
            DevInfo->NodeWWN[Bit8_Index]
                = osCardRamReadBit8(
                                     hpRoot,
                                     Offset_to_Payload_Wrapped + hpFieldOffset(
                                                                                FC_ELS_ACC_ADISC_Payload_t,
                                                                                Node_Name_of_Responder[Bit8_Index]
                                                                              )
                                   );
        }
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
    return fiLinkSvc_Cmd_Status_ACC;
}

os_bit32 fiLinkSvcProcess_ADISC_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                       Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_ELS_ACC_ADISC_Payload_t *Payload,
                                              os_bit32                       Payload_Wrap_Offset,
                                              FC_ELS_ACC_ADISC_Payload_t *Payload_Wrapped
                                            )
{
#ifndef __MemMap_Force_On_Card__
    agFCDevInfo_t *DevInfo                   = &(SFThread->parent.Device->DevInfo);
    os_bit32          Hard_Address_of_Responder;
    os_bit32          Bit8_Index;
    os_bit32          N_Port_ID_of_Responder;
/*
**    agRoot_t      *hpRoot                    = SFThread->thread_hdr.hpRoot;
*/
    if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Hard_Address_of_Responder)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Hard_Address_of_Responder = hpSwapBit32(Payload->Hard_Address_of_Responder);
    }
    else
    {
        Hard_Address_of_Responder = hpSwapBit32(Payload_Wrapped->Hard_Address_of_Responder);
    }

    if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,N_Port_ID_of_Responder)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        N_Port_ID_of_Responder = hpSwapBit32(Payload->N_Port_ID_of_Responder);
    }
    else
    {
        N_Port_ID_of_Responder = hpSwapBit32(Payload_Wrapped->N_Port_ID_of_Responder);
    }

/*
    fiLogDebugString(hpRoot,
                0,
                "  Domain %02X %02X Area %02X %02X AL_PA %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                DevInfo->CurrentAddress.Domain,
                (N_Port_ID_of_Responder & 0x00FF0000) >> 16,
                DevInfo->CurrentAddress.Area,
                (N_Port_ID_of_Responder & 0x0000FF00) >>  8,
                DevInfo->CurrentAddress.AL_PA,
                (N_Port_ID_of_Responder & 0x000000FF),
                0,0);
*/
/*Add verification here ...... */
    if( DevInfo->CurrentAddress.Domain != ((N_Port_ID_of_Responder & 0x00FF0000) >> 16))
    {
        return fiLinkSvc_Cmd_Status_RJT;
    }

    if( DevInfo->CurrentAddress.Area   != ((N_Port_ID_of_Responder & 0x0000FF00) >>  8))
    {
        return fiLinkSvc_Cmd_Status_RJT;
    }

    if( DevInfo->CurrentAddress.AL_PA  != ((N_Port_ID_of_Responder & 0x000000FF)))
    {
        return fiLinkSvc_Cmd_Status_RJT;
    }


    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Port_Name_of_Responder[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if( DevInfo->PortWWN[Bit8_Index] != Payload->Port_Name_of_Responder[Bit8_Index])
            {
                return fiLinkSvc_Cmd_Status_RJT;
            }

        }
        else
        {
            if( DevInfo->PortWWN[Bit8_Index] != Payload_Wrapped->Port_Name_of_Responder[Bit8_Index])
            {
                return fiLinkSvc_Cmd_Status_RJT;
            }
        }
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        if ((hpFieldOffset(FC_ELS_ACC_ADISC_Payload_t,Node_Name_of_Responder[Bit8_Index])
            + sizeof(os_bit8)) <= Payload_Wrap_Offset)
        {
            if( DevInfo->NodeWWN[Bit8_Index] != Payload->Node_Name_of_Responder[Bit8_Index])
            {
                return fiLinkSvc_Cmd_Status_RJT;
            }
        }
        else
        {
            if( DevInfo->NodeWWN[Bit8_Index] != Payload_Wrapped->Node_Name_of_Responder[Bit8_Index])
            {
                return fiLinkSvc_Cmd_Status_RJT;
            }
        }
    }

    return fiLinkSvc_Cmd_Status_ACC;

#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInSCR(
                     SFThread_t *SFThread
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInSCR_OnCard(
                                     SFThread
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInSCR_OffCard(
                                      SFThread
                                    );
    }
}


os_bit32 fiFillInSCR_OnCard(
                            SFThread_t *SFThread
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot               = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread              = CThread_ptr(hpRoot);
    os_bit32        SCR_Header_Offset    = SFThread->SF_CMND_Offset;
    os_bit32        SCR_Payload_Offset   = SCR_Header_Offset + sizeof(FCHS_t);
    os_bit32        D_ID;
    os_bit32        S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_SCR;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in SCR Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   FC_Well_Known_Port_ID_Fabric_Controller,
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );
    D_ID = FC_Well_Known_Port_ID_Fabric_Controller;


/*+
Fill in SCR Frame Payload
-*/
    S_ID = fiComputeCThread_S_ID(CThread );

    osCardRamWriteBit32(
                         hpRoot,
                         SCR_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_SCR_Payload_t,
                                                               ELS_Type_Command
                                                             ),
                         hpSwapBit32( FC_ELS_Type_SCR )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         SCR_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_SCR_Payload_t,
                                                               Reserved_Registration_Function
                                                             ),
                         hpSwapBit32(FC_ELS_SCR_Full_Registration)
                       );


/*+
Return length of SCR Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_SCR_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInSCR_OffCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    FCHS_t                 *SCR_Header          = SFThread->SF_CMND_Ptr;
    FC_ELS_SCR_Payload_t   *SCR_Payload         = (FC_ELS_SCR_Payload_t *)((os_bit8 *)SCR_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_SCR;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in SCR Frame Header
-*/

                                                           
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    FC_Well_Known_Port_ID_Fabric_Controller,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in SCR Frame Payload
-*/

    SCR_Payload->ELS_Type_Command = hpSwapBit32( FC_ELS_Type_SCR );

    SCR_Payload->Reserved_Registration_Function = hpSwapBit32(FC_ELS_SCR_Full_Registration);

/*+
Return length of SCR Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_SCR_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}



void fiLinkSvcProcess_TargetRequest_OnCard(
                                            agRoot_t *hpRoot,
                                            os_bit32     Frame_Length,
                                            os_bit32     Offset_to_FCHS,
                                            os_bit32     Offset_to_Payload,
                                            os_bit32     Payload_Wrap_Offset,
                                            os_bit32     Offset_to_Payload_Wrapped
                                          )
{
    TgtThread_t *TgtThread;
    FCHS_t      *TgtCmnd_FCHS;
    void        *TgtCmnd_Payload;
    os_bit32        TgtCmnd_Payload_Max     = CThread_ptr(hpRoot)->Calculation.MemoryLayout.TgtThread.elementSize - sizeof(TgtThread_t);
    os_bit32        TgtCmnd_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32        TgtCmnd_Payload_To_Copy;
    os_bit32        Bit8_Index;

    if ((TgtThread = TgtThreadAlloc(
                                     hpRoot
                                   )       ) != (TgtThread_t *)agNULL)
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_TargetRequest_OnCard(): Allocated TgtThread @ 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          TgtThread,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
        TgtCmnd_Payload = (void *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));

        TgtThread->TgtCmnd_Length = Frame_Length;

        osCardRamReadBlock(
                            hpRoot,
                            Offset_to_FCHS,
                            (void *)TgtCmnd_FCHS,
                            sizeof(FCHS_t)
                          );

        if (TgtCmnd_Payload_Size < TgtCmnd_Payload_Max)
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Size;
        }
        else /* TgtCmnd_Payload_Size >= TgtCmnd_Payload_Max */
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Max;
        }

        for (Bit8_Index = 0;
             Bit8_Index < TgtCmnd_Payload_To_Copy;
             Bit8_Index++)
        {
            if (Bit8_Index <= Payload_Wrap_Offset)
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index)
                    = osCardRamReadBit8(
                                         hpRoot,
                                         Offset_to_Payload + Bit8_Index
                                       );
            }
            else /* Bit8_Index > Payload_Wrap_Offset */
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index)
                    = osCardRamReadBit8(
                                         hpRoot,
                                         Offset_to_Payload_Wrapped + Bit8_Index
                                       );
            }
        }

        fiSendEvent( &(TgtThread->thread_hdr),TgtEventIncoming );
    }
    else /* (TgtThread = TgtThreadAlloc(
                                         hpRoot
                                       )       ) == (TgtThread_t *)agNULL */
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_TargetRequest_OnCard(): Could not allocate TgtThread !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
}

void fiLinkSvcProcess_TargetRequest_OffCard(
                                             agRoot_t *hpRoot,
                                             os_bit32     Frame_Length,
                                             FCHS_t   *FCHS,
                                             void     *Payload,
                                             os_bit32     Payload_Wrap_Offset,
                                             void     *Payload_Wrapped
                                           )
{
    TgtThread_t *TgtThread;
    FCHS_t      *TgtCmnd_FCHS;
    void        *TgtCmnd_Payload;
    os_bit32        TgtCmnd_Payload_Max     = CThread_ptr(hpRoot)->Calculation.MemoryLayout.TgtThread.elementSize - sizeof(TgtThread_t);
    os_bit32        TgtCmnd_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32        TgtCmnd_Payload_To_Copy;
    os_bit32        Bit8_Index;

    if ((TgtThread = TgtThreadAlloc(
                                     hpRoot
                                   )       ) != (TgtThread_t *)agNULL)
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_TargetRequest_OffCard(): Allocated TgtThread @ 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          TgtThread,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
        TgtCmnd_Payload = (void *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));

        TgtThread->TgtCmnd_Length = Frame_Length;

        *TgtCmnd_FCHS = *FCHS;

        if (TgtCmnd_Payload_Size < TgtCmnd_Payload_Max)
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Size;
        }
        else /* TgtCmnd_Payload_Size >= TgtCmnd_Payload_Max */
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Max;
        }

        for (Bit8_Index = 0;
             Bit8_Index < TgtCmnd_Payload_To_Copy;
             Bit8_Index++)
        {
            if (Bit8_Index <= Payload_Wrap_Offset)
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index) = *((os_bit8 *)Payload + Bit8_Index);
            }
            else /* Bit8_Index > Payload_Wrap_Offset */
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index) = *((os_bit8 *)Payload_Wrapped + Bit8_Index);
            }
        }

        fiSendEvent( &(TgtThread->thread_hdr), TgtEventIncoming );
    }
    else /* (TgtThread = TgtThreadAlloc(
                                         hpRoot
                                       )       ) == (TgtThread_t *)agNULL */
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcess_TargetRequest_OffCard(): Could not allocate TgtThread !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
}

os_bit32 fiLinkSvcProcessSFQ(
                           agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           fi_thread__t       **Thread_to_return
                         )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inCardRam)
    {
        return fiLinkSvcProcessSFQ_OnCard(
                                           hpRoot,
                                           SFQConsIndex,
                                           Frame_Length,
                                           Thread_to_return
                                         );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inDmaMemory */
    {
        return fiLinkSvcProcessSFQ_OffCard(
                                            hpRoot,
                                            SFQConsIndex,
                                            Frame_Length,
                                            Thread_to_return
                                          );
    }
}

os_bit32 fiLinkSvcProcessSFQ_OnCard(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    os_bit32                       Offset_to_FCHS             = SFQ_MemoryDescriptor->addr.CardRam.cardRamOffset
                                                             + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize);
    os_bit32                       Offset_to_Payload          = Offset_to_FCHS + sizeof(FCHS_t);
    os_bit32                       Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    os_bit32                       Offset_to_Payload_Wrapped  = Offset_to_Payload
                                                             - SFQ_MemoryDescriptor->objectSize;
    os_bit32                       R_CTL__D_ID;
    os_bit32                       TYPE__F_CTL;
    os_bit32                       Recv_BLS_Type;
    os_bit32                       Recv_ELS_Type;
    os_bit32                       Sent_LinkSvc_Type;
    X_ID_t                      OX_ID;
    X_ID_t                      RX_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                       CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    CDBThread_t                *CDBThread;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                       SFThread_X_ID_Offset       = CDBThread_X_ID_Max + 1;
    os_bit32                       SFThread_X_ID_Max          = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    SFThread_t                 *SFThread;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    OX_ID = (X_ID_t)(((osCardRamReadBit32(
                                           hpRoot,
                                           Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                         ) & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RX_ID = (X_ID_t)(((osCardRamReadBit32(
                                           hpRoot,
                                           Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                         ) & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    R_CTL__D_ID = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,R_CTL__D_ID)
                                    );

    TYPE__F_CTL = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                    );

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_BLS)
    {
        /* Process Basic Link Service Frame */

        if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
        {
            /* Starting here, this function only understands BLS Responses */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    TYPE__F_CTL==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              TYPE__F_CTL,
                              0,0,0,0,0,0,0
                              );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    R_CTL__D_ID 0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              R_CTL__D_ID,
                              0,0,0,0,0,0,0
                             );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        Recv_BLS_Type = R_CTL__D_ID & FC_Frame_Header_R_CTL_Lo_MASK;

        if ((Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT)
            && (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC))
        {
            /* Starting here, this function only understands BLS Responses (i.e. Rejects and Accepts) */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT) && (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    Recv_BLS_Type==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Recv_BLS_Type,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        if (OX_ID > CDBThread_X_ID_Max)
        {
            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (OX_ID > CDBThread_X_ID_Max)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    OX_ID==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              OX_ID,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                    + (OX_ID * CDBThread_MemoryDescriptor->elementSize));

        SFThread = CDBThread->SFThread_Request.SFThread;

        *Thread_to_return = (fi_thread__t *)SFThread;

        if( SFThread == (SFThread_t *) agNULL )
        {
            return fiLinkSvc_Cmd_Status_Confused;
        }

        Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

        SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

        if (Recv_BLS_Type == FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT)
        {
            /* Simply indicate that the command was rejected */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard(): BLS Command [0x%08X] rejected",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                            );

            return fiLinkSvc_Cmd_Status_RJT;
        }

        switch(Sent_LinkSvc_Type)
        {
            case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                fiLinkSvcProcess_ABTS_Response_OnCard(
                                                       SFThread,
                                                       Frame_Length,
                                                       Offset_to_FCHS,
                                                       Offset_to_Payload,
                                                       Payload_Wrap_Offset,
                                                       Offset_to_Payload_Wrapped
                                                     );
                break;

            default:
                /* Unknown LinkSvc Command recorded in SFThread */

                fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard(): Unknown LinkSvc Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                              );

                return fiLinkSvc_Cmd_Status_Confused;
        }

        return fiLinkSvc_Cmd_Status_ACC;
    }

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_ELS)
    {
        /* Starting here, this function only understands ELS Frames */

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "fiLinkSvcProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "    (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_ELS",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "A    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((hpFieldOffset(FC_ELS_Unknown_Payload_t,ELS_Type) + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Recv_ELS_Type = hpSwapBit32(osCardRamReadBit32(
                                                        hpRoot,
                                                        Offset_to_Payload + hpFieldOffset(FC_ELS_Unknown_Payload_t,ELS_Type)
                                                      ));
    }
    else
    {
        Recv_ELS_Type = hpSwapBit32(osCardRamReadBit32(
                                                        hpRoot,
                                                        Offset_to_Payload_Wrapped + hpFieldOffset(FC_ELS_Unknown_Payload_t,ELS_Type)
                                                      ));
    }

    if ((Recv_ELS_Type & FC_ELS_Type_LoopInit_Code_MASK) == FC_ELS_Type_LoopInit_Code_LILP)
    {
        fiLinkSvcProcess_LILP_OnCard(
                                      hpRoot,
                                      Frame_Length,
                                      Offset_to_FCHS,
                                      Offset_to_Payload,
                                      Payload_Wrap_Offset,
                                      Offset_to_Payload_Wrapped
                                    );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Position_Map;
    }

    Recv_ELS_Type &= FC_ELS_Type_MASK;

    if ((TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        if (Recv_ELS_Type == FC_ELS_Type_PLOGI)
        {
            return fiLinkSvcProcess_PLOGI_Request_OnCard(
                                                          hpRoot,
                                                          OX_ID,
                                                          Frame_Length,
                                                          Offset_to_FCHS,
                                                          Offset_to_Payload,
                                                          Payload_Wrap_Offset,
                                                          Offset_to_Payload_Wrapped,
                                                          Thread_to_return
                                                        );
        }
        else /* Recv_ELS_Type != FC_ELS_Type_PLOGI */
        {
            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogTraceHideLevel,
                              "fiLinkSvcProcessSFQ_OnCard(): Recv_ELS_Type(=0x%08X) != FC_ELS_Type_PLOGI",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Recv_ELS_Type,
                              0,0,0,0,0,0,0
                            );

            fiLinkSvcProcess_TargetRequest_OnCard(
                                                   hpRoot,
                                                   Frame_Length,
                                                   Offset_to_FCHS,
                                                   Offset_to_Payload,
                                                   Payload_Wrap_Offset,
                                                   Offset_to_Payload_Wrapped
                                                 );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_TargetRequest;
        }
    }

    if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
    {
        /* Starting here, this function only understands ELS Responses */

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((Recv_ELS_Type != FC_ELS_Type_LS_RJT)
        && (Recv_ELS_Type != FC_ELS_Type_ACC))
    {
        /* Starting here, this function only understands ELS Responses (i.e. Rejects and Accepts) */

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (Recv_ELS_Type != FC_ELS_Type_LS_RJT) && (Recv_ELS_Type != FC_ELS_Type_ACC)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    Recv_ELS_Type==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Recv_ELS_Type,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    *Thread_to_return = (fi_thread__t *)SFThread;

    Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

    if (Recv_ELS_Type == FC_ELS_Type_LS_RJT)
    {
        /* Simply indicate that the command was rejected */

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OnCard(): ELS Command [0x%08X] rejected",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Sent_LinkSvc_Type,
                          0,0,0,0,0,0,0
                        );

        return fiLinkSvc_Cmd_Status_RJT;
    }

    switch(Sent_LinkSvc_Type)
    {
        case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
            fiLinkSvcProcess_PLOGI_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
            fiLinkSvcProcess_FLOGI_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_RRQ:
            fiLinkSvcProcess_RRQ_Response_OnCard(
                                                  SFThread,
                                                  Frame_Length,
                                                  Offset_to_FCHS,
                                                  Offset_to_Payload,
                                                  Payload_Wrap_Offset,
                                                  Offset_to_Payload_Wrapped
                                                );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_LOGO:
            fiLinkSvcProcess_LOGO_Response_OnCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   Offset_to_FCHS,
                                                   Offset_to_Payload,
                                                   Payload_Wrap_Offset,
                                                   Offset_to_Payload_Wrapped
                                                 );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_PRLI:
            fiLinkSvcProcess_PRLI_Response_OnCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   Offset_to_FCHS,
                                                   Offset_to_Payload,
                                                   Payload_Wrap_Offset,
                                                   Offset_to_Payload_Wrapped
                                                 );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_PRLO:
            fiLinkSvcProcess_PRLO_Response_OnCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   Offset_to_FCHS,
                                                   Offset_to_Payload,
                                                   Payload_Wrap_Offset,
                                                   Offset_to_Payload_Wrapped
                                                 );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_ADISC:
            /* ADISC can fail verification */
            return (fiLinkSvcProcess_ADISC_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  ));

        case SFThread_SF_CMND_LinkSvc_Type_SCR:
            /* We just recieve an ACCept or a REJect from SCR. No processing of the payload
               is required. */
            break;

        case SFThread_SF_CMND_LinkSvc_Type_SRR:
            /*
            fiLinkSvcProcess_SRR_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  );
            */
            break;

        case SFThread_SF_CMND_LinkSvc_Type_REC:
            fiLinkSvcProcess_REC_Response_OnCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    Offset_to_FCHS,
                                                    Offset_to_Payload,
                                                    Payload_Wrap_Offset,
                                                    Offset_to_Payload_Wrapped
                                                  );
            break;

        default:
            /* Unknown LinkSvc Command recorded in SFThread */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OnCard(): Unknown LinkSvc Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                            );

            return fiLinkSvc_Cmd_Status_Confused;
    }

    return fiLinkSvc_Cmd_Status_ACC;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiLinkSvcProcessSFQ_OffCard(
                                   agRoot_t        *hpRoot,
                                   SFQConsIndex_t   SFQConsIndex,
                                   os_bit32            Frame_Length,
                                   fi_thread__t       **Thread_to_return
                                 )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    FCHS_t                     *FCHS                       = (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                                                        + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize));
    FC_ELS_Unknown_Payload_t   *Payload                    = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));
    os_bit32                    Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    FC_ELS_Unknown_Payload_t   *Payload_Wrapped            = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)Payload
                                                                                          - SFQ_MemoryDescriptor->objectSize);
    os_bit32                    R_CTL__D_ID                = FCHS->R_CTL__D_ID;
    os_bit32                    TYPE__F_CTL                = FCHS->TYPE__F_CTL;
    os_bit32                    Recv_BLS_Type;
    os_bit32                    Recv_ELS_Type;
    os_bit32                    RejectReason               = 0;
    os_bit32                    Sent_LinkSvc_Type;
    X_ID_t                      OX_ID;
    X_ID_t                      RX_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                    CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    CDBThread_t                *CDBThread;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset       = CDBThread_X_ID_Max + 1;
    os_bit32                    SFThread_X_ID_Max          = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    SFThread_t                 *SFThread;
    os_bit32 * DisplayPayload = (os_bit32 * )Payload;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    OX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "   (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

    }

    
    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_BLS)
    {
        /* Process Basic Link Service Frame */

        if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
        {
            /* Starting here, this function only understands BLS Responses */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    TYPE__F_CTL==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              TYPE__F_CTL,
                              0,0,0,0,0,0,0
                              );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    R_CTL__D_ID 0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              R_CTL__D_ID,
                              0,0,0,0,0,0,0
                             );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        Recv_BLS_Type = R_CTL__D_ID & FC_Frame_Header_R_CTL_Lo_MASK;

        if(Recv_BLS_Type == FC_ELS_Type_ECHO)
        {
            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_TargetRequest;

        }


        if ((Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT)
            && (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC))
        {
            /* Starting here, this function only understands BLS Responses (i.e. Rejects and Accepts) */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT) && (Recv_BLS_Type != FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    Recv_BLS_Type==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Recv_BLS_Type,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

        if (OX_ID > CDBThread_X_ID_Max)
        {
            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard():",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    (OX_ID > CDBThread_X_ID_Max)",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "    OX_ID==0x%08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              OX_ID,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_Confused;
        }

    if ((OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "   (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          " CDB   OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

    }


        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                    + (OX_ID * CDBThread_MemoryDescriptor->elementSize));

        SFThread = CDBThread->SFThread_Request.SFThread;

        *Thread_to_return = (fi_thread__t *)SFThread;

        if( SFThread == (SFThread_t *) agNULL )
        {   /* Maybe Status No SF Thread ???? */
            return fiLinkSvc_Cmd_Status_Confused;
        }

        Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

        SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

        if (Recv_BLS_Type == FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT)
        {
            /* Simply indicate that the command was rejected */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard(): BLS Command [0x%08X] rejected",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                            );

            return fiLinkSvc_Cmd_Status_RJT;
        }

        switch(Sent_LinkSvc_Type)
        {
            case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                fiLinkSvcProcess_ABTS_Response_OffCard(
                                                        SFThread,
                                                        Frame_Length,
                                                        FCHS,
                                                        (FC_BA_ACC_Payload_t *)Payload,
                                                        Payload_Wrap_Offset,
                                                        (FC_BA_ACC_Payload_t *)Payload_Wrapped
                                                      );
                break;

            default:
                /* Unknown LinkSvc Command recorded in SFThread */

                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLogConsoleLevel,
                                  "fiLinkSvcProcessSFQ_OffCard(): Unknown LinkSvc Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  Sent_LinkSvc_Type,
                                  0,0,0,0,0,0,0
                                );
                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLogConsoleLevel,
                                  "A SFThread %p  LinkSvc Command [0x%02X] Class [0x%02X] State [0x%02X]",
                                  (char *)agNULL,(char *)agNULL,
                                  SFThread,(void *)agNULL,
                                  (os_bit32)SFThread->SF_CMND_Class,
                                  (os_bit32)SFThread->SF_CMND_Type,
                                  (os_bit32)SFThread->SF_CMND_State,
                                  0,0,0,0,0
                                );

                return fiLinkSvc_Cmd_Status_Confused;
        }

        return fiLinkSvc_Cmd_Status_ACC;
    }

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_ELS)
    {
        /* Starting here, this function only understands ELS Frames */

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "    (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_ELS",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          CStateLogConsoleHideInboundErrors,
                          "B    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );
    /* SRR's can cause a FC4 Link Data Reply RCtl  So its a FCP response to a SF request */
        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );

        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *(DisplayPayload+0),
                        *(DisplayPayload+1),
                        *(DisplayPayload+2),
                        *(DisplayPayload+3),
                        *(DisplayPayload+4),
                        *(DisplayPayload+5),
                        *(DisplayPayload+6),
                        *(DisplayPayload+7));

        if( ( FCHS->R_CTL__D_ID & FCHS_R_CTL_MASK ) == 0x33000000)
        {
            OX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

            if (OX_ID > CDBThread_X_ID_Max && OX_ID < SFThread_X_ID_Max)
            {

                SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                          + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

                *Thread_to_return = (fi_thread__t *)SFThread;

                Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

                SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

                if( *(DisplayPayload+0) == 0x01000000)
                {
                    return fiLinkSvc_Cmd_Status_RJT;
                }
                else
                {
                    return fiLinkSvc_Cmd_Status_ACC;
                }

            }
        }
        else
        {
            if( ( FCHS->R_CTL__D_ID & FCHS_R_CTL_MASK ) == 0x05000000)
            {    /* Xfer ready */

                OX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

                if (OX_ID < CDBThread_X_ID_Max )
                {

                    CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                                + (OX_ID * CDBThread_MemoryDescriptor->elementSize));

                    fiLogDebugString(hpRoot,
                                    SF_FCP_LogConsoleLevel,
                                    "XRDY CDB %p X_ID %X",
                                    (void *)agNULL,(char *)agNULL,
                                    CDBThread,(void *)agNULL,
                                    OX_ID,
                                    0,0,0,0,0,0,0);


                    *Thread_to_return = (fi_thread__t *)CDBThread;

                    CDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY;
                    CDBThread->CDB_CMND_Status= SFThread_SF_CMND_Status_CDB_FC_TapeInitiatorReSend_Data;

                    return fiLinkSvc_Cmd_Status_FC_Tape_XRDY;

                }

            }
            else
            {
                fiLogDebugString(hpRoot,
                            SF_FCP_LogConsoleLevel,
                            "( FCHS->R_CTL__D_ID & FCHS_R_CTL_MASK ) == %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            ( FCHS->R_CTL__D_ID & FCHS_R_CTL_MASK ),
                            0,0,0,0,0,0,0);

                *Thread_to_return = (fi_thread__t *)agNULL;
                return fiLinkSvc_Cmd_Status_Confused;
            }
        }
    }

    if ((hpFieldOffset(FC_ELS_Unknown_Payload_t,ELS_Type) + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Recv_ELS_Type = hpSwapBit32(Payload->ELS_Type);
    }
    else
    {
        Recv_ELS_Type = hpSwapBit32(Payload_Wrapped->ELS_Type);
    }

    if ((Recv_ELS_Type & FC_ELS_Type_LoopInit_Code_MASK) == FC_ELS_Type_LoopInit_Code_LILP)
    {
        fiLinkSvcProcess_LILP_OffCard(
                                       hpRoot,
                                       Frame_Length,
                                       FCHS,
                                       (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)Payload,
                                       Payload_Wrap_Offset,
                                       (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)Payload_Wrapped
                                     );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Position_Map;
    }

    Recv_ELS_Type &= FC_ELS_Type_MASK;

    if ((TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        if (Recv_ELS_Type == FC_ELS_Type_PLOGI)
        {
            return fiLinkSvcProcess_PLOGI_Request_OffCard(
                                                           hpRoot,
                                                           OX_ID,
                                                           Frame_Length,
                                                           FCHS,
                                                           (FC_ELS_PLOGI_Payload_t *)Payload,
                                                           Payload_Wrap_Offset,
                                                           (FC_ELS_PLOGI_Payload_t *)Payload_Wrapped,
                                                           Thread_to_return
                                                         );
        }
#ifdef _DvrArch_1_30_
        else if (Recv_ELS_Type == FC_ELS_Type_FARP_REQ)
	{
            return fiLinkSvcProcess_FARP_Request_OffCard(
                                                           hpRoot,
                                                           OX_ID,
                                                           Frame_Length,
                                                           FCHS,
                                                           (FC_ELS_FARP_REQ_Payload_t *)Payload,
                                                           Payload_Wrap_Offset,
                                                           (FC_ELS_FARP_REQ_Payload_t *)Payload_Wrapped,
                                                           Thread_to_return
                                                         );
	}
#endif /* _DvrArch_1_30_ was defined */
        else /* Recv_ELS_Type != FC_ELS_Type_PLOGI or FC_ELS_Type_FARP_REQ */
        {
            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard(): Recv_ELS_Type(=0x%08X) != FC_ELS_Type_PLOGI",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Recv_ELS_Type,
                              0,0,0,0,0,0,0
                            );

            fiLinkSvcProcess_TargetRequest_OffCard(
                                                    hpRoot,
                                                    Frame_Length,
                                                    FCHS,
                                                    (void *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (void *)Payload_Wrapped
                                                  );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiLinkSvc_Cmd_Status_TargetRequest;
        }
    }

    if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
    {
        /* Starting here, this function only understands ELS Responses */

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                          );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "R_CTL__D_ID 0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          R_CTL__D_ID,
                          0,0,0,0,0,0,0
                         );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((Recv_ELS_Type != FC_ELS_Type_LS_RJT)
#ifdef _DvrArch_1_30_
        && (Recv_ELS_Type != FC_ELS_Type_FARP_REPLY)
#endif /* _DvrArch_1_30_ was defined */
        && (Recv_ELS_Type != FC_ELS_Type_ACC))
    {
        /* Starting here, this function only understands ELS Responses (i.e. Rejects and Accepts) */
        if(Frame_Length == 0x20)
        { /* Find where this is spec'd out - F_RJT Link control frames */
            if( (R_CTL__D_ID & 0xff000000) == 0xC3000000 )
            {

                    if ( (OX_ID > SFThread_X_ID_Max))
                    {
                        fiLogDebugString(
                                          hpRoot,
                                          LinkSvcLogConsoleLevel,
                                          "fiLinkSvcProcessSFQ_OffCard():",
                                          (char *)agNULL,(char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          0,0,0,0,0,0,0,0
                                        );

                        fiLogDebugString(
                                          hpRoot,
                                          LinkSvcLogConsoleLevel,
                                          "   (OX_ID > SFThread_X_ID_Max)",
                                          (char *)agNULL,(char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          0,0,0,0,0,0,0,0
                                        );

                        fiLogDebugString(
                                          hpRoot,
                                          LinkSvcLogConsoleLevel,
                                          " SF Rej    OX_ID==0x%08X",
                                          (char *)agNULL,(char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          OX_ID,
                                          0,0,0,0,0,0,0
                                        );
                    }

                SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                          + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

                *Thread_to_return = (fi_thread__t *)SFThread;

                Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

                SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

                return fiLinkSvc_Cmd_Status_RJT;
            }
            else
            {   /* With Vixel should not take this branch */
                fiLogDebugString(
                                  hpRoot,
                                  LinkSvcLogConsoleLevel,
                                  "Fail R_CTL__D_ID 0x%08X",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  R_CTL__D_ID,
                                  0,0,0,0,0,0,0
                                 );
                if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
                {
                    fiLogDebugString(
                                      hpRoot,
                                      LinkSvcLogConsoleLevel,
                                      "fiLinkSvcProcessSFQ_OffCard():",
                                      (char *)agNULL,(char *)agNULL,
                                      (void *)agNULL,(void *)agNULL,
                                      0,0,0,0,0,0,0,0
                                    );

                    fiLogDebugString(
                                      hpRoot,
                                      LinkSvcLogConsoleLevel,
                                      "   (OX_ID > SFThread_X_ID_Max)",
                                      (char *)agNULL,(char *)agNULL,
                                      (void *)agNULL,(void *)agNULL,
                                      0,0,0,0,0,0,0,0
                                    );

                    fiLogDebugString(
                                      hpRoot,
                                      LinkSvcLogConsoleLevel,
                                      "B    OX_ID==0x%08X",
                                      (char *)agNULL,(char *)agNULL,
                                      (void *)agNULL,(void *)agNULL,
                                      OX_ID,
                                      0,0,0,0,0,0,0
                                    );

                }

                SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                          + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

                *Thread_to_return = (fi_thread__t *)SFThread;

                Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

                SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;


                return fiLinkSvc_Cmd_Status_RJT;
            }

        }


        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (Recv_ELS_Type != FC_ELS_Type_LS_RJT) && (Recv_ELS_Type != FC_ELS_Type_ACC)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    Recv_ELS_Type==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Recv_ELS_Type,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "R_CTL__D_ID 0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          R_CTL__D_ID,
                          0,0,0,0,0,0,0
                         );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLog_ERROR_Level,
                          "%s %p %08X %08X %08X",
                          "REJ_Response",(char *)agNULL,
                          DisplayPayload,(void *)agNULL,
                          hpSwapBit32(* DisplayPayload ),
                          hpSwapBit32(*(DisplayPayload+1)),
                          hpSwapBit32(*(DisplayPayload+2)),
                          0,0,0,0,0 );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    if ((OX_ID < SFThread_X_ID_Offset) || (OX_ID > SFThread_X_ID_Max))
    {
        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    (OX_ID < SFThread_X_ID_Offset) | (OX_ID > SFThread_X_ID_Max)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "    OX_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          OX_ID,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiLinkSvc_Cmd_Status_Confused;
    }

    SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    *Thread_to_return = (fi_thread__t *)SFThread;

    Sent_LinkSvc_Type = SFThread->SF_CMND_Type;

    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Finished;

    if (Recv_ELS_Type == FC_ELS_Type_LS_RJT)
    {
        /* Simply indicate that the command was rejected */
        RejectReason = hpSwapBit32( *(DisplayPayload+1));
        SFThread->RejectReasonCode = (os_bit8)((RejectReason & FC_ELS_LS_RJT_Reason_Code_MASK ) >>  FC_ELS_LS_RJT_Reason_Code_Shift);
        SFThread->RejectExplanation = (os_bit8)((RejectReason & FC_ELS_LS_RJT_Reason_Explanation_MASK ) >> FC_ELS_LS_RJT_Reason_Explanation_Shift );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard(): ELS Command [0x%08X] rejected %08X %08X %x %x %x",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Sent_LinkSvc_Type,
                          hpSwapBit32( *(DisplayPayload+0)),
                          hpSwapBit32( *(DisplayPayload+1)),
                          RejectReason,
                          SFThread->RejectReasonCode,
                          SFThread->RejectExplanation,
                          0,0 );

        fiLogDebugString(hpRoot,
                        LinkSvcLogConsoleLevel,
                        "FCHS %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );

        fiLogDebugString(
                          hpRoot,
                          LinkSvcLogConsoleLevel,
                          "fiLinkSvcProcessSFQ_OffCard(): Frame_Length %X ",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Frame_Length,
                          0,0,0,0,0,0,0
                        );

        return fiLinkSvc_Cmd_Status_RJT;
    }

    switch(Sent_LinkSvc_Type)
    {
        case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
            fiLinkSvcProcess_PLOGI_Response_OffCard(
                                                     SFThread,
                                                     Frame_Length,
                                                     FCHS,
                                                     (FC_ELS_ACC_PLOGI_Payload_t *)Payload,
                                                     Payload_Wrap_Offset,
                                                     (FC_ELS_ACC_PLOGI_Payload_t *)Payload_Wrapped
                                                   );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
            fiLinkSvcProcess_FLOGI_Response_OffCard(
                                                     SFThread,
                                                     Frame_Length,
                                                     FCHS,
                                                     (FC_ELS_ACC_FLOGI_Payload_t *)Payload,
                                                     Payload_Wrap_Offset,
                                                     (FC_ELS_ACC_FLOGI_Payload_t *)Payload_Wrapped
                                                   );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_LOGO:
            fiLinkSvcProcess_LOGO_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_GENERIC_ACC_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_GENERIC_ACC_Payload_t *)Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_RRQ:
            fiLinkSvcProcess_RRQ_Response_OffCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   FCHS,
                                                   (FC_ELS_ACC_RRQ_Payload_t *)Payload,
                                                   Payload_Wrap_Offset,
                                                   (FC_ELS_ACC_RRQ_Payload_t *)Payload_Wrapped
                                                 );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_PRLI:
            fiLinkSvcProcess_PRLI_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_ACC_PRLI_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_ACC_PRLI_Payload_t *)Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_PRLO:
            fiLinkSvcProcess_PRLO_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_ACC_PRLO_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_ACC_PRLO_Payload_t *)Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_ADISC:
            /* ADISC can fail verification */
            return ( fiLinkSvcProcess_ADISC_Response_OffCard(
                                                     SFThread,
                                                     Frame_Length,
                                                     FCHS,
                                                     (FC_ELS_ACC_ADISC_Payload_t *)Payload,
                                                     Payload_Wrap_Offset,
                                                     (FC_ELS_ACC_ADISC_Payload_t *)Payload_Wrapped
                                                   ));

        case SFThread_SF_CMND_LinkSvc_Type_SCR:
               /* We just recieve an ACCept or a REJect from SCR. No processing of the payload
               is required. */
            break;

        case SFThread_SF_CMND_LinkSvc_Type_SRR:
            fiLinkSvcProcess_SRR_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_GENERIC_ACC_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_GENERIC_ACC_Payload_t *)Payload_Wrapped
                                                  );
            break;

        case SFThread_SF_CMND_LinkSvc_Type_REC:
            fiLinkSvcProcess_REC_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_REC_ACC_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_REC_ACC_Payload_t *)Payload_Wrapped
                                                  );
            break;
#ifdef _DvrArch_1_30_
        case SFThread_SF_CMND_LinkSvc_Type_FARP_REQ:
            fiLinkSvcProcess_FARP_Response_OffCard(
                                                    SFThread,
                                                    Frame_Length,
                                                    FCHS,
                                                    (FC_ELS_FARP_REPLY_Payload_t *)Payload,
                                                    Payload_Wrap_Offset,
                                                    (FC_ELS_FARP_REPLY_Payload_t *)Payload_Wrapped
                                                  );
            break;
#endif /* _DvrArch_1_30_ was defined */
        default:
            /* Unknown LinkSvc Command recorded in SFThread */

            fiLogDebugString(
                              hpRoot,
                              LinkSvcLogConsoleLevel,
                              "fiLinkSvcProcessSFQ_OffCard(): Unknown LinkSvc Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_LinkSvc_Type,
                              0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                            hpRoot,
                            LinkSvcLogConsoleLevel,
                            "B SFThread %p LinkSvc Command [0x%02X] Class [0x%02X] State [0x%02X]",
                            (char *)agNULL,(char *)agNULL,
                            SFThread,(void *)agNULL,
                            (os_bit32)SFThread->SF_CMND_Class,
                            (os_bit32)SFThread->SF_CMND_Type,
                            (os_bit32)SFThread->SF_CMND_State,
                            0,0,0,0,0
                            );
            return fiLinkSvc_Cmd_Status_Confused;
    }

    return fiLinkSvc_Cmd_Status_ACC;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInADISC_ACC(
                                   SFThread_t *SFThread,
                                   os_bit32       D_ID,
                                   os_bit32       OX_ID
                   )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInADISC_ACC_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID
                                   );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInADISC_ACC_OffCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID
                                    );
    }

}

os_bit32 fiFillInADISC_ACC_OnCard(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID
                          )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot               = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread              = CThread_ptr(hpRoot);
    os_bit32        ADISC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        ADISC_Payload_Offset = ADISC_Header_Offset + sizeof(FCHS_t);
    os_bit32        Bit8_Index;
    os_bit32        S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ADISC_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in ADISC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   D_ID,
                                   OX_ID,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                 );


/*+
Fill in ADISC Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;
    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               ELS_Type
                                                             ),
                         hpSwapBit32( FC_ELS_Type_ACC )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               Hard_Address_of_Originator
                                                             ),
                         hpSwapBit32(   (CThread->ChanInfo.CurrentAddress.Domain << 16)
                                      | (CThread->ChanInfo.CurrentAddress.Area   <<  8)
                                      | CThread->ChanInfo.CurrentAddress.AL_PA          )
                       );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            ADISC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ADISC_Payload_t,
                                                                  Port_Name_of_Originator[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.PortWWN[Bit8_Index]
                          );
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            ADISC_Payload_Offset + hpFieldOffset(
                                                                  FC_ELS_ADISC_Payload_t,
                                                                  Node_Name_of_Originator[Bit8_Index]
                                                                ),
                            CThread->ChanInfo.NodeWWN[Bit8_Index]
                          );
    }

    osCardRamWriteBit32(
                         hpRoot,
                         ADISC_Payload_Offset + hpFieldOffset(
                                                               FC_ELS_ADISC_Payload_t,
                                                               N_Port_ID_of_Originator
                                                             ),
                         hpSwapBit32(S_ID )
                       );

/*+
Return length of ADISC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ADISC_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInADISC_ACC_OffCard(
                             SFThread_t *SFThread,
                             os_bit32       D_ID,
                             os_bit32       OX_ID
                           )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t              *CThread             = CThread_ptr(SFThread->thread_hdr.hpRoot);
    DevThread_t            *DevThread           = SFThread->parent.Device;
    FCHS_t                 *ADISC_Header        = SFThread->SF_CMND_Ptr;
    FC_ELS_ADISC_Payload_t *ADISC_Payload       = (FC_ELS_ADISC_Payload_t *)((os_bit8 *)ADISC_Header + sizeof(FCHS_t));
    os_bit32                   Bit8_Index;
    os_bit32                   S_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_ADISC_ACC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in ADISC Frame Header
-*/

    D_ID  = fiComputeDevThread_D_ID(DevThread);
                                                           
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    OX_ID,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Responder |
                                    FC_Frame_Header_F_CTL_Last_Sequence
                                  );

/*+
Fill in ADISC Frame Payload
-*/

    ADISC_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_ACC );

    ADISC_Payload->Hard_Address_of_Originator
        = hpSwapBit32(   (CThread->ChanInfo.CurrentAddress.Domain << 16)
                       | (CThread->ChanInfo.CurrentAddress.Area   <<  8)
                       | CThread->ChanInfo.CurrentAddress.AL_PA          );

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_N_Port_Name_t);
         Bit8_Index++)
    {
        ADISC_Payload->Port_Name_of_Originator[Bit8_Index] = CThread->ChanInfo.PortWWN[Bit8_Index];
    }

    for (Bit8_Index = 0;
         Bit8_Index < sizeof(FC_Node_Name_t);
         Bit8_Index++)
    {
        ADISC_Payload->Node_Name_of_Originator[Bit8_Index] = CThread->ChanInfo.NodeWWN[Bit8_Index];
    }
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    ADISC_Payload->N_Port_ID_of_Originator
        = hpSwapBit32( S_ID
                     );

/*+
Return length of ADISC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_ADISC_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}


os_bit32 fiFillInSRR(
                    SFThread_t *SFThread,
                    os_bit32       OXID,
                    os_bit32       RXID,
                    os_bit32       Relative_Offset,
                    os_bit32       R_CTL
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInSRR_OnCard(
                                    SFThread,
                                    OXID, 
                                    RXID,
                                    Relative_Offset,
                                    R_CTL
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInSRR_OffCard(
                                     SFThread,
                                     OXID,
                                     RXID,
                                     Relative_Offset,
                                     R_CTL
                                   );
    }
}

os_bit32 fiFillInSRR_OnCard(
                           SFThread_t *SFThread,
                           os_bit32       OXID,
                           os_bit32       RXID,
                           os_bit32       Relative_Offset,
                           os_bit32       R_CTL
                        )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    DevThread_t *DevThread           = SFThread->parent.Device;
    os_bit32        SRR_Header_Offset   = SFThread->SF_CMND_Offset;
    os_bit32        SRR_Payload_Offset  = SRR_Header_Offset + sizeof(FCHS_t);
    os_bit32        S_ID=0;
    os_bit32        D_ID;
    os_bit32        OXID_RXID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_SRR;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in SRR Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in SRR Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         SRR_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_SRR_Payload_t,
                                                              ELS_Type
                                                            ),
                         hpSwapBit32( FC_ELS_Type_SRR )
                       );

    D_ID = fiComputeDevThread_D_ID(
                                                            DevThread
                                                          );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    osCardRamWriteBit32(
                         hpRoot,
                         SRR_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_SRR_Payload_t,
                                                              Relative_Offset
                                                            ),
                         hpSwapBit32(Relative_Offset)
                       );

    OXID_RXID       =       (OXID << FC_ELS_SRR_OXID_SHIFT) | RXID;

    osCardRamWriteBit32(
                        hpRoot,
                        SRR_Payload_Offset + hpFieldOffset(
                                                            FC_ELS_SRR_Payload_t,
                                                            OXID_RXID
                                                           ),
                        hpSwapBit32(OXID_RXID)
                        );
 

/*+
Return length of SRR Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_SRR_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInSRR_OffCard(
                            SFThread_t *SFThread,
                            os_bit32       OXID,
                            os_bit32       RXID,
                            os_bit32       Relative_Offset,
                            os_bit32       R_CTL
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t             *CThread      = CThread_ptr(SFThread->thread_hdr.hpRoot);
    CDBThread_t           *CdbThread    = SFThread->parent.CDB;
    DevThread_t           *DevThread    = CdbThread->Device;
    FCHS_t                *SRR_Header   = SFThread->SF_CMND_Ptr;
    FC_ELS_SRR_Payload_t  *SRR_Payload  = (FC_ELS_SRR_Payload_t *)((os_bit8 *)SRR_Header + sizeof(FCHS_t));
/*    os_bit32                  Bit8_Index; */
    os_bit32                  S_ID=0;
    os_bit32                  D_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_SRR;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in SRR Frame Header
-*/

    D_ID =  fiComputeDevThread_D_ID( DevThread); 
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in SRR Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;
    
    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "Out %s D_ID %X S_ID %0X OXID %X RXID %X",
                    "fiFillInSRR_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    D_ID,
                    S_ID,
                    OXID,
                    RXID,
                    0,0,0,0);

    OXID = 0xFFFF;

    SRR_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_SRR );

/* ??????? Switched oxid and rxid */
    SRR_Payload->OXID_RXID     = hpSwapBit32(( RXID << FC_ELS_SRR_OXID_SHIFT) |OXID);

/* Was this
    SRR_Payload->OXID_RXID = hpSwapBit32((OXID << FC_ELS_SRR_OXID_SHIFT) | RXID);
*/        

    SRR_Payload->Relative_Offset       =  hpSwapBit32(Relative_Offset);
    SRR_Payload->R_CTL_For_IU_Reserved =  hpSwapBit32(R_CTL << FC_ELS_R_CTL_FOR_IU_SHIFT);

    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "Out %s OXID_RXID %08X Relative_Offset %08X R_CTL_For_IU_Reserved %08X",
                    "fiFillInSRR_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    SRR_Payload->OXID_RXID,
                    SRR_Payload->Relative_Offset,
                    SRR_Payload->R_CTL_For_IU_Reserved,
                    0,0,0,0,0);
/*+
Return length of SRR Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_SRR_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_SRR_Response_OnCard(
                                   SFThread_t *SFThread,
                                   os_bit32     Frame_Length,
                                   os_bit32     Offset_to_FCHS,
                                   os_bit32     Offset_to_Payload,
                                   os_bit32     Payload_Wrap_Offset,
                                   os_bit32     Offset_to_Payload_Wrapped
                                 )
{
#ifndef __MemMap_Force_Off_Card__
/* 
    os_bit32                                         SRR_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                         SRR_Payload_To_Copy;
    os_bit32                                         Bit8_Index;
*/
#endif /* __MemMap_Force_Off_Card__ */
 }

void fiLinkSvcProcess_SRR_Response_OffCard(
                                    SFThread_t                                    *SFThread,
                                    os_bit32                                         Frame_Length,
                                    FCHS_t                                       *FCHS,
                                    FC_ELS_GENERIC_ACC_Payload_t                 *Payload,
                                    os_bit32                                         Payload_Wrap_Offset,
                                    FC_ELS_GENERIC_ACC_Payload_t                 *Payload_Wrapped
                                  )
{
#ifndef __MemMap_Force_On_Card__
/*
    os_bit32                                         SRR_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                         SRR_Payload_To_Copy;
    os_bit32                                         Bit8_Index;
*/
 
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInREC(
                    SFThread_t *SFThread,
                    os_bit32       OXID,
                    os_bit32       RXID
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInREC_OnCard(
                                    SFThread,
                                    OXID,
                                    RXID
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInREC_OffCard(
                                     SFThread,
                                    OXID,
                                    RXID
                                   );
    }
}

os_bit32 fiFillInREC_OnCard(
                           SFThread_t *SFThread,
                           os_bit32       OXID,
                           os_bit32       RXID
                         )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    CDBThread_t           *CdbThread    = SFThread->parent.CDB;
    DevThread_t           *DevThread    = CdbThread->Device;
    os_bit32        REC_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        REC_Payload_Offset = REC_Header_Offset + sizeof(FCHS_t);
/*    os_bit32        Bit8_Index; */
    os_bit32        S_ID=0;
    os_bit32        D_ID;
    os_bit32        OXID_RXID;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_REC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

    OXID_RXID   = (OXID << FC_ELS_SRR_OXID_SHIFT) | RXID;
/*+
Fill in REC Frame Header
-*/

    fiFillInELSFrameHeader_OnCard(
                                   SFThread,
                                   fiComputeDevThread_D_ID(
                                                            DevThread
                                                          ),
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in REC Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         REC_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_REC_Payload_t,
                                                              ELS_Type
                                                            ),
                         hpSwapBit32( FC_ELS_Type_REC )
                       );

    D_ID = fiComputeDevThread_D_ID(
                                                            DevThread
                                                          );

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    osCardRamWriteBit32(
                         hpRoot,
                         REC_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_REC_Payload_t,
                                                              Reserved_ExChOriginatorSid
                                                            ),
                         hpSwapBit32(S_ID)
                       );

    
    osCardRamWriteBit32(
                         hpRoot,
                         REC_Payload_Offset + hpFieldOffset(
                                                              FC_ELS_REC_Payload_t,
                                                              OXID_RXID
                                                            ),
                         hpSwapBit32(OXID_RXID)
                       );

    

/*+
Return length of REC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_REC_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInREC_OffCard(
                            SFThread_t *SFThread,
                            os_bit32       OXID,
                            os_bit32       RXID
                          )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t             *CThread      = CThread_ptr(SFThread->thread_hdr.hpRoot);
    CDBThread_t           *CDBThread    = SFThread->parent.CDB;
    DevThread_t           *DevThread    = CDBThread->Device;
    FCHS_t                *REC_Header   = SFThread->SF_CMND_Ptr;
    FC_ELS_REC_Payload_t  *REC_Payload  = (FC_ELS_REC_Payload_t *)((os_bit8 *)REC_Header + sizeof(FCHS_t));
    os_bit32                  S_ID=0;
    os_bit32                  D_ID=0;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_LinkSvc;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_LinkSvc_Type_REC;
    SFThread->SF_CMND_State = SFThread_SF_CMND_LinkSvc_State_Started;

/*+
Fill in REC Frame Header
-*/

    D_ID =  fiComputeDevThread_D_ID( DevThread); 
    fiFillInELSFrameHeader_OffCard(
                                    SFThread,
                                    D_ID,
                                    0xFFFF,
                                    FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                  );

/*+
Fill in REC Frame Payload
-*/
    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;
    
    REC_Payload->ELS_Type = hpSwapBit32( FC_ELS_Type_REC );

    REC_Payload->Reserved_ExChOriginatorSid  = hpSwapBit32(S_ID);
/* ??????? Switched oxid and rxid */

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        RXID = CDBThread->X_ID | X_ID_Read;
        REC_Payload->OXID_RXID     = hpSwapBit32(( RXID << FC_ELS_SRR_OXID_SHIFT) |OXID);
    }
    REC_Payload->OXID_RXID     = hpSwapBit32(( RXID << FC_ELS_SRR_OXID_SHIFT) |OXID);

    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "Out %s ExChOriginatorSid %08X OX_ID RX_ID %08X OXID %x RXID %x",
                    "fiFillInREC_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    REC_Payload->Reserved_ExChOriginatorSid,
                    REC_Payload->OXID_RXID,
                    OXID,
                    RXID,
                    0,0,0,0);

   

/*+
Return length of REC Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_ELS_REC_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiLinkSvcProcess_REC_Response_OnCard(
                                   SFThread_t *SFThread,
                                   os_bit32     Frame_Length,
                                   os_bit32     Offset_to_FCHS,
                                   os_bit32     Offset_to_Payload,
                                   os_bit32     Payload_Wrap_Offset,
                                   os_bit32     Offset_to_Payload_Wrapped
                                 )
{
#ifndef __MemMap_Force_Off_Card__
/*    
    os_bit32                                         REC_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32                                         REC_Payload_To_Copy;
    os_bit32                                         Bit8_Index;
*/
 
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiLinkSvcProcess_REC_Response_OffCard(
                                    SFThread_t               * SFThread,
                                    os_bit32                   Frame_Length,
                                    FCHS_t                   * FCHS,
                                    FC_ELS_REC_ACC_Payload_t * Payload,
                                    os_bit32                   Payload_Wrap_Offset,
                                    FC_ELS_REC_ACC_Payload_t * Payload_Wrapped
                                  )
{
#ifndef __MemMap_Force_On_Card__
/*      
    os_bit32   REC_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32   REC_Payload_To_Copy;
    os_bit32   Bit8_Index;
*/
    CDBThread_t           *CdbThread    = SFThread->parent.CDB;

    os_bit32 * REC_Payload= (os_bit32 *) Payload;

    CdbThread->FC_Tape_ExchangeStatusBlock = hpSwapBit32(* (REC_Payload + 5));
    /*
    CdbThread->FC_Tape_ExchangeStatusBlock &= FC_REC_ESTAT_Mask;
    */
    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "%s %08X %08X %08X",
                    "fiLinkSvcProcess_REC_Response_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(* (REC_Payload + 0)),
                    hpSwapBit32(* (REC_Payload + 1)),
                    hpSwapBit32(* (REC_Payload + 2)),
                    0,0,0,0,0);

    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "%s %08X XFER %08X ESTAT %08X",
                    "fiLinkSvcProcess_REC_Response_OffCard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(* (REC_Payload + 3)),
                    hpSwapBit32(* (REC_Payload + 4)),
                    hpSwapBit32(* (REC_Payload + 5)),
                    0,0,0,0,0);


#endif /* __MemMap_Force_On_Card__ was not defined */
}

#ifdef _DvrArch_1_30_
void fiLinkSvcProcess_FARP_Response_OffCard(
                                    SFThread_t                  * SFThread,
                                    os_bit32                      Frame_Length,
                                    FCHS_t                      * FCHS,
                                    FC_ELS_FARP_REPLY_Payload_t * Payload,
                                    os_bit32                      Payload_Wrap_Offset,
                                    FC_ELS_FARP_REPLY_Payload_t * Payload_Wrapped
                                  )
{
#ifndef __MemMap_Force_On_Card__
    fiLogDebugString( SFThread->thread_hdr.hpRoot,
                    SFStateLogErrorLevel,
                    "fiLinkSvcProcess_FARP_Response_OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
#endif /* __MemMap_Force_On_Card__ was not defined */
}
#endif /* _DvrArch_1_30_ was defined */

/* void linksvc_c(void){}  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\mapping.h ===
#ifdef YAM2_1
/*++

Copyright (c) 2000 Agilent Technologies

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/mapping.h $

   $Revision: 6 $
   $Date: 11/10/00 5:52p $ (Last Check-In)
   $Modtime:: $ (Last Modified)

Purpose:
   Structures for YAM2.1 Implementation

--*/

#ifndef _MAPPING_H_
#define _MAPPING_H_

#define MAX_VS_DEVICE       128            /* maximum 128 Volume Set device */
#define MAX_LU_DEVICE       8              /* maximum 8 Logical unit (Muxes) supported */
//#define    MAX_PA_DEVICE       256
#define      MAX_PA_DEVICE       MAX_FC_DEVICES
#define      ALL_DEVICE               -1L


#define      DEFAULT_PaPathIdWidth    4
#define      DEFAULT_VoPathIdWidth    2
#define      DEFAULT_LuPathIdWidth    2
#define      DEFAULT_LuTargetWidth    8

#define      CHECK_STATUS             1
#define      DONT_CHECK_STATUS        0

/*
   This structure describe an the coressponding FC handle entry in the OS device entry table
        Index = the FC handle array handle 
        Flags = the state of the FC handle
   Rules:
   1. A value of zero means that there is no corresponding FC handle
   2. Once, the index is set to non zero, it will stay that way until driver unload
   3. A non zero value is active  when the flags is set to MAP_ENTRY_ACTIVE 
   4. During LINKUP and LINKDOWN asynch events, the Index value never change, only the flags do
   5. The Index value IS Unique within the OS Device Entry table 
   6. During LINKUP the entire FC Handle array is scanned to determine if there is any
      NEW entries.  Any new entries   will be assigned to a new PID-TID in the order that 
        FC Handle array is scanned.
*/
typedef struct _WWN_ENTRY
{
   UCHAR          IPortWWN[8];                  /* initiator Port WWN */
   UCHAR          TNodeWWN[8];                  /* target Node WWN */
   UCHAR          TPortWWN[8];                  /* target Port WWN */
   USHORT         Pid;                               /* desired Path ID */
   USHORT         Tid;                               /* desired target ID */
   ULONG          Flags;                             /* undefined */
   void      *agroot;                           /* which card */
} WWN_ENTRY;

typedef struct _WWN_TABLE
{
   ULONG               ElementCount;
   WWN_ENTRY Entry[1];
}  WWN_TABLE;

typedef struct _DEVICE_INFO
{
   UCHAR               InquiryData[40];
   UCHAR               PortWWN[8];
   UCHAR               NodeWWN[8];
// agFCDevInfo_t   devinfo;
} DEVICE_INFO;

typedef struct _VS_DEVICE_IDX
{
   USHORT              PaDeviceIndex;      /* index to PA Device table */
   USHORT              MaxLuns;            /* number of luns connected to this VS device */
} VS_DEVICE_IDX;

typedef struct _LU_DEVICE_IDX
{
   USHORT              PaDeviceIndex;      /* Index to PA Device table */
   USHORT              MaxLuns;            /* number of luns connected to this LU device */
} LU_DEVICE_IDX;

typedef struct _PA_DEVICE_IDX
{
   USHORT              FcDeviceIndex;      /* Index to PA Device table */
   USHORT              MaxLuns;            /* number of luns connected to this LU device */
} PA_DEVICE_IDX;

typedef struct _COMMON_IDX
{

   USHORT              Index;         /* Index to PA Device table */
   USHORT              MaxLuns;            /* number of luns connected to this LU device */
}  COMMON_IDX;


typedef union     _DEVICE_MAP
{
   VS_DEVICE_IDX  Vs;
   LU_DEVICE_IDX  Lu;
   PA_DEVICE_IDX  Pa;
   COMMON_IDX          Com;
} DEVICE_MAP;

#define PA_DEVICE_NO_ENTRY       0xffff

/* this structure describe an NT device PathID-targetID mode */
typedef struct _PA_DEVICE
{
   DEVICE_MAP          Index;
   UCHAR               EntryState;
        #define   PA_DEVICE_EMPTY               0
        #define   PA_DEVICE_ACTIVE         1
        #define   PA_DEVICE_GONEAWAY       2
        #define   PA_DEVICE_TRANSIENT      4

   CHAR           ModeFlag;
        #define   PA_DEVICE_TRY_MODE_MASK            0x07
             #define   PA_DEVICE_TRY_MODE_NONE       0x00      /* new device, has not been tried */
             #define   PA_DEVICE_TRY_MODE_VS         0x01      /* tried VS mode */
             #define   PA_DEVICE_TRY_MODE_LU         0x02      /* tried LU mode */
             #define   PA_DEVICE_TRY_MODE_PA         0x03      /* tried PA mode */
             #define   PA_DEVICE_TRY_MODE_ALL        0x04      /* tried all mode */

        #define PA_DEVICE_BUILDING_DEVICE_MAP   0x08
        #define PA_DEVICE_ALL_LUN_FIELDS_BUILT  0x10
        #define   PA_DEVICE_SUPPORT_PA               0x80
        #define   PA_DEVICE_SUPPORT_VS               0x40
        #define   PA_DEVICE_SUPPORT_LU               0x20

    UCHAR           Padding1;
    UCHAR           Padding2;

    ULONG              OpFlag;             /* operation flags */

   DEVICE_INFO         DevInfo;
} PA_DEVICE;

typedef struct _REG_SETTING
{
   ULONG          PaPathIdWidth;
   ULONG          VoPathIdWidth;
   ULONG          LuPathIdWidth;
   ULONG          LuTargetWidth;
   ULONG          MaximumTids;
} REG_SETTING;


typedef struct _DEVICE_ARRAY
{
   ULONG          Signature;                         /* 'HNDL' */
   ULONG          ElementCount;                 /* maximum structures allocated */
   ULONG          DeviceCount;                  /* Total device reported by FC layer */
   ULONG          CardHandleIndex;         /* index into the devHandle array for card itself */
   ULONG          Num_Devices;
   ULONG          OldNumDevices;
   REG_SETTING    Reg;
   ULONG          VsDeviceIndex;
   ULONG          LuDeviceIndex;
    ULONG       Reserved1;
   DEVICE_MAP     VsDevice[MAX_VS_DEVICE];
   DEVICE_MAP     LuDevice[MAX_LU_DEVICE];
   PA_DEVICE PaDevice[1];
} DEVICE_ARRAY;

#define	DEV_ARRAY_SIZE		(sizeof(DEVICE_ARRAY)) 
#define PADEV_SIZE			(gMaxPaDevices)*sizeof(PA_DEVICE)
#define FCDEV_SIZE			(gMaxPaDevices)*sizeof(agFCDev_t)
#define FCNODE_INFO_SIZE	(gMaxPaDevices)*sizeof(NODE_INFO)
#ifdef _DEBUG_EVENTLOG_
#define EVENTLOG_SIZE       (gEventLogCount ? sizeof(EVENTLOG_BUFFER) +     \
                                (gEventLogCount-1)*sizeof(EVENTLOG_ENTRY) : 0)
#else
#define EVENTLOG_SIZE       (0)
#endif

//#define OSDATA_SIZE (sizeof(CARD_EXTENSION) - sizeof(PA_DEVICE) + PADEV_SIZE + FCDEV_SIZE + FCNODE_INFO_SIZE )
#define OSDATA_SIZE			(sizeof(CARD_EXTENSION))
#define OSDATA_UNCACHED_SIZE (DEV_ARRAY_SIZE-sizeof(PA_DEVICE)+PADEV_SIZE+FCDEV_SIZE+FCNODE_INFO_SIZE+EVENTLOG_SIZE)

#define PADEV_OFFSET		0
#define FCDEV_OFFSET		(DEV_ARRAY_SIZE - sizeof(PA_DEVICE) + PADEV_SIZE)
#define FCNODE_INFO_OFFSET	(FCDEV_OFFSET + FCDEV_SIZE)
#define EVENTLOG_OFFSET     (FCNODE_INFO_OFFSET + FCNODE_INFO_SIZE)   
#define CACHE_OFFSET		(EVENTLOG_OFFSET + EVENTLOG_SIZE)


#define SET_PA_LUN(plun, pathId, targetId, lun) \
             plun->lun_pd[0].Address_mode = PERIPHERAL_ADDRESS; \
             plun->lun_pd[0].Bus_number = 0;    \
             plun->lun_pd[0].Lun = (UCHAR)lun;

#define SET_LU_LUN(plun, pathId, targetId, lun) \
             plun->lun_lu[0].Address_mode = LUN_ADDRESS; \
             plun->lun_lu[0].Target = (UCHAR) (targetId & 0x7); \
             plun->lun_lu[0].Bus_number = (UCHAR) ( (targetId >> 3 ) & 3); \
             plun->lun_lu[0].Lun = (UCHAR) lun;

#define SET_VS_LUN(plun, pathId, targetId, lun) \
             plun->lun_vs[0].Address_mode = VOLUME_SET_ADDRESS; \
             plun->lun_vs[0].Lun_hi = 0; \
             plun->lun_vs[0].Lun = (UCHAR)lun;


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\mapping.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

    mapping.c

Abstract:

    YAMS 2.1 implementation

Authors:

    IW - Ie Wei Njoo
    LP - Leopold Purwadihardja

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/mapping.c $

Revision History:
    $Revision: 7 $
    $Date: 11/10/00 5:51p $
    $Modtime: 10/23/00 5:13p $

Notes:

--*/


#include "buildop.h"        //LP021100 build switches

#include "osflags.h"
#include "err_code.h"
#include "mapping.h"

#ifdef YAM2_1

REG_SETTING gRegSetting = 
   {DEFAULT_PaPathIdWidth,
    DEFAULT_VoPathIdWidth,
    DEFAULT_LuPathIdWidth,
    DEFAULT_LuTargetWidth,
    MAXIMUM_TID
   };
   
WWN_TABLE   *gWWNTable=NULL;
ULONG       gMaxPaDevices = MAX_PA_DEVICE;
int         gDeviceExtensionSize;
int         gMaximumTargetIDs = MAXIMUM_TID;

extern ULONG gMultiMode;

#ifdef WWN_TABLE_ENABLE
/*++

Routine Description:

    Read the registry to get WWn and PID-TID assignment
    (NOT Implemented yet) - for Persistent Binding/Fail-Over

Arguments:


Return Value:

    currently always -1

--*/

void ReadDesiredWWNMapping()
{
    ULONG    count=0, x;
    WCHAR    name[64];
   
    RegGetNumberOfPorts();
    if (count)
    {
        gDesiredWWNMapping = (WWN_TABLE *) ExAllocatePool(NonPagedPool, 
        sizeof(WWN_TABLE) + (count -1)*sizeof(WWN_ENTRY) );
    }
    else
    {
      
    }
    return;
}
#endif

/*++

Routine Description:

    Find in the WWN table a WWN entry.
    (Not implemented) - for persistent Binding/Fail Over

Arguments:


Return Value:

    Currently always return a -1 (not Found)

--*/
ULONG FindInWWNTable (PCARD_EXTENSION pCard, UCHAR *nodeWWN)
{
    return (-1L);
}


/*++

Routine Description:

    Search in the device extension, the index in PaTable containing an FChandle Index

Arguments:

    pcard = the DeviceExtension
    fcDeviceIndex = FCDevice handle index to search

Return Value:

    0 to (gMaxPaDevices-1) Good handle 
    gMaxPaDevices and higher represent non existing handle

--*/
ULONG FindInPaDeviceTable(PCARD_EXTENSION pCard, ULONG fcDeviceIndex)
{
    ULONG x;
    PA_DEVICE   *pa = pCard->Dev->PaDevice;
   
    for (x=0; x < gMaxPaDevices; x++) 
    {
        if (pa->Index.Pa.FcDeviceIndex == fcDeviceIndex)
            break;
        pa++;
    }

    return x;
}


/*++

Routine Description:

    Fill the pCard->Dev.PaDevice from the FChandles built from LinkUp events

Arguments:

    pcard = the deviceExtension

Return Value:
    none
   
--*/
void FillPaDeviceTable(PCARD_EXTENSION pCard)
{
    agRoot_t       *hpRoot = &pCard->hpRoot;
    agFCDevInfo_t  devinfo;
    ULONG          x;
    ULONG          here;
    PA_DEVICE      *pa = pCard->Dev->PaDevice; 

    for (x=0; x < gMaxPaDevices; x++) 
    {
        if (pCard->hpFCDev[x]) 
        {
            /* First see if we have this device in our table already */
            here = FindInPaDeviceTable(pCard, x);  
            if (here < gMaxPaDevices  )
            {
                /* found the entry, reactivate*/
                (pa+here)->EntryState = PA_DEVICE_ACTIVE;
                osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: Reactivating device at handle %d\n", here ));
            }
            else
            {
                /* don't find the entry */
                fcGetDeviceInfo (hpRoot, pCard->hpFCDev[x], &devinfo );
            
                /* check if this is our card */
                if (devinfo.DeviceType & agDevSelf) 
                {
                    pCard->Dev->CardHandleIndex = x;
                    osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: DevSelf at slot %d\n", x ));
                    continue;
                }

                /* make sure that it is scsi device */
                if (devinfo.DeviceType & agDevSCSITarget)
                {
                    if (FindInWWNTable (pCard,devinfo.NodeWWN) == -1L)
                    {
                        /* Don't find in WWN table, assign our own PID, TID */
                        here = FindInPaDeviceTable(pCard, PA_DEVICE_NO_ENTRY);   /* find an empty slot */
                        if (here < gMaxPaDevices  )
                        {
                            (pa+here)->EntryState = PA_DEVICE_ACTIVE;
                            osCopy((pa+here)->DevInfo.PortWWN, devinfo.PortWWN, 8);
                            osCopy((pa+here)->DevInfo.NodeWWN, devinfo.NodeWWN, 8);
                            (pa+here)->Index.Pa.FcDeviceIndex = (USHORT) x;
                            osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: New device at slot %d assigned handle %d %02x%02x%02x%02x%02x%02x%02x%02x\n", 
                                x, here ,
                                devinfo.NodeWWN[0], devinfo.NodeWWN[1], 
                                devinfo.NodeWWN[2], devinfo.NodeWWN[3], 
                                devinfo.NodeWWN[4], devinfo.NodeWWN[5], 
                                devinfo.NodeWWN[6], devinfo.NodeWWN[7] ));
                        }
                        else
                        {
                            osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: Running out of slot\n"));
                            /* Running out of slot
                            * 1. Log the status
                            * 2. don't enable this device
                            */
                        }
                    }
                    else
                    {
                        /* Find an Entry in WWN, use this PID, TID mapping - NOT IMPLEMENTED (YAM2.2)*/
                        osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: Found in WWN Table\n"));
                    }
                }
                else
                {
                    osDEBUGPRINT((ALWAYS_PRINT, "FillPaDeviceTable: Found Non agDevSCSITarget at slot %d device type = %x\n",x, devinfo.DeviceType));
                }
            }
        }
    }

    return;
}

/*++

Routine Description:

    setting/resetting a PA handle data struct

Arguments:

    pcard       = the deviceExtension
    devIndex    - PA device index
    flag        - value to set

Return Value:
    none
   
--*/
void SetPaDeviceTable(PCARD_EXTENSION pCard, ULONG devIndex, ULONG flag)
{
    PA_DEVICE      *pa = pCard->Dev->PaDevice;
    ULONG          x; 
    if (devIndex == ALL_DEVICE)
    {
        for (x=0; x < gMaxPaDevices; x++) 
        {
            if ((pa+x)->Index.Pa.FcDeviceIndex != PA_DEVICE_NO_ENTRY)   
                (pa+x)->EntryState = (UCHAR)flag;
        }
    }
    else
    {
        if ((pa+devIndex)->Index.Pa.FcDeviceIndex != PA_DEVICE_NO_ENTRY)
            (pa+devIndex)->EntryState = (UCHAR)flag;
    }
   
    return ;

}


/*++

Routine Description:

    get the index to paDevice table.

Arguments:

    pcard       = the deviceExtension
    pathId      - SP pathID
    targetId    - SP target ID
    lun         - SP lun
    *addrMode   - (out) addessing mode of this device


Return Value:
    if this number is > gMaxPaDevices, the value is not valid.   
   
--*/
USHORT MapToPaIndex(PCARD_EXTENSION pCard,
    ULONG            pathId,
    ULONG            targetId,
    ULONG            lun,
    CHAR             *addrMode)
{
    REG_SETTING *pRegSetting = &pCard->Dev->Reg;
    ULONG       paDevIndex;
    ULONG       vsDevIndex;
    ULONG       luDevIndex;
   
    /* if not assigned, use the global setting */
    if ( !(pRegSetting->PaPathIdWidth + pRegSetting->VoPathIdWidth + pRegSetting->LuPathIdWidth))
        pRegSetting = &gRegSetting;

    /* initialize Luns */
    paDevIndex = gMaxPaDevices;      /* this will make it invalid index */
   
    /* check addressing mode */
    if ((pathId) < pRegSetting->PaPathIdWidth)
    {
        /* Peripheral Device addressing mode */
        paDevIndex = pathId*pRegSetting->MaximumTids + targetId;
      
        /* fill LUN */
        *addrMode = PA_DEVICE_TRY_MODE_PA;
    }
    else
    {
        if ((pathId) < (pRegSetting->PaPathIdWidth + pRegSetting->VoPathIdWidth) )
        {
            /* Volume Set addressing mode */
            vsDevIndex = (pathId-pRegSetting->PaPathIdWidth)*pRegSetting->MaximumTids + targetId;
            if (vsDevIndex < MAX_VS_DEVICE)
            {
                paDevIndex = pCard->Dev->VsDevice[vsDevIndex].Vs.PaDeviceIndex;
                if (paDevIndex == PA_DEVICE_NO_ENTRY)  
                paDevIndex = gMaxPaDevices;      /* this will make it invalid index */
            }
            *addrMode = PA_DEVICE_TRY_MODE_VS;
        }
        else
        {
            /* logical Unit addressing mode 
            *  PathId is used to index to the array
            */
            *addrMode = PA_DEVICE_TRY_MODE_LU;
            luDevIndex = pathId - pRegSetting->PaPathIdWidth - pRegSetting->VoPathIdWidth;
            if (luDevIndex < MAX_LU_DEVICE)
            {
                paDevIndex = pCard->Dev->LuDevice[luDevIndex].Lu.PaDeviceIndex;
                if (paDevIndex == PA_DEVICE_NO_ENTRY) 
                    paDevIndex = gMaxPaDevices;      /* this will make it invalid index */
            }
        }  
    }
   
    return (USHORT) paDevIndex;
}

/*++

Routine Description:

    get the index to paDevice table.

Arguments:

    pcard       = the deviceExtension
    pathId      - SP pathID
    targetId    - SP target ID
    lun         - SP lun
    pLunExt     - lun extension
    *ret_padevindex   - the device index 


Return Value:
    0    - good
    else - failed
   
--*/
ULONG GetPaDeviceHandle(
    PCARD_EXTENSION pCard,
    ULONG          pathId,
    ULONG          targetId,
    ULONG          lun,
    PLU_EXTENSION  pLunExt,
    USHORT         *ret_paDevIndex)
{
    PA_DEVICE      *dev;
    CHAR           addrmode;
    USHORT         paDevIndex;
    PLUN           plun; 
    CHAR           *pPa, *pVs, *pLu;
   
    /* use registry setting to find the index */ 
    paDevIndex = MapToPaIndex(pCard, pathId,targetId,lun, &addrmode);
   
    /* over the range, fault it */
    if ((ULONG)paDevIndex >= gMaxPaDevices)
    {
//      osDEBUGPRINT((ALWAYS_PRINT, "GetPaDeviceHandle: handle not valid\n"));
        *ret_paDevIndex = 0; /* make sure if used will not BugCheck caller */
        return (-1L);
    }                                
      
    *ret_paDevIndex = paDevIndex;
    /* have it in our array */
    if (pLunExt)
    {
        pLunExt->PaDeviceIndex = paDevIndex;
        dev = pCard->Dev->PaDevice + paDevIndex;   
      
        /* see if there is FC handle */
        if (dev->Index.Pa.FcDeviceIndex == PA_DEVICE_NO_ENTRY)
            return (-1L);
         
        if ( !(dev->ModeFlag & PA_DEVICE_ALL_LUN_FIELDS_BUILT) )
        {
            dev->ModeFlag |= PA_DEVICE_BUILDING_DEVICE_MAP;
         
            dev->ModeFlag |= PA_DEVICE_ALL_LUN_FIELDS_BUILT;
        }
      
        if ( (addrmode ==  PA_DEVICE_TRY_MODE_PA) && (lun == 0) )
        {
            /* Find out any addressing mode only for LUN 0 and PA device*/
            if ( (dev->ModeFlag & PA_DEVICE_TRY_MODE_MASK) < PA_DEVICE_TRY_MODE_ALL) 
            {
                addrmode = dev->ModeFlag & PA_DEVICE_TRY_MODE_MASK;
                /* this device has not been queried for VS or LU addressing Mode */
                switch(addrmode)
                {
                    case PA_DEVICE_TRY_MODE_NONE:
                    {
                        dev->ModeFlag = (dev->ModeFlag & ~PA_DEVICE_TRY_MODE_MASK) |
                                             PA_DEVICE_TRY_MODE_VS;
                        pLunExt->Mode = PA_DEVICE_TRY_MODE_VS;
                        osDEBUGPRINT((ALWAYS_PRINT, "GetPaDeviceHandle: Try mode VS for device %d\n", paDevIndex));
                        break;
                    }
               
                    case PA_DEVICE_TRY_MODE_VS:
                    {
                        dev->ModeFlag = (dev->ModeFlag & ~PA_DEVICE_TRY_MODE_MASK) |
                                                PA_DEVICE_TRY_MODE_LU;
                        pLunExt->Mode = PA_DEVICE_TRY_MODE_LU;
                        osDEBUGPRINT((ALWAYS_PRINT, "GetPaDeviceHandle: Try mode LU for device %d\n", paDevIndex));
                        break;
                    }
               
                    case PA_DEVICE_TRY_MODE_LU:
                    {
                        dev->ModeFlag = (dev->ModeFlag & ~PA_DEVICE_TRY_MODE_MASK) |
                                                PA_DEVICE_TRY_MODE_PA;
                        pLunExt->Mode = PA_DEVICE_TRY_MODE_PA;
                        osDEBUGPRINT((ALWAYS_PRINT, "GetPaDeviceHandle: Try mode PA for device %d\n", paDevIndex));
                        break;
                    }
                }
            }
            else
            {
                /* this device is already prep'ed to run */
            }
        }
        else
        {
            /** Non Zero LUNs OR non PA device**/
            pLunExt->Mode = addrmode;
        }
    }
    return 0;
}


/*++

Routine Description:

    Try a different FC addresing mode for this device to determine
    device addressing capabilities

Arguments:

    pcard          = the deviceExtension
    pHPIorequest   - Agilent Common IO request structure
    pSrbExt        - srb extension
    flag           -  CHECK_STATUS (determine after status is checked)
                     DON"T_CHECK_STATUS (disregard status)


Return Value:
    TRUE  - need to process this command, put the io back in the retry Q
    FALSE - complete this SRB back to SP
   
--*/
int  TryOtherAddressingMode(
    PCARD_EXTENSION   pCard, 
    agIORequest_t     *phpIORequest,
    PSRB_EXTENSION    pSrbExt, 
    ULONG             flag)
{
    PSCSI_REQUEST_BLOCK        pSrb;
    PLU_EXTENSION              plunExtension;
    int                        resend = FALSE;
    CHAR                       support;
    PA_DEVICE                  *dev;
    CHAR                       addrmode;
    int                        inqDevType;
    char                       *vid;
    char                       *pid;
    char                       inqData[24];
    ULONG                      *lptr;
      
    plunExtension = pSrbExt->pLunExt;
    dev = pCard->Dev->PaDevice + plunExtension->PaDeviceIndex;
    pSrb = pSrbExt->pSrb;
   
// osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Will try handle %d type ModeFlag=%x\n",
 //         plunExtension->PaDeviceIndex, dev->PaDevice.ModeFlag));
         
    if (  ( (dev->ModeFlag & PA_DEVICE_TRY_MODE_MASK) < PA_DEVICE_TRY_MODE_ALL) &&
         (pSrb->Lun == 0) )
    {
        osCopy(inqData, ((char*)pSrb->DataBuffer)+8, sizeof(inqData)-1);
        inqData[sizeof(inqData)-1] = '\0';
      
        inqDevType = (int) (*((CHAR *)pSrb->DataBuffer) & 0x1F);
        osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Found (%s) handle %d type=%x Mode = %x PID=%d TID=%d LUN=%d\n",
            inqData, plunExtension->PaDeviceIndex, inqDevType, dev->ModeFlag, 
            pSrb->PathId,pSrb->TargetId, pSrb->Lun ));
      
        /* need to try  next mode */
        if (flag == CHECK_STATUS)
        {
            switch (pSrb->SrbStatus)
            {
                case SRB_STATUS_DATA_OVERRUN:
                case SRB_STATUS_SUCCESS:
                    if (inqDevType != 0x1f)
                        support=TRUE;
                    else
                        support=FALSE;
                    break;
            
                case SRB_STATUS_SELECTION_TIMEOUT:
                    support= FALSE;
                    break;
               
                default:
                    support = FALSE;
                    break;
            }
        }
        else
        {
            if (inqDevType != 0x1f)
            {
                support=TRUE;
            
                /* sanity check. Clarion return all zeros data */
                lptr = (ULONG *)pSrb->DataBuffer;
                if ( !(*lptr++) && !(*lptr++) && !(*lptr++) && !(*lptr++) )
                    support = FALSE;
            }
            else
                support=FALSE;
         
        }
   
        addrmode = dev->ModeFlag & PA_DEVICE_TRY_MODE_MASK;

        if (addrmode == PA_DEVICE_TRY_MODE_PA)
        {
            if (support)
                dev->ModeFlag |= PA_DEVICE_SUPPORT_PA;
            /* 
            * Done testing all modes, now prepare VsDevice and LuDevice tables.......
            */
            /* No need to test anymore */
            dev->ModeFlag |= PA_DEVICE_TRY_MODE_ALL;
         
            /* let all non zero LUNs to continue */
            dev->ModeFlag &= ~PA_DEVICE_BUILDING_DEVICE_MAP;
         
            osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Done trying handle %d on all modes \n",   plunExtension->PaDeviceIndex));
            resend = FALSE;
        }
        else
        {
            if (addrmode == PA_DEVICE_TRY_MODE_VS)
            {
                if (support)
                {
                    dev->ModeFlag |= PA_DEVICE_SUPPORT_VS;
                    if (pCard->Dev->VsDeviceIndex < MAX_VS_DEVICE)
                    {
                        pCard->Dev->VsDevice[pCard->Dev->VsDeviceIndex].Vs.PaDeviceIndex = plunExtension->PaDeviceIndex;
                        pCard->Dev->VsDeviceIndex++;
                        osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Adding handle %d to VS Device\n",   plunExtension->PaDeviceIndex));
                    }
                }
            }
            else
            {
                if (support)
                {
                    dev->ModeFlag |= PA_DEVICE_SUPPORT_LU;
                    if (pCard->Dev->LuDeviceIndex < MAX_LU_DEVICE)
                    {
                        pCard->Dev->LuDevice[pCard->Dev->LuDeviceIndex].Lu.PaDeviceIndex = plunExtension->PaDeviceIndex;
                        pCard->Dev->LuDeviceIndex++;
                        osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: Adding handle %d to LU Device\n",   plunExtension->PaDeviceIndex));
                    }
                }
            }
         
            
            /* try next mode */
            dev->ModeFlag++;
            plunExtension->Mode++;
            osDEBUGPRINT((ALWAYS_PRINT, "TryOtherAddressingMode: ModeFlag for Device %d Now %xx plun->mode=%xx\n",     plunExtension->PaDeviceIndex, dev->ModeFlag, plunExtension->Mode));
         
            /* reinitialize param to send back to the queue */
            phpIORequest->osData = pSrbExt;
            pSrbExt->SRB_State =  RS_WAITING;
            pSrb->SrbStatus = SRB_STATUS_SUCCESS;
            pSrb->ScsiStatus = SCSISTAT_GOOD;
         
            /* requeue it */
            SrbEnqueueHead (&pCard->RetryQ, pSrb);
            resend = TRUE;
        }
    }
    else
    {
        resend = FALSE;
    }
      
    return (resend);
}


/*++

Routine Description:

    Update the FC LUN payload before sening the command to FC layer
   
Arguments:

    pcard          = the deviceExtension
    pHPIorequest   - Agilent Common IO request structure
    pSrbExt        - srb extension

Return Value:
    none
--*/
void SetFcpLunBeforeStartIO (
    PLU_EXTENSION           pLunExt,
    agIORequestBody_t *     pHpio_CDBrequest,
    PSCSI_REQUEST_BLOCK     pSrb)
{
    PLUN plun;

    plun = (PLUN)&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0];
   
    switch(pLunExt->Mode)
    {
        case PA_DEVICE_TRY_MODE_VS:
            SET_VS_LUN(plun, pSrb->PathId, pSrb->TargetId, pSrb->Lun)
            break;
      
        case PA_DEVICE_TRY_MODE_LU:
            SET_LU_LUN(plun, pSrb->PathId, pSrb->TargetId, pSrb->Lun)
            break;
         
        case PA_DEVICE_TRY_MODE_PA:
            SET_PA_LUN(plun, pSrb->PathId, pSrb->TargetId, pSrb->Lun)
            break;
    }
    #ifdef OLD     
    osDEBUGPRINT((ALWAYS_PRINT, "ModifyModeBeforeStartIO: Lun %02x%02x Mode Flag %xx \n",    
        pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0],
        pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[1],
        pLunExt->Mode));        
    #endif
    return;
}


/*++

Routine Description:

    Initialize all YAM tables
Arguments:

    pcard          = the deviceExtension


Return Value:
    none
   
--*/
void InitializeDeviceTable(PCARD_EXTENSION pCard)
{
    ULONG x;
   
    for (x = 0; x < MAX_VS_DEVICE;x++)
    {
        pCard->Dev->VsDevice[x].Vs.PaDeviceIndex = PA_DEVICE_NO_ENTRY;
    }
   
    #ifdef _ENABLE_PSEUDO_DEVICE_
    if (gEnablePseudoDevice)
        pCard->Dev->VsDeviceIndex = 1;
    #endif
   
    for (x = 0; x < MAX_LU_DEVICE;x++)
    {
        pCard->Dev->LuDevice[x].Lu.PaDeviceIndex = PA_DEVICE_NO_ENTRY;
    }
      
    for (x = 0; x < gMaxPaDevices;x++)
    {
        pCard->Dev->PaDevice[x].Index.Pa.FcDeviceIndex = PA_DEVICE_NO_ENTRY;
      
        /* if onlu single addressing mode support, default to PA mode */
        if (gMultiMode == FALSE)
            pCard->Dev->PaDevice[x].ModeFlag = 
                (CHAR) (PA_DEVICE_TRY_MODE_ALL | PA_DEVICE_TRY_MODE_MASK |PA_DEVICE_ALL_LUN_FIELDS_BUILT | PA_DEVICE_SUPPORT_PA);
      
    }
      
    return ;
   
}



/*++

Routine Description:

    Get a device table mapping
Arguments:

    pcard          = the deviceExtension
    pathId         - SP bus id
    targetId       - SP target ID
    lun            - SP lun 
    *addrmode      - (OUT) addressing mode of this device
    *paIndex       - (OUT) pa device index
   
Return Value:
    device map location or NULL
   
--*/
DEVICE_MAP  *GetDeviceMapping(PCARD_EXTENSION pCard,
    ULONG            pathId,
    ULONG            targetId,
    ULONG            lun, 
    CHAR             *addrmode,
    USHORT           *paIndex)
    
{
    DEVICE_MAP  *devmap;
    USHORT         paDevIndex;
    ULONG          x;
   
    paDevIndex = MapToPaIndex(pCard, pathId,targetId,lun, addrmode);
   
    if ((ULONG)paDevIndex < gMaxPaDevices)
    {
        *paIndex = paDevIndex;
      
        switch (*addrmode)
        {
            case PA_DEVICE_TRY_MODE_VS:
                for (x=0; x< MAX_VS_DEVICE;x++)
                {
                    if (pCard->Dev->VsDevice[x].Vs.PaDeviceIndex == paDevIndex)  
                    {
                        return (&pCard->Dev->VsDevice[x]);
                    }
                }
            
                break;
                        
            case PA_DEVICE_TRY_MODE_LU:
                for (x=0; x< MAX_LU_DEVICE;x++)
                {
                    if (pCard->Dev->LuDevice[x].Lu.PaDeviceIndex == paDevIndex)  
                    {
                        return (&pCard->Dev->LuDevice[x]);
                    }
                 }
                break;
                     
            case PA_DEVICE_TRY_MODE_PA:
                return (&pCard->Dev->PaDevice[paDevIndex].Index);
        }
    }
    return NULL;
}



/*++

Routine Description:

    Setting the maximum number of luns supported by this device
   
Arguments:

    pcard          = the deviceExtension
    pathId         - SP bus id
    targetId       - SP target ID
    lun            - SP lun 

Return Value:
    none
   
--*/
void SetLunCount(
    PCARD_EXTENSION pCard,
    ULONG            pathId,
    ULONG            targetId,
    ULONG            lun)
{
    DEVICE_MAP     *devmap;
    CHAR           addrmode;
    USHORT         padev;   
   
    devmap = GetDeviceMapping(pCard,pathId,targetId,lun, &addrmode, &padev);
    if (devmap)
    {
        if (devmap->Com.MaxLuns < (USHORT)lun)
        {
            osDEBUGPRINT((ALWAYS_PRINT, "SetLunCount: %s device at paDevIndex %d Max Lun = %d\n", 
                ((addrmode == PA_DEVICE_TRY_MODE_PA) ? "PA" : ((addrmode == PA_DEVICE_TRY_MODE_VS) ? "VS" : "LU") ), 
                padev, lun));
            devmap->Com.MaxLuns = (USHORT)lun;
        }
    }
   
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\ntdebug.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   ntdebug.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/NTDEBUG.H $


Revision History:

   $Revision: 2 $
   $Date: 9/07/00 11:17a $
   $Modtime:: 8/31/00 3:23p            $

Notes:


--*/

#ifndef __NTDEBUG_H_
#define __NTDEBUG_H_

#if DBG == 0

#define EXTERNAL_DEBUG_LEVEL     0
#define EXTERNAL_HP_DEBUG_LEVEL  6 // 0x00000103

#endif  //  DBG == 0

#if DBG == 1

#define EXTERNAL_DEBUG_LEVEL     ( DBG_JUST_ERRORS | CS_DURING_ANY)
#define EXTERNAL_HP_DEBUG_LEVEL  8

#endif //  DBG == 1

#if DBG == 2

#define EXTERNAL_DEBUG_LEVEL   0 // (DBG_MODERATE_DETAIL | CS_DURING_ANY)
#define EXTERNAL_HP_DEBUG_LEVEL  11

#endif //  DBG == 2


#if DBG > 2

#define EXTERNAL_DEBUG_LEVEL      0 // (DBG_DEBUG_FULL) //
#define EXTERNAL_HP_DEBUG_LEVEL  11 // Log


#endif //  DBG > 2



// CS_DURING_ANY | DBG_LOW_DETAIL
// DBG_DEBUG_FULL show it all
// CS_DURING_ANY | DBG_LOW_DETAIL;
// CS_DRIVER_ENTRY            0x00000100 // Initial Driver load superset
// CS_DURING_DRV_ENTRY        0x00000001 // of DRV_ENTRY FIND and START
// CS_DURING_FINDADAPTER      0x00000002 // Anything during scsiportinit
// CS_DURING_DRV_INIT         0x00000004
// CS_DURING_RESET_ADAPTER    0x00000008
// CS_DURING_STARTIO          0x00000010
// CS_DURING_ISR              0x00000020
// CS_DURING_OSCOMPLETE       0x00000040
// CS_HANDLES_GOOD            0x00000080
// CS_DURING_ANY              0x000001FF
// CS_DUR_ANY_ALL             0xF00001FF

// DBG_VERY_DETAILED          0x10000000  // All debug statements
// DBG_MODERATE_DETAIL        0x20000000  // Most debug statements
// DBG_LOW_DETAIL             0x40000000  // Entry and exit
// DBG_JUST_ERRORS            0x80000000  // Errors
// DBG_DEBUG_MASK             0xF0000000  // Mask debug bits
// DBG_DEBUG_OFF              0xF0000000  // NO debug statements
// DBG_DEBUG_FULL             0x000001FF  // ALL debug statements and CS
// DBG_DEBUG_ALL              0x00000000  // ALL debug statements






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\ntdebug.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

    ntdebug.c

Abstract:

    Debugging aid
   
Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only

Notes:

Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/NTDEBUG.C $


Revision History:

    $Revision: 5 $
    $Date: 12/07/00 1:35p $
    $Modtime:: 12/05/00 4:33p           $

Notes:


--*/

#include "globals.h"

#ifdef PVOID
#undef PVOID
#endif

//#ifdef BOOLEAN
//#undef BOOLEAN
//#endif


//#include <miniport.h>
#include <stdarg.h>
//#include <stdio.h>
#include "buildop.h"
#include "cstring.h"

#define SCSIPORT_API

SCSIPORT_API
VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


#define DebugPrint(x) ScsiDebugPrint x

extern ULONG DbgPrint( char * Format, ... );

ULONG Global_Print_Level; // DBG_DEBUG_FULL;

void osDebugPrintString( os_bit32 Print_LEVEL, char *formatString, ... )
{
    char buffer[512];
    ULONG instate;
    ULONG level;
    ULONG glob_level;
    ULONG glob_state;
    va_list ap;
    va_start(ap,formatString );

    // DebugPrint((0,"Print_LEVEL\n",Print_LEVEL));

    instate = Print_LEVEL & CS_DURING_ANY;
    level = Print_LEVEL & DBG_DEBUG_MASK;

    glob_state = Global_Print_Level & CS_DURING_ANY;
    glob_level = Global_Print_Level & DBG_DEBUG_MASK;

    if(Print_LEVEL & ALWAYS_PRINT)
    {
        C_vsprintf(buffer, formatString, ap);
        DebugPrint((1, buffer));

    }
    else
    {
        if( glob_state & instate )
        {
            if( level > glob_level )
            {
                C_vsprintf(buffer, formatString, ap);
                DebugPrint((1, buffer));

            }
        }
    }
    va_end(ap);
}

#if DBG > 2

void  dump_PCI_regs( PPCI_COMMON_CONFIG pciCommonConfig )
{
    osDEBUGPRINT((DVHIGH,"VendorID       %04x\n", pciCommonConfig->VendorID      ));
    osDEBUGPRINT((DVHIGH,"DeviceID       %04x\n", pciCommonConfig->DeviceID      ));
    osDEBUGPRINT((DVHIGH,"Command        %04x\n", pciCommonConfig->Command       ));
    osDEBUGPRINT((DVHIGH,"Status         %04x\n", pciCommonConfig->Status        ));
    osDEBUGPRINT((DVHIGH,"RevisionID     %02x\n", pciCommonConfig->RevisionID    ));
    osDEBUGPRINT((DVHIGH,"ProgIf         %02x\n", pciCommonConfig->ProgIf        ));
    osDEBUGPRINT((DVHIGH,"SubClass       %02x\n", pciCommonConfig->SubClass      ));
    osDEBUGPRINT((DVHIGH,"BaseClass      %02x\n", pciCommonConfig->BaseClass     ));
    osDEBUGPRINT((DVHIGH,"CacheLineSize  %02x\n", pciCommonConfig->CacheLineSize ));
    osDEBUGPRINT((DVHIGH,"LatencyTimer   %02x\n", pciCommonConfig->LatencyTimer  ));
    osDEBUGPRINT((DVHIGH,"HeaderType     %02x\n", pciCommonConfig->HeaderType    ));
    osDEBUGPRINT((DVHIGH,"BIST           %02x\n", pciCommonConfig->BIST          ));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[0] %08x\n", pciCommonConfig->u.type0.BaseAddresses[0]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[1] %08x\n", pciCommonConfig->u.type0.BaseAddresses[1]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[2] %08x\n", pciCommonConfig->u.type0.BaseAddresses[2]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[3] %08x\n", pciCommonConfig->u.type0.BaseAddresses[3]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[4] %08x\n", pciCommonConfig->u.type0.BaseAddresses[4]));
    osDEBUGPRINT((DVHIGH,"BaseAddresses[5] %08x\n", pciCommonConfig->u.type0.BaseAddresses[5]));
 
    osDEBUGPRINT((DVHIGH,"CIS            %08x\n", pciCommonConfig->u.type0.CIS           ));
    osDEBUGPRINT((DVHIGH,"SubVendorID    %04x\n", pciCommonConfig->u.type0.SubVendorID   ));
    osDEBUGPRINT((DVHIGH,"SubSystemID    %04x\n", pciCommonConfig->u.type0.SubSystemID   ));
    osDEBUGPRINT((DVHIGH,"ROMBaseAddress %08x\n", pciCommonConfig->u.type0.ROMBaseAddress));

#if defined(HP_NT50)
    osDEBUGPRINT((DVHIGH,"Reserved1[0]   %08x\n", pciCommonConfig->u.type0.Reserved1[0]  ));
    osDEBUGPRINT((DVHIGH,"Reserved1[1]   %08x\n", pciCommonConfig->u.type0.Reserved1[1]  ));
    osDEBUGPRINT((DVHIGH,"Reserved1[2]   %08x\n", pciCommonConfig->u.type0.Reserved1[2]  ));
    osDEBUGPRINT((DVHIGH,"Reserved2   %08x\n", pciCommonConfig->u.type0.Reserved2 ));
#else
    osDEBUGPRINT((DVHIGH,"Reserved2[0]   %08x\n", pciCommonConfig->u.type0.Reserved2[0]  ));
    osDEBUGPRINT((DVHIGH,"Reserved2[1]   %08x\n", pciCommonConfig->u.type0.Reserved2[1]  ));
#endif

    osDEBUGPRINT((DVHIGH,"InterruptLine  %02x\n", pciCommonConfig->u.type0.InterruptLine ));
    osDEBUGPRINT((DVHIGH,"InterruptPin   %02x\n", pciCommonConfig->u.type0.InterruptPin  ));
    osDEBUGPRINT((DVHIGH,"MinimumGrant   %02x\n", pciCommonConfig->u.type0.MinimumGrant  ));
    osDEBUGPRINT((DVHIGH,"MaximumLatency %02x\n", pciCommonConfig->u.type0.MaximumLatency));
 
}


void dump_pCard( IN PCARD_EXTENSION pCard)
{
    ULONG i;

    osDEBUGPRINT(( DHIGH,"pCard                   %lx\n", pCard                   ));
    osDEBUGPRINT(( DHIGH,"hpRoot.fcData          %lx\n", pCard->hpRoot.fcData    ));
    osDEBUGPRINT(( DHIGH,"hpRoot.osData          %lx\n", pCard->hpRoot.osData    ));
    osDEBUGPRINT(( DHIGH,"IoLBase                %lx\n", pCard->IoLBase           ));
    osDEBUGPRINT(( DHIGH,"IoUpBase               %lx\n", pCard->IoUpBase          ));
    osDEBUGPRINT(( DHIGH,"MemIoBase              %lx\n", pCard->MemIoBase         ));
    osDEBUGPRINT(( DHIGH,"RamBase                %lx\n", pCard->RamBase           ));
    osDEBUGPRINT(( DHIGH,"RomBase                %lx\n", pCard->RomBase           ));
    osDEBUGPRINT(( DHIGH,"RamLength               %x\n", pCard->RamLength        ));
    osDEBUGPRINT(( DHIGH,"RomLength               %x\n", pCard->RomLength        ));
    osDEBUGPRINT(( DHIGH,"State                   %x\n", pCard->State             ));
    osDEBUGPRINT(( DHIGH,"SystemIoBusNumber       %x\n", pCard->SystemIoBusNumber ));
    osDEBUGPRINT(( DHIGH,"SlotNumber              %x\n", pCard->SlotNumber        ));
    osDEBUGPRINT(( DHIGH,"cachedMemoryPtr        %lx\n", pCard->cachedMemoryPtr   ));
    osDEBUGPRINT(( DHIGH,"cachedMemoryNeeded      %x\n", pCard->cachedMemoryNeeded));
    osDEBUGPRINT(( DHIGH,"cachedMemoryAlign       %x\n", pCard->cachedMemoryAlign ));
    osDEBUGPRINT(( DHIGH,"dmaMemoryUpper32        %x\n", pCard->dmaMemoryUpper32  ));
    osDEBUGPRINT(( DHIGH,"dmaMemoryLower32        %x\n", pCard->dmaMemoryLower32  ));
    osDEBUGPRINT(( DHIGH,"dmaMemoryPtr           %lx\n", pCard->dmaMemoryPtr      ));
    osDEBUGPRINT(( DHIGH,"dmaMemoryNeeded         %x\n", pCard->dmaMemoryNeeded   ));
    osDEBUGPRINT(( DHIGH,"nvMemoryNeeded          %x\n", pCard->nvMemoryNeeded    ));
    osDEBUGPRINT(( DHIGH,"usecsPerTick            %x\n", pCard->usecsPerTick      ));
    osDEBUGPRINT(( DHIGH,"IsFirstTime             %x\n", pCard->IsFirstTime       ));
    osDEBUGPRINT(( DHIGH,"ResetType               %x\n", pCard->ResetType         ));
    osDEBUGPRINT(( DHIGH,"Num_Devices             %x\n", pCard->Num_Devices       ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[0]              %lx\n", pCard->hpFCDev[0]        ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[1]              %lx\n", pCard->hpFCDev[1]        ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[2]              %lx\n", pCard->hpFCDev[2]        ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[3]              %lx\n", pCard->hpFCDev[3]        ));
    osDEBUGPRINT(( DHIGH,"hpFCDev[4]              %lx\n", pCard->hpFCDev[4]        ));
 
}




#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\memmap.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/MemMap.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:30a  $ (Last Modified)

Purpose:

  This file implements the laying out of memory (on and off card).

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/flashsvc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "flashsvc.h"
#endif  /* _New_Header_file_Layout_ */

/*+
Function:  fiMemMapGetParameterBit32()

Purpose:   Allows OS Layer to adjust the specified parameter.

Algorithm: If EnforceDefaults is agTRUE (meaning fiMemMapCalculate
           was called specifying that all parameters be set to their
           defaults) or if ADJUSTABLE is agFALSE (meaning this particular
           PARAMETER is not adjustable), then this function simply
           returns the DEFAULT.

           Otherwise, osAdjustParameterBit32() is called to allow the
           OS Layer a chance to adjust the value of this PARAMETER.  The
           value returned from osAdjustParameterBit32() is bounds checked
           (if less than MIN, MIN is used; if more than MAX, MAX is used).
           If POWER_OF_2 is agTRUE (meaning the value must be a power of 2),
           the value is truncated to be a power of 2 if necessary.
-*/

os_bit32 fiMemMapGetParameterBit32(
                                 agRoot_t *hpRoot,
                                 char     *PARAMETER,
                                 os_bit32     MIN,
                                 os_bit32     MAX,
                                 agBOOLEAN   ADJUSTABLE,
                                 agBOOLEAN   POWER_OF_2,
                                 os_bit32     DEFAULT,
                                 agBOOLEAN   EnforceDefaults
                               )
{
    os_bit32 power_of_2 = 0x80000000;
    os_bit32 to_return;

    if (EnforceDefaults == agTRUE)
    {
        /* If enforcing defaults, simply return the default value */
        
        return DEFAULT;
    }

    if (ADJUSTABLE == agFALSE)
    {
        /* If not adjustable, simply return the default value */
        
        return DEFAULT;
    }

    /* Call OS Layer to see if parameter needs to be adjusted */
    
    to_return = osAdjustParameterBit32(
                                        hpRoot,
                                        PARAMETER,
                                        DEFAULT,
                                        MIN,
                                        MAX
                                      );

    if (to_return < MIN)
    {
        /* Enforce minimum value for parameter */
        
        return MIN;
    }

    if (to_return > MAX)
    {
        /* Enforce maximum value for parameter */
        
        return MAX;
    }

    if (POWER_OF_2 != agTRUE)
    {
        /* If not needed to be a power of 2, to_return is okay */
        
        return to_return;
    }

    if (to_return == (to_return & ~(to_return-1)))
    {
        /* Above calculation is true if to_return is a power of 2 */
        
        return to_return;
    }

    /* Need to truncate value to make it a power of 2 */
    
    while ((power_of_2 & to_return) != power_of_2)
    {
        power_of_2 = power_of_2 >> 1;
    }

    return power_of_2;
}

/*+
Function:  fiMemMapGetParameters()

Purpose:   Allows OS Layer to adjust all parameters.

Algorithm: This function simply calls fiMemMapGetParameterBit32()
           for each parameter.  Each value returned is placed in
           the Calculation->Parameters structure.
-*/

void fiMemMapGetParameters(
                            agRoot_t              *hpRoot,
                            fiMemMapCalculation_t *Calculation,
                            agBOOLEAN                EnforceDefaults
                          )
{
    Calculation->Parameters.NumDevSlotsPerArea
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumDevSlotsPerArea_PARAMETER,
                                     MemMap_NumDevSlotsPerArea_MIN,
                                     MemMap_NumDevSlotsPerArea_MAX,
                                     MemMap_NumDevSlotsPerArea_ADJUSTABLE,
                                     MemMap_NumDevSlotsPerArea_POWER_OF_2,
                                     MemMap_NumDevSlotsPerArea_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumAreasPerDomain
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumAreasPerDomain_PARAMETER,
                                     MemMap_NumAreasPerDomain_MIN,
                                     MemMap_NumAreasPerDomain_MAX,
                                     MemMap_NumAreasPerDomain_ADJUSTABLE,
                                     MemMap_NumAreasPerDomain_POWER_OF_2,
                                     MemMap_NumAreasPerDomain_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumDomains
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumDomains_PARAMETER,
                                     MemMap_NumDomains_MIN,
                                     MemMap_NumDomains_MAX,
                                     MemMap_NumDomains_ADJUSTABLE,
                                     MemMap_NumDomains_POWER_OF_2,
                                     MemMap_NumDomains_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumDevices
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumDevices_PARAMETER,
                                     MemMap_NumDevices_MIN,
                                     MemMap_NumDevices_MAX,
                                     MemMap_NumDevices_ADJUSTABLE,
                                     MemMap_NumDevices_POWER_OF_2,
                                     MemMap_NumDevices_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumIOs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumIOs_PARAMETER,
                                     MemMap_NumIOs_MIN,
                                     MemMap_NumIOs_MAX,
                                     MemMap_NumIOs_ADJUSTABLE,
                                     MemMap_NumIOs_POWER_OF_2,
                                     MemMap_NumIOs_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SizeSGLs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SizeSGLs_PARAMETER,
                                     MemMap_SizeSGLs_MIN,
                                     MemMap_SizeSGLs_MAX,
                                     MemMap_SizeSGLs_ADJUSTABLE,
                                     MemMap_SizeSGLs_POWER_OF_2,
                                     MemMap_SizeSGLs_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumSGLs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumSGLs_PARAMETER,
                                     MemMap_NumSGLs_MIN,
                                     MemMap_NumSGLs_MAX,
                                     MemMap_NumSGLs_ADJUSTABLE,
                                     MemMap_NumSGLs_POWER_OF_2,
                                     MemMap_NumSGLs_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SizeCachedSGLs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SizeCachedSGLs_PARAMETER,
                                     MemMap_SizeCachedSGLs_MIN,
                                     MemMap_SizeCachedSGLs_MAX,
                                     MemMap_SizeCachedSGLs_ADJUSTABLE,
                                     MemMap_SizeCachedSGLs_POWER_OF_2,
                                     MemMap_SizeCachedSGLs_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.FCP_CMND_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_FCP_CMND_Size_PARAMETER,
                                     MemMap_FCP_CMND_Size_MIN,
                                     MemMap_FCP_CMND_Size_MAX,
                                     MemMap_FCP_CMND_Size_ADJUSTABLE,
                                     MemMap_FCP_CMND_Size_POWER_OF_2,
                                     MemMap_FCP_CMND_Size_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.FCP_RESP_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_FCP_RESP_Size_PARAMETER,
                                     MemMap_FCP_RESP_Size_MIN,
                                     MemMap_FCP_RESP_Size_MAX,
                                     MemMap_FCP_RESP_Size_ADJUSTABLE,
                                     MemMap_FCP_RESP_Size_POWER_OF_2,
                                     MemMap_FCP_RESP_Size_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SF_CMND_Reserve
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SF_CMND_Reserve_PARAMETER,
                                     MemMap_SF_CMND_Reserve_MIN,
                                     (MemMap_SF_CMND_Reserve_MAX - (Calculation->Parameters.NumIOs - MemMap_NumIOs_MIN)),
                                     MemMap_SF_CMND_Reserve_ADJUSTABLE,
                                     MemMap_SF_CMND_Reserve_POWER_OF_2,
                                     MemMap_SF_CMND_Reserve_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SF_CMND_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SF_CMND_Size_PARAMETER,
                                     MemMap_SF_CMND_Size_MIN,
                                     MemMap_SF_CMND_Size_MAX,
                                     MemMap_SF_CMND_Size_ADJUSTABLE,
                                     MemMap_SF_CMND_Size_POWER_OF_2,
                                     MemMap_SF_CMND_Size_DEFAULT,
                                     EnforceDefaults
                                   );

#ifdef _DvrArch_1_30_
    Calculation->Parameters.Pkt_CMND_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_Pkt_CMND_Size_PARAMETER,
                                     MemMap_Pkt_CMND_Size_MIN,
                                     MemMap_Pkt_CMND_Size_MAX,
                                     MemMap_Pkt_CMND_Size_ADJUSTABLE,
                                     MemMap_Pkt_CMND_Size_POWER_OF_2,
                                     MemMap_Pkt_CMND_Size_DEFAULT,
                                     EnforceDefaults
                                   );
#endif /* _DvrArch_1_30_ was not defined */

    Calculation->Parameters.NumTgtCmnds
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumTgtCmnds_PARAMETER,
                                     MemMap_NumTgtCmnds_MIN,
                                     MemMap_NumTgtCmnds_MAX,
                                     MemMap_NumTgtCmnds_ADJUSTABLE,
                                     MemMap_NumTgtCmnds_POWER_OF_2,
                                     MemMap_NumTgtCmnds_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.TGT_CMND_Size
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_TGT_CMND_Size_PARAMETER,
                                     MemMap_TGT_CMND_Size_MIN,
                                     MemMap_TGT_CMND_Size_MAX,
                                     MemMap_TGT_CMND_Size_ADJUSTABLE,
                                     MemMap_TGT_CMND_Size_POWER_OF_2,
                                     MemMap_TGT_CMND_Size_DEFAULT,
                                     EnforceDefaults
                                   );

#ifdef _DvrArch_1_30_
    Calculation->Parameters.NumPktThreads
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumPktThreads_PARAMETER,
                                     MemMap_NumPktThreads_MIN,
                                     MemMap_NumPktThreads_MAX,
                                     MemMap_NumPktThreads_ADJUSTABLE,
                                     MemMap_NumPktThreads_POWER_OF_2,
                                     MemMap_NumPktThreads_DEFAULT,
                                     EnforceDefaults
                                   );
#endif /* _DvrArch_1_30_ was defined */

    Calculation->Parameters.NumCommandQ
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumCommandQ_PARAMETER,
                                     MemMap_NumCommandQ_MIN,
                                     MemMap_NumCommandQ_MAX,
                                     MemMap_NumCommandQ_ADJUSTABLE,
                                     MemMap_NumCommandQ_POWER_OF_2,
                                     MemMap_NumCommandQ_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumCompletionQ
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumCompletionQ_PARAMETER,
                                     MemMap_NumCompletionQ_MIN,
                                     MemMap_NumCompletionQ_MAX,
                                     MemMap_NumCompletionQ_ADJUSTABLE,
                                     MemMap_NumCompletionQ_POWER_OF_2,
                                     MemMap_NumCompletionQ_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.NumInboundBufferQ
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_NumInboundBufferQ_PARAMETER,
                                     MemMap_NumInboundBufferQ_MIN,
                                     MemMap_NumInboundBufferQ_MAX,
                                     MemMap_NumInboundBufferQ_ADJUSTABLE,
                                     MemMap_NumInboundBufferQ_POWER_OF_2,
                                     MemMap_NumInboundBufferQ_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.InboundBufferSize
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_InboundBufferSize_PARAMETER,
                                     MemMap_InboundBufferSize_MIN,
                                     MemMap_InboundBufferSize_MAX,
                                     MemMap_InboundBufferSize_ADJUSTABLE,
                                     MemMap_InboundBufferSize_POWER_OF_2,
                                     MemMap_InboundBufferSize_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CardRamSize
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CardRamSize_PARAMETER,
                                     MemMap_CardRamSize_MIN,
                                     MemMap_CardRamSize_MAX,
                                     MemMap_CardRamSize_ADJUSTABLE,
                                     MemMap_CardRamSize_POWER_OF_2,
                                     MemMap_CardRamSize_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CardRamAlignment
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CardRamAlignment_PARAMETER,
                                     MemMap_CardRamAlignment_MIN,
                                     MemMap_CardRamAlignment_MAX,
                                     MemMap_CardRamAlignment_ADJUSTABLE,
                                     MemMap_CardRamAlignment_POWER_OF_2,
                                     MemMap_CardRamAlignment_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.HostNvRamSize
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_HostNvRamSize_PARAMETER,
                                     MemMap_HostNvRamSize_MIN,
                                     MemMap_HostNvRamSize_MAX,
                                     MemMap_HostNvRamSize_ADJUSTABLE,
                                     MemMap_HostNvRamSize_POWER_OF_2,
                                     MemMap_HostNvRamSize_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.ExchangeTableLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_ExchangeTableLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_ExchangeTableLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_ExchangeTableLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SGLsLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SGLsLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_SGLsLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_SGLsLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.FCP_CMND_Loc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_FCP_CMND_Loc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_FCP_CMND_Loc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_FCP_CMND_Loc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.FCP_RESP_Loc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_FCP_RESP_Loc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_FCP_RESP_Loc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_FCP_RESP_Loc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.SF_CMND_Loc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_SF_CMND_Loc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_SF_CMND_Loc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_SF_CMND_Loc_DEFAULT,
                                     EnforceDefaults
                                   );

#ifdef _DvrArch_1_30_
    Calculation->Parameters.Pkt_CMND_Loc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_Pkt_CMND_Loc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_Pkt_CMND_Loc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_Pkt_CMND_Loc_DEFAULT,
                                     EnforceDefaults
                                   );
#endif /* _DvrArch_1_30_ was not defined */

    Calculation->Parameters.CommandQLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CommandQLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_CommandQLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_CommandQLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CommandQConsLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CommandQConsLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_CommandQConsLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_CommandQConsLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CompletionQLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CompletionQLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_CompletionQLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_CompletionQLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.CompletionQProdLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_CompletionQProdLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_CompletionQProdLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_CompletionQProdLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.InboundBufferLoc
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_InboundBufferLoc_PARAMETER,
                                     MemMap_Alloc_From_Host,
                                     MemMap_Alloc_On_Card,
                                     MemMap_InboundBufferLoc_ADJUSTABLE,
                                     agFALSE,
                                     MemMap_InboundBufferLoc_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.TimerTickInterval
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_TimerTickInterval_PARAMETER,
                                     MemMap_TimerTickInterval_MIN,
                                     MemMap_TimerTickInterval_MAX,
                                     MemMap_TimerTickInterval_ADJUSTABLE,
                                     MemMap_TimerTickInterval_POWER_OF_2,
                                     MemMap_TimerTickInterval_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IO_Mode
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IO_Mode_PARAMETER,
                                     MemMap_IO_Mode_MIN,
                                     MemMap_IO_Mode_MAX,
                                     MemMap_IO_Mode_ADJUSTABLE,
                                     MemMap_IO_Mode_POWER_OF_2,
                                     MemMap_IO_Mode_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IntDelayAmount
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IntDelayAmount_PARAMETER,
                                     MemMap_IntDelayAmount_MIN,
                                     MemMap_IntDelayAmount_MAX,
                                     MemMap_IntDelayAmount_ADJUSTABLE,
                                     MemMap_IntDelayAmount_POWER_OF_2,
                                     MemMap_IntDelayAmount_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IntDelayRateMethod
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IntDelayRateMethod_PARAMETER,
                                     MemMap_IntDelayRateMethod_MIN,
                                     MemMap_IntDelayRateMethod_MAX,
                                     MemMap_IntDelayRateMethod_ADJUSTABLE,
                                     MemMap_IntDelayRateMethod_POWER_OF_2,
                                     MemMap_IntDelayRateMethod_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IntDelayOnIORate
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IntDelayOnIORate_PARAMETER,
                                     MemMap_IntDelayOnIORate_MIN,
                                     MemMap_IntDelayOnIORate_MAX,
                                     MemMap_IntDelayOnIORate_ADJUSTABLE,
                                     MemMap_IntDelayOnIORate_POWER_OF_2,
                                     MemMap_IntDelayOnIORate_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IntDelayOffIORate
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IntDelayOffIORate_PARAMETER,
                                     MemMap_IntDelayOffIORate_MIN,
                                     MemMap_IntDelayOffIORate_MAX,
                                     MemMap_IntDelayOffIORate_ADJUSTABLE,
                                     MemMap_IntDelayOffIORate_POWER_OF_2,
                                     MemMap_IntDelayOffIORate_DEFAULT,
                                     EnforceDefaults
                                   );

    Calculation->Parameters.IOsBetweenISRs
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_IOsBetweenISRs_PARAMETER,
                                     MemMap_IOsBetweenISRs_MIN,
                                     MemMap_IOsBetweenISRs_MAX,
                                     MemMap_IOsBetweenISRs_ADJUSTABLE,
                                     MemMap_IOsBetweenISRs_POWER_OF_2,
                                     MemMap_IOsBetweenISRs_DEFAULT,
                                     EnforceDefaults
                                   );

#ifdef _Enforce_MaxCommittedMemory_
    Calculation->Parameters.MaxCommittedMemory
        = fiMemMapGetParameterBit32(
                                     hpRoot,
                                     MemMap_MaxCommittedMemory_PARAMETER,
                                     MemMap_MaxCommittedMemory_MIN,
                                     MemMap_MaxCommittedMemory_MAX,
                                     MemMap_MaxCommittedMemory_ADJUSTABLE,
                                     MemMap_MaxCommittedMemory_POWER_OF_2,
                                     MemMap_MaxCommittedMemory_DEFAULT,
                                     EnforceDefaults
                                   );
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    Calculation->Parameters.FlashUsageModel 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_FlashUsageModel_PARAMETER,
                                    MemMap_FlashUsageModel_MIN,
                                    MemMap_FlashUsageModel_MAX,
                                    MemMap_FlashUsageModel_ADJUSTABLE,
                                    MemMap_FlashUsageModel_POWER_OF_2,
                                    MemMap_FlashUsageModel_DEFAULT,
                                    EnforceDefaults
                                   );

    Calculation->Parameters.InitAsNport 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_InitAsNport_PARAMETER,
                                    MemMap_InitAsNport_MIN,
                                    MemMap_InitAsNport_MAX,
                                    MemMap_InitAsNport_ADJUSTABLE,
                                    MemMap_InitAsNport_POWER_OF_2,
                                    MemMap_InitAsNport_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.RelyOnLossSyncStatus 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_RelyOnLossSyncStatus_PARAMETER,
                                    MemMap_RelyOnLossSyncStatus_MIN,
                                    MemMap_RelyOnLossSyncStatus_MAX,
                                    MemMap_RelyOnLossSyncStatus_ADJUSTABLE,
                                    MemMap_RelyOnLossSyncStatus_POWER_OF_2,
                                    MemMap_RelyOnLossSyncStatus_DEFAULT,
                                    EnforceDefaults
                                   );
/* New to r20 */
    Calculation->Parameters.WolfPack 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_WolfPack_PARAMETER,
                                    MemMap_WolfPack_MIN,
                                    MemMap_WolfPack_MAX,
                                    MemMap_WolfPack_ADJUSTABLE,
                                    MemMap_WolfPack_POWER_OF_2,
                                    MemMap_WolfPack_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.HeartBeat 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_HeartBeat_PARAMETER,
                                    MemMap_HeartBeat_MIN,
                                    MemMap_HeartBeat_MAX,
                                    MemMap_HeartBeat_ADJUSTABLE,
                                    MemMap_HeartBeat_POWER_OF_2,
                                    MemMap_HeartBeat_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.ED_TOV 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_ED_TOV_PARAMETER,
                                    MemMap_ED_TOV_MIN,
                                    MemMap_ED_TOV_MAX,
                                    MemMap_ED_TOV_ADJUSTABLE,
                                    MemMap_ED_TOV_POWER_OF_2,
                                    MemMap_ED_TOV_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.RT_TOV 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_RT_TOV_PARAMETER,
                                    MemMap_RT_TOV_MIN,
                                    MemMap_RT_TOV_MAX,
                                    MemMap_RT_TOV_ADJUSTABLE,
                                    MemMap_RT_TOV_POWER_OF_2,
                                    MemMap_RT_TOV_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.LP_TOV 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_LP_TOV_PARAMETER,
                                    MemMap_LP_TOV_MIN,
                                    MemMap_LP_TOV_MAX,
                                    MemMap_LP_TOV_ADJUSTABLE,
                                    MemMap_LP_TOV_POWER_OF_2,
                                    MemMap_LP_TOV_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.AL_Time 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_AL_Time_PARAMETER,
                                    MemMap_AL_Time_MIN,
                                    MemMap_AL_Time_MAX,
                                    MemMap_AL_Time_ADJUSTABLE,
                                    MemMap_AL_Time_POWER_OF_2,
                                    MemMap_AL_Time_DEFAULT,
                                    EnforceDefaults
                                   );
    Calculation->Parameters.R_A_TOV 
        = fiMemMapGetParameterBit32(
                                    hpRoot,
                                    MemMap_R_A_TOV_PARAMETER,
                                    MemMap_R_A_TOV_MIN,
                                    MemMap_R_A_TOV_MAX,
                                    MemMap_R_A_TOV_ADJUSTABLE,
                                    MemMap_R_A_TOV_POWER_OF_2,
                                    MemMap_R_A_TOV_DEFAULT,
                                    EnforceDefaults
                                   );
/* New to r20 */

}

/*+
Function:  fiMemMapAlignUp()

Purpose:   Rounds up (if necessary) "base" to a multiple of "align".

Algorithm: This function simply rounds up "base" to the next "align"
           boundary if it isn't already so aligned.  If "align" is
           ZERO, then "base" is simply rounded up to the next power of 2.
-*/

#define fiMemMapAlignUp_Power_of_2    0
#define fiMemMapAlignUp_None_Required 1

os_bit32 fiMemMapAlignUp(
                          os_bit32 base,
                          os_bit32 align
                        )
{
    os_bit32 to_return;

    if (align == fiMemMapAlignUp_Power_of_2)
    {
        /* Align "base" up to next power of 2 (if necessary) */

        to_return = 0x80000000;

        while (to_return > base)
        {
            to_return = to_return >> 1;
        }

        if (to_return != base)
        {
            to_return = to_return << 1;
        }
    }
    else /* align != fiMemMapAlignUp_Power_of_2 */
    {
        to_return = base + align - 1;

        to_return = to_return / align;

        to_return = to_return * align;
    }

    return to_return;
}

/*+
Function:  fiMemMapAlignUpPtr()

Purpose:   Similar to fiMemMapAlignUp() except works with void pointers.

Algorithm: This function simply rounds up "base" to the next "align"
           boundary if it isn't already so aligned.  An "align" of ZERO
           (requesting rounding up to the next power of 2) is not supported.
-*/

void *fiMemMapAlignUpPtr(
                          void     *base,
                          os_bit32  align
                        )
{
    os_bitptr to_return;

    to_return = (os_bitptr)base + align - 1;

    to_return = to_return / align;

    to_return = to_return * align;

    return (void *)to_return;
}

/*+
Function:  fiMemMapSetupLayoutObjects()

Purpose:   Using the specified parameters, size all FC Layer objects.

Algorithm: This function computes the size and location for all FC Layer
           objects based on the values in the the Calculation->Parameters
           structure.  It also places each object on an unsorted list.
-*/

void fiMemMapSetupLayoutObjects(
                                 agRoot_t              *hpRoot,
                                 fiMemMapCalculation_t *Calculation
                               )
{
    Calculation->MemoryLayout.On_Card_MASK               = ((Calculation->Parameters.ExchangeTableLoc   == MemMap_Alloc_On_Card) ? MemMap_ExchangeTableLoc_MASK : 0)   |
                                                           ((Calculation->Parameters.SGLsLoc            == MemMap_Alloc_On_Card) ? MemMap_SGLsLoc_MASK : 0)            |
                                                           ((Calculation->Parameters.FCP_CMND_Loc       == MemMap_Alloc_On_Card) ? MemMap_FCP_CMND_Loc_MASK : 0)       |
                                                           ((Calculation->Parameters.FCP_RESP_Loc       == MemMap_Alloc_On_Card) ? MemMap_FCP_RESP_Loc_MASK : 0)       |
                                                           ((Calculation->Parameters.SF_CMND_Loc        == MemMap_Alloc_On_Card) ? MemMap_SF_CMND_Loc_MASK : 0)        |

#ifdef _DvrArch_1_30_
                                                           ((Calculation->Parameters.Pkt_CMND_Loc       == MemMap_Alloc_On_Card) ? MemMap_Pkt_CMND_Loc_MASK : 0)       |
#endif /* _DvrArch_1_30_ was not defined */
                                                           ((Calculation->Parameters.CommandQLoc        == MemMap_Alloc_On_Card) ? MemMap_CommandQLoc_MASK : 0)        |
                                                           ((Calculation->Parameters.CompletionQLoc     == MemMap_Alloc_On_Card) ? MemMap_CompletionQLoc_MASK : 0)     |
                                                           ((Calculation->Parameters.CommandQConsLoc    == MemMap_Alloc_On_Card) ? MemMap_CommandQConsLoc_MASK : 0)    |
                                                           ((Calculation->Parameters.CompletionQProdLoc == MemMap_Alloc_On_Card) ? MemMap_CompletionQProdLoc_MASK : 0) |
                                                           ((Calculation->Parameters.InboundBufferLoc   == MemMap_Alloc_On_Card) ? MemMap_InboundBufferLoc_MASK : 0);

    Calculation->MemoryLayout.unsorted                   = &(Calculation->MemoryLayout.SEST);

    Calculation->MemoryLayout.SEST.elements              = Calculation->Parameters.NumIOs;
    Calculation->MemoryLayout.SEST.elementSize           = sizeof(SEST_t);
    Calculation->MemoryLayout.SEST.objectSize            = Calculation->MemoryLayout.SEST.elements * Calculation->MemoryLayout.SEST.elementSize;
    Calculation->MemoryLayout.SEST.objectAlign           = fiMemMapAlignUp(
                                                                            Calculation->MemoryLayout.SEST.objectSize,
                                                                            fiMemMapAlignUp_Power_of_2
                                                                          );
    Calculation->MemoryLayout.SEST.memLoc                = ((Calculation->Parameters.ExchangeTableLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.SEST.flink                 = &(Calculation->MemoryLayout.ESGL);

    Calculation->MemoryLayout.ESGL.elements              = Calculation->Parameters.NumSGLs;
    Calculation->MemoryLayout.ESGL.elementSize           = Calculation->Parameters.SizeSGLs * sizeof(SG_Element_t);
    Calculation->MemoryLayout.ESGL.objectSize            = Calculation->MemoryLayout.ESGL.elements * Calculation->MemoryLayout.ESGL.elementSize;
    Calculation->MemoryLayout.ESGL.objectAlign           = Calculation->MemoryLayout.ESGL.elementSize;
    Calculation->MemoryLayout.ESGL.memLoc                = ((Calculation->Parameters.SGLsLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.ESGL.flink                 = &(Calculation->MemoryLayout.FCP_CMND);

    Calculation->MemoryLayout.FCP_CMND.elements          = Calculation->Parameters.NumIOs;
    Calculation->MemoryLayout.FCP_CMND.elementSize       = Calculation->Parameters.FCP_CMND_Size;
    Calculation->MemoryLayout.FCP_CMND.objectSize        = Calculation->MemoryLayout.FCP_CMND.elements * Calculation->MemoryLayout.FCP_CMND.elementSize;
    Calculation->MemoryLayout.FCP_CMND.objectAlign       = Calculation->MemoryLayout.FCP_CMND.elementSize;
    Calculation->MemoryLayout.FCP_CMND.memLoc            = ((Calculation->Parameters.FCP_CMND_Loc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.FCP_CMND.flink             = &(Calculation->MemoryLayout.FCP_RESP);

    Calculation->MemoryLayout.FCP_RESP.elements          = Calculation->Parameters.NumIOs;
    Calculation->MemoryLayout.FCP_RESP.elementSize       = Calculation->Parameters.FCP_RESP_Size;
    Calculation->MemoryLayout.FCP_RESP.objectSize        = Calculation->MemoryLayout.FCP_RESP.elements * Calculation->MemoryLayout.FCP_RESP.elementSize;
    Calculation->MemoryLayout.FCP_RESP.objectAlign       = Calculation->MemoryLayout.FCP_RESP.elementSize;
    Calculation->MemoryLayout.FCP_RESP.memLoc            = ((Calculation->Parameters.FCP_RESP_Loc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.FCP_RESP.flink             = &(Calculation->MemoryLayout.SF_CMND);

    Calculation->MemoryLayout.SF_CMND.elements           = Calculation->Parameters.SF_CMND_Reserve;
    Calculation->MemoryLayout.SF_CMND.elementSize        = Calculation->Parameters.SF_CMND_Size;
    Calculation->MemoryLayout.SF_CMND.objectSize         = Calculation->MemoryLayout.SF_CMND.elements * Calculation->MemoryLayout.SF_CMND.elementSize;
    Calculation->MemoryLayout.SF_CMND.objectAlign        = Calculation->MemoryLayout.SF_CMND.elementSize;
    Calculation->MemoryLayout.SF_CMND.memLoc             = ((Calculation->Parameters.SF_CMND_Loc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.SF_CMND.flink              = &(Calculation->MemoryLayout.ERQ);
#ifdef _DvrArch_1_30_
    Calculation->MemoryLayout.SF_CMND.flink              = &(Calculation->MemoryLayout.Pkt_CMND);

    Calculation->MemoryLayout.Pkt_CMND.elements           = Calculation->Parameters.NumPktThreads;
    Calculation->MemoryLayout.Pkt_CMND.elementSize        = Calculation->Parameters.Pkt_CMND_Size;
    Calculation->MemoryLayout.Pkt_CMND.objectSize         = Calculation->MemoryLayout.Pkt_CMND.elements * Calculation->MemoryLayout.Pkt_CMND.elementSize;
    Calculation->MemoryLayout.Pkt_CMND.objectAlign        = Calculation->MemoryLayout.Pkt_CMND.elementSize;
    Calculation->MemoryLayout.Pkt_CMND.memLoc             = ((Calculation->Parameters.Pkt_CMND_Loc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.Pkt_CMND.flink              = &(Calculation->MemoryLayout.ERQ);
#else
    Calculation->MemoryLayout.SF_CMND.flink              = &(Calculation->MemoryLayout.ERQ);
#endif /* _DvrArch_1_30_ was not defined */

    Calculation->MemoryLayout.ERQ.elements               = Calculation->Parameters.NumCommandQ;
    Calculation->MemoryLayout.ERQ.elementSize            = sizeof(IRB_t);
    Calculation->MemoryLayout.ERQ.objectSize             = Calculation->MemoryLayout.ERQ.elements * Calculation->MemoryLayout.ERQ.elementSize;
    Calculation->MemoryLayout.ERQ.objectAlign            = Calculation->MemoryLayout.ERQ.objectSize;
    Calculation->MemoryLayout.ERQ.memLoc                 = ((Calculation->Parameters.CommandQLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.ERQ.flink                  = &(Calculation->MemoryLayout.ERQConsIndex);

    Calculation->MemoryLayout.ERQConsIndex.elements      = 1;
    Calculation->MemoryLayout.ERQConsIndex.elementSize   = sizeof(ERQConsIndex_t);
    Calculation->MemoryLayout.ERQConsIndex.objectSize    = Calculation->MemoryLayout.ERQConsIndex.elements * Calculation->MemoryLayout.ERQConsIndex.elementSize;
    Calculation->MemoryLayout.ERQConsIndex.objectAlign   = Calculation->MemoryLayout.ERQConsIndex.elementSize * 2;
    Calculation->MemoryLayout.ERQConsIndex.memLoc        = ((Calculation->Parameters.CommandQConsLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.ERQConsIndex.flink         = &(Calculation->MemoryLayout.IMQ);

    Calculation->MemoryLayout.IMQ.elements               = Calculation->Parameters.NumCompletionQ;
    Calculation->MemoryLayout.IMQ.elementSize            = sizeof(Completion_Message_t);
    Calculation->MemoryLayout.IMQ.objectSize             = Calculation->MemoryLayout.IMQ.elements * Calculation->MemoryLayout.IMQ.elementSize;
    Calculation->MemoryLayout.IMQ.objectAlign            = Calculation->MemoryLayout.IMQ.objectSize;
    Calculation->MemoryLayout.IMQ.memLoc                 = ((Calculation->Parameters.CompletionQLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.IMQ.flink                  = &(Calculation->MemoryLayout.IMQProdIndex);

    Calculation->MemoryLayout.IMQProdIndex.elements      = 1;
    Calculation->MemoryLayout.IMQProdIndex.elementSize   = sizeof(IMQProdIndex_t);
    Calculation->MemoryLayout.IMQProdIndex.objectSize    = Calculation->MemoryLayout.IMQProdIndex.elements * Calculation->MemoryLayout.IMQProdIndex.elementSize;
    Calculation->MemoryLayout.IMQProdIndex.objectAlign   = Calculation->MemoryLayout.IMQProdIndex.elementSize * 2;
    Calculation->MemoryLayout.IMQProdIndex.memLoc        = ((Calculation->Parameters.CompletionQProdLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.IMQProdIndex.flink         = &(Calculation->MemoryLayout.SFQ);

    Calculation->MemoryLayout.SFQ.elements               = Calculation->Parameters.NumInboundBufferQ;
    Calculation->MemoryLayout.SFQ.elementSize            = Calculation->Parameters.InboundBufferSize;
    Calculation->MemoryLayout.SFQ.objectSize             = Calculation->MemoryLayout.SFQ.elements * Calculation->MemoryLayout.SFQ.elementSize;
    Calculation->MemoryLayout.SFQ.objectAlign            = Calculation->MemoryLayout.SFQ.objectSize;
    Calculation->MemoryLayout.SFQ.memLoc                 = ((Calculation->Parameters.InboundBufferLoc == MemMap_Alloc_On_Card) ? inCardRam : inDmaMemory);
    Calculation->MemoryLayout.SFQ.flink                  = &(Calculation->MemoryLayout.FlashSector);

    Calculation->MemoryLayout.FlashSector.elements       = 1;
    Calculation->MemoryLayout.FlashSector.elementSize    = sizeof(fiFlashSector_Last_Form_t);
    Calculation->MemoryLayout.FlashSector.objectSize     = Calculation->MemoryLayout.FlashSector.elements * Calculation->MemoryLayout.FlashSector.elementSize;
    Calculation->MemoryLayout.FlashSector.objectAlign    = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.FlashSector.memLoc         = inCachedMemory;
    Calculation->MemoryLayout.FlashSector.flink          = &(Calculation->MemoryLayout.SlotWWN);

    Calculation->MemoryLayout.SlotWWN.elements           = Calculation->Parameters.NumDevSlotsPerArea * Calculation->Parameters.NumAreasPerDomain * Calculation->Parameters.NumDomains;
    Calculation->MemoryLayout.SlotWWN.elementSize        = sizeof(SlotWWN_t);
    Calculation->MemoryLayout.SlotWWN.objectSize         = Calculation->MemoryLayout.SlotWWN.elements * Calculation->MemoryLayout.SlotWWN.elementSize;
    Calculation->MemoryLayout.SlotWWN.objectAlign        = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.SlotWWN.memLoc             = inCachedMemory;
    Calculation->MemoryLayout.SlotWWN.flink              = &(Calculation->MemoryLayout.CThread);

    Calculation->MemoryLayout.CThread.elements           = 1;
    Calculation->MemoryLayout.CThread.elementSize        = sizeof(CThread_t);
    Calculation->MemoryLayout.CThread.objectSize         = Calculation->MemoryLayout.CThread.elements * Calculation->MemoryLayout.CThread.elementSize;
    Calculation->MemoryLayout.CThread.objectAlign        = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CThread.memLoc             = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
#ifdef _DvrArch_1_30_
    Calculation->MemoryLayout.CThread.flink              = &(Calculation->MemoryLayout.IPThread);
#else  /* _DvrArch_1_30_ was not defined */
    Calculation->MemoryLayout.CThread.flink              = &(Calculation->MemoryLayout.TgtThread);
#endif /* _DvrArch_1_30_ was not defined */
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.CThread.flink              = &(Calculation->MemoryLayout.CTransitions);

    Calculation->MemoryLayout.CTransitions.elements      = 1;
    Calculation->MemoryLayout.CTransitions.elementSize   = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.CTransitions.objectSize    = Calculation->MemoryLayout.CTransitions.elements * Calculation->MemoryLayout.CTransitions.elementSize;
    Calculation->MemoryLayout.CTransitions.objectAlign   = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CTransitions.memLoc        = inCachedMemory;
    Calculation->MemoryLayout.CTransitions.flink         = &(Calculation->MemoryLayout.CActions);

    Calculation->MemoryLayout.CActions.elements          = 1;
    Calculation->MemoryLayout.CActions.elementSize       = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.CActions.objectSize        = Calculation->MemoryLayout.CActions.elements * Calculation->MemoryLayout.CActions.elementSize;
    Calculation->MemoryLayout.CActions.objectAlign       = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CActions.memLoc            = inCachedMemory;
#ifdef _DvrArch_1_30_
    Calculation->MemoryLayout.CActions.flink             = &(Calculation->MemoryLayout.IPThread);
#else  /* _DvrArch_1_30_ was not defined */
    Calculation->MemoryLayout.CActions.flink             = &(Calculation->MemoryLayout.TgtThread);
#endif /* _DvrArch_1_30_ was not defined */
#endif /* __State_Force_Static_State_Tables__ was not defined */

#ifdef _DvrArch_1_30_
    Calculation->MemoryLayout.IPThread.elements          = 1;
    Calculation->MemoryLayout.IPThread.elementSize       = sizeof(IPThread_t);
    Calculation->MemoryLayout.IPThread.objectSize        = Calculation->MemoryLayout.IPThread.elements * Calculation->MemoryLayout.IPThread.elementSize;
    Calculation->MemoryLayout.IPThread.objectAlign       = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.IPThread.memLoc            = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.IPThread.flink             = &(Calculation->MemoryLayout.PktThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.IPThread.flink             = &(Calculation->MemoryLayout.IPTransitions);

    Calculation->MemoryLayout.IPTransitions.elements     = 1;
    Calculation->MemoryLayout.IPTransitions.elementSize  = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.IPTransitions.objectSize   = Calculation->MemoryLayout.IPTransitions.elements * Calculation->MemoryLayout.IPTransitions.elementSize;
    Calculation->MemoryLayout.IPTransitions.objectAlign  = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.IPTransitions.memLoc       = inCachedMemory;
    Calculation->MemoryLayout.IPTransitions.flink        = &(Calculation->MemoryLayout.IPActions);

    Calculation->MemoryLayout.IPActions.elements         = 1;
    Calculation->MemoryLayout.IPActions.elementSize      = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.IPActions.objectSize       = Calculation->MemoryLayout.IPActions.elements * Calculation->MemoryLayout.IPActions.elementSize;
    Calculation->MemoryLayout.IPActions.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.IPActions.memLoc           = inCachedMemory;
    Calculation->MemoryLayout.IPActions.flink            = &(Calculation->MemoryLayout.PktThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.PktThread.elements         = Calculation->Parameters.NumPktThreads;
    Calculation->MemoryLayout.PktThread.elementSize      = sizeof(PktThread_t);
    Calculation->MemoryLayout.PktThread.objectSize       = Calculation->MemoryLayout.PktThread.elements * Calculation->MemoryLayout.PktThread.elementSize;
    Calculation->MemoryLayout.PktThread.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.PktThread.memLoc           = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.PktThread.flink            = &(Calculation->MemoryLayout.TgtThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.PktThread.flink            = &(Calculation->MemoryLayout.PktTransitions);

    Calculation->MemoryLayout.PktTransitions.elements    = 1;
    Calculation->MemoryLayout.PktTransitions.elementSize = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.PktTransitions.objectSize  = Calculation->MemoryLayout.PktTransitions.elements * Calculation->MemoryLayout.PktTransitions.elementSize;
    Calculation->MemoryLayout.PktTransitions.objectAlign = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.PktTransitions.memLoc      = inCachedMemory;
    Calculation->MemoryLayout.PktTransitions.flink       = &(Calculation->MemoryLayout.PktActions);

    Calculation->MemoryLayout.PktActions.elements        = 1;
    Calculation->MemoryLayout.PktActions.elementSize     = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.PktActions.objectSize      = Calculation->MemoryLayout.PktActions.elements * Calculation->MemoryLayout.PktActions.elementSize;
    Calculation->MemoryLayout.PktActions.objectAlign     = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.PktActions.memLoc          = inCachedMemory;
    Calculation->MemoryLayout.PktActions.flink           = &(Calculation->MemoryLayout.TgtThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */
#endif /* _DvrArch_1_30_ was defined */

    Calculation->MemoryLayout.TgtThread.elements         = Calculation->Parameters.NumTgtCmnds;
    Calculation->MemoryLayout.TgtThread.elementSize      = sizeof(TgtThread_t) + Calculation->Parameters.TGT_CMND_Size - sizeof(FCHS_t);
    Calculation->MemoryLayout.TgtThread.objectSize       = Calculation->MemoryLayout.TgtThread.elements * Calculation->MemoryLayout.TgtThread.elementSize;
    Calculation->MemoryLayout.TgtThread.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.TgtThread.memLoc           = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.TgtThread.flink            = &(Calculation->MemoryLayout.DevThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.TgtThread.flink            = &(Calculation->MemoryLayout.TgtTransitions);

    Calculation->MemoryLayout.TgtTransitions.elements    = 1;
    Calculation->MemoryLayout.TgtTransitions.elementSize = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.TgtTransitions.objectSize  = Calculation->MemoryLayout.TgtTransitions.elements * Calculation->MemoryLayout.TgtTransitions.elementSize;
    Calculation->MemoryLayout.TgtTransitions.objectAlign = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.TgtTransitions.memLoc      = inCachedMemory;
    Calculation->MemoryLayout.TgtTransitions.flink       = &(Calculation->MemoryLayout.TgtActions);

    Calculation->MemoryLayout.TgtActions.elements        = 1;
    Calculation->MemoryLayout.TgtActions.elementSize     = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.TgtActions.objectSize      = Calculation->MemoryLayout.TgtActions.elements * Calculation->MemoryLayout.TgtActions.elementSize;
    Calculation->MemoryLayout.TgtActions.objectAlign     = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.TgtActions.memLoc          = inCachedMemory;
    Calculation->MemoryLayout.TgtActions.flink           = &(Calculation->MemoryLayout.DevThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.DevThread.elements         = Calculation->Parameters.NumDevices;
    Calculation->MemoryLayout.DevThread.elementSize      = sizeof(DevThread_t);
    Calculation->MemoryLayout.DevThread.objectSize       = Calculation->MemoryLayout.DevThread.elements * Calculation->MemoryLayout.DevThread.elementSize;
    Calculation->MemoryLayout.DevThread.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.DevThread.memLoc           = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.DevThread.flink            = &(Calculation->MemoryLayout.CDBThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.DevThread.flink            = &(Calculation->MemoryLayout.DevTransitions);

    Calculation->MemoryLayout.DevTransitions.elements    = 1;
    Calculation->MemoryLayout.DevTransitions.elementSize = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.DevTransitions.objectSize  = Calculation->MemoryLayout.DevTransitions.elements * Calculation->MemoryLayout.DevTransitions.elementSize;
    Calculation->MemoryLayout.DevTransitions.objectAlign = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.DevTransitions.memLoc      = inCachedMemory;
    Calculation->MemoryLayout.DevTransitions.flink       = &(Calculation->MemoryLayout.DevActions);

    Calculation->MemoryLayout.DevActions.elements        = 1;
    Calculation->MemoryLayout.DevActions.elementSize     = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.DevActions.objectSize      = Calculation->MemoryLayout.DevActions.elements * Calculation->MemoryLayout.DevActions.elementSize;
    Calculation->MemoryLayout.DevActions.objectAlign     = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.DevActions.memLoc          = inCachedMemory;
    Calculation->MemoryLayout.DevActions.flink           = &(Calculation->MemoryLayout.CDBThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.CDBThread.elements         = Calculation->Parameters.NumIOs;
    Calculation->MemoryLayout.CDBThread.elementSize      = sizeof(CDBThread_t) + ((Calculation->Parameters.SizeCachedSGLs - MemMap_SizeCachedSGLs_MIN) * sizeof(SG_Element_t));
    Calculation->MemoryLayout.CDBThread.objectSize       = Calculation->MemoryLayout.CDBThread.elements * Calculation->MemoryLayout.CDBThread.elementSize;
    Calculation->MemoryLayout.CDBThread.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CDBThread.memLoc           = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.CDBThread.flink            = &(Calculation->MemoryLayout.SFThread);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.CDBThread.flink            = &(Calculation->MemoryLayout.CDBTransitions);

    Calculation->MemoryLayout.CDBTransitions.elements    = 1;
    Calculation->MemoryLayout.CDBTransitions.elementSize = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.CDBTransitions.objectSize  = Calculation->MemoryLayout.CDBTransitions.elements * Calculation->MemoryLayout.CDBTransitions.elementSize;
    Calculation->MemoryLayout.CDBTransitions.objectAlign = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CDBTransitions.memLoc      = inCachedMemory;
    Calculation->MemoryLayout.CDBTransitions.flink       = &(Calculation->MemoryLayout.CDBActions);

    Calculation->MemoryLayout.CDBActions.elements        = 1;
    Calculation->MemoryLayout.CDBActions.elementSize     = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.CDBActions.objectSize      = Calculation->MemoryLayout.CDBActions.elements * Calculation->MemoryLayout.CDBActions.elementSize;
    Calculation->MemoryLayout.CDBActions.objectAlign     = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.CDBActions.memLoc          = inCachedMemory;
    Calculation->MemoryLayout.CDBActions.flink           = &(Calculation->MemoryLayout.SFThread);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.SFThread.elements          = Calculation->Parameters.SF_CMND_Reserve;
    Calculation->MemoryLayout.SFThread.elementSize       = sizeof(SFThread_t);
    Calculation->MemoryLayout.SFThread.objectSize        = Calculation->MemoryLayout.SFThread.elements * Calculation->MemoryLayout.SFThread.elementSize;
    Calculation->MemoryLayout.SFThread.objectAlign       = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.SFThread.memLoc            = inCachedMemory;
#ifdef __State_Force_Static_State_Tables__
    Calculation->MemoryLayout.SFThread.flink             = &(Calculation->MemoryLayout.LOOPDeviceMAP);
#else /* __State_Force_Static_State_Tables__ was not defined */
    Calculation->MemoryLayout.SFThread.flink             = &(Calculation->MemoryLayout.SFTransitions);

    Calculation->MemoryLayout.SFTransitions.elements     = 1;
    Calculation->MemoryLayout.SFTransitions.elementSize  = sizeof(stateTransitionMatrix_t);
    Calculation->MemoryLayout.SFTransitions.objectSize   = Calculation->MemoryLayout.SFTransitions.elements * Calculation->MemoryLayout.SFTransitions.elementSize;
    Calculation->MemoryLayout.SFTransitions.objectAlign  = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.SFTransitions.memLoc       = inCachedMemory;
    Calculation->MemoryLayout.SFTransitions.flink        = &(Calculation->MemoryLayout.SFActions);

    Calculation->MemoryLayout.SFActions.elements         = 1;
    Calculation->MemoryLayout.SFActions.elementSize      = sizeof(stateActionScalar_t);
    Calculation->MemoryLayout.SFActions.objectSize       = Calculation->MemoryLayout.SFActions.elements * Calculation->MemoryLayout.SFActions.elementSize;
    Calculation->MemoryLayout.SFActions.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.SFActions.memLoc           = inCachedMemory;
    Calculation->MemoryLayout.SFActions.flink            = &(Calculation->MemoryLayout.LOOPDeviceMAP);
#endif /* __State_Force_Static_State_Tables__ was not defined */

    Calculation->MemoryLayout.LOOPDeviceMAP.elements         = 1;
    Calculation->MemoryLayout.LOOPDeviceMAP.elementSize      = MemMap_NumLOOPDeviceMAP_DEFAULT;
    Calculation->MemoryLayout.LOOPDeviceMAP.objectSize       = MemMap_NumLOOPDeviceMAP_DEFAULT;
    Calculation->MemoryLayout.LOOPDeviceMAP.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.LOOPDeviceMAP.memLoc           = inCachedMemory;
    Calculation->MemoryLayout.LOOPDeviceMAP.flink            =  &(Calculation->MemoryLayout.FabricDeviceMAP);


    Calculation->MemoryLayout.FabricDeviceMAP.elements         = Calculation->Parameters.NumDevices;
    Calculation->MemoryLayout.FabricDeviceMAP.elementSize      = sizeof(os_bit32);
    Calculation->MemoryLayout.FabricDeviceMAP.objectSize       = sizeof(os_bit32) * Calculation->Parameters.NumDevices;
    Calculation->MemoryLayout.FabricDeviceMAP.objectAlign      = fiMemMapAlignUp_None_Required;
    Calculation->MemoryLayout.FabricDeviceMAP.memLoc           = inCachedMemory;
    Calculation->MemoryLayout.FabricDeviceMAP.flink            = (fiMemMapMemoryDescriptor_t *)agNULL;

}

/*+
Function:  fiMemMapSortByAlignThenSize()

Purpose:   Inserts an object into a sorted list based on alignment & size.

Algorithm: This function inserts an object in the specified list.  This
           list is sorted to start with the object requiring the largest
           alignment.  If two objects require the same alignment, the
           larger object will appear first.
-*/

void fiMemMapSortByAlignThenSize(
                                  agRoot_t                    *hpRoot,
                                  fiMemMapMemoryDescriptor_t **listHead,
                                  fiMemMapMemoryDescriptor_t  *listObject
                                )
{
    fiMemMapMemoryDescriptor_t **insertAfter  =  listHead;
    fiMemMapMemoryDescriptor_t  *insertBefore = *listHead;

    while ((insertBefore != (fiMemMapMemoryDescriptor_t *)agNULL) &&
           ((listObject->objectAlign < insertBefore->objectAlign) ||
            ((listObject->objectAlign == insertBefore->objectAlign) &&
             (listObject->objectSize < insertBefore->objectSize))))
    {
        insertAfter  = (fiMemMapMemoryDescriptor_t **)(*insertAfter);
        insertBefore =                                 *insertAfter;
    }

     listObject->flink = *insertAfter;
    *insertAfter       =  listObject;
}

/*+
Function:  fiMemMapSortLayoutObjects()

Purpose:   Creates ordered lists of objects for each memory type.

Algorithm: This function creates a sorted list for each memory type to
           hold objects of decreasing alignment & size.
-*/

void fiMemMapSortLayoutObjects(
                                agRoot_t               *hpRoot,
                                fiMemMapMemoryLayout_t *MemoryLayout
                              )
{
    fiMemMapMemoryDescriptor_t *nextDescriptor;
    
    MemoryLayout->sortedCachedMemory = (fiMemMapMemoryDescriptor_t *)agNULL;
    MemoryLayout->sortedDmaMemory    = (fiMemMapMemoryDescriptor_t *)agNULL;
    MemoryLayout->sortedCardRam      = (fiMemMapMemoryDescriptor_t *)agNULL;

    while (MemoryLayout->unsorted != ((fiMemMapMemoryDescriptor_t *)agNULL))
    {
        nextDescriptor = MemoryLayout->unsorted;

        MemoryLayout->unsorted = nextDescriptor->flink;

        if (nextDescriptor->memLoc == inCachedMemory)
        {
            fiMemMapSortByAlignThenSize(
                                         hpRoot,
                                         &(MemoryLayout->sortedCachedMemory),
                                         nextDescriptor
                                       );
        }
        else if (nextDescriptor->memLoc == inDmaMemory)
        {
            fiMemMapSortByAlignThenSize(
                                         hpRoot,
                                         &(MemoryLayout->sortedDmaMemory),
                                         nextDescriptor
                                       );
        }
        else /* nextDescriptor->memLoc == inCardRam */
        {
            fiMemMapSortByAlignThenSize(
                                         hpRoot,
                                         &(MemoryLayout->sortedCardRam),
                                         nextDescriptor
                                       );
        }
    }
}

/*+
Function:  fiMemMapLayoutObjects()

Purpose:   Allocates memory for each object in the FC Layer.

Algorithm: This function walks each sorted list of objects allocating
           the corresponding type of memory while obeying the alignment
           restrictions of each object.  All addresses & offsets are
           computed along the way based on the supplied base addresses.
-*/

void fiMemMapLayoutObjects(
                            agRoot_t              *hpRoot,
                            fiMemMapCalculation_t *Calculation
                          )
{
    fiMemMapMemoryDescriptor_t *MemoryDescriptor;
    os_bit32                       MemoryOffset;

/*+
Allocate CachedMemory objects
-*/

    MemoryDescriptor = Calculation->MemoryLayout.sortedCachedMemory;

    if (MemoryDescriptor == (fiMemMapMemoryDescriptor_t *)agNULL)
    {
        Calculation->ToRequest.cachedMemoryNeeded          = 0;
        Calculation->ToRequest.cachedMemoryPtrAlignAssumed = fiMemMapAlignUp_None_Required;
    }
    else
    {
        Calculation->ToRequest.cachedMemoryPtrAlignAssumed
            = MemoryDescriptor->objectAlign;
    
        MemoryOffset = 0;

        while (MemoryDescriptor != (fiMemMapMemoryDescriptor_t *)agNULL)
        {
            MemoryOffset = fiMemMapAlignUp(
                                            MemoryOffset,
                                            MemoryDescriptor->objectAlign
                                          );

            MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                = (void *)((os_bit8 *)Calculation->Input.cachedMemoryPtr + MemoryOffset);

            MemoryOffset += MemoryDescriptor->objectSize;

            MemoryDescriptor = MemoryDescriptor->flink;
        }

        Calculation->ToRequest.cachedMemoryNeeded = MemoryOffset;
    }

/*+
Allocate DmaMemory objects
-*/

    MemoryDescriptor = Calculation->MemoryLayout.sortedDmaMemory;

    Calculation->ToRequest.dmaMemoryPtrAlignAssumed     = fiMemMapAlignUp_None_Required;

    if (MemoryDescriptor == (fiMemMapMemoryDescriptor_t *)agNULL)
    {
        Calculation->ToRequest.dmaMemoryNeeded          = 0;
        Calculation->ToRequest.dmaMemoryPhyAlignAssumed = fiMemMapAlignUp_None_Required;
    }
    else
    {
        Calculation->ToRequest.dmaMemoryPhyAlignAssumed
            = MemoryDescriptor->objectAlign;
    
        MemoryOffset = 0;

        while (MemoryDescriptor != (fiMemMapMemoryDescriptor_t *)agNULL)
        {
            MemoryOffset = fiMemMapAlignUp(
                                            MemoryOffset,
                                            MemoryDescriptor->objectAlign
                                          );

            MemoryDescriptor->addr.DmaMemory.dmaMemoryUpper32
                = Calculation->Input.dmaMemoryUpper32;
            MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32
                = Calculation->Input.dmaMemoryLower32 + MemoryOffset;
            MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr
                = (void *)((os_bit8 *)Calculation->Input.dmaMemoryPtr + MemoryOffset);

            MemoryOffset += MemoryDescriptor->objectSize;

            MemoryDescriptor = MemoryDescriptor->flink;
        }

        Calculation->ToRequest.dmaMemoryNeeded = MemoryOffset;
    }

/*+
Allocate CardRam objects
-*/

    MemoryDescriptor = Calculation->MemoryLayout.sortedCardRam;

    if (MemoryDescriptor == (fiMemMapMemoryDescriptor_t *)agNULL)
    {
        Calculation->ToRequest.cardRamNeeded          = 0;
        Calculation->ToRequest.cardRamPhyAlignAssumed = fiMemMapAlignUp_None_Required;
    }
    else
    {
        Calculation->ToRequest.cardRamPhyAlignAssumed
            = MemoryDescriptor->objectAlign;
    
        MemoryOffset = 0;

        while (MemoryDescriptor != (fiMemMapMemoryDescriptor_t *)agNULL)
        {
            MemoryOffset = fiMemMapAlignUp(
                                            MemoryOffset,
                                            MemoryDescriptor->objectAlign
                                          );

            MemoryDescriptor->addr.CardRam.cardRamUpper32
                = Calculation->Input.cardRamUpper32;
            MemoryDescriptor->addr.CardRam.cardRamLower32
                = Calculation->Input.cardRamLower32 + MemoryOffset;
            MemoryDescriptor->addr.CardRam.cardRamOffset = MemoryOffset;

            MemoryOffset += MemoryDescriptor->objectSize;

            MemoryDescriptor = MemoryDescriptor->flink;
        }

        Calculation->ToRequest.cardRamNeeded = MemoryOffset;
    }

    Calculation->ToRequest.nvMemoryNeeded
        = Calculation->Parameters.HostNvRamSize;

    Calculation->ToRequest.usecsPerTick
        = Calculation->Parameters.TimerTickInterval;
}

/*+
Function:  fiMemMapFinishToRequest()

Purpose:   Completes the ToRequest portion of Calculation.

Algorithm: This function merely fills in the ToRequest portion of
           the Calculation structure with the values unrelated to
           memory objects allocated in fiMemMapLayoutObjects().
-*/

void fiMemMapFinishToRequest(
                              agRoot_t              *hpRoot,
                              fiMemMapCalculation_t *Calculation
                            )
{
    Calculation->ToRequest.nvMemoryNeeded
        = Calculation->Parameters.HostNvRamSize;

    Calculation->ToRequest.usecsPerTick
        = Calculation->Parameters.TimerTickInterval;
}

/*+
Function:  fiMemMapValidate()

Purpose:   Validates the Input portion of Calculation.

Algorithm: This function verifies that the Input portion of
           the Calculation structure satisfies the ToRequest
           portion of the Calculation structure.
-*/

agBOOLEAN fiMemMapValidate(
                          agRoot_t              *hpRoot,
                          fiMemMapCalculation_t *Calculation
                        )
{
    agBOOLEAN to_return = agTRUE;

    if (Calculation->ToRequest.cachedMemoryNeeded > Calculation->Input.cachedMemoryLen)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): cachedMemoryNeeded > cachedMemoryLen",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }
    
    if (Calculation->Input.cachedMemoryPtr !=
        fiMemMapAlignUpPtr(
                            Calculation->Input.cachedMemoryPtr,
                            Calculation->ToRequest.cachedMemoryPtrAlignAssumed
                          ))
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): cachedMemoryPtr not cachedMemoryPtrAlignAssumed aligned",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    if (Calculation->ToRequest.dmaMemoryNeeded > Calculation->Input.dmaMemoryLen)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): dmaMemoryNeeded > dmaMemoryLen",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }
    
    if (Calculation->Input.dmaMemoryPtr !=
        fiMemMapAlignUpPtr(
                            Calculation->Input.dmaMemoryPtr,
                            Calculation->ToRequest.dmaMemoryPtrAlignAssumed
                          ))
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): dmaMemoryPtr not dmaMemoryPtrAlignAssumed aligned",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    if (Calculation->Input.dmaMemoryLower32 !=
        fiMemMapAlignUp(
                         Calculation->Input.dmaMemoryLower32,
                         Calculation->ToRequest.dmaMemoryPhyAlignAssumed
                       ))
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): dmaMemoryLower32 not dmaMemoryPhyAlignAssumed aligned",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    if (Calculation->ToRequest.cardRamNeeded > Calculation->Input.cardRamLen)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): cardRamNeeded > cardRamLen",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }
    
    if (Calculation->Input.cardRamLower32 !=
        fiMemMapAlignUp(
                         Calculation->Input.cardRamLower32,
                         Calculation->ToRequest.cardRamPhyAlignAssumed
                       ))
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): cardRamLower32 not cardRamPhyAlignAssumed aligned",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    if (Calculation->ToRequest.nvMemoryNeeded > Calculation->Input.nvMemoryLen)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "fiMemMapValidate(): nvMemoryNeeded > nvMemoryLen",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        to_return = agFALSE;
    }

    return to_return;
}

/*+
Function:  fiMemMapDumpBit32()

Purpose:   Shorthand for a call to fiLogDebugString().

Algorithm: This function simply calls fiLogDebugString() logging the
           specified Bit32 value.
-*/

void fiMemMapDumpBit32(
                        agRoot_t *hpRoot,
                        char     *formatString,
                        os_bit32     Bit32
                      )
{
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      formatString,
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      Bit32,
                      0,0,0,0,0,0,0
                    );
}

/*+
Function:  fiMemMapDumpMemoryDescriptor()

Purpose:   Logs the various fields of a MemoryDescriptor.

Algorithm: This function logs each of the fields of a MemoryDescriptor
           object.  MemoryDescriptor objects for each type of memory
           are supported.
-*/

void fiMemMapDumpMemoryDescriptor(
                                   agRoot_t                   *hpRoot,
                                   char                       *headingString,
                                   fiMemMapMemoryDescriptor_t *MemoryDescriptor
                                 )
{
    if (MemoryDescriptor->memLoc == inCachedMemory)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "%40s         va = 0x%p",
                          headingString,(char *)agNULL,
                          MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
    else if (MemoryDescriptor->memLoc == inDmaMemory)
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "%40s         pa = 0x%08X",
                          headingString,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32,
                          0,0,0,0,0,0,0
                        );
/*
        fiMemMapDumpBit32(
                           hpRoot,
                           "                                                 va = 0x%08X",
                           (os_bit32)MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr
                         );
*/
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "                                                 va = 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                         );

    }
    else /* MemoryDescriptor->memLoc == inCardRam */
    {
        fiLogDebugString(
                          hpRoot,
                          MemMapDumpCalculationLogConsoleLevel,
                          "%40s         pa = 0x%08X",
                          headingString,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          MemoryDescriptor->addr.CardRam.cardRamLower32,
                          0,0,0,0,0,0,0
                        );

        fiMemMapDumpBit32(
                           hpRoot,
                           "                                                off = 0x%08X",
                           MemoryDescriptor->addr.CardRam.cardRamOffset
                         );
    }

    fiMemMapDumpBit32(
                       hpRoot,
                       "                                         objectSize = 0x%08X",
                       MemoryDescriptor->objectSize
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                                        objectAlign = 0x%08X",
                       MemoryDescriptor->objectAlign
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                                           elements = 0x%08X",
                       MemoryDescriptor->elements
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                                        elementSize = 0x%08X",
                       MemoryDescriptor->elementSize
                     );
}

/*+
Function:  fiMemMapDumpCalculation()

Purpose:   Logs the various fields of the entire Calculation structure.

Algorithm: This function logs each of the fields of a Calculation
           structure.  The amount of data logged is quite large, but
           very complete.  The output can be used to understand the
           entire memory layout of the FC Layer in all types of memory.
-*/

void fiMemMapDumpCalculation(
                              agRoot_t              *hpRoot,
                              fiMemMapCalculation_t *Calculation,
                              agBOOLEAN                EnforceDefaults,
                              agBOOLEAN                to_return
                            )
{
    char *agTRUE_str            = "agTRUE";
    char *agFALSE_str           = "agFALSE";
    char *EnforceDefaults_str;
    char *to_return_str;
    char *sysIntsActive_str;

    if (EnforceDefaults == agTRUE)
    {
        EnforceDefaults_str = agTRUE_str;
    }
    else
    {
        EnforceDefaults_str = agFALSE_str;
    }
    
    if (to_return == agTRUE)
    {
        to_return_str = agTRUE_str;
    }
    else
    {
        to_return_str = agFALSE_str;
    }
    
    if (Calculation->Input.sysIntsActive == agTRUE)
    {
        sysIntsActive_str = agTRUE_str;
    }
    else
    {
        sysIntsActive_str = agFALSE_str;
    }
/*    
    fiMemMapDumpBit32(
                       hpRoot,
                       "fiMemMapCalculate( hpRoot          == 0x%08X,",
                       (os_bit32)hpRoot
                     );
*/
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "fiMemMapCalculate( hpRoot          == 0x%p,",
                      (char *)agNULL,(char *)agNULL,
                      hpRoot,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

/*
    fiMemMapDumpBit32(
                       hpRoot,
                       "                   Calculation     == 0x%08X,",
                       (os_bit32)Calculation
                     );
*/
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   Calculation     == 0x%p,",
                      (char *)agNULL,(char *)agNULL,
                      Calculation,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   EnforceDefaults == %12s) returns %s",
                      EnforceDefaults_str,
                      to_return_str,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiMemMapDumpBit32(
                       hpRoot,
                       "  Calculation.Input.initType         = 0x%08X",
                       (os_bit32)Calculation->Input.initType
                     );

    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   .sysIntsActive    = %s",
                      sysIntsActive_str,
                      (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );
/*
    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cachedMemoryPtr  = 0x%08X",
                       (os_bit32)Calculation->Input.cachedMemoryPtr
                     );
*/
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   .cachedMemoryPtr  = 0x%p",
                      (char *)agNULL,(char *)agNULL,
                      Calculation->Input.cachedMemoryPtr,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cachedMemoryLen  = 0x%08X",
                       Calculation->Input.cachedMemoryLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .dmaMemoryUpper32 = 0x%08X",
                       Calculation->Input.dmaMemoryUpper32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .dmaMemoryLower32 = 0x%08X",
                       Calculation->Input.dmaMemoryLower32
                     );
/*
    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .dmaMemoryPtr     = 0x%08X",
                       (os_bit32)Calculation->Input.dmaMemoryPtr
                     );
*/
    fiLogDebugString(
                      hpRoot,
                      MemMapDumpCalculationLogConsoleLevel,
                      "                   .dmaMemoryPtr     = 0x%p",
                      (char *)agNULL,(char *)agNULL,
                      Calculation->Input.dmaMemoryPtr,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .dmaMemoryLen     = 0x%08X",
                       Calculation->Input.dmaMemoryLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .nvMemoryLen      = 0x%08X",
                       Calculation->Input.nvMemoryLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRamUpper32   = 0x%08X",
                       Calculation->Input.cardRamUpper32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRamLower32   = 0x%08X",
                       Calculation->Input.cardRamLower32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRamLen       = 0x%08X",
                       Calculation->Input.cardRamLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRomUpper32   = 0x%08X",
                       Calculation->Input.cardRomUpper32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRomLower32   = 0x%08X",
                       Calculation->Input.cardRomLower32
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .cardRomLen       = 0x%08X",
                       Calculation->Input.cardRomLen
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                   .usecsPerTick     = 0x%08X",
                       Calculation->Input.usecsPerTick
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "  Calculation.Parameters.NumDevSlotsPerArea = 0x%08X",
                       Calculation->Parameters.NumDevSlotsPerArea
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumAreasPerDomain  = 0x%08X",
                       Calculation->Parameters.NumAreasPerDomain
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumDomains         = 0x%08X",
                       Calculation->Parameters.NumDomains
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumDevices         = 0x%08X",
                       Calculation->Parameters.NumDevices
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumIOs             = 0x%08X",
                       Calculation->Parameters.NumIOs
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SizeSGLs           = 0x%08X",
                       Calculation->Parameters.SizeSGLs
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumSGLs            = 0x%08X",
                       Calculation->Parameters.NumSGLs
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SizeCachedSGLs     = 0x%08X",
                       Calculation->Parameters.SizeCachedSGLs
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FCP_CMND_Size      = 0x%08X",
                       Calculation->Parameters.FCP_CMND_Size
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FCP_RESP_Size      = 0x%08X",
                       Calculation->Parameters.FCP_RESP_Size
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SF_CMND_Reserve    = 0x%08X",
                       Calculation->Parameters.SF_CMND_Reserve
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SF_CMND_Size       = 0x%08X",
                       Calculation->Parameters.SF_CMND_Size
                     );

#ifdef _DvrArch_1_30_
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .Pkt_CMND_Size       = 0x%08X",
                       Calculation->Parameters.Pkt_CMND_Size
                     );
#endif /* _DvrArch_1_30_ was not defined */

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumTgtCmnds        = 0x%08X",
                       Calculation->Parameters.NumTgtCmnds
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .TGT_CMND_Size      = 0x%08X",
                       Calculation->Parameters.TGT_CMND_Size
                     );

#ifdef _DvrArch_1_30_
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumPktThreads      = 0x%08X",
                       Calculation->Parameters.NumPktThreads
                     );
#endif /* _DvrArch_1_30_ was defined */

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumCommandQ        = 0x%08X",
                       Calculation->Parameters.NumCommandQ
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumCompletionQ     = 0x%08X",
                       Calculation->Parameters.NumCompletionQ
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .NumInboundBufferQ  = 0x%08X",
                       Calculation->Parameters.NumInboundBufferQ
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .InboundBufferSize  = 0x%08X",
                       Calculation->Parameters.InboundBufferSize
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CardRamSize        = 0x%08X",
                       Calculation->Parameters.CardRamSize
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CardRamAlignment   = 0x%08X",
                       Calculation->Parameters.CardRamAlignment
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .HostNvRamSize      = 0x%08X",
                       Calculation->Parameters.HostNvRamSize
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .ExchangeTableLoc   = %1d",
                       Calculation->Parameters.ExchangeTableLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SGLsLoc            = %1d",
                       Calculation->Parameters.SGLsLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FCP_CMND_Loc       = %1d",
                       Calculation->Parameters.FCP_CMND_Loc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FCP_RESP_Loc       = %1d",
                       Calculation->Parameters.FCP_RESP_Loc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .SF_CMND_Loc        = %1d",
                       Calculation->Parameters.SF_CMND_Loc
                     );

#ifdef _DvrArch_1_30_
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .Pkt_CMND_Loc        = %1d",
                       Calculation->Parameters.Pkt_CMND_Loc
                     );

#endif /* _DvrArch_1_30_ was not defined */

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CommandQLoc        = %1d",
                       Calculation->Parameters.CommandQLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CommandQConsLoc    = %1d",
                       Calculation->Parameters.CommandQConsLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CompletionQLoc     = %1d",
                       Calculation->Parameters.CompletionQLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .CompletionQProdLoc = %1d",
                       Calculation->Parameters.CompletionQProdLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .InboundBufferLoc   = %1d",
                       Calculation->Parameters.InboundBufferLoc
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .TimerTickInterval  = 0x%08X",
                       Calculation->Parameters.TimerTickInterval
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IO_Mode            = %1d",
                       Calculation->Parameters.IO_Mode
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IntDelayAmount     = 0x%08X",
                       Calculation->Parameters.IntDelayAmount
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IntDelayRateMethod = %1d",
                       Calculation->Parameters.IntDelayRateMethod
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IntDelayOnIORate   = 0x%08X",
                       Calculation->Parameters.IntDelayOnIORate
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IntDelayOffIORate  = 0x%08X",
                       Calculation->Parameters.IntDelayOffIORate
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .IOsBetweenISRs     = 0x%08X",
                       Calculation->Parameters.IOsBetweenISRs
                     );

#ifdef _Enforce_MaxCommittedMemory_
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .MaxCommittedMemory = 0x%08X",
                       Calculation->Parameters.MaxCommittedMemory
                     );
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .FlashUsageModel    = %1d",
                       Calculation->Parameters.FlashUsageModel
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .RelyOnLossSyncStatus        = %1d",
                       Calculation->Parameters.RelyOnLossSyncStatus
                     );
    fiMemMapDumpBit32(
                       hpRoot,
                       "                        .InitAsNport        = %1d",
                       Calculation->Parameters.InitAsNport
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "  Calculation.ToRequest.cachedMemoryNeeded          = 0x%08X",
                       Calculation->ToRequest.cachedMemoryNeeded
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .cachedMemoryPtrAlignAssumed = 0x%08X",
                       Calculation->ToRequest.cachedMemoryPtrAlignAssumed
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .dmaMemoryNeeded             = 0x%08X",
                       Calculation->ToRequest.dmaMemoryNeeded
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .dmaMemoryPtrAlignAssumed    = 0x%08X",
                       Calculation->ToRequest.dmaMemoryPtrAlignAssumed
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .dmaMemoryPhyAlignAssumed    = 0x%08X",
                       Calculation->ToRequest.dmaMemoryPhyAlignAssumed
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .cardRamNeeded               = 0x%08X",
                       Calculation->ToRequest.cardRamNeeded
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .cardRamPhyAlignAssumed      = 0x%08X",
                       Calculation->ToRequest.cardRamPhyAlignAssumed
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .nvMemoryNeeded              = 0x%08X",
                       Calculation->ToRequest.nvMemoryNeeded
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "                       .usecsPerTick                = 0x%08X",
                       Calculation->ToRequest.usecsPerTick
                     );

    fiMemMapDumpBit32(
                       hpRoot,
                       "  Calculation.MemoryLayout.On_Card_MASK             = 0x%08X",
                       Calculation->MemoryLayout.On_Card_MASK
                     );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SEST",
                                  &(Calculation->MemoryLayout.SEST)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .ESGL",
                                  &(Calculation->MemoryLayout.ESGL)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .FCP_CMND",
                                  &(Calculation->MemoryLayout.FCP_CMND)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .FCP_RESP",
                                  &(Calculation->MemoryLayout.FCP_RESP)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SF_CMND",
                                  &(Calculation->MemoryLayout.SF_CMND)
                                );

#ifdef _DvrArch_1_30_
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .Pkt_CMND",
                                  &(Calculation->MemoryLayout.Pkt_CMND)
                                );

#endif /* _DvrArch_1_30_ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .ERQ",
                                  &(Calculation->MemoryLayout.ERQ)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .ERQConsIndex",
                                  &(Calculation->MemoryLayout.ERQConsIndex)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IMQ",
                                  &(Calculation->MemoryLayout.IMQ)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IMQProdIndex",
                                  &(Calculation->MemoryLayout.IMQProdIndex)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SFQ",
                                  &(Calculation->MemoryLayout.SFQ)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .FlashSector",
                                  &(Calculation->MemoryLayout.FlashSector)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SlotWWN",
                                  &(Calculation->MemoryLayout.SlotWWN)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CThread",
                                  &(Calculation->MemoryLayout.CThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CTransitions",
                                  &(Calculation->MemoryLayout.CTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CActions",
                                  &(Calculation->MemoryLayout.CActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

#ifdef _DvrArch_1_30_
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IPThread",
                                  &(Calculation->MemoryLayout.IPThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IPTransitions",
                                  &(Calculation->MemoryLayout.IPTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .IPActions",
                                  &(Calculation->MemoryLayout.IPActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .PktThread",
                                  &(Calculation->MemoryLayout.PktThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .PktTransitions",
                                  &(Calculation->MemoryLayout.PktTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .PktActions",
                                  &(Calculation->MemoryLayout.PktActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */
#endif /* _DvrArch_1_30_ was defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .TgtThread",
                                  &(Calculation->MemoryLayout.TgtThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .TgtTransitions",
                                  &(Calculation->MemoryLayout.TgtTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .TgtActions",
                                  &(Calculation->MemoryLayout.TgtActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .DevThread",
                                  &(Calculation->MemoryLayout.DevThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .DevTransitions",
                                  &(Calculation->MemoryLayout.DevTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .DevActions",
                                  &(Calculation->MemoryLayout.DevActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CDBThread",
                                  &(Calculation->MemoryLayout.CDBThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CDBTransitions",
                                  &(Calculation->MemoryLayout.CDBTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .CDBActions",
                                  &(Calculation->MemoryLayout.CDBActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SFThread",
                                  &(Calculation->MemoryLayout.SFThread)
                                );

#ifndef __State_Force_Static_State_Tables__
    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SFTransitions",
                                  &(Calculation->MemoryLayout.SFTransitions)
                                );

    fiMemMapDumpMemoryDescriptor(
                                  hpRoot,
                                  "                          .SFActions",
                                  &(Calculation->MemoryLayout.SFActions)
                                );
#endif /* __State_Force_Static_State_Tables__ was not defined */
}

/*+
Function:  fiMemMapCalculate()

Purpose:   Calculates the memory layout for the entire FC Layer.

Algorithm: This function first calls fiMemMapGetParameters() to
           set the various parameters used in calculating the amount
           and type of memory for each object which is performed in
           fiMemMapSetupLayoutObjects().  Next, the objects are sorted
           by fiMemMapSortLayoutObjects().  Then, the objects are
           allocated by calling fiMemMapLayoutObjects().  Finally, the
           remaining fields in the ToRequest sub-structure are filled
           in by a call to fiMemMapFinishToRequest().  The calculated
           layout is validated by calling fiMemMapValidate.  The results
           of the calculations (i.e. the memory layout for the entire
           FC Layer) are logged by calling fiMemMapDumpCalculation().

Assumes:   Calculation->Input has been initialized to describe the
           memory allocated to the FC Layer (as the arguments to
           fcInitializeChannel() indicate).  In the initial call from
           fcInitializeDriver(), the following values should be used:

                Calculation.Input.initType         = 0;
                Calculation.Input.sysIntsActive    = agFALSE;
                Calculation.Input.cachedMemoryPtr  = agNULL;
                Calculation.Input.cachedMemoryLen  = 0xFFFFFFFF;
                Calculation.Input.dmaMemoryUpper32 = 0;
                Calculation.Input.dmaMemoryLower32 = 0;
                Calculation.Input.dmaMemoryPtr     = agNULL;
                Calculation.Input.dmaMemoryLen     = 0xFFFFFFFF;
                Calculation.Input.nvMemoryLen      = 0xFFFFFFFF;
                Calculation.Input.cardRamUpper32   = 0;
                Calculation.Input.cardRamLower32   = 0;
                Calculation.Input.cardRamLen       = 0xFFFFFFFF;
                Calculation.Input.cardRomUpper32   = 0;
                Calculation.Input.cardRomLower32   = 0;
                Calculation.Input.cardRomLen       = 0xFFFFFFFF;
                Calculation.Input.usecsPerTick     = 0;

Returns:   agTRUE     If the resulting memory layout will fit
                    in the memory specified in Calculation->Input

           agFALSE    If the resulting memory layout will not fit
                    in the memory specified in Calculation->Input
-*/

agBOOLEAN fiMemMapCalculate(
                           agRoot_t              *hpRoot,
                           fiMemMapCalculation_t *Calculation,
                           agBOOLEAN                EnforceDefaults
                         )
{
    agBOOLEAN to_return;

    fiMemMapGetParameters(
                           hpRoot,
                           Calculation,
                           EnforceDefaults
                         );

    fiMemMapSetupLayoutObjects(
                                hpRoot,
                                Calculation
                              );

    fiMemMapSortLayoutObjects(
                               hpRoot,
                               &(Calculation->MemoryLayout)
                             );

    fiMemMapLayoutObjects(
                           hpRoot,
                           Calculation
                         );

    fiMemMapFinishToRequest(
                             hpRoot,
                             Calculation
                           );

    to_return = fiMemMapValidate(
                                  hpRoot,
                                  Calculation
                                );

    fiMemMapDumpCalculation(
                             hpRoot,
                             Calculation,
                             EnforceDefaults,
                             to_return
                           );

    return to_return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\memmap.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/MemMap.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/13/00 4:07p  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/MemMap.C

--*/

#ifndef __MemMap_H__
#define __MemMap_H__

/*+
The following are used to scale the sizes of various data structures
-*/

#define MemMap_NumDevSlotsPerArea_PARAMETER  "NumDevSlotsPerArea"
#define MemMap_NumDevSlotsPerArea_MIN        1
#define MemMap_NumDevSlotsPerArea_MAX        128
#define MemMap_NumDevSlotsPerArea_ADJUSTABLE agTRUE
#define MemMap_NumDevSlotsPerArea_POWER_OF_2 agFALSE
#define MemMap_NumDevSlotsPerArea_DEFAULT    126

#define MemMap_NumAreasPerDomain_PARAMETER   "NumAreasPerDomain"
#define MemMap_NumAreasPerDomain_MIN         1
#define MemMap_NumAreasPerDomain_MAX         256
#define MemMap_NumAreasPerDomain_ADJUSTABLE  agTRUE
#define MemMap_NumAreasPerDomain_POWER_OF_2  agFALSE
#define MemMap_NumAreasPerDomain_DEFAULT     1

#define MemMap_NumDomains_PARAMETER          "NumDomains"
#define MemMap_NumDomains_MIN                1
#define MemMap_NumDomains_MAX                256
#define MemMap_NumDomains_ADJUSTABLE         agTRUE
#define MemMap_NumDomains_POWER_OF_2         agFALSE
#define MemMap_NumDomains_DEFAULT            1

#define MemMap_NumDevices_PARAMETER          "NumDevices"
#define MemMap_NumDevices_MIN                (MemMap_NumDevSlotsPerArea_MIN * MemMap_NumAreasPerDomain_MIN * MemMap_NumDomains_MIN)
#define MemMap_NumDevices_MAX                (MemMap_NumDevSlotsPerArea_MAX * MemMap_NumAreasPerDomain_MAX * MemMap_NumDomains_MAX)
#define MemMap_NumDevices_ADJUSTABLE         agTRUE
#define MemMap_NumDevices_POWER_OF_2         agFALSE
#define MemMap_NumDevices_DEFAULT            128 

#define MemMap_NumLOOPDeviceMAP_PARAMETER    "LOOPDeviceMAP"
#define MemMap_NumLOOPDeviceMAP_MIN          sizeof(FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t)
#define MemMap_NumLOOPDeviceMAP_MAX          sizeof(FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t)
#define MemMap_NumLOOPDeviceMAP_ADJUSTABLE   agFALSE
#define MemMap_NumLOOPDeviceMAP_POWER_OF_2   agFALSE
#define MemMap_NumLOOPDeviceMAP_DEFAULT      sizeof(FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t)

#define MemMap_NumFabricDeviceMAP_PARAMETER  "FabricDeviceMAP"
#define MemMap_NumFabricDeviceMAP_MIN        MemMap_NumDevices_MIN
#define MemMap_NumFabricDeviceMAP_MAX        MemMap_NumDevices_MAX
#define MemMap_NumFabricDeviceMAP_ADJUSTABLE agFALSE
#define MemMap_NumFabricDeviceMAP_POWER_OF_2 agFALSE
#define MemMap_NumFabricDeviceMAP_DEFAULT    MemMap_NumDevices_DEFAULT

#define MemMap_NumIOs_PARAMETER              "NumIOs"
#define MemMap_NumIOs_MIN                    2
#define MemMap_NumIOs_MAX                    0x7FFD
#define MemMap_NumIOs_ADJUSTABLE             agTRUE
#define MemMap_NumIOs_POWER_OF_2             agFALSE
#define MemMap_NumIOs_DEFAULT                512

#define MemMap_SizeSGLs_PARAMETER            "SizeSGLs"
#define MemMap_SizeSGLs_MIN                  4
#define MemMap_SizeSGLs_MAX                  256
#define MemMap_SizeSGLs_ADJUSTABLE           agTRUE
#define MemMap_SizeSGLs_POWER_OF_2           agTRUE
#define MemMap_SizeSGLs_DEFAULT              32

#define MemMap_NumSGLs_PARAMETER             "NumSGLs"
#define MemMap_NumSGLs_MIN                   0
#define MemMap_NumSGLs_MAX                   MemMap_NumIOs_MAX
#define MemMap_NumSGLs_ADJUSTABLE            agTRUE
#define MemMap_NumSGLs_POWER_OF_2            agFALSE
#define MemMap_NumSGLs_DEFAULT               (MemMap_NumIOs_DEFAULT/4)

#define MemMap_SizeCachedSGLs_PARAMETER      "SizeCachedSGLs"
#define MemMap_SizeCachedSGLs_MIN            3
#define MemMap_SizeCachedSGLs_MAX            256
#define MemMap_SizeCachedSGLs_ADJUSTABLE     agTRUE
#define MemMap_SizeCachedSGLs_POWER_OF_2     agFALSE
#define MemMap_SizeCachedSGLs_DEFAULT        17

#define MemMap_FCP_CMND_Size_PARAMETER       "FCP_CMND_Size"
#define MemMap_FCP_CMND_Size_MIN             64
#define MemMap_FCP_CMND_Size_MAX             64
#define MemMap_FCP_CMND_Size_ADJUSTABLE      agFALSE
#define MemMap_FCP_CMND_Size_POWER_OF_2      agTRUE
#define MemMap_FCP_CMND_Size_DEFAULT         64

#define MemMap_FCP_RESP_Size_PARAMETER       "FCP_RESP_Size"
#define MemMap_FCP_RESP_Size_MIN             128
#define MemMap_FCP_RESP_Size_MAX             256
#define MemMap_FCP_RESP_Size_ADJUSTABLE      agTRUE
#define MemMap_FCP_RESP_Size_POWER_OF_2      agTRUE
#define MemMap_FCP_RESP_Size_DEFAULT         128

#define MemMap_SF_CMND_Reserve_PARAMETER     "SF_CMND_Reserve"
#define MemMap_SF_CMND_Reserve_MIN           2
#define MemMap_SF_CMND_Reserve_MAX           0x7FFD
#define MemMap_SF_CMND_Reserve_ADJUSTABLE    agTRUE
#define MemMap_SF_CMND_Reserve_POWER_OF_2    agFALSE
#define MemMap_SF_CMND_Reserve_DEFAULT       64

#define MemMap_SF_CMND_Size_PARAMETER        "SF_CMND_Size"
#define MemMap_SF_CMND_Size_MIN              256
#define MemMap_SF_CMND_Size_MAX              1024
#define MemMap_SF_CMND_Size_ADJUSTABLE       agTRUE
#define MemMap_SF_CMND_Size_POWER_OF_2       agTRUE
#define MemMap_SF_CMND_Size_DEFAULT          256

#define MemMap_NumTgtCmnds_PARAMETER         "NumTgtCmnds"
#define MemMap_NumTgtCmnds_MIN               1
#define MemMap_NumTgtCmnds_MAX               1024
#define MemMap_NumTgtCmnds_ADJUSTABLE        agTRUE
#define MemMap_NumTgtCmnds_POWER_OF_2        agFALSE
#define MemMap_NumTgtCmnds_DEFAULT           128

#define MemMap_TGT_CMND_Size_PARAMETER       "TGT_CMND_Size"
#define MemMap_TGT_CMND_Size_MIN             1056
#define MemMap_TGT_CMND_Size_MAX             1056
#define MemMap_TGT_CMND_Size_ADJUSTABLE      agFALSE
#define MemMap_TGT_CMND_Size_POWER_OF_2      agFALSE
#define MemMap_TGT_CMND_Size_DEFAULT         1056

#ifdef _DvrArch_1_30_
#define MemMap_NumPktThreads_PARAMETER       "NumPktThreads"
#define MemMap_NumPktThreads_MIN             1
#define MemMap_NumPktThreads_MAX             1024
#define MemMap_NumPktThreads_ADJUSTABLE      agTRUE
#define MemMap_NumPktThreads_POWER_OF_2      agFALSE
#define MemMap_NumPktThreads_DEFAULT         32

#define MemMap_Pkt_CMND_Size_PARAMETER       "Pkt_CMND_Size"
#define MemMap_Pkt_CMND_Size_MIN             256
#define MemMap_Pkt_CMND_Size_MAX             1024
#define MemMap_Pkt_CMND_Size_ADJUSTABLE      agTRUE
#define MemMap_Pkt_CMND_Size_POWER_OF_2      agTRUE
#define MemMap_Pkt_CMND_Size_DEFAULT         256

#endif /* _DvrArch_1_30_ was defined */

#define MemMap_NumCommandQ_PARAMETER         "NumCommandQ"     /* Exchange Request Queue ERQ */
#define MemMap_NumCommandQ_MIN               2
#define MemMap_NumCommandQ_MAX               4096
#define MemMap_NumCommandQ_ADJUSTABLE        agTRUE
#define MemMap_NumCommandQ_POWER_OF_2        agTRUE
#define MemMap_NumCommandQ_DEFAULT           MemMap_NumIOs_DEFAULT

#define MemMap_NumCompletionQ_PARAMETER      "NumCompletionQ" /* Inbound Message Queue IMQ */
#define MemMap_NumCompletionQ_MIN            2
#define MemMap_NumCompletionQ_MAX            4096
#define MemMap_NumCompletionQ_ADJUSTABLE     agTRUE
#define MemMap_NumCompletionQ_POWER_OF_2     agTRUE
#define MemMap_NumCompletionQ_DEFAULT        MemMap_NumIOs_DEFAULT

#define MemMap_NumInboundBufferQ_PARAMETER   "NumInboundBufferQ"  /* Single Frame Queue SFQ */
#define MemMap_NumInboundBufferQ_MIN         32
#define MemMap_NumInboundBufferQ_MAX         4096
#define MemMap_NumInboundBufferQ_ADJUSTABLE  agTRUE
#define MemMap_NumInboundBufferQ_POWER_OF_2  agTRUE
#define MemMap_NumInboundBufferQ_DEFAULT     512

#define MemMap_InboundBufferSize_PARAMETER   "InboundBufferSize"
#define MemMap_InboundBufferSize_MIN         64
#define MemMap_InboundBufferSize_MAX         64
#define MemMap_InboundBufferSize_ADJUSTABLE  agFALSE
#define MemMap_InboundBufferSize_POWER_OF_2  agTRUE
#define MemMap_InboundBufferSize_DEFAULT     64

#define MemMap_CardRamSize_PARAMETER         "CardRamSize"
#define MemMap_CardRamSize_MIN               0
#define MemMap_CardRamSize_MAX               (256*1024)
#define MemMap_CardRamSize_ADJUSTABLE        agFALSE
#define MemMap_CardRamSize_POWER_OF_2        agFALSE
#define MemMap_CardRamSize_DEFAULT           (256*1024)

#define MemMap_CardRamAlignment_PARAMETER    "CardRamAlignment"
#define MemMap_CardRamAlignment_MIN          0
#define MemMap_CardRamAlignment_MAX          (256*1024)
#define MemMap_CardRamAlignment_ADJUSTABLE   agFALSE
#define MemMap_CardRamAlignment_POWER_OF_2   agFALSE
#define MemMap_CardRamAlignment_DEFAULT      (256*1024)

#define MemMap_HostNvRamSize_PARAMETER       "HostNvRamSize"
#define MemMap_HostNvRamSize_MIN             0
#define MemMap_HostNvRamSize_MAX             (16*1024)
#define MemMap_HostNvRamSize_ADJUSTABLE      agTRUE
#define MemMap_HostNvRamSize_POWER_OF_2      agFALSE
#define MemMap_HostNvRamSize_DEFAULT         0

/*+
The following are used to locate the various data structures in on-card or host ram
-*/

#define MemMap_Alloc_On_Card                 1
#define MemMap_Alloc_From_Host               0

#if defined(__MemMap_Force_On_Card__)

#define MemMap_DEFAULT_Loc_ADJUSTABLE        agFALSE
#define MemMap_DEFAULT_Loc_DEFAULT           MemMap_Alloc_On_Card

#elif defined (__MemMap_Force_Off_Card__)

#define MemMap_DEFAULT_Loc_ADJUSTABLE        agFALSE
#define MemMap_DEFAULT_Loc_DEFAULT           MemMap_Alloc_From_Host

#else

#define MemMap_DEFAULT_Loc_ADJUSTABLE        agTRUE
#define MemMap_DEFAULT_Loc_DEFAULT           MemMap_Alloc_From_Host

#endif

#define MemMap_ExchangeTableLoc_PARAMETER    "ExchangeTableLoc"
#define MemMap_ExchangeTableLoc_ADJUSTABLE   MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_ExchangeTableLoc_DEFAULT      MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_ExchangeTableLoc_MASK         (MemMap_Alloc_On_Card<<0)

#define MemMap_SGLsLoc_PARAMETER             "SGLsLoc"
#define MemMap_SGLsLoc_ADJUSTABLE            MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_SGLsLoc_DEFAULT               MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_SGLsLoc_MASK                  (MemMap_Alloc_On_Card<<1)

#define MemMap_FCP_CMND_Loc_PARAMETER        "FCP_CMND_Loc"
#define MemMap_FCP_CMND_Loc_ADJUSTABLE       MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_FCP_CMND_Loc_DEFAULT          MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_FCP_CMND_Loc_MASK             (MemMap_Alloc_On_Card<<2)

#define MemMap_FCP_RESP_Loc_PARAMETER        "FCP_RESP_Loc"
#define MemMap_FCP_RESP_Loc_ADJUSTABLE       MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_FCP_RESP_Loc_DEFAULT          MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_FCP_RESP_Loc_MASK             (MemMap_Alloc_On_Card<<3)

#define MemMap_SF_CMND_Loc_PARAMETER         "SF_CMND_Loc"
#define MemMap_SF_CMND_Loc_ADJUSTABLE        MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_SF_CMND_Loc_DEFAULT           MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_SF_CMND_Loc_MASK              (MemMap_Alloc_On_Card<<4)

#ifdef _DvrArch_1_30_
#define MemMap_Pkt_CMND_Loc_PARAMETER        "Pkt_CMND_Loc"
#define MemMap_Pkt_CMND_Loc_ADJUSTABLE       MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_Pkt_CMND_Loc_DEFAULT          MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_Pkt_CMND_Loc_MASK             (MemMap_Alloc_On_Card<<4)
#endif /* _DvrArch_1_30_ was defined */

#define MemMap_CommandQLoc_PARAMETER         "CommandQLoc"
#define MemMap_CommandQLoc_ADJUSTABLE        MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_CommandQLoc_DEFAULT           MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_CommandQLoc_MASK              (MemMap_Alloc_On_Card<<5)

#define MemMap_CommandQConsLoc_PARAMETER     "CommandQConsLoc"
#define MemMap_CommandQConsLoc_ADJUSTABLE    MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_CommandQConsLoc_DEFAULT       MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_CommandQConsLoc_MASK          (MemMap_Alloc_On_Card<<6)

#define MemMap_CompletionQLoc_PARAMETER      "CompletionQLoc"
#define MemMap_CompletionQLoc_ADJUSTABLE     MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_CompletionQLoc_DEFAULT        MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_CompletionQLoc_MASK           (MemMap_Alloc_On_Card<<7)

#define MemMap_CompletionQProdLoc_PARAMETER  "CompletionQProdLoc"
#define MemMap_CompletionQProdLoc_ADJUSTABLE MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_CompletionQProdLoc_DEFAULT    MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_CompletionQProdLoc_MASK       (MemMap_Alloc_On_Card<<8)

#define MemMap_InboundBufferLoc_PARAMETER    "InboundBufferLoc"
#define MemMap_InboundBufferLoc_ADJUSTABLE   MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_InboundBufferLoc_DEFAULT      MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_InboundBufferLoc_MASK         (MemMap_Alloc_On_Card<<9)

#define MemMap_LOOPMapLoc_PARAMETER         "LOOPMapLoc"
#define MemMap_LOOPMapLoc_ADJUSTABLE        MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_LOOPMapLoc_DEFAULT           MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_LOOPMapLoc_MASK              (MemMap_Alloc_On_Card<<10)

#define MemMap_FabricMapLoc_PARAMETER       "FabricMapLoc"
#define MemMap_FabricMapLoc_ADJUSTABLE      MemMap_DEFAULT_Loc_ADJUSTABLE
#define MemMap_FabricMapLoc_DEFAULT         MemMap_DEFAULT_Loc_DEFAULT
#define MemMap_FabricMapLoc_MASK            (MemMap_Alloc_On_Card<<11)

/*+
The following are used for other FC Layer settings
-*/

#define MemMap_TimerTickInterval_PARAMETER   "TimerTickInterval"
#define MemMap_TimerTickInterval_MIN         0
#define MemMap_TimerTickInterval_MAX         (100*1000*1000)
#define MemMap_TimerTickInterval_ADJUSTABLE  agTRUE
#define MemMap_TimerTickInterval_POWER_OF_2  agFALSE
#define MemMap_TimerTickInterval_DEFAULT     1000000

#define MemMap_Interrupt_IO_Mode             0
#define MemMap_Polling_IO_Mode               1

#define MemMap_IO_Mode_PARAMETER             "IO_Mode"
#define MemMap_IO_Mode_MIN                   MemMap_Interrupt_IO_Mode
#define MemMap_IO_Mode_MAX                   MemMap_Polling_IO_Mode
#define MemMap_IO_Mode_ADJUSTABLE            agTRUE
#define MemMap_IO_Mode_POWER_OF_2            agFALSE
#define MemMap_IO_Mode_DEFAULT               MemMap_Interrupt_IO_Mode

#define MemMap_GPIO_BITS_MASK                (ChipIOUp_TachLite_Control_GP1 | ChipIOUp_TachLite_Control_GP0)

#define MemMap_GPIO_BITS_PAL_Delay_0_00_ms   0x00
#define MemMap_GPIO_BITS_PAL_Delay_0_75_ms   ChipIOUp_TachLite_Control_GP0
#define MemMap_GPIO_BITS_PAL_Delay_1_00_ms   ChipIOUp_TachLite_Control_GP1
#define MemMap_GPIO_BITS_PAL_Delay_1_50_ms   (ChipIOUp_TachLite_Control_GP1 | ChipIOUp_TachLite_Control_GP0)

#define MemMap_IntDelayAmount_PARAMETER      "IntDelayAmount"
#define MemMap_IntDelayAmount_MIN            MemMap_GPIO_BITS_PAL_Delay_0_00_ms
#define MemMap_IntDelayAmount_MAX            MemMap_GPIO_BITS_PAL_Delay_1_50_ms
#define MemMap_IntDelayAmount_ADJUSTABLE     agTRUE
#define MemMap_IntDelayAmount_POWER_OF_2     agFALSE
#define MemMap_IntDelayAmount_DEFAULT        MemMap_GPIO_BITS_PAL_Delay_1_00_ms

#define MemMap_RateMethod_IOsStarted         0
#define MemMap_RateMethod_IOsCompleted       1
#define MemMap_RateMethod_IOsIntCompleted    2
#define MemMap_RateMethod_IOsPollCompleted   3
#define MemMap_RateMethod_IOsActive          4

#define MemMap_IntDelayRateMethod_PARAMETER  "IntDelayRateMethod"
#define MemMap_IntDelayRateMethod_MIN        MemMap_RateMethod_IOsStarted
#define MemMap_IntDelayRateMethod_MAX        MemMap_RateMethod_IOsActive
#define MemMap_IntDelayRateMethod_ADJUSTABLE agTRUE
#define MemMap_IntDelayRateMethod_POWER_OF_2 agFALSE
#define MemMap_IntDelayRateMethod_DEFAULT    MemMap_RateMethod_IOsPollCompleted

#define MemMap_IntDelayOnIORate_PARAMETER    "IntDelayOnIORate"
#define MemMap_IntDelayOnIORate_MIN          0x00000000
#define MemMap_IntDelayOnIORate_MAX          0xFFFFFFFF
#define MemMap_IntDelayOnIORate_ADJUSTABLE   agTRUE
#define MemMap_IntDelayOnIORate_POWER_OF_2   agFALSE
#define MemMap_IntDelayOnIORate_DEFAULT      0x00000100

#define MemMap_IntDelayOffIORate_PARAMETER   "IntDelayOffIORate"
#define MemMap_IntDelayOffIORate_MIN         0x00000000
#define MemMap_IntDelayOffIORate_MAX         0xFFFFFFFF
#define MemMap_IntDelayOffIORate_ADJUSTABLE  agTRUE
#define MemMap_IntDelayOffIORate_POWER_OF_2  agFALSE
#define MemMap_IntDelayOffIORate_DEFAULT     0x00000010

#define MemMap_IOsBetweenISRs_PARAMETER      "IOsBetweenISRs"
#define MemMap_IOsBetweenISRs_MIN            0x00000000
#define MemMap_IOsBetweenISRs_MAX            0xFFFFFFFF
#define MemMap_IOsBetweenISRs_ADJUSTABLE     agTRUE
#define MemMap_IOsBetweenISRs_POWER_OF_2     agFALSE
#define MemMap_IOsBetweenISRs_DEFAULT        0x00000100

#define MemMap_AssumedSGLChunkSize           0x1000

#ifdef _Enforce_MaxCommittedMemory_
#define MemMap_MaxCommittedMemory_PARAMETER  "MaxCommittedMemory"
#define MemMap_MaxCommittedMemory_MIN        0
#define MemMap_MaxCommittedMemory_MAX        0xFFFFFFFF
#define MemMap_MaxCommittedMemory_ADJUSTABLE agTRUE
#define MemMap_MaxCommittedMemory_POWER_OF_2 agFALSE
#define MemMap_MaxCommittedMemory_DEFAULT    (MemMap_SizeSGLs_DEFAULT * MemMap_NumSGLs_DEFAULT * MemMap_AssumedSGLChunkSize)
#endif /* _Enforce_MaxCommittedMemory_ was defined */

#define MemMap_FlashUsageModel_DoNotUse      0
#define MemMap_FlashUsageModel_UseIfGood     1
#define MemMap_FlashUsageModel_InitIfBad     2

#define MemMap_FlashUsageModel_PARAMETER     "FlashUsageModel"
#define MemMap_FlashUsageModel_MIN           MemMap_FlashUsageModel_DoNotUse
#define MemMap_FlashUsageModel_MAX           MemMap_FlashUsageModel_InitIfBad
#define MemMap_FlashUsageModel_ADJUSTABLE    agTRUE
#define MemMap_FlashUsageModel_POWER_OF_2    agFALSE
#define MemMap_FlashUsageModel_DEFAULT       MemMap_FlashUsageModel_UseIfGood

#define MemMap_InitAsNport_PARAMETER         "InitAsNport"
#define MemMap_InitAsNport_MIN               0
#define MemMap_InitAsNport_MAX               1
#define MemMap_InitAsNport_ADJUSTABLE        agTRUE
#define MemMap_InitAsNport_POWER_OF_2        agFALSE
#define MemMap_InitAsNport_DEFAULT           0

#define MemMap_RelyOnLossSyncStatus_PARAMETER         "RelyOnLossSyncStatus"
#define MemMap_RelyOnLossSyncStatus_MIN               0
#define MemMap_RelyOnLossSyncStatus_MAX               1
#define MemMap_RelyOnLossSyncStatus_ADJUSTABLE        agTRUE
#define MemMap_RelyOnLossSyncStatus_POWER_OF_2        agFALSE
#define MemMap_RelyOnLossSyncStatus_DEFAULT           agTRUE

#define MemMap_WolfPack_PARAMETER         "WolfPack"
#define MemMap_WolfPack_MIN               0
#define MemMap_WolfPack_MAX               1
#define MemMap_WolfPack_ADJUSTABLE        agTRUE
#define MemMap_WolfPack_POWER_OF_2        agFALSE
#define MemMap_WolfPack_DEFAULT           agFALSE

#define MemMap_HeartBeat_PARAMETER         "HeartBeat"
#define MemMap_HeartBeat_MIN               0
#define MemMap_HeartBeat_MAX               1
#define MemMap_HeartBeat_ADJUSTABLE        agTRUE
#define MemMap_HeartBeat_POWER_OF_2        agFALSE
#define MemMap_HeartBeat_DEFAULT           agFALSE

#define MemMap_ED_TOV_PARAMETER         "ED_TOV"
#define MemMap_ED_TOV_MIN               1
#define MemMap_ED_TOV_MAX               0xFFFF
#define MemMap_ED_TOV_ADJUSTABLE        agTRUE
#define MemMap_ED_TOV_POWER_OF_2        agFALSE
#define MemMap_ED_TOV_DEFAULT           Chip_Frame_Manager_TimeOut_Values_1_ED_TOV_Default

#define MemMap_RT_TOV_PARAMETER         "RT_TOV"
#define MemMap_RT_TOV_MIN               1
#define MemMap_RT_TOV_MAX               0x1FF
#define MemMap_RT_TOV_ADJUSTABLE        agTRUE
#define MemMap_RT_TOV_POWER_OF_2        agFALSE
#define MemMap_RT_TOV_DEFAULT           Chip_Frame_Manager_TimeOut_Values_1_RT_TOV_Default_After_Reset

#define MemMap_LP_TOV_PARAMETER         "LP_TOV"
#define MemMap_LP_TOV_MIN               1
#define MemMap_LP_TOV_MAX               0xFFFF
#define MemMap_LP_TOV_ADJUSTABLE        agTRUE
#define MemMap_LP_TOV_POWER_OF_2        agFALSE
#define MemMap_LP_TOV_DEFAULT           Chip_Frame_Manager_TimeOut_Values_2_LP_TOV_Default

#define MemMap_AL_Time_PARAMETER         "AL_Time"
#define MemMap_AL_Time_MIN               1
#define MemMap_AL_Time_MAX               0x1FF
#define MemMap_AL_Time_ADJUSTABLE        agTRUE
#define MemMap_AL_Time_POWER_OF_2        agFALSE
#define MemMap_AL_Time_DEFAULT           Chip_Frame_Manager_TimeOut_Values_2_AL_Time_Default_After_Reset

#define MemMap_R_A_TOV_PARAMETER         "R_A_TOV"
#define MemMap_R_A_TOV_MIN               1
#define MemMap_R_A_TOV_MAX               0xFFFFFFFF
#define MemMap_R_A_TOV_ADJUSTABLE        agTRUE
#define MemMap_R_A_TOV_POWER_OF_2        agFALSE
#define MemMap_R_A_TOV_DEFAULT           7000000 /* was 10,000,000*/


/*+
Data stuctures used to communicate calculations
-*/

typedef struct fiMemMapInput_s
               fiMemMapInput_t;

struct fiMemMapInput_s
       {
         os_bit32    initType;
         agBOOLEAN  sysIntsActive;
         void    *cachedMemoryPtr;
         os_bit32    cachedMemoryLen;
         os_bit32    dmaMemoryUpper32;
         os_bit32    dmaMemoryLower32;
         void    *dmaMemoryPtr;
         os_bit32    dmaMemoryLen;
         os_bit32    nvMemoryLen;
         os_bit32    cardRamUpper32;
         os_bit32    cardRamLower32;
         os_bit32    cardRamLen;
         os_bit32    cardRomUpper32;
         os_bit32    cardRomLower32;
         os_bit32    cardRomLen;
         os_bit32    usecsPerTick;
       };

typedef struct fiMemMapParameters_s
               fiMemMapParameters_t;

struct fiMemMapParameters_s
       {
         os_bit32 NumDevSlotsPerArea;
         os_bit32 NumAreasPerDomain;
         os_bit32 NumDomains;
         os_bit32 NumDevices;
         os_bit32 NumIOs;
         os_bit32 SizeSGLs;
         os_bit32 NumSGLs;
         os_bit32 SizeCachedSGLs;
         os_bit32 FCP_CMND_Size;
         os_bit32 FCP_RESP_Size;
         os_bit32 SF_CMND_Reserve;
         os_bit32 SF_CMND_Size;
         os_bit32 NumTgtCmnds;
         os_bit32 TGT_CMND_Size;
#ifdef _DvrArch_1_30_
         os_bit32 Pkt_CMND_Size;
         os_bit32 NumPktThreads;
#endif /* _DvrArch_1_30_ was defined */
         os_bit32 NumCommandQ;
         os_bit32 NumCompletionQ;
         os_bit32 NumInboundBufferQ;
         os_bit32 InboundBufferSize;
         os_bit32 CardRamSize;
         os_bit32 CardRamAlignment;
         os_bit32 HostNvRamSize;
         os_bit32 ExchangeTableLoc;
         os_bit32 SGLsLoc;
         os_bit32 FCP_CMND_Loc;
         os_bit32 FCP_RESP_Loc;
         os_bit32 SF_CMND_Loc;
#ifdef _DvrArch_1_30_
         os_bit32 Pkt_CMND_Loc;
#endif /* _DvrArch_1_30_ was defined */
         os_bit32 CommandQLoc;
         os_bit32 CommandQConsLoc;
         os_bit32 CompletionQLoc;
         os_bit32 CompletionQProdLoc;
         os_bit32 InboundBufferLoc;
         os_bit32 TimerTickInterval;
         os_bit32 IO_Mode;
         os_bit32 IntDelayAmount;
         os_bit32 IntDelayRateMethod;
         os_bit32 IntDelayOnIORate;
         os_bit32 IntDelayOffIORate;
         os_bit32 IOsBetweenISRs;
#ifdef _Enforce_MaxCommittedMemory_
         os_bit32 MaxCommittedMemory;
#endif /* _Enforce_MaxCommittedMemory_ was defined */
         os_bit32 FlashUsageModel;
         os_bit32 InitAsNport;
         os_bit32 RelyOnLossSyncStatus;

         os_bit32 WolfPack;
         os_bit32 HeartBeat;
         os_bit32 ED_TOV;
         os_bit32 RT_TOV;
         os_bit32 LP_TOV;
         os_bit32 AL_Time;
         os_bit32 R_A_TOV;
       };

typedef struct fiMemMapToRequest_s
               fiMemMapToRequest_t;

struct fiMemMapToRequest_s
       {
         os_bit32 cachedMemoryNeeded;
         os_bit32 cachedMemoryPtrAlignAssumed;
         os_bit32 dmaMemoryNeeded;
         os_bit32 dmaMemoryPtrAlignAssumed;
         os_bit32 dmaMemoryPhyAlignAssumed;
         os_bit32 cardRamNeeded;
         os_bit32 cardRamPhyAlignAssumed;
         os_bit32 nvMemoryNeeded;
         os_bit32 usecsPerTick;
       };

enum fiMemMapMemoryLocation_e
     {
       inCachedMemory,
       inDmaMemory,
       inCardRam
     };

typedef enum fiMemMapMemoryLocation_e
             fiMemMapMemoryLocation_t;

typedef struct fiMemMapMemoryCachedMemoryAddress_s
               fiMemMapMemoryCachedMemoryAddress_t;

struct fiMemMapMemoryCachedMemoryAddress_s
       {
         void *cachedMemoryPtr;
       };

typedef struct fiMemMapMemoryDmaMemoryAddress_s
               fiMemMapMemoryDmaMemoryAddress_t;

struct fiMemMapMemoryDmaMemoryAddress_s
       {
         os_bit32  dmaMemoryUpper32;
         os_bit32  dmaMemoryLower32;
         void  *dmaMemoryPtr;
       };

typedef struct fiMemMapMemoryCardRamAddress_s
               fiMemMapMemoryCardRamAddress_t;

struct fiMemMapMemoryCardRamAddress_s
       {
         os_bit32 cardRamUpper32;
         os_bit32 cardRamLower32;
         os_bit32 cardRamOffset;
       };

typedef union fiMemMapMemoryAddress_s
              fiMemMapMemoryAddress_t;

union fiMemMapMemoryAddress_s
      {
        fiMemMapMemoryCachedMemoryAddress_t CachedMemory;
        fiMemMapMemoryDmaMemoryAddress_t    DmaMemory;
        fiMemMapMemoryCardRamAddress_t      CardRam;
      };

typedef struct fiMemMapMemoryDescriptor_s
               fiMemMapMemoryDescriptor_t;

struct fiMemMapMemoryDescriptor_s
       {
         fiMemMapMemoryDescriptor_t *flink;       /* Must be first field !!! */
         os_bit32                       objectSize;
         os_bit32                       objectAlign;
         os_bit32                       elements;
         os_bit32                       elementSize;
         fiMemMapMemoryLocation_t    memLoc;
         fiMemMapMemoryAddress_t     addr;
       };

typedef struct fiMemMapMemoryLayout_s
               fiMemMapMemoryLayout_t;

struct fiMemMapMemoryLayout_s
       {
         os_bit32                       On_Card_MASK;
         fiMemMapMemoryDescriptor_t *unsorted;
         fiMemMapMemoryDescriptor_t *sortedCachedMemory;
         fiMemMapMemoryDescriptor_t *sortedDmaMemory;
         fiMemMapMemoryDescriptor_t *sortedCardRam;
         fiMemMapMemoryDescriptor_t  SEST;
         fiMemMapMemoryDescriptor_t  ESGL;
         fiMemMapMemoryDescriptor_t  FCP_CMND;
         fiMemMapMemoryDescriptor_t  FCP_RESP;
         fiMemMapMemoryDescriptor_t  SF_CMND;
#ifdef _DvrArch_1_30_
         fiMemMapMemoryDescriptor_t  Pkt_CMND;
#endif /* _DvrArch_1_30_ was defined */
         fiMemMapMemoryDescriptor_t  ERQ;
         fiMemMapMemoryDescriptor_t  ERQConsIndex;
         fiMemMapMemoryDescriptor_t  IMQ;
         fiMemMapMemoryDescriptor_t  IMQProdIndex;
         fiMemMapMemoryDescriptor_t  SFQ;
         fiMemMapMemoryDescriptor_t  FlashSector;
         fiMemMapMemoryDescriptor_t  SlotWWN;
         fiMemMapMemoryDescriptor_t  FabricDeviceMAP;
         fiMemMapMemoryDescriptor_t  LOOPDeviceMAP;
         fiMemMapMemoryDescriptor_t  CThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  CTransitions;
         fiMemMapMemoryDescriptor_t  CActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
#ifdef _DvrArch_1_30_
         fiMemMapMemoryDescriptor_t  IPThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  IPTransitions;
         fiMemMapMemoryDescriptor_t  IPActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
         fiMemMapMemoryDescriptor_t  PktThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  PktTransitions;
         fiMemMapMemoryDescriptor_t  PktActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
#endif /* _DvrArch_1_30_ was defined */
         fiMemMapMemoryDescriptor_t  TgtThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  TgtTransitions;
         fiMemMapMemoryDescriptor_t  TgtActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
         fiMemMapMemoryDescriptor_t  DevThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  DevTransitions;
         fiMemMapMemoryDescriptor_t  DevActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
         fiMemMapMemoryDescriptor_t  CDBThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  CDBTransitions;
         fiMemMapMemoryDescriptor_t  CDBActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
         fiMemMapMemoryDescriptor_t  SFThread;
#ifndef __State_Force_Static_State_Tables__
         fiMemMapMemoryDescriptor_t  SFTransitions;
         fiMemMapMemoryDescriptor_t  SFActions;
#endif /* __State_Force_Static_State_Tables__ was not defined */
       };

typedef struct fiMemMapCalculation_s
               fiMemMapCalculation_t;

struct fiMemMapCalculation_s
       {
         fiMemMapInput_t        Input;
         fiMemMapParameters_t   Parameters;
         fiMemMapToRequest_t    ToRequest;
         fiMemMapMemoryLayout_t MemoryLayout;
       };

/*+
Function prototype
-*/

/*+
Function:  fiMemMapCalculate()

Purpose:   Calculates the memory layout for the entire FC Layer.

Assumes:   Calculation->Input has been initialized to describe the
           memory allocated to the FC Layer (as the arguments to
           fcInitializeChannel() indicate).  In the initial call from
           fcInitializeDriver(), the following values should be used:

                Calculation.Input.initType         = 0;
                Calculation.Input.sysIntsActive    = agFALSE;
                Calculation.Input.cachedMemoryPtr  = agNULL;
                Calculation.Input.cachedMemoryLen  = 0xFFFFFFFF;
                Calculation.Input.dmaMemoryUpper32 = 0;
                Calculation.Input.dmaMemoryLower32 = 0;
                Calculation.Input.dmaMemoryPtr     = agNULL;
                Calculation.Input.dmaMemoryLen     = 0xFFFFFFFF;
                Calculation.Input.nvMemoryLen      = 0xFFFFFFFF;
                Calculation.Input.cardRamUpper32   = 0;
                Calculation.Input.cardRamLower32   = 0;
                Calculation.Input.cardRamLen       = 0xFFFFFFFF;
                Calculation.Input.cardRomUpper32   = 0;
                Calculation.Input.cardRomLower32   = 0;
                Calculation.Input.cardRomLen       = 0xFFFFFFFF;
                Calculation.Input.usecsPerTick     = 0;

Returns:   agTRUE     If the resulting memory layout will fit
                    in the memory specified in Calculation->Input

           agFALSE    If the resulting memory layout will not fit
                    in the memory specified in Calculation->Input
-*/

osGLOBAL agBOOLEAN fiMemMapCalculate(
                                  agRoot_t              *hpRoot,
                                  fiMemMapCalculation_t *Calculation,
                                  agBOOLEAN                EnforceDefaults
                                );

#endif /* __MemMap_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\ntioctl.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   ntioctl.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/NTIOCTL.H $


Revision History:

   $Revision: 2 $
   $Date: 9/07/00 11:17a $
   $Modtime:: 8/31/00 3:23p            $

Notes:


--*/

#ifndef NTIOCTL_H
#define NTIOCTL_H

//
// IOCtl definitions
//



//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0x0000 - 0x7FFF, and 0x8000 - 0xFFFF are
// reserved for use by customers.
//

#define IOCTL_SCSI_MINIPORT_IO_CONTROL  0x8001

//
// Macro definition for defining IOCTL and FSCTL function control codes.
// Note that function codes 0x000 - 0x7FF are reserved for Microsoft
// Corporation, and 0x800 - 0xFFF are reserved for customers.
//

#define RETURNCODE0x0000003F   0x850

#define SMP_RETURN_3F     CTL_CODE(IOCTL_SCSI_MINIPORT_IO_CONTROL, RETURNCODE0x0000003F, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SMP_PRINT_STRING        0x80000001
#define SMP_DUMP_REGISTERS      0x80000002
#define SMP_DUMP_TRACE          0x80000003
#define SMP_WRITE_REGISTER      0x80000004

PCHAR Signature="MyDrvr";
PCHAR DrvrString="This string was placed in the data area by the SCSI miniport driver\n";

typedef struct {
    SRB_IO_CONTROL sic;
    UCHAR          ucDataBuffer[512];
} SRB_BUFFER, *PSRB_BUFFER;




#endif // NTIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\osflags.h ===
#ifndef __OSFLAGS_H__
#define __OSFLAGS_H__

#define  DA_8X_Compliant

// #define OSLayer_NT

// #define USE_EXTENDED_SGL

#include <miniport.h>
#include <scsi.h>
#include <devioctl.h>
#include <ntddscsi.h>
#include "cstring.h"
#include "globals.h"

#include "osstruct.h"
#include "hpfcctl.h"

#ifdef _FCCI_SUPPORT
#include "fccint.h"
#include "fcciimpl.h"
#endif

#include "protos.h"

#endif //  __OSFLAGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\oscalls.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   oscalls.c

Abstract:

   Contains calls to kernel

Authors:

   Michael Bessire
   Dennis Lindfors FC Layer support

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/MSE/OSLayer/C/OSCALLS.C $


Revision History:

   $Revision: 6 $
   $Date: 12/07/00 3:10p $
   $Modtime:: 12/07/00 3:09p           $

Notes:

--*/


#include "buildop.h"


#ifdef _DEBUG_READ_FROM_REGISTRY

BOOLEAN
ReadFromRegistry (char *paramName, int type, void *data, int len)
{
   return TRUE;
}

void
osBugCheck (ULONG code,
   ULONG param1,
   ULONG param2,
   ULONG param3,
   ULONG param4)
{
}

#endif // 

#ifndef osTimeStamp
#ifndef _SYSTEM_TIMESTAMP_
void
GetSystemTime (
   short int *Year, 
   short int *Month,
   short int *Day, 
   short int *Hour,
   short int *Minute,
   short int *Second,
   short int *Milliseconds)
{
   
}


unsigned long get_time_stamp(void)
{
	return 0;
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\osapi.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/OsApi.H $

   $Revision: 3 $
   $Date: 9/07/00 11:18a $ (Last Check-In)
   $Modtime:: 8/31/00 3:34p         $ (Last Modified)

Purpose:

  This is the NT-specific OS Layer API Include File.

--*/

#ifndef __NT_OsApi_H__

#define __NT_OsApi_H__

#ifndef __OSSTRUCT_H__

#include "osstruct.h"


#endif

/*
 * Define each OS Layer function
 */

#define osChipConfigWriteBit8(  hpRoot,Offset, Value) osChipConfigWriteBit( hpRoot, Offset, (os_bit32)Value, 8 )
#define osChipConfigWriteBit16( hpRoot,Offset, Value) osChipConfigWriteBit( hpRoot, Offset, (os_bit32)Value, 16 )
#define osChipConfigWriteBit32( hpRoot,Offset, Value) osChipConfigWriteBit( hpRoot, Offset, (os_bit32)Value, 32 )

#if DBG >= 1

#define osDEBUGPRINT(x) osDebugPrintString x

#define osBREAKPOINT \
    osDEBUGPRINT(( 0xF00000FF,"BreakPoint Hit ! %s Line %d\n", __FILE__, __LINE__ ))

osGLOBAL void osSingleThreadedEnter(
                                   agRoot_t *hpRoot
                                 );

osGLOBAL void osSingleThreadedLeave(
                                   agRoot_t *hpRoot
                                 );


#else

#define osSingleThreadedEnter( hpRoot )

#define osSingleThreadedLeave( hpRoot )


#define BREAKPOINT
#define osDEBUGPRINT(x)

#endif // DBG

#ifndef osFakeInterrupt

osGLOBAL void osFakeInterrupt( agRoot_t *hpRoot );

osGLOBAL void * osGetVirtAddress(
    agRoot_t      *hpRoot,
    agIORequest_t *hpIORequest,
    os_bit32 phys_addr );

#endif  /* ~osFakeInterrupt */

osGLOBAL void osCopy(void * destin, void * source, os_bit32 length );
osGLOBAL void osZero(void * destin, os_bit32 length );
osGLOBAL void osCopyAndSwap(void * destin, void * source, os_bit8 length );

os_bit8  SPReadRegisterUchar( void * x);
os_bit16 SPReadRegisterUshort(void * x);
os_bit32 SPReadRegisterUlong( void * x);

void SPWriteRegisterUchar(void * x, os_bit8  y);
void SPWriteRegisterUshort(void * x, os_bit16 y);
void SPWriteRegisterUlong(void * x, os_bit32 y);

os_bit8  SPReadPortUchar( void * x);
os_bit16 SPReadPortUshort(void * x);
os_bit32 SPReadPortUlong( void * x);

void SPWritePortUchar(void * x, os_bit8  y);
void SPWritePortUshort(void * x, os_bit16 y);
void SPWritePortUlong(void * x, os_bit32 y);


#define PVOID void *

#ifndef osDebugPrintString

osGLOBAL void osDebugPrintString(
                            os_bit32 Print_LEVEL,
                            char     *formatString,
                            ...
                            );

#endif  /* ~osDebugPrintString */


#if DBG < 1

#ifdef _DvrArch_1_20_
#define osLogDebugString(a,l,f,s1,s2,p1,p2,i1,i2,i3,i4,i5,i6,i7,i8)
#else    /* _DvrArch_1_20_ was not defined */
#define osLogDebugString(h,c,t,f,s1,s2,i1,i2,i3,i4,i5,i6,i7,i8)
#endif  /* _DvrArch_1_20_ was not defined */

#define osDebugBreakpoint(hpRoot, BreakIfTrue, DisplayIfTrue)
#define osTimeStamp(hpRoot)      ((os_bit32)0)

#endif // DBG < 1

#if DBG > 3
#define pCf  (unsigned char * )(( struct _CARD_EXTENSION * )(hpRoot->osData))

#define osCardRamReadBit8(  hpRoot, Offset ) SPReadRegisterUchar( (unsigned char *  )(((unsigned char  * )pCf->RamBase)+Offset))
#define osCardRamReadBit16( hpRoot, Offset ) SPReadRegisterUshort((unsigned short * )(((unsigned char *  )pCf->RamBase)+Offset))
#define osCardRamReadBit32( hpRoot, Offset ) SPReadRegisterUlong( (unsigned int *   )(((unsigned char  * )pCf->RamBase)+Offset))

#define osCardRamWriteBit8(  hpRoot,Offset, Value) SPWriteRegisterUchar(  (unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),(unsigned char )Value)
#define osCardRamWriteBit16( hpRoot,Offset, Value) SPWriteRegisterUshort( (unsigned short * )(((unsigned char * )pCf->RamBase)+Offset),(unsigned short)Value)
#define osCardRamWriteBit32( hpRoot,Offset, Value) SPWriteRegisterUlong(  (unsigned int *   )(((unsigned char * )pCf->RamBase)+Offset),(unsigned int ) Value)

#define osCardRamReadBlock( hpRoot, Offset, Buffer, BufLen)  ScsiPortReadRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),Buffer,BufLen)
#define osCardRamWriteBlock(hpRoot, Offset, Buffer, BufLen)  ScsiPortWriteRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),Buffer,BufLen)

#define osCardRomReadBlock( hpRoot, Offset, Buffer, BufLen)  ScsiPortReadRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RomBase)+Offset),Buffer,BufLen)
#define osCardRomWriteBlock(hpRoot, Offset, Buffer, BufLen)  ScsiPortWriteRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RomBase)+Offset),Buffer,BufLen)

#define osCardRomReadBit8(  hpRoot, Offset ) SPReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->RomBase)+Offset))
#define osCardRomReadBit16( hpRoot, Offset ) SPReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->RomBase)+Offset))
#define osCardRomReadBit32( hpRoot, Offset ) SPReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->RomBase)+Offset))


#define osCardRomWriteBit8(  hpRoot,Offset, Value) SPWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned char )Value)
#define osCardRomWriteBit16( hpRoot,Offset, Value) SPWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned short)Value)
#define osCardRomWriteBit32( hpRoot,Offset, Value) SPWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned int ) Value)


#define osChipIOLoReadBit8(  hpRoot, Offset ) SPReadPortUchar( (unsigned char * )(((unsigned char * )pCf->IoLBase)+Offset))
#define osChipIOLoReadBit16( hpRoot, Offset ) SPReadPortUshort((unsigned short *)(((unsigned char * )pCf->IoLBase)+Offset))
#define osChipIOLoReadBit32( hpRoot, Offset ) SPReadPortUlong( ( unsigned int * )(((unsigned char * )pCf->IoLBase)+Offset))

#define osChipIOLoWriteBit8(  hpRoot,Offset, Value) SPWritePortUchar( (unsigned char * )(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned char )Value)
#define osChipIOLoWriteBit16( hpRoot,Offset, Value) SPWritePortUshort((unsigned short *)(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned short)Value)
#define osChipIOLoWriteBit32( hpRoot,Offset, Value) SPWritePortUlong( ( unsigned int * )(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned int ) Value)

#define osChipIOUpReadBit8(  hpRoot, Offset ) SPReadPortUchar( (unsigned char * )(((unsigned char * )pCf->IoUpBase)+Offset))
#define osChipIOUpReadBit16( hpRoot, Offset ) SPReadPortUshort((unsigned short *)(((unsigned char * )pCf->IoUpBase)+Offset))
#define osChipIOUpReadBit32( hpRoot, Offset ) SPReadPortUlong( ( unsigned int * )(((unsigned char * )pCf->IoUpBase)+Offset))

#define osChipIOUpWriteBit8(  hpRoot,Offset,Value) SPWritePortUchar( (unsigned char * )(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned char )Value)
#define osChipIOUpWriteBit16( hpRoot,Offset,Value) SPWritePortUshort((unsigned short *)(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned short)Value)
#define osChipIOUpWriteBit32( hpRoot,Offset,Value) SPWritePortUlong( ( unsigned int * )(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned int ) Value)

#define osCardMemReadBit8(  hpRoot, Offset ) SPReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset))
#define osCardMemReadBit16( hpRoot, Offset ) SPReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset))
#define osCardMemReadBit32( hpRoot, Offset ) SPReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset))

#define osCardMemWriteBit8(  hpRoot,Offset, Value) SPWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned char )Value)
#define osCardMemWriteBit16( hpRoot,Offset, Value) SPWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned short)Value)
#define osCardMemWriteBit32( hpRoot,Offset, Value) SPWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned int ) Value)

#define osNvMemReadBit8(  hpRoot, nvMemOffset ) ((os_bit8)0)
#define osNvMemReadBit16( hpRoot, nvMemOffset ) ((os_bit16)0)
#define osNvMemReadBit32( hpRoot, nvMemOffset ) ((os_bit32)0)
#define osNvMemReadBlock( hpRoot, nvMemOffset, nvMemBuffer, nvMemBufLen )

#define osNvMemWriteBit8(  hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBit16( hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBit32( hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBlock( hpRoot, nvMemOffset, nvMemBuffer, nvMemBufLen )


#define osChipMemReadBit8(hpRoot, Offset)  SPReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset))
#define osChipMemReadBit16(hpRoot, Offset) SPReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset))
#define osChipMemReadBit32(hpRoot, Offset) SPReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset))

#define osChipMemWriteBit8(  hpRoot,Offset, Value) SPWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned char )Value)
#define osChipMemWriteBit16( hpRoot,Offset, Value) SPWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned short)Value)
#define osChipMemWriteBit32( hpRoot,Offset, Value) SPWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned int ) Value)
// *****************************************************************************************************************************************************************************
#else // Non DBG case
#define pCf  (unsigned char * )(( struct _CARD_EXTENSION * )(hpRoot->osData))

#define osCardRamReadBit8(  hpRoot, Offset ) ScsiPortReadRegisterUchar( (unsigned char *  )(((unsigned char  * )pCf->RamBase)+Offset))
#define osCardRamReadBit16( hpRoot, Offset ) ScsiPortReadRegisterUshort((unsigned short * )(((unsigned char *  )pCf->RamBase)+Offset))
#define osCardRamReadBit32( hpRoot, Offset ) ScsiPortReadRegisterUlong( (unsigned int *   )(((unsigned char  * )pCf->RamBase)+Offset))

#define osCardRamWriteBit8(  hpRoot,Offset, Value) ScsiPortWriteRegisterUchar(  (unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),(unsigned char )Value)
#define osCardRamWriteBit16( hpRoot,Offset, Value) ScsiPortWriteRegisterUshort( (unsigned short * )(((unsigned char * )pCf->RamBase)+Offset),(unsigned short)Value)
#define osCardRamWriteBit32( hpRoot,Offset, Value) ScsiPortWriteRegisterUlong(  (unsigned int *   )(((unsigned char * )pCf->RamBase)+Offset),(unsigned int ) Value)

#define osCardRamReadBlock( hpRoot, Offset, Buffer, BufLen)  ScsiPortReadRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),Buffer,BufLen)
#define osCardRamWriteBlock(hpRoot, Offset, Buffer, BufLen)  ScsiPortWriteRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RamBase)+Offset),Buffer,BufLen)

#define osCardRomReadBlock( hpRoot, Offset, Buffer, BufLen)  ScsiPortReadRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RomBase)+Offset),Buffer,BufLen)
#define osCardRomWriteBlock(hpRoot, Offset, Buffer, BufLen)  ScsiPortWriteRegisterBufferUchar((unsigned char *  )(((unsigned char * )pCf->RomBase)+Offset),Buffer,BufLen)

#define osCardRomReadBit8(  hpRoot, Offset ) ScsiPortReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->RomBase)+Offset))
#define osCardRomReadBit16( hpRoot, Offset ) ScsiPortReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->RomBase)+Offset))
#define osCardRomReadBit32( hpRoot, Offset ) ScsiPortReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->RomBase)+Offset))


#define osCardRomWriteBit8(  hpRoot,Offset, Value) ScsiPortWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned char )Value)
#define osCardRomWriteBit16( hpRoot,Offset, Value) ScsiPortWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned short)Value)
#define osCardRomWriteBit32( hpRoot,Offset, Value) ScsiPortWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->RomBase)+Offset) ,(unsigned int ) Value)


#define osChipIOLoReadBit8(  hpRoot, Offset ) ScsiPortReadPortUchar( (unsigned char * )(((unsigned char * )pCf->IoLBase)+Offset))
#define osChipIOLoReadBit16( hpRoot, Offset ) ScsiPortReadPortUshort((unsigned short *)(((unsigned char * )pCf->IoLBase)+Offset))
#define osChipIOLoReadBit32( hpRoot, Offset ) ScsiPortReadPortUlong( ( unsigned int * )(((unsigned char * )pCf->IoLBase)+Offset))

#define osChipIOLoWriteBit8(  hpRoot,Offset, Value) ScsiPortWritePortUchar( (unsigned char * )(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned char )Value)
#define osChipIOLoWriteBit16( hpRoot,Offset, Value) ScsiPortWritePortUshort((unsigned short *)(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned short)Value)
#define osChipIOLoWriteBit32( hpRoot,Offset, Value) ScsiPortWritePortUlong( ( unsigned int * )(((unsigned char * )pCf->IoLBase)+Offset) ,(unsigned int ) Value)

#define osChipIOUpReadBit8(  hpRoot, Offset ) ScsiPortReadPortUchar( (unsigned char * )(((unsigned char * )pCf->IoUpBase)+Offset))
#define osChipIOUpReadBit16( hpRoot, Offset ) ScsiPortReadPortUshort((unsigned short *)(((unsigned char * )pCf->IoUpBase)+Offset))
#define osChipIOUpReadBit32( hpRoot, Offset ) ScsiPortReadPortUlong( ( unsigned int * )(((unsigned char * )pCf->IoUpBase)+Offset))

#define osChipIOUpWriteBit8(  hpRoot,Offset,Value) ScsiPortWritePortUchar( (unsigned char * )(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned char )Value)
#define osChipIOUpWriteBit16( hpRoot,Offset,Value) ScsiPortWritePortUshort((unsigned short *)(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned short)Value)
#define osChipIOUpWriteBit32( hpRoot,Offset,Value) ScsiPortWritePortUlong( ( unsigned int * )(((unsigned char * )pCf->IoUpBase)+Offset) ,(unsigned int ) Value)

#define osCardMemReadBit8(  hpRoot, Offset ) ScsiPortReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset))
#define osCardMemReadBit16( hpRoot, Offset ) ScsiPortReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset))
#define osCardMemReadBit32( hpRoot, Offset ) ScsiPortReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset))

#define osCardMemWriteBit8(  hpRoot,Offset, Value) ScsiPortWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned char )Value)
#define osCardMemWriteBit16( hpRoot,Offset, Value) ScsiPortWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned short)Value)
#define osCardMemWriteBit32( hpRoot,Offset, Value) ScsiPortWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned int ) Value)

#define osNvMemReadBit8(  hpRoot, nvMemOffset ) ((os_bit8)0)
#define osNvMemReadBit16( hpRoot, nvMemOffset ) ((os_bit16)0)
#define osNvMemReadBit32( hpRoot, nvMemOffset ) ((os_bit32)0)
#define osNvMemReadBlock( hpRoot, nvMemOffset, nvMemBuffer, nvMemBufLen )

#define osNvMemWriteBit8(  hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBit16( hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBit32( hpRoot, nvMemOffset, nvMemValue)
#define osNvMemWriteBlock( hpRoot, nvMemOffset, nvMemBuffer, nvMemBufLen )

#define osChipMemReadBit8(hpRoot, Offset)  ScsiPortReadRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset))
#define osChipMemReadBit16(hpRoot, Offset) ScsiPortReadRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset))
#define osChipMemReadBit32(hpRoot, Offset) ScsiPortReadRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset))

#define osChipMemWriteBit8(  hpRoot,Offset, Value) ScsiPortWriteRegisterUchar( (unsigned char * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned char )Value)
#define osChipMemWriteBit16( hpRoot,Offset, Value) ScsiPortWriteRegisterUshort((unsigned short *)(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned short)Value)
#define osChipMemWriteBit32( hpRoot,Offset, Value) ScsiPortWriteRegisterUlong( ( unsigned int * )(((unsigned char * )pCf->MemIoBase)+Offset) ,(unsigned int ) Value)



#endif // DBG

#ifdef ScsiPortMoveMemory
#undef ScsiPortMoveMemory
void    ScsiPortMoveMemory( void * WriteBuffer,void * ReadBuffer,os_bit32 Length );
#endif


#ifndef _NTSRB_

os_bit8    ScsiPortReadPortUchar( os_bit8 * Port );
os_bit16 ScsiPortReadPortUshort( os_bit16 * Port );
os_bit32 ScsiPortReadPortUlong( os_bit32 * Port );
void ScsiPortReadPortBufferUchar( os_bit8 * Port, os_bit8 * Buffer, os_bit32  Count );
void ScsiPortReadPortBufferUshort( os_bit16 * Port, os_bit16 * Buffer, os_bit32 Count );
void ScsiPortReadPortBufferUlong( os_bit32 * Port,os_bit32 * Buffer,os_bit32 Count);
os_bit8 ScsiPortReadRegisterUchar( os_bit8 * Register );
os_bit16 ScsiPortReadRegisterUshort( os_bit16 * Register );
os_bit32 ScsiPortReadRegisterUlong( os_bit32 * Register );
void ScsiPortReadRegisterBufferUshort( os_bit16 * Register,os_bit16 * Buffer, os_bit32 Count );
void ScsiPortReadRegisterBufferUlong( os_bit32 * Register, os_bit32 * Buffer, os_bit32 Count );
void ScsiPortStallExecution( os_bit32 Delay );
void ScsiPortWritePortUchar( os_bit8 * Port, os_bit8 Value );
void ScsiPortWritePortUshort( os_bit16 * Port, os_bit16 Value );
void ScsiPortWritePortUlong(  os_bit32 * Port, os_bit32 Value );
void ScsiPortWritePortBufferUchar( os_bit8 * Port, os_bit8 * Buffer, os_bit32  Count );
void ScsiPortWritePortBufferUshort( os_bit16 * Port, os_bit16 * Buffer, os_bit32 Count );
void ScsiPortWritePortBufferUlong( os_bit32 * Port, os_bit32 * Buffer, os_bit32 Count );
void ScsiPortWriteRegisterUchar( os_bit8 * Register,os_bit8 Value );
void ScsiPortWriteRegisterUshort( os_bit16 * Register, os_bit16 Value );
void ScsiPortWriteRegisterUlong( os_bit32 * Register, os_bit32 Value );
void ScsiPortWriteRegisterBufferUshort( os_bit16 * Register, os_bit16 * Buffer,  os_bit32 Count );
void ScsiPortWriteRegisterBufferUlong( os_bit32 * Register, os_bit32 * Buffer, os_bit32 Count );

// #ifdef ScsiPortWriteRegisterBufferUchar

// #undef ScsiPortWriteRegisterBufferUchar

void ScsiPortWriteRegisterBufferUchar( os_bit8 * Register, os_bit8 * Buffer, os_bit32  Count );

#endif

// #ifdef  ScsiPortReadRegisterBufferUchar
// #undef  ScsiPortReadRegisterBufferUchar

#ifndef _NTSRB_
void ScsiPortReadRegisterBufferUchar( os_bit8 * Register, os_bit8 * Buffer,os_bit32  Count );
#endif

#endif  /* ~__NT_OsApi_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\osstruct.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   osstruct.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/MSE/OSLayer/H/Osstruct.h $


Revision History:

   $Revision: 8 $
   $Date: 3/30/01 11:54a $
   $Modtime:: 3/30/01 11:51a           $

Notes:


--*/

#ifndef __OSSTRUCT_H__
#define __OSSTRUCT_H__
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    OSSTRUCTS.H

Abstract:

    This is the Driver structures for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/MSE/OSLayer/H/Osstruct.h $

Revision History:

    $Revision: 8 $
        $Date: 3/30/01 11:54a $
     $Modtime:: 3/30/01 11:51a          $

--*/

#include "buildop.h"

#ifdef _DEBUG_EVENTLOG_
#include "eventlog.h"
#endif
#ifdef YAM2_1
#include "mapping.h"
#endif

#define pNULL ((void *)0)

#define NUMBER_ACCESS_RANGES 5

#define Debug_Break_Point _asm int 3

//
// NT documentation note:
// The registry subkey to specify the maximum number of scatter/gather list
// elements for each device on a given bus is
// \Registry\Machine\System\CurrentControlSet\Services\DriverName\
// Parameters\DeviceN\MaximumSGList
// N is the bus number assigned at initialization. If a value is present in this
// subkey at device initialization, the scsi port driver uses MaximumSGList as the
// initial for NumberOfPhysicalBreaks. The miniport driver's HwScsiFindAdapter
// routine can set NumberOfPhysicalBreaks to a lower value, if appropriate.
// The maximum value for MaximumSGList is 255. MaximumSGList is a REG_DWORD.
//
// As per Ed, FC Layer supports a maximum value of 31 * 0x3e0

#define osSGL_NUM_ENTRYS        256     // Maximum value for MaximumSGList (=255) + 1

#if DBG > 1
#define MULTIPLE_IOS_PER_DEVICE         TRUE
#define OS_STAMP_INTERVAL               1220 // 3050  // 610 per second
#else
#define MULTIPLE_IOS_PER_DEVICE         TRUE
#define OS_STAMP_INTERVAL               1831    // 3 seconds
#endif



#define NUMBER_OF_BUSES 8
#define MAXIMUM_TID     32
#define MAXIMUM_LUN     8
#define MAX_IO_PER_DEVICE 64 // For now Was 8

#define MAX_FC_DEVICES 128  // 127 + one unused slot at the end. Rounding to 128 is necessary
                            // to avoid accidently referring to the 128th entry using BUILD_SLOT macro.
#define MAX_ADAPTERS 32

#define OS_STAMP_PER_SECOND             610 //  per second


#define OS_TIMER_CALL_TO_STAMP_RATIO    1637    // Microseconds to stamp increment

#define OS_TIMER_CALL_INTERVAL (OS_TIMER_CALL_TO_STAMP_RATIO * OS_STAMP_INTERVAL)

#define SWAPDWORD(val) (((val)<<24)|(((val)&0xFF00)<<8)|(((val)&0xFF0000)>>8)|((val)>>24))

#define osFCP_RSP_LEN_VALID   0x1 // For FCP_RSP status byte
#define osFCP_SNS_LEN_VALID   0x2
#define osFCP_RESID_OVER      0x4
#define osFCP_RESID_UNDER     0x8

#define osFCP_STATUS_VALID_FLAGS     0x2
#define osFCP_STATUS_SCSI_STATUS     0x3

#define FCP_RSP_CODE_OK             0x0
#define FCP_RSP_CODE_BURST          0x1
#define FCP_RSP_CODE_CMD_INVALID    0x2
#define FCP_RSP_CODE_RO_MISMATCH    0x3
#define FCP_RSP_CODE_TM_NOT_SUPPORT 0x4
#define FCP_RSP_CODE_TM_FAILED      0x5


#if DBG
#define HP_FC_TRACE_BUFFER_LEN  8192
#define Bad_Things_Happening _asm int 3
#else
#define Bad_Things_Happening _asm nop
#endif



// Macro used to convert bus(0-3),tid(0-31) to a 0-127 tid value
// #define GET_TID(bus,tid) ((bus * MAXIMUM_TID) + tid)

// number of times we'll retry logi commands on busy or unable to perform command
// #define MAX_LOGI_RETRIES 3

#define ERR_MAP_RAMBASE 0xC0001000

#define MIN(x,y)  (((x) < (y)) ? (x) : (y))
#define MAX(x,y)  (((x) > (y)) ? (x) : (y))

#define PCI_SOFTRST             0x00000001

#define SOFT_RESET  CORE_RESET
#define HARD_RESET  PCI_SOFTRST
#define NO_RESET    0x00000000

#define BUILD_SLOT( PathId , TargetId )  ((( (PathId >= 4  ? (PathId - 4) : PathId  ) << 5)) | TargetId)

#define IS_VALID_PTR( p ) (((void *)p) ? (TRUE) : (FALSE))

#define offsetofS(s,m)   (size_t)&(((s *)0)->m)

typedef union LongChar_u LongChar_t;

union LongChar_u{
    UCHAR   bytes[4];
    USHORT  shorts[2];
    ULONG   ul;
    };

typedef struct _OSL_QUEUE {
    void    *Head;
    void    *Tail;
} OSL_QUEUE;


#define PERIPHERAL_ADDRESS  0
#define VOLUME_SET_ADDRESS  1
#define LUN_ADDRESS         2

typedef struct _LUN_LU{   // Logical Unit Addressing SCSI Mux
    UCHAR Target        : 6;
    UCHAR Address_mode  : 2;
    UCHAR Lun           : 5;
    UCHAR Bus_number    : 3;
    } LUN_LU, *pLUN_LU;

typedef struct _LUN_PD{  // Peripheral device Addressing Disk drives
    UCHAR Bus_number    : 6;
    UCHAR Address_mode  : 2;
    UCHAR Lun           : 8;
    } LUN_PD, *pLUN_PD;

typedef struct _LUN_VS{  // Volume Set Addressing Disk Arrays
    UCHAR Lun_hi         :  6;
    UCHAR  Address_mode  :  2;
    UCHAR Lun            :  8;
    } LUN_VS, *pLUN_VS;

typedef union _LUN{
    LUN_PD lun_pd[4];
    LUN_VS lun_vs[4];
    LUN_LU lun_lu[4];
    }LUN,* PLUN;

// Card State
#define  CS_DRIVER_ENTRY            0x00000100 // Initial Driver load superset
#define  CS_FCLAYER_LOST_IO         0x00001000 // IO Lost
#define  CS_DURING_DRV_ENTRY        0x00000001 // of DRV_ENTRY FIND and START
#define  CS_DURING_FINDADAPTER      0x00000002 // Anything during scsiportinit
#define  CS_DURING_DRV_INIT         0x00000004
#define  CS_DURING_RESET_ADAPTER    0x00000008
#define  CS_DURING_STARTIO          0x00000010
#define  CS_DURING_ISR              0x00000020
#define  CS_DURING_OSCOMPLETE       0x00000040
#define  CS_HANDLES_GOOD            0x00000080
#define  CS_DURING_ANY              0x000001FF
#define  CS_DUR_ANY_ALL             0xF00001FF
#define  CS_DUR_ANY_MOD             0x200001FF
#define  CS_DUR_ANY_LOW             0x400001FF

#define  ALWAYS_PRINT               0x01000000  // If statement executes always
#define  DBG_VERY_DETAILED          0x10000000  // All debug statements
#define  DBG_MODERATE_DETAIL        0x20000000  // Most debug statements
#define  DBG_LOW_DETAIL             0x40000000  // Entry and exit
#define  DBG_JUST_ERRORS            0x80000000  // Errors
#define  DBG_DEBUG_MASK             0xF0000000  // Mask debug bits
#define  DBG_DEBUG_OFF              0xF0000000  // NO debug statements
#define  DBG_DEBUG_FULL             0x000001FF  // ALL debug statements and CS
#define  DBG_DEBUG_ALL              0x00000000  // ALL debug statements

//#define DBGSTATE  ((pCard) ? (pCard->State)  : osBREAKPOINT)
#define DBGSTATE  (pCard->State)


#define DENTHIGH    ( CS_DURING_DRV_ENTRY   | DBG_VERY_DETAILED )
#define DENTMOD     ( CS_DURING_DRV_ENTRY   | DBG_MODERATE_DETAIL )
#define DENT        ( CS_DURING_DRV_ENTRY   | DBG_LOW_DETAIL )
#define DVHIGH      ( CS_DURING_ANY         | DBG_VERY_DETAILED )
#define DERROR ( DBG_DEBUG_FULL )
#define DHIGH ( DBGSTATE | DBG_VERY_DETAILED   )
#define DMOD  ( DBGSTATE | DBG_MODERATE_DETAIL )
#define DLOW  ( DBGSTATE | DBG_LOW_DETAIL      )
#define DERR  ( DBGSTATE | DBG_JUST_ERRORS     )

//#define  ALWAYS_PRINT               DBG_DEBUG_OFF

// Request State
#define  RS_STARTIO                 0x00000001
#define  RS_WAITING                 0x00000002
#define  RS_ISR                     0x00000004
#define  RS_COMPLETE                0x00000008
#define  RS_NODEVICE                0x00000010
#define  RS_TIMEOUT                 0x00000020
#define  RS_RESET                   0x00000040
#define  RS_TO_BE_ABORTED           0x00000080

typedef struct _PERFORMANCE    PERFORMANCE;
typedef struct _PERFORMANCE * pPERFORMANCE;

struct _PERFORMANCE {
                    ULONG inOsStartio;
                    ULONG inFcStartio;
                    ULONG outFcStartio;
                    ULONG outOsStartio;
                    ULONG inOsIsr;
                    // ULONG inFcIsr;
                    // ULONG outFcIsr;
                    ULONG inFcDIsr;
                    ULONG inOsIOC;
                    ULONG outOsIOC;
                    // ULONG outFcDIsr;
                    ULONG outOsIsr;
                    };




typedef struct _LU_EXTENSION{   // Logical Unit Extension per Device Storage
    UCHAR       flags;
    UCHAR       deviceType;
    USHORT      OutstandingIOs;
    USHORT      MaxOutstandingIOs;
    USHORT      MaxAllowedIOs;
    LUN Lun;
    agFCDev_t * phandle;
    #ifndef YAM2_1
    #ifdef _DEBUG_EVENTLOG_
    UCHAR           InquiryData[40];
    agFCDevInfo_t   devinfo;
    UCHAR           WWN[8];
    #endif
    #else
    USHORT      PaDeviceIndex;  
        #define PA_DEVICE_ALREADY_LOGGED    0x0001
    USHORT      LogFlags;
    ULONG       Mode;
//  ULONG       CurrentMode;
//  LUN         PaLun;
//  LUN         VsLun;
//  LUN         LuLun;
    #endif  
      }LU_EXTENSION, *PLU_EXTENSION;

// Defines for LU_EXTENSION flags

#define LU_EXT_INITIALIZED      1

typedef struct _CARD_EXTENSION    CARD_EXTENSION;
typedef struct _CARD_EXTENSION * PCARD_EXTENSION;
typedef struct _SRB_EXTENSION      SRB_EXTENSION;
typedef struct _SRB_EXTENSION    *PSRB_EXTENSION;

struct _SRB_EXTENSION{   // SRB Extension per Request Storage
    PSRB_EXTENSION pNextSrbExt;
    agRoot_t * phpRoot;
    pPERFORMANCE Perf_ptr;
    PCARD_EXTENSION pCard;
    void * AbortSrb;   // PSCSI_REQUEST_BLOCK
                       // Save srb for abort when interrupt handler is called
    void * pSrb;       // Original srb
    void *  pNextSrb;   // Next srb
    PUCHAR SglVirtAddr;
    ULONG SglDataLen;
    ULONG SglElements;
    ULONG SRB_State;
    ULONG SRB_StartTime;
    ULONG SRB_TimeOutTime;
    ULONG SRB_IO_COUNT;
    PLU_EXTENSION pLunExt;
    void * orgDataBuffer; // used to store the original Srb->DataBuffer, during dump
    agIORequest_t hpIORequest;
    agIORequestBody_t hpRequestBody;
    };

// Device type definitions */

#define DEV_NONE                0
#define DEV_MUX                 1
//
// The artiste Formerly known as DEV_EMC
//
#define DEV_VOLUMESET                 2
#define DEV_COMPAQ              3

#define MAX_SPECIAL_DEVICES     2

typedef struct _SPECIAL_DEV {
    USHORT  devType;            /* type of device DEV_MUX / DEV_VOLUMESET / DEV_COMPAQ / DEV_NONE */
    USHORT  addrMode;           /* Addressing mode used with the device */
    ULONG   devHandleIndex;     /* index into device handle array */
} SPECIAL_DEV;

#define LOGGED_IO_MAX 100
#define HP_FC_RESPONSE_BUFFER_LEN 128

typedef struct _NODE_INFO {
    ULONG       DeviceType;
} NODE_INFO;

#define PCI_CONFIG_DATA_SIZE            256
#define NUM_PCI_CONFIG_DATA_ELEMENTS    (PCI_CONFIG_DATA_SIZE/sizeof(ULONG))

#if defined(HP_PCI_HOT_PLUG)

    #define MAX_CONTROLLERS             12
    #define HPP_VERSION                 SUPPORT_VERSION_10
    #define HBA_DESCRIPTION             "Agilent Technologies Fibre Channel HBA"    //Max length 255 characters
    //Controller States for Hot Plug Operation
    #define IOS_HPP_HBA_EXPANDING       0x00001070
    #define IOS_HPP_HBA_CACHE_IN_USE    0x00001075
    #define IOS_HPP_BAD_REQUEST         0x000010ff

    // The following 2 macros are used to temporarily block and then release
    // our startio routine by setting/clearing the state hot plug flags.

    #define HOLD_IO(pCard) (pCard->stateFlags |= PCS_HBA_OFFLINE)
    #define FREE_IO(pCard) (pCard->stateFlags &= ~PCS_HBA_OFFLINE)

    // Callback prototype for hot plug service async messaging.

    typedef ULONG (*PCALLBACK) ( void *pEvent );

    typedef struct _RCMC_DATA {
        ULONG   driverId;
        PCALLBACK   healthCallback;
        ULONG   controllerChassis;
        UCHAR   slot;                           
        UCHAR   numAccessRanges;
        ULONG   accessRangeLength[NUMBER_ACCESS_RANGES];
    }RCMC_DATA, *PRCMC_DATA;

    typedef struct _PSUEDO_DEVICE_EXTENSION {
        ULONG   extensions[MAX_CONTROLLERS];
        ULONG   driverId;
        ULONG   hotplugVersion;
    } PSUEDO_DEVICE_EXTENSION, *PPSUEDO_DEVICE_EXTENSION;

#endif


/* 
 * Events used for SNIA.
 */
#ifdef _SAN_IOCTL_

#define SAN_EVENT_LIP_OCCURRED          1
#define SAN_EVENT_LINK_UP               2
#define SAN_EVENT_LINK_DOWN             3
#define SAN_EVENT_LIP_RESET_OCCURRED    4
#define SAN_EVENT_RSCN                  5
#define SAN_EVENT_PROPRIETARY           0xFFFF

typedef struct SAN_Link_EventInfo {
    ULONG       PortFcId;               /* Port which this event occurred */
    ULONG       Reserved[3];
} SAN_LINK_EVENTINFO, *PSAN_LINK_EVENTINFO;

typedef struct SAN_RSCN_EventInfo {
    ULONG       PortFcId;               /* Port which this event occurred */
    ULONG       NPortPage;              /* Reference FC-FS for  RSCN ELS "Affected N-Port Pages"*/
    ULONG       Reserved[2];
} SAN_RSCN_EVENTINFO, *PSAN_RSCN_EVENTINFO;

typedef struct SAN_Pty_EventInfo {
    ULONG       PtyData[4];  /* Proprietary data */
} SAN_PTY_EVENTINFO, *PSAN_PTY_EVENTINFO;

typedef struct SAN_EventInfo {
    ULONG       EventCode;
    union {
        SAN_LINK_EVENTINFO Link_EventInfo;
        SAN_RSCN_EVENTINFO RSCN_EventInfo;
        SAN_PTY_EVENTINFO Pty_EventInfo;
        } Event;
} SAN_EVENTINFO, *PSAN_EVENTINFO;

#endif

#if defined(_DEBUG_STALL_ISSUE_) && defined(i386)
typedef struct _S_STALL_DATA
{
    ULONG   MicroSec;
    ULONG   Address;
}   S_STALL_DATA;

#endif

struct _CARD_EXTENSION{  // Card Pointer per Adapter Storage
    ULONG signature;                    // unique signature for debugging purposes
    PSRB_EXTENSION RootSrbExt;
    
    #ifdef _DEBUG_PERF_DATA_
    PERFORMANCE perf_data[ LOGGED_IO_MAX ];
    ULONG PerfStartTimed;
    ULONG TimedOutIO;
    #endif
    
#ifdef _DEBUG_LOSE_IOS_
    ULONG Srb_IO_Count;
    ULONG Last_Srb_IO_Count;
#endif
    agRoot_t hpRoot;
    void * IoLBase;              // Io Address Lower Reg 0
    void * IoUpBase;             // Io Address Upper Reg 0
    void * MemIoBase;            // Memory mapped Io Address Reg 0
    void * RamBase;              // On card Ram Address 0
    void * RomBase;              // On card Flash Address 0
    void * AltRomBase;           // Alternate Rom at config space 0x30
    ULONG RamLength;             // Ram Length
    ULONG RomLength;             // Rom Length
    ULONG AltRomLength;          // Alternate Rom Length
    USHORT State;                 // Current Adapter State
    USHORT flags;
    USHORT LinkState;             // Current link state.
    USHORT LostDevTickCount;      // # of ticks to wait after link up to see lost devices
    ULONG SystemIoBusNumber;     // Needed by PCI config
    ULONG SlotNumber;            // Needed by PCI config

    PULONG cachedMemoryPtr;
    ULONG cachedMemoryNeeded;
    ULONG cachedMemoryAlign;
    ULONG dmaMemoryUpper32;
    ULONG dmaMemoryLower32;
    PULONG dmaMemoryPtr;
    ULONG dmaMemoryNeeded;
    ULONG nvMemoryNeeded;
    ULONG cardRamUpper;
    ULONG cardRamLower;
    ULONG cardRomUpper;
    ULONG cardRomLower;
    ULONG usecsPerTick;

    OSL_QUEUE   AdapterQ;
    OSL_QUEUE   RetryQ;
    ULONG IsFirstTime;                      //
    ULONG SingleThreadCount;                //
    ULONG ResetType;                        //
    ULONG External_ResetCount;              //
    ULONG Internal_ResetCount;              //
    ULONG LIPCount;
    ULONG Num_Devices;                      //
    ULONG OldNumDevices;
    ULONG ResetPathId;
    ULONG ForceTag;
	
//--LP101000    agFCDev_t hpFCDev[MAX_FC_DEVICES];
//--LP101000	NODE_INFO nodeInfo[MAX_FC_DEVICES];
    agFCDev_t	*hpFCDev;
	NODE_INFO	*nodeInfo;
    ULONG  cardHandleIndex;      // index into the devHandle array for card itself
    ULONG Number_interrupts;
    ULONG TicksSinceLinkDown;
#ifndef YAM2_1
    SPECIAL_DEV specialDev[MAX_SPECIAL_DEVICES];
#endif  

    // Move these to the bottom to avoid alignment issue in IA-64, BOOLEAN is defined as BYTE.
    //    volatile BOOLEAN inDriver;
    //    volatile BOOLEAN inTimer;

    //
    // For IA-64 , the Response_Buffer has to be 32 bit alligned.
    //
    UCHAR Response_Buffer[HP_FC_RESPONSE_BUFFER_LEN];
    ULONG pciConfigData[NUM_PCI_CONFIG_DATA_ELEMENTS];
    //
    // KC
    //
    char * ArgumentString;
#if DBG_TRACE
    ULONG traceBufferLen;
    char  *curTraceBufferPtr;
    char  traceBuffer[HP_FC_TRACE_BUFFER_LEN];
#endif

#if defined(HP_PCI_HOT_PLUG)
    ULONG   stateFlags;
    ULONG   controlFlags;
    ULONG   IoHeldRetMaxIter;   // Max countdown before returning SRB_STATUS_ERROR in StartIo
    ULONG   IoHeldRetTimer;     // Countdown for returning SRB_STATUS_BUSY in StartIo
    RCMC_DATA   rcmcData;       // PCI Hot Plug related structure
    PPSUEDO_DEVICE_EXTENSION    pPsuedoExt;
#endif

    ULONG   PrevLinkState;

#ifdef _DEBUG_EVENTLOG_
    ULONG   LogActive;

//  struct  _EVENTLOG_STRUCT    EventLog;
    struct  _EVENTLOG_BUFFER        *Events;
    ULONG   EventLogBufferIndex;

    #ifndef YAM2_1
    agFCDev_t Old_hpFCDev[MAX_FC_DEVICES];
    #endif
#endif
    ULONG   CDResetCount;
#ifdef __REGISTERFORSHUTDOWN__
    ULONG   AlreadyShutdown;
#endif
    ULONG SrbStatusFlag;
    void *localDataBuffer;  // pointer to the local DMA area, used during dump
// Move these from the top to the bottom to avoid alignment issue in IA-64, BOOLEAN is defined as BYTE.
    volatile BOOLEAN inDriver;
    volatile BOOLEAN inTimer;

#ifdef _SAN_IOCTL_
    #define             MAX_FC_EVENTS   64
    ULONG               SanEvent_GetIndex;
    ULONG               SanEvent_PutIndex;
    LONG                SanEvent_UngetCount;
    ULONG               SanEvent_Reserved;
    SAN_EVENTINFO       SanEvents[MAX_FC_EVENTS];
#endif

#ifdef YAM2_1
    PULONG	UncachedMemoryPtr;
	UCHAR   Reserved1;
    UCHAR   Reserved2;
    struct _DEVICE_ARRAY    *Dev;
#endif  

#if defined(_DEBUG_STALL_ISSUE_) && defined(i386)
    #define             STALL_COUNT_MAX     20
    ULONG               StallCount;
    S_STALL_DATA        StallData[STALL_COUNT_MAX];
#endif
    };

#define MAX_OS_ADJUST_BIT32_PARAMS           64
#define MAX_OS_ADJUST_BUFFER_PARAMS          16
#define MAX_OS_ADJUST_PARAM_NAME_LEN         64
#define MAX_OS_ADJUST_PARAM_BUFFER_VALUE_LEN 64

struct _OS_ADJUST_PARAM_CACHE {
    int     numBit32Elements;
    int     numBufferElements;
    BOOLEAN safeToAccessRegistry;
    struct {
        char  paramName[MAX_OS_ADJUST_PARAM_NAME_LEN];
        ULONG value;
    } bit32Element[MAX_OS_ADJUST_BIT32_PARAMS];
    struct {
        char  paramName[MAX_OS_ADJUST_PARAM_NAME_LEN];
        char  value[MAX_OS_ADJUST_PARAM_BUFFER_VALUE_LEN];
    } bufferElement[MAX_OS_ADJUST_BUFFER_PARAMS];
};

typedef struct _OS_ADJUST_PARAM_CACHE OS_ADJUST_PARAM_CACHE;

//
// Remove the use of static global, NT50 PnP support
//

/*
extern PCARD_EXTENSION  hpTLCards [MAX_ADAPTERS];
extern int hpTLNumCards;
*/

// LinkState defintions.

#define LS_LINK_UP      0
#define LS_LINK_DOWN    1
#define LS_LINK_DEAD    2


// Flags

#define OS_DO_SOFT_RESET        1
#define OS_IGNORE_NEXT_RESET    2

#define TICKS_FOR_LINK_DEAD     60
#define INITIATOR_BUS_ID        254

#define LOST_DEV_TICK_COUNT     15

#endif //  __OSSTRUCT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\osapi.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    Osapi.c

Abstract:

    This file provides OS specific functions to the FCLayer

Authors:

    Dennis Lindfors

Environment:

    kernel mode only


Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/OSAPI.C $

Revision History:

    $Revision: 8 $
    $Date: 3/30/01 11:55a $
    $Modtime:: 3/30/01 11:52a    $


*/

#include "buildop.h"        //LP021100 build switches
#include "osflags.h"
//#include <memory.h>

#if DBG > 0
#include <stdarg.h>
//#include <stdio.h>
#include "ntdebug.h"
#endif // DBG

#if DBG < 2
os_bit32   hpFcConsoleLevel = 0;
os_bit32   hpFcTraceLevel = 0;
#else
os_bit32   hpFcConsoleLevel = EXTERNAL_HP_DEBUG_LEVEL; // NTdebug.h
os_bit32   hpFcTraceLevel = 0;

#endif

extern ULONG gCrashDumping;

void ERROR_CONTEXT(char * file,  int line)
{
    osDEBUGPRINT((ALWAYS_PRINT,"Invalid Context File %s Line %d\n",file, line));
    // Bad_Things_Happening
}

#ifdef NEVEREVER
void * osGetVirtAddress(
    agRoot_t      *hpRoot,
    agIORequest_t *hpIORequest,
    os_bit32      phys_addr
    )
{
    PCARD_EXTENSION pCard;
    PSRB_EXTENSION pSrbExt;
    
    void * Virtaddr = NULL;
    pCard   = (PCARD_EXTENSION)hpRoot->osData;
    
    osDEBUGPRINT((DHIGH,"IN osGetVirtAddress hpIORequest %lx phys_addr %x\n", hpIORequest,phys_addr ));
    
    //pSrbExt = (PSRB_EXTENSION)hpIORequest->osData;
    pSrbExt = hpObjectBase(SRB_EXTENSION,hpIORequest,hpIORequest);
    
    if( pSrbExt->OrigPhysicalDataAddr == phys_addr)
    {
       Virtaddr = pSrbExt->OrigVirtDataAddr;
    }
    
    if(!Virtaddr ) osDEBUGPRINT((DMOD,"OUT osGetVirtAddress Addr %lx\n", Virtaddr));
    
    return(Virtaddr );
}
#endif // NEVEREVER

os_bit32 osGetSGLChunk(
    agRoot_t         *hpRoot,
    agIORequest_t    *hpIORequest,
    os_bit32          hpChunkOffset,
    os_bit32         *hpChunkUpper32,
    os_bit32         *hpChunkLower32,
    os_bit32         *hpChunkLen
    )
{
	SCSI_PHYSICAL_ADDRESS phys_addr;
	PSRB_EXTENSION pSrbExt;
	os_bit32 length;
	PCARD_EXTENSION pCard;
	ULONG	printLevel;
	PVOID	param;

	pCard   = (PCARD_EXTENSION)hpRoot->osData;
    //pSrbExt = (PSRB_EXTENSION)hpIORequest->osData;
	pSrbExt = hpObjectBase(SRB_EXTENSION,hpIORequest,hpIORequest);

	pSrbExt->SglElements++;

	#ifdef _DEBUG_CRASHDUMP_
	if (gCrashDumping)
		printLevel = ALWAYS_PRINT;
	else
	#endif
		printLevel = DHIGH;

	osDEBUGPRINT((printLevel,"IN osGetSGLChunk hpRoot %lx hpIORequest %lx\n", hpRoot, hpIORequest ));
	osDEBUGPRINT((printLevel,"pCard %lx pSrbExt %lx Data addr %lx Length %x\n", pCard ,
                        pSrbExt,pSrbExt->SglVirtAddr, pSrbExt->SglDataLen ));

	osDEBUGPRINT((printLevel,"Data offset %x U %lx L %x pLen %x\n",hpChunkOffset,*hpChunkUpper32,*hpChunkLower32,*hpChunkLen ));
	
	param = (PSCSI_REQUEST_BLOCK)pSrbExt->pSrb;

	if (gCrashDumping)
	{
	   if (pSrbExt->orgDataBuffer)
		   param = NULL;
	   length = pSrbExt->SglDataLen;
	}

    phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                        // (PSCSI_REQUEST_BLOCK)pSrbExt->pSrb,
										(PSCSI_REQUEST_BLOCK)param,
                                        pSrbExt->SglVirtAddr+hpChunkOffset,
                                        &length);

	osDEBUGPRINT((printLevel,"Length %x High %x Low %x\n",length, phys_addr.HighPart,phys_addr.LowPart ));

	if(phys_addr.LowPart == 0 &&  phys_addr.HighPart == 0 ) return(osSGLInvalid);

	*hpChunkLower32 = phys_addr.LowPart;
	*hpChunkUpper32 = phys_addr.HighPart;

	// WAS pSrbExt->SglVirtAddr += length;

	if(  (int)(pSrbExt->SglDataLen) < (length+hpChunkOffset))
	{
		*hpChunkLen = (int)(pSrbExt->SglDataLen) - hpChunkOffset;
	}
	else
	{
		// pSrbExt->SglDataLen-= length;
		*hpChunkLen = length;
	}

	osDEBUGPRINT((printLevel,"OUT osGetSGLChunk length %lx hpChunkLen %lx Data addr %lx Length %x\n", length , *hpChunkLen,pSrbExt->SglVirtAddr, pSrbExt->SglDataLen ));

	return(osSGLSuccess);
}


char * error_discriptions[25]=
{
   "ERR_MAP_IOBASELADDR   ",
   "ERR_MAP_IOBASEUADDR   ",
   "ERR_UNCACHED_EXTENSION",
   "ERR_RESET_FAILED      ",
   "ERR_ALIGN_QUEUE_BUF   ",
   "ERR_ACQUIRED_ALPA     ",
   "ERR_RECEIVED_LIPF_ALPA",
   "ERR_RECEIVED_BAD_ALPA ",
   "ERR_CM_RECEIVED       ",
   "ERR_INT_STATUS ?IDLE ?",
   "ERR_FM_STATUS         ",
   "ERR_PLOGI             ",
   "ERR_PDISC             ",
   "ERR_ADISC             ",
   "ERR_PRLI              ",
   "ERR_ERQ_FULL          ",
   "ERR_INVALID_LUN_EXT   ",
   "ERR_SEST_INVALIDATION ",
   "ERR_SGL_ADDRESS       ",
   "ERR_SGL_CHUNK_INVALID ",
   "ERR_SGL_DESCRIPTOR    ",
   "ERR_FCP_CONTROL       ",
   "ERR_CACHED_EXTENSION  ",
   "LINK UP DOWN DETECTED ",
   "UNKNOWN ERROR !       "
};

//
// osLogBit32 ()
//
// Logs the value of the input parameter "hpBit32" to event log.
//

osGLOBAL void osLogBit32(
   agRoot_t *hpRoot,
   os_bit32  hpBit32
   )
{
   PCARD_EXTENSION pCard;
   BOOLEAN known_error = FALSE;
   char *tmp = error_discriptions[24];

   pCard = (PCARD_EXTENSION)hpRoot->osData;

   switch(hpBit32)
   {
      case    0xf0000000: tmp=error_discriptions[0];  known_error = TRUE; break;
      case    0xe0000000: tmp=error_discriptions[1];  known_error = TRUE; break;
      case    0xd0000000: tmp=error_discriptions[2];  known_error = TRUE; break;
      case    0xc0000000: tmp=error_discriptions[3];  known_error = TRUE; break;
      case    0xb0000000: tmp=error_discriptions[4];  known_error = TRUE; break;
      case    0xa0000000: tmp=error_discriptions[5];  known_error = TRUE; break;
      case    0x90000000: tmp=error_discriptions[6];  known_error = TRUE; break;
      case    0x80000000: tmp=error_discriptions[7];  known_error = TRUE; break;
      case    0x80000300: tmp=error_discriptions[23]; known_error = TRUE; break;
      case    0x70000000: tmp=error_discriptions[8];  known_error = TRUE; break;
      case    0x70000001: tmp=error_discriptions[24]; known_error = TRUE; break;
      case    0x60000000: tmp=error_discriptions[9];  known_error = TRUE; break;
      case    0x50000000: tmp=error_discriptions[10]; known_error = TRUE; break;
      case    0x40000000: tmp=error_discriptions[11]; known_error = TRUE; break;
      case    0x30000000: tmp=error_discriptions[12]; known_error = TRUE; break;
      case    0x20000000: tmp=error_discriptions[13]; known_error = TRUE; break;
      case    0x10000000: tmp=error_discriptions[14]; known_error = TRUE; break;
      case    0x0f000000: tmp=error_discriptions[15]; known_error = TRUE; break;
      case    0x0e000000: tmp=error_discriptions[16]; known_error = TRUE; break;
      case    0x0d000000: tmp=error_discriptions[17]; known_error = TRUE; break;
      case    0x0c000000: tmp=error_discriptions[18]; known_error = TRUE; break;
      case    0x0b000000: tmp=error_discriptions[19]; known_error = TRUE; break;
      case    0x0a000000: tmp=error_discriptions[20]; known_error = TRUE; break;
      case    0x09000000: tmp=error_discriptions[21]; known_error = TRUE; break;
      case    0xd8000000: tmp=error_discriptions[22]; known_error = TRUE; break;

      // default:
   }
   osDEBUGPRINT((ALWAYS_PRINT,"osLogBit32 %x %s \n", hpBit32,tmp));

   ScsiPortLogError( pCard,
                        NULL,
                        0,
                        0,
                        0,
                        SP_INTERNAL_ADAPTER_ERROR,
                        hpBit32 );

   #ifdef _DEBUG_EVENTLOG_
   LogEvent(pCard, NULL, HPFC_MSG_LOGBIT32, NULL, 0, "hex(%08x) %s", hpBit32, tmp);
   #endif
   
}


#ifdef _DvrArch_1_20_

//
// osLogDebugString ()
//
// Generates a formatted string and logs the formatted string to
// either debug window or trace buffer or both depending on the
// input parameters "detailLevel".
//
// If the input parameter "detailLevel" is less than or equal to
// the global parameter hpFcConsoleLevel then the formatted string is
// logged to the debug window.
//
// If the input parameter "detailLevel" is less than or equal to
// the global parameter hpFcTraceLevel then the formatted string is
// logged to the trace buffer.
//
#ifndef osLogDebugString
osGLOBAL void
osLogDebugString (
   agRoot_t *hpRoot,
   os_bit32  detailLevel,
   char     *formatString,
   char     *firstString,
   char     *secondString,
   void     *firstPtr,
   void     *secondPtr,
   os_bit32  firstBit32,
   os_bit32  secondBit32,
   os_bit32  thirdBit32,
   os_bit32  fourthBit32,
   os_bit32  fifthBit32,
   os_bit32  sixthBit32,
   os_bit32  seventhBit32,
   os_bit32  eighthBit32 )
{
#if DBG
   PCARD_EXTENSION pCard;
   char            *trBufEnd, *srcPtr;
   char            s[256];
   os_bit32        n=0;
   char            *ps;
   CSHORT          year, month, day;
   CSHORT          hour, minute, second, milliseconds;

   ps = &s[0];

   #ifdef testing  
   s[250] = '\0';
   s[251] = 'K';
   s[252] = 'I';
   s[253] = 'L';
   s[254] = 'L';
   s[255] = '\0';
   #endif
   
      
   n = agFmtFill (s, (os_bit32) 255,
                     formatString,
                     firstString, secondString, firstPtr, secondPtr,
                     firstBit32, secondBit32, thirdBit32, fourthBit32,
                     fifthBit32, sixthBit32, seventhBit32, eighthBit32);

   if (n > 255) 
   {
      osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
      n=255;  
   }

   #ifdef TESTING
   if (( s[250] != '\0' ) || 
       ( s[251] != 'K'  ) ||
       ( s[252] != 'I'  ) ||
       ( s[253] != 'L'  ) ||
       ( s[254] != 'L'  ) ||
       ( s[255] != '\0' ) )
   {
      osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: agFmtFill modify end of line signature\n"));
      #ifdef _DEBUG_EVENTLOG_
      LogEvent(   NULL, 
                  NULL,
                  HPFC_MSG_INTERNAL_ERROR,
                  NULL, 
                  0, 
                  "%s",
                  "agFmtFill overrun");
      #endif
   }
   #endif 
      
       
   s[n] = '\0';

   GetSystemTime (&year, &month, &day, &hour, &minute, &second, &milliseconds);

   if (detailLevel <= hpFcConsoleLevel)
   {
      osDEBUGPRINT(((ALWAYS_PRINT),"%02d:%02d:%02d:%03d[%10d]%s\n",
            hour, minute, second, milliseconds, osTimeStamp(0), ps));
   }

   if (hpRoot == NULL || hpRoot->osData == NULL)
        return;

   pCard = (PCARD_EXTENSION)hpRoot->osData;

   if ((detailLevel <= hpFcTraceLevel) && (n > 0)) 
   {
      char    s1[256];

      n = agFmtFill (s1, (os_bit32) 255,
                        "%02d:%02d:%02d:%03d[%10d]%s\n",
                        s, NULL, 0, 0,
                        (os_bit32)hour, (os_bit32)minute, (os_bit32)second, (os_bit32)milliseconds,
                        osTimeStamp(0), 0, 0, 0);

      if (n > 255) 
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
         n=255;  
      }

      s[n] = '\0';

#if DBG_TRACE
      trBufEnd = &pCard->traceBuffer[0] + pCard->traceBufferLen;
      srcPtr = &s1[0];
      while (n--) 
      {
         *pCard->curTraceBufferPtr = *srcPtr;
         srcPtr++;
         pCard->curTraceBufferPtr++;
         if (pCard->curTraceBufferPtr >= trBufEnd)
            pCard->curTraceBufferPtr = &pCard->traceBuffer[0];
      }
      *pCard->curTraceBufferPtr = '\0';
#endif
   }

#endif // DBG
}
#endif /* osLogDebugString was defined */


#else /* _DvrArch_1_20_ was not defined */

//
// osLogDebugString ()
//
// Generates a formatted string and logs the formatted string to
// either debug window or trace buffer or both depending on the
// input parameters "consoleLevel" and "traceLevel".
// If the input parameter "consoleLevel" is less than or equal to
// the global parameter hpFcConsoleLevel then the formatted string is
// logged to the debug window.
// If the input parameter "traceLevel" is less than or equal to
// the global parameter hpFcTraceLevel then the formatted string is
// logged to the trace buffer.
//
#ifndef osLogDebugString
osGLOBAL void
osLogDebugString (
   hpRoot_t *hpRoot,
   bit32  consoleLevel,
   bit32  traceLevel,
   char     *formatString,
   char     *firstString,
   char     *secondString,
   bit32  firstBit32,
   bit32  secondBit32,
   bit32  thirdBit32,
   bit32  fourthBit32,
   bit32  fifthBit32,
   bit32  sixthBit32,
   bit32  seventhBit32,
   bit32  eighthBit32 )
{
#if DBG
   PCARD_EXTENSION pCard;
   char            *trBufEnd, *srcPtr;
   char            s[256];
   bit32         n=0;
   char            *ps;
   CSHORT          year, month, day;
   CSHORT          hour, minute, second, milliseconds;

   ps = &s[0];

   n = hpFmtFill (s, (os_bit32) 255,
                     formatString,
                     firstString, secondString,
                     firstBit32, secondBit32, thirdBit32, fourthBit32,
                     fifthBit32, sixthBit32, seventhBit32, eighthBit32);

   if (n > 255) 
   {
      osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
   }
   s[n] = '\0';

   GetSystemTime (&year, &month, &day, &hour, &minute, &second, &milliseconds);

   if (consoleLevel <= hpFcConsoleLevel)
   {
      osDEBUGPRINT(((ALWAYS_PRINT),"%02d:%02d:%02d:%03d[%10d]%s\n",
            hour, minute, second, milliseconds, osTimeStamp(0), ps));
   }

   if (hpRoot == NULL || hpRoot->osData == NULL)
        return;

   pCard = (PCARD_EXTENSION)hpRoot->osData;

   if ((traceLevel <= hpFcTraceLevel) && (n > 0)) 
   {
      char    s1[256];

      n = hpFmtFill (s1, (os_bit32) 255,
                        "%02d:%02d:%02d:%03d[%10d]%s\n",
                        s, NULL,
                        (os_bit32)hour, (os_bit32)minute, (os_bit32)second, (os_bit32)milliseconds,
                        osTimeStamp(0), 0, 0, 0);

      if (n > 255) 
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
      }

      s[n] = '\0';

#if DBG_TRACE
      trBufEnd = &pCard->traceBuffer[0] + pCard->traceBufferLen;
      srcPtr = &s1[0];
      while (n--) 
      {
         *pCard->curTraceBufferPtr = *srcPtr;
         srcPtr++;
         pCard->curTraceBufferPtr++;
         if (pCard->curTraceBufferPtr >= trBufEnd)
            pCard->curTraceBufferPtr = &pCard->traceBuffer[0];
      }
      *pCard->curTraceBufferPtr = '\0';
#endif
   }

#endif // DBG
}
#endif /* osLogDebugString was defined */

#endif   /* _DvrArch_1_20_ was not defined */



#ifdef _DvrArch_1_20_

void osLogString(
   agRoot_t *hpRoot,
   char     *formatString,
   char     *firstString,
   char     *secondString,
   void     *firstPtr,
   void     *secondPtr,
   os_bit32  firstBit32,
   os_bit32  secondBit32,
   os_bit32  thirdBit32,
   os_bit32  fourthBit32,
   os_bit32  fifthBit32,
   os_bit32  sixthBit32,
   os_bit32  seventhBit32,
   os_bit32  eighthBit32
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;

//   osDEBUGPRINT((ALWAYS_PRINT,"osLogString enter\n"));

   #ifdef LP012800_OLDSTUFF
   ScsiPortLogError( pCard,
                        NULL,
                        0,
                        0,
                        0,
                        fifthBit32,
                        sixthBit32 );
   #endif
                  
   #ifdef _DEBUG_EVENTLOG_
   {
      char            s[256];
      os_bit32           n=0;
      
      if ( LogLevel == LOG_LEVEL_NONE ) 
      {
//       osDEBUGPRINT((ALWAYS_PRINT,"osLogString exit\n"));
         return;
      }
      
      #ifdef TESTING
      s[250] = '\0';
      s[251] = 'K';
      s[252] = 'I';
      s[253] = 'L';
      s[254] = 'L';
      s[255] = '\0';
      #endif
      
      n = agFmtFill (s, (os_bit32) 255,
                         formatString,
                         firstString, secondString, firstPtr, secondPtr,
                         firstBit32, secondBit32, thirdBit32, fourthBit32,
                         fifthBit32, sixthBit32, seventhBit32, eighthBit32);
      if (n > 255) 
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogString: hpFmtFill returned value > target string length"));
         n=255;  
      }
      
          
      s[n] = '\0';
       
      #ifdef TESTING
      if (( s[250] != '\0' ) || 
          ( s[251] != 'K'  ) ||
          ( s[252] != 'I'  ) ||
          ( s[253] != 'L'  ) ||
          ( s[254] != 'L'  ) ||
          ( s[255] != '\0' ) )
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogString: agFmtFill modify end of line signature\n"));
         LogEvent(   NULL, 
                     NULL,
                     HPFC_MSG_INTERNAL_ERROR,
                     NULL, 
                     0, 
                     "%s",
                     "agFmtFill overrun");
//        osDEBUGPRINT((ALWAYS_PRINT,"osLogString enter\n"));
         return;     
      }
      #endif
      
      LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L4, NULL, 0, "%s", s);
   }
   #endif      
//    osDEBUGPRINT((ALWAYS_PRINT,"osLogString exit\n"));
   return;     

}


#else /* _DvrArch_1_20_ was not defined */

void osLogString(
   hpRoot_t *hpRoot,
   char     *formatString,
   char     *firstString,
   char     *secondString,
   bit32  firstBit32,
   bit32  secondBit32,
   bit32  thirdBit32,
   bit32  fourthBit32,
   bit32  fifthBit32,
   bit32  sixthBit32,
   bit32  seventhBit32,
   bit32  eighthBit32
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;

//   osDEBUGPRINT((ALWAYS_PRINT,"osLogString enter\n"));

   #ifdef OLDSTUFF
   ScsiPortLogError( pCard,
                       NULL,
                       0,
                       0,
                       0,
                       fifthBit32,
                       sixthBit32 );
   #endif
                  
   #ifdef _DEBUG_EVENTLOG_
   {
      char            s[256];
      bit32           n=0;
      
      n = hpFmtFill (s, (os_bit32) 255,
                         formatString,
                         firstString, secondString,
                         firstBit32, secondBit32, thirdBit32, fourthBit32,
                         fifthBit32, sixthBit32, seventhBit32, eighthBit32);
      if (n > 255)    
      {
         osDEBUGPRINT((ALWAYS_PRINT,"osLogDebugString: hpFmtFill returned value > target string length"));
         n=255;  
      }     
      
      s[n] = '\0';
       
      LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L4, NULL, 0, "%s", s);
   }
   #endif      

//    osDEBUGPRINT((ALWAYS_PRINT,"osLogString exit\n"));
}

#endif   /* _DvrArch_1_20_ was not defined */

#if defined(_DEBUG_STALL_ISSUE_) && defined(i386)
os_bit32    osStallThreadBrk=0;
ULONG       curAddress=0;
long        curCount=0;
long        curMs=0;
#define     DEBUG_STALL_COUNT  100000

osGLOBAL void osStallThread(
   agRoot_t *hpRoot,
   os_bit32 microseconds
   )
{   
    ULONG            address;
    PCARD_EXTENSION pCard;
    ULONG           x;
    __asm
    {
        ;
        ; c call already push the ebp
        ;   push    ebp
        ;   mov     ebp,esp
        mov     eax, dword ptr [ebp+4]        ; Get returned address
        mov     address, eax
    }
    /* record stall per ISR */
    pCard = (PCARD_EXTENSION)hpRoot->osData;
    for (x=0;x< STALL_COUNT_MAX;x++)
    {
        if ( pCard->StallData[x].Address == address)
        {
            pCard->StallData[x].MicroSec += microseconds;
            break;
        }
    }
    
    
    if (x == STALL_COUNT_MAX)
    {
        for (x=0;x< STALL_COUNT_MAX;x++)
        {
            if ( ! pCard->StallData[x].Address)
            {
                pCard->StallData[x].MicroSec += microseconds;
                pCard->StallData[x].Address = address;
                break;
            }
        }
    }

    pCard->StallCount += microseconds;

    if (curAddress == address)
    {
        curCount+=microseconds;
        curMs+=microseconds;
    }
    else
    {
        curCount= 0;
        curMs = 0;
    }
    curAddress = address;

    if (osStallThreadBrk || (curCount > DEBUG_STALL_COUNT) )
    {
        curCount = curCount % DEBUG_STALL_COUNT;
        osDEBUGPRINT((ALWAYS_PRINT,"osStallThread in address=%x  %d ms\n",address, curMs));
    }
    
    ScsiPortStallExecution(microseconds);
}
#else
osGLOBAL void osStallThread(
   agRoot_t *hpRoot,
   os_bit32 microseconds
   )
{
   //PCARD_EXTENSION pCard;
   //pCard = (PCARD_EXTENSION)hpRoot->osData;
   // osDEBUGPRINT((DLOW,"IN osStallThread %x\n",microseconds));
   ScsiPortStallExecution(microseconds);
}
#endif

// Copy (destin, source, size) in reverse order
void osCopyAndSwap(void * destin, void * source, UCHAR length )
{
   PULONG out= (PULONG)destin;
   PULONG in= (PULONG)source;
   ULONG invalue;
   UCHAR x;
   // osDEBUGPRINT((DVHIGH,"IN osCopyAndSwap %lx %lx %x\n", destin, source,length ));
   // osDEBUGPRINT((DVHIGH,"IN source  %02x %02x %02x %02x %02x\n",((PUCHAR)source)+0,
   //                                                      ((PUCHAR)source)+1,
   //                                                      ((PUCHAR)source)+2,
   //                                                      ((PUCHAR)source)+4,
   //                                                      ((PUCHAR)source)+5 ));
   if(length >= 4) length /= 4;
   for(x=0; x< length; x++)
   {
      invalue = *(in+ x);
      *(out + x) = SWAPDWORD(invalue);
   }

}

void osCopy(void * destin, void * source, os_bit32 length )
{
   ScsiPortMoveMemory( destin, source, length );
}

void osZero(void * destin, os_bit32 length )
{
   memset( destin, 0,length );
}

void osFill(void * destin, os_bit32 length, os_bit8 fill )
{
   PUCHAR out= (PUCHAR)destin;

   // osDEBUGPRINT((DVHIGH,"osZero out %lx in %lx length %x\n", destin, length  ));

   memset( destin, fill,length );

   // PERF  for(x=0; x < length; x++){
   // osDEBUGPRINT((DVHIGH,"osCopy out %lx in %lx %x\n", (out + x)));
   // PERF *(out + x) = fill;
   // PERF}
}

//
// osStringCompare ()
//
// Compares the strings str1 and str2.
// Returns:
//     TRUE    If str1 is equal to str2
//     FALSE   If str1 is not equal to str2
//
BOOLEAN
osStringCompare (
   char *str1,
   char *str2)
{
   while (*str1 !=  '\0' && *str2 != '\0' ) 
   {
      if (*str1 == *str2) 
      {
         str1++;
         str2++;
      } 
      else
         break;
   }

   if (*str1 == *str2)
      return TRUE;
   else
      return FALSE;
}

//
// osMemCompare ()
//
// Compares the strings "str1" and "str2" for "count" number of bytes.
// Returns:
//     TRUE    If str1 is equal to str2
//     FALSE   If str1 is not equal to str2
//
BOOLEAN
osMemCompare (char *str1, char *str2, int count)
{
   while (count--) 
   {
      if (*str1 != *str2)
         return FALSE;
      str1++;
      str2++;
   }

   return TRUE;
}

//
// osStringCopy ()
//
// Parameters:
//     destStr    Pointer to destination string
//     sourceStr  Pointer to source string
//     destStrLen Maximum number of bytes to be copied
//
// Copies bytes from the sourceStr to destStr.
//
void
osStringCopy (
   char *destStr,
   char *sourceStr,
   int  destStrLen)
{
   while (destStrLen--) 
   {
      *destStr = *sourceStr;
      if (*sourceStr == '\0')
         break;
      destStr++;
      sourceStr++;
   }
}

os_bit8
osChipConfigReadBit8 (agRoot_t *hpRoot, os_bit32 cardConfigOffset)
{
   PCARD_EXTENSION pCard = (PCARD_EXTENSION)hpRoot->osData;

   return *(((os_bit8 *)pCard->pciConfigData) + cardConfigOffset);
}

os_bit16
osChipConfigReadBit16 (agRoot_t *hpRoot, os_bit32 cardConfigOffset)
{
   PCARD_EXTENSION pCard = (PCARD_EXTENSION)hpRoot->osData;

   return *((os_bit16 *)(((os_bit8 *)pCard->pciConfigData) + cardConfigOffset));
}

os_bit32
osChipConfigReadBit32 (agRoot_t *hpRoot, os_bit32 cardConfigOffset)
{
   PCARD_EXTENSION pCard = (PCARD_EXTENSION)hpRoot->osData;

   return *((PULONG)(((os_bit8 *)pCard->pciConfigData) + cardConfigOffset));
}

void
osChipConfigWriteBit( agRoot_t *hpRoot, os_bit32 cardConfigOffset,os_bit32 chipIOLValue, os_bit32 valuesize)
{
   os_bit32 length;
    PCARD_EXTENSION pCard;

   pCard = (PCARD_EXTENSION)hpRoot->osData;

   osDEBUGPRINT((ALWAYS_PRINT,"osChipConfigWriteBit %lx %x %x\n", hpRoot, cardConfigOffset, chipIOLValue ));

   length = ScsiPortSetBusDataByOffset(pCard,
                               PCIConfiguration,
                               pCard->SystemIoBusNumber,
                               pCard->SlotNumber,
                               &chipIOLValue,
                               cardConfigOffset,
                               (valuesize/8));

   return;
}

osGLOBAL void osResetDeviceCallback(
   agRoot_t  *hpRoot,
   agFCDev_t  hpFCDev,
   os_bit32   hpResetStatus
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;

   osDEBUGPRINT((DLOW,"osResetDeviceCallback %lx Dev %lx\n", hpRoot, hpFCDev ));

}

#if DBG >= 1
osGLOBAL void osSingleThreadedEnter(
   agRoot_t *hpRoot
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;
   pCard->SingleThreadCount++;
   // osDEBUGPRINT((DLOW,"osSingleThreadedEnter %lx\n", hpRoot));

}

osGLOBAL void osSingleThreadedLeave(
   agRoot_t *hpRoot
   )
{
   PCARD_EXTENSION pCard;
   pCard = (PCARD_EXTENSION)hpRoot->osData;
   pCard->SingleThreadCount--;
   // osDEBUGPRINT((DLOW,"osSingleThreadedLeave %lx\n", hpRoot));
}

#endif

void osFCLayerAsyncError( 
   agRoot_t *hpRoot,
   os_bit32  fcLayerError
   )
{
    PCARD_EXTENSION pCard;
    pCard = (PCARD_EXTENSION)hpRoot->osData;
    osDEBUGPRINT((ALWAYS_PRINT,"osFCLayerAsyncError %lx error\n", hpRoot,fcLayerError));
   
    if (fcLayerError == osFCConfused)
    {
        #ifdef _DEBUG_DETECT_P_ERR
        //WIN64 compliant
        if (gDebugPerr)
        {
        osBugCheck (0xe0000000, fcLayerError, 0, __LINE__, (pCard->SystemIoBusNumber << 16) | pCard->SlotNumber);
        }
        #endif
    }
}

void osFakeInterrupt( agRoot_t *hpRoot )
{
    PCARD_EXTENSION pCard = (PCARD_EXTENSION) hpRoot->osData;
    osDEBUGPRINT((DLOW,"IN osFakeInterrupt %lx @ %x\n", hpRoot, osTimeStamp(0)));

    HPFibreInterrupt( pCard );

    osDEBUGPRINT((DLOW,"OUT osFakeInterrupt %lx @ %x\n", hpRoot, osTimeStamp(0)));

}

#ifndef osTimeStamp

unsigned long get_time_stamp(void);

os_bit32
osTimeStamp (agRoot_t *hpRoot)
{
   return get_time_stamp ();
}

//
// Returns the number of units since the first time get_time_stamp called.
// Each unit is 1.6384 ms.
//

#endif

#ifdef _DEBUG_PERF_DATA_
void dump_perf_data( PCARD_EXTENSION pCard )
{
    int x;

    osDEBUGPRINT((ALWAYS_PRINT,"Dump Performance data start time %08x End time %08x\n",
    pCard->PerfStartTimed,osTimeStamp(0) ));

    for(x=0; x < LOGGED_IO_MAX-1; x++)
        osDEBUGPRINT((ALWAYS_PRINT,"%08x %08x %08x %08x %08x %08x %08x %08x %08x\n",
                   pCard->perf_data[x].inOsStartio,
                   pCard->perf_data[x].inFcStartio,
                   pCard->perf_data[x].outFcStartio,
                   pCard->perf_data[x].outOsStartio,
                   pCard->perf_data[x].inOsIsr,
                   pCard->perf_data[x].inFcDIsr,
                   pCard->perf_data[x].inOsIOC,
                   pCard->perf_data[x].outOsIOC,
                   pCard->perf_data[x].outOsIsr ));
}
#endif
os_bit8  SPReadRegisterUchar( void * x)
{
   os_bit8 tmp;
   tmp = ScsiPortReadRegisterUchar(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadRegisterUchar  %lx %02x\n",x,tmp));
   return( tmp );
}

os_bit16 SPReadRegisterUshort(void * x)
{
   os_bit16 tmp;
   tmp = ScsiPortReadRegisterUshort(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadRegisterUshort %lx %04x\n",x,tmp));
   return( tmp );
}

os_bit32 SPReadRegisterUlong( void * x)
{
   os_bit32 tmp;
   tmp = ScsiPortReadRegisterUlong(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadRegisterUlong %lx %08x\n",x,tmp));
   return( tmp );
}

void SPWriteRegisterUchar(void * x, os_bit8  y)  
{
   ScsiPortWriteRegisterUchar(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WriteRegisterUchar  %lx val %02x\n",x,y));
//   if(x == (void *)0xf888) Debug_Break_Point;
}

void SPWriteRegisterUshort(void * x, os_bit16 y)
{
   ScsiPortWriteRegisterUshort(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WriteRegisterUshort %lx val %04x\n",x,y));
//    if(x == (void *)0xf888) Debug_Break_Point;
}

void SPWriteRegisterUlong(void * x, os_bit32 y)
{
   ScsiPortWriteRegisterUlong(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WriteRegisterUlong  %lx val %08x\n",x,y));
//    if(x == (void *)0xf888) Debug_Break_Point;
}

os_bit8  SPReadPortUchar( void * x)
{
   os_bit8 tmp;
   tmp = ScsiPortReadPortUchar(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadPortUchar  %lx %02x\n",x,tmp));
   return( tmp );
}

os_bit16 SPReadPortUshort(void * x)
{
   os_bit16 tmp;
   tmp =  ScsiPortReadPortUshort(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadPortUshort  %lx %04x\n",x,tmp));
   return( tmp );
}
os_bit32 SPReadPortUlong( void * x)
{
   os_bit32 tmp;
   tmp = ScsiPortReadPortUlong(x);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"ReadPortUlong   %lx %08x\n",x,tmp));
   return( tmp );
}

void SPWritePortUchar(void * x, os_bit8  y)  
{
   ScsiPortWritePortUchar(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WritePortUchar  %lx val %02x\n",x,y));
}

void SPWritePortUshort(void * x, os_bit16 y) 
{
   ScsiPortWritePortUshort(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WritePortUshort %lx val %04x\n",x,y));
}

void SPWritePortUlong(void * x, os_bit32 y)  
{
   ScsiPortWritePortUlong(x,y);
   osDEBUGPRINT((CS_DUR_ANY_MOD,"WritePortUlong  %lx val %08x\n",x,y));
}

//
//Moved from OSCALL.C
//
//WIN64 compliant

#ifndef osDebugBreakpoint

void 
osDebugBreakpoint (agRoot_t *hpRoot, agBOOLEAN BreakIfTrue, char *DisplayIfTrue)
{
   if (BreakIfTrue) 
   {
      osDEBUGPRINT((ALWAYS_PRINT,"%s\n", DisplayIfTrue));
      //DbgBreakPoint ();

   }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\pktstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/PktState.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 8/14/00 6:50p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/PktState.C

--*/

#ifndef __PktState_H__
#define __PktState_H__

#define PktStateConfused                 0
#define PktStateFree                     1
#define PktStateAllocSFThread            2
#define PktStateDoFarp                   3
#define PktStateLogin                    4
#define PktStateReady                    5
#define PktStateDoIPData                 6

#define PktStateMAXState                 PktStateDoIPData

#define PktEventConfused                 0
#define PktEventGotSFThread              1
#define PktEventFarpSuccess              2
#define PktEventLoginSuccess             3
#define PktEventDoIPData                 4

#define PktEventMAXEvent                 PktEventDoIPData

STATE_PROTO(PktActionConfused);
STATE_PROTO(PktActionFree);
STATE_PROTO(PktActionAllocSFThread);
STATE_PROTO(PktActionDoFarp);
STATE_PROTO(PktActionLogin);
STATE_PROTO(PktActionReady);
STATE_PROTO(PktActionDoIPData);

stateTransitionMatrix_t PktStateTransitionMatrix;
stateActionScalar_t PktStateActionScalar;
#ifdef _DvrArch_1_30_
void PktFuncIRB_OffCardInit(PktThread_t  * PktThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit);
#endif /* _DvrArch_1_30_ was defined */

#endif /*  __PktState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\pktstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/PktState.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 9/19/00 12:05p  $

Purpose:

  This file implements the FC Layer State Machine for each IP Packet Thread.
  Each thread is responsible for managing a single IP Packet Send.

--*/
#ifdef _DvrArch_1_30_

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"
#include "../h/fcstruct.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"

#include "../h/ipstate.h"
#include "../h/pktstate.h"
#include "../h/sfstate.h"
#include "../h/queue.h"
#include "../h/timersvc.h"
#include "../h/ip.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "fcstruct.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"

#include "cstate.h"
#include "cfunc.h"

#include "ipstate.h"
#include "pktstate.h"
#include "sfstate.h"
#include "queue.h"
#include "timersvc.h"
#include "ip.h"
#endif  /* _New_Header_file_Layout_ */

stateTransitionMatrix_t PktStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...              */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1 PktEventGotSFThread                                  */
    0,0,PktStateDoFarp,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2 PktEventFarpSuccess                                  */
    0,0,0,PktStateLogin,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 3 PktEventLoginSuccess                                 */
    0,0,0,0,PktStateReady, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 4 PktEventDoIPData                                    */
    0,PktStateAllocSFThread,0,0,0, PktStateDoIPData,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 5                                                     */
    0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6                                                     */
    0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7                                                     */
    0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8                                                     */
    0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 10                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 20                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 30                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    };

stateTransitionMatrix_t copiedPktStateTransitionMatrix;

stateActionScalar_t PktStateActionScalar = {
    &PktActionConfused,
    &PktActionFree,
    &PktActionAllocSFThread,
    &PktActionDoFarp,
    &PktActionLogin,
    &PktActionReady,
    &PktActionDoIPData,
    &PktActionConfused
    };

stateActionScalar_t copiedPktStateActionScalar;

#ifdef USESTATEMACROS

PktSTATE_FUNCTION_TERMINATE(PktActionConfused);

#endif /* USESTATEMACROS */

#define testPktCompareBase 0x00000110


/* PktStateConfused 0  */
extern void PktActionConfused( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiLogString(thread->hpRoot,
                    "PktActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    PktStateLogErrorLevel,
                    "In %s - State = %d",
                    "PktActionConfused",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

extern void PktActionFree( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiLogDebugString(thread->hpRoot,
                    PktStateLogErrorLevel,
                    "In %s - State = %d",
                    "PktActionFree",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

extern void PktActionAllocSFThread( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    PktThread_t     * pPktThread = ( PktThread_t  * )thread;
    SFThread_t      * pSFThread  = pPktThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount ++;

    pPktThread->SFThread_Request.eventRecord_to_send.event = PktEventGotSFThread;
    pPktThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiLogDebugString(thread->hpRoot,
                    PktStateLogConsoleLevel,
                    "In %s - State = %d SF Request State %x",
                    "PktActionAllocSFThread",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pPktThread->SFThread_Request.State,
                    0,0,0,0,0,0);

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList( &(pSFThread->SFLink),
                                  &(CThread_ptr(thread->hpRoot)->Free_SFLink) ) )
	{
            SFThreadFree( thread->hpRoot, &pPktThread->SFThread_Request );
        }
    }

    if( pPktThread->SFThread_Request.State )
    {
            fiLogDebugString(thread->hpRoot,
                        PktStateLogErrorLevel,
                        "In %s - State = %d   ALPA %X  FDCnt %x SFThread req state  %08X Wrong !",
                        "PktActionAllocSFThread",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pPktThread->Device->DevInfo.CurrentAddress.AL_PA,
                        CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                        pPktThread->SFThread_Request.State,
                        0,0,0,0);
    }
    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, & pPktThread->SFThread_Request );
}

/* PktStateDoFarp                       3    */
extern void PktActionDoFarp( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    PktThread_t  * pPktThread = ( PktThread_t  * )thread;
    SFThread_t   * pSFThread  = pPktThread->SFThread_Request.SFThread;

    pSFThread->parent.IPPkt = pPktThread;

    fiLogDebugString(thread->hpRoot,
                    PktStateLogConsoleLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "PktActionDoFarp",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pPktThread->Device->DevInfo.CurrentAddress.AL_PA,
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

    /* Send event to SFthread */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFarpRequest);
}

/* PktStateLogin                       3    */
extern void PktActionLogin( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    /* currently not implemented */
    fiLogDebugString(thread->hpRoot,
                    PktStateLogErrorLevel,
                    "In %s - State = %d",
                    "PktActionLogin",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

extern void PktActionReady( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiSetEventRecord(eventRecord,thread,PktEventDoIPData);
}

extern void PktActionDoIPData( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    PktThread_t *   pPktThread  = (PktThread_t * )thread;
    DevThread_t *   pDevThread  = pPktThread->Device;
    os_bit32 SFS_Len            = 0;

    fiLogDebugString(hpRoot ,
                    PktStateLogConsoleLevel,
                    "In %s - State = %d DCnt %x",
                    "PktActionDoIPData",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pDevThread->pollingCount,0,0,0,0,0,0);

    /* pCThread->PktpollingCount++; */
    pDevThread->pollingCount++;

    pPktThread->status = FC_CMND_STATUS_TIMEDOUT;

    if( CFuncAll_clear( hpRoot ) )
    {
        WaitForERQ( hpRoot );

        SFS_Len = fiFillInIPData( pPktThread );

        pCThread->FuncPtrs.Pkt_IRB_Init(pPktThread, SFS_Len, fiComputeDevThread_D_ID(pDevThread), 0);

        pPktThread->Timer_Request.eventRecord_to_send.thread = (fi_thread__t *) pCThread->IP;
        pPktThread->Timer_Request.eventRecord_to_send.event = IPEventOutgoingComplete;

        fiTimerSetDeadlineFromNow( hpRoot, &pPktThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot, &pPktThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncIPCmnd);

        fiSetEventRecordNull(eventRecord);
    }
    else
    {
        fiLogDebugString(hpRoot,
                   PktStateLogErrorLevel,
                   "IPData CFunc_Queues_Frozen  Wrong LD %x IR %x",
                   (char *)agNULL,(char *)agNULL,
                   (void *)agNULL,(void *)agNULL,
                   pCThread->LOOP_DOWN,
                   pCThread->IDLE_RECEIVED,
                   0,0, 0,0,0,0);

        fiSetEventRecord(eventRecord,(fi_thread__t *)pCThread->IP,IPEventOutgoingComplete);
    }
}

void PktFuncIRB_OffCardInit(PktThread_t  * PktThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit)
{
#ifndef __MemMap_Force_On_Card__

    CThread_t                  *CThread = CThread_ptr(PktThread->thread_hdr.hpRoot);
    fiMemMapMemoryDescriptor_t *ERQ     = &(CThread->Calculation.MemoryLayout.ERQ);
    IRB_t                      *pIrb;

    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
    pIrb += CThread->HostCopy_ERQProdIndex;

    pIrb->Req_A.Bits__SFS_Len   = SFS_Len | IRB_SFA | DCM_Bit |
            ((D_ID & 0xff) == 0xff ? IRB_BRD : 0);
    pIrb->Req_A.SFS_Addr        = PktThread->Pkt_CMND_Lower32;
    pIrb->Req_A.D_ID            = D_ID << IRB_D_ID_SHIFT;
    pIrb->Req_A.MBZ__SEST_Index__Trans_ID = PktThread->Device->IP_X_ID;
    pIrb->Req_B.Bits__SFS_Len = 0;

#endif /* __MemMap_Force_On_Card__ was not defined */
}

#endif /* _DvrArch_1_30_ was defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\ostypes.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/OSTypes.H $

   $Revision: 3 $
   $Date: 9/07/00 11:19a $ (Last Check-In)
   $Modtime:: 8/31/00 3:25p   $ (Last Modified)

Purpose:

  This is the NT-specific OS Layer Types Include File.

  This file should be included by every module to ensure a uniform definition
  of all basic data types.  The NT-specific Layer must provide definitions for:

    os_bit8    - unsigned 8-bit value
    os_bit16   - unsigned 16-bit value
    os_bit32   - unsigned 32-bit value
    osGLOBAL   - used to declare a 'C' function external to a module
    osLOCAL    - used to declare a 'C' function local to a module

--*/

#ifndef __NT_OSTypes_H__

#define __NT_OSTypes_H__

//#ifndef _DvrArch_1_20_
//#define _DvrArch_1_20_
//#endif /* _DvrArch_1_20_ was not defined */


typedef unsigned char  os_bit8;
typedef unsigned short os_bit16;
typedef unsigned int   os_bit32;

#define osGLOBAL         extern
#define osLOCAL


#ifndef _DvrArch_1_20_

#define agBOOLEAN BOOLEAN
#define agTRUE         TRUE
#define agFALSE        FALSE
#define agNULL         NULL

#define bit8 os_bit8
#define bit16     os_bit16
#define bit32     os_bit32

#define GLOBAL    osGLOBAL
#define LOCAL     osLOCAL

#define agFCChanInfo_s      hpFCChanInfo_s
#define agFCChanInfo_t      hpFCChanInfo_t

#define agFCDev_t           hpFCDev_t

#define agDevUnknown        hpDevUnknown
#define agDevSelf           hpDevSelf
#define agDevSCSIInitiator  hpDevSCSIInitiator
#define agDevSCSITarget          hpDevSCSITarget

#define agFCDevInfo_s       hpFCDevInfo_s
#define agFCDevInfo_t       hpFCDevInfo_t

#define agFcpCntlReadData   hpFcpCntlReadData
#define agFcpCntlWriteData  hpFcpCntlWriteData

#define agFcpCmnd_s              hpFcpCmnd_s
#define agFcpCmnd_t              hpFcpCmnd_t

#define agCDBRequest_s      hpCDBRequest_s
#define agCDBRequest_t      hpCDBRequest_t

#define agFcpRspHdr_s       hpFcpRspHdr_s
#define agFcpRspHdr_t       hpFcpRspHdr_t

#define agIORequest_s       hpIORequest_s
#define agIORequest_t       hpIORequest_t

#define agIORequestBody_u   hpIORequestBody_u
#define agIORequestBody_t   hpIORequestBody_t

#define agRoot_s            hpRoot_s
#define agRoot_t            hpRoot_t



#endif  // #ifndef _DvrArch_1_20_


#include     <miniport.h>

#if defined(HP_NT50)
#define os_bitptr UINT_PTR
#else
#define os_bitptr ULONG
#endif


#endif  /* ~__NT_OSTypes_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\queue.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/Queue.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 9/18/00 11:32a  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/Queue.C

--*/

#ifndef __Queue_H__
#define __Queue_H__

/*+
Paranoia Setting
-*/

#ifndef __Queue_Paranoia__
#define __Queue_Paranoia__
#endif
#undef  __Queue_Paranoia__

/*+
Queue Macros
-*/

#define fiListInitHdr(hdr)                                  \
          {                                                 \
            ((fiList_t *)(hdr))->flink = (fiList_t *)(hdr); \
            ((fiList_t *)(hdr))->blink = (fiList_t *)(hdr); \
          }

#ifdef __Queue_Paranoia__
#define fiListInitElementFlinkBlinkSentinel (fiList_t *)0x0BAD0BAD

#define fiListInitElement(hdr)                                                \
          {                                                                   \
            ((fiList_t *)(hdr))->flink = fiListInitElementFlinkBlinkSentinel; \
            ((fiList_t *)(hdr))->blink = fiListInitElementFlinkBlinkSentinel; \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListInitElement(hdr)                             \
          {                                                \
            ((fiList_t *)(hdr))->flink = (fiList_t *)agNULL; \
            ((fiList_t *)(hdr))->blink = (fiList_t *)agNULL; \
          }
#endif /* __Queue_Paranoia__ was not defined */

#ifdef __Queue_Paranoia__
#define fiListEnqueueAtHead(toAddHdr,listHdr)                                                                                  \
          {                                                                                                                    \
            osDebugBreakpoint(                                                                                                 \
                               (agRoot_t *)agNULL,                                                                               \
                               ((((fiList_t *)(toAddHdr))->flink != fiListInitElementFlinkBlinkSentinel) ? agTRUE : agFALSE),      \
                               "fiListEnqueueAtHead(): ((fiList_t *)(toAddHdr))->flink != fiListInitElementFlinkBlinkSentinel" \
                             );                                                                                                \
            osDebugBreakpoint(                                                                                                 \
                               (agRoot_t *)agNULL,                                                                               \
                               ((((fiList_t *)(toAddHdr))->blink != fiListInitElementFlinkBlinkSentinel) ? agTRUE : agFALSE),      \
                               "fiListEnqueueAtHead(): ((fiList_t *)(toAddHdr))->blink != fiListInitElementFlinkBlinkSentinel" \
                             );                                                                                                \
            ((fiList_t *)(toAddHdr))->flink       = ((fiList_t *)(listHdr))->flink;                                            \
            ((fiList_t *)(toAddHdr))->blink       =  (fiList_t *)(listHdr);                                                    \
            ((fiList_t *)(listHdr))->flink->blink =  (fiList_t *)(toAddHdr);                                                   \
            ((fiList_t *)(listHdr))->flink        =  (fiList_t *)(toAddHdr);                                                   \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListEnqueueAtHead(toAddHdr,listHdr)                                       \
          {                                                                         \
            ((fiList_t *)(toAddHdr))->flink       = ((fiList_t *)(listHdr))->flink; \
            ((fiList_t *)(toAddHdr))->blink       =  (fiList_t *)(listHdr);         \
            ((fiList_t *)(listHdr))->flink->blink =  (fiList_t *)(toAddHdr);        \
            ((fiList_t *)(listHdr))->flink        =  (fiList_t *)(toAddHdr);        \
          }
#endif /* __Queue_Paranoia__ was not defined */

#ifdef __Queue_Paranoia__
#define fiListEnqueueAtTail(toAddHdr,listHdr)                                                                                  \
          {                                                                                                                    \
            osDebugBreakpoint(                                                                                                 \
                               (agRoot_t *)agNULL,                                                                               \
                               ((((fiList_t *)(toAddHdr))->flink != fiListInitElementFlinkBlinkSentinel) ? agTRUE : agFALSE),      \
                               "fiListEnqueueAtTail(): ((fiList_t *)(toAddHdr))->flink != fiListInitElementFlinkBlinkSentinel" \
                             );                                                                                                \
            osDebugBreakpoint(                                                                                                 \
                               (agRoot_t *)agNULL,                                                                               \
                               ((((fiList_t *)(toAddHdr))->blink != fiListInitElementFlinkBlinkSentinel) ? agTRUE : agFALSE),      \
                               "fiListEnqueueAtTail(): ((fiList_t *)(toAddHdr))->blink != fiListInitElementFlinkBlinkSentinel" \
                             );                                                                                                \
            ((fiList_t *)(toAddHdr))->flink       =  (fiList_t *)(listHdr);                                                    \
            ((fiList_t *)(toAddHdr))->blink       = ((fiList_t *)(listHdr))->blink;                                            \
            ((fiList_t *)(listHdr))->blink->flink =  (fiList_t *)(toAddHdr);                                                   \
            ((fiList_t *)(listHdr))->blink        =  (fiList_t *)(toAddHdr);                                                   \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListEnqueueAtTail(toAddHdr,listHdr)                                       \
          {                                                                         \
            ((fiList_t *)(toAddHdr))->flink       =  (fiList_t *)(listHdr);         \
            ((fiList_t *)(toAddHdr))->blink       = ((fiList_t *)(listHdr))->blink; \
            ((fiList_t *)(listHdr))->blink->flink =  (fiList_t *)(toAddHdr);        \
            ((fiList_t *)(listHdr))->blink        =  (fiList_t *)(toAddHdr);        \
          }
#endif /* __Queue_Paranoia__ was not defined */

#define fiListEmpty(hdr) \
          (((fiList_t *)(hdr))->flink == ((fiList_t *)(hdr)))

#define fiListNotEmpty(hdr) \
          (((fiList_t *)(hdr))->flink != ((fiList_t *)(hdr)))

#define fiListEnqueueListAtHeadFast(toAddListHdr,listHdr)                                     \
          {                                                                                   \
            ((fiList_t *)(toAddListHdr))->blink->flink = ((fiList_t *)(listHdr))->flink;      \
            ((fiList_t *)(toAddListHdr))->flink->blink =  (fiList_t *)(listHdr);              \
            ((fiList_t *)(listHdr))->flink->blink      = ((fiList_t *)(toAddListHdr))->blink; \
            ((fiList_t *)(listHdr))->flink             = ((fiList_t *)(toAddListHdr))->flink; \
            fiListInitHdr(toAddListHdr);                                                      \
          }

#define fiListEnqueueListAtHead(toAddListHdr,listHdr)              \
          {                                                        \
            if (fiListNotEmpty(toAddListHdr))                      \
              {                                                    \
                fiListEnqueueListAtHeadFast(toAddListHdr,listHdr); \
              }                                                    \
          }

#define fiListEnqueueListAtTailFast(toAddListHdr,listHdr)                                     \
          {                                                                                   \
            ((fiList_t *)(toAddListHdr))->blink->flink =  (fiList_t *)(listHdr);              \
            ((fiList_t *)(toAddListHdr))->flink->blink = ((fiList_t *)(listHdr))->blink;      \
            ((fiList_t *)(listHdr))->blink->flink      = ((fiList_t *)(toAddListHdr))->flink; \
            ((fiList_t *)(listHdr))->blink             = ((fiList_t *)(toAddListHdr))->blink; \
            fiListInitHdr(toAddListHdr);                                                      \
          }

#define fiListEnqueueListAtTail(toAddListHdr,listHdr)              \
          {                                                        \
            if (fiListNotEmpty(toAddListHdr))                      \
              {                                                    \
                fiListEnqueueListAtTailFast(toAddListHdr,listHdr); \
              }                                                    \
          }

#ifdef __Queue_Paranoia__
#define fiListDequeueThis(hdr) \
          {                                                                 \
            ((fiList_t *)(hdr))->blink->flink = ((fiList_t *)(hdr))->flink; \
            ((fiList_t *)(hdr))->flink->blink = ((fiList_t *)(hdr))->blink; \
            fiListInitElement(hdr);                                         \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListDequeueThis(hdr) \
          {                                                                 \
            ((fiList_t *)(hdr))->blink->flink = ((fiList_t *)(hdr))->flink; \
            ((fiList_t *)(hdr))->flink->blink = ((fiList_t *)(hdr))->blink; \
          }
#endif /* __Queue_Paranoia__ was not defined */

#ifdef __Queue_Paranoia__
#define fiListDequeueFromHeadFast(atHeadHdr,listHdr)                                         \
          {                                                                                  \
              *((fiList_t **)atHeadHdr)                =   ((fiList_t *)listHdr)->flink;     \
             (*((fiList_t **)atHeadHdr))->flink->blink =    (fiList_t *)listHdr;             \
               ((fiList_t  *)listHdr)->flink           = (*((fiList_t **)atHeadHdr))->flink; \
            fiListInitElement(*atHeadHdr);                                                   \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListDequeueFromHeadFast(atHeadHdr,listHdr)                                         \
          {                                                                                  \
              *((fiList_t **)atHeadHdr)                =   ((fiList_t *)listHdr)->flink;     \
             (*((fiList_t **)atHeadHdr))->flink->blink =    (fiList_t *)listHdr;             \
               ((fiList_t  *)listHdr)->flink           = (*((fiList_t **)atHeadHdr))->flink; \
          }
#endif /* __Queue_Paranoia__ was not defined */

#define fiListDequeueFromHead(atHeadHdr,listHdr)              \
          {                                                   \
            if (fiListNotEmpty(listHdr))                      \
              {                                               \
                fiListDequeueFromHeadFast(atHeadHdr,listHdr); \
              }                                               \
            else                                              \
              {                                               \
                *((fiList_t **)atHeadHdr) = (fiList_t *)agNULL; \
              }                                               \
          }

#ifdef __Queue_Paranoia__
#define fiListDequeueFromTailFast(atTailHdr,listHdr)                                        \
          {                                                                                 \
             *((fiList_t **)atTailHdr)                =   ((fiList_t *)listHdr)->blink;     \
            (*((fiList_t **)atTailHdr))->blink->flink =    (fiList_t *)listHdr;             \
              ((fiList_t  *)listHdr)->blink           = (*((fiList_t **)atTailHdr))->blink; \
            fiListInitElement(*atTailHdr);                                                   \
          }
#else /* __Queue_Paranoia__ was not defined */
#define fiListDequeueFromTailFast(atTailHdr,listHdr)                                        \
          {                                                                                 \
             *((fiList_t **)atTailHdr)                =   ((fiList_t *)listHdr)->blink;     \
            (*((fiList_t **)atTailHdr))->blink->flink =    (fiList_t *)listHdr;             \
              ((fiList_t  *)listHdr)->blink           = (*((fiList_t **)atTailHdr))->blink; \
          }
#endif /* __Queue_Paranoia__ was not defined */

#define fiListDequeueFromTail(atTailHdr,listHdr)              \
          {                                                   \
            if (fiListNotEmpty(listHdr))                      \
              {                                               \
                fiListDequeueFromTailFast(atTailHdr,listHdr); \
              }                                               \
            else                                              \
              {                                               \
                *((fiList_t **)atTailHdr) = (fiList_t *)agNULL; \
              }                                               \
          }

/*+
Queue Functions
-*/

osGLOBAL agBOOLEAN fiListElementOnList(
                                    fiList_t *toFindHdr,
                                    fiList_t *listHdr
                                  );

osGLOBAL os_bit32 fiNumElementsOnList(
                                  fiList_t *listHdr
                                );

/*+
ERQ Management
-*/

#define ERQ_Polling_osStallThread_Parameter 20

osGLOBAL void WaitForERQ(
                        agRoot_t *hpRoot
                      );

osGLOBAL void WaitForERQ_ConsIndexOnCard(
                                        agRoot_t *hpRoot
                                      );

osGLOBAL void WaitForERQ_ConsIndexOffCard(
                                         agRoot_t *hpRoot
                                       );

osGLOBAL void WaitForERQEmpty(
                             agRoot_t *hpRoot
                           );

osGLOBAL void WaitForERQEmpty_ConsIndexOnCard(
                                             agRoot_t *hpRoot
                                           );

osGLOBAL void WaitForERQEmpty_ConsIndexOffCard(
                                              agRoot_t *hpRoot
                                            );

#ifdef _DvrArch_1_30_
/*+
PktThread Management
-*/

osGLOBAL void PktThreadsInitializeFreeList(
                                            agRoot_t *agRoot
                                          );

osGLOBAL PktThread_t *PktThreadAlloc(
                                      agRoot_t *agRoot,
                                      DevThread_t *pDevThread
                                    );

osGLOBAL void PktThreadFree(
                             agRoot_t    *agRoot,
                             PktThread_t *PktThread
                           );
#endif /* _DvrArch_1_30_ was defined */

/*+
TgtThread Management
-*/

osGLOBAL void TgtThreadsInitializeFreeList(
                                          agRoot_t *hpRoot
                                        );

osGLOBAL TgtThread_t *TgtThreadAlloc(
                                    agRoot_t *hpRoot
                                  );

osGLOBAL void TgtThreadFree(
                           agRoot_t    *hpRoot,
                           TgtThread_t *TgtThread
                         );

/*+
DevThread Management
-*/

osGLOBAL void DevThreadsInitializeFreeList(
                                          agRoot_t *hpRoot
                                        );

osGLOBAL DevThread_t *DevThreadAlloc(
                                    agRoot_t     *hpRoot,
                                    FC_Port_ID_t  Port_ID
                                  );

osGLOBAL void DevThreadFree(
                           agRoot_t    *hpRoot,
                           DevThread_t *DevThread
                         );

osGLOBAL agBOOLEAN DevThreadMatchWWN( FC_Port_Name_t *WWN_1, FC_Port_Name_t *WWN_2 );

osGLOBAL DevSlot_t DevThreadFindSlot(
                                    agRoot_t       *hpRoot,
                                    os_bit8            Domain_Address,
                                    os_bit8            Area_Address,
                                    os_bit8            Loop_Address,
                                    FC_Port_Name_t *FindWWN
                                  );

osGLOBAL void DevThreadFreeSlot(
                               agRoot_t  *hpRoot,
                               DevSlot_t  DevSlot
                             );

osGLOBAL void DevThreadInitializeSlots(
                                      agRoot_t *hpRoot
                                    );

/*+
CDBThread Management
-*/

osGLOBAL void CDBThreadsInitializeFreeList(
                                          agRoot_t *hpRoot
                                        );

osGLOBAL CDBThread_t *CDBThreadAlloc(
                                    agRoot_t          *hpRoot,
                                    agIORequest_t     *hpIORequest,
                                    agFCDev_t          hpFCDev,
                                    agIORequestBody_t *hpRequestBody
                                  );

osGLOBAL void CDBThreadFree(
                           agRoot_t    *hpRoot,
                           CDBThread_t *CDBThread
                         );

/*+
SFThread Management
-*/

osGLOBAL void SFThreadsInitializeFreeList(
                                         agRoot_t *hpRoot
                                       );

osGLOBAL void SFThreadInitializeRequest(
                                       SFThread_Request_t *SFThread_Request
                                     );

osGLOBAL void SFThreadAlloc(
                           agRoot_t           *hpRoot,
                           SFThread_Request_t *SFThread_Request
                         );

osGLOBAL void SFThreadAllocCancel(
                                 agRoot_t           *hpRoot,
                                 SFThread_Request_t *SFThread_Request
                               );

osGLOBAL void SFThreadFree(
                          agRoot_t           *hpRoot,
                          SFThread_Request_t *SFThread_Request
                        );

/*+
ESGL Management
-*/

osGLOBAL void ESGLInitializeFreeList(
                                    agRoot_t *hpRoot
                                  );

osGLOBAL void ESGLInitializeRequest(
                                   ESGL_Request_t *ESGL_Request
                                 );

osGLOBAL void ESGLAlloc(
                       agRoot_t       *hpRoot,
                       ESGL_Request_t *ESGL_Request
                     );

osGLOBAL void ESGLAlloc_OnCard(
                              agRoot_t       *hpRoot,
                              ESGL_Request_t *ESGL_Request
                            );

osGLOBAL void ESGLAlloc_OffCard(
                               agRoot_t       *hpRoot,
                               ESGL_Request_t *ESGL_Request
                             );

osGLOBAL void ESGLAllocCancel(
                             agRoot_t       *hpRoot,
                             ESGL_Request_t *ESGL_Request
                           );

osGLOBAL void ESGLAllocCancel_OnCard(
                                    agRoot_t       *hpRoot,
                                    ESGL_Request_t *ESGL_Request
                                  );

osGLOBAL void ESGLAllocCancel_OffCard(
                                     agRoot_t       *hpRoot,
                                     ESGL_Request_t *ESGL_Request
                                   );

osGLOBAL void ESGLFree(
                      agRoot_t       *hpRoot,
                      ESGL_Request_t *ESGL_Request
                    );

osGLOBAL void ESGLFree_OnCard(
                             agRoot_t       *hpRoot,
                             ESGL_Request_t *ESGL_Request
                           );

osGLOBAL void ESGLFree_OffCard(
                              agRoot_t       *hpRoot,
                              ESGL_Request_t *ESGL_Request
                            );

#endif /* __Queue_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\protos.h ===
/*
Copyright (c) 2000 Agilent Technologies

    Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/H/PROTOS.H $

Revision History:

    $Revision: 9 $
    $Date: 12/07/00 1:38p $
    $Modtime:: 12/05/00 5:32p    $

*/

#ifndef __PROTOS_H__
#define __PROTOS_H__

#ifndef  GetDriverParameter
ULONG 
GetDriverParameter(
    IN PCHAR Parameter,
    IN ULONG Default,
    IN ULONG Min,
    IN ULONG Max,
    IN PCHAR ArgumentString
    );
#endif



ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    );

ULONG
HPFibreEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    );

ULONG
HPFibreFindAdapter(
    IN PCARD_EXTENSION pCard,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

BOOLEAN
HPFibreInitialize(
    IN PCARD_EXTENSION pCard
    );

BOOLEAN
HPFibreStartIo(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
HPFibreInterrupt(
    IN PCARD_EXTENSION pCard
    );

BOOLEAN
HPFibreResetBus(
    IN PCARD_EXTENSION HwDeviceExtension,
    ULONG  notused
    );

#if defined(HP_NT50)
SCSI_ADAPTER_CONTROL_STATUS
HPAdapterControl(
    IN PCARD_EXTENSION pCard,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );
#endif

void
ResetTimer (PCARD_EXTENSION pCard);
void
doLinkDownProcessing (PCARD_EXTENSION pCard);
void
ClearDevHandleArray (PCARD_EXTENSION pCard);
void
doPostResetProcessing (PCARD_EXTENSION pCard);

void
completeRequests (
    IN PCARD_EXTENSION pCard,
    UCHAR PId,
    UCHAR TId,
    UCHAR compStatus);

void
CompleteQueuedRequests (PCARD_EXTENSION pCard, agFCDev_t devHandle, UCHAR compStatus);
void
FixDevHandlesForLinkDown (PCARD_EXTENSION pCard);
void
FixDevHandlesForLinkUp (PCARD_EXTENSION pCard);
void
CompleteQueue (PCARD_EXTENSION pCard, 
               OSL_QUEUE *queue, 
               int param, 
               agFCDev_t devHandle, 
               UCHAR compStatus);

void
RegisterIfSpecialDev (PCARD_EXTENSION pCard, ULONG pathId, ULONG targetId, char *inquiryData);

BOOLEAN Map_FC_ScsiError( agRoot_t      *hpRoot,
                 agIORequest_t *phpIORequest,
                 agFcpRspHdr_t  * pResponseHeader,
                 ULONG hpIOInfoLen,
                 PSCSI_REQUEST_BLOCK Srb
                 );
int
RetrySrbOK (PSCSI_REQUEST_BLOCK pSrb);


void osFill(void * destin, os_bit32 length, os_bit8 fill );
BOOLEAN osStringCompare (char *str1, char *str2);
BOOLEAN osMemCompare (char *str1, char *str2, int count);
void osStringCopy ( char *destStr, char *sourceStr, int  destStrLen);

void osChipConfigWriteBit( agRoot_t *hpRoot, os_bit32 cardConfigOffset,os_bit32 chipIOLValue, os_bit32 valuesize);


void osCopyAndSwap(void * destin, void * source, UCHAR length );


VOID KeQuerySystemTime(
        OUT PLARGE_INTEGER  CurrentTime
        );

unsigned long get_time_stamp(void);

void ERROR_CONTEXT(char * file,  int line);

void SrbEnqueueTail (OSL_QUEUE *queue, PSCSI_REQUEST_BLOCK pSrb);
void SrbEnqueueHead (OSL_QUEUE *queue, PSCSI_REQUEST_BLOCK pSrb);
PSCSI_REQUEST_BLOCK SrbDequeueHead (OSL_QUEUE *queue);
void Startio (PCARD_EXTENSION pCard);


#if DBG

void dump_pCard( IN PCARD_EXTENSION pCard);

void  dump_PCI_regs( PCI_COMMON_CONFIG * pciCommonConfig );

#endif

int remove_Srbext(PCARD_EXTENSION     pCard,    PSRB_EXTENSION      pSrbExt);
void insert_Srbext(PCARD_EXTENSION     pCard,    PSRB_EXTENSION      pSrbExt);
PSRB_EXTENSION  Get_next_Srbext( PSRB_EXTENSION pNextSrbExt);
PSRB_EXTENSION  Del_next_Srbext( PSRB_EXTENSION pSrbExt,PSRB_EXTENSION pOldSrbExt);
PSRB_EXTENSION  Add_next_Srbext( PSRB_EXTENSION pSrbExt,PSRB_EXTENSION pNewSrbExt);


void display_sest_data(agIORequest_t *hpIORequest );
void display_srbext(agIORequest_t *hpIORequest );
void show_outstanding_IOs(PCARD_EXTENSION pCard);
os_bit32 fcGet_QA_Trace(agRoot_t  *hpRoot, void * data_out);
void fcDumpRegisters(agRoot_t  *hpRoot, void * data_out);

unsigned long get_hi_time_stamp(void);

#ifdef _DEBUG_PERF_DATA_
void dump_perf_data( PCARD_EXTENSION pCard  );
#endif

BOOLEAN
ReadFromRegistry (char *paramName, int type, void *data, int len);
void
osBugCheck (ULONG code,
    ULONG param1,
    ULONG param2,
    ULONG param3,
    ULONG param4);

void HPFibreTimerTick (IN PCARD_EXTENSION pCard);

BOOLEAN
RetrieveOsAdjustBufferEntry (
    char  *paramName,
    char  *value,
    int   len);

BOOLEAN
RetrieveOsAdjustBit32Entry (
    char  *paramName,
    os_bit32 *value);

agFCDev_t
MapToHandle (PCARD_EXTENSION pCard,
    ULONG           pathId,
    ULONG           targetId,
    ULONG           lun,
    PLU_EXTENSION   pLunExt);

/* The following are List of functions called in IOCTLs */

void
HPFillDriverInfo(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDriverInformation_t *hpFcDriverInfo,
    UCHAR *status
    );

void
HPFillCardConfig(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcCardConfiguration_t *hpFcCardConfig,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPFillDeviceConfig(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceConfiguration_t *hpFcDeviceConfig,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPFillLinkStat(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcLinkStatistics_t *hpFcLinkStat,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPFillDevStat(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceStatistics_t *hpFcDevStat,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPDoLinkReset(
    PSRB_IO_CONTROL srbIoCtl,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPDoDevReset(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcDeviceReset_t *hpFcDevReset,
    PCARD_EXTENSION pCard,
    UCHAR *PathId,
    UCHAR *TargetId,
    UCHAR *status
    );

void
HPDoRegRead(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcRegRead_t *hpFcRegRead,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
HPDoRegWrite(
    PSRB_IO_CONTROL srbIoCtl,
    hpFcRegWrite_t *hpFcRegWrite,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

#ifdef _FCCI_SUPPORT
void
FcciFillDriverInfo(
    PSRB_IO_CONTROL srbIoCtl,
    AFCCI_DRIVER_INFO *FcciDriverInfo,
    UCHAR *status
    );

void
FcciFillAdapterInfo(
    PSRB_IO_CONTROL srbIoCtl,
    AFCCI_ADAPTER_INFO *FcciAdapterInfo,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
FcciFillAdapterPortInfo(
    PSRB_IO_CONTROL srbIoCtl,
    FCCI_ADAPTER_PORT_INFO *FcciAdapterPortInfo,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
FcciFillLogUnitInfo(
    PSRB_IO_CONTROL srbIoCtl,
    FCCI_LOGUNIT_INFO *FcciLogUnitInfo,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
FcciFillDeviceInfo(
    PSRB_IO_CONTROL srbIoCtl,
    AFCCI_DEVICE_INFO *FcciGetDeviceInfo,
    PCARD_EXTENSION pCard,
    UCHAR *status
    );

void
FcciDoDeviceReset(
    PSRB_IO_CONTROL srbIoCtl,
    FCCI_RESET_TARGET *FcciResetTarget,
    PCARD_EXTENSION pCard,
    UCHAR *PathId,
    UCHAR *TargetId,
    UCHAR *status
    );
#endif

void
InitLunExtension (PLU_EXTENSION pLunExt);

void
GetNodeInfo (PCARD_EXTENSION pCard);
void
RetryQToAdapterQ (PCARD_EXTENSION pCard);
int 
TestOnCardRam (agRoot_t *hpRoot);

void
GetSystemTime (CSHORT *Year, 
               CSHORT *Month,
               CSHORT *Day, 
               CSHORT *Hour,
               CSHORT *Minute,
               CSHORT *Second,
               CSHORT *Milliseconds);

/* Till here */
#ifdef _DEBUG_EVENTLOG_
VOID 
LogEvent(    
            PVOID                   pCard,
            PVOID                   pDeviceObject,
            ULONG                   errorType,
            ULONG                   Parm[],
            ULONG                   ParmCount,
            char                    *formatString,
            ... 
            );
BOOLEAN LogScsiError( agRoot_t            *hpRoot,
                      PSCSI_REQUEST_BLOCK pSrb ,
                  agFcpRspHdr_t  * pResponseHeader,
                  ULONG           hpIOInfoLen);

void FlushCardErrors(PCARD_EXTENSION    pcard);

extern ULONG LogLevel;

extern ULONG DecodeSrbError(UCHAR err);
extern void LogHBAInformation(PCARD_EXTENSION pCard);
extern VOID LogAnyMessage(IN PVOID DriverObject,
            LONG    msgCode,
            UCHAR   *formatString,
            ...
            );

extern ULONG AllocEventLogBuffer(IN PVOID DriverObject, IN PVOID pc);

extern VOID ReleaseEventLogBuffer(IN PVOID DriverObject, IN PVOID pc);

#endif


void ReadGlobalRegistry(PVOID DriverObject);

#ifdef __REGISTERFORSHUTDOWN__
extern ULONG gRegisterForShutdown;
#endif

#ifdef   _ENABLE_LARGELUN_
extern ULONG gEnableLargeLun;
extern ULONG gMaximumLuns;
#endif
#ifdef YAM2_1
extern REG_SETTING  gRegSetting;
extern WWN_TABLE    *gWWNTable;
extern ULONG            gMaxPaDevices;
extern int          gDeviceExtensionSize;
extern int          gMaximumTargetIDs;
extern ULONG    FindInPaDeviceTable(PCARD_EXTENSION pCard, ULONG fcDeviceIndex);
extern void     FillPaDeviceTable(PCARD_EXTENSION pCard);
extern ULONG    FindInWWNTable (PCARD_EXTENSION pCard, UCHAR *nodeWWN);
ULONG   GetPaDeviceHandle(PCARD_EXTENSION pCard,
            ULONG           pathId,
            ULONG           targetId,
            ULONG           lun,
            PLU_EXTENSION   pLunExt,
            USHORT          *paIndex);
void SetPaDeviceTable(PCARD_EXTENSION pCard, ULONG devIndex, ULONG flag);

void SetFcpLunBeforeStartIO (
            PLU_EXTENSION           pLunExt,
            agIORequestBody_t       *pHpio_CDBrequest,
            PSCSI_REQUEST_BLOCK     pSrb);

int  TryOtherAddressingMode(
            PCARD_EXTENSION     pCard, 
            agIORequest_t       *phpIORequest,
            PSRB_EXTENSION  pSrbExt, 
            ULONG               flag);

void InitializeDeviceTable(PCARD_EXTENSION pCard);
DEVICE_MAP  *GetDeviceMapping(PCARD_EXTENSION pCard,
    ULONG               pathId,
    ULONG               targetId,
    ULONG               lun, 
    CHAR                    *addrmode,
    USHORT              *paIndex);

void SetLunCount(PCARD_EXTENSION pCard,
    ULONG               pathId,
    ULONG               targetId,
    ULONG               lun);

#endif


#ifdef _DEBUG_SCSIPORT_NOTIFICATION_
VOID
Local_ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    );
#define ScsiPortNotification                Local_ScsiPortNotification

VOID 
Local_ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    );
#define ScsiPortCompleteRequest             Local_ScsiPortCompleteRequest

#endif

#ifdef DBGPRINT_IO

#define DBGPRINT_START                      0x1
#define DBGPRINT_SEND                       0x2
#define DBGPRINT_DONE                       0x4
#define DBGPRINT_QHEAD                      0x8
#define DBGPRINT_QTAIL                      0x10
#define DBGPRINT_DEQHEAD                    0x20
#define DBGPRINT_HPFibreStartIo             0x40
#define DBGPRINT_SCSIPORT_RequestComplete   0x100
#define DBGPRINT_SCSIPORT_NextRequest       0x200
#define DBGPRINT_SCSIPORT_NextLuRequest     0x400
#define DBGPRINT_SCSIPORT_ResetDetected     0x800
#define DBGPRINT_SCSIPORT_ScsiportCompleteRequest       0x1000

extern ULONG    gDbgPrintIo;
#endif

#ifdef _DEBUG_PERR_             /* enable BugCheck */
extern ULONG    gDebugPerr;
#endif
#ifdef _DEBUG_REPORT_LUNS_
void PrintReportLunData(PSCSI_REQUEST_BLOCK pSrb);
#endif

#ifdef _ENABLE_PSEUDO_DEVICE_
extern ULONG    gEnablePseudoDevice;
ULONG   PseudoDeviceIO(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    );
#endif

ULONG DoIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    );


#ifdef _SAN_IOCTL_
ULONG AgSANIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN     *LinkResetPerformed,
    BOOLEAN     *DeviceResetPerformed,
    UCHAR           *srb_status,
    UCHAR       *PathId, 
    UCHAR           *TargetId);

void SANPutNextBuffer(
    IN PCARD_EXTENSION pCard,
    SAN_EVENTINFO      *this);
#endif


extern ULONG gCrashDumping;
extern ULONG gIrqlLevel;
#endif // __PROTOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\readreg.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   readreg.h

Abstract:

Authors:

Environment:

    kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/readreg.h $

Revision History:
   $Revision: 3 $
   $Date: 9/07/00 11:19a $
   $Modtime: 8/31/00 3:26p $

Notes:

--*/

#include "buildop.h"             //LP021100 build switches

#include <stdarg.h>
#include <stdio.h>

#ifndef _READREG_H_
#define _READREG_H_

#ifdef HP_NT50
#define REG_ParametersDevice          "AFCW2K\\Parameters\\Device"
#define REG_Parameters                "AFCW2K\\Parameters"
#else
#ifdef _USE_OLD_NAME_
#define REG_ParametersDevice          "HHBA5100\\Parameters\\Device"
#define REG_Parameters                "HHBA5100\\Parameters"
#else
#define REG_ParametersDevice          "AFCNT4\\Parameters\\Device"
#define REG_Parameters                "AFCNT4\\Parameters"
#endif
#endif

#define REG_PaPathIdWidth        "PaPathIdWidth"
#define REG_VoPathIdWidth        "VoPathIdWidth"
#define REG_LuPathIdWidth        "LuPathIdWidth"
#define REG_LuTargetWidth        "LuTargetWidth"
#define REG_MaximumTids          "MaximumTids"

#ifdef HP_NT50
#define REG_LARGE_LUNS_RELPATH   RTL_REGISTRY_SERVICES
#define REG_LARGE_LUNS_PATH "\\ScsiPort\\SpecialTargetList\\GenDisk"
#else
#define REG_LARGE_LUNS_RELPATH   RTL_REGISTRY_CONTROL
#define REG_LARGE_LUNS_PATH REG_ParametersDevice
#endif


BOOLEAN ReadRegistry(
   ULONG          dataType,
   ULONG          relativeTo,
   char           *name, 
   char      *path,
   ULONG     *dwordOrLen,
   void      *stringData);


void RegGetDword(ULONG cardinstance, IN char *path, IN char *name, ULONG *retData, ULONG min_val, ULONG max_val);


#ifndef osDEBUGPRINT
#if DBG >= 1
#define osDEBUGPRINT(x) osDebugPrintString x
#else
#define osDEBUGPRINT(x)
#endif
#endif

#ifndef ALWAYS_PRINT
#define  ALWAYS_PRINT               0x01000000  // If statement executes always
#endif

#ifndef osDebugPrintString
extern void osDebugPrintString(
                            unsigned int Print_LEVEL,
                            char     *formatString,
                            ...
                            );

#endif  /* ~osDebugPrintString */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\queue.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/Queue.C $

  $Revision:: 3               $
      $Date:: 9/06/01 5:31p   $ (Last Check-In)
   $Modtime:: 8/31/01 1:23p   $ (Last Modified)

Purpose:

  This file implements queue management for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/timersvc.h"
#include "../h/queue.h"
#include "../h/cstate.h"
#include "../h/sfstate.h"
#include "../h/cfunc.h" 
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "timersvc.h"
#include "queue.h"
#include "cstate.h"
#include "sfstate.h"
#include "cfunc.h" 
#endif  /* _New_Header_file_Layout_ */

/*+
Static Table to convert AL_PA to Loop Index
-*/

os_bit8 AL_PA_to_Loop_Index[256] =
     {
       0x7E, 0x7D, 0x7C, 0xFF, 0x7B, 0xFF, 0xFF, 0xFF,
       0x7A, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x79,
       0x78, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x77,
       0x76, 0xFF, 0xFF, 0x75, 0xFF, 0x74, 0x73, 0x72,
       0xFF, 0xFF, 0xFF, 0x71, 0xFF, 0x70, 0x6F, 0x6E,
       0xFF, 0x6D, 0x6C, 0x6B, 0x6A, 0x69, 0x68, 0xFF,
       0xFF, 0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0xFF,
       0xFF, 0x61, 0x60, 0xFF, 0x5F, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0x5E, 0xFF, 0x5D, 0x5C, 0x5B,
       0xFF, 0x5A, 0x59, 0x58, 0x57, 0x56, 0x55, 0xFF,
       0xFF, 0x54, 0x53, 0x52, 0x51, 0x50, 0x4F, 0xFF,
       0xFF, 0x4E, 0x4D, 0xFF, 0x4C, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0x4B, 0xFF, 0x4A, 0x49, 0x48,
       0xFF, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0xFF,
       0xFF, 0x41, 0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0xFF,
       0xFF, 0x3B, 0x3A, 0xFF, 0x39, 0xFF, 0xFF, 0xFF,
       0x38, 0x37, 0x36, 0xFF, 0x35, 0xFF, 0xFF, 0xFF,
       0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x33,
       0x32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x31,
       0x30, 0xFF, 0xFF, 0x2F, 0xFF, 0x2E, 0x2D, 0x2C,
       0xFF, 0xFF, 0xFF, 0x2B, 0xFF, 0x2A, 0x29, 0x28,
       0xFF, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0xFF,
       0xFF, 0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0xFF,
       0xFF, 0x1B, 0x1A, 0xFF, 0x19, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0x18, 0xFF, 0x17, 0x16, 0x15,
       0xFF, 0x14, 0x13, 0x12, 0x11, 0x10, 0x0F, 0xFF,
       0xFF, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0xFF,
       0xFF, 0x08, 0x07, 0xFF, 0x06, 0xFF, 0xFF, 0xFF,
       0x05, 0x04, 0x03, 0xFF, 0x02, 0xFF, 0xFF, 0xFF,
       0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
     };

/*+
Queue Functions
-*/

agBOOLEAN fiListElementOnList(
                             fiList_t *toFindHdr,
                             fiList_t *listHdr
                           )
{
    fiList_t *elementHdr = listHdr;

    while ((elementHdr = elementHdr->flink) != listHdr)
    {
        if (elementHdr == toFindHdr)
        {
            return agTRUE;
        }
    }

    return agFALSE;
}

os_bit32 fiNumElementsOnList(
                           fiList_t *listHdr
                         )
{
    fiList_t *elementHdr  = listHdr;
    os_bit32     numElements = 0;
    if( elementHdr->flink == agNULL)
    {
        fiLogDebugString(agNULL,
                        0,
                        "In %s elementHdr->flink NULL",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        return numElements;
    }
    if( elementHdr->blink == agNULL)
    {
        fiLogDebugString(agNULL,
                        0,
                        "In %s   elementHdr->blink NULL",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        return numElements;
    }

    while ((elementHdr = elementHdr->flink) != listHdr)
    {
        if( elementHdr->flink == agNULL)
        {
            fiLogDebugString(agNULL,
                        0,
                        "In %s   elementHdr->flink->flink NULL",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
            return numElements;
        }

        if( elementHdr->blink == agNULL)
        {
            fiLogDebugString(agNULL,
                        0,
                        "In %s   elementHdr->flink->blink NULL",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
            return numElements;
        }

        numElements++;

        if( elementHdr->flink == elementHdr->blink)
        {
            break;
        }

/*        
		if( listHdr->flink == listHdr->blink)
        {
            break;
        }
*/

        if(numElements > 0x1000)
        {
            fiLogDebugString(agNULL,
                        CStateLogConsoleERROR,
                        "In %s                   List exceeds 0x1000",
                        "fiNumElementsOnList",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
            break;
        } 
    }

    return numElements;
}

/*+
ERQ Management
-*/

void WaitForERQ(
                 agRoot_t *hpRoot
               )
{
    CThread_t      *CThread          = CThread_ptr(hpRoot);
    ERQProdIndex_t  NextProdIndex    = CThread->HostCopy_ERQProdIndex + 1;
    os_bit32           ConsIndex_Offset;
    ERQConsIndex_t *ConsIndex_Ptr;
    os_bit32 ERQ_Polling_Count = 0;
    if (NextProdIndex == CThread->Calculation.MemoryLayout.ERQ.elements)
    {
        NextProdIndex = 0;
    }

    if (CThread->Calculation.MemoryLayout.ERQConsIndex.memLoc == inCardRam)
    {
        ConsIndex_Offset = CThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset;

        while (NextProdIndex == osCardRamReadBit32(
                                                    hpRoot,
                                                    ConsIndex_Offset
                                                  ))
        {
            osStallThread(
                           hpRoot,
                           ERQ_Polling_osStallThread_Parameter
                         );
        }
    }
    else /* CThread->Calculation.MemoryLayout.ERQConsIndex.memLoc == inDmaMemory */
    {
        ConsIndex_Ptr = (ERQConsIndex_t *)(CThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr);

        while (NextProdIndex == *ConsIndex_Ptr)
        {
            ERQ_Polling_Count++;
            if(ERQ_Polling_Count > 30000)
            {
                fiLogDebugString(
                                  hpRoot,
                                  QueueLogConsoleERRORLevel,
                                  "ERQ_Polling_Count over 30000",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  0,0,0,0,0,0,0,0
                                );
                ERQ_Polling_Count=0;
            break;
            
            }

            osStallThread(
                           hpRoot,
                           ERQ_Polling_osStallThread_Parameter
                         );
        }
    ERQ_Polling_Count=0;
    }
}

void WaitForERQ_ConsIndexOnCard(
                                 agRoot_t *hpRoot
                               )
{
#ifndef __MemMap_Force_Off_Card__
    CThread_t      *CThread          = CThread_ptr(hpRoot);
    ERQProdIndex_t  NextProdIndex    = CThread->HostCopy_ERQProdIndex + 1;
    os_bit32           ConsIndex_Offset = CThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset;

    if (NextProdIndex == CThread->Calculation.MemoryLayout.ERQ.elements)
    {
        NextProdIndex = 0;
    }

    while (NextProdIndex == osCardRamReadBit32(
                                                hpRoot,
                                                ConsIndex_Offset
                                              ))
    {
        osStallThread(
                       hpRoot,
                       ERQ_Polling_osStallThread_Parameter
                     );
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void WaitForERQ_ConsIndexOffCard(
                                  agRoot_t *hpRoot
                                )
{
#ifndef __MemMap_Force_On_Card__
    CThread_t      *CThread       = CThread_ptr(hpRoot);
    ERQProdIndex_t  NextProdIndex = CThread->HostCopy_ERQProdIndex + 1;
    ERQConsIndex_t *ConsIndex_Ptr = (ERQConsIndex_t *)(CThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr);

    if (NextProdIndex == CThread->Calculation.MemoryLayout.ERQ.elements)
    {
        NextProdIndex = 0;
    }

    while (NextProdIndex == *ConsIndex_Ptr)
    {
        osStallThread(
                       hpRoot,
                       ERQ_Polling_osStallThread_Parameter
                     );
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void WaitForERQEmpty(
                      agRoot_t *hpRoot
                    )
{
    CThread_t      *CThread          = CThread_ptr(hpRoot);
    ERQProdIndex_t  ProdIndex        = CThread->HostCopy_ERQProdIndex;
    os_bit32           ConsIndex_Offset;
    ERQConsIndex_t *ConsIndex_Ptr;

    if (CThread->Calculation.MemoryLayout.ERQConsIndex.memLoc == inCardRam)
    {
        ConsIndex_Offset = CThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset;

        while (ProdIndex != osCardRamReadBit32(
                                                hpRoot,
                                                ConsIndex_Offset
                                              ))
        {
            osStallThread(
                           hpRoot,
                           ERQ_Polling_osStallThread_Parameter
                         );
        }
    }
    else /* CThread->Calculation.MemoryLayout.ERQConsIndex.memLoc == inDmaMemory */
    {
        ConsIndex_Ptr = (ERQConsIndex_t *)(CThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr);

        while (ProdIndex != *ConsIndex_Ptr)
        {
            osStallThread(
                           hpRoot,
                           ERQ_Polling_osStallThread_Parameter
                         );
        }
    }
}

void WaitForERQEmpty_ConsIndexOnCard(
                                      agRoot_t *hpRoot
                                    )
{
#ifndef __MemMap_Force_Off_Card__
    CThread_t      *CThread          = CThread_ptr(hpRoot);
    ERQProdIndex_t  ProdIndex        = CThread->HostCopy_ERQProdIndex;
    os_bit32           ConsIndex_Offset = CThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset;

    while (ProdIndex != osCardRamReadBit32(
                                            hpRoot,
                                            ConsIndex_Offset
                                          ))
    {
        osStallThread(
                       hpRoot,
                       ERQ_Polling_osStallThread_Parameter
                     );
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void WaitForERQEmpty_ConsIndexOffCard(
                                       agRoot_t *hpRoot
                                     )
{
#ifndef __MemMap_Force_On_Card__
    CThread_t      *CThread       = CThread_ptr(hpRoot);
    ERQProdIndex_t  ProdIndex     = CThread->HostCopy_ERQProdIndex;
    ERQConsIndex_t *ConsIndex_Ptr = (ERQConsIndex_t *)(CThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr);

    while (ProdIndex != *ConsIndex_Ptr)
    {
        osStallThread(
                       hpRoot,
                       ERQ_Polling_osStallThread_Parameter
                     );
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

#ifdef _DvrArch_1_30_
/*+
PktThread Management
-*/
void PktThreadsInitializeFreeList(
                                   agRoot_t *agRoot
                                 )
{
    CThread_t                  *CThread                    = CThread_ptr(agRoot);
    fiMemMapMemoryDescriptor_t *PktThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.PktThread);
    fiMemMapMemoryDescriptor_t *Pkt_CMND_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.Pkt_CMND);
    PktThread_t                *PktThread                  = PktThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    FCHS_t                     *Pkt_CMND_Ptr;
    os_bit32                    Pkt_CMND_Offset;
    os_bit32                    Pkt_CMND_Lower32;
    os_bit32                    PktThread_size             = PktThread_MemoryDescriptor->elementSize;
    os_bit32                    Pkt_CMND_size              = Pkt_CMND_MemoryDescriptor->elementSize;
    fiMemMapMemoryLocation_t    Pkt_CMND_memLoc            = Pkt_CMND_MemoryDescriptor->memLoc;
    os_bit32                    total_PktThreads           = PktThread_MemoryDescriptor->elements;
    os_bit32                    PktThread_index;

    if (Pkt_CMND_memLoc == inCardRam)
    {
        Pkt_CMND_Ptr     = (FCHS_t *) agNULL;
        Pkt_CMND_Offset  = Pkt_CMND_MemoryDescriptor->addr.CardRam.cardRamOffset;
        Pkt_CMND_Lower32 = Pkt_CMND_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* Pkt_CMND_memLoc == inDmaMemory */
    {
        Pkt_CMND_Ptr     = (FCHS_t *)(Pkt_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        Pkt_CMND_Offset  = 0;
        Pkt_CMND_Lower32 = Pkt_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
    }

    fiListInitHdr(
                   &(CThread->Free_PktLink)
                 );

    for (PktThread_index = 0;
         PktThread_index < total_PktThreads;
         PktThread_index++)
    {
        PktThread->Pkt_CMND_Ptr     = Pkt_CMND_Ptr;
        PktThread->Pkt_CMND_Offset  = Pkt_CMND_Offset;
        PktThread->Pkt_CMND_Lower32 = Pkt_CMND_Lower32;

        fiListInitElement(&(PktThread->PktLink));

        fiListEnqueueAtTail( &(PktThread->PktLink),
                             &(CThread->Free_PktLink));

        PktThread = (PktThread_t *)((os_bit8 *)PktThread + PktThread_size);

        if (Pkt_CMND_memLoc == inCardRam)
        {
            Pkt_CMND_Offset += Pkt_CMND_size;
        }
        else /* Pkt_CMND_memLoc == inDmaMemory */
        {
            Pkt_CMND_Ptr     = (FCHS_t *)((os_bit8 *)Pkt_CMND_Ptr + Pkt_CMND_size);
        }

        Pkt_CMND_Lower32    += Pkt_CMND_size;
    }
}

PktThread_t *PktThreadAlloc(
                             agRoot_t *agRoot,
                             DevThread_t *pDevThread
                           )
{
    CThread_t   *CThread             = CThread_ptr(agRoot);
    fiList_t    *fiList_to_return;
    PktThread_t *PktThread_to_return;

    fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_PktLink)
                         );

    if (fiList_to_return == (fiList_t *)agNULL)
    {
        PktThread_to_return = (PktThread_t *)agNULL;
    }
    else /* fiList_to_return != (fiList_t *)agNULL */
    {
        PktThread_to_return = hpObjectBase(
                                            PktThread_t,
                                            PktLink,
                                            fiList_to_return
                                          );
        PktThread_to_return->Device = pDevThread;
    }

    return PktThread_to_return;
}

void PktThreadFree(
                    agRoot_t    *agRoot,
                    PktThread_t *PktThread
                  )
{
    CThread_t *CThread        = CThread_ptr(agRoot);
    fiList_t  *fiList_to_free = &(PktThread->PktLink);

    fiListEnqueueAtTail(
                         fiList_to_free,
                         &(CThread->Free_PktLink)
                       );
}

#endif /* _DvrArch_1_30_ was defined */

/*+
TgtThread Management
-*/

void TgtThreadsInitializeFreeList(
                                   agRoot_t *hpRoot
                                 )
{
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *TgtThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.TgtThread);
    TgtThread_t                *TgtThread                  = TgtThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                       TgtThread_size             = TgtThread_MemoryDescriptor->elementSize;
    os_bit32                       total_TgtThreads           = TgtThread_MemoryDescriptor->elements;
    os_bit32                       TgtThread_index;

    fiListInitHdr(
                   &(CThread->Free_TgtLink)
                 );

    for (TgtThread_index = 0;
         TgtThread_index < total_TgtThreads;
         TgtThread_index++)
    {
        TgtThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

        SFThreadInitializeRequest(
                                   &(TgtThread->SFThread_Request)
                                 );

        fiListInitElement(&(TgtThread->TgtLink));

        fiListEnqueueAtTail( &(TgtThread->TgtLink),
                             &(CThread->Free_TgtLink));

        TgtThread = (TgtThread_t *)((os_bit8 *)TgtThread + TgtThread_size);
    }
}

TgtThread_t *TgtThreadAlloc(
                             agRoot_t *hpRoot
                           )
{
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    fiList_t    *fiList_to_return;
    TgtThread_t *TgtThread_to_return;

    fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_TgtLink)
                         );

    if (fiList_to_return == (fiList_t *)agNULL)
    {
        TgtThread_to_return = (TgtThread_t *)agNULL;
    }
    else /* fiList_to_return != (fiList_t *)agNULL */
    {
        TgtThread_to_return = hpObjectBase(
                                            TgtThread_t,
                                            TgtLink,
                                            fiList_to_return
                                          );
    }

    return TgtThread_to_return;
}

void TgtThreadFree(
                    agRoot_t    *hpRoot,
                    TgtThread_t *TgtThread
                  )
{
    CThread_t *CThread        = CThread_ptr(hpRoot);
    fiList_t  *fiList_to_free = &(TgtThread->TgtLink);

    if (TgtThread->SFThread_Request.State != SFThread_Request_InActive)
    {
        if (TgtThread->SFThread_Request.State == SFThread_Request_Pending)
        {
            SFThreadAllocCancel(
                                 hpRoot,
                                 &(TgtThread->SFThread_Request)
                               );
        }
        else /* TgtThread->SFThread_Request.State == SFThread_Request_Granted */
        {
            SFThreadFree(
                          hpRoot,
                          &(TgtThread->SFThread_Request)
                        );
        }
    }

    fiListEnqueueAtTail(
                         fiList_to_free,
                         &(CThread->Free_TgtLink)
                       );
}

/*+
DevThread Management
-*/

void DevThreadsInitializeFreeList(
                                   agRoot_t *hpRoot
                                 )
{
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *DevThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.DevThread);
    DevThread_t                *DevThread                  = DevThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                    DevThread_size             = DevThread_MemoryDescriptor->elementSize;
    os_bit32                    total_DevThreads           = DevThread_MemoryDescriptor->elements;
    os_bit32                    DevThread_index;
#ifdef _DvrArch_1_30_
    os_bit32                    IP_X_ID_Offset             = CThread->Calculation.MemoryLayout.CDBThread.elements +
                                                             CThread->Calculation.MemoryLayout.SFThread.elements;
#endif /* _DvrArch_1_30_ was defined */

    fiListInitHdr(
                   &(CThread->Free_DevLink)
                 );

    for (DevThread_index = 0;
         DevThread_index < total_DevThreads;
         DevThread_index++)
    {
#ifdef _DvrArch_1_30_
        DevThread->IP_X_ID                         =(X_ID_t) (DevThread_index + IP_X_ID_Offset);
        DevThread->NewIPExchange                   = agTRUE;
#endif /* _DvrArch_1_30_ was defined */
        DevThread->DevSlot                         = DevSlot_Invalid;

        DevThread->DevInfo.CurrentAddress.reserved = 0;
        DevThread->DevInfo.CurrentAddress.Domain   = 0;
        DevThread->DevInfo.CurrentAddress.Area     = 0;
        DevThread->DevInfo.CurrentAddress.AL_PA    = 0;

        DevThread->DevInfo.HardAddress.reserved    = 0;
        DevThread->DevInfo.HardAddress.Domain      = 0;
        DevThread->DevInfo.HardAddress.Area        = 0;
        DevThread->DevInfo.HardAddress.AL_PA       = 0;

        DevThread->SFThread_Request.SFThread       = (SFThread_t *)agNULL;

        SFThreadInitializeRequest(
                                   &(DevThread->SFThread_Request)
                                 );

        fiTimerInitializeRequest(
                                  &(DevThread->Timer_Request)
                                );

        fiListInitHdr( &(DevThread->Active_CDBLink_0));
        fiListInitHdr( &(DevThread->Active_CDBLink_1));
        fiListInitHdr( &(DevThread->Active_CDBLink_2));
        fiListInitHdr( &(DevThread->Active_CDBLink_3));
        fiListInitHdr( &(DevThread->TimedOut_CDBLink));

        fiListInitHdr( &(DevThread->Send_IO_CDBLink));

        fiListInitHdr( &(DevThread->Awaiting_Login_CDBLink));

        fiListInitElement( &(DevThread->DevLink) );

        fiListEnqueueAtTail( &(DevThread->DevLink),
                             &(CThread->Free_DevLink)
                           );

        DevThread = (DevThread_t *)((os_bit8 *)DevThread + DevThread_size);
    }
}

DevThread_t *DevThreadAlloc(
                             agRoot_t     *hpRoot,
                             FC_Port_ID_t  Port_ID
                           )
{
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    fiList_t    *fiList_to_return;
    DevThread_t *DevThread_to_return;

    fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_DevLink)
                         );

    if (fiList_to_return == (fiList_t *)agNULL)
    {
        DevThread_to_return = (DevThread_t *)agNULL;
    }
    else /* fiList_to_return != (fiList_t *)agNULL */
    {
        DevThread_to_return = hpObjectBase(
                                            DevThread_t,
                                            DevLink,
                                            fiList_to_return
                                          );

        DevThread_to_return->DevInfo.CurrentAddress.reserved = 0;
        DevThread_to_return->DevInfo.CurrentAddress.Domain = Port_ID.Struct_Form.Domain;
        DevThread_to_return->DevInfo.CurrentAddress.Area   = Port_ID.Struct_Form.Area;
        DevThread_to_return->DevInfo.CurrentAddress.AL_PA  = Port_ID.Struct_Form.AL_PA;
        CFuncInit_DevThread( hpRoot, DevThread_to_return );
        DevThread_to_return->DevSlot                       = DevSlot_Invalid;
        DevThread_to_return->PRLI_rejected                 = agFALSE;
        DevThread_to_return->FC_TapeDevice                 = agFALSE;
        DevThread_to_return->OtherAgilentHBA               = agFALSE;

    }

    return DevThread_to_return;
}

void DevThreadFree(
                    agRoot_t    *hpRoot,
                    DevThread_t *DevThread
                  )
{
    CThread_t   *CThread        = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread;
    fiList_t    *fiList_to_free;

    while (fiListNotEmpty(
                           &(DevThread->Active_CDBLink_0)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Active_CDBLink_0",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Active_CDBLink_0),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Active_CDBLink_0)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }
    while (fiListNotEmpty(
                           &(DevThread->Active_CDBLink_1)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Active_CDBLink_1",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Active_CDBLink_1),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Active_CDBLink_1)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }
    while (fiListNotEmpty(
                           &(DevThread->Active_CDBLink_2)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Active_CDBLink_2",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Active_CDBLink_2),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Active_CDBLink_2)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }
    while (fiListNotEmpty(
                           &(DevThread->Active_CDBLink_3)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Active_CDBLink_3",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Active_CDBLink_3),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Active_CDBLink_3)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }
    while (fiListNotEmpty(
                           &(DevThread->TimedOut_CDBLink)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","TimedOut_CDBLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->TimedOut_CDBLink),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->TimedOut_CDBLink)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }

    while (fiListNotEmpty(
                           &(DevThread->Send_IO_CDBLink)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Send_IO_CDBLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Send_IO_CDBLink),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Send_IO_CDBLink)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }

    while (fiListNotEmpty(
                           &(DevThread->Awaiting_Login_CDBLink)
                         )                             )
    {
        fiLogString(hpRoot,
                        "%s %s Not empty %d",
                        "DevThreadFree","Awaiting_Login_CDBLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink),
                        0,0,0,0,0,0,0);

        fiListDequeueFromHeadFast(
                                   &fiList_to_free,
                                   &(DevThread->Awaiting_Login_CDBLink)
                                 );

        CDBThread = hpObjectBase(
                                  CDBThread_t,
                                  CDBLink,
                                  fiList_to_free
                                );

        CDBThreadFree(
                       hpRoot,
                       CDBThread
                     );
    }

    if (DevThread->SFThread_Request.State != SFThread_Request_InActive)
    {
        if (DevThread->SFThread_Request.State == SFThread_Request_Pending)
        {
            SFThreadAllocCancel(
                                 hpRoot,
                                 &(DevThread->SFThread_Request)
                               );
        }
        else /* DevThread->SFThread_Request.State == SFThread_Request_Granted */
        {
            SFThreadFree(
                          hpRoot,
                          &(DevThread->SFThread_Request)
                        );
        }
    }

    if (DevThread->Timer_Request.Active == agTRUE)
    {
        fiTimerStop(
                     &(DevThread->Timer_Request)
                   );
    }

    DevThread->DevSlot                       = DevSlot_Invalid;

    DevThread->DevInfo.CurrentAddress.Domain = 0;
    DevThread->DevInfo.CurrentAddress.Area   = 0;
    DevThread->DevInfo.CurrentAddress.AL_PA  = 0;

    fiListDequeueThis( &(DevThread->DevLink));    
    fiList_to_free = &(DevThread->DevLink);

    fiListEnqueueAtTail(
                         fiList_to_free,
                         &(CThread->Free_DevLink)
                       );
}

void DevThreadInitializeSlots(
                               agRoot_t *hpRoot
                             )
{
    os_bit32 total_SlotWWNs = CThread_ptr(hpRoot)->Calculation.MemoryLayout.SlotWWN.elements;
    os_bit32 SlotWWN_index;

    for (SlotWWN_index = 0;
         SlotWWN_index < total_SlotWWNs;
         SlotWWN_index++)
    {
        DevThreadFreeSlot(
                           hpRoot,
                           SlotWWN_index
                         );
    }
}

agBOOLEAN DevThreadMatchWWN(FC_Port_Name_t *WWN_1,FC_Port_Name_t *WWN_2 )
{
    if ((*WWN_1)[0] != (*WWN_2)[0]) return agFALSE;
    if ((*WWN_1)[1] != (*WWN_2)[1]) return agFALSE;
    if ((*WWN_1)[2] != (*WWN_2)[2]) return agFALSE;
    if ((*WWN_1)[3] != (*WWN_2)[3]) return agFALSE;
    if ((*WWN_1)[4] != (*WWN_2)[4]) return agFALSE;
    if ((*WWN_1)[5] != (*WWN_2)[5]) return agFALSE;
    if ((*WWN_1)[6] != (*WWN_2)[6]) return agFALSE;
    if ((*WWN_1)[7] != (*WWN_2)[7]) return agFALSE;

    return agTRUE;
}

#define MAX_DevSlot_Ranges  4

#define DevSlot_Bounds      2
#define DevSlot_Range_Start 0
#define DevSlot_Range_End   1

DevSlot_t DevThreadFindSlot(
                             agRoot_t       *hpRoot,
                             os_bit8            Domain_Address,
                             os_bit8            Area_Address,
                             os_bit8            Loop_Address,
                             FC_Port_Name_t *FindWWN
                           )
{
    CThread_t                  *CThread                                           = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SlotWWN_MemoryDescriptor                          = &(CThread->Calculation.MemoryLayout.SlotWWN);
    SlotWWN_t                  *SlotWWN_First                                     = (SlotWWN_t *)(SlotWWN_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr);
    os_bit32                       SlotWWN_size                                      = SlotWWN_MemoryDescriptor->elementSize;
    SlotWWN_t                  *SlotWWN;
    os_bit32                       NumDevSlotsPerArea                                = CThread->Calculation.Parameters.NumDevSlotsPerArea;
    os_bit32                       NumAreasPerDomain                                 = CThread->Calculation.Parameters.NumAreasPerDomain;
    os_bit32                       NumDomains                                        = CThread->Calculation.Parameters.NumDomains;
    os_bit32                       Loop_Index                                        = AL_PA_to_Loop_Index[Loop_Address];
    DevSlot_t                   DevSlot_Bucket_Min;
    DevSlot_t                   DevSlot_Bucket_Max;
    DevSlot_t                   DevSlot_Ideal;
    DevSlot_t                   DevSlot_Last                                      = SlotWWN_MemoryDescriptor->elements - 1;
    os_bit32                       DevSlot_Range_Index;
    os_bit32                       DevSlot_Ranges;
    DevSlot_t                   DevSlot_Range[MAX_DevSlot_Ranges][DevSlot_Bounds];
    DevSlot_t                   DevSlot_ToReturn;
    fiList_t                   *DevThread_DevLink;
    DevThread_t                *DevThread;

    /* Compute DevSlot_Bucket and DevSlot_Ideal */

    if (Loop_Index == 0xFF)
    {
        /* Invalid AL_PA: Use first DevSlot of Last DevSlot_Bucket */

        DevSlot_Ideal =   (  (  (NumDomains - 1)
                              * NumAreasPerDomain)
                           + (NumAreasPerDomain - 1) )
                        * NumDevSlotsPerArea;

        if (DevSlot_Ideal == 0)
        {
            /* Only a single DevSlot_Bucket, so only a single, simple DevSlot_Range */

            DevSlot_Ranges                        = 1;

            DevSlot_Range[0][DevSlot_Range_Start] = 0;
            DevSlot_Range[0][DevSlot_Range_End  ] = DevSlot_Last;
        }
        else /* DevSlot_Ideal != 0 */
        {
            /* More than one DevSlot_Bucket, so use two DevSlot_Ranges */

            DevSlot_Ranges                        = 2;

            DevSlot_Range[0][DevSlot_Range_Start] = DevSlot_Ideal;
            DevSlot_Range[0][DevSlot_Range_End  ] = DevSlot_Last;

            DevSlot_Range[1][DevSlot_Range_Start] = 0;
            DevSlot_Range[1][DevSlot_Range_End  ] = DevSlot_Ideal - 1;
        }
    }
    else /* Loop_Index != 0xFF */
    {
        /* Valid AL_PA: Use Loop_Index-based DevSlot in Domain/Area-based DevSlot_Bucket */

        DevSlot_Bucket_Min =   (  (  (Domain_Address % NumDomains)
                                   * NumAreasPerDomain            )
                                + (Area_Address % NumAreasPerDomain) )
                             * NumDevSlotsPerArea;

        DevSlot_Bucket_Max = DevSlot_Bucket_Min + NumDevSlotsPerArea - 1;

        DevSlot_Ideal      =   DevSlot_Bucket_Min
                             + (Loop_Index % NumDevSlotsPerArea);

        if (DevSlot_Ideal == DevSlot_Bucket_Min)
        {
            /* Only a simple DevSlot_Range needed for this DevSlot_Bucket */

            DevSlot_Ranges                        = 1;

            DevSlot_Range[0][DevSlot_Range_Start] = DevSlot_Bucket_Min;
            DevSlot_Range[0][DevSlot_Range_End  ] = DevSlot_Bucket_Max;
        }
        else /* DevSlot_Ideal == DevSlot_Bucket_Min */
        {
            /* Two DevSlot_Ranges needed for this DevSlot_Bucket */

            DevSlot_Ranges                        = 2;

            DevSlot_Range[0][DevSlot_Range_Start] = DevSlot_Ideal;
            DevSlot_Range[0][DevSlot_Range_End  ] = DevSlot_Bucket_Max;

            DevSlot_Range[1][DevSlot_Range_Start] = DevSlot_Bucket_Min;
            DevSlot_Range[1][DevSlot_Range_End  ] = DevSlot_Ideal - 1;
        }

        if (DevSlot_Bucket_Max < DevSlot_Last)
        {
            /* Additional DevSlot_Range for DevSlot_Buckets after DevSlot_Ideal Bucket */

            DevSlot_Range[DevSlot_Ranges][DevSlot_Range_Start]  = DevSlot_Bucket_Max + 1;
            DevSlot_Range[DevSlot_Ranges][DevSlot_Range_End  ]  = DevSlot_Last;

            DevSlot_Ranges                                     += 1;
        }

        if (DevSlot_Bucket_Min > 0)
        {
            /* Additional DevSlot_Range for DevSlot_Buckets before DevSlot_Ideal Bucket */

            DevSlot_Range[DevSlot_Ranges][DevSlot_Range_Start]  = 0;
            DevSlot_Range[DevSlot_Ranges][DevSlot_Range_End  ]  = DevSlot_Bucket_Min - 1;

            DevSlot_Ranges                                     += 1;
        }
    }

    /* First, see if this Port is already in a DevSlot */

    for (DevSlot_Range_Index = 0;
         DevSlot_Range_Index < DevSlot_Ranges;
         DevSlot_Range_Index++)
    {
        for (DevSlot_ToReturn  = DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_Start];
             DevSlot_ToReturn <= DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_End  ];
             DevSlot_ToReturn++)
        {
            SlotWWN = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevSlot_ToReturn * SlotWWN_size));

            if (    (SlotWWN->Slot_Status == SlotWWN_Slot_Status_InUse)
                 && (DevThreadMatchWWN( FindWWN,
                                        &(SlotWWN->Slot_PortWWN)
                                      )                         == agTRUE) )
            {
                SlotWWN->Slot_Domain_Address = Domain_Address;
                SlotWWN->Slot_Area_Address   = Area_Address;
                SlotWWN->Slot_Loop_Address   = Loop_Address;

                return DevSlot_ToReturn;
            }
        }
    }

    /* Since not found, see if there is room to insert this Port */

    for (DevSlot_Range_Index = 0;
         DevSlot_Range_Index < DevSlot_Ranges;
         DevSlot_Range_Index++)
    {
        for (DevSlot_ToReturn  = DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_Start];
             DevSlot_ToReturn <= DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_End  ];
             DevSlot_ToReturn++)
        {
            SlotWWN = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevSlot_ToReturn * SlotWWN_size));

            if (SlotWWN->Slot_Status == SlotWWN_Slot_Status_Empty)
            {
                SlotWWN->Slot_Status         = SlotWWN_Slot_Status_InUse;

                SlotWWN->Slot_Domain_Address = Domain_Address;
                SlotWWN->Slot_Area_Address   = Area_Address;
                SlotWWN->Slot_Loop_Address   = Loop_Address;

                SlotWWN->Slot_PortWWN[0]     = (*FindWWN)[0];
                SlotWWN->Slot_PortWWN[1]     = (*FindWWN)[1];
                SlotWWN->Slot_PortWWN[2]     = (*FindWWN)[2];
                SlotWWN->Slot_PortWWN[3]     = (*FindWWN)[3];
                SlotWWN->Slot_PortWWN[4]     = (*FindWWN)[4];
                SlotWWN->Slot_PortWWN[5]     = (*FindWWN)[5];
                SlotWWN->Slot_PortWWN[6]     = (*FindWWN)[6];
                SlotWWN->Slot_PortWWN[7]     = (*FindWWN)[7];

                return DevSlot_ToReturn;
            }
        }
    }

    /* No room, so see if some DevSlots can be reclaimed */

    /* First, mark all DevSlots (potentially) Stale (since they are all InUse currently) */

    SlotWWN = SlotWWN_First;

    for (DevSlot_ToReturn  = 0;
         DevSlot_ToReturn <= DevSlot_Last;
         DevSlot_ToReturn++)
    {
        SlotWWN->Slot_Status = SlotWWN_Slot_Status_Stale;

        SlotWWN++;
    }

    if (   (CThread->DeviceSelf != (DevThread_t *)agNULL)
        && (CThread->DeviceSelf->DevSlot != DevSlot_Invalid))
    {
        /* DeviceSelf is not on any list, so if it exists (it should) & DevSlot allocated, mark DevSlot as InUse */

        SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (CThread->DeviceSelf->DevSlot * SlotWWN_size));

        SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
    }

    /* Walk CThread->Active_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Active_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Active_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Walk CThread->Unknown_Slot_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Unknown_Slot_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Unknown_Slot_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Walk CThread->Slot_Searching_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Slot_Searching_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Slot_Searching_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Walk CThread->Prev_Active_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Prev_Active_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Prev_Active_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Walk CThread->Prev_Unknown_Slot_DevLink, marking each DevSlot referenced as InUse */

    DevThread_DevLink = CThread->Prev_Unknown_Slot_DevLink.flink;

    while (DevThread_DevLink != &(CThread->Prev_Unknown_Slot_DevLink))
    {
        DevThread = hpObjectBase(
                                  DevThread_t,
                                  DevLink,
                                  DevThread_DevLink
                                );

        if (DevThread->DevSlot != DevSlot_Invalid)
        {
            SlotWWN              = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevThread->DevSlot * SlotWWN_size));

            SlotWWN->Slot_Status = SlotWWN_Slot_Status_InUse;
        }

        DevThread_DevLink = DevThread_DevLink->flink;
    }

    /* Finally, free up (i.e. mark as Empty) Stale DevSlots */

    SlotWWN = SlotWWN_First;

    for (DevSlot_ToReturn  = 0;
         DevSlot_ToReturn <= DevSlot_Last;
         DevSlot_ToReturn++)
    {
        if (SlotWWN->Slot_Status == SlotWWN_Slot_Status_Stale)
        {
            SlotWWN->Slot_Status = SlotWWN_Slot_Status_Empty;
        }

        SlotWWN++;
    }

    /* Now repeat the search for an empty DevSlot */

    for (DevSlot_Range_Index = 0;
         DevSlot_Range_Index < DevSlot_Ranges;
         DevSlot_Range_Index++)
    {
        for (DevSlot_ToReturn  = DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_Start];
             DevSlot_ToReturn <= DevSlot_Range[DevSlot_Range_Index][DevSlot_Range_End  ];
             DevSlot_ToReturn++)
        {
            SlotWWN = (SlotWWN_t *)((os_bit8 *)SlotWWN_First + (DevSlot_ToReturn * SlotWWN_size));

            if (SlotWWN->Slot_Status == SlotWWN_Slot_Status_Empty)
            {
                SlotWWN->Slot_Status         = SlotWWN_Slot_Status_InUse;

                SlotWWN->Slot_Domain_Address = Domain_Address;
                SlotWWN->Slot_Area_Address   = Area_Address;
                SlotWWN->Slot_Loop_Address   = Loop_Address;

                SlotWWN->Slot_PortWWN[0]     = (*FindWWN)[0];
                SlotWWN->Slot_PortWWN[1]     = (*FindWWN)[1];
                SlotWWN->Slot_PortWWN[2]     = (*FindWWN)[2];
                SlotWWN->Slot_PortWWN[3]     = (*FindWWN)[3];
                SlotWWN->Slot_PortWWN[4]     = (*FindWWN)[4];
                SlotWWN->Slot_PortWWN[5]     = (*FindWWN)[5];
                SlotWWN->Slot_PortWWN[6]     = (*FindWWN)[6];
                SlotWWN->Slot_PortWWN[7]     = (*FindWWN)[7];

                return DevSlot_ToReturn;
            }
        }
    }

    return DevSlot_Invalid;
}

void DevThreadFreeSlot(
                        agRoot_t  *hpRoot,
                        DevSlot_t  DevSlot
                      )
{
    CThread_t                  *CThread                  = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SlotWWN_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SlotWWN);
    os_bit32                       SlotWWN_size             = SlotWWN_MemoryDescriptor->elementSize;
    SlotWWN_t                  *SlotWWN;

    SlotWWN = (SlotWWN_t *)((os_bit8 *)(SlotWWN_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr) + (DevSlot * SlotWWN_size));

    SlotWWN->Slot_Status         = SlotWWN_Slot_Status_Empty;

    SlotWWN->Slot_Domain_Address = 0;
    SlotWWN->Slot_Area_Address   = 0;
    SlotWWN->Slot_Loop_Address   = 0;

    SlotWWN->Slot_PortWWN[0]     = 0;
    SlotWWN->Slot_PortWWN[1]     = 0;
    SlotWWN->Slot_PortWWN[2]     = 0;
    SlotWWN->Slot_PortWWN[3]     = 0;
    SlotWWN->Slot_PortWWN[4]     = 0;
    SlotWWN->Slot_PortWWN[5]     = 0;
    SlotWWN->Slot_PortWWN[6]     = 0;
    SlotWWN->Slot_PortWWN[7]     = 0;
}

/*+
CDBThread Management
-*/

void CDBThreadsInitializeFreeList(
                                   agRoot_t *hpRoot
                                 )
{
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    fiMemMapMemoryDescriptor_t *SEST_MemoryDescriptor      = &(CThread->Calculation.MemoryLayout.SEST);
    fiMemMapMemoryDescriptor_t *FCP_CMND_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.FCP_CMND);
    fiMemMapMemoryDescriptor_t *FCP_RESP_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.FCP_RESP);
    CDBThread_t                *CDBThread                  = CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    SEST_t                     *SEST_Ptr;
    os_bit32                       SEST_Offset;
    FCHS_t                     *FCP_CMND_Ptr;
    os_bit32                       FCP_CMND_Offset;
    os_bit32                       FCP_CMND_Lower32;
    FCHS_t                     *FCP_RESP_Ptr;
    os_bit32                       FCP_RESP_Offset;
    os_bit32                       FCP_RESP_Lower32;
    os_bit32                       CDBThread_size             = CDBThread_MemoryDescriptor->elementSize;
    os_bit32                       SEST_size                  = SEST_MemoryDescriptor->elementSize;
    os_bit32                       FCP_CMND_size              = FCP_CMND_MemoryDescriptor->elementSize;
    os_bit32                       FCP_RESP_size              = FCP_RESP_MemoryDescriptor->elementSize;
    fiMemMapMemoryLocation_t    SEST_memLoc                = SEST_MemoryDescriptor->memLoc;
    fiMemMapMemoryLocation_t    FCP_CMND_memLoc            = FCP_CMND_MemoryDescriptor->memLoc;
    fiMemMapMemoryLocation_t    FCP_RESP_memLoc            = FCP_RESP_MemoryDescriptor->memLoc;
    os_bit32                       total_CDBThreads           = CDBThread_MemoryDescriptor->elements;
    os_bit32                       CDBThread_index;

    if (SEST_memLoc == inCardRam)
    {
        SEST_Ptr         = (SEST_t *)agNULL;
        SEST_Offset      = SEST_MemoryDescriptor->addr.CardRam.cardRamOffset;
    }
    else /* SEST_memLoc == inDmaMemory */
    {
        SEST_Ptr         = (SEST_t *)(SEST_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        SEST_Offset      = 0;
    }

    if (FCP_CMND_memLoc == inCardRam)
    {
        FCP_CMND_Ptr     = (FCHS_t *)agNULL;
        FCP_CMND_Offset  = FCP_CMND_MemoryDescriptor->addr.CardRam.cardRamOffset;
        FCP_CMND_Lower32 = FCP_CMND_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* FCP_CMND_memLoc == inDmaMemory */
    {
        FCP_CMND_Ptr     = (FCHS_t *)(FCP_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        FCP_CMND_Offset  = 0;
        FCP_CMND_Lower32 = FCP_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
    }

    if (FCP_RESP_memLoc == inCardRam)
    {
        FCP_RESP_Ptr     = (FCHS_t *)agNULL;
        FCP_RESP_Offset  = FCP_RESP_MemoryDescriptor->addr.CardRam.cardRamOffset;
        FCP_RESP_Lower32 = FCP_RESP_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* FCP_RESP_memLoc == inDmaMemory */
    {
        FCP_RESP_Ptr     = (FCHS_t *)(FCP_RESP_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        FCP_RESP_Offset  = 0;
        FCP_RESP_Lower32 = FCP_RESP_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
    }

    CThread->IOsStartedThisTimerTick      = 0;
    CThread->IOsCompletedThisTimerTick    = 0;
    CThread->IOsIntCompletedThisTimerTick = 0;
    CThread->IOsActive                    = 0;
    CThread->IOsStartedSinceISR           = 0;

#ifdef _Enforce_MaxCommittedMemory_
    CThread->CommittedMemory              = 0;
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    fiListInitHdr(
                   &(CThread->Free_CDBLink)
                 );

    for (CDBThread_index = 0;
         CDBThread_index < total_CDBThreads;
         CDBThread_index++)
    {
        CDBThread->Active                    = agFALSE;
        CDBThread->ExchActive                = agFALSE;

        CDBThread->hpIORequest               = (agIORequest_t *)agNULL;
        CDBThread->X_ID                      = (os_bit16)CDBThread_index;
        CDBThread->SEST_Ptr                  = SEST_Ptr;
        CDBThread->SEST_Offset               = SEST_Offset;
        CDBThread->FCP_CMND_Ptr              = FCP_CMND_Ptr;
        CDBThread->FCP_CMND_Offset           = FCP_CMND_Offset;
        CDBThread->FCP_CMND_Lower32          = FCP_CMND_Lower32;
        CDBThread->FCP_RESP_Ptr              = FCP_RESP_Ptr;
        CDBThread->FCP_RESP_Offset           = FCP_RESP_Offset;
        CDBThread->FCP_RESP_Lower32          = FCP_RESP_Lower32;

        CDBThread->CDB_CMND_Class            = SFThread_SF_CMND_Class_CDB_FCP;
        CDBThread->CDB_CMND_Type             = SFThread_SF_CMND_Type_NULL;
        CDBThread->CDB_CMND_State            = SFThread_SF_CMND_State_NULL;
        CDBThread->CDB_CMND_Status           = SFThread_SF_CMND_Status_NULL;

        CDBThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

        SFThreadInitializeRequest(
                                   &(CDBThread->SFThread_Request)
                                 );

        fiTimerInitializeRequest(
                                  &(CDBThread->Timer_Request)
                                );

        ESGLInitializeRequest(
                               &(CDBThread->ESGL_Request)
                             );

        fiListInitElement(
                           &(CDBThread->CDBLink)
                         );

        fiListEnqueueAtTail(
                             &(CDBThread->CDBLink),
                             &(CThread->Free_CDBLink)
                           );

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread + CDBThread_size);

        if (SEST_memLoc == inCardRam)
        {
            SEST_Offset     += SEST_size;
        }
        else /* SEST_memLoc == inDmaMemory */
        {
            SEST_Ptr        += 1;
        }

        if (FCP_CMND_memLoc == inCardRam)
        {
            FCP_CMND_Offset += FCP_CMND_size;
        }
        else /* FCP_CMND_memLoc == inDmaMemory */
        {
            FCP_CMND_Ptr     = (FCHS_t *)((os_bit8 *)FCP_CMND_Ptr + FCP_CMND_size);
        }

        if (FCP_RESP_memLoc == inCardRam)
        {
            FCP_RESP_Offset += FCP_RESP_size;
        }
        else /* FCP_RESP_memLoc == inDmaMemory */
        {
            FCP_RESP_Ptr     = (FCHS_t *)((os_bit8 *)FCP_RESP_Ptr + FCP_RESP_size);
        }

        FCP_CMND_Lower32    += FCP_CMND_size;
        FCP_RESP_Lower32    += FCP_RESP_size;
    }
}

CDBThread_t *CDBThreadAlloc(
                             agRoot_t          *hpRoot,
                             agIORequest_t     *hpIORequest,
                             agFCDev_t          hpFCDev,
                             agIORequestBody_t *hpRequestBody
                           )
{
    CThread_t   *CThread             = CThread_ptr(hpRoot);
    DevThread_t *DevThread           = DevThread_ptr(hpFCDev);
    fiList_t    *fiList_to_return;
    CDBThread_t *CDBThread_to_return;
    agFcpCmnd_t *FcpCmnd             = &(hpRequestBody->CDBRequest.FcpCmnd);
    os_bit32        Add_CommittedMemory;
#ifdef _Enforce_MaxCommittedMemory_
    os_bit32        New_CommittedMemory;
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    Add_CommittedMemory =   (FcpCmnd->FcpDL[0] << 24)
                          + (FcpCmnd->FcpDL[1] << 16)
                          + (FcpCmnd->FcpDL[2] <<  8)
                          + (FcpCmnd->FcpDL[3] <<  0);

#ifdef _Enforce_MaxCommittedMemory_
    New_CommittedMemory = CThread->CommittedMemory + Add_CommittedMemory;

    if (New_CommittedMemory > CThread->Calculation.Parameters.MaxCommittedMemory)
    {

        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "CDBThreadAlloc Fail - New_CommittedMemory(%X) > %X",
                    (char *)agNULL,(char *)agNULL,
                    New_CommittedMemory,
                    CThread->Calculation.Parameters.MaxCommittedMemory,
                    0,0,0,0,0,0);

        hpIORequest->fcData = (void *)agNULL;
        return (CDBThread_t *)agNULL;
    }
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_CDBLink)
                         );

    if (fiList_to_return == (fiList_t *)agNULL)
    {
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "CDBThreadAlloc Fail - No CDBThreads Left ! IOsActive %X CCnt %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread->IOsActive,
                    CThread->CDBpollingCount,
                    0,0,0,0,0,0);

        hpIORequest->fcData = (void *)agNULL;
        return (CDBThread_t *)agNULL;
    }

    CDBThread_to_return = hpObjectBase(
                                        CDBThread_t,
                                        CDBLink,
                                        fiList_to_return
                                      );
    /* If you want to drop a X_ID zero  do this
    if(CDBThread_to_return->X_ID == 0x0)
    {
        fiListEnqueueAtTail(
                             &(CDBThread_to_return->CDBLink),
                             &(CThread->Free_CDBLink)
                           );

        fiListDequeueFromHead(
                           &fiList_to_return,
                           &(CThread->Free_CDBLink)
                         );

        CDBThread_to_return = hpObjectBase(
                                            CDBThread_t,
                                            CDBLink,
                                            fiList_to_return
                                          );
    }
    */

    CDBThread_to_return->Active      = agTRUE;
    CDBThread_to_return->ExchActive  = agTRUE;

    CDBThread_to_return->ReSentIO    = agFALSE;
    CDBThread_to_return->TimeStamp   =  0;
    CDBThread_to_return->ActiveDuringLinkEvent = agFALSE;
    CDBThread_to_return->CompletionStatus = osIOInvalid;


    CDBThread_to_return->Device      = DevThread;
    CDBThread_to_return->hpIORequest = hpIORequest;
    CDBThread_to_return->CDBRequest  = &(hpRequestBody->CDBRequest);
    CDBThread_to_return->DataLength  = Add_CommittedMemory;

    CDBThread_to_return->SFThread_Request.SFThread = (SFThread_t * )agNULL;
    CThread->IOsStartedThisTimerTick += 1;
    CThread->IOsActive               += 1;

#ifdef FULL_FC_TAPE_DBG
    if( DevThread->FC_TapeDevice)
    {
        CDBThread_to_return->FC_Tape_Active = agTRUE;
        CDBThread_to_return->CDB_CMND_Class = SFThread_SF_CMND_Class_FC_Tape;
        CDBThread_to_return->CDB_CMND_Type  = SFThread_SF_CMND_Type_CDB_FC_Tape;
    }
    else
    {
#endif /* FULL_FC_TAPE_DBG */
        CDBThread_to_return->FC_Tape_Active = agFALSE;
        CDBThread_to_return->CDB_CMND_Class = SFThread_SF_CMND_Class_CDB_FCP;
        CDBThread_to_return->CDB_CMND_Type  = SFThread_SF_CMND_Type_CDB;
#ifdef FULL_FC_TAPE_DBG
    }
#endif /* FULL_FC_TAPE_DBG */

    CDBThread_to_return->CDB_CMND_State            = SFThread_SF_CMND_State_NULL;
    CDBThread_to_return->CDB_CMND_Status           = SFThread_SF_CMND_Status_NULL;


#ifdef _Enforce_MaxCommittedMemory_
    CThread->CommittedMemory = New_CommittedMemory;
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    hpIORequest->fcData = (void *)CDBThread_to_return;

    fiListEnqueueAtTail(
                         fiList_to_return,
                         &(DevThread->Send_IO_CDBLink)
                       );

    return CDBThread_to_return;
}

void CDBThreadFree(
                    agRoot_t    *hpRoot,
                    CDBThread_t *CDBThread
                  )
{
    CThread_t *CThread        = CThread_ptr(hpRoot);
    fiList_t  *fiList_to_free = &(CDBThread->CDBLink);

    if (!(CDBThread->Active))
        fiLogDebugString(hpRoot,
                FCMainLogErrorLevel,
                "CDBThreadFree: Freeing already freed Cdb %p",
                (char *)agNULL,(char *)agNULL,
                CDBThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    osDebugBreakpoint(
                       hpRoot,
                       ((CDBThread->Active == agTRUE) ? agFALSE : agTRUE),
                       "CDBThreadFree(): CDBThread->Active != agTRUE"
                     );

    if (CDBThread->ESGL_Request.State != ESGL_Request_InActive)
    {
        if (CDBThread->ESGL_Request.State == ESGL_Request_Pending)
        {
            CThread->FuncPtrs.ESGLAllocCancel(
                                               hpRoot,
                                               &(CDBThread->ESGL_Request)
                                             );
        }
        else /* CDBThread->ESGL_Request.State == ESGL_Request_Granted */
        {
            CThread->FuncPtrs.ESGLFree(
                                        hpRoot,
                                        &(CDBThread->ESGL_Request)
                                      );
        }
    }

    if (CDBThread->SFThread_Request.State != SFThread_Request_InActive)
    {
        if (CDBThread->SFThread_Request.State == SFThread_Request_Pending)
        {
            SFThreadAllocCancel(
                                 hpRoot,
                                 &(CDBThread->SFThread_Request)
                               );
        }
        else /* CDBThread->SFThread_Request.State == SFThread_Request_Granted */
        {
            fiLogDebugString(hpRoot,
                            CDBStateAbortPathLevel,
                            "In %s - SF %p SFState = %d CCnt %x",
                            "CDBThreadFree",(char *)agNULL,
                            CDBThread->SFThread_Request.SFThread,(void *)agNULL,
                            (os_bit32)CDBThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            CThread->CDBpollingCount,
                            0,0,0,0,0,0);

           /*  CThread->pollingCount--; */
            SFThreadFree(
                          hpRoot,
                          &(CDBThread->SFThread_Request)
                        );
        }
    }

    if (CDBThread->Timer_Request.Active == agTRUE)
    {
        fiTimerStop(
                     &(CDBThread->Timer_Request)
                   );
    }

    CDBThread->hpIORequest = (agIORequest_t *)agNULL;

    fiListDequeueThis(
                       fiList_to_free
                     );

    CDBThread->Active = agFALSE;

    CThread->IOsCompletedThisTimerTick += 1;
    CThread->IOsActive                 -= 1;

#ifdef _Enforce_MaxCommittedMemory_
    CThread->CommittedMemory           -= CDBThread->DataLength;
#endif /* _Enforce_MaxCommittedMemory_ was defined */

    fiListEnqueueAtTail(
                         fiList_to_free,
                         &(CThread->Free_CDBLink)
                       );
}

/*+
SFThread Management
-*/

void SFThreadsInitializeFreeList(
                                  agRoot_t *hpRoot
                                )
{
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    fiMemMapMemoryDescriptor_t *SF_CMND_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SF_CMND);
    SFThread_t                 *SFThread                  = SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    FCHS_t                     *SF_CMND_Ptr;
    os_bit32                       SF_CMND_Offset;
    os_bit32                       SF_CMND_Lower32;
    os_bit32                       SFThread_size             = SFThread_MemoryDescriptor->elementSize;
    os_bit32                       SF_CMND_size              = SF_CMND_MemoryDescriptor->elementSize;
    fiMemMapMemoryLocation_t    SF_CMND_memLoc            = SF_CMND_MemoryDescriptor->memLoc;
    os_bit32                       total_SFThreads           = SFThread_MemoryDescriptor->elements;
    os_bit32                       SFThread_X_ID_Offset      = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                       SFThread_index;

    if (SF_CMND_memLoc == inCardRam)
    {
        SF_CMND_Ptr     = (FCHS_t *)agNULL;
        SF_CMND_Offset  = SF_CMND_MemoryDescriptor->addr.CardRam.cardRamOffset;
        SF_CMND_Lower32 = SF_CMND_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* SF_CMND_memLoc == inDmaMemory */
    {
        SF_CMND_Ptr     = (FCHS_t *)(SF_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr);
        SF_CMND_Offset  = 0;
        SF_CMND_Lower32 = SF_CMND_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
    }

    fiListInitHdr(
                   &(CThread->SFThread_Wait_Link)
                 );
    fiListInitHdr(
                   &(CThread->Free_SFLink)
                 );

    for (SFThread_index = 0;
         SFThread_index < total_SFThreads;
         SFThread_index++)
    {
        SFThread->X_ID            = (X_ID_t)(SFThread_index + SFThread_X_ID_Offset);
        SFThread->SF_CMND_Ptr     = SF_CMND_Ptr;
        SFThread->SF_CMND_Offset  = SF_CMND_Offset;
        SFThread->SF_CMND_Lower32 = SF_CMND_Lower32;
        SFThread->SF_CMND_Class   = SFThread_SF_CMND_Class_NULL;
        SFThread->SF_CMND_Type    = SFThread_SF_CMND_Type_NULL;
        SFThread->SF_CMND_State   = SFThread_SF_CMND_State_NULL;
        SFThread->SF_CMND_Status  = SFThread_SF_CMND_Status_NULL;

        fiTimerInitializeRequest(
                                  &(SFThread->Timer_Request)
                                );

        fiListInitElement(
                           &(SFThread->SFLink)
                         );

        fiListEnqueueAtTail(
                             &(SFThread->SFLink),
                             &(CThread->Free_SFLink)
                           );

        SFThread = (SFThread_t *)((os_bit8 *)SFThread + SFThread_size);

        if (SF_CMND_memLoc == inCardRam)
        {
            SF_CMND_Offset += SF_CMND_size;
        }
        else /* SF_CMND_memLoc == inDmaMemory */
        {
            SF_CMND_Ptr     = (FCHS_t *)((os_bit8 *)SF_CMND_Ptr + SF_CMND_size);
        }

        SF_CMND_Lower32    += SF_CMND_size;
    }
}

void SFThreadInitializeRequest(
                                SFThread_Request_t *SFThread_Request
                              )
{
    fiListInitElement(
                       &(SFThread_Request->SFThread_Wait_Link)
                     );

    SFThread_Request->SFThread = (SFThread_t *)agNULL;
    SFThread_Request->State    = SFThread_Request_InActive;
}

void SFThreadAlloc(
                    agRoot_t           *hpRoot,
                    SFThread_Request_t *SFThread_Request
                  )
{
    CThread_t *CThread = CThread_ptr(hpRoot);
    fiList_t  *fiList;

    if(SFThread_Request->State != SFThread_Request_InActive)
    {
        fiLogString(hpRoot,
                "In %s  %x != SFThread_Request_InActive",
                "SFThreadAlloc",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                SFThread_Request->State,
                0,0,0,0,0,0,0);
    }

    osDebugBreakpoint(
                       hpRoot,
                       ((SFThread_Request->State == SFThread_Request_InActive) ? agFALSE : agTRUE),
                       "SFThreadAlloc(): SFThread_Request->State != SFThread_Request_InActive"
                     );

    fiListDequeueFromHead(
                           &fiList,
                           &(CThread->Free_SFLink)
                         );

    if (fiList == (fiList_t *)agNULL)
    {
        SFThread_Request->State = SFThread_Request_Pending;
        /*
        fiLogString(hpRoot,
                "In %s %s     event %d",
                "SFThreadAlloc","SFThread_Request_Pending",
                (void *)agNULL,(void *)agNULL,
                SFThread_Request->eventRecord_to_send.event,
                0,0,0,0,0,0,0);
        */
        fiListEnqueueAtTail(
                             SFThread_Request,
                             &(CThread->SFThread_Wait_Link)
                           );
    }
    else /* fiList != (fiList_t *)agNULL */
    {
        SFThread_Request->SFThread = hpObjectBase(
                                                   SFThread_t,
                                                   SFLink,
                                                   fiList
                                                 );

        SFThread_Request->State = SFThread_Request_Granted;
        /*
        fiLogString(hpRoot,
                "In %s %s = %p event %d",
                "SFThreadAlloc","SFThread_Request_Granted",
                SFThread_Request->SFThread,(void *)agNULL,
                SFThread_Request->eventRecord_to_send.event,
                0,0,0,0,0,0,0);
        */
        fiListInitHdr(&(SFThread_Request->SFThread->SFLink));

        fiSendEvent(
                     SFThread_Request->eventRecord_to_send.thread,
                     SFThread_Request->eventRecord_to_send.event
                   );
    }
}

void SFThreadAllocCancel(
                          agRoot_t           *hpRoot,
                          SFThread_Request_t *SFThread_Request
                        )
{

    if(SFThread_Request->State != SFThread_Request_Pending)
    {
        fiLogString(hpRoot,
                "In %s  %x != SFThread_Request_Pending",
                "SFThreadAllocCancel",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                SFThread_Request->State,
                0,0,0,0,0,0,0);
    }

    osDebugBreakpoint(
                       hpRoot,
                       ((SFThread_Request->State == SFThread_Request_Pending) ? agFALSE : agTRUE),
                       "SFThreadAllocCancel(): SFThread_Request->State != SFThread_Request_Pending"
                     );

    fiListDequeueThis(
                       SFThread_Request
                     );

    SFThread_Request->State = SFThread_Request_InActive;
}

void SFThreadFree(
                   agRoot_t           *hpRoot,
                   SFThread_Request_t *SFThread_Request
                 )
{
    CThread_t          *CThread                  = CThread_ptr(hpRoot);
    SFThread_t         *SFThread                 = SFThread_Request->SFThread;
    fiList_t           *fiList;
    SFThread_Request_t *Pending_SFThread_Request;

    if(SFThread_Request->State != SFThread_Request_Granted)
    {
        fiLogString(hpRoot,
                "In %s  %x != SFThread_Request_Granted",
                "SFThreadFree",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                SFThread_Request->State,
                0,0,0,0,0,0,0);
    }
    osDebugBreakpoint(
                       hpRoot,
                       ((SFThread_Request->State == SFThread_Request_Granted) ? agFALSE : agTRUE),
                       "SFThreadFree(): SFThread_Request->State != SFThread_Request_Granted"
                     );


    fiSendEvent(&SFThread->thread_hdr,SFEventReset);

    if (SFThread->Timer_Request.Active == agTRUE)
    {
        fiTimerStop(
                     &(SFThread->Timer_Request)
                   );
    }

    SFThread_Request->SFThread = (SFThread_t *)agNULL;
    SFThread_Request->State    = SFThread_Request_InActive;

    SFThread->SF_CMND_Class    = SFThread_SF_CMND_Class_NULL;
    SFThread->SF_CMND_Type     = SFThread_SF_CMND_Type_NULL;
    SFThread->SF_CMND_State    = SFThread_SF_CMND_State_NULL;
    SFThread->SF_CMND_Status   = SFThread_SF_CMND_Status_NULL;
    
    fiListDequeueFromHead(
                           &fiList,
                           &(CThread->SFThread_Wait_Link)
                         );

    if (fiList == (fiList_t *)agNULL)
    {
        fiListEnqueueAtTail(
                             &(SFThread->SFLink),
                             &(CThread->Free_SFLink)
                           );
    }
    else /* fiList != (fiList_t *)agNULL */
    {
        Pending_SFThread_Request = hpObjectBase(
                                                 SFThread_Request_t,
                                                 SFThread_Wait_Link,
                                                 fiList
                                               );

        Pending_SFThread_Request->SFThread = SFThread;
        Pending_SFThread_Request->State    = SFThread_Request_Granted;

        fiSendEvent(
                     Pending_SFThread_Request->eventRecord_to_send.thread,
                     Pending_SFThread_Request->eventRecord_to_send.event
                   );
    }
}

/*+
ESGL Management
-*/

void ESGLInitializeFreeList(
                             agRoot_t *hpRoot
                           )
{
    CThread_t                  *CThread               = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *ESGL_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.ESGL);
    fiMemMapMemoryLocation_t    ESGL_memLoc           = ESGL_MemoryDescriptor->memLoc;
    os_bit32                    ESGL_Upper32;
    os_bit32                    ESGL_Lower32;
    os_bit32                    ESGL_Offset;
    SG_Element_t               *ESGL;
    os_bit32                    ESGL_size             = ESGL_MemoryDescriptor->elementSize;
    os_bit32                    ESGL_Next_Lower32;
    os_bit32                    ESGL_Next_Offset;
    SG_Element_t               *ESGL_Next;
    os_bit32                    ESGL_Chain_Offset;
    SG_Element_t               *ESGL_Chain;
    os_bit32                    total_ESGLs           = ESGL_MemoryDescriptor->elements;
    os_bit32                    ESGL_index;
    SG_Element_t                ESGL_Chain_To_Write;
    ESGL = ESGL_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr;

    if (ESGL_memLoc == inCardRam)
    {
        ESGL_Offset  = ESGL_MemoryDescriptor->addr.CardRam.cardRamOffset;
        ESGL_Lower32 = ESGL_Offset + CThread->Calculation.Input.cardRamLower32;
    }
    else /* ESGL_memLoc == inDmaMemory */
    {
        ESGL_Lower32 = ESGL_MemoryDescriptor->addr.DmaMemory.dmaMemoryLower32;
        ESGL_Offset  = ESGL_Lower32 - CThread->Calculation.Input.dmaMemoryLower32;
        ESGL         = ESGL_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr;
    }

    ESGL_Upper32 = CThread->Calculation.Input.cardRamUpper32;

    fiListInitHdr(
                   &(CThread->ESGL_Wait_Link)
                 );

    CThread->Free_ESGL_count        = total_ESGLs;
    CThread->offsetToFirstFree_ESGL = ESGL_Offset;

    for (ESGL_index = 0;
         ESGL_index < total_ESGLs;
         ESGL_index++)
    {
        ESGL_Next_Lower32 = ESGL_Lower32 + ESGL_size;

        if (ESGL_index == (total_ESGLs - 1))
        {
            ESGL_Chain_To_Write.U32_Len = 0;
            ESGL_Chain_To_Write.L32     = 0;
        }
        else /* ESGL_index != (total_ESGLs - 1) */
        {
            ESGL_Chain_To_Write.U32_Len = (~SG_Element_Chain_Res_MASK)
                                          & ((ESGL_Upper32 << SG_Element_U32_SHIFT)
                                             | SG_Element_Len_MASK);
            ESGL_Chain_To_Write.L32     = ESGL_Next_Lower32;
        }

        if (ESGL_memLoc == inCardRam)
        {
            ESGL_Next_Offset  = ESGL_Offset  + ESGL_size;
            ESGL_Chain_Offset = ESGL_Next_Offset - sizeof(SG_Element_t);

            osCardRamWriteBlock(
                                 hpRoot,
                                 ESGL_Chain_Offset,
                                 (os_bit8 *)&ESGL_Chain_To_Write,
                                 sizeof(SG_Element_t)
                               );

            ESGL_Offset = ESGL_Next_Offset;
        }
        else /* ESGL_memLoc == inDmaMemory */
        {
            ESGL_Next   = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_size);
            ESGL_Chain  = ESGL_Next - 1;

            *ESGL_Chain = ESGL_Chain_To_Write;

            ESGL        = ESGL_Next;
        }

        ESGL_Lower32 = ESGL_Next_Lower32;
    }
}

void ESGLInitializeRequest(
                            ESGL_Request_t *ESGL_Request
                          )
{
    fiListInitElement(
                       &(ESGL_Request->ESGL_Wait_Link)
                     );

    ESGL_Request->num_ESGL      = 0;
    ESGL_Request->offsetToFirst = 0;
    ESGL_Request->State         = ESGL_Request_InActive;
}

void ESGLAlloc(
                agRoot_t       *hpRoot,
                ESGL_Request_t *ESGL_Request
              )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inCardRam)
    {
        ESGLAlloc_OnCard(
                          hpRoot,
                          ESGL_Request
                        );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory */
    {
        ESGLAlloc_OffCard(
                           hpRoot,
                           ESGL_Request
                         );
    }
}

void ESGLAlloc_OnCard(
                       agRoot_t       *hpRoot,
                       ESGL_Request_t *ESGL_Request
                     )
{
    CThread_t    *CThread             = CThread_ptr(hpRoot);
    os_bit32         ESGL_deltaToChain   = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32         ESGL_deltaToU32_Len = hpFieldOffset(
                                                       SG_Element_t,
                                                       U32_Len
                                                     );
    os_bit32         ESGL_deltaToL32     = hpFieldOffset(
                                                       SG_Element_t,
                                                       L32
                                                     );
    os_bit32         ESGLs_Needed        = ESGL_Request->num_ESGL;
    os_bit32         ESGL_offset;
    os_bit32         ESGL_Chain = 0;
    os_bit32         cardRamLower32      = CThread->Calculation.Input.cardRamLower32;


    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_InActive) ? agFALSE : agTRUE),
                       "ESGLAlloc_OnCard(): ESGL_Request->State != ESGL_Request_InActive"
                     );

    if ((ESGLs_Needed > CThread->Free_ESGL_count) ||
        (fiListNotEmpty(
                         &(CThread->ESGL_Wait_Link)
                       )))
    {
        ESGL_Request->State = ESGL_Request_Pending;

        fiListEnqueueAtTail(
                             ESGL_Request,
                             &(CThread->ESGL_Wait_Link)
                           );
    }
    else /* (ESGLs_Needed <= CThread->Free_ESGL_count) &&
            (fiListEmpty(
                          &(CThread->ESGL_Wait_Link)
                        )) */
    {
        ESGL_offset = CThread->offsetToFirstFree_ESGL;

        ESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count    -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = ESGL_offset + ESGL_deltaToChain;

            ESGL_offset   = osCardRamReadBit32(
                                                hpRoot,
                                                ESGL_Chain + ESGL_deltaToL32
                                              )
                            - cardRamLower32;

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToU32_Len,
                             0
                           );
        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToL32,
                             0
                           );

        ESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     ESGL_Request->eventRecord_to_send.thread,
                     ESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLAlloc_OffCard(
                        agRoot_t       *hpRoot,
                        ESGL_Request_t *ESGL_Request
                      )
{
    CThread_t    *CThread           = CThread_ptr(hpRoot);
    os_bit32         ESGL_deltaToChain = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32         ESGLs_Needed      = ESGL_Request->num_ESGL;
    os_bit32         ESGL_offset;
    SG_Element_t *ESGL;
    SG_Element_t *ESGL_Chain = (SG_Element_t *)agNULL;
    os_bit32         dmaMemoryLower32  = CThread->Calculation.Input.dmaMemoryLower32;
    void         *dmaMemoryPtr      = CThread->Calculation.Input.dmaMemoryPtr;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_InActive) ? agFALSE : agTRUE),
                       "ESGLAlloc_OffCard(): ESGL_Request->State != ESGL_Request_InActive"
                     );

    if ((ESGLs_Needed > CThread->Free_ESGL_count) ||
        (fiListNotEmpty(
                         &(CThread->ESGL_Wait_Link)
                       )))
    {
        ESGL_Request->State = ESGL_Request_Pending;

        fiListEnqueueAtTail(
                             ESGL_Request,
                             &(CThread->ESGL_Wait_Link)
                           );
    }
    else /* (ESGLs_Needed <= CThread->Free_ESGL_count) &&
            (fiListEmpty(
                          &(CThread->ESGL_Wait_Link)
                        )) */
    {
        ESGL_offset = CThread->offsetToFirstFree_ESGL;
        ESGL        = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

        ESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count    -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_deltaToChain);

            ESGL_offset   = ESGL_Chain->L32 - dmaMemoryLower32;

            ESGL          = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        ESGL_Chain->U32_Len = 0;
        ESGL_Chain->L32     = 0;

        ESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     ESGL_Request->eventRecord_to_send.thread,
                     ESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLAllocCancel(
                      agRoot_t       *hpRoot,
                      ESGL_Request_t *ESGL_Request
                    )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inCardRam)
    {
        ESGLAllocCancel_OnCard(
                                hpRoot,
                                ESGL_Request
                              );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory */
    {
        ESGLAllocCancel_OffCard(
                                 hpRoot,
                                 ESGL_Request
                               );
    }
}

void ESGLAllocCancel_OnCard(
                             agRoot_t       *hpRoot,
                             ESGL_Request_t *ESGL_Request
                           )
{
    CThread_t      *CThread             = CThread_ptr(hpRoot);
    os_bit32           ESGL_deltaToChain   = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32           ESGL_deltaToU32_Len = hpFieldOffset(
                                                         SG_Element_t,
                                                         U32_Len
                                                       );
    os_bit32           ESGL_deltaToL32     = hpFieldOffset(
                                                         SG_Element_t,
                                                         L32
                                                       );
    os_bit32           ESGL_offset         = ESGL_Request->offsetToFirst;
    os_bit32           ESGL_Chain = 0;
    os_bit32           cardRamLower32      = CThread->Calculation.Input.cardRamLower32;
    ESGL_Request_t *NextESGL_Request;
    os_bit32           ESGLs_Needed;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_Pending) ? agFALSE : agTRUE),
                       "ESGLAllocCancel_OnCard(): ESGL_Request->State != ESGL_Request_Pending"
                     );

    fiListDequeueThis(
                       ESGL_Request
                     );

    ESGL_Request->State = ESGL_Request_InActive;

    while (fiListNotEmpty(
                           &(CThread->ESGL_Wait_Link)
                         ) &&
           (((ESGL_Request_t *)(CThread->ESGL_Wait_Link.flink))->num_ESGL <= CThread->Free_ESGL_count))
    {
        fiListDequeueFromHeadFast(
                                   &NextESGL_Request,
                                   &(CThread->ESGL_Wait_Link)
                                 );

        ESGLs_Needed = NextESGL_Request->num_ESGL;

        ESGL_offset = CThread->offsetToFirstFree_ESGL;

        NextESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count        -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = ESGL_offset + ESGL_deltaToChain;

            ESGL_offset   = osCardRamReadBit32(
                                                hpRoot,
                                                ESGL_Chain + ESGL_deltaToL32
                                              )
                            - cardRamLower32;

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToU32_Len,
                             0
                           );
        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToL32,
                             0
                           );

        NextESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     NextESGL_Request->eventRecord_to_send.thread,
                     NextESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLAllocCancel_OffCard(
                              agRoot_t       *hpRoot,
                              ESGL_Request_t *ESGL_Request
                            )
{
    CThread_t      *CThread           = CThread_ptr(hpRoot);
    os_bit32           ESGL_deltaToChain = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32           ESGL_offset       = ESGL_Request->offsetToFirst;
    SG_Element_t   *ESGL;
    SG_Element_t   *ESGL_Chain = (SG_Element_t   *)agNULL;
    os_bit32           dmaMemoryLower32  = CThread->Calculation.Input.dmaMemoryLower32;
    void           *dmaMemoryPtr      = CThread->Calculation.Input.dmaMemoryPtr;
    ESGL_Request_t *NextESGL_Request;
    os_bit32           ESGLs_Needed;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_Pending) ? agFALSE : agTRUE),
                       "ESGLAllocCancel_OffCard(): ESGL_Request->State != ESGL_Request_Pending"
                     );

    fiListDequeueThis(
                       ESGL_Request
                     );

    ESGL_Request->State = ESGL_Request_InActive;

    while (fiListNotEmpty(
                           &(CThread->ESGL_Wait_Link)
                         ) &&
           (((ESGL_Request_t *)(CThread->ESGL_Wait_Link.flink))->num_ESGL <= CThread->Free_ESGL_count))
    {
        fiListDequeueFromHeadFast(
                                   &NextESGL_Request,
                                   &(CThread->ESGL_Wait_Link)
                                 );

        ESGLs_Needed = NextESGL_Request->num_ESGL;

        ESGL_offset  = CThread->offsetToFirstFree_ESGL;
        ESGL         = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

        NextESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count        -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_deltaToChain);

            ESGL_offset   = ESGL_Chain->L32 - dmaMemoryLower32;

            ESGL          = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        ESGL_Chain->U32_Len = 0;
        ESGL_Chain->L32     = 0;

        NextESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     NextESGL_Request->eventRecord_to_send.thread,
                     NextESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLFree(
               agRoot_t       *hpRoot,
               ESGL_Request_t *ESGL_Request
             )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inCardRam)
    {
        ESGLFree_OnCard(
                         hpRoot,
                         ESGL_Request
                       );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory */
    {
        ESGLFree_OffCard(
                          hpRoot,
                          ESGL_Request
                        );
    }
}

void ESGLFree_OnCard(
                      agRoot_t       *hpRoot,
                      ESGL_Request_t *ESGL_Request
                    )
{
    CThread_t      *CThread             = CThread_ptr(hpRoot);
    os_bit32           ESGL_deltaToChain   = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32           ESGL_deltaToU32_Len = hpFieldOffset(
                                                         SG_Element_t,
                                                         U32_Len
                                                       );
    os_bit32           ESGL_deltaToL32     = hpFieldOffset(
                                                         SG_Element_t,
                                                         L32
                                                       );
    os_bit32           ESGLs_Freed         = ESGL_Request->num_ESGL;
    os_bit32           ESGL_offset         = ESGL_Request->offsetToFirst;
    os_bit32           ESGL_Chain = 0;
    os_bit32           cardRamUpper32      = CThread->Calculation.Input.cardRamUpper32;
    os_bit32           cardRamLower32      = CThread->Calculation.Input.cardRamLower32;
    ESGL_Request_t *NextESGL_Request;
    os_bit32           ESGLs_Needed;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_Granted) ? agFALSE : agTRUE),
                       "ESGLFree_OnCard(): ESGL_Request->State != ESGL_Request_Granted"
                     );

    CThread->Free_ESGL_count += ESGLs_Freed;

    while (ESGLs_Freed > 0)
    {
        ESGL_Chain   = ESGL_offset + ESGL_deltaToChain;

        ESGL_offset  = osCardRamReadBit32(
                                           hpRoot,
                                           ESGL_Chain + ESGL_deltaToL32
                                         )
                       - cardRamLower32;

        ESGLs_Freed -= 1;
    }

    osCardRamWriteBit32(
                         hpRoot,
                         ESGL_Chain + ESGL_deltaToU32_Len,
                         (~SG_Element_Chain_Res_MASK)
                         & ((cardRamUpper32 << SG_Element_U32_SHIFT)
                            | SG_Element_Len_MASK)
                       );
    osCardRamWriteBit32(
                         hpRoot,
                         ESGL_Chain + ESGL_deltaToL32,
                         CThread->offsetToFirstFree_ESGL + cardRamLower32
                       );

    CThread->offsetToFirstFree_ESGL = ESGL_Request->offsetToFirst;

    ESGL_Request->State = ESGL_Request_InActive;

    while (fiListNotEmpty(
                           &(CThread->ESGL_Wait_Link)
                         ) &&
           (((ESGL_Request_t *)(CThread->ESGL_Wait_Link.flink))->num_ESGL <= CThread->Free_ESGL_count))
    {
        fiListDequeueFromHeadFast(
                                   &NextESGL_Request,
                                   &(CThread->ESGL_Wait_Link)
                                 );

        ESGLs_Needed = NextESGL_Request->num_ESGL;

        ESGL_offset = CThread->offsetToFirstFree_ESGL;

        NextESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count        -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = ESGL_offset + ESGL_deltaToChain;

            ESGL_offset   = osCardRamReadBit32(
                                                hpRoot,
                                                ESGL_Chain + ESGL_deltaToL32
                                              )
                            - cardRamLower32;

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToU32_Len,
                             0
                           );
        osCardRamWriteBit32(
                             hpRoot,
                             ESGL_Chain + ESGL_deltaToL32,
                             0
                           );

        NextESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     NextESGL_Request->eventRecord_to_send.thread,
                     NextESGL_Request->eventRecord_to_send.event
                   );
    }
}

void ESGLFree_OffCard(
                       agRoot_t       *hpRoot,
                       ESGL_Request_t *ESGL_Request
                     )
{
    CThread_t      *CThread           = CThread_ptr(hpRoot);
    os_bit32           ESGL_deltaToChain = CThread->Calculation.MemoryLayout.ESGL.elementSize - sizeof(SG_Element_t);
    os_bit32           ESGLs_Freed       = ESGL_Request->num_ESGL;
    os_bit32           ESGL_offset       = ESGL_Request->offsetToFirst;
    SG_Element_t   *ESGL;
    SG_Element_t   *ESGL_Chain = (SG_Element_t   *)agNULL;
    os_bit32           dmaMemoryUpper32  = CThread->Calculation.Input.dmaMemoryUpper32;
    os_bit32           dmaMemoryLower32  = CThread->Calculation.Input.dmaMemoryLower32;
    void           *dmaMemoryPtr      = CThread->Calculation.Input.dmaMemoryPtr;
    ESGL_Request_t *NextESGL_Request;
    os_bit32           ESGLs_Needed;

    osDebugBreakpoint(
                       hpRoot,
                       ((ESGL_Request->State == ESGL_Request_Granted) ? agFALSE : agTRUE),
                       "ESGLFree_OffCard(): ESGL_Request->State != ESGL_Request_Granted"
                     );

    CThread->Free_ESGL_count += ESGLs_Freed;

    ESGL         = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

    while (ESGLs_Freed > 0)
    {
        ESGL_Chain   = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_deltaToChain);

        ESGL_offset  = ESGL_Chain->L32 - dmaMemoryLower32;

        ESGL         = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

        ESGLs_Freed -= 1;
    }

    ESGL_Chain->U32_Len = (~SG_Element_Chain_Res_MASK)
                          & ((dmaMemoryUpper32 << SG_Element_U32_SHIFT)
                             | SG_Element_Len_MASK);
    ESGL_Chain->L32     = CThread->offsetToFirstFree_ESGL + dmaMemoryLower32;

    CThread->offsetToFirstFree_ESGL = ESGL_Request->offsetToFirst;

    ESGL_Request->State = ESGL_Request_InActive;

    while (fiListNotEmpty(
                           &(CThread->ESGL_Wait_Link)
                         ) &&
           (((ESGL_Request_t *)(CThread->ESGL_Wait_Link.flink))->num_ESGL <= CThread->Free_ESGL_count))
    {
        fiListDequeueFromHeadFast(
                                   &NextESGL_Request,
                                   &(CThread->ESGL_Wait_Link)
                                 );

        ESGLs_Needed = NextESGL_Request->num_ESGL;

        ESGL_offset  = CThread->offsetToFirstFree_ESGL;
        ESGL         = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

        NextESGL_Request->offsetToFirst  = ESGL_offset;
        CThread->Free_ESGL_count        -= ESGLs_Needed;

        while (ESGLs_Needed > 0)
        {
            ESGL_Chain    = (SG_Element_t *)((os_bit8 *)ESGL + ESGL_deltaToChain);

            ESGL_offset   = ESGL_Chain->L32 - dmaMemoryLower32;

            ESGL          = (SG_Element_t *)((os_bit8 *)dmaMemoryPtr + ESGL_offset);

            ESGLs_Needed -= 1;
        }

        CThread->offsetToFirstFree_ESGL = ESGL_offset;

        ESGL_Chain->U32_Len = 0;
        ESGL_Chain->L32     = 0;

        NextESGL_Request->State = ESGL_Request_Granted;

        fiSendEvent(
                     NextESGL_Request->eventRecord_to_send.thread,
                     NextESGL_Request->eventRecord_to_send.event
                   );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\sa110.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/SA110.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures
  specific to the Intel StrongARM SA-110 Microprocessor

Reference Documents:

  SA-110 Microprocessor Technical Reference Manual
                   September 1998

  Advanced RISC Machines Architectural Reference Manual
    Edited by Dave Jaggar          ISBN 0-13-736299-4

  ARM System Architecture
    By Steve Furber                ISBN 0-201-40352-8

--*/

#ifndef __SA110_H__
#define __SA110_H__

/*+
System Control Coprocessor
-*/

#define SA110_Coprocessor                                                      p15

#define SA110_Coprocessor_ID                                                   c0
#define SA110_Coprocessor_Control                                              c1
#define SA110_Coprocessor_TranslationTableBase                                 c2
#define SA110_Coprocessor_DomainAccessControl                                  c3
#define SA110_Coprocessor_FaultStatus                                          c5
#define SA110_Coprocessor_FaultAddress                                         c6
#define SA110_Coprocessor_CacheControlOperations                               c7
#define SA110_Coprocessor_TLBOperations                                        c8
#define SA110_Coprocessor_TestClockIdleControl                                 c15

#define SA110_Coprocessor_Ignored_OPC_1                                        0
#define SA110_Coprocessor_Ignored_OPC_2                                        0
#define SA110_Coprocessor_Ignored_CRm                                          c0

#define SA110_Coprocessor_ID_MASK                                              (os_bit32)0xFFFFFFF0
#define SA110_Coprocessor_ID_VALUE                                             (os_bit32)0x4401A100

#define SA110_Coprocessor_ID_Revision_MASK                                     (os_bit32)0x0000000F

#define SA110_Coprocessor_Control_MASK                                         (os_bit32)0x0000138F
#define SA110_Coprocessor_Control_TEMPLATE                                     (os_bit32)0x00000070

#define SA110_Coprocessor_Control_ICache_Enabled                               (os_bit32)0x00001000
#define SA110_Coprocessor_Control_ROM_Protect                                  (os_bit32)0x00000200
#define SA110_Coprocessor_Control_System_Protect                               (os_bit32)0x00000100
#define SA110_Coprocessor_Control_Big_Endian                                   (os_bit32)0x00000080
#define SA110_Coprocessor_Control_WrtBuf_Enabled                               (os_bit32)0x00000008
#define SA110_Coprocessor_Control_DCache_Enabled                               (os_bit32)0x00000004
#define SA110_Coprocessor_Control_AddrFault_Enabled                            (os_bit32)0x00000002
#define SA110_Coprocessor_Control_MMU_Enabled                                  (os_bit32)0x00000001

#define SA110_Coprocessor_TranslationTableBase_MASK                            (os_bit32)0xFFFFC000

#define SA110_Coprocessor_DomainAccessControl_SIZE                             (os_bit32)0x02
#define SA110_Coprocessor_DomainAccessControl_MASK                             (os_bit32)0x00000003

#define SA110_Coprocessor_DomainAccessControl_NoAccess                         (os_bit32)0x00000000
#define SA110_Coprocessor_DomainAccessControl_Client                           (os_bit32)0x00000001
#define SA110_Coprocessor_DomainAccessControl_Reserved                         (os_bit32)0x00000002
#define SA110_Coprocessor_DomainAccessControl_Manager                          (os_bit32)0x00000003

#define SA110_Coprocessor_FaultStatus_ZeroBit_MASK                             (os_bit32)0x00000100

#define SA110_Coprocessor_FaultStatus_Domain_MASK                              (os_bit32)0x000000F0
#define SA110_Coprocessor_FaultStatus_Domain_SHIFT                             (os_bit32)0x04

#define SA110_Coprocessor_FaultStatus_Status_MASK                              (os_bit32)0x0000000F
#define SA110_Coprocessor_FaultStatus_Status_TerminalException                 (os_bit32)0x00000002
#define SA110_Coprocessor_FaultStatus_Status_VectorException                   (os_bit32)0x00000000
#define SA110_Coprocessor_FaultStatus_Status_Alignment_1                       (os_bit32)0x00000001
#define SA110_Coprocessor_FaultStatus_Status_Alignment_3                       (os_bit32)0x00000003
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnTransL1                 (os_bit32)0x0000000C
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnTransL2                 (os_bit32)0x0000000E
#define SA110_Coprocessor_FaultStatus_Status_TranslationSection                (os_bit32)0x00000005
#define SA110_Coprocessor_FaultStatus_Status_TranslationPage                   (os_bit32)0x00000007
#define SA110_Coprocessor_FaultStatus_Status_DomainSection                     (os_bit32)0x00000009
#define SA110_Coprocessor_FaultStatus_Status_DomainPage                        (os_bit32)0x0000000B
#define SA110_Coprocessor_FaultStatus_Status_PermissionSection                 (os_bit32)0x0000000D
#define SA110_Coprocessor_FaultStatus_Status_PermissionPage                    (os_bit32)0x0000000F
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnLineFetchSection        (os_bit32)0x00000004
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnLineFetchPage           (os_bit32)0x00000006
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnNonLineFetchSection     (os_bit32)0x00000008
#define SA110_Coprocessor_FaultStatus_Status_ExtAbortOnNonLineFetchPage        (os_bit32)0x0000000A

#define SA110_Coprocessor_CacheControlOperations_FlushID_OPC_2                 0
#define SA110_Coprocessor_CacheControlOperations_FlushID_CRm                   c7

#define SA110_Coprocessor_CacheControlOperations_FlushI_OPC_2                  0
#define SA110_Coprocessor_CacheControlOperations_FlushI_CRm                    c5

#define SA110_Coprocessor_CacheControlOperations_FlushD_OPC_2                  0
#define SA110_Coprocessor_CacheControlOperations_FlushD_CRm                    c6

#define SA110_Coprocessor_CacheControlOperations_FlushDEntry_OPC_2             1
#define SA110_Coprocessor_CacheControlOperations_FlushDEntry_CRm               c6

#define SA110_Coprocessor_CacheControlOperations_CleanDEntry_OPC_2             1
#define SA110_Coprocessor_CacheControlOperations_CleanDEntry_CRm               c10

#define SA110_Coprocessor_CacheControlOperations_DrainWriteBuffer_OPC_2        4
#define SA110_Coprocessor_CacheControlOperations_DrainWriteBuffer_CRm          c10

#define SA110_Coprocessor_TLBOperations_FlushID_OPC_2                          0
#define SA110_Coprocessor_TLBOperations_FlushID_CRm                            c7

#define SA110_Coprocessor_TLBOperations_FlushI_OPC_2                           0
#define SA110_Coprocessor_TLBOperations_FlushI_CRm                             c5

#define SA110_Coprocessor_TLBOperations_FlushD_OPC_2                           0
#define SA110_Coprocessor_TLBOperations_FlushD_CRm                             c6

#define SA110_Coprocessor_TLBOperations_FlushDEntry_OPC_2                      1
#define SA110_Coprocessor_TLBOperations_FlushDEntry_CRm                        c6

#define SA110_Coprocessor_TestClockIdleControl_EnableOddWordLFSR_OPC_2         1
#define SA110_Coprocessor_TestClockIdleControl_EnableOddWordLFSR_CRm           c1

#define SA110_Coprocessor_TestClockIdleControl_EnableEvenWordLFSR_OPC_2        1
#define SA110_Coprocessor_TestClockIdleControl_EnableEvenWordLFSR_CRm          c2

#define SA110_Coprocessor_TestClockIdleControl_ClearICacheLFSR_OPC_2           1
#define SA110_Coprocessor_TestClockIdleControl_ClearICacheLFSR_CRm             c4

#define SA110_Coprocessor_TestClockIdleControl_MoveLFSRtoR14_OPC_2             1
#define SA110_Coprocessor_TestClockIdleControl_MoveLFSRtoR14_CRm               c8

#define SA110_Coprocessor_TestClockIdleControl_EnableClockSwitching_OPC_2      2
#define SA110_Coprocessor_TestClockIdleControl_EnableClockSwitching_CRm        c1

#define SA110_Coprocessor_TestClockIdleControl_DisableClockSwitching_OPC_2     2
#define SA110_Coprocessor_TestClockIdleControl_DisableClockSwitching_CRm       c2

#define SA110_Coprocessor_TestClockIdleControl_DisablenMCLKOutput_OPC_2        2
#define SA110_Coprocessor_TestClockIdleControl_DisablenMCLKOutput_CRm          c4

#define SA110_Coprocessor_TestClockIdleControl_WaitForInterrupt_OPC_2          2
#define SA110_Coprocessor_TestClockIdleControl_WaitForInterrupt_CRm            c8

/*+
MMU Declarations
-*/

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_MASK                   (os_bit32)0x00000003
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_Fault                  (os_bit32)0x00000000
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_PageTable              (os_bit32)0x00000001
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_Section                (os_bit32)0x00000002
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Type_Reserved               (os_bit32)0x00000003

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_PageTable_BaseAddress_MASK  (os_bit32)0xFFFFFC00

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_PageTable_Domain_MASK       (os_bit32)0x000001E0
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_PageTable_Domain_SHIFT      (os_bit32)0x05

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_BaseAddress_MASK    (os_bit32)0xFFF00000

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_AP_MASK             (os_bit32)0x00000C00
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_AP_SHIFT            (os_bit32)0x0A

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_Domain_MASK         (os_bit32)0x000001E0
#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_Domain_SHIFT        (os_bit32)0x05

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_Cacheable           (os_bit32)0x00000008

#define SA110_Coprocessor_MMU_FirstLevelDescriptor_Section_Bufferable          (os_bit32)0x00000004

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_MASK                  (os_bit32)0x00000003
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_Fault                 (os_bit32)0x00000000
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_LargePage             (os_bit32)0x00000001
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_SmallPage             (os_bit32)0x00000002
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_Type_Reserved              (os_bit32)0x00000003

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_BaseAddress_MASK (os_bit32)0xFFFF0000

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP3_MASK         (os_bit32)0x00000C00
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP3_SHIFT        (os_bit32)0x0A

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP2_MASK         (os_bit32)0x00000300
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP2_SHIFT        (os_bit32)0x08

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP1_MASK         (os_bit32)0x000000C0
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP1_SHIFT        (os_bit32)0x06

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP0_MASK         (os_bit32)0x00000030
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_AP0_SHIFT        (os_bit32)0x04

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_Cacheable        (os_bit32)0x00000008

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_LargePage_Bufferable       (os_bit32)0x00000004

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_BaseAddress_MASK (os_bit32)0xFFFFF000

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP3_MASK         (os_bit32)0x00000C00
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP3_SHIFT        (os_bit32)0x0A

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP2_MASK         (os_bit32)0x00000300
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP2_SHIFT        (os_bit32)0x08

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP1_MASK         (os_bit32)0x000000C0
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP1_SHIFT        (os_bit32)0x06

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP0_MASK         (os_bit32)0x00000030
#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_AP0_SHIFT        (os_bit32)0x04

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_Cacheable        (os_bit32)0x00000008

#define SA110_Coprocessor_MMU_SecondLevelDescriptor_SmallPage_Bufferable       (os_bit32)0x00000004

#endif /* __SA110_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\sanapi.h ===
#ifndef SANAPI_H
#define SANAPI_H

#include "hbaapi.h"

/* FOR REFERENCE - from NTDDSCSI.h
typedef struct _SRB_IO_CONTROL 
{
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;
*/

#define AG_SAN_IOCTL_SIGNATURE 	"SANIOCTL"

/*
	Agilent SAN IOCTLs
	------------------
 	AG_IOCTL_GET_HBA_ATTRIBUTES			Retrieve the attributes of the HBA.
	AG_IOCTL_GET_HBA_PORT_ATTRIBUTES	Retrieve the attributes for  the specific FC port on the HBA.
	AG_IOCTL_GET_HBA_PORT_STATISTICS	Retrieve the statistics for the specific FC port on the HBA.
	AG_IOCTL_GET_PORT_ATTRIBUTES		Retrieve the attributes of the specific FC port discovered by the HBA.
	AG_IOCTL_GET_FCP_LUN_MAPPING		Retrieve ALL mapping between the FCP Lun and OS SCSI address.
	AG_IOCTL_GET_PERSISTENT_BINDING		Retrieve the persistent binding between the FCP Lun and the OS SCSI address.
	AG_IOCTL_GET_EVENT_BUFFER			Retrieve the HBA event queue.
	AG_IOCTL_SEND_CT_PASSTHRU			Send a CT passthrough frame.
	AG_IOCTL_SET_RNID_MGMT_INFO			Set the RNID management info for the HBA.
	AG_IOCTL_GET_RNID_MGMT_INFO			Retrieve the RNID management info from the HBA.
	AG_IOCTL_SEND_RNID					Send an ELS  RNID to another node.
	AG_IOCTL_SEND_SCSI_INQUIRY			Send a SCSI Inquiry to an FCL Lun of a port.
	AG_IOCTL_SEND_SCSI_REPORT_LUN		Send a SCSI Report Lun to an FCP Lun of a port.
	AG_IOCTL_SEND_SCSI_READ_CAPACITY	Send a SCSI Capacity  to an FCP Lun of a port.
	AG_IOCTL_GET_DEV_FCP_LUN_MAPPING	Retrieve the mapping between a FCP Lun and OS SCSI address of a device
	AG_IOCTL_GET_OS_SCSI_FCP_ATTRIBUTE	Retrieve an FCP Port attribute for an OS known SCSI device.
	AG_IOCTL_GET_FCP_LUN_MAPPING_SIZE	Retrieve the size in bytes required for all the mappings between the FCP Lun and OS SCSI address.
	AG_IOCTL_GET_PERSISTENT_BINDING_SIZE	Retrieve the size in bytes required for all the persistent bindings between the FCP Lun and the OS SCSI address
 */

typedef enum IOCTL_CODES{
	AG_IOCTL_GET_HBA_PORT_ATTRIBUTES	=	0x20,
	AG_IOCTL_GET_HBA_PORT_STATISTICS,
	AG_IOCTL_GET_HBA_ATTRIBUTES,
	AG_IOCTL_GET_PORT_ATTRIBUTES,
	AG_IOCTL_GET_FCP_LUN_MAPPING,
	AG_IOCTL_GET_PERSISTENT_BINDING,
	AG_IOCTL_GET_EVENT_BUFFER,
	AG_IOCTL_SEND_CT_PASSTHRU,
	AG_IOCTL_SET_RNID_MGMT_INFO,
	AG_IOCTL_GET_RNID_MGMT_INFO,
	AG_IOCTL_SEND_RNID,
	AG_IOCTL_SEND_SCSI_INQUIRY,
	AG_IOCTL_SEND_SCSI_REPORT_LUN,
	AG_IOCTL_SEND_SCSI_READ_CAPACITY,
	AG_IOCTL_GET_OS_SCSI_FCP_ATTRIBUTE,
	AG_IOCTL_GET_FCP_LUN_MAPPING_SIZE,
	AG_IOCTL_GET_PERSISTENT_BINDING_SIZE
}; // end of codes


/* Return Codes */
/*	
	HP_FC_RTN_OK					The requested operation completed successfully.
	HP_FC_RTN_FAILED				The requested operation failed.
	HP_FC_RTN_BAD_CTL_CODE			The Control Code of the requested operation is invalid.
	HP_FC_RTN_INSUFFICIENT_BUFFER	The requested operation could not be satisfied due to the Data Area being smaller than the expected.
	HP_FC_RTN_INVALID_DEVICE		The target device specified in the input SCSI_ADDRESS data structure is not valid.
	HP_FC_RTN_INVALID_INDEX			The index (such as DiscoveredPortIndex in AG_IOCTL_GET_PORT_ATTRIBUTES).
*/
#define HP_FC_RTN_OK					0
#define HP_FC_RTN_FAILED				1
#define HP_FC_RTN_BAD_CTL_CODE			2
#define HP_FC_RTN_INSUFFICIENT_BUFFER	3
#define HP_FC_RTN_INVALID_DEVICE		4
#define HP_FC_RTN_BAD_SIGNATURE			5
#define HP_FC_RTN_INVALID_INDEX			6

/* Structures used for different IOCTLs */

/* Get Port attributes - AG_IOCTL_GET_HBA_PORT_ATTRIBUTES */
typedef struct _AG_HBA_PORTATTRIBUTES {
	SRB_IO_CONTROL		srbIoCtl;
	HBA_PORTATTRIBUTES	Com;
} AG_HBA_PORTATTRIBUTES, *PAG_HBA_PORTATTRIBUTES;

/* Get Port statistics - AG_IOCTL_GET_PORT_STATISTICS */
typedef struct _AG_HBA_PORTSTATISTICS {
	SRB_IO_CONTROL		srbIoCtl;
	HBA_PORTSTATISTICS	Com;
} AG_HBA_PORTSTATISTICS, *PAG_HBA_PORTSTATISTICS;

/* Get Adapter/HBA attributes - AG_IOCTL_GET_HBA_ATTRIBUTES */
typedef struct _AG_HBA_ADAPTERATTRIBUTES {
	SRB_IO_CONTROL			srbIoCtl;
	HBA_ADAPTERATTRIBUTES	Com;
} AG_HBA_ADAPTERATTRIBUTES, *PAG_HBA_ADAPTERATTRIBUTES;

// Wrapper structure, which stores the discovered port
// properties and also the port index
typedef struct _DISCOVERED_PORTATTRIBUTES {
	HBA_UINT32			DiscoveredPortIndex;
	HBA_PORTATTRIBUTES	PortAttributes;
} DISCOVERED_PORTATTRIBUTES, *PDISCOVERED_PORTATTRIBUTES;

/* Get Port attributes - AG_IOCTL_GET_PORT_ATTRIBUTES */
typedef struct _AG_DISCOVERED_PORTATTRIBUTES {
	SRB_IO_CONTROL				srbIoCtl;
	DISCOVERED_PORTATTRIBUTES	Com;
} AG_DISCOVERED_PORTATTRIBUTES, *PAG_DISCOVERED_PORTATTRIBUTES;

/* Get FCP LUN mapping - AG_IOCTL_GET_FCP_LUN_MAPPING */
typedef struct _AG_HBA_FCPTARGETMAPPING {
	SRB_IO_CONTROL 	srbIoCtl;
	HBA_FCPTARGETMAPPING	Com;
} AG_HBA_FCPTARGETMAPPING, *PAG_HBA_FCPTARGETMAPPING;

typedef struct _AG_HBA_FCPBINDING {
	SRB_IO_CONTROL 	srbIoCtl;
	HBA_FCPBINDING	Com;
} AG_HBA_FCPBINDING, *PAG_HBA_FCPBINDING;

typedef struct _AG_HBA_MGMTINFO {
	SRB_IO_CONTROL 	srbIoCtl;
	HBA_MGMTINFO	Com;
} AG_HBA_MGMTINFO, *PAG_HBA_MGMTINFO;

typedef struct _AG_HBA_EVENTINFO {
	SRB_IO_CONTROL 	srbIoCtl;
	HBA_EVENTINFO	Com;
} AG_HBA_EVENTINFO, *PAG_HBA_EVENTINFO;

/* Data structures needed for AG_IOCTL_GET_OS_SCSI_FCP_ATTRIBUTE */
typedef struct OS_ScsiAddress {
	HBA_UINT32		OsScsiBusNumber;
	HBA_UINT32		OsScsiTargetNumber;
	HBA_UINT32		OsScsiLun;
} OS_SCSI_ADDRESS, *POS_SCSI_ADDRESS;

typedef struct Scsi_Fcp_Attribute {
	OS_SCSI_ADDRESS	OsScsi;
	HBA_FCPID		FcpId;
} SCSI_FCP_ATTRIBUTE, *PSCSI_FCP_ATTRIBUTE;

typedef struct _AG_SCSI_FCP_ATTRIBUTE {
	SRB_IO_CONTROL 	srbIoCtl;
	SCSI_FCP_ATTRIBUTE	Com;
} AG_SCSI_FCP_ATTRIBUTE, *PAG_SCSI_FCP_ATTRIBUTE;

/* Data structures needed for AG_IOCTL_GET_FCP_LUN_MAPPING_SIZE */

typedef struct FCPTargetMapping_Size {
	HBA_UINT32		TotalLunMappings;
	HBA_UINT32		SizeInBytes;
} FCPTARGETMAPPING_SIZE, *PFCPTARGETMAPPING_SIZE;

typedef struct _AG_FCPTARGETMAPPING_SIZE {
	SRB_IO_CONTROL 	srbIoCtl;
	FCPTARGETMAPPING_SIZE	Com;
} AG_FCPTARGETMAPPING_SIZE, *PAG_FCPTARGETMAPPING_SIZE;

/* Data structures needed for AG_IOCTL_GET_PERSISTENT_BINDING_SIZE */
typedef struct FCPBinding_Size {
	HBA_UINT32		TotalLunBindings;
	HBA_UINT32		SizeInBytes;
} FCPBINDING_SIZE, *PFCPBINDING_SIZE;

typedef struct _AG_FCPBINDING_SIZE {
	SRB_IO_CONTROL 	srbIoCtl;
	FCPBINDING_SIZE	Com;
} AG_FCPBINDING_SIZE, *PAG_FCPBINDING_SIZE;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\resetbus.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    ResetBus.c

Abstract:

    This is the reset bus enty point for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/RESETBUS.C $
    
Revision History:

    $Revision: 9 $
    $Date: 10/25/00 10:17a $
    $Modtime:: 10/25/00 10:17a       $

Notes:



--*/

#include "buildop.h"        //LP021100 build switches
#include "osflags.h"
// #include "HPFibre.h"    // includes scsi.h
#ifdef _DEBUG_EVENTLOG_
#include "eventlog.h"
#endif

BOOLEAN
HPFibreResetBus(
    IN PCARD_EXTENSION pCard,
    ULONG PathId)

/*++

Routine Description:

    Reset adapter.

Arguments:

    pCard - HBA miniport driver's adapter data storage
    PathId          - Identifies the bus to be reset.
                      Only > 0 for multi-bus HBA's.

Return Value:

    TRUE  if reset successful
    FALSE if reset unsuccessful

--*/

{
    PLU_EXTENSION plunExtension = NULL;
    ULONG Reset_Status;
    agRoot_t * hpRoot=&pCard->hpRoot;
    
    pCard->inDriver = TRUE;

    while (pCard->inTimer == TRUE)
       // HPFibreTimerTick routine is running. Busy wait until
       // HPFibreTimerTick returns.
       ;

    if ((pCard->flags & OS_IGNORE_NEXT_RESET) && 
       (PathId == (pCard->ResetPathId + 1))) 
    {
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreResetBus: Ignoring... pCard = 0x%x PathId = %d ResetCount = %d @ %d\n", 
           pCard, PathId, pCard->External_ResetCount ,  osTimeStamp(0) ));

        if(PathId == (NUMBER_OF_BUSES - 1)) 
        {
            pCard->flags &= ~OS_IGNORE_NEXT_RESET;
            ScsiPortNotification (RequestTimerCall, pCard,
                         (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);
        } 
        else 
        {
            pCard->ResetPathId = PathId;
            ScsiPortNotification (RequestTimerCall, pCard, (PHW_TIMER) ResetTimer, 30000); // 30 ms
        }

    } 
    else 
    {
        pCard->State |= CS_DURING_RESET_ADAPTER;
        pCard->flags &= ~OS_IGNORE_NEXT_RESET;
        pCard->External_ResetCount++;

        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreResetBus: pCard = 0x%x PathId = %d ResetCount = %d @ %d\n", 
           pCard, PathId, pCard->External_ResetCount ,  osTimeStamp(0) ));

        pCard->LinkState = LS_LINK_DOWN;
        if (pCard->OldNumDevices == 0)
            pCard->OldNumDevices = pCard->Num_Devices;

        Reset_Status = fcResetDevice (hpRoot, fcResetAllDevs, fcHardReset);

        doPostResetProcessing (pCard);

        if (PathId == 0) 
        {
            pCard->flags |= OS_IGNORE_NEXT_RESET;
            pCard->ResetPathId = PathId;
            ScsiPortNotification (RequestTimerCall, pCard, (PHW_TIMER) ResetTimer, 30000); // 30 ms
        }

        // osZero(&pCard->OutStandingSrbExt[0],sizeof(pCard->OutStandingSrbExt));
        // ScsiPortNotification(NextRequest,pCard,NULL);

        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreResetBus: Exiting... pCard = 0x%x Reset_Status = %d @ %d\n", pCard, Reset_Status, osTimeStamp(0) ));

        pCard->State &= ~CS_DURING_RESET_ADAPTER;
    }

    #ifdef _DEBUG_EVENTLOG_
    LogEvent(pCard, NULL, HPFC_MSG_DEV_RESET, NULL, 0, "%d", Reset_Status);
    #endif
   
    pCard->inDriver = FALSE;
    return (Reset_Status == fcResetSuccess);
} // end HPFibreResetBus()

void
ResetTimer (PCARD_EXTENSION pCard)
{
    pCard->flags &= ~OS_IGNORE_NEXT_RESET;

    ScsiPortNotification (RequestTimerCall, pCard,
                          (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);
}

#ifdef DBG
void show_outstanding_IOs(PCARD_EXTENSION pCard)
{
    int Num_outstanding=0;
    PSRB_EXTENSION      pSrbExt=pCard->RootSrbExt;

    while( pSrbExt )
    {
        if(pSrbExt )
        {
            osDEBUGPRINT((ALWAYS_PRINT,"IO %lx lost because of reset SRB %lx DEV %lx Delta T %x %s\n",
                &pSrbExt->hpIORequest,pSrbExt->pSrb,pSrbExt->pLunExt->phandle,osTimeStamp(0)-pSrbExt->SRB_StartTime,
                pSrbExt->SRB_State & RS_TIMEOUT ? "TIMEDOUT" : "Not marked" ));
                Num_outstanding++;
                // display_sest_data(&pSrbExt->hpIORequest );
            display_srbext(&pSrbExt->hpIORequest );
            pSrbExt->SRB_State |= RS_RESET;
        }
        pSrbExt=Get_next_Srbext(pSrbExt);
    }

    osDEBUGPRINT((ALWAYS_PRINT,"Out %x\n",Num_outstanding));
}
#endif

osGLOBAL void osResetChannelCallback(
    agRoot_t *hpRoot,
    os_bit32  hpResetStatus
    )
{
    PCARD_EXTENSION pCard;
    PLU_EXTENSION plunExtension = NULL;
    pCard   = (PCARD_EXTENSION)hpRoot->osData;

    osDEBUGPRINT((ALWAYS_PRINT,"IN osResetChannelCallback Notify scsiport of reset @ %x\n",osTimeStamp(0)));

    osDEBUGPRINT((ALWAYS_PRINT,"OUT osResetChannelCallback OK\n"));

}

void
osFCLayerAsyncEvent (agRoot_t *hpRoot, os_bit32 fcLayerEvent)
{
    PCARD_EXTENSION  pCard = (PCARD_EXTENSION)hpRoot->osData;
    PLU_EXTENSION lunEx;
    UCHAR   path, target, lun;


    #ifdef _DEBUG_EVENTLOG_Testing
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L4, NULL, 0, "%s", 
      "123456789-123456789-123456789-123456789-123456789-123456789-123456789-123456789-1234567890");

    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L1 ,NULL,0, "Dynamic L1");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L2 ,NULL,0, "Dynamic L2");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L3 ,NULL,0, "Dynamic L3");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L4 ,NULL,0, "Dynamic L4");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L5 ,NULL,0, "Dynamic L5");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L6 ,NULL,0, "Dynamic L6");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L7 ,NULL,0, "Dynamic L7");
    LogEvent(pCard, NULL, HPFC_MSG_DYNAMIC_L8 ,NULL,0, "Dynamic L8");
    #endif

   
    switch (fcLayerEvent) 
    {
        case osFCLinkUp:
            #ifdef _DEBUG_EVENTLOG_
            if (pCard->PrevLinkState != fcLayerEvent)
                LogEvent(pCard, NULL,HPFC_MSG_LOOP_UP,NULL,0, NULL);
            #endif
      
            #ifdef _SAN_IOCTL_
            {
                SAN_EVENTINFO      this;
      
                osZero(&this, sizeof(this) );
                this.EventCode = SAN_EVENT_LINK_UP;
                if (pCard->PrevLinkState != fcLayerEvent)
                SANPutNextBuffer(pCard, &this);
            }
            #endif
            osDEBUGPRINT((ALWAYS_PRINT, "osFCLayerAsyncEvent: fcLayerEvent = osFCLinkUp\n"));
            pCard->LIPCount++;
            // Reset the flag, since link is up
            pCard->SrbStatusFlag = FALSE;
            // Do link down processing just in case. If every thing is going well
            // doLinkDownProcessing should not do any harm.
            doLinkDownProcessing (pCard);

            GetNodeInfo (pCard);

            if ( (pCard->OldNumDevices == 0) || (pCard->OldNumDevices <= pCard->Num_Devices) ) 
            {
                FixDevHandlesForLinkUp (pCard);
                pCard->LinkState = LS_LINK_UP;
                pCard->flags &= ~OS_DO_SOFT_RESET;

                #if defined(HP_NT50)
                // 
                // Tell SCSIPort to rescan the target device for this HBA.
                //

                if (pCard->OldNumDevices < pCard->Num_Devices)
                {
                    osDEBUGPRINT((ALWAYS_PRINT, "BusChangeDetected notification to SCSIPort.\n"));
                    ScsiPortNotification(BusChangeDetected, pCard, 0);
                }
                #endif         
                pCard->OldNumDevices = 0;
                ScsiPortNotification (NextRequest, pCard, NULL, NULL, NULL);

            } 
            else 
            {
                ClearDevHandleArray (pCard);
                pCard->LinkState = LS_LINK_DOWN;
                if (!(pCard->flags & OS_DO_SOFT_RESET)) 
                {
                    pCard->flags |= OS_DO_SOFT_RESET;
                pCard->LostDevTickCount = LOST_DEV_TICK_COUNT;
                }
                osDEBUGPRINT((ALWAYS_PRINT, ".............................................\n"));
                osDEBUGPRINT((ALWAYS_PRINT, "osFCLayerAsyncEvent: Channel Reset will be done. OldNumDevices = %d, Num_Devices = %d\n",
                    pCard->OldNumDevices, pCard->Num_Devices));
            }

            break;

        case osFCLinkDown:
        case osFCLinkFalling:
        case osFCLinkRising:
        case osFCLinkDead:
            #ifdef _DEBUG_EVENTLOG_
            if (pCard->PrevLinkState != fcLayerEvent)
            {
                if (fcLayerEvent == osFCLinkDown) 
                    LogEvent(pCard, NULL,HPFC_MSG_LOOP_DOWN,NULL,0, "");
                else
                    if (fcLayerEvent == osFCLinkDead) 
                        LogEvent(pCard, NULL,HPFC_MSG_LOOP_DEAD, NULL,0, "");
            }
            #endif   

            #ifdef _SAN_IOCTL_
            {
                SAN_EVENTINFO      this;
      
                osZero(&this, sizeof(this) );
                this.EventCode = SAN_EVENT_LINK_DOWN;
                if (pCard->PrevLinkState != fcLayerEvent)
                    SANPutNextBuffer(pCard, &this);
            }
            #endif
      
            pCard->LinkState = LS_LINK_DOWN;
            osDEBUGPRINT((ALWAYS_PRINT, "osFCLayerAsyncEvent: fcLayerEvent = osFCLinkDown\n"));
            doLinkDownProcessing (pCard);
            break;

        default:
            osDEBUGPRINT((ALWAYS_PRINT, "osFCLayerAsyncEvent: fcLayerEvent = %d - default\n", fcLayerEvent));
            break;
    }
    #ifdef _DEBUG_EVENTLOG_ 
    pCard->PrevLinkState = fcLayerEvent;
    #endif
}

void
doLinkDownProcessing (PCARD_EXTENSION pCard)
{
    PLU_EXTENSION   pLunExt;

    FixDevHandlesForLinkDown (pCard);

    if (pCard->OldNumDevices == 0)
        pCard->OldNumDevices = pCard->Num_Devices;

    ClearDevHandleArray (pCard);
    #ifdef YAM2_1
    SetPaDeviceTable(pCard, ALL_DEVICE, PA_DEVICE_GONEAWAY);
    #endif
}

void
ClearDevHandleArray (PCARD_EXTENSION pCard)
{
    ULONG     x;

    pCard->Num_Devices = 0;
    pCard->cardHandleIndex = -1;

    #ifndef YAM2_1
    for(x=0; x < MAX_FC_DEVICES; x++)
    {
    #else
    for(x=0; x < gMaxPaDevices; x++)
    {
    #endif
        pCard->hpFCDev[x] = NULL;
        pCard->nodeInfo[x].DeviceType = agDevUnknown;
    }
}

void
doPostResetProcessing (PCARD_EXTENSION pCard)
{
    completeRequests (pCard, SP_UNTAGGED, SP_UNTAGGED, SRB_STATUS_BUS_RESET);

//--LP101000   pCard->TimedOutIO=0;
    pCard->State &= ~CS_FCLAYER_LOST_IO;
    pCard->RootSrbExt = NULL;
    pCard->AdapterQ.Head = NULL;
    pCard->AdapterQ.Tail = NULL;

    GetNodeInfo (pCard);

    if (pCard->OldNumDevices == 0 || pCard->OldNumDevices <= pCard->Num_Devices) 
    {
        if (pCard->LinkState != LS_LINK_UP) 
        {
            ScsiPortNotification (NextRequest, pCard, NULL, NULL, NULL);
            pCard->LinkState = LS_LINK_UP;
            pCard->flags &= ~OS_DO_SOFT_RESET;
            pCard->OldNumDevices = 0;
        }
    } 
    else 
    {
        ClearDevHandleArray (pCard);
        pCard->LinkState = LS_LINK_DOWN;
        if (!(pCard->flags & OS_DO_SOFT_RESET)) 
        {
            pCard->flags |= OS_DO_SOFT_RESET;
            pCard->LostDevTickCount = LOST_DEV_TICK_COUNT;
        }
        osDEBUGPRINT((ALWAYS_PRINT, ".............................................\n"));
        osDEBUGPRINT((ALWAYS_PRINT, "doPostResetProcessing: Channel Reset will be done. OldNumDevices = %d, Num_Devices = %d\n",
                pCard->OldNumDevices, pCard->Num_Devices));
    }
}

void
completeRequests (
    IN PCARD_EXTENSION pCard,
    UCHAR PId,
    UCHAR TId,
    UCHAR compStatus)
{
    UCHAR PathId;
    UCHAR TargId;
    UCHAR Cur_Lun;
    PLU_EXTENSION plunExtension = NULL;
    agFCDev_t devPidTid, devPathidTargid;
    agRoot_t *hpRoot = &pCard->hpRoot;
    PSCSI_REQUEST_BLOCK pSrb;
    int completeAll;
    #ifdef YAM2_1
    DEVICE_MAP  *devmap;
    CHAR        addrmode;
    USHORT      paIndex;
    #endif

    devPidTid = devPathidTargid = NULL;
    if (PId == SP_UNTAGGED && TId == SP_UNTAGGED)
        completeAll = TRUE;
    else 
    {
        completeAll = FALSE;
        devPidTid = MapToHandle(pCard, PId, TId, 0, NULL);
        if (devPidTid == NULL)
        {
            osDEBUGPRINT ((ALWAYS_PRINT," [CompleteRequests] devPidTid ==NULL\n"));
            return;
        }
    }

    if (completeAll) 
    {
        CompleteQueuedRequests (pCard, NULL, compStatus);
#ifdef NONONO
        ScsiPortCompleteRequest(pCard,
                            PId,
                            TId,
                            SP_UNTAGGED,
                            compStatus);
#endif
    } 
    else
        CompleteQueuedRequests (pCard, devPidTid, compStatus);
    

    osDEBUGPRINT((DMOD,"Reinit plunExtensions\n"));

    for( PathId = 0; PathId < NUMBER_OF_BUSES; PathId++ )
    {
        #ifndef YAM2_1
        for( TargId = 0; TargId < MAXIMUM_TID; TargId++)
        { 
        #else
        for( TargId = 0; TargId < gMaximumTargetIDs; TargId++)
        {
        #endif
            #ifndef YAM2_1
            for( Cur_Lun = 0; Cur_Lun < gMaximumLuns; Cur_Lun++)
            {
            #else
            devmap = GetDeviceMapping(pCard, PathId, TargId, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
            for( Cur_Lun = 0; Cur_Lun < devmap->Com.MaxLuns+1; Cur_Lun++)
            {
            #endif
                devPathidTargid = MapToHandle(pCard, PathId, TargId, Cur_Lun, NULL);
                if (completeAll || (devPidTid == devPathidTargid)) 
                {
                    if (completeAll == FALSE) 
                    {
                    osDEBUGPRINT ((ALWAYS_PRINT," [CompleteRequests] completeAll False Doing ScsiportCompletion\n"));

#ifdef NONONO
                    ScsiPortCompleteRequest(pCard,
                            PathId,
                            TargId,
                            SP_UNTAGGED,
                            compStatus);
#endif
                    }

                    plunExtension = ScsiPortGetLogicalUnit(pCard,
                                                           PathId,
                                                           TargId,
                                                           Cur_Lun
                                                           );
                    if( plunExtension != NULL)
                    {
                        osDEBUGPRINT((DMOD,"plunExtension %lx OK\n",plunExtension));
                        plunExtension->OutstandingIOs = 0;
                        plunExtension->phandle = NULL;
                    }
                }
            }
        }
    }
}

//
// Complete the queued SRB requests on pCard->RootSrb queue with the given compStatus.
// If devHandle is null then complete all the queued SRB requests.
// If devHandle is non-null then complete only those queued SRB requests that 
// belong to the devHandle.
//
void
CompleteQueuedRequests (PCARD_EXTENSION pCard, agFCDev_t devHandle, UCHAR compStatus)
{
    if(!pCard)
    {
        osDEBUGPRINT ((ALWAYS_PRINT, "[CompleteQueuedRequests] pCard = 0x%x devHandle = 0x%x compStatus = 0x%x\n", pCard, devHandle, compStatus));
    }

    if (devHandle == NULL) 
    {
        CompleteQueue (pCard, &pCard->RetryQ, 0, NULL, compStatus);
        CompleteQueue (pCard, &pCard->AdapterQ, 0, NULL, compStatus);
    } 
    else 
    {
        CompleteQueue (pCard, &pCard->RetryQ, 1, devHandle, compStatus);
        CompleteQueue (pCard, &pCard->AdapterQ, 1, devHandle, compStatus);
    }
}

void
FixDevHandlesForLinkDown (PCARD_EXTENSION pCard)
{
    UCHAR   p, t, l;
    PLU_EXTENSION pLunExt;
    #ifdef YAM2_1
    DEVICE_MAP  *devmap;
    CHAR        addrmode;
    USHORT      paIndex;
    #endif


    for (p = 0; p < NUMBER_OF_BUSES; p++ ) 
    {
        #ifndef YAM2_1
        for (t = 0; t < MAXIMUM_TID; t++) 
        {
        #else
        for (t = 0; t < gMaximumTargetIDs; t++) 
        {
        #endif
   
            #ifndef YAM2_1 
            for (l = 0; l < gMaximumLuns; l++) 
            {
            #else
            devmap = GetDeviceMapping(pCard, p, t, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
      
            for (l = 0; l < devmap->Com.MaxLuns+1; l++) 
            {
            #endif
                pLunExt = ScsiPortGetLogicalUnit (pCard, p, t, l);

                if (pLunExt != NULL) 
                {
                    pLunExt->phandle = NULL;
                }
            }
        }
    }
}

void
FixDevHandlesForLinkUp (PCARD_EXTENSION pCard)
{
    UCHAR   p, t, l;
    PLU_EXTENSION pLunExt;
    #ifdef YAM2_1
    DEVICE_MAP  *devmap;
    CHAR        addrmode;
    USHORT      paIndex;
    #endif



    for (p = 0; p < NUMBER_OF_BUSES; p++ ) 
    {
        #ifndef YAM2_1
        for (t = 0; t < MAXIMUM_TID; t++) 
        {
        #else
        for (t = 0; t < gMaximumTargetIDs; t++) 
        {
        #endif

            #ifndef YAM2_1 
            for (l = 0; l < gMaximumLuns ; l++) 
            {
            #else
            devmap = GetDeviceMapping(pCard, p, t, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
      
            for (l = 0; l < devmap->Com.MaxLuns+1; l++) 
            {
            #endif
                pLunExt = ScsiPortGetLogicalUnit (pCard, p, t, l);

                if (pLunExt != NULL)
//--LP101900 bug with missing EMC                    pLunExt->phandle = MapToHandle (pCard, p, t, l, pLunExt);
                    pLunExt->phandle = MapToHandle (pCard, p, t, l, NULL);
            }
        }
    }

    // Device may have disappeared after link up. Complete the SRBs
    // of missing devices.

    CompleteQueue (pCard, &pCard->RetryQ, 1, NULL, SRB_STATUS_SELECTION_TIMEOUT);
    CompleteQueue (pCard, &pCard->AdapterQ, 1, NULL, SRB_STATUS_SELECTION_TIMEOUT);
}

//
// Complete SRBs on the given queue with the given compStatus.
// If param == 0 then complete all the SRBs on the queue
// If param == non-zero then complete only the SRBs with the given devHandle
//
void
CompleteQueue (
    PCARD_EXTENSION pCard, 
    OSL_QUEUE *queue, 
    int param, 
    agFCDev_t devHandle, 
    UCHAR compStatus)
{
    PSCSI_REQUEST_BLOCK pSrb = queue->Head;
    PSRB_EXTENSION      pSrbExt;
    PLU_EXTENSION       pLunExt;
    PSCSI_REQUEST_BLOCK prevSrb = NULL;
    PSCSI_REQUEST_BLOCK temp_Srb;
    ULONG                paDeviceIndex = 0;
   
   
    osDEBUGPRINT ((ALWAYS_PRINT," [CompleteQueue] pCard=%x Q=%x Param=%d devHandle=%x sta=%x Srb=%x\n",
         pCard, 
         queue, 
         param, 
         devHandle, 
         compStatus,
         pSrb));


    while (pSrb != NULL) 
    {
        pSrbExt = (PSRB_EXTENSION)(pSrb->SrbExtension);
        pLunExt = pSrbExt->pLunExt;

        // ADPTFIX
        //
        // With Compaq style hot plug PCI, if heavy I/O activity a device
        // behind an adapter that is powered off then powered on pLunExt
        // occasionally is NULL.
        //
        // if (param == 0 || pLunExt->phandle == devHandle) 
        // {
        //
        if (param == 0 || ((pLunExt) && (pLunExt->phandle == devHandle))) 
        {
            pSrb->SrbStatus = compStatus;
            pSrb->ScsiStatus = 0;
            pLunExt->OutstandingIOs--;

            if (queue->Head == pSrb)
                queue->Head = pSrbExt->pNextSrb;
            else
                ((PSRB_EXTENSION)(prevSrb->SrbExtension))->pNextSrb = pSrbExt->pNextSrb;

            if (queue->Tail == pSrb)
                queue->Tail = prevSrb;

            #ifdef YAM2_1
            paDeviceIndex =  pLunExt->PaDeviceIndex;
            #endif

            // EBUGPRINT ((ALWAYS_PRINT, "[CompleteQueue] Completing Srb = 0x%x SrbStatus = 0x%x\n", pSrb, compStatus));
            osDEBUGPRINT((ALWAYS_PRINT, " [CompleteQueue] %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x FCP0 %02x%02x PAIx=%d FCHndl=%08x\n",
                        pSrb->PathId,
                        pSrb->TargetId,
                        pSrb->Lun,
                        pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                        pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9],          
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[0],
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[1],
                        paDeviceIndex, 
                        pSrbExt->pLunExt->phandle 
                        ));

            temp_Srb = pSrb;
            
            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_DONE )
            {
                static   count;
                UCHAR    *uptr;
                osDEBUGPRINT((ALWAYS_PRINT, " CplQ(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Next=%x Head=%x Tail=%x\n",
                  count++,
                  pSrb->PathId,
                  pSrb->TargetId,
                  pSrb->Lun,
                  pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                  pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
                  pSrb,
                  ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb,
                  queue->Head,
                  queue->Tail
                  ));
            }
            #endif   
            if (prevSrb == NULL)
                pSrb = queue->Head;
            else
                pSrb = ((PSRB_EXTENSION)(prevSrb->SrbExtension))->pNextSrb;
            ASSERT(pSrb == temp_Srb);

            ScsiPortNotification (RequestComplete, pCard, temp_Srb);

        } 
        else 
        {
            prevSrb = pSrb;
            pSrb = pSrbExt->pNextSrb;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\sanioctl.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    sanioctl.c

Abstract:

    Contains routines for SAN IOTCL handler


Author:

    Leopold Purwadihardja

Revision History:

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/sanioctl.c $
    
Revision History:

    $Revision: 15 $
    $Date: 7/13/01 3:55p $
    $Modtime:: $

--*/

#include "buildop.h"        //LP021100 build switches

#include "osflags.h"
#include "sanioctl.h"
#include "hhba5100.ver"
#include "tlstruct.h"
//#include <stdio.h>

#ifdef _SAN_IOCTL_

/* 
 * SANGetNextBuffer()
 *   return the unread SAN event buffer.  
 */
SAN_EVENTINFO *SANGetNextBuffer(
    IN PCARD_EXTENSION pCard)
{
    SAN_EVENTINFO  *this=NULL;
   
    if (pCard->SanEvent_UngetCount > 0)                      /* check the counter */
    {
        pCard->SanEvent_UngetCount --;                        /* get one off */
        this = &pCard->SanEvents[pCard->SanEvent_GetIndex];   /* get the event buffer */
        pCard->SanEvent_GetIndex++;                           /* increment index */
        if (pCard->SanEvent_GetIndex > (MAX_FC_EVENTS-1) )    /* make sure it doesn't wrap around */
            pCard->SanEvent_GetIndex = 0;
    }
    return this;
}


/*
 * SANPutNextBuffer()
 *  - add a new entry into the circular buffer. 
 */
void SANPutNextBuffer(
    IN PCARD_EXTENSION pCard,
    SAN_EVENTINFO      *this)
{
    /* get the next buffer and return it to the caller */
    osCopy (&pCard->SanEvents[pCard->SanEvent_PutIndex], this, sizeof(*this) );   
   
    pCard->SanEvent_PutIndex ++;                          /* increment the index */
    if (pCard->SanEvent_PutIndex > (MAX_FC_EVENTS-1) )    /* make sure it doesn't wrap around*/
        pCard->SanEvent_PutIndex = 0;
   
    /* handle case where put operation coms faster than get operation */
    if (pCard->SanEvent_UngetCount < MAX_FC_EVENTS)       
    {
        pCard->SanEvent_UngetCount ++;                     /* if within limit, increment the # of items */
    }
    else
    {
        pCard->SanEvent_GetIndex = pCard->SanEvent_PutIndex;     /* buffer wrapped around, move the get pointer too */
    }
    return;   
}


ULONG SANGetPortAttributes(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL         srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_DISCOVERED_PORTATTRIBUTES   *data = (AG_DISCOVERED_PORTATTRIBUTES *)Srb->DataBuffer;
    ULONG                   paDevIndex, fcDevIndex;
    agFCDevInfo_t           devinfo;
    agRoot_t                *hpRoot = &pCard->hpRoot;
    PA_DEVICE               *dev;
   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetPortAttributes : port index %d\n", data->Com.DiscoveredPortIndex));
   
    paDevIndex = data->Com.DiscoveredPortIndex;
   
    if ( paDevIndex < gMaxPaDevices)
    {
        dev = pCard->Dev->PaDevice + paDevIndex;   
        fcDevIndex = dev->Index.Pa.FcDeviceIndex;
        if ( fcDevIndex != PA_DEVICE_NO_ENTRY) 
        {
            if  (pCard->hpFCDev[fcDevIndex]) 
            {
            fcGetDeviceInfo (hpRoot, pCard->hpFCDev[fcDevIndex], &devinfo );
      
            osCopy(data->Com.PortAttributes.NodeWWN.wwn, devinfo.NodeWWN, 8); 
            osCopy(data->Com.PortAttributes.PortWWN.wwn, devinfo.PortWWN, 8);
   
            data->Com.PortAttributes.PortFcId  =   ((ULONG)devinfo.CurrentAddress.reserved << 24 )|
                              ((ULONG)devinfo.CurrentAddress.Domain   << 16 )|
                              ((ULONG)devinfo.CurrentAddress.Area     << 8  )|
                              (ULONG)devinfo.CurrentAddress.AL_PA ;
            data->Com.PortAttributes.PortType = devinfo.PortType;      /*PTP, Fabric, etc. */
            data->Com.PortAttributes.PortState = devinfo.PortState;
            data->Com.PortAttributes.PortSupportedClassofService = devinfo.PortSupportedClassofService;
         
            osCopy(&data->Com.PortAttributes.PortSupportedFc4Types, devinfo.PortSupportedFc4Types, sizeof(HBA_FC4TYPES) );
            osCopy(&data->Com.PortAttributes.PortActiveFc4Types, devinfo.PortActiveFc4Types, sizeof(HBA_FC4TYPES) );
            C_strcpy(data->Com.PortAttributes.PortSymbolicName, "");      /* I don't know what it is */
            C_strcpy(data->Com.PortAttributes.OSDeviceName, "");          /* I don't know what it is */
            data->Com.PortAttributes.PortSupportedSpeed = devinfo.PortSupportedSpeed;
            data->Com.PortAttributes.PortSpeed = devinfo.PortSpeed; 
            data->Com.PortAttributes.PortMaxFrameSize = devinfo.MaxFrameSize;
            osCopy(data->Com.PortAttributes.FabricName.wwn, devinfo.FabricName, sizeof(data->Com.PortAttributes.FabricName) );
    //raghu should change here...
            //data->Com.PortAttributes.NumberofDiscoveredPorts = paDevIndex;
            data->Com.PortAttributes.NumberofDiscoveredPorts = 0;
            }
             
        }
        else
        {
            osDEBUGPRINT((ALWAYS_PRINT,"SANGetPortAttributes : No FC handle \n"));
            srbIoCtl->ReturnCode = HP_FC_RTN_INVALID_DEVICE;
        }
    }
    else
    {
        osDEBUGPRINT((ALWAYS_PRINT,"SANGetPortAttributes : PA Index > MAX \n"));
        srbIoCtl->ReturnCode = HP_FC_RTN_INVALID_DEVICE;
    }
      
    return 0;
   
}

ULONG SANGetHBAPortAttributes(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL         srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_PORTATTRIBUTES   *data = (AG_HBA_PORTATTRIBUTES *)Srb->DataBuffer;
    agFCChanInfo_t          chanInfo;
    ULONG                   x;
   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetHBAPortAttributes \n"));
   
    fcGetChannelInfo (&pCard->hpRoot, &chanInfo);
    
    osCopy(data->Com.NodeWWN.wwn, chanInfo.NodeWWN, 8); 
    osCopy(data->Com.PortWWN.wwn, chanInfo.PortWWN, 8);
    
    data->Com.PortFcId  = ((ULONG)chanInfo.CurrentAddress.reserved << 24 )|
                         ((ULONG)chanInfo.CurrentAddress.Domain   << 16 )|
                         ((ULONG)chanInfo.CurrentAddress.Area     << 8  )|
                         (ULONG)chanInfo.CurrentAddress.AL_PA ;
    data->Com.PortType = chanInfo.PortType;      /*PTP, Fabric, etc. */
    data->Com.PortState = chanInfo.PortState;
    data->Com.PortSupportedClassofService = chanInfo.PortSupportedClassofService;
   
    osCopy(&data->Com.PortSupportedFc4Types, chanInfo.PortSupportedFc4Types, sizeof(HBA_FC4TYPES) );
    osCopy(&data->Com.PortActiveFc4Types, chanInfo.PortActiveFc4Types, sizeof(HBA_FC4TYPES) );
    C_strcpy(data->Com.PortSymbolicName, "");      /* I don't know what it is */
    C_strcpy(data->Com.OSDeviceName, "");          /* I don't know what it is */
    data->Com.PortSupportedSpeed = chanInfo.PortSupportedSpeed;
    data->Com.PortSpeed = chanInfo.PortSpeed; 
    data->Com.PortMaxFrameSize = chanInfo.MaxFrameSize;
    osCopy(data->Com.FabricName.wwn, chanInfo.FabricName, sizeof(data->Com.FabricName) );
    data->Com.NumberofDiscoveredPorts = 0;
   
    for (x = 0; x < gMaxPaDevices;x++)
    {
        if ( pCard->Dev->PaDevice[x].Index.Pa.FcDeviceIndex != PA_DEVICE_NO_ENTRY) 
        {
         if (pCard->hpFCDev[pCard->Dev->PaDevice[x].Index.Pa.FcDeviceIndex]) 
            data->Com.NumberofDiscoveredPorts++;
        }
    }
   
    return 0;
   
}


ULONG SANGetPortStatistics(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL         srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_PORTSTATISTICS  *data = (AG_HBA_PORTSTATISTICS*) Srb->DataBuffer;
    agFCChanInfo_t          chanInfo;
    
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetPortStatistics\n"));
   
    fcGetChannelInfo (&pCard->hpRoot, &chanInfo);
   
    data->Com.SecondsSinceLastReset = 0;
    data->Com.TxFrames         = (((_int64)chanInfo.TxFramesUpper)<<32)  | chanInfo.TxFramesLower;
    data->Com.TxWords          = (((_int64)chanInfo.TxWordsUpper)<<32)   | chanInfo.TxWordsLower;
    data->Com.RxFrames         = (((_int64)chanInfo.RxFramesUpper)<<32)  | chanInfo.RxFramesLower;
    data->Com.RxWords          = (((_int64)chanInfo.RxWordsUpper)<<32)   | chanInfo.RxWordsLower;
    data->Com.LIPCount         = (((_int64)chanInfo.LIPCountUpper)<<32)  | chanInfo.LIPCountLower;
    data->Com.NOSCount         = (((_int64)chanInfo.NOSCountUpper)<<32)  | chanInfo.NOSCountLower;
    data->Com.ErrorFrames      = (((_int64)chanInfo.ErrorFramesUpper)<<32)  | chanInfo.ErrorFramesLower;
    data->Com.DumpedFrames     = (((_int64)chanInfo.DumpedFramesUpper)<<32)  | chanInfo.DumpedFramesLower;
    data->Com.LinkFailureCount = (((_int64)chanInfo.LinkFailureCountUpper)<<32)  | chanInfo.LinkFailureCountLower;
    data->Com.LossOfSyncCount  = (((_int64)chanInfo.LossOfSyncCountUpper)<<32)  | chanInfo.LossOfSyncCountLower;
    data->Com.LossOfSignalCount= (((_int64)chanInfo.LossOfSignalCountUpper)<<32)  | chanInfo.LossOfSignalCountLower;
    data->Com.PrimitiveSeqProtocolErrCount= (((_int64)chanInfo.PrimitiveSeqProtocolErrCountUpper)<<32)  | chanInfo.PrimitiveSeqProtocolErrCountLower;
    data->Com.InvalidTxWordCount= (((_int64)chanInfo.InvalidRxWordCountUpper)<<32)  | chanInfo.InvalidRxWordCountLower;
    data->Com.InvalidCRCCount  = (((_int64)chanInfo.InvalidCRCCountUpper)<<32)  | chanInfo.InvalidCRCCountLower;
    
    return 0;
   
}

typedef struct _ADAPTER_MODEL
{
    WCHAR    DID;
    WCHAR    VID;
    WCHAR    SSID;
    WCHAR    SVID;
    UCHAR    Model[64];
    UCHAR    ModelDescription[64];
}  ADAPTER_MODEL;


ADAPTER_MODEL  agModels[] = 
    {
    {0x1028,0,0,0,"HHBA-510x","Agilent HHBA-510x (Tachyon TL)"},
    {0x102a,0,0,0,"HHBA-512x","Agilent HHBA-512x (Tachyon TS)"},
    {0x1029,0,0,0,"HHBA-522x","Agilent HHBA-522x (Tachyon XL2)"},
    {0,0,0,0,"",""}
    };

ADAPTER_MODEL *GetAdapterModel(ULONG devid)
{
    ADAPTER_MODEL *this = agModels;
   
    while(this->DID)
    {
        if (this->DID == (WCHAR)devid)
            return this;
        this++;
    }
   
    return NULL;
}


ULONG SANGetHBAAttributes(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{   
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_ADAPTERATTRIBUTES   *data = (AG_HBA_ADAPTERATTRIBUTES*) Srb->DataBuffer;
    agFCChanInfo_t             chanInfo;
    ChipConfig_t               *pciConfig;
    ADAPTER_MODEL              *model;
    ULONG DEVID_VENDID;
    ULONG VENDID;
    ULONG DEVID;
    ULONG REVID;
    ULONG SVID;
    ULONG MAJOR_REVID;
    ULONG MINOR_REVID;

    osDEBUGPRINT((ALWAYS_PRINT,"SANGetHBAAttributes \n"));
   
    pciConfig = (ChipConfig_t*)pCard->pciConfigData;
   
    fcGetChannelInfo (&pCard->hpRoot, &chanInfo);
 
    C_strcpy(data->Com.Manufacturer, VER_COMPANYNAME_STR);
    C_sprintf(data->Com.SerialNumber, "%02x%02x%02x%02x%02x%02x%02x%02x", 
       chanInfo.NodeWWN[0], chanInfo.NodeWWN[1],
       chanInfo.NodeWWN[2], chanInfo.NodeWWN[3],
       chanInfo.NodeWWN[4], chanInfo.NodeWWN[5],
       chanInfo.NodeWWN[6], chanInfo.NodeWWN[7]);
   
    DEVID_VENDID = pciConfig->DEVID_VENDID;
    VENDID       = DEVID_VENDID & ChipConfig_VENDID_MASK;
    DEVID        = DEVID_VENDID & ChipConfig_DEVID_MASK;
    REVID        = pciConfig->CLSCODE_REVID & ChipConfig_REVID_Major_Minor_MASK;
    MAJOR_REVID  = (REVID & ChipConfig_REVID_Major_MASK) >> ChipConfig_REVID_Major_MASK_Shift;
    MINOR_REVID  = REVID & ChipConfig_REVID_Minor_MASK;
    SVID         = pciConfig->SVID;
    DEVID        = DEVID >> 16;
      
   
    model = GetAdapterModel(DEVID);
    if (model)
    {
        C_strcpy(data->Com.Model, model->Model);
        C_strcpy(data->Com.ModelDescription, model->ModelDescription);
    }
    else
    {
        C_strcpy(data->Com.Model, "Unknown");
        C_strcpy(data->Com.ModelDescription, "unknown");
    }     
      
    osCopy(data->Com.NodeWWN.wwn, chanInfo.NodeWWN, 8); 
    C_strcpy(data->Com.NodeSymbolicName, "");
    C_sprintf(data->Com.HardwareVersion, "%d.%d", MAJOR_REVID, MINOR_REVID);
    C_strcpy(data->Com.DriverVersion,  DRIVER_VERSION_STR);
    C_strcpy(data->Com.OptionROMVersion, "");
    C_strcpy(data->Com.FirmwareVersion, "");
    data->Com.VendorSpecificID = SVID;
    data->Com.NumberOfPorts = 1;
    C_strcpy(data->Com.DriverName, DRIVER_NAME);
   
//   *status = 0;
   
    return 0;
}


ULONG SANGetFCPLunMappingSize(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_FCPTARGETMAPPING_SIZE   *data = (AG_FCPTARGETMAPPING_SIZE*) Srb->DataBuffer;
    UCHAR                      p, t, l;
    PLU_EXTENSION              pLunExt;
    DEVICE_MAP                 *devmap;
    CHAR                       addrmode;
    USHORT                     paIndex;
    ULONG                      count = 0;
    
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetLunMappingSize\n"));
   
    for (p = 0; p < NUMBER_OF_BUSES; p++ ) 
    {
        for (t = 0; t < gMaximumTargetIDs; t++) 
        {
            devmap = GetDeviceMapping(pCard, p, t, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
      
            for (l = 0; l < devmap->Com.MaxLuns+1; l++) 
            {
                pLunExt = ScsiPortGetLogicalUnit (pCard, p, t, l);

                if (pLunExt != NULL) 
                {
                    count++;
                }
            }
        }
    }

   
    data->Com.TotalLunMappings = count;
    data->Com.SizeInBytes = sizeof (AG_HBA_FCPTARGETMAPPING) + count*sizeof(HBA_FCPBINDINGENTRY);
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetLunMappingSize: TotalLunMappings=%d  SizeInBytes=%d\n", 
       data->Com.TotalLunMappings, data->Com.SizeInBytes));
   
    return 0;
}

ULONG GetOSToFcpMapping(
    IN PCARD_EXTENSION pCard,
    HBA_FCPSCSIENTRY *fcpEntry, 
    UCHAR PathId, 
    UCHAR TargetId, 
    UCHAR Lun)
{
    PLU_EXTENSION           pLunExt;
    agFCDevInfo_t           devinfo;
    ULONG                   paDevIndex, fcDevIndex;
    LUN                     tempLun;                        /* added for FCP Lun data */
    PLUN                    ptempLun = &tempLun;
    ULONG                   status = -1;
    PA_DEVICE               *dev;
    
   
    pLunExt = ScsiPortGetLogicalUnit (pCard, PathId, TargetId, Lun);

    if (pLunExt != NULL) 
    {
        osZero( (void *)&tempLun, sizeof(tempLun));

        paDevIndex = pLunExt->PaDeviceIndex;
       
        if ( paDevIndex < gMaxPaDevices) 
        {
            dev = pCard->Dev->PaDevice + paDevIndex;   
            fcDevIndex = dev->Index.Pa.FcDeviceIndex;
            if ( fcDevIndex != PA_DEVICE_NO_ENTRY) 
            {
                fcGetDeviceInfo (&pCard->hpRoot, pCard->hpFCDev[fcDevIndex], &devinfo );
         
                if (devinfo.PortState == HBA_PORTSTATE_ONLINE)
                {
                    /* Fill HBA_FCPID data */
                    fcpEntry->FcpId.FcId  = 
                        ((ULONG)devinfo.CurrentAddress.reserved << 24 )|
                        ((ULONG)devinfo.CurrentAddress.Domain   << 16 )|
                        ((ULONG)devinfo.CurrentAddress.Area     << 8  )|
                        (ULONG)devinfo.CurrentAddress.AL_PA ;
                         
                osCopy (fcpEntry->FcpId.NodeWWN.wwn, devinfo.NodeWWN, sizeof(fcpEntry->FcpId.NodeWWN.wwn));
                osCopy (fcpEntry->FcpId.PortWWN.wwn, devinfo.PortWWN, sizeof(fcpEntry->FcpId.PortWWN.wwn));
         
                switch(pLunExt->Mode)
                {
                    case PA_DEVICE_TRY_MODE_VS:
                        SET_VS_LUN(ptempLun, PathId, TargetId, Lun)
                        break;
            
                    case PA_DEVICE_TRY_MODE_LU:
                        SET_LU_LUN(ptempLun, PathId, TargetId, Lun)
                        break;
            
                    case PA_DEVICE_TRY_MODE_PA:
                        SET_PA_LUN(ptempLun, PathId, TargetId, Lun)
                        break;
                } // end switch
         
                osCopy(&fcpEntry->FcpId.FcpLun, ptempLun, sizeof(fcpEntry->FcpId.FcpLun) );
         
                /* Fill HBA_SCSIID data */
         
                C_strcpy (fcpEntry->ScsiId.OSDeviceName, "");
                fcpEntry->ScsiId.ScsiBusNumber      = (ULONG) PathId;
                fcpEntry->ScsiId.ScsiTargetNumber   = (ULONG) TargetId;
                fcpEntry->ScsiId.ScsiOSLun          = (ULONG) Lun;
         
                status = 0;
                }
            }
            else
            {
                osDEBUGPRINT((ALWAYS_PRINT,"GetOsToFcpMapping: No FC handle \n"));
            }
        }
        else
        {  
            osDEBUGPRINT((ALWAYS_PRINT,"GetOsToFcpMapping : PA Index > MAX \n"));
        }
    }
    return status;
}

ULONG SANGetFCPLunMapping(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_FCPTARGETMAPPING   *data = (AG_HBA_FCPTARGETMAPPING*) Srb->DataBuffer;
    UCHAR                      p, t, l;
    DEVICE_MAP                 *devmap;
    CHAR                       addrmode;
    USHORT                     paIndex;
    LONG                       count=0, reqCount;
    ULONG                      done = FALSE;
    HBA_FCPSCSIENTRY           *fcpEntry = data->Com.entry;

   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetFCPLunMapping: req:%d entries\n", data->Com.NumberOfEntries));
    
    reqCount = (LONG) data->Com.NumberOfEntries;       /* get requested number of entries */
    
    data->Com.NumberOfEntries = 0;                     /* reset number of entries */
   
    osZero(( void *)data, sizeof(data));
    for (p = 0; (p < NUMBER_OF_BUSES) && (done==FALSE); p++ ) 
    {
        for (t = 0; (t < gMaximumTargetIDs) && (done==FALSE); t++) 
        {
            devmap = GetDeviceMapping(pCard, p, t, 0, &addrmode, &paIndex);
            if (!devmap)
                continue;
      
            for (l = 0; (l < devmap->Com.MaxLuns+1) && (done==FALSE); l++) 
            {
                if (!GetOSToFcpMapping(pCard, fcpEntry, p,t,l))
                {
                    data->Com.NumberOfEntries++;     /* incerement number of entries */
                    fcpEntry++;                      /* move the storage pointer */                  
                    reqCount--;                      /* decrement # of requested entries */
                    if (reqCount <=0 )               /* is it done yet ? */
                        done = TRUE;
                }
            }
        }
    }

    return 0;
}


ULONG SANGetOsScsiFcpAttribute(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_SCSI_FCP_ATTRIBUTE      *data = (AG_SCSI_FCP_ATTRIBUTE*) Srb->DataBuffer;
    HBA_FCPSCSIENTRY           fcpEntry;
    UCHAR                      pathId, targetId, lun;
    
    pathId   = (UCHAR) data->Com.OsScsi.OsScsiBusNumber;
    targetId = (UCHAR) data->Com.OsScsi.OsScsiTargetNumber;
    lun      = (UCHAR) data->Com.OsScsi.OsScsiLun;
   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetOsScsiFcpAttribute: Bus=%d Tid=%d Lun=%d\n",pathId, targetId, lun));
    if (!GetOSToFcpMapping(pCard, &fcpEntry, pathId, targetId, lun))
    {
        osCopy(&data->Com.FcpId, &fcpEntry.FcpId, sizeof(data->Com.FcpId) );
    }
    else
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED; 
        return 1; /* SNIA : This is needed as on some older versions of win2, setting
                  Srb return code is not working */
    }

    return 0;
}


ULONG SANGetEventBuffer(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_EVENTINFO           *data = (AG_HBA_EVENTINFO*) Srb->DataBuffer;
    ULONG                      portid;
    agFCChanInfo_t             chanInfo;
    SAN_EVENTINFO              *this=NULL;
   
    osDEBUGPRINT((ALWAYS_PRINT,"SANGetEventBuffer\n"));
   
    this = SANGetNextBuffer(pCard);
    if (this)
    {
        fcGetChannelInfo (&pCard->hpRoot, &chanInfo);
      
        portid = ((ULONG)chanInfo.CurrentAddress.reserved << 24 )|
               ((ULONG)chanInfo.CurrentAddress.Domain   << 16 )|
               ((ULONG)chanInfo.CurrentAddress.Area     << 8  )|
               (ULONG)chanInfo.CurrentAddress.AL_PA ;
             
        data->Com.EventCode = this->EventCode;
        data->Com.Event.Link_EventInfo.PortFcId = portid;
        data->Com.Event.Link_EventInfo.Reserved[0] = this->Event.Link_EventInfo.Reserved[0];
        data->Com.Event.Link_EventInfo.Reserved[1] = this->Event.Link_EventInfo.Reserved[1];
        data->Com.Event.Link_EventInfo.Reserved[2] = this->Event.Link_EventInfo.Reserved[2];
    }
    else
    {
        srbIoCtl->ReturnCode = HP_FC_RTN_FAILED; 
    }   
   
    return 0;
}


ULONG SANGetPersistentBindingSize(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_FCPBINDING_SIZE         *data = (AG_FCPBINDING_SIZE*) Srb->DataBuffer;
    SCSI_REQUEST_BLOCK         tempSrb;
    AG_FCPTARGETMAPPING_SIZE   tempBuffer;
    UCHAR                      tempStatus = SRB_STATUS_SUCCESS;
    PSRB_IO_CONTROL            tempSrbIoCtl;

    tempSrb.DataBuffer = &tempBuffer;
    tempSrb.DataTransferLength = sizeof(tempBuffer);
    tempSrbIoCtl = (PSRB_IO_CONTROL) &tempBuffer;
   
    SANGetFCPLunMappingSize(&tempSrb, pCard, &tempStatus);
   
    if( (tempStatus == SRB_STATUS_SUCCESS) && (tempSrbIoCtl->ReturnCode == HP_FC_RTN_OK) )
    {
        data->Com.TotalLunBindings = tempBuffer.Com.TotalLunMappings;
        data->Com.SizeInBytes = tempBuffer.Com.SizeInBytes;
    }
    else
    {
        *status = tempStatus;
        srbIoCtl->ReturnCode = tempSrbIoCtl->ReturnCode;      
    }
   
    return 0;
      
}

ULONG SANGetPersistentBinding(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCARD_EXTENSION pCard,
    UCHAR    *status
    )
{
    PSRB_IO_CONTROL            srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    AG_HBA_FCPBINDING          *data = (AG_HBA_FCPBINDING*) Srb->DataBuffer;
    
    return 0;
}


#define PROCESS_IOCTL(size, func)   \
   { \
      if (Srb->DataTransferLength >= size ) \
      { \
         func (Srb, pCard, &status); \
      } \
      else \
      { \
         osDEBUGPRINT((ALWAYS_PRINT,"PROCESS_IOCTL Func %d : GivenSize=%d required=%d\n", \
            srbIoCtl->ControlCode, Srb->DataTransferLength, size));  \
         srbIoCtl->ReturnCode = HP_FC_RTN_INSUFFICIENT_BUFFER; \
      } \
   }

ULONG AgSANIoctl(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN     *LinkResetPerformed,
    BOOLEAN     *DeviceResetPerformed,
    UCHAR       *srb_status,
    UCHAR       *PathId, 
    UCHAR       *TargetId
    )
{
    agRoot_t * phpRoot      =   &pCard->hpRoot;
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
    PSRB_IO_CONTROL srbIoCtl;
    UCHAR status;
//  PSRB_IO_CONTROL srbIoCtl;
//  ULONG    done = FALSE;
//    UCHAR    srbPathId = Srb->PathId;
//    UCHAR    srbTargetId = Srb->TargetId;
//    UCHAR    srbLun = Srb->Lun;

    status = *srb_status;
    srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));
    
    switch (srbIoCtl->ControlCode) 
    {
        case AG_IOCTL_GET_HBA_ATTRIBUTES : 
            PROCESS_IOCTL(sizeof(AG_HBA_ADAPTERATTRIBUTES), SANGetHBAAttributes)
            break;
         
        case AG_IOCTL_GET_HBA_PORT_ATTRIBUTES: 
            PROCESS_IOCTL(sizeof(AG_HBA_PORTATTRIBUTES), SANGetHBAPortAttributes)
            break;

        case AG_IOCTL_GET_HBA_PORT_STATISTICS : 
            PROCESS_IOCTL(sizeof(AG_HBA_PORTSTATISTICS), SANGetPortStatistics)
            break;

        case AG_IOCTL_GET_PORT_ATTRIBUTES : 
            PROCESS_IOCTL(sizeof(AG_DISCOVERED_PORTATTRIBUTES), SANGetPortAttributes)
            break;

        case AG_IOCTL_GET_FCP_LUN_MAPPING_SIZE:
            PROCESS_IOCTL(sizeof(AG_FCPTARGETMAPPING_SIZE), SANGetFCPLunMappingSize)
            break;
     
        case AG_IOCTL_GET_FCP_LUN_MAPPING:
            PROCESS_IOCTL(sizeof(AG_HBA_FCPTARGETMAPPING), SANGetFCPLunMapping)
            break;
     
        case AG_IOCTL_GET_EVENT_BUFFER:
            PROCESS_IOCTL(sizeof(AG_HBA_EVENTINFO), SANGetEventBuffer)
            break;
     
        case AG_IOCTL_GET_OS_SCSI_FCP_ATTRIBUTE:
            PROCESS_IOCTL(sizeof(AG_SCSI_FCP_ATTRIBUTE), SANGetOsScsiFcpAttribute)
            break;
     
        case AG_IOCTL_GET_PERSISTENT_BINDING_SIZE:
            PROCESS_IOCTL(sizeof(AG_FCPBINDING_SIZE), SANGetPersistentBindingSize)
            break;
     
        case AG_IOCTL_GET_PERSISTENT_BINDING:
            PROCESS_IOCTL(sizeof(AG_HBA_FCPBINDING), SANGetPersistentBinding)
            break;
         
        default :
            osDEBUGPRINT((ALWAYS_PRINT,"AgSANIoctl: MiniportIOCtl not supported\n"));
            srbIoCtl->ReturnCode = HP_FC_RTN_BAD_CTL_CODE;
    } // end IOCTL switch

    if( (status != SRB_STATUS_SUCCESS) || (srbIoCtl->ReturnCode) )
        osDEBUGPRINT((ALWAYS_PRINT,"AgSANIoctl: Func %d failed. NT Status %xx  Ioctl Status %xx\n",
            srbIoCtl->ControlCode, status, srbIoCtl->ReturnCode));
    *srb_status = status;
   
    return 0;
           
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\sfstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/SFSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 9/12/00 5:01p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/SFState.C

--*/

#ifndef __SFState_H__
#define __SFState_H__

#define SFTHREAD_FINISHED               0xBAD10BAD

#define SF_EDTOV                         900000  /* Micro seconds  was 2 000 000*/
#define SF_FLOGI_TOV                     900000  /* Micro seconds  was   700 000*/
#define SF_RECTOV                        500000  /* */

#define SFCompletion                    42

#define SFStateConfused                 0
#define SFStateFree                     1

#define SFStateDoPlogi                  2
#define SFStatePlogiAccept              3
#define SFStatePlogiRej                 4
#define SFStatePlogiBadALPA             5
#define SFStatePlogiTimedOut            6

#define SFStateDoPrli                   7
#define SFStatePrliAccept               8
#define SFStatePrliRej                  9
#define SFStatePrliBadAlpa              10
#define SFStatePrliTimedOut             11

#define SFStateDoFlogi                  12
#define SFStateFlogiAccept              13
#define SFStateFlogiRej                 14
#define SFStateFlogiBadALPA             15
#define SFStateFlogiTimedOut            16

#define SFStateDoLogo                  17
#define SFStateLogoAccept              18
#define SFStateLogoRej                 19
#define SFStateLogoBadALPA             20
#define SFStateLogoTimedOut            21

#define SFStateDoPrlo                   22
#define SFStatePrloAccept               23
#define SFStatePrloRej                  24
#define SFStatePrloBadALPA              25
#define SFStatePrloTimedOut             26

#define SFStateDoAdisc                  27
#define SFStateAdiscAccept              28
#define SFStateAdiscRej                 29
#define SFStateAdiscBadALPA             30
#define SFStateAdiscTimedOut            31

#define SFStateDoPdisc                  32
#define SFStatePdiscAccept              33
#define SFStatePdiscRej                 34
#define SFStatePdiscBadALPA             35
#define SFStatePdiscTimedOut            36

#define SFStateDoAbort                  37
#define SFStateAbortAccept              38
#define SFStateAbortRej                 39
#define SFStateAbortBadALPA             40
#define SFStateAbortTimedOut            41

#define SFStateDoResetDevice                 42
#define SFStateResetDeviceAccept             43
#define SFStateResetDeviceRej                44
#define SFStateResetDeviceBadALPA            45
#define SFStateResetDeviceTimedOut           46

#define SFStateDoLS_RJT                      47
#define SFStateLS_RJT_Done                   48

#define SFStateDoPlogiAccept                 49
#define SFStatePlogiAccept_Done              50

#define SFStateDoPrliAccept                  51
#define SFStatePrliAccept_Done               52

#define SFStateDoELSAccept                   53
#define SFStateELSAccept_Done                54

#define SFStateDoFCP_DR_ACC_Reply            55
#define SFStateFCP_DR_ACC_Reply_Done         56

#define SFStateLS_RJT_TimeOut                57
#define SFStatePlogiAccept_TimeOut           58
#define SFStatePrliAccept_TimeOut            59
#define SFStateELSAccept_TimeOut             60
#define SFStateFCP_DR_ACC_Reply_TimeOut      61

#ifdef NAME_SERVICES
#define SFStateDoRFT_ID                      62
#define SFStateRFT_IDAccept                  63
#define SFStateRFT_IDRej                     64
#define SFStateRFT_IDBadALPA                 65
#define SFStateRFT_IDTimedOut                66

#define SFStateDoGID_FT                      67
#define SFStateGID_FTAccept                  68
#define SFStateGID_FTRej                     69
#define SFStateGID_FTBadALPA                 70
#define SFStateGID_FTTimedOut                71

#define SFStateDoSCR                         72
#define SFStateSCRAccept                     73
#define SFStateSCRBadALPA                    74
#define SFStateSCRTimedOut                   75
#define SFStateSCRRej                        76

#endif

#define SFStateDoSRR                  77
#define SFStateSRRAccept              78
#define SFStateSRRRej                 79
#define SFStateSRRBadALPA             80
#define SFStateSRRTimedOut            81

#define SFStateDoREC                  82
#define SFStateRECAccept              83
#define SFStateRECRej                 84
#define SFStateRECBadALPA             85
#define SFStateRECTimedOut            86

#define SFStateDoADISCAccept          87
#define SFStateADISCAccept_Done       88
#define SFStateADISCAccept_TimeOut    89

#ifdef _DvrArch_1_30_
#define SFStateDoFarpRequest                 90
#define SFStateFarpRequestDone               91
#define SFStateFarpRequestTimedOut           92
#define SFStateDoFarpReply                   93
#define SFStateFarpReplyDone                 94
#define SFStateFarpReplyTimedOut             95 /* not handled, exceeded the maximum state number */
#define SFStateMAXState         SFStateFarpReplayTimedOut
#else /* _DvrArch_1_30_ was not defined */
#define SFStateMAXState         SFStateADISCAccept_TimeOut
#endif /* _DvrArch_1_30_ was not defined */

#define SFEventReset                         1

#define SFEventDoPlogi                       2
#define SFEventPlogiAccept                   3
#define SFEventPlogiRej                      4
#define SFEventPlogiBadALPA                  5
#define SFEventPlogiTimedOut                 6

#define SFEventDoPrli                        7
#define SFEventPrliAccept                    8
#define SFEventPrliRej                       9
#define SFEventPrliBadALPA                   10
#define SFEventPrliTimedOut                  11

#define SFEventDoFlogi                       12
#define SFEventFlogiAccept                   13
#define SFEventFlogiRej                      14
#define SFEventFlogiBadALPA                  15
#define SFEventFlogiTimedOut                 16

#define SFEventDoLogo                       17
#define SFEventLogoAccept                   18
#define SFEventLogoRej                      19
#define SFEventLogoBadALPA                  20
#define SFEventLogoTimedOut                 21

#define SFEventDoPrlo                        22
#define SFEventPrloAccept                    23
#define SFEventPrloRej                       24
#define SFEventPrloBadALPA                   25
#define SFEventPrloTimedOut                  26

#define SFEventDoAdisc                       27
#define SFEventAdiscAccept                   28
#define SFEventAdiscRej                      29
#define SFEventAdiscBadALPA                  30
#define SFEventAdiscTimedOut                 31

#define SFEventDoPdisc                       32
#define SFEventPdiscAccept                   33
#define SFEventPdiscRej                      34
#define SFEventPdiscBadALPA                  35
#define SFEventPdiscTimedOut                 36

#define SFEventDoAbort                       37
#define SFEventAbortAccept                   38
#define SFEventAbortRej                      39
#define SFEventAbortBadALPA                  40
#define SFEventAbortTimedOut                 41

#define SFEventDoResetDevice                 42
#define SFEventResetDeviceAccept             43
#define SFEventResetDeviceRej                44
#define SFEventResetDeviceBadALPA            45
#define SFEventResetDeviceTimedOut           46

#define SFEventDoLS_RJT                      47
#define SFEventLS_RJT_Done                   48

#define SFEventDoPlogiAccept                 49
#define SFEventPlogiAccept_Done              50

#define SFEventDoPrliAccept                  51
#define SFEventPrliAccept_Done               52

#define SFEventDoELSAccept                   53
#define SFEventELSAccept_Done                54

#define SFEventDoFCP_DR_ACC_Reply            55
#define SFEventFCP_DR_ACC_Reply_Done         56

#define SFEventLS_RJT_TimeOut                57
#define SFEventPlogiAccept_TimeOut           58
#define SFEventPrliAccept_TimeOut            59
#define SFEventELSAccept_TimeOut             60
#define SFEventFCP_DR_ACC_Reply_TimeOut      61
#ifdef NAME_SERVICES
#define SFEventDoRFT_ID                      62
#define SFEventRFT_IDAccept                  63
#define SFEventRFT_IDRej                     64
#define SFEventRFT_IDBadALPA                 65
#define SFEventRFT_IDTimedOut                66

#define SFEventDoGID_FT                      67
#define SFEventGID_FTAccept                  68
#define SFEventGID_FTRej                     69
#define SFEventGID_FTBadALPA                 70
#define SFEventGID_FTTimedOut                71

#define SFEventDoSCR                         72
#define SFEventSCRAccept                     73
#define SFEventSCRRej                        74
#define SFEventSCRBadALPA                    75
#define SFEventSCRTimedOut                   76
#endif

#define SFEventDoSRR                         77
#define SFEventSRRAccept                     78
#define SFEventSRRRej                        79
#define SFEventSRRBadALPA                    80
#define SFEventSRRTimedOut                   81

#define SFEventDoREC                         82
#define SFEventRECAccept                     83
#define SFEventRECRej                        84
#define SFEventRECBadALPA                    85
#define SFEventRECTimedOut                   86

#define SFEventDoADISCAccept                 87
#define SFEventADISCAccept_Done              88
#define SFEventADISCAccept_TimeOut           89


#ifdef _DvrArch_1_30_
#define SFEventDoFarpRequest                 90
#define SFEventFarpReplied                   91
#define SFEventFarpRequestTimedOut           92
#define SFEventDoFarpReply                   93
#define SFEventFarpReplyDone                 94
#define SFEventFarpReplyTimedOut             95 /* not handled, exceeded the maximum event number */
#define SFEventMAXState   SFEventReplyTimedOut
#else /* _DvrArch_1_30_ was not defined */
#define SFEventMAXEvent   SFEventADISCAccept_TimeOut      
#endif /* _DvrArch_1_30_ was not defined */


STATE_PROTO(SFActionConfused);
STATE_PROTO(SFActionReset);

STATE_PROTO(SFActionDoPlogi);
STATE_PROTO(SFActionPlogiAccept);
STATE_PROTO(SFActionPlogiRej);
STATE_PROTO(SFActionPlogiBadALPA);
STATE_PROTO(SFActionPlogiTimedOut);

STATE_PROTO(SFActionDoPrli);
STATE_PROTO(SFActionPrliAccept);
STATE_PROTO(SFActionPrliRej);
STATE_PROTO(SFActionPrliBadALPA);
STATE_PROTO(SFActionPrliTimedOut);

STATE_PROTO(SFActionDoFlogi);
STATE_PROTO(SFActionFlogiAccept);
STATE_PROTO(SFActionFlogiRej);
STATE_PROTO(SFActionFlogiBadALPA);
STATE_PROTO(SFActionFlogiTimedOut);

STATE_PROTO(SFActionDoLogo);
STATE_PROTO(SFActionLogoAccept);
STATE_PROTO(SFActionLogoRej);
STATE_PROTO(SFActionLogoBadALPA);
STATE_PROTO(SFActionLogoTimedOut);

STATE_PROTO(SFActionDoPrlo);
STATE_PROTO(SFActionPrloAccept);
STATE_PROTO(SFActionPrloRej);
STATE_PROTO(SFActionPrloBadALPA);
STATE_PROTO(SFActionPrloTimedOut);

STATE_PROTO(SFActionDoAdisc);
STATE_PROTO(SFActionAdiscAccept);
STATE_PROTO(SFActionAdiscRej);
STATE_PROTO(SFActionAdiscBadALPA);
STATE_PROTO(SFActionAdiscTimedOut);

STATE_PROTO(SFActionDoPdisc);
STATE_PROTO(SFActionPdiscAccept);
STATE_PROTO(SFActionPdiscRej);
STATE_PROTO(SFActionPdiscBadALPA);
STATE_PROTO(SFActionPdiscTimedOut);

STATE_PROTO(SFActionDoAbort);
STATE_PROTO(SFActionAbortAccept);
STATE_PROTO(SFActionAbortRej);
STATE_PROTO(SFActionAbortBadALPA);
STATE_PROTO(SFActionAbortTimedOut);

STATE_PROTO(SFActionDoResetDevice);
STATE_PROTO(SFActionResetDeviceAccept);
STATE_PROTO(SFActionResetDeviceRej);
STATE_PROTO(SFActionResetDeviceBadALPA);
STATE_PROTO(SFActionResetDeviceTimedOut);


STATE_PROTO(SFActionDoLS_RJT);
STATE_PROTO(SFActionLS_RJT_Done );

STATE_PROTO(SFActionDoPlogiAccept);
STATE_PROTO(SFActionPlogiAccept_Done);

STATE_PROTO(SFActionDoPrliAccept);
STATE_PROTO(SFActionPrliAccept_Done);

STATE_PROTO(SFActionDoELSAccept);
STATE_PROTO(SFActionELSAccept_Done);

STATE_PROTO(SFActionDoFCP_DR_ACC_Reply);
STATE_PROTO(SFActionFCP_DR_ACC_Reply_Done);


STATE_PROTO(SFActionLS_RJT_TimeOut );
STATE_PROTO(SFActionPlogiAccept_TimeOut);
STATE_PROTO(SFActionPrliAccept_TimeOut);
STATE_PROTO(SFActionELSAccept_TimeOut);
STATE_PROTO(SFActionFCP_DR_ACC_Reply_TimeOut);
STATE_PROTO(SFActionDoRFT_ID);
STATE_PROTO(SFActionRFT_IDAccept);
STATE_PROTO(SFActionRFT_IDRej);
STATE_PROTO(SFActionRFT_IDBadALPA);
STATE_PROTO(SFActionRFT_IDTimedOut);
STATE_PROTO(SFActionDoGID_FT);
STATE_PROTO(SFActionGID_FTAccept);
STATE_PROTO(SFActionGID_FTRej);
STATE_PROTO(SFActionGID_FTBadALPA);
STATE_PROTO(SFActionGID_FTTimedOut);

STATE_PROTO(SFActionDoSCR);
STATE_PROTO(SFActionSCRAccept);
STATE_PROTO(SFActionSCRRej);
STATE_PROTO(SFActionSCRBadALPA);
STATE_PROTO(SFActionSCRTimedOut);

STATE_PROTO(SFActionDoSRR);
STATE_PROTO(SFActionSRRAccept);
STATE_PROTO(SFActionSRRRej);
STATE_PROTO(SFActionSRRBadALPA);
STATE_PROTO(SFActionSRRTimedOut);

STATE_PROTO(SFActionDoREC);
STATE_PROTO(SFActionRECAccept);
STATE_PROTO(SFActionRECRej);
STATE_PROTO(SFActionRECBadALPA);
STATE_PROTO(SFActionRECTimedOut);

STATE_PROTO(SFActionDoADISCAccept);
STATE_PROTO(SFActionADISCAccept_Done);
STATE_PROTO(SFActionADISCAccept_TimeOut);

#ifdef _DvrArch_1_30_
STATE_PROTO(SFActionDoFarpRequest);
STATE_PROTO(SFActionFarpRequestDone);
STATE_PROTO(SFActionFarpRequestTimedOut);
STATE_PROTO(SFActionDoFarpReply);
STATE_PROTO(SFActionFarpReplyDone);
STATE_PROTO(SFActionFarpReplyTimedOut);
#endif /* _DvrArch_1_30_ was not defined */

extern stateTransitionMatrix_t SFStateTransitionMatrix;
extern stateActionScalar_t     SFStateActionScalar;


void SFFuncIRB_OnCardInit(SFThread_t  * SFThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit);
void SFFuncIRB_OffCardInit(SFThread_t  * SFThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit);

#ifdef USESTATEMACROS

void testSFthread( agRoot_t * hpRoot );

#define SFSTATE_FUNCTION_ACTION( x , Action) extern void x( fi_thread__t * thread, \
                 eventRecord_t * eventRecord ){         \
    agRoot_t * hpRoot=thread->hpRoot;                   \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",             \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "Sends event...%s %d",          \
                      #Action,(char *)agNULL,             \
                      (void * )agNULL,(void * )agNULL,  \
                      Action,0,0,0,0,0,0,0);            \
    fiSetEventRecord(eventRecord, thread, Action);   }  \

#define SFSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                            \
    CThread_t  * pCThread=CThread_ptr(hpRoot);                   \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;             \
    DevThread_t * pDevThread=pCDBThread->Device;                 \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (char *)agNULL,(char *)agNULL,        \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\

#define SFSTATE_FUNCTION_MULTI_ACTION(x,Action0,Action1,Action2,Action3) extern void x( fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){ \
    agRoot_t * hpRoot = thread->hpRoot;                            \
    CThread_t  * pCThread = CThread_ptr(hpRoot);                   \
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;             \
    DevThread_t * pDevThread = pCDBThread->Device;                 \
    os_bit8 WhichAction[4];                                            \
    static  os_bit32 ActionCount=0;                                    \
    WhichAction[0] = Action0;                                       \
    WhichAction[1] = Action1;                                       \
    WhichAction[2] = Action2;                                       \
    WhichAction[3] = Action3;                                       \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d ALPA %X",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                    \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...returns event %s %d",       \
                      #Action0,#Action1,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)WhichAction[ActionCount],  \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "or %s  or %s",                  \
                      (void * )agNULL,(void * )agNULL,  \
                      #Action2,#Action3,                \
                      0,0,0,0,0,0,0,0);                 \
    fiSetEventRecord(eventRecord,thread,WhichAction[ActionCount]);  \
    if(ActionCount<3)ActionCount++;                              \
    else ActionCount =0;                                            \
    }                                                               \

#ifdef TestSFStateMachine

char * SFStateString[]=
{

    "SFStateConfused            ",
    "SFStateFree                ",
    "SFStateDoPlogi             ",
    "SFStatePlogiAccept         ",
    "SFStatePlogiRej            ",
    "SFStatePlogiBadALPA        ",
    "SFStatePlogiTimedOut       ",
    "SFStateDoPrli              ",
    "SFStatePrliAccept          ",
    "SFStatePrliRej             ",
    "SFStatePrliBadAlpa         ",
    "SFStatePrliTimedOut        ",
    "SFStateDoFlogi             ",
    "SFStateFlogiAccept         ",
    "SFStateFlogiRej            ",
    "SFStateFlogiBadALPA        ",
    "SFStateFlogiTimedOut       ",
    "SFStateDoLogo              ",
    "SFStateLogoAccept          ",
    "SFStateLogoRej             ",
    "SFStateLogoBadALPA         ",
    "SFStateLogoTimedOut        ",
    "SFStateDoPrlo              ",
    "SFStatePrloAccept          ",
    "SFStatePrloRej             ",
    "SFStatePrloBadALPA         ",
    "SFStatePrloTimedOut        ",
    "SFStateDoAdisc             ",
    "SFStateAdiscAccept         ",
    "SFStateAdiscRej            ",
    "SFStateAdiscBadALPA        ",
    "SFStateAdiscTimedOut       ",
    "SFStateDoPdisc             ",
    "SFStatePdiscAccept         ",
    "SFStatePdiscRej            ",
    "SFStatePdiscBadALPA        ",
    "SFStatePdiscTimedOut       ",
    "SFStateDoAbort             ",
    "SFStateAbortAccept         ",
    "SFStateAbortRej            ",
    "SFStateAbortBadALPA        ",
    "SFStateAbortTimedOut       ",
    "SFStateDoResetDevice       ",
    "SFStateResetDeviceAccept   ",
    "SFStateResetDeviceRej      ",
    "SFStateResetDeviceBadALPA  ",
    "SFStateResetDeviceTimedOut ",
    "SFStateDoLS_RJT            ",
    "SFStateLS_RJT_Done         ",
    "SFStateDoPlogiAccept       ",
    "SFStatePlogiAccept_Done    ",
    "SFStateDoPrliAccept        ",
    "SFStatePrliAccept_Done     ",
    "SFStateDoELSAccept         ",
    "SFStateELSAccept_Done      ",
    "SFStateDoFCP_DR_ACC_Reply  ",
    "SFStateFCP_DR_ACC_Reply_Done ",
    "SFStateLS_RJT_TimeOut        ",
    "SFStatePlogiAccept_TimeOut   ",
    "SFStatePrliAccept_TimeOut       ",
    "SFStateELSAccept_TimeOut        ",
    "SFStateFCP_DR_ACC_Reply_TimeOut ",
    "SFStateDoRFT_ID                 ",
    "SFStateRFT_IDAccept             ",
    "SFStateRFT_IDRej                ",
    "SFStateRFT_IDBadALPA            ",
    "SFStateRFT_IDTimedOut           ",
    "SFStateDoGID_FT                 ",
    "SFStateGID_FTAccept             ",
    "SFStateGID_FTRej                ",
    "SFStateGID_FTBadALPA            ",
    "SFStateGID_FTTimedOut           ",
    "SFStateDoSCR                    ",
    "SFStateSCRAccept                ",
    "SFStateSCRBadALPA               ",
    "SFStateSCRTimedOut              ",
    "SFStateSCRRej                   ",
    "SFStateDoSRR                    ",
    "SFStateSRRAccept                ",
    "SFStateSRRRej                   ",
    "SFStateSRRBadALPA               ",
    "SFStateSRRTimedOut              ",
    "SFStateDoREC                    ",
    "SFStateRECAccept                ",
    "SFStateRECRej                   ",
    "SFStateRECBadALPA               ",
    "SFStateRECTimedOut              ",
    "SFStateDoADISCAccept            ",
    "SFStateADISCAccept_Done         ",
    "SFStateADISCAccept_TimeOut      ",
    agNULL
};

char * SFEventString[]=
{
    "SFEventReset                    ",
    "SFEventDoPlogi                  ",
    "SFEventPlogiAccept              ",
    "SFEventPlogiRej                 ",
    "SFEventPlogiBadALPA             ",
    "SFEventPlogiTimedOut            ",
    "SFEventDoPrli                   ",
    "SFEventPrliAccept               ",
    "SFEventPrliRej                  ",
    "SFEventPrliBadALPA              ",
    "SFEventPrliTimedOut             ",
    "SFEventDoFlogi                  ",
    "SFEventFlogiAccept              ",
    "SFEventFlogiRej                 ",
    "SFEventFlogiBadALPA             ",
    "SFEventFlogiTimedOut            ",
    "SFEventDoLogo                   ",
    "SFEventLogoAccept               ",
    "SFEventLogoRej                  ",
    "SFEventLogoBadALPA              ",
    "SFEventLogoTimedOut             ",
    "SFEventDoPrlo                   ",
    "SFEventPrloAccept               ",
    "SFEventPrloRej                  ",
    "SFEventPrloBadALPA              ",
    "SFEventPrloTimedOut             ",
    "SFEventDoAdisc                  ",
    "SFEventAdiscAccept              ",
    "SFEventAdiscRej                 ",
    "SFEventAdiscBadALPA             ",
    "SFEventAdiscTimedOut            ",
    "SFEventDoPdisc                  ",
    "SFEventPdiscAccept              ",
    "SFEventPdiscRej                 ",
    "SFEventPdiscBadALPA             ",
    "SFEventPdiscTimedOut            ",
    "SFEventDoAbort                  ",
    "SFEventAbortAccept              ",
    "SFEventAbortRej                 ",
    "SFEventAbortBadALPA             ",
    "SFEventAbortTimedOut            ",
    "SFEventDoResetDevice            ",
    "SFEventResetDeviceAccept        ",
    "SFEventResetDeviceRej           ",
    "SFEventResetDeviceBadALPA       ",
    "SFEventResetDeviceTimedOut      ",
    "SFEventDoLS_RJT                 ",
    "SFEventLS_RJT_Done              ",
    "SFEventDoPlogiAccept            ",
    "SFEventPlogiAccept_Done         ",
    "SFEventDoPrliAccept             ",
    "SFEventPrliAccept_Done          ",
    "SFEventDoELSAccept              ",
    "SFEventELSAccept_Done           ",
    "SFEventDoFCP_DR_ACC_Reply       ",
    "SFEventFCP_DR_ACC_Reply_Done    ",
    "SFEventLS_RJT_TimeOut           ",
    "SFEventPlogiAccept_TimeOut      ",
    "SFEventPrliAccept_TimeOut       ",
    "SFEventELSAccept_TimeOut        ",
    "SFEventFCP_DR_ACC_Reply_TimeOut ",
    "SFEventDoRFT_ID                 ",
    "SFEventRFT_IDAccept             ",
    "SFEventRFT_IDRej                ",
    "SFEventRFT_IDBadALPA            ",
    "SFEventRFT_IDTimedOut           ",
    "SFEventDoGID_FT                 ",
    "SFEventGID_FTAccept             ",
    "SFEventGID_FTRej                ",
    "SFEventGID_FTBadALPA            ",
    "SFEventGID_FTTimedOut           ",
    "SFEventDoSCR                    ",
    "SFEventSCRAccept                ",
    "SFEventSCRRej                   ",
    "SFEventSCRBadALPA               ",
    "SFEventSCRTimedOut              ",
    "SFEventDoSRR                    ",
    "SFEventSRRAccept                ",
    "SFEventSRRRej                   ",
    "SFEventSRRBadALPA               ",
    "SFEventSRRTimedOut              ",
    "SFEventDoREC                    ",
    "SFEventRECAccept                ",
    "SFEventRECRej                   ",
    "SFEventRECBadALPA               ",
    "SFEventRECTimedOut              ",
    "SFEventDoADISCAccept            ",
    "SFEventADISCAccept_Done         ",
    "SFEventADISCAccept_TimeOut      ",
    agNULL
};
#endif /* TestSFStateMachine was defined */

#endif /* USESTATEMACROS was defined */

#endif /*  __SFState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\sanioctl.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   sanioctl.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/sanioctl.h $


Revision History:

   $Revision: 2 $
   $Date: 9/07/00 11:19a $
   $Modtime:: 8/31/00 3:27p            $

Notes:


--*/

#ifndef SANIOCTL_H
#define SANIOCTL_H

#include "buildop.h"             //LP021100 build switches
#include "osflags.h"
#include "hbaapi.h"
#include "sanapi.h"

/* FOR REFERENCE - from NTDDSCSI.h
typedef struct _SRB_IO_CONTROL 
{
   ULONG HeaderLength;
   UCHAR Signature[8];
   ULONG Timeout;
   ULONG ControlCode;
   ULONG ReturnCode;
   ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;
*/

#endif  // SANIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\sf_fcp.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/SF_FCP.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/SF_FCP.C

--*/

#ifndef __SF_FCP_H__
#define __SF_FCP_H__

/* SF_CMND_Type(SF_CMND_Class==SFThread_SF_CMND_Class_SF_FCP) Declarations */

#define SFThread_SF_CMND_SF_FCP_Type_TargetReset      0x01
#define SFThread_SF_CMND_SF_FCP_Type_TargetReset_RESP 0x02
#define SFThread_SF_CMND_SF_FCP_Type_FCP_CMND_IU      0x03
#define SFThread_SF_CMND_SF_FCP_Type_FCP_XFER_RDY_IU  0x04
#define SFThread_SF_CMND_SF_FCP_Type_FCP_DATA_IU      0x05
#define SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU       0x06

/* SF_CMND_State(SF_CMND_Class==SFThread_SF_CMND_Class_SF_FCP,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_SF_FCP_State_Started  0x01
#define SFThread_SF_CMND_SF_FCP_State_Finished 0x02

/* SF_CMND_Status(SF_CMND_Class==SFThread_SF_CMND_Class_SF_FCP,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_SF_FCP_Status_Good 0x01
#define SFThread_SF_CMND_SF_FCP_Status_Bad  0x02

/* Function Prototypes */

osGLOBAL void fiFillInSF_FCP_FrameHeader_OnCard(
                                               SFThread_t *SFThread,
                                               os_bit32       D_ID,
                                               os_bit32       X_ID,
                                               os_bit32       F_CTL_Exchange_Context
                                             );

osGLOBAL void fiFillInSF_FCP_FrameHeader_OffCard(
                                                SFThread_t *SFThread,
                                                os_bit32       D_ID,
                                                os_bit32       X_ID,
                                                os_bit32       F_CTL_Exchange_Context
                                              );

osGLOBAL os_bit32 fiFillInTargetReset(
                                  SFThread_t *SFThread
                                );

osGLOBAL os_bit32 fiFillInTargetReset_OnCard(
                                         SFThread_t *SFThread
                                       );

osGLOBAL os_bit32 fiFillInTargetReset_OffCard(
                                          SFThread_t *SFThread
                                        );

osGLOBAL void fiSF_FCP_Process_TargetReset_Response_OnCard(
                                                          SFThread_t *SFThread,
                                                          os_bit32       Frame_Length,
                                                          os_bit32       Offset_to_FCHS,
                                                          os_bit32       Offset_to_Payload,
                                                          os_bit32       Payload_Wrap_Offset,
                                                          os_bit32       Offset_to_Payload_Wrapped
                                                        );

osGLOBAL void fiSF_FCP_Process_TargetReset_Response_OffCard(
                                                           SFThread_t                 *SFThread,
                                                           os_bit32                       Frame_Length,
                                                           FCHS_t                     *FCHS,
                                                           FC_ELS_ACC_PLOGI_Payload_t *Payload,
                                                           os_bit32                       Payload_Wrap_Offset,
                                                           FC_ELS_ACC_PLOGI_Payload_t *Payload_Wrapped
                                                         );

osGLOBAL os_bit32 fiFillInFCP_RSP_IU(
                                 SFThread_t           *SFThread,
                                 os_bit32                 D_ID,
                                 os_bit32                 OX_ID,
                                 os_bit32                 Payload_LEN,
                                 FC_FCP_RSP_Payload_t *Payload
                               );

osGLOBAL os_bit32 fiFillInFCP_RSP_IU_OnCard(
                                        SFThread_t           *SFThread,
                                        os_bit32                 D_ID,
                                        os_bit32                 OX_ID,
                                        os_bit32                 Payload_LEN,
                                        FC_FCP_RSP_Payload_t *Payload
                                      );

osGLOBAL os_bit32 fiFillInFCP_RSP_IU_OffCard(
                                         SFThread_t           *SFThread,
                                         os_bit32                 D_ID,
                                         os_bit32                 OX_ID,
                                         os_bit32                 Payload_LEN,
                                         FC_FCP_RSP_Payload_t *Payload
                                       );

osGLOBAL void fiSF_FCP_Process_TargetRequest_OnCard(
                                                   agRoot_t *hpRoot,
                                                   os_bit32     Frame_Length,
                                                   os_bit32     Offset_to_FCHS,
                                                   os_bit32     Offset_to_Payload,
                                                   os_bit32     Payload_Wrap_Offset,
                                                   os_bit32     Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiSF_FCP_Process_TargetRequest_OffCard(
                                                    agRoot_t *hpRoot,
                                                    os_bit32     Frame_Length,
                                                    FCHS_t   *FCHS,
                                                    void     *Payload,
                                                    os_bit32     Payload_Wrap_Offset,
                                                    void     *Payload_Wrapped
                                                  );

#define fiSF_FCP_Cmd_Status_Success       0x00000000
#define fiSF_FCP_Cmd_Status_TargetRequest 0x00000001
#define fiSF_FCP_Cmd_Status_Bad_CDB_Frame 0x00000002
#define fiSF_FCP_Cmd_Status_Confused      0xFFFFFFFF 

osGLOBAL os_bit32 fiSF_FCP_ProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                );

osGLOBAL os_bit32 fiSF_FCP_ProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t   SFQConsIndex,
                                         os_bit32            Frame_Length,
                                         fi_thread__t       **Thread_to_return
                                       );

osGLOBAL os_bit32 fiSF_FCP_ProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t   SFQConsIndex,
                                          os_bit32            Frame_Length,
                                          fi_thread__t       **Thread_to_return
                                        );

#endif /* __SF_FCP_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\sf_fcp.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/SF_FCP.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:32a  $ (Last Modified)

Purpose:

  This file implements Single Frame FCP services for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tgtstate.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/sf_fcp.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tgtstate.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "sf_fcp.h"
#endif  /* _New_Header_file_Layout_ */

void fiFillInSF_FCP_FrameHeader_OnCard(
                                        SFThread_t *SFThread,
                                        os_bit32       D_ID,
                                        os_bit32       X_ID,
                                        os_bit32       F_CTL_Exchange_Context
                                      )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t  *hpRoot            = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread           = CThread_ptr(hpRoot);
    os_bit32      FCP_Header_Offset = SFThread->SF_CMND_Offset;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID=0;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Command
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_SCSI_FCP
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Command_Status
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_SCSI_FCP
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            MBZ1
                                                          ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                          ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            R_CTL__D_ID
                                                          ),
                         R_CTL__D_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            CS_CTL__S_ID
                                                          ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            TYPE__F_CTL
                                                          ),
                         TYPE__F_CTL
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SEQ_ID__DF_CTL__SEQ_CNT
                                                          ),
                         FC_Frame_Header_DF_CTL_No_Device_Header
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            OX_ID__RX_ID
                                                          ),
                         OX_ID__RX_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            RO
                                                          ),
                         0
                       );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiFillInSF_FCP_FrameHeader_OffCard(
                                         SFThread_t *SFThread,
                                         os_bit32       D_ID,
                                         os_bit32       X_ID,
                                         os_bit32       F_CTL_Exchange_Context
                                       )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t  *hpRoot       = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread      = CThread_ptr(hpRoot);
    FCHS_t    *FCP_Header   = SFThread->SF_CMND_Ptr;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID=0;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    if (D_ID > 0xff)
        S_ID = fiComputeCThread_S_ID(CThread );
    else
        S_ID =     CThread->ChanInfo.CurrentAddress.AL_PA;

    

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Command
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_SCSI_FCP
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Command_Status
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_SCSI_FCP
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    FCP_Header->MBZ1                                        = 0;
    FCP_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                               | FCHS_EOF_EOFn
                                                               | FCHS_CLS;
    FCP_Header->R_CTL__D_ID                                 = R_CTL__D_ID;
    FCP_Header->CS_CTL__S_ID                                = S_ID;
    FCP_Header->TYPE__F_CTL                                 = TYPE__F_CTL;
    FCP_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    FCP_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    FCP_Header->RO                                          = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInTargetReset(
                           SFThread_t *SFThread
                         )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInTargetReset_OnCard(
                                           SFThread
                                         );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInTargetReset_OffCard(
                                            SFThread
                                          );
    }
}

os_bit32 fiFillInTargetReset_OnCard(
                                  SFThread_t *SFThread
                                )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot             = SFThread->thread_hdr.hpRoot;
    DevThread_t *DevThread          = SFThread->parent.Device;
    os_bit32        FCP_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32        FCP_Payload_Offset = FCP_Header_Offset + sizeof(FCHS_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_SF_FCP;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_SF_FCP_Type_TargetReset;
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Started;

/*+
Fill in TargetReset Frame Header
-*/

    fiFillInSF_FCP_FrameHeader_OnCard(
                                       SFThread,
                                       fiComputeDevThread_D_ID(
                                                                DevThread
                                                              ),
                                       0xFFFF,
                                       FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                     );

/*+
Fill in TargetReset Frame Payload
-*/

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_1].Byte_0
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_1].Byte_1
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_2].Byte_0
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_2].Byte_1
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_3].Byte_0
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_3].Byte_1
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_4].Byte_0
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpLun[FC_FCP_CMND_FcpLun_LEVEL_4].Byte_1
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCntl.Reserved_Bit8
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCntl.TaskCodes
                                                          ),
                        FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCntl.TaskManagementFlags
                                                          ),
                        FC_FCP_CMND_FcpCntl_TaskManagementFlags_TARGET_RESET
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCntl.ExecutionManagementCodes
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 0]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 1]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 2]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 3]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 4]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 5]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 6]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 7]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 8]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[ 9]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[10]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[11]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[12]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[13]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[14]
                                                          ),
                        0
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        FCP_Payload_Offset + hpFieldOffset(
                                                            FC_FCP_CMND_Payload_t,
                                                            FcpCdb[15]
                                                          ),
                        0
                      );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_Payload_Offset + hpFieldOffset(
                                                             FC_FCP_CMND_Payload_t,
                                                             FcpDL
                                                           ),
                         hpSwapBit32( 0 )
                       );

/*+
Return length of TargetReset Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_FCP_CMND_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInTargetReset_OffCard(
                                   SFThread_t *SFThread
                                 )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    DevThread_t           *DevThread   = SFThread->parent.Device;
    FCHS_t                *FCP_Header  = SFThread->SF_CMND_Ptr;
    FC_FCP_CMND_Payload_t *FCP_Payload = (FC_FCP_CMND_Payload_t *)((os_bit8 *)FCP_Header + sizeof(FCHS_t));

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_SF_FCP;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_SF_FCP_Type_TargetReset;
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Started;

/*+
Fill in TargetReset Frame Header
-*/

    fiFillInSF_FCP_FrameHeader_OffCard(
                                        SFThread,
                                        fiComputeDevThread_D_ID(
                                                                 DevThread
                                                               ),
                                        0xFFFF,
                                        FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                      );

/*+
Fill in TargetReset Frame Payload
-*/

    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_1].Byte_0 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_1].Byte_1 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_2].Byte_0 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_2].Byte_1 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_3].Byte_0 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_3].Byte_1 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_4].Byte_0 = 0;
    FCP_Payload->FcpLun[FC_FCP_CMND_FcpLun_LEVEL_4].Byte_1 = 0;

    FCP_Payload->FcpCntl.Reserved_Bit8                     = 0;
    FCP_Payload->FcpCntl.TaskCodes                         = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q;
    FCP_Payload->FcpCntl.TaskManagementFlags               = FC_FCP_CMND_FcpCntl_TaskManagementFlags_TARGET_RESET;
    FCP_Payload->FcpCntl.ExecutionManagementCodes          = 0;

    FCP_Payload->FcpCdb[ 0]                                = 0;
    FCP_Payload->FcpCdb[ 1]                                = 0;
    FCP_Payload->FcpCdb[ 2]                                = 0;
    FCP_Payload->FcpCdb[ 3]                                = 0;
    FCP_Payload->FcpCdb[ 4]                                = 0;
    FCP_Payload->FcpCdb[ 5]                                = 0;
    FCP_Payload->FcpCdb[ 6]                                = 0;
    FCP_Payload->FcpCdb[ 7]                                = 0;
    FCP_Payload->FcpCdb[ 8]                                = 0;
    FCP_Payload->FcpCdb[ 9]                                = 0;
    FCP_Payload->FcpCdb[10]                                = 0;
    FCP_Payload->FcpCdb[11]                                = 0;
    FCP_Payload->FcpCdb[12]                                = 0;
    FCP_Payload->FcpCdb[13]                                = 0;
    FCP_Payload->FcpCdb[14]                                = 0;
    FCP_Payload->FcpCdb[15]                                = 0;

    FCP_Payload->FcpDL                                     = hpSwapBit32( 0 );

/*+
Return length of TargetReset Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_FCP_CMND_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiSF_FCP_Process_TargetReset_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 )
{
#ifndef __MemMap_Force_Off_Card__
#if 0
    agRoot_t *hpRoot = SFThread->thread_hdr.hpRoot;

    agFCDevInfo_t *DevInfo = &(SFThread->parent.Device->DevInfo);
    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }
    else
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(osCardRamReadBit32(
                                              hpRoot,
                                              ( Offset_to_Payload_Wrapped
                                                + hpFieldOffset(
                                                                 FC_ELS_ACC_PLOGI_Payload_t,
                                                                 Common_Service_Parameters.FC_PH_Version__BB_Credit
                                                               ) )
                                            ));
    }
#endif /* if 0 */
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiSF_FCP_Process_TargetReset_Response_OffCard(
                                                    SFThread_t                 *SFThread,
                                                    os_bit32                       Frame_Length,
                                                    FCHS_t                     *FCHS,
                                                    FC_ELS_ACC_PLOGI_Payload_t *Payload,
                                                    os_bit32                       Payload_Wrap_Offset,
                                                    FC_ELS_ACC_PLOGI_Payload_t *Payload_Wrapped
                                                  )
{
#ifndef __MemMap_Force_On_Card__
#if 0
    agFCDevInfo_t *DevInfo = &(SFThread->parent.Device->DevInfo);
    if ((hpFieldOffset(FC_ELS_ACC_PLOGI_Payload_t,Common_Service_Parameters.FC_PH_Version__BB_Credit)
        + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }
    else
    {
        DevInfo->N_Port_Common_Parms.FC_PH_Version__BB_Credit
            = hpSwapBit32(Payload_Wrapped->Common_Service_Parameters.FC_PH_Version__BB_Credit);
    }
#endif /* if 0 */
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInFCP_RSP_IU(
                          SFThread_t           *SFThread,
                          os_bit32                 D_ID,
                          os_bit32                 OX_ID,
                          os_bit32                 Payload_LEN,
                          FC_FCP_RSP_Payload_t *Payload
                        )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInFCP_RSP_IU_OnCard(
                                          SFThread,
                                          D_ID,
                                          OX_ID,
                                          Payload_LEN,
                                          Payload
                                        );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInFCP_RSP_IU_OffCard(
                                           SFThread,
                                           D_ID,
                                           OX_ID,
                                           Payload_LEN,
                                           Payload
                                         );
    }
}

os_bit32 fiFillInFCP_RSP_IU_OnCard(
                                 SFThread_t           *SFThread,
                                 os_bit32                 D_ID,
                                 os_bit32                 OX_ID,
                                 os_bit32                 Payload_LEN,
                                 FC_FCP_RSP_Payload_t *Payload
                               )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t  *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread             = CThread_ptr(hpRoot);
    os_bit32      FCP_Header_Offset   = SFThread->SF_CMND_Offset;
    os_bit32      FCP_Payload_Offset  = FCP_Header_Offset + sizeof(FCHS_t);
    os_bit32      FCP_Payload_MAX_LEN = CThread->Calculation.MemoryLayout.SF_CMND.elementSize - sizeof(FCHS_t);
    os_bit32      FCP_Payload_to_copy;
    os_bit32      Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_SF_FCP;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU;
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Finished;

/*+
Fill in FCP_RSP_IU Frame Header
-*/

    fiFillInSF_FCP_FrameHeader_OnCard(
                                       SFThread,
                                       D_ID,
                                       OX_ID,
                                       FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                     );

/*+
Fill in FCP_RSP_IU Frame Payload
-*/

    FCP_Payload_to_copy = ((Payload_LEN < FCP_Payload_MAX_LEN) ? Payload_LEN : FCP_Payload_MAX_LEN);

    for (Bit8_Index = 0;
         Bit8_Index < FCP_Payload_to_copy;
         Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            FCP_Payload_Offset + Bit8_Index,
                            *((os_bit8 *)Payload + Bit8_Index)
                          );
    }

/*+
Return length of FCP_RSP_IU Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + FCP_Payload_to_copy;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInFCP_RSP_IU_OffCard(
                                  SFThread_t           *SFThread,
                                  os_bit32                 D_ID,
                                  os_bit32                 OX_ID,
                                  os_bit32                 Payload_LEN,
                                  FC_FCP_RSP_Payload_t *Payload
                                )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    agRoot_t  *hpRoot              = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread             = CThread_ptr(hpRoot);
    FCHS_t    *FCP_Header          = SFThread->SF_CMND_Ptr;
    os_bit8      *FCP_Payload         = (os_bit8 *)FCP_Header + sizeof(FCHS_t);
    os_bit32      FCP_Payload_MAX_LEN = CThread->Calculation.MemoryLayout.SF_CMND.elementSize - sizeof(FCHS_t);
    os_bit32      FCP_Payload_to_copy;
    os_bit32      Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_SF_FCP;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU;
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Finished;

/*+
Fill in FCP_RSP_IU Frame Header
-*/

    fiFillInSF_FCP_FrameHeader_OffCard(
                                        SFThread,
                                        D_ID,
                                        OX_ID,
                                        FC_Frame_Header_F_CTL_Exchange_Context_Responder
                                      );

/*+
Fill in FCP_RSP_IU Frame Payload
-*/

    FCP_Payload_to_copy = ((Payload_LEN < FCP_Payload_MAX_LEN) ? Payload_LEN : FCP_Payload_MAX_LEN);

    for (Bit8_Index = 0;
         Bit8_Index < FCP_Payload_to_copy;
         Bit8_Index++)
    {
        *FCP_Payload++ = *((os_bit8 *)Payload + Bit8_Index);
    }

/*+
Return length of FCP_RSP_IU Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + FCP_Payload_to_copy;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

void fiSF_FCP_Process_TargetRequest_OnCard(
                                            agRoot_t *hpRoot,
                                            os_bit32     Frame_Length,
                                            os_bit32     Offset_to_FCHS,
                                            os_bit32     Offset_to_Payload,
                                            os_bit32     Payload_Wrap_Offset,
                                            os_bit32     Offset_to_Payload_Wrapped
                                          )
{
    TgtThread_t *TgtThread;
    FCHS_t      *TgtCmnd_FCHS;
    void        *TgtCmnd_Payload;
    os_bit32        TgtCmnd_Payload_Max     = CThread_ptr(hpRoot)->Calculation.MemoryLayout.TgtThread.elementSize - sizeof(TgtThread_t);
    os_bit32        TgtCmnd_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32        TgtCmnd_Payload_To_Copy;
    os_bit32        Bit8_Index;

    if ((TgtThread = TgtThreadAlloc(
                                     hpRoot
                                   )       ) != (TgtThread_t *)agNULL)
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_Process_TargetRequest_OnCard(): Allocated TgtThread @ 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          TgtThread,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
        TgtCmnd_Payload = (void *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));

        TgtThread->TgtCmnd_Length = Frame_Length;

        osCardRamReadBlock(
                            hpRoot,
                            Offset_to_FCHS,
                            (void *)TgtCmnd_FCHS,
                            sizeof(FCHS_t)
                          );

        if (TgtCmnd_Payload_Size < TgtCmnd_Payload_Max)
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Size;
        }
        else /* TgtCmnd_Payload_Size >= TgtCmnd_Payload_Max */
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Max;
        }

        for (Bit8_Index = 0;
             Bit8_Index < TgtCmnd_Payload_To_Copy;
             Bit8_Index++)
        {
            if (Bit8_Index <= Payload_Wrap_Offset)
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index)
                    = osCardRamReadBit8(
                                         hpRoot,
                                         Offset_to_Payload + Bit8_Index
                                       );
            }
            else /* Bit8_Index > Payload_Wrap_Offset */
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index)
                    = osCardRamReadBit8(
                                         hpRoot,
                                         Offset_to_Payload_Wrapped + Bit8_Index
                                       );
            }
        }

        fiSendEvent(
                     &(TgtThread->thread_hdr),
                     TgtEventIncoming
                   );
    }
    else /* (TgtThread = TgtThreadAlloc(
                                         hpRoot
                                       )       ) == (TgtThread_t *)agNULL */
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_Process_TargetRequest_OnCard(): Could not allocate TgtThread !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
}

void fiSF_FCP_Process_TargetRequest_OffCard(
                                             agRoot_t *hpRoot,
                                             os_bit32     Frame_Length,
                                             FCHS_t   *FCHS,
                                             void     *Payload,
                                             os_bit32     Payload_Wrap_Offset,
                                             void     *Payload_Wrapped
                                           )
{
    TgtThread_t *TgtThread;
    FCHS_t      *TgtCmnd_FCHS;
    void        *TgtCmnd_Payload;
    os_bit32     TgtCmnd_Payload_Max     = CThread_ptr(hpRoot)->Calculation.MemoryLayout.TgtThread.elementSize - sizeof(TgtThread_t);
    os_bit32     TgtCmnd_Payload_Size    = Frame_Length - sizeof(FCHS_t);
    os_bit32     TgtCmnd_Payload_To_Copy;
    os_bit32     Bit8_Index;

    if ((TgtThread = TgtThreadAlloc(
                                     hpRoot
                                   )       ) != (TgtThread_t *)agNULL)
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_Process_TargetRequest_OffCard(): Allocated TgtThread @ 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          TgtThread,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        TgtCmnd_FCHS    = &(TgtThread->TgtCmnd_FCHS);
        TgtCmnd_Payload = (void *)((os_bit8 *)TgtCmnd_FCHS + sizeof(FCHS_t));

        TgtThread->TgtCmnd_Length = Frame_Length;

        *TgtCmnd_FCHS = *FCHS;

        if (TgtCmnd_Payload_Size < TgtCmnd_Payload_Max)
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Size;
        }
        else /* TgtCmnd_Payload_Size >= TgtCmnd_Payload_Max */
        {
            TgtCmnd_Payload_To_Copy = TgtCmnd_Payload_Max;
        }

        for (Bit8_Index = 0;
             Bit8_Index < TgtCmnd_Payload_To_Copy;
             Bit8_Index++)
        {
            if (Bit8_Index <= Payload_Wrap_Offset)
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index) = *((os_bit8 *)Payload + Bit8_Index);
            }
            else /* Bit8_Index > Payload_Wrap_Offset */
            {
                *((os_bit8 *)TgtCmnd_Payload + Bit8_Index) = *((os_bit8 *)Payload_Wrapped + Bit8_Index);
            }
        }

        fiSendEvent(
                     &(TgtThread->thread_hdr),
                     TgtEventIncoming
                   );
    }
    else /* (TgtThread = TgtThreadAlloc(
                                         hpRoot
                                       )       ) == (TgtThread_t *)agNULL */
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_Process_TargetRequest_OffCard(): Could not allocate TgtThread !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
    }
}

os_bit32 fiSF_FCP_ProcessSFQ(
                           agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           fi_thread__t       **Thread_to_return
                         )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inCardRam)
    {
        return fiSF_FCP_ProcessSFQ_OnCard(
                                           hpRoot,
                                           SFQConsIndex,
                                           Frame_Length,
                                           Thread_to_return
                                         );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inDmaMemory */
    {
        return fiSF_FCP_ProcessSFQ_OffCard(
                                            hpRoot,
                                            SFQConsIndex,
                                            Frame_Length,
                                            Thread_to_return
                                          );
    }
}

os_bit32 fiSF_FCP_ProcessSFQ_OnCard(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    os_bit32                       Offset_to_FCHS             = SFQ_MemoryDescriptor->addr.CardRam.cardRamOffset
                                                             + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize);
    os_bit32                       Offset_to_Payload          = Offset_to_FCHS + sizeof(FCHS_t);
    os_bit32                       Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    os_bit32                       Offset_to_Payload_Wrapped  = Offset_to_Payload
                                                             - SFQ_MemoryDescriptor->objectSize;
    os_bit32                       TYPE__F_CTL;
    X_ID_t                      X_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                       CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    CDBThread_t                *CDBThread;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                       SFThread_X_ID_Offset       = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                       SFThread_X_ID_Max          = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    SFThread_t                 *SFThread;
    fiMemMapMemoryDescriptor_t *SEST_MemoryDescriptor      = &(CThread->Calculation.MemoryLayout.SEST);
    os_bit32                       SEST_Offset;
    SEST_t                     *SEST;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    TYPE__F_CTL = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                    );

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_SCSI_FCP)
    {
        /* This function only understands SCSI FCP Frames */

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_SCSI_FCP",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_Confused;
    }

    if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
    {
        fiSF_FCP_Process_TargetRequest_OnCard(
                                               hpRoot,
                                               Frame_Length,
                                               Offset_to_FCHS,
                                               Offset_to_Payload,
                                               Payload_Wrap_Offset,
                                               Offset_to_Payload_Wrapped
                                             );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_TargetRequest;
    }

    X_ID = (X_ID_t)(((osCardRamReadBit32(
                                          hpRoot,
                                          Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                        ) & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    if (X_ID <= CDBThread_X_ID_Max)
    {
        /* Got an unexpected Inbound CDB Frame on SFQ */

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                    + (X_ID * CDBThread_MemoryDescriptor->elementSize));

        *Thread_to_return = (fi_thread__t *)CDBThread;
        
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID <= CDBThread_X_ID_Max",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID==0x%08X  CThread==0x%p",
                          (char *)agNULL,(char *)agNULL,
                          CThread,(void *)agNULL,
                          X_ID,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,MBZ1)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,R_CTL__D_ID)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,CS_CTL__S_ID)
                                            ),
                          0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,SEQ_ID__DF_CTL__SEQ_CNT)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,RO)
                                            ),
                          0,0,0,0
                        );

        if (SEST_MemoryDescriptor->memLoc == inCardRam)
        {
            SEST_Offset =   SEST_MemoryDescriptor->addr.CardRam.cardRamOffset
                          + (X_ID * SEST_MemoryDescriptor->elementSize);

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 0 %08X 1 %08X 2 %08X 3 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Bits)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_1)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_2)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_3)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 4 %08X 5 %08X 6 %08X 7 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.LOC)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_5)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_6)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_7)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 8 %08X 9 %08X A %08X B %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_8)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_9)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.First_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.First_SG.L32)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST C %08X D %08X E %08X F %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Second_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Second_SG.L32)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Third_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Third_SG.L32)
                                                ),
                              0,0,0,0
                            );
        }
        else /* SEST_MemoryDescriptor->memLoc == inDmaMemory */
        {
            SEST = (SEST_t *)(  (os_bit8 *)SEST_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr
                              + (X_ID * SEST_MemoryDescriptor->elementSize)               );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 0 %08X 1 %08X 2 %08X 3 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Bits,
                              SEST->USE.Unused_DWord_1,
                              SEST->USE.Unused_DWord_2,
                              SEST->USE.Unused_DWord_3,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 4 %08X 5 %08X 6 %08X 7 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.LOC,
                              SEST->USE.Unused_DWord_5,
                              SEST->USE.Unused_DWord_6,
                              SEST->USE.Unused_DWord_7,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 8 %08X 9 %08X A %08X B %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Unused_DWord_8,
                              SEST->USE.Unused_DWord_9,
                              SEST->USE.First_SG.U32_Len,
                              SEST->USE.First_SG.L32,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST C %08X D %08X E %08X F %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Second_SG.U32_Len,
                              SEST->USE.Second_SG.L32,
                              SEST->USE.Third_SG.U32_Len,
                              SEST->USE.Third_SG.L32,
                              0,0,0,0
                            );
        }

        return fiSF_FCP_Cmd_Status_Bad_CDB_Frame;
    }

    if (X_ID > SFThread_X_ID_Max)
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OnCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID > SFThread_X_ID_Max",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          X_ID,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,MBZ1)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,R_CTL__D_ID)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,CS_CTL__S_ID)
                                            ),
                          0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,SEQ_ID__DF_CTL__SEQ_CNT)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                            ),
                          osCardRamReadBit32(
                                              hpRoot,
                                              Offset_to_FCHS + hpFieldOffset(FCHS_t,RO)
                                            ),
                          0,0,0,0
                        );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_Confused;
    }

    SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((X_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    *Thread_to_return = (fi_thread__t *)SFThread;
        
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Finished;

    /* For now, assume TargetReset */

    fiLogDebugString(
                      hpRoot,
                      SF_FCP_LogConsoleLevel,
                      "fiSF_FCP_ProcessSFQ_OnCard(): hard-coded call to fiSF_FCP_Process_TargetReset_Response_OnCard()",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );

    fiSF_FCP_Process_TargetReset_Response_OnCard(
                                                  SFThread,
                                                  Frame_Length,
                                                  Offset_to_FCHS,
                                                  Offset_to_Payload,
                                                  Payload_Wrap_Offset,
                                                  Offset_to_Payload_Wrapped
                                                );

    return fiSF_FCP_Cmd_Status_Success;
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiSF_FCP_ProcessSFQ_OffCard(
                                   agRoot_t        *hpRoot,
                                   SFQConsIndex_t   SFQConsIndex,
                                   os_bit32            Frame_Length,
                                   fi_thread__t       **Thread_to_return
                                 )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    FCHS_t                     *FCHS                       = (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                                                        + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize));
    FC_ELS_Unknown_Payload_t   *Payload                    = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));
    os_bit32                    Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    FC_ELS_Unknown_Payload_t   *Payload_Wrapped            = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)Payload
                                                                                          - SFQ_MemoryDescriptor->objectSize);
    os_bit32                    TYPE__F_CTL                = FCHS->TYPE__F_CTL;
    X_ID_t                      X_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                    CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    CDBThread_t                *CDBThread;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset       = CThread->Calculation.MemoryLayout.CDBThread.elements;
    os_bit32                    SFThread_X_ID_Max          = SFThread_X_ID_Offset + SFThread_MemoryDescriptor->elements - 1;
    SFThread_t                 *SFThread;
    fiMemMapMemoryDescriptor_t *SEST_MemoryDescriptor      = &(CThread->Calculation.MemoryLayout.SEST);
    os_bit32                    SEST_Offset;
    SEST_t                     *SEST;
    os_bit32                  * FCHS_Payload = (os_bit32 *) Payload;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_SCSI_FCP)
    {
        /* This function only understands SCSI FCP Frames */

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    (TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) != FC_Frame_Header_TYPE_SCSI_FCP",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    TYPE__F_CTL==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          TYPE__F_CTL,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );
        fiLogDebugString(
                        hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *(FCHS_Payload+0),
                        *(FCHS_Payload+1),
                        *(FCHS_Payload+2),
                        *(FCHS_Payload+3),
                        *(FCHS_Payload+4),
                        *(FCHS_Payload+5),
                        *(FCHS_Payload+6),
                        *(FCHS_Payload+7));


        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_Confused;
    }

    if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
    {
        fiSF_FCP_Process_TargetRequest_OffCard(
                                                hpRoot,
                                                Frame_Length,
                                                FCHS,
                                                (void *)Payload,
                                                Payload_Wrap_Offset,
                                                (void *)Payload_Wrapped
                                              );

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_TargetRequest;
    }

    X_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    if (X_ID <= CDBThread_X_ID_Max)
    {
        /* Got an unexpected Inbound CDB Frame on SFQ */

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                                    + (X_ID * CDBThread_MemoryDescriptor->elementSize));

        *Thread_to_return = (fi_thread__t *)CDBThread;
        
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID <= CDBThread_X_ID_Max   X_ID==0x%08X ",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          X_ID,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );
        fiLogDebugString(
                        hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *(FCHS_Payload+0),
                        *(FCHS_Payload+1),
                        *(FCHS_Payload+2),
                        *(FCHS_Payload+3),
                        *(FCHS_Payload+4),
                        *(FCHS_Payload+5),
                        *(FCHS_Payload+6),
                        *(FCHS_Payload+7));

        if (SEST_MemoryDescriptor->memLoc == inCardRam)
        {
            SEST_Offset =   SEST_MemoryDescriptor->addr.CardRam.cardRamOffset
                          + (X_ID * SEST_MemoryDescriptor->elementSize);

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 0 %08X 1 %08X 2 %08X 3 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Bits)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_1)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_2)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_3)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 4 %08X 5 %08X 6 %08X 7 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.LOC)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_5)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_6)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_7)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 8 %08X 9 %08X A %08X B %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_8)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Unused_DWord_9)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.First_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.First_SG.L32)
                                                ),
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST C %08X D %08X E %08X F %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Second_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Second_SG.L32)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Third_SG.U32_Len)
                                                ),
                              osCardRamReadBit32(
                                                  hpRoot,
                                                  SEST_Offset + hpFieldOffset(SEST_t,USE.Third_SG.L32)
                                                ),
                              0,0,0,0
                            );
        }
        else /* SEST_MemoryDescriptor->memLoc == inDmaMemory */
        {
            SEST = (SEST_t *)(  (os_bit8 *)SEST_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr
                              + (X_ID * SEST_MemoryDescriptor->elementSize)               );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 0 %08X 1 %08X 2 %08X 3 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Bits,
                              SEST->USE.Unused_DWord_1,
                              SEST->USE.Unused_DWord_2,
                              SEST->USE.Unused_DWord_3,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 4 %08X 5 %08X 6 %08X 7 %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.LOC,
                              SEST->USE.Unused_DWord_5,
                              SEST->USE.Unused_DWord_6,
                              SEST->USE.Unused_DWord_7,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST 8 %08X 9 %08X A %08X B %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Unused_DWord_8,
                              SEST->USE.Unused_DWord_9,
                              SEST->USE.First_SG.U32_Len,
                              SEST->USE.First_SG.L32,
                              0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              SF_FCP_LogConsoleLevel,
                              "    SEST C %08X D %08X E %08X F %08X",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              SEST->USE.Second_SG.U32_Len,
                              SEST->USE.Second_SG.L32,
                              SEST->USE.Third_SG.U32_Len,
                              SEST->USE.Third_SG.L32,
                              0,0,0,0
                            );
        }

        return fiSF_FCP_Cmd_Status_Bad_CDB_Frame;
    }

    if (X_ID > SFThread_X_ID_Max)
    {
        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "fiSF_FCP_ProcessSFQ_OffCard():",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          SF_FCP_LogConsoleLevel,
                          "    X_ID > SFThread_X_ID_Max   X_ID==0x%08X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          X_ID,
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                         (void *)agNULL,(void *)agNULL,
                        FCHS->MBZ1,
                        FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                        FCHS->R_CTL__D_ID,
                        FCHS->CS_CTL__S_ID,
                        FCHS->TYPE__F_CTL,
                        FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                        FCHS->OX_ID__RX_ID,
                        FCHS->RO );

        fiLogDebugString( hpRoot,
                        SF_FCP_LogConsoleLevel,
                        "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *(FCHS_Payload+0),
                        *(FCHS_Payload+1),
                        *(FCHS_Payload+2),
                        *(FCHS_Payload+3),
                        *(FCHS_Payload+4),
                        *(FCHS_Payload+5),
                        *(FCHS_Payload+6),
                        *(FCHS_Payload+7));

        *Thread_to_return = (fi_thread__t *)agNULL;

        return fiSF_FCP_Cmd_Status_Confused;
    }

    SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((X_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

    *Thread_to_return = (fi_thread__t *)SFThread;
        
    SFThread->SF_CMND_State = SFThread_SF_CMND_SF_FCP_State_Finished;

    /* For now, assume TargetReset */

    fiLogDebugString(
                      hpRoot,
                      SF_FCP_LogConsoleLevel,
                      "fiSF_FCP_ProcessSFQ_OffCard(): hard-coded call to fiSF_FCP_Process_TargetReset_Response_OffCard()",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0 );

    fiLogDebugString(hpRoot,
                    SF_FCP_LogConsoleLevel,
                    "FCHS DWORD 0 %08X %08X %08X %08X %08X %08X %08X %08X",
                    (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    FCHS->MBZ1,
                    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                    FCHS->R_CTL__D_ID,
                    FCHS->CS_CTL__S_ID,
                    FCHS->TYPE__F_CTL,
                    FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                    FCHS->OX_ID__RX_ID,
                    FCHS->RO );

    fiLogDebugString(hpRoot,
                    SF_FCP_LogConsoleLevel,
                    "FCHS_Payload %08X %08X %08X %08X %08X %08X %08X %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *(FCHS_Payload+0),
                    *(FCHS_Payload+1),
                    *(FCHS_Payload+2),
                    *(FCHS_Payload+3),
                    *(FCHS_Payload+4),
                    *(FCHS_Payload+5),
                    *(FCHS_Payload+6),
                    *(FCHS_Payload+7));


    fiSF_FCP_Process_TargetReset_Response_OffCard(
                                                   SFThread,
                                                   Frame_Length,
                                                   FCHS,
                                                   (FC_ELS_ACC_PLOGI_Payload_t *)Payload,
                                                   Payload_Wrap_Offset,
                                                   (FC_ELS_ACC_PLOGI_Payload_t *)Payload_Wrapped
                                                 );

    return fiSF_FCP_Cmd_Status_Success;
#endif /* __MemMap_Force_On_Card__ was not defined */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\startio.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    StartIo.c

Abstract:

    This source handles calls to start processing  requests
    
Authors:

    Michael Bessire
    Dennis Lindfors FC Layer support

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/STARTIO.C $

Revision History:

    $Revision: 9 $
    $Date: 3/30/01 11:55a $
    $Modtime:: 3/30/01 11:51a        $


--*/


#include "buildop.h"        //LP021100 build switches

#include "osflags.h"
#include "hhba5100.ver"
#if defined(HP_PCI_HOT_PLUG)
    #include "HotPlug4.h"    // NT 4.0 PCI Hot-Plug header file
#endif

ULONG LOG_TIME=0;
extern ULONG gGlobalIOTimeout;
#ifdef DBGPRINT_IO
ULONG gDbgPrintIo=0;
#endif

ULONG gMultiMode=FALSE;

BOOLEAN
HPFibreStartIo(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver synchronized
    with the kernel to send an ECB or issue an immediate command.

Arguments:

    pCard - HBA miniport driver's adapter data storage
    Srb             - I/O request packet

Return Value:

    TRUE - to acknowledge receipt of srb

--*/

{
    agRoot_t * phpRoot      =   &pCard->hpRoot;
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
    SCSI_NOTIFICATION_TYPE  notify_type = NextRequest;
    ULONG                           response_length; // ignored
    PULONG ptmp32;

    PSCSI_REQUEST_BLOCK         abortedSrb;
    PLU_EXTENSION               plunExtension = NULL;
    agIORequest_t *             pHpio_request;
    agIORequestBody_t *         pHpio_CDBrequest;
    PLUN plun;
    UCHAR    srbPathId = Srb->PathId;
    UCHAR    srbTargetId = Srb->TargetId;
    UCHAR    srbLun = Srb->Lun;


    #ifdef DBGPRINT_IO   
    if (gDbgPrintIo & DBGPRINT_HPFibreStartIo)
    {
        static count;
        osDEBUGPRINT((ALWAYS_PRINT, "HPStr(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x  Dev=%x &Srb=%x &Ext=%x Flags=%x Buf=%x Len=%x Funct=%d\n",
                   count++,
                   Srb->PathId,
                   Srb->TargetId,
                   Srb->Lun,
                   Srb->Cdb[0],Srb->Cdb[1],Srb->Cdb[2],Srb->Cdb[3],Srb->Cdb[4],
                   Srb->Cdb[5],Srb->Cdb[6],Srb->Cdb[7],Srb->Cdb[8],Srb->Cdb[9],
                    pCard, Srb, Srb->SrbExtension, Srb->SrbFlags, Srb->DataBuffer, Srb->DataTransferLength,Srb->Function));            
    }
    #endif

    pCard->inDriver = TRUE;

    while (pCard->inTimer == TRUE)
        // HPFibreTimerTick routine is running. Busy wait until
        // HPFibreTimerTick returns.
        ;

    //----------------------------------------------------------------------------

    #if defined(HP_PCI_HOT_PLUG)     // NT 4.0 PCI Hot Plug support

    //
    // Added for support of NT 4.0 PCI Hot Plug.  If we are in a state of 
    // transitioning, we need to refuse all requests until we have completed 
    // hot plug transitioning.
    //

    if (PCS_HBA_NOT_READY(pCard->stateFlags)) 
    {
        if (pCard->controlFlags & ~LCS_HBA_TIMER_ACTIVE)   // Check if timer active
        {
            osDEBUGPRINT((ALWAYS_PRINT, "\tStartIo PCS_HBA_NOT_READY: Slot: %x  controlFlags: %x - Send BUSY.\n",
                pCard->rcmcData.slot, pCard->controlFlags));
            Srb->SrbStatus = SRB_STATUS_BUSY;
        }
        else 
            if (pCard->stateFlags & PCS_HBA_FAILED) 
            {
                osDEBUGPRINT((ALWAYS_PRINT, "\tStartIo: (Slot: %x) PCS_HBA_FAILED: SRB_STATUS_ERROR returned.\n",
                    pCard->rcmcData.slot));
                pCard->stateFlags |= PCS_HBA_UNFAIL_PENDING;
                Srb->SrbStatus = SRB_STATUS_ERROR;
            }
            else
            {
                if (pCard->stateFlags & PCS_HPP_POWER_DOWN) 
                {
                    if (pCard->IoHeldRetTimer < pCard->IoHeldRetMaxIter ) 
                    {
                        Srb->SrbStatus = SRB_STATUS_BUSY;
                        osDEBUGPRINT((ALWAYS_PRINT, "\tStartIo: (Slot: %x) - POWER DOWN: Status returned: %x\n",
                        pCard->rcmcData.slot, Srb->SrbStatus));
                    }
                    else 
                    {
                    osDEBUGPRINT((ALWAYS_PRINT, "StartIo: (Slot: %x) - POWER DOWN: Timed out\n",
                        pCard->rcmcData.slot));
                    Srb->SrbStatus = SRB_STATUS_ERROR;
                    }
                }
                else 
                {
                    if ( (pCard->stateFlags & PCS_HBA_UNFAIL_PENDING) &&
                        (pCard->stateFlags & PCS_HBA_OFFLINE) ) 
                    {
                        Srb->SrbStatus = SRB_STATUS_ERROR;
                    }
                    else 
                    {
                        pCard->stateFlags &= ~PCS_HBA_UNFAIL_PENDING;
                        Srb->SrbStatus = SRB_STATUS_BUSY;
                    }
                }
            }

        //    Indicate to system that the controller can take another request
        //    for this device.

        ScsiPortNotification(NextLuRequest,
            pCard,
            Srb->PathId,
            Srb->TargetId,
            Srb->Lun);      

        ScsiPortNotification(RequestComplete, pCard, Srb);
           pCard->inDriver = FALSE;
        return TRUE;

    } // end if (PCS_HBA_NOT_READY(pCard->stateFlags))
    else 
    {
        pCard->stateFlags &= ~PCS_HBA_UNFAIL_PENDING; 
        pCard->IoHeldRetTimer = 0;  

    }

    #endif      // NT 4.0 PCI Hot Plug support
    //----------------------------------------------------------------------------

    if (pCard->flags & OS_IGNORE_NEXT_RESET)
        pCard->flags &= ~OS_IGNORE_NEXT_RESET;

    pCard->State |= CS_DURING_STARTIO;

    // Zero out SRB extension here !!!!
    osZero(Srb->SrbExtension, sizeof(SRB_EXTENSION));

    // osDEBUGPRINT((DHIGH,"IN HPFibreStartIo %lx %lx hpRoot %lx Srb->DataBuffer %lx\n", pCard, Srb, phpRoot ,Srb->DataBuffer ));
    #ifdef _DEBUG_PERF_DATA_
    pSrbExt->Perf_ptr = &pCard->perf_data[ LOG_TIME];

    // PERF     pSrbExt->Perf_ptr->inOsStartio  = get_hi_time_stamp();

    if( LOG_TIME )
    {
        if( LOG_TIME == 1) pCard->PerfStartTimed = osTimeStamp(0);

        if( LOG_TIME < LOGGED_IO_MAX-1)
        {
            LOG_TIME++;
        }
        else
        {
            LOG_TIME = 0;
            pSrbExt->Perf_ptr = &pCard->perf_data[0];
            dump_perf_data( pCard);
        }
    }
    #endif

    // Init SRB Extension
    pSrbExt->pCard              =   pCard;
    pSrbExt->phpRoot            =   phpRoot;
    pSrbExt->pSrb               =   Srb;

    // IWN
    // Init the SCSIStatus, bug in Win2000 SCSIPort of not reinit SCSIStatus.

    Srb->ScsiStatus = SCSISTAT_GOOD;


    if (Srb->Function == SRB_FUNCTION_ABORT_COMMAND) 
    {
        // get ECB to abort.
        abortedSrb = Srb->NextSrb;
        pSrbExt =abortedSrb->SrbExtension;
        pSrbExt->SRB_State =  RS_TO_BE_ABORTED;        

        osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_ABORT_COMMAND Srb %lx abortedSrb %lx\n", Srb, abortedSrb ));
        #ifdef _DEBUG_EVENTLOG_
        LogEvent(   pCard, 
                 (PVOID)pSrbExt, 
                 HPFC_MSG_IO_ABORTINITIATED , 
                 NULL, 
                 0, 
                 NULL);
        #endif
        
        plunExtension = ScsiPortGetLogicalUnit(pCard,
                                            abortedSrb->PathId,
                                            abortedSrb->TargetId,
                                            abortedSrb->Lun
                                            );

        fcAbortIO( phpRoot,
                   &pSrbExt->hpIORequest );

        ScsiPortNotification(NextRequest,
                                pCard,
                                Srb->PathId,
                                Srb->TargetId,
                                Srb->Lun);

        // indicate request complete
        pSrbExt->SRB_State = RS_COMPLETE;

        ScsiPortNotification(RequestComplete,
                               pCard,
                               Srb);

        pCard->State &= ~CS_DURING_STARTIO;

        pCard->inDriver = FALSE;

        return TRUE;
    }

    switch (Srb->Function) 
    {
        case SRB_FUNCTION_EXECUTE_SCSI:
            #ifdef _DEBUG_EVENTLOG_
            pSrbExt->pLunExt = NULL;               /* initialize the lun extension */
            #endif
       
            #ifdef _ENABLE_PSEUDO_DEVICE_
            if (gEnablePseudoDevice)
            {
                if (PseudoDeviceIO(pCard, Srb) == TRUE)
                {
                    return TRUE;
                }
            }
            #endif
         
            /* Check if the link is down
            * So that we can block any inquiry IO
            */
            if((pCard->LinkState == LS_LINK_DOWN) && (Srb->Cdb[0] == SCSIOP_INQUIRY))
            {
                if(!pCard->SrbStatusFlag) 
                    pCard->SrbStatusFlag = TRUE;
                /* Check if the link has been down for atleast
                * Global_IO_Timeout value
                * If it has then set the status to selection timeout
                * else set the status to busy
                */
                if(pCard->TicksSinceLinkDown > gGlobalIOTimeout)
                    Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                else 
                    Srb->SrbStatus = SRB_STATUS_BUSY;
                break;
            }  /* end if LinkState==LS_LINK_DOWN */
            
            plunExtension = ScsiPortGetLogicalUnit(pCard,
                                                  Srb->PathId,
                                                  Srb->TargetId,
                                                  Srb->Lun );

            pHpio_request    = &pSrbExt->hpIORequest;
            pHpio_CDBrequest = &pSrbExt->hpRequestBody;

            #ifdef DBGPRINT_IO   
            if (gDbgPrintIo & DBGPRINT_START )
            {
                static count;
                osDEBUGPRINT((ALWAYS_PRINT, "Start(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Buf=%x Len=%x\n",
                        count++,
                        Srb->PathId,
                        Srb->TargetId,
                        Srb->Lun,
                        Srb->Cdb[0],Srb->Cdb[1],Srb->Cdb[2],Srb->Cdb[3],Srb->Cdb[4],
                        Srb->Cdb[5],Srb->Cdb[6],Srb->Cdb[7],Srb->Cdb[8],Srb->Cdb[9],
                        Srb->DataBuffer, Srb->DataTransferLength));
              
            }


            #endif

            if(plunExtension == NULL)
            {
                Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                osDEBUGPRINT((ALWAYS_PRINT,"..........EXECUTE_SCSI NO LU EXT srb %lx luext %lx\n", Srb,plunExtension ));
                osDEBUGPRINT((ALWAYS_PRINT,"..........Bus %x TargetId %x Lun %x\n", Srb->PathId,Srb->TargetId,Srb->Lun));
                
                break;
            } 
            else 
            {
                 // osDEBUGPRINT((DHIGH,"Lu Extension srb %lx luext %lx\n", Srb,plunExtension ));

                if (!(plunExtension->flags & LU_EXT_INITIALIZED))
                    InitLunExtension (plunExtension);

                if (pCard->LinkState != LS_LINK_DOWN) 
                {
                    if(plunExtension->phandle == NULL) 
                    {
                        plunExtension->phandle = MapToHandle(pCard, Srb->PathId, Srb->TargetId, Srb->Lun, plunExtension);
                        if (plunExtension->phandle == NULL) 
                        {
                            Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                            
                            break;
                        }
                    }
                } 
                else 
                {
                    // For now set phandle to NULL.
                    // The phandle will be updated after the link comes up.
                    plunExtension->phandle = NULL;
                }
                
                plunExtension->OutstandingIOs++;
                plunExtension->MaxOutstandingIOs = MAX(plunExtension->MaxOutstandingIOs, plunExtension->OutstandingIOs);

                plun = (PLUN)&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0];
                *plun = plunExtension->Lun;

                if(plunExtension->OutstandingIOs > plunExtension->MaxOutstandingIOs )
                {
                    osDEBUGPRINT((ALWAYS_PRINT,"plunExtension->OutstandingIOs:%d > plunExtension->MaxOutstandingIOs:%d\n",plunExtension->OutstandingIOs ,plunExtension->MaxOutstandingIOs ));
                }
                osDEBUGPRINT((DHIGH,"IN HPFibreStartIo %lx %lx hpRoot %lx Srb->DataBuffer %lx OUT %x \n", pCard, Srb, phpRoot ,Srb->DataBuffer, plunExtension->OutstandingIOs ));
            }

            if (Srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE) 
            {
                if (Srb->QueueAction == SRB_SIMPLE_TAG_REQUEST)
                    pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q;
                else 
                    if (Srb->QueueAction == SRB_HEAD_OF_QUEUE_TAG_REQUEST)
                        pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_HEAD_OF_Q;
                    else 
                        if (Srb->QueueAction == SRB_ORDERED_QUEUE_TAG_REQUEST)
                            pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_ORDERED_Q;

                if (plunExtension->OutstandingIOs < plunExtension->MaxAllowedIOs) 
                {
                    osDEBUGPRINT((DMOD,"Next Lu Req srb %lx luext %lx\n", Srb,plunExtension));
                    notify_type = NextLuRequest;
                }
            } 
            else 
                if (pCard->ForceTag) 
                {
                    pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q;
                    if (plunExtension->OutstandingIOs < plunExtension->MaxAllowedIOs) 
                    {
                        osDEBUGPRINT((DMOD,"Next Lu Req srb %lx luext %lx\n", Srb,plunExtension));
                        notify_type = NextLuRequest;
                    }

                } 
                else
                    pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[1] = FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_UNTAGGED;

            osDEBUGPRINT((DMOD,"HPFibreStartIo: CDB %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x pCDB %lx\n",
                Srb->Cdb[0],Srb->Cdb[1],Srb->Cdb[2],Srb->Cdb[3],Srb->Cdb[4],
                Srb->Cdb[5],Srb->Cdb[6],Srb->Cdb[7],Srb->Cdb[8],Srb->Cdb[9], &Srb->Cdb[0] ));
            osDEBUGPRINT((DMOD, "HPFibreStartIo: PathId = %d, TargetId = %d, lun = %d DateBuffer = 0x%x XferLen = 0x%x\n",
                Srb->PathId, Srb->TargetId, Srb->Lun, Srb->DataBuffer, Srb->DataTransferLength));


            osDEBUGPRINT((DMOD,"Setup Pointers SrbExtension %lx\n", Srb->SrbExtension));

            pSrbExt->pLunExt = plunExtension;
            // Point request to extension

            // Save extension for later
            pHpio_request->osData = pSrbExt;
            // Build response
            // Move (destin, source, size)
            // osCopyAndSwap(&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCdb[0],Srb->Cdb,16);
            osCopy(&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCdb[0],Srb->Cdb,16);

            osDEBUGPRINT((DHIGH,"ScsiPortMoveMemory pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun %lx\n",
                  pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCdb));

            // LunExt does not exist !!! ScsiPortMoveMemory(pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun,plunExtension->FcpLun,8);

#ifdef FCLayer_Stub // Stub only !!!!

            if(Srb->Lun)
            {
                Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                //ScsiPortLogError( pCard,
                //                Srb,
                //              Srb->PathId,
                //            Srb->TargetId,
                //          Srb->Lun,
                //        SP_BUS_TIME_OUT,
                //      0xABAD );
                pSrbExt->SRB_State = RS_COMPLETE;
                ScsiPortNotification(RequestComplete, pCard, Srb);
                pCard->inDriver = FALSE;
                return;
            }

            pHpio_CDBrequest->CDBRequest.FcpDataVirtAddr= Srb->DataBuffer;
            pHpio_CDBrequest->CDBRequest.FcpRespVirtAddr= &pSrbExt->ResponseHeader;

#endif /*  FCLayer_Stub */

            // plun = (pLUN)&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[1];
            // plun->Address_mode  = 0;
            // plun->Bus_number    = 0;
            // plun->Lun           = Srb->Lun;
            // ptmp32 = (PULONG)&pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0];
            // * ptmp32 = SWAPDWORD(*ptmp32);

            #ifdef TESTING_CRASH_DUMP
            if(gCrashDumping)
            {
                SCSI_PHYSICAL_ADDRESS phys_addr;
                ULONG length = 0;
                ULONG addr;

                
                // we have a write, then just check if we 
                // pass ScsiPortGetPhysical Address
                if(Srb->Cdb[0] == 0x2a)
                {
                    phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                        Srb,
                                        Srb->DataBuffer,
                                        &length);

                    addr=ScsiPortConvertPhysicalAddressToUlong(phys_addr);
                    {
                    osDEBUGPRINT((ALWAYS_PRINT,"ScsiPortGetPhysicalAddress: return %x:%x addr = %x for vBuffer=%x\n Length=%x", 
                        phys_addr.HighPart, phys_addr.LowPart, addr, Srb->DataBuffer,length));
                    }
                }
            }
            #endif

            // if we are in dump path, we find that some of the DataBuffers
            // dont give any physical addresses. to bypass that, we have our 
            // own dma area, which we use to succeed the ScsiPortGetPhysical
            // call
            if(gCrashDumping)
            {
                if (Srb->DataBuffer && Srb->DataTransferLength)
                {
                    osDEBUGPRINT((ALWAYS_PRINT, "CrashDump: Buffer = %x data = %02x%02x%02x%02x\n",
                        Srb->DataBuffer, 
                        *(char *)((char*)Srb->DataBuffer+0), 
                        *(char *)((char*)Srb->DataBuffer+1), 
                        *(char *)((char*)Srb->DataBuffer+2), 
                        *(char *)((char*)Srb->DataBuffer+3) )); 
                } 
                   
                if(Srb->Cdb[0] == 0x2a)
                {
                    SCSI_PHYSICAL_ADDRESS phys_addr;
                    ULONG length = 0;
                    // we have a write, then just check if we 
                    // pass ScsiPortGetPhysical Address
                    phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                        Srb,
                                        Srb->DataBuffer,
                                        &length);

                    if(phys_addr.LowPart == 0 &&  phys_addr.HighPart == 0 )
                    {
                        // we failed to get physical address, lets use our own,
                        // if the buffer is small enuff.. 8K is the limit
                        if(Srb->DataTransferLength <= (8 * 1024))
                        {
                            // save away the Original DataBuffer
                            pSrbExt->orgDataBuffer = Srb->DataBuffer;
                            // make the copy into our local DMA buffer
                            osCopy(pCard->localDataBuffer, Srb->DataBuffer, Srb->DataTransferLength);
                            // patch the pointer..
                            Srb->DataBuffer = pCard->localDataBuffer;
                            osDEBUGPRINT((ALWAYS_PRINT,"patching SRB->DataBuffer - VA %x Len %x\n",Srb->DataBuffer,Srb->DataTransferLength));
                        }
                        else
                        {
                            // transfer length is greater than 8K
                            // we are screwed.. let the fc layer handle this.. 
                            osDEBUGPRINT((ALWAYS_PRINT,"!!Cant get physical address - VA %x Len %x ( %ld )\n",Srb->DataBuffer,Srb->DataTransferLength));
                        }
                    }// if physical ZERO
                }// if its a Write
            }// if in Dump path

            osDEBUGPRINT((DHIGH,"** Srb->Lun %02x  FcpLun %02x %02x %02x %02x %02x %02x %02x %02x\n",
               Srb->Lun,
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[0],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[1],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[2],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[3],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[4],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[5],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[6],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpLun[7]));


            ptmp32 = (PULONG) &pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[0];
            response_length = Srb->DataTransferLength;
            * ptmp32 = SWAPDWORD(response_length);

            osDEBUGPRINT((DHIGH,"Srb->Datalength %08x response_length %08x  FcpDL %02x %02x %02x %02x\n",
               Srb->DataTransferLength,response_length,
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[0],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[1],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[2],
               pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL[3]));


            // pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpDL = Srb->DataTransferLength;

            pSrbExt->SglDataLen  = Srb->DataTransferLength;
            pSrbExt->SglVirtAddr = Srb->DataBuffer;

            // if(Srb->DataBuffer){
            pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[3] = (  ((Srb->SrbFlags & SRB_FLAGS_DATA_IN ) ? agFcpCntlReadData  : 0)
                                                            | ((Srb->SrbFlags & SRB_FLAGS_DATA_OUT) ? agFcpCntlWriteData : 0) );
            //  }
            //else pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[3] = 0;

            osDEBUGPRINT((DMOD,"Set direction flag %x @ %x OutstandingIOs %x\n",pHpio_CDBrequest->CDBRequest.FcpCmnd.FcpCntl[3], osTimeStamp(0),plunExtension->OutstandingIOs));

            SrbEnqueueTail (&pCard->AdapterQ, Srb);

            if (pCard->LinkState == LS_LINK_UP)
                Startio (pCard);

            if (pCard->LinkState != LS_LINK_UP)
                osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartio called while not LS_LINK_UP.\n" ));

            pCard->inDriver = FALSE;

            return(TRUE);
// The following should be added to the SCSI miniport driver's source
// code :
//
// and the following should be added to the SCSI miniport driver's
// StartIo routine :

// the following ioctl case is added in function HPFibreStartIo()

        case SRB_FUNCTION_IO_CONTROL: 
        {
            DoIoctl(pCard, Srb);
            pCard->inDriver = FALSE;
            return(TRUE);
        } //end case SRB_FUNCTION_IO_CONTROL

    

        // the scsiport routine calls the HwResetBus routine directly.
        // these and others are defined in srb.h for future use.
        // just drop through for now. We may want to implement these later.


        case SRB_FUNCTION_RESET_BUS:
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_RESET_BUS\n"));

            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;


        case SRB_FUNCTION_RESET_DEVICE:
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_RESET_DEVICE\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;

        case SRB_FUNCTION_REMOVE_DEVICE:
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_REMOVE_DEVICE\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;


        #ifdef __REGISTERFORSHUTDOWN__
        /* 
        * LP: Flush and Shutdown will not be called unless there is a logical drive 
        * created on a drive. Shutdown will be called once, but Flush will be called
        * many times in between the normal IOs
        */
        case SRB_FUNCTION_SHUTDOWN:
            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_SHUTDOWN\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            if (!pCard->AlreadyShutdown)
                fcShutdownChannel(&pCard->hpRoot);
            pCard->AlreadyShutdown++;
               
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;
            break;
         
        case SRB_FUNCTION_FLUSH:
            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_FUNCTION_FLUSH\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
            ScsiPortNotification(notify_type,
                                  pCard,
                                  srbPathId,
                                  srbTargetId,
                                  srbLun);

            ScsiPortNotification(RequestComplete, pCard, Srb);
            pCard->State &= ~CS_DURING_STARTIO;
            pCard->inDriver = FALSE;
            return TRUE;

            break;
        #endif
         
        default:
            // set error and complete request.
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

            osDEBUGPRINT((ALWAYS_PRINT,"SRB_STATUS_INVALID_REQUEST\n"));
            pSrbExt->SRB_State = RS_COMPLETE;
        } // end switch Srb->Function

        // request another request for this logical unit.
        // osDEBUGPRINT((DHIGH,"ScsiPortNotification %x\n", notify_type));

        #ifdef ORG
        ScsiPortNotification(notify_type,
                         pCard,
                         srbPathId,
                         srbTargetId,
                         srbLun);
        #endif

    pCard->State &= ~CS_DURING_STARTIO;
    //pSrbExt->Perf_ptr->outOsStartio = get_hi_time_stamp();

    pCard->inDriver = FALSE;

#ifdef DEBUG_OTHERS
    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIo: Completing other type of request: %d.%d.%d Func: %x SrbSta: %x ScsiSta: %x\n",
      Srb->PathId,
      Srb->TargetId,
      Srb->Lun,
      Srb->Function,
      Srb->SrbStatus,
      Srb->ScsiStatus ));
#endif
      
    ScsiPortNotification(RequestComplete, pCard, Srb);

    ScsiPortNotification(notify_type,
                         pCard,
                         srbPathId,
                         srbTargetId,
                         srbLun);

    return TRUE;

} // end HPFibreStartIo()


agFCDev_t
MapToHandle (PCARD_EXTENSION pCard,
    ULONG           pathId,
    ULONG           targetId,
    ULONG           lun,
    PLU_EXTENSION   pLunExt)
{   
    #ifndef YAM2_1
    ULONG       slot, specialDevIdx, volume;
    agFCDev_t   devHandle = NULL;
    
    if (pathId <= 3) 
    {
        slot = BUILD_SLOT(pathId, targetId);
        if (pCard->nodeInfo[slot].DeviceType & agDevSCSITarget) 
        {
            devHandle = pCard->hpFCDev[slot];
            if (pLunExt) 
            {
                pLunExt->Lun.lun_pd[0].Address_mode = PERIPHERAL_ADDRESS;
                pLunExt->Lun.lun_pd[0].Bus_number = 0;
                pLunExt->Lun.lun_pd[0].Lun = (UCHAR)lun;
            }
        }
    } 
    else 
    {
        specialDevIdx = targetId >> 4;
        if ((specialDevIdx < MAX_SPECIAL_DEVICES) &&
            (pCard->specialDev[specialDevIdx].devType != DEV_NONE)) 
        {
            if (pCard->specialDev[specialDevIdx].addrMode == LUN_ADDRESS) 
            {
                // This case is for MUX
                // LUN Addressing mode has only 5 bits for LUN number
                if (lun < 32) 
                {
                devHandle = pCard->hpFCDev [pCard->specialDev[specialDevIdx].devHandleIndex];
                if (pLunExt) 
                {
                    pLunExt->Lun.lun_lu[0].Address_mode = LUN_ADDRESS;
                    pLunExt->Lun.lun_lu[0].Target = (UCHAR) (targetId & 0xf);
                    pLunExt->Lun.lun_lu[0].Bus_number = (UCHAR) (pathId & 3);
                    pLunExt->Lun.lun_lu[0].Lun = (UCHAR) lun;
                }
            }
        } 
        else 
            if (pCard->specialDev[specialDevIdx].addrMode == VOLUME_SET_ADDRESS) 
            {
                //
                // This case is for EMC and COMPAQ
                // In order to be downward compatible with NT SP3, here we use only
                // 3 bits in LUN to build volume set number.
                //
                // Compaq array seems to be supporting only 256 volume sets.
                // It takes voume set 256 as volume set 0.
                // To work-around this problem we return NULL device handle for Compaq
                // array if the the volume set address is >= 256
                //
                if (lun < 8 && 
                    (pCard->specialDev[specialDevIdx].devType != DEV_COMPAQ || !(pathId & 2))) 
                {
                    devHandle = pCard->hpFCDev [pCard->specialDev[specialDevIdx].devHandleIndex];
                    if (pLunExt) 
                    {
                        volume = ((pathId & 3) << 7) | ((targetId & 0xf) << 3) | lun;
                        pLunExt->Lun.lun_vs[0].Address_mode = VOLUME_SET_ADDRESS;
                        pLunExt->Lun.lun_vs[0].Lun_hi = (UCHAR) (volume >> 8);
                        pLunExt->Lun.lun_vs[0].Lun = (UCHAR) (volume & 0xff);
                    }
                }
            }
        }
    }

    return devHandle;
    #else
    agFCDev_t   devHandle = NULL;
    USHORT      paIndex;
   
    if (GetPaDeviceHandle(pCard,pathId,targetId,lun,pLunExt,&paIndex) != -1L)
    {
        if ((pCard->Dev->PaDevice[paIndex].Index.Pa.FcDeviceIndex != PA_DEVICE_NO_ENTRY) )
        {
            ULONG fcIndex;
            fcIndex = pCard->Dev->PaDevice[paIndex].Index.Pa.FcDeviceIndex;
            #ifdef DBG
            if (fcIndex > gMaxPaDevices)
                osDEBUGPRINT((ALWAYS_PRINT, "MapToHandle: fcindex (=%d) > gMaxPaDevices (=%d)\n", fcIndex, gMaxPaDevices));
            #endif
         
            devHandle = pCard->hpFCDev[fcIndex];
        }
        else
            devHandle = NULL;
    }
    else
    {
        devHandle = NULL;
    }
    return devHandle;
    #endif
}

#ifdef _DEBUG_PERF_DATA_
void cdbswitch(PSCSI_REQUEST_BLOCK pSrb)
{
    PCARD_EXTENSION     pCard;
    PSRB_EXTENSION      pSrbExt;

    pSrbExt          = pSrb->SrbExtension;
    pCard            = pSrbExt->pCard;

    switch( pSrb->Cdb[0])
    {
        case SCSIOP_TEST_UNIT_READY    :
            osDEBUGPRINT((DMOD,"SCSIOP_TEST_UNIT_READY    \n"));break;
        case SCSIOP_REZERO_UNIT        :
            osDEBUGPRINT((DMOD,"SCSIOP_REZERO_UNIT        \n"));break;
        case SCSIOP_REQUEST_BLOCK_ADDR :
            osDEBUGPRINT((DMOD,"SCSIOP_REQUEST_BLOCK_ADDR \n"));break;
        case SCSIOP_REQUEST_SENSE      :
            osDEBUGPRINT((DMOD,"SCSIOP_REQUEST_SENSE      \n"));break;
        case SCSIOP_FORMAT_UNIT        :
            osDEBUGPRINT((DMOD,"SCSIOP_FORMAT_UNIT        \n"));break;
        case SCSIOP_READ_BLOCK_LIMITS  :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_BLOCK_LIMITS  \n"));break;
        case SCSIOP_REASSIGN_BLOCKS    :
            osDEBUGPRINT((DMOD,"SCSIOP_REASSIGN_BLOCKS    \n"));break;
        case SCSIOP_READ6              :
            osDEBUGPRINT((DMOD,"SCSIOP_READ6              \n"));break;
        case SCSIOP_WRITE6             :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE6             \n"));break;
        case SCSIOP_SEEK6              :
            osDEBUGPRINT((DMOD,"SCSIOP_SEEK6              \n"));break;
        case SCSIOP_PARTITION          :
            osDEBUGPRINT((DMOD,"SCSIOP_PARTITION          \n"));break;
        case SCSIOP_READ_REVERSE       :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_REVERSE       \n"));break;
        case SCSIOP_WRITE_FILEMARKS    :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE_FILEMARKS    \n"));break;
        case SCSIOP_SPACE              :
            osDEBUGPRINT((DMOD,"SCSIOP_SPACE              \n"));break;
        case SCSIOP_INQUIRY            :
            osDEBUGPRINT((DMOD,"SCSIOP_INQUIRY            \n"));break;
        case SCSIOP_VERIFY6            :
            osDEBUGPRINT((DMOD,"SCSIOP_VERIFY6            \n"));break;
        case SCSIOP_RECOVER_BUF_DATA   :
            osDEBUGPRINT((DMOD,"SCSIOP_RECOVER_BUF_DATA   \n"));break;
        case SCSIOP_MODE_SELECT        :
            osDEBUGPRINT((DMOD,"SCSIOP_MODE_SELECT        \n"));break;
        case SCSIOP_RESERVE_UNIT       :
            osDEBUGPRINT((ALWAYS_PRINT,"SCSIOP_RESERVE_UNIT       \n"));break;
        case SCSIOP_RELEASE_UNIT       :
            osDEBUGPRINT((ALWAYS_PRINT,"SCSIOP_RELEASE_UNIT       \n"));break;
        case SCSIOP_COPY               :
            osDEBUGPRINT((DMOD,"SCSIOP_COPY               \n"));break;
        case SCSIOP_ERASE              :
            osDEBUGPRINT((DMOD,"SCSIOP_ERASE              \n"));break;
        case SCSIOP_MODE_SENSE         :
            osDEBUGPRINT((DMOD,"SCSIOP_MODE_SENSE         \n"));break;
        case SCSIOP_START_STOP_UNIT    :
            osDEBUGPRINT((DMOD,"SCSIOP_START_STOP_UNIT    \n"));break;
        case SCSIOP_RECEIVE_DIAGNOSTIC :
            osDEBUGPRINT((DMOD,"SCSIOP_RECEIVE_DIAGNOSTIC \n"));break;
        case SCSIOP_SEND_DIAGNOSTIC    :
            osDEBUGPRINT((DMOD,"SCSIOP_SEND_DIAGNOSTIC    \n"));break;
        case SCSIOP_MEDIUM_REMOVAL     :
            osDEBUGPRINT((DMOD,"SCSIOP_MEDIUM_REMOVAL     \n"));break;
        case SCSIOP_READ_CAPACITY      :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_CAPACITY      \n"));break;
        case SCSIOP_READ               :
            osDEBUGPRINT((DMOD,"SCSIOP_READ               \n"));break;
        case SCSIOP_WRITE              :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE              \n"));break;
        case SCSIOP_SEEK               :
            osDEBUGPRINT((DMOD,"SCSIOP_SEEK               \n"));break;
        case SCSIOP_WRITE_VERIFY       :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE_VERIFY       \n"));break;
        case SCSIOP_VERIFY             :
            osDEBUGPRINT((DMOD,"SCSIOP_VERIFY             \n"));break;
        case SCSIOP_SEARCH_DATA_HIGH   :
            osDEBUGPRINT((DMOD,"SCSIOP_SEARCH_DATA_HIGH   \n"));break;
        case SCSIOP_SEARCH_DATA_EQUAL  :
            osDEBUGPRINT((DMOD,"SCSIOP_SEARCH_DATA_EQUAL  \n"));break;
        case SCSIOP_SEARCH_DATA_LOW    :
            osDEBUGPRINT((DMOD,"SCSIOP_SEARCH_DATA_LOW    \n"));break;
        case SCSIOP_SET_LIMITS         :
            osDEBUGPRINT((DMOD,"SCSIOP_SET_LIMITS         \n"));break;
        case SCSIOP_READ_POSITION      :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_POSITION      \n"));break;
        case SCSIOP_SYNCHRONIZE_CACHE  :
            osDEBUGPRINT((DMOD,"SCSIOP_SYNCHRONIZE_CACHE  \n"));break;
        case SCSIOP_COMPARE            :
            osDEBUGPRINT((DMOD,"SCSIOP_COMPARE            \n"));break;
        case SCSIOP_COPY_COMPARE       :
            osDEBUGPRINT((DMOD,"SCSIOP_COPY_COMPARE       \n"));break;
        case SCSIOP_WRITE_DATA_BUFF    :
            osDEBUGPRINT((DMOD,"SCSIOP_WRITE_DATA_BUFF    \n"));break;
        case SCSIOP_READ_DATA_BUFF     :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_DATA_BUFF     \n"));break;
        case SCSIOP_CHANGE_DEFINITION  :
            osDEBUGPRINT((DMOD,"SCSIOP_CHANGE_DEFINITION  \n"));break;
        case SCSIOP_READ_SUB_CHANNEL   :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_SUB_CHANNEL   \n"));break;
        case SCSIOP_READ_TOC           :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_TOC           \n"));break;
        case SCSIOP_READ_HEADER        :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_HEADER        \n"));break;
        case SCSIOP_PLAY_AUDIO         :
            osDEBUGPRINT((DMOD,"SCSIOP_PLAY_AUDIO         \n"));break;
        case SCSIOP_PLAY_AUDIO_MSF     :
            osDEBUGPRINT((DMOD,"SCSIOP_PLAY_AUDIO_MSF     \n"));break;
        case SCSIOP_PLAY_TRACK_INDEX   :
            osDEBUGPRINT((DMOD,"SCSIOP_PLAY_TRACK_INDEX   \n"));break;
        case SCSIOP_PLAY_TRACK_RELATIVE:
            osDEBUGPRINT((DMOD,"SCSIOP_PLAY_TRACK_RELATIVE\n"));break;
        case SCSIOP_PAUSE_RESUME       :
            osDEBUGPRINT((DMOD,"SCSIOP_PAUSE_RESUME       \n"));break;
        case SCSIOP_LOG_SELECT         :
            osDEBUGPRINT((DMOD,"SCSIOP_LOG_SELECT         \n"));break;
        case SCSIOP_LOG_SENSE          :
            osDEBUGPRINT((DMOD,"SCSIOP_LOG_SENSE          \n"));break;
        case SCSIOP_MODE_SELECT10      :
            osDEBUGPRINT((DMOD,"SCSIOP_MODE_SELECT10      \n"));break;
        case SCSIOP_MODE_SENSE10       :
            osDEBUGPRINT((DMOD,"SCSIOP_MODE_SENSE10       \n"));break;
        case SCSIOP_LOAD_UNLOAD_SLOT   :
            osDEBUGPRINT((DMOD,"SCSIOP_LOAD_UNLOAD_SLOT   \n"));break;
        case SCSIOP_MECHANISM_STATUS   :
            osDEBUGPRINT((DMOD,"SCSIOP_MECHANISM_STATUS   \n"));break;
        case SCSIOP_READ_CD            :
            osDEBUGPRINT((DMOD,"SCSIOP_READ_CD            \n"));break;
        default:
            osDEBUGPRINT((DMOD,"UNKNOWN_CMD               \n"));break;
    }    
            
}
#endif

PSRB_EXTENSION  Add_next_Srbext( PSRB_EXTENSION pSrbExt,PSRB_EXTENSION pNewSrbExt)
{
    if(pSrbExt->pNextSrbExt) 
        return pSrbExt->pNextSrbExt;
    else 
    {
        pSrbExt->pNextSrbExt = pNewSrbExt;
        pNewSrbExt->pNextSrbExt = NULL;
        return pNewSrbExt->pNextSrbExt;
    }
}

void insert_Srbext(PCARD_EXTENSION  pCard,PSRB_EXTENSION pSrbExt)
{
    PSRB_EXTENSION pTmpSrbExt = pCard->RootSrbExt;
    if(!pTmpSrbExt)
    {
        pCard->RootSrbExt = pSrbExt;
        return;
    }
   
    while(pTmpSrbExt)
    {
        pTmpSrbExt= Add_next_Srbext( pTmpSrbExt,pSrbExt);
    }
}

PSRB_EXTENSION  Del_next_Srbext( PSRB_EXTENSION pSrbExt,PSRB_EXTENSION pOldSrbExt)
{
    if(pSrbExt->pNextSrbExt != pOldSrbExt)
    {
        return pSrbExt->pNextSrbExt;
    }
    else 
    {
        pSrbExt->pNextSrbExt = pOldSrbExt->pNextSrbExt;
        return NULL;
    }
}

int remove_Srbext(PCARD_EXTENSION  pCard, PSRB_EXTENSION pSrbExt)
{
    PSRB_EXTENSION pTmpSrbExt = pCard->RootSrbExt;

    if(pTmpSrbExt == pSrbExt )
    {    
        pCard->RootSrbExt = pTmpSrbExt->pNextSrbExt;
        return(TRUE);
    }
   
    while(pTmpSrbExt)
    {
        pTmpSrbExt= Del_next_Srbext( pTmpSrbExt,pSrbExt);
    }
    return(TRUE);
}

void
SrbEnqueueTail (OSL_QUEUE *queue, PSCSI_REQUEST_BLOCK pSrb)
{
    ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb = NULL;
    if (queue->Head == NULL) 
    {
        queue->Head = pSrb;
        queue->Tail = pSrb;
    } 
    else 
    {
        ((PSRB_EXTENSION)(((PSCSI_REQUEST_BLOCK)(queue->Tail))->SrbExtension))->pNextSrb = pSrb;
        queue->Tail = pSrb;
    }

    #ifdef DBGPRINT_IO
    if (gDbgPrintIo & DBGPRINT_QTAIL )
    {
        static   count;
        UCHAR    *uptr;
        osDEBUGPRINT((ALWAYS_PRINT, " QueT(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Next=%x Head=%x Tail=%x\n",
         count++,
         pSrb->PathId,
         pSrb->TargetId,
         pSrb->Lun,
         pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
         pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
         pSrb,
         ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb,
         queue->Head,
         queue->Tail
         ));
    }
    #endif   

}

void
SrbEnqueueHead (OSL_QUEUE *queue, PSCSI_REQUEST_BLOCK pSrb)
{
    if (queue->Head == NULL) 
    {
        queue->Head = pSrb;
        queue->Tail = pSrb;
        ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb = NULL;
    } 
    else 
    {
        ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb = queue->Head;
        queue->Head = pSrb;
    }
    #ifdef DBGPRINT_IO
    if (gDbgPrintIo & DBGPRINT_QHEAD )
    {
        static   count;
        UCHAR    *uptr;
        osDEBUGPRINT((ALWAYS_PRINT, " QueH(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Next=%x Head=%x Tail=%x\n",
            count++,
            pSrb->PathId,
            pSrb->TargetId,
            pSrb->Lun,
            pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
            pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
            pSrb,
            ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb,
            queue->Head,
            queue->Tail
            ));
    }
    #endif   
}

PSCSI_REQUEST_BLOCK
SrbDequeueHead (OSL_QUEUE *queue)
{  
    PSCSI_REQUEST_BLOCK  pSrb;

    pSrb = queue->Head;
    if (pSrb != NULL) 
    {
        queue->Head = ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb;
        if (queue->Head == NULL)
            queue->Tail = NULL;
        #ifdef DBGPRINT_IO
        if (gDbgPrintIo & DBGPRINT_DEQHEAD )
        {
            static   count;
            UCHAR    *uptr;
            osDEBUGPRINT((ALWAYS_PRINT, " DeQH(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Next=%x Head=%x Tail=%x\n",
                count++,
                pSrb->PathId,
                pSrb->TargetId,
                pSrb->Lun,
                pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
                pSrb,
                ((PSRB_EXTENSION)(pSrb->SrbExtension))->pNextSrb,
                queue->Head,
                queue->Tail
                ));
        }
        #endif   
    }

    return pSrb;
}

void
Startio (PCARD_EXTENSION pCard)
{
    PSCSI_REQUEST_BLOCK     pSrb;
    PSRB_EXTENSION          pSrbExt;
    agRoot_t                *phpRoot;
    agFCDev_t               handle;
    agIORequest_t           *pHpio_request;
    agIORequestBody_t       *pHpio_CDBrequest;
    ULONG                   fcIoStatus;
    PLU_EXTENSION           pLunExt;
    int                     completeRequest;
    UCHAR                    pathId, targetId, lun;
    #ifdef YAM2_1
    PA_DEVICE                  *dev;
    #endif
   
    while ((pSrb = SrbDequeueHead (&pCard->AdapterQ)) != NULL) 
    {
        #ifdef _DEBUG_LOSE_IOS_
        osDEBUGPRINT((DMOD, "Startio Srb = %lx pCard->Srb_IO_Count = %x\n", pSrb, pCard->Srb_IO_Count));
        #endif
        pSrbExt          = pSrb->SrbExtension;
        phpRoot          = pSrbExt->phpRoot;
        handle           = pSrbExt->pLunExt->phandle;
        pHpio_request    = &pSrbExt->hpIORequest;
        pHpio_CDBrequest = &pSrbExt->hpRequestBody;
        pathId           = pSrb->PathId;
        targetId         = pSrb->TargetId;
        lun              = pSrb->Lun;
        completeRequest  = 0;
      
        #ifdef YAM2_1
        pLunExt = ScsiPortGetLogicalUnit (pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun);
        dev = pCard->Dev->PaDevice + pLunExt->PaDeviceIndex;
   
       /* wait till the addressing mode are established before processing non zeo LUNs */
//       if ( (dev->ModeFlag & PA_DEVICE_BUILDING_DEVICE_MAP) && (lun != 0) )
        if ( !(dev->ModeFlag & PA_DEVICE_TRY_MODE_ALL) && (lun != 0) )
        {
            pSrbExt->SRB_State =  RS_WAITING;
            SrbEnqueueTail (&pCard->RetryQ, pSrb);
            return;
        }
            
        /* make suer the FCP LUNs are set properly */
        SetFcpLunBeforeStartIO (pLunExt, pHpio_CDBrequest, pSrb);
        #endif
      
        #ifdef _DEBUG_PERF_DATA_
        cdbswitch(pSrb);
        pSrbExt->SRB_StartTime = osTimeStamp(0);
        #endif
        
        #ifdef _DEBUG_LOSE_IOS_
        pSrbExt->SRB_IO_COUNT = pCard->Srb_IO_Count;
        #endif
      
        #ifdef _DEBUG_PERF_DATA_
        pSrbExt->SRB_TimeOutTime = pSrbExt->SRB_StartTime+((pSrb->TimeOutValue - 3 ) * OS_STAMP_PER_SECOND);
        #endif
        
        #if DBG > 4
        if(pSrb->TimeOutValue < 10)
            osDEBUGPRINT((DMOD,"Time out value of IO is less than 10 seconds %d\n",pSrb->TimeOutValue));
        #endif

        #ifdef _DEBUG_PERF_DATA_
        pSrbExt->Perf_ptr->inFcStartio  = get_hi_time_stamp();
        #endif
        pSrbExt->SRB_State = RS_STARTIO;

        #ifdef DBGPRINT_IO
        if (gDbgPrintIo & DBGPRINT_SEND )
        {
            static   count;
            UCHAR    *uptr;
            ULONG    paDeviceIndex = 0;
         
            #ifdef YAM2_1
            paDeviceIndex = pLunExt->PaDeviceIndex;
            #endif

            osDEBUGPRINT((ALWAYS_PRINT, " Send(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x FCP0 %02x%02x PAIx=%d FCHndl=%08x\n",
                        count++,
                        pSrb->PathId,
                        pSrb->TargetId,
                        pSrb->Lun,
                        pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                        pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9],          
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[0],
                        pSrbExt->hpRequestBody.CDBRequest.FcpCmnd.FcpLun[1],
                        paDeviceIndex,
                        pSrbExt->pLunExt->phandle));
        }
        #endif   

        if (pCard->LinkState != LS_LINK_UP) 
            fcIoStatus = fcIOBusy;
        else
            fcIoStatus = fcStartIO( phpRoot,
                                pHpio_request,
                                handle, // pLunExt->phandle,
                                fcCDBRequest,
                                &pSrbExt->hpRequestBody);

        #ifdef _DEBUG_PERF_DATA_
        pSrbExt->Perf_ptr->outFcStartio = get_hi_time_stamp();
        #endif
        
        switch (fcIoStatus )
        {
            case fcIOStarted:

                #ifdef FCLayer_Stub // Stub only !!!!
                osDEBUGPRINT((DMOD,"HPFibreStartIo DO TimerCall @ %x\n", osTimeStamp(0) ));
                ScsiPortNotification(RequestTimerCall,
                                    pCard,
                                    (PHW_TIMER) osFakeInterrupt,
                                    // 1000000 ); // 1000000 should be 1 second
                                    12000 ); //  .012 sec
                                    //100000 ); //  .10 sec
                                    // 250000 ); //  .25 sec

                #endif /*  FCLayer_Stub */

                #ifdef _DEBUG_LOSE_IOS_
                pCard->Srb_IO_Count++;
                #endif
                //
                // NOTE: There is a chance that FC Layer may complete the request (call
                // osIoCompleted) before fcStartIo returns.
                // So don't make any references to Srb from here onwards.
                
                
                #ifdef _DEBUG_PERF_DATA_
                insert_Srbext( pCard, pSrbExt);
                #endif
                break;

            case fcIOBusy:

                pSrbExt->SRB_State =  RS_WAITING;
                SrbEnqueueHead (&pCard->AdapterQ, pSrb);
                osDEBUGPRINT((ALWAYS_PRINT,"startio FCLAYER Busy\n"));
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(   pCard, 
                    (PVOID)pSrbExt, 
                    HPFC_MSG_STARTIO_ERROR,
                    NULL, 
                    0, 
                    "%x", fcIoStatus);
                #endif
                return;

            case fcIONoDevice:
                pSrbExt->SRB_State =  RS_NODEVICE;
                osDEBUGPRINT((ALWAYS_PRINT,"startio FCLAYER reports fcIONoDevice\n"));
                pSrb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                completeRequest = 1;
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(   pCard, 
                     (PVOID)pSrbExt, 
                     HPFC_MSG_STARTIO_ERROR,
                     NULL, 
                     0, 
                     "%x", fcIoStatus);
                #endif
                break;

            case fcIONoSupport:
            case fcIOBad:
            default:
                osDEBUGPRINT((ALWAYS_PRINT,"startio FCLAYER reports fcIoStatus = %d\n", fcIoStatus));
                pSrb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
                completeRequest = 1;
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(   pCard, 
                  (PVOID)pSrbExt, 
                  HPFC_MSG_STARTIO_ERROR,
                  NULL, 
                  0, 
                  "%x", fcIoStatus);
                #endif
                break;

        } // switch fcIoStatus

        if (completeRequest) 
        {
            pLunExt = ScsiPortGetLogicalUnit (pCard, pSrb->PathId, pSrb->TargetId, pSrb->Lun);

            if (pLunExt)
                pLunExt->OutstandingIOs--;

            pSrbExt->SRB_State = RS_COMPLETE;
            osDEBUGPRINT((ALWAYS_PRINT,"StartIO: Completing request Srb=%x\n",pSrb));

            ScsiPortNotification (RequestComplete, pCard, pSrb);
        }
    } // while ((pSrb = SrbDequeueFromHead (&pCard->AdapterQ)) != NULL)

    ScsiPortNotification (NextLuRequest, pCard, pathId, targetId, lun);

    osDEBUGPRINT((DMOD,"OUT StartIo\n" ));
    return;
}

void
InitLunExtension (PLU_EXTENSION pLunExt)
{
    pLunExt->flags = LU_EXT_INITIALIZED;
    pLunExt->MaxAllowedIOs = MAX_IO_PER_DEVICE;
    pLunExt->OutstandingIOs = 0;
    pLunExt->MaxOutstandingIOs = 0;
    pLunExt->phandle = 0;

    /* if not multi mode, set it to PA addressing only */
    if (gMultiMode == FALSE)
        pLunExt->Mode = PA_DEVICE_TRY_MODE_PA;

}

#ifdef _ENABLE_PSEUDO_DEVICE_
ULONG PseudoDeviceIO(
    IN PCARD_EXTENSION pCard,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    ULONG tid, tmp, i;
   
    PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
   
    if ((Srb->PathId == 4) && (Srb->TargetId == 0))
    {
        if ( (Srb->Lun == 0)  && (Srb->Cdb[0] == SCSIOP_INQUIRY) )
        {
            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            //
            // Zero INQUIRY data structure.
            //
            for (i = 0; i < Srb->DataTransferLength; i++) 
            {
                ((PUCHAR) Srb->DataBuffer)[i] = 0;
            }

            //
            // Set to funky device type to hide from windisk.
            //
            ((PINQUIRYDATA) Srb->DataBuffer)->DeviceType = PROCESSOR_DEVICE;

            //
            // Fill in vendor identification fields.
            //
            tid = Srb->TargetId + 0x30;

            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[0] = 'F';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[1] = 'C';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[2] = 'C';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[3] = 'I';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[4] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[5] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[6] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->VendorId[7] = ' ';

            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[0]  = 'P';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[1]  = 'S';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[2]  = 'E';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[3]  = 'U';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[4]  = 'D';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[5]  = 'O';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[6]  = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[7]  = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[8]  = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[9]  = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[10] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[11] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[12] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[13] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[14] = ' ';
            ((PINQUIRYDATA) Srb->DataBuffer)->ProductId[15] = ' ';

            tmp = 1;

            for (i = 0; i < 4; i++) 
            {
                ((PINQUIRYDATA) Srb->DataBuffer)->ProductRevisionLevel[i] = (UCHAR) tmp + 0x30;
                tmp >>= 8;
            }
        }
        else 
        {
            Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
        }
         
        pSrbExt->SRB_State = RS_COMPLETE;
        ScsiPortNotification(RequestComplete, pCard, Srb);
        ScsiPortNotification(NextRequest,
                         pCard,
                         Srb->PathId,
                         Srb->TargetId,
                         Srb->Lun);

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\sfstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/SFSTATE.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/30/00 3:19p  $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/fcstruct.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"

#include "../h/devstate.h"
#ifdef _DvrArch_1_30_
#include "../h/ip.h"
#include "../h/pktstate.h"
#endif /* _DvrArch_1_30_ was defined */
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/tgtstate.h"
#include "../h/queue.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/sf_fcp.h"
#include "../h/timersvc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "fcstruct.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"

#include "cstate.h"
#include "cfunc.h"

#include "devstate.h"
#ifdef _DvrArch_1_30_
#include "ip.h"
#include "pktstate.h"
#endif /* _DvrArch_1_30_ was defined */
#include "cdbstate.h"
#include "sfstate.h"
#include "tgtstate.h"
#include "queue.h"
#include "linksvc.h"
#include "cmntrans.h"
#include "sf_fcp.h"
#include "timersvc.h"
#endif  /* _New_Header_file_Layout_ */


/*
[maxEvents][maxStates];

*/
stateTransitionMatrix_t SFStateTransitionMatrix = {
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1 SFEventReset */
    SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
      SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
        SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
          SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
            SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
              SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                  SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                    SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                      SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                        SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                          SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                            SFStateFree, SFStateFree, SFStateFree, SFStateFree,
    SFStateFree,
      SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
        SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
          SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
            SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
              SFStateFree, SFStateFree, SFStateFree, SFStateFree, SFStateFree,
                SFStateFree, SFStateFree, SFStateFree,SFStateFree, SFStateFree,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2 SFEventDoPlogi */
     SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
      SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
        SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
          SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
            SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
              SFStateDoPlogi, SFStateDoPlogi,              0, SFStateDoPlogi, SFStateDoPlogi,
                SFStateDoPlogi, SFStateDoPlogi,   SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                  SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                    SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                      SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                        SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                          SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
                            SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi,
    SFStateDoPlogi,
      SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,
        SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
          SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,
            SFStateDoPlogi, SFStateDoPlogi, SFStateDoPlogi,  SFStateDoPlogi,SFStateDoPlogi,
              SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,
                SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,SFStateDoPlogi,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 3 SFEventPlogiAccept  */
    0,0,SFStatePlogiAccept,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 4 SFEventPlogiRej */
    0,0,SFStatePlogiRej,     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 5 SFEventPlogiBadALPA */
    0,SFStateFree,SFStatePlogiBadALPA,0,0,
      SFStatePlogiBadALPA,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6 SFEventPlogiTimedOut */
    0,0,SFStatePlogiTimedOut,0,0,SFStatePlogiTimedOut,SFStatePlogiTimedOut,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7 SFEventDoPrli */
    SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
      SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
        SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
          SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
            SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
              SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                  SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                    SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                      SFStateDoPrli, SFStateDoPrli,             0, SFStateDoPrli, SFStateDoPrli,
                        SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
                          SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
                            SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
    SFStateDoPrli,
      SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,
        SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
          SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,
            SFStateDoPrli, SFStateDoPrli, SFStateDoPrli, SFStateDoPrli,SFStateDoPrli,
              SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,
                SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,SFStateDoPrli,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8 SFEventPrliAccept */
    0,0,0,0,0,0,0,SFStatePrliAccept,   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9 SFEventPrliRej */
    0,0,0,0,0,0,0,SFStatePrliRej,      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10  SFEventPrliBadALPA0 */
    0,0,0,0,0,0,0,SFStatePrliBadAlpa,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11 B SFEventPrliTimedOut */
    0,0,0,0,0,0,0,SFStatePrliTimedOut, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12 C SFEventDoFlogi */
    SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
      SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
        SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
          SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
            SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
              SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                  SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                    SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                      SFStateDoFlogi, SFStateDoFlogi,              0, SFStateDoFlogi, SFStateDoFlogi,
                        SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
                          SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
                            SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
    SFStateDoFlogi,
      SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,
        SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
          SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,
            SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,SFStateDoFlogi,
              SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,SFStateDoFlogi,
                SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi, SFStateDoFlogi,SFStateDoFlogi,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13 D SFEventFlogiAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,SFStateFlogiAccept,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14 E SFEventFlogiRej */
    0,0,0,0,0,0,0,0,0,0,0,0,SFStateFlogiRej,     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15 F SFEventFlogiBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,SFStateFlogiBadALPA, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16 10 SFEventFlogiTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,SFStateFlogiTimedOut,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17 11 SFEventDoLogo */
    SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
      SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
        SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
          SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
            SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
              SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                  SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                    SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                      SFStateDoLogo, SFStateDoLogo,              0, SFStateDoLogo, SFStateDoLogo,
                        SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
                          SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
                            SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
    SFStateDoLogo,
      SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,
        SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
          SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,
            SFStateDoLogo, SFStateDoLogo, SFStateDoLogo, SFStateDoLogo,SFStateDoLogo,
              SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,
                SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,SFStateDoLogo,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18 12 SFEventLogoAccept*/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateLogoAccept,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19 13 SFEventLogoRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateLogoRej,     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 20 14 SFEventLogoBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateLogoBadALPA, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21 15 SFEventLogoTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateLogoTimedOut,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22 16 SFEventDoPrlo */
    SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
     SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
      SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
       SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
        SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
         SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
          SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
           SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
            SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
             SFStateDoPrlo, SFStateDoPrlo,             0, SFStateDoPrlo, SFStateDoPrlo,
              SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
               SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
                SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
    SFStateDoPrlo,
      SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,SFStateDoPrlo,
        SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
          SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,
            SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,SFStateDoPrlo,
              SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,SFStateDoPrlo,
                SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo, SFStateDoPrlo,SFStateDoPrlo,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23 17 SFEventPrloAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePrloAccept,   0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24 18 SFEventPrloRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePrloRej,      0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25 19 SFEventPrloBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePrloBadALPA,  0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26 1a SFEventPrloTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePrloTimedOut ,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27 1b SFEventDoAdisc */
    SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
     SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
      SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
       SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
        SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
         SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
          SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
           SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
            SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
             SFStateDoAdisc, SFStateDoAdisc,              0, SFStateDoAdisc, SFStateDoAdisc,
              SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
               SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
                SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
    SFStateDoAdisc,
      SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,SFStateDoAdisc,
        SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
          SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
            SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,
              SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,SFStateDoAdisc,
                SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc, SFStateDoAdisc,SFStateDoAdisc,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28 1c SFEventAdiscAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAdiscAccept,  0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29 1d SFEventAdiscRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAdiscRej,     0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 30 1e SFEventAdiscBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAdiscBadALPA, 0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31 1f SFEventAdiscTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAdiscTimedOut,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32 20 SFEventDoPdisc */
    SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
     SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
      SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
       SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
        SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
         SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
          SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
           SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
            SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
             SFStateDoPdisc, SFStateDoPdisc,              0, SFStateDoPdisc, SFStateDoPdisc,
              SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
               SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
                SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
    SFStateDoPdisc,
      SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,
        SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
          SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
            SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,SFStateDoPdisc,
              SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,SFStateDoPdisc,
                SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc, SFStateDoPdisc,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33 21 SFEventPdiscAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePdiscAccept,  0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34 22 SFEventPdiscRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePdiscRej,     0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35 23 SFEventPdiscBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePdiscBadALPA, 0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36 24 SFEventPdiscTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStatePdiscTimedOut,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37 25 SFEventDoAbort */
    SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
     SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
      SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
       SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
        SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
         SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
          SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
           SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
            SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
             SFStateDoAbort, SFStateDoAbort,              0, SFStateDoAbort, SFStateDoAbort,
              SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
               SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
                SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
    SFStateDoAbort,
      SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,
        SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
          SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,
            SFStateDoAbort, SFStateDoAbort, SFStateDoAbort, SFStateDoAbort,SFStateDoAbort,
              SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,
                SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,SFStateDoAbort,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38 26 SFEventAbortAccept */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAbortAccept,  0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39 27 SFEventAbortRej */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAbortRej,     0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 40 28 SFEventAbortBadALPA */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAbortBadALPA, 0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41 29 SFEventAbortTimedOut */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SFStateAbortTimedOut,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42 2a SFEventDoResetDevice */
    SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
     SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
      SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
       SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
        SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
         SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
          SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
           SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
            SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
             SFStateDoResetDevice, SFStateDoResetDevice,                    0, SFStateDoResetDevice, SFStateDoResetDevice,
              SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
               SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
                SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
    SFStateDoResetDevice,
      SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,
        SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
          SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
            SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
              SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,SFStateDoResetDevice,
                SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice, SFStateDoResetDevice,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43 2b SFEventResetDeviceAccept */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateResetDeviceAccept,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44 2c SFEventResetDeviceRej */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateResetDeviceRej,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45 2d SFEventResetDeviceBadALPA */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateResetDeviceBadALPA,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46 2e SFEventResetDeviceTimedOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateResetDeviceTimedOut,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47 2f SFEventDoLS_RJT */
    SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
     SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
      SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
       SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
        SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
         SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
          SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
           SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
            SFStateDoLS_RJT, SFStateDoLS_RJT,               0, SFStateDoLS_RJT, SFStateDoLS_RJT,
             SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
              SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
               SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
                SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
    SFStateDoLS_RJT,
      SFStateDoLS_RJT, SFStateDoLS_RJT,  SFStateDoLS_RJT, SFStateDoLS_RJT,SFStateDoLS_RJT,
        SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
          SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
            SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,
              SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT, SFStateDoLS_RJT,SFStateDoLS_RJT,
                SFStateDoLS_RJT, SFStateDoLS_RJT,  SFStateDoLS_RJT, SFStateDoLS_RJT,SFStateDoLS_RJT,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 48 30 SFEventLS_RJT_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFStateLS_RJT_Done,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49 31 SFEventDoPlogiAccept */
    SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
     SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
      SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
       SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
        SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
         SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
          SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
           SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
            SFStateDoPlogiAccept, SFStateDoPlogiAccept,                    0, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
             SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
              SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
               SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
                SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
    SFStateDoPlogiAccept,
      SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
        SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
          SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
            SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
              SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
                SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept, SFStateDoPlogiAccept,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 50 32 SFEventPlogiAccept_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,SFStatePlogiAccept_Done, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51 33 SFEventDoPrliAccept */
    SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
     SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
      SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
       SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
        SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
         SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
          SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
           SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
            SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
             SFStateDoPrliAccept, SFStateDoPrliAccept,                   0, SFStateDoPrliAccept, SFStateDoPrliAccept,
              SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
               SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
                SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
    SFStateDoPrliAccept,
      SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept, SFStateDoPrliAccept,
        SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
          SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
            SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept, SFStateDoPrliAccept,
              SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept, SFStateDoPrliAccept,
                SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept,SFStateDoPrliAccept, SFStateDoPrliAccept,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52 34 SFEventPrliAccept_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,SFStatePrliAccept_Done,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53 35 SFEventDoELSAccept    */
    SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
     SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
      SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
       SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
        SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
         SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
          SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
           SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
            SFStateDoELSAccept, SFStateDoELSAccept,                    0, SFStateDoELSAccept, SFStateDoELSAccept,
             SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
              SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
               SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
                SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
    SFStateDoELSAccept,
      SFStateDoELSAccept,SFStateDoELSAccept,SFStateDoELSAccept,SFStateDoELSAccept, SFStateDoELSAccept,
        SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
          SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
            SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,
              SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept, SFStateDoELSAccept,SFStateDoELSAccept,
                SFStateDoELSAccept,SFStateDoELSAccept,SFStateDoELSAccept,SFStateDoELSAccept, SFStateDoELSAccept,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54 SFEventELSAccept_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,SFStateELSAccept_Done,0,  0,0,0,0,0, 0,0,0,0,
    0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55 SFEventDoFCP_DR_ACC_Reply */
    SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                          0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
     SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
      SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
       SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
        SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
         SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
          SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
           SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
            SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,                         0, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
             SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
              SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
               SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
                SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
    SFStateDoFCP_DR_ACC_Reply,
      SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
        SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
          SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
            SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
              SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
                SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply,SFStateDoFCP_DR_ACC_Reply, SFStateDoFCP_DR_ACC_Reply,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56 SFEventFCP_DR_ACC_Reply_Done */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  SFStateFCP_DR_ACC_Reply_Done,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  57 SFEventLS_RJT_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,SFEventLS_RJT_TimeOut,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  58 SFEventPlogiAccept_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,SFEventPlogiAccept_TimeOut, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  59 SFEventPrliAccept_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,SFEventPrliAccept_TimeOut,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  60 SFEventELSAccept_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,SFEventELSAccept_TimeOut,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event  61 SFEventFCP_DR_ACC_Reply_TimeOut */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  SFEventFCP_DR_ACC_Reply_TimeOut,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62   SFEventDoRFT_ID */
    SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
      SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
        SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
          SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
            SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
              SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                  SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                    SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                      SFStateDoRFT_ID, SFStateDoRFT_ID,              0, SFStateDoRFT_ID, SFStateDoRFT_ID,
                        SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                          SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                            SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                              SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,SFStateDoRFT_ID,
                                SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                                  SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                                    SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,
                                      SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,SFStateDoRFT_ID,
                                        SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID, SFStateDoRFT_ID,SFStateDoRFT_ID,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63   SFEventRFT_IDAccept */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0, 0,
                          0,0,0,0,0,
                            0,0,SFStateRFT_IDAccept,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64   SFEventRFT_IDRej */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,SFStateRFT_IDRej,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65   SFEventRFT_IDBadALPA */
    0,0,0,0,0,
      0,0,0,0,0,
         0,0,0,0,0,
           0,0,0,0,0,
             0,0,0,0,0,
               0,0,0,0,0,
                 0,0,0,0,0,
                   0,0,0,0,0,
                     0,0,0,0,0,
                       0,0,0,0,0,
                         0,0,0,0,0,
                           0,0,0,0,0,
                             0,0,SFStateRFT_IDBadALPA,0,0,
                               0,0,0,0,0,
                                 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66   SFEventRFT_IDTimedOut */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0, 0 ,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,SFStateRFT_IDTimedOut,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67   SFEventDoGID_FT */
    SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
      SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
        SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
          SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
            SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
              SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                  SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                    SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                      SFStateDoGID_FT, SFStateDoGID_FT,              0, SFStateDoGID_FT, SFStateDoGID_FT,
                        SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                          SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                            SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                              SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,SFStateDoGID_FT,
                                SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                                  SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                                    SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,
                                      SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,SFStateDoGID_FT,
                                        SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT, SFStateDoGID_FT,SFStateDoGID_FT,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68   SFEventGID_FTAccept */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,SFStateGID_FTAccept,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69   SFEventGID_FTRej */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,SFStateGID_FTRej,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 70   SFEventGID_FTBadALPA */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,SFStateGID_FTBadALPA,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71   SFEventGID_FTTimedOut */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,SFStateGID_FTTimedOut,0,0,
                                0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
   /* Event 72   SFEventDoSCR */
    SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
      SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
        SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
          SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
            SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
              SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                  SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                    SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                      SFStateDoSCR, SFStateDoSCR,              0, SFStateDoSCR, SFStateDoSCR,
                        SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                          SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                            SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                              SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,SFStateDoSCR,
                                SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                                  SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                                    SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,
                                      SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,SFStateDoSCR,
                                        SFStateDoSCR, SFStateDoSCR, SFStateDoSCR, SFStateDoSCR,SFStateDoSCR,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73   SFEventSCRAccept */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,SFStateSCRAccept,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74   SFEventSCRRej */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,SFStateSCRRej,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75   SFEventSCRBadALPA */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,SFStateSCRBadALPA,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76   SFEventSCRTimedOut */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,SFStateSCRTimedOut,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77 11 SFEventDoSRR */
    SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
      SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
        SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
          SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
            SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
              SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                  SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                    SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                      SFStateDoSRR,SFStateDoSRR,           0,SFStateDoSRR,SFStateDoSRR,
                        SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                          SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                            SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                              SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                  SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                    SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                      SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
                                        SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,SFStateDoSRR,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78 12 SFEventSRRAccept*/
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0,
                                  0,0,SFStateSRRAccept,0,0,
                                    0,0,0,0,0,
                                      0,0,0,0,0,
                                        0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79 13 SFEventSRRRej */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,SFStateSRRRej,SFStateSRRRej,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 80 14 SFEventSRRBadALPA */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0,
                                  0,0,SFStateSRRBadALPA,0,0,
                                    0,0,0,0,0,
                                      0,0,0,0,0,
                                        0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81 15 SFEventSRRTimedOut */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0,
                                  0,0,SFStateSRRTimedOut,0,0,
                                    0,0,0,0,0,
                                      0,0,0,0,0,
                                        0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82 11 SFEventDoREC */
    SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
      SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
        SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
          SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
            SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
              SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                  SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                    SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                      SFStateDoREC, SFStateDoREC,              0, SFStateDoREC, SFStateDoREC,
                        SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
                          SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
                            SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
    SFStateDoREC,
      SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,
        SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
          SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,
            SFStateDoREC, SFStateDoREC, SFStateDoREC, SFStateDoREC,SFStateDoREC,
              SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,
                SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,SFStateDoREC,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83 12 SFEventRECAccept*/
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,SFStateRECAccept,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84 13 SFEventRECRej */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,SFStateRECRej,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85 14 SFEventRECBadALPA */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,SFStateRECBadALPA,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86 15 SFEventRECTimedOut */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,SFStateRECTimedOut,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87 SFEventDoADISCAccept                                                     */
    SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept,
      SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 5 */
        SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 10 */
          SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 15 */
            SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 20 */
              SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 25 */
                SFStateDoADISCAccept,SFStateDoADISCAccept,    0,    SFStateDoADISCAccept,SFStateDoADISCAccept, /* 30 */
                  SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 35 */
                    SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 40 */
                      SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,    0    , /* 45 */
                        SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept, /* 50 */
                          SFStateDoADISCAccept,SFStateDoADISCAccept,SFStateDoADISCAccept,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 55 */
                                0    ,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 60 */
                              SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 65 */
                                SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 70 */
                                  SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 75 */
                                    SFStateDoADISCAccept,SFStateDoADISCAccept,    0    ,SFStateDoADISCAccept,SFStateDoADISCAccept, /* 80 */
                                      SFStateDoADISCAccept,SFStateDoADISCAccept,SFStateDoADISCAccept,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88 SFEventADISCAccept_Done                                                     */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,SFStateADISCAccept_Done,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89 SFEventADISCAccept_TimeOut                */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,SFStateADISCAccept_TimeOut,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
#ifdef _DvrArch_1_30_
    /* Event 90 SFEventDoFarpRequest                      */
    SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
     SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
      SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
       SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
        SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
         SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
          SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
           SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
            SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
             SFStateDoFarpRequest, SFStateDoFarpRequest,              0, SFStateDoFarpRequest, SFStateDoFarpRequest,
              SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
               SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                 SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,SFStateDoFarpRequest,
                  SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                   SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                    SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,
                     SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,SFStateDoFarpRequest,
                      SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest, SFStateDoFarpRequest,SFStateDoFarpRequest,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91 SFEventFarpReplied                        */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        SFStateFarpRequestDone,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92 SFEventFarpRequestTimedOut                */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        SFStateFarpRequestTimedOut,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93 SFEventDoFarpReply                        */
    SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
     SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
      SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
       SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
        SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
         SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
          SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
           SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
            SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
             SFStateDoFarpReply, SFStateDoFarpReply,              0, SFStateDoFarpReply, SFStateDoFarpReply,
              SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
               SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                 SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,SFStateDoFarpReply,
                  SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                   SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                    SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,
                     SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,SFStateDoFarpReply,
                      SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply, SFStateDoFarpReply,SFStateDoFarpReply,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94 SFEventFarpReplyDone                      */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,SFStateFarpReplyDone,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
#else /* _DvrArch_1_30_ was not defined */
    /* Event 90                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
#endif /* _DvrArch_1_30_ was not defined */
    /* Event 95                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                           */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 110                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 120                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 125                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                          */
    0,0,0,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

/*
stateTransitionMatrix_t copiedSFStateTransitionMatrix;
*/

stateActionScalar_t SFStateActionScalar = {
    &SFActionConfused,
    &SFActionReset,
    &SFActionDoPlogi,
    &SFActionPlogiAccept,
    &SFActionPlogiRej,
    &SFActionPlogiBadALPA,
    &SFActionPlogiTimedOut,
    &SFActionDoPrli,
    &SFActionPrliAccept,
    &SFActionPrliRej,
    &SFActionPrliBadALPA,
    &SFActionPrliTimedOut,
    &SFActionDoFlogi,
    &SFActionFlogiAccept,
    &SFActionFlogiRej,
    &SFActionFlogiBadALPA,
    &SFActionFlogiTimedOut,
    &SFActionDoLogo,
    &SFActionLogoAccept,
    &SFActionLogoRej,
    &SFActionLogoBadALPA,
    &SFActionLogoTimedOut,
    &SFActionDoPrlo,
    &SFActionPrloAccept,
    &SFActionPrloRej,
    &SFActionPrloBadALPA,
    &SFActionPrloTimedOut,
    &SFActionDoAdisc,
    &SFActionAdiscAccept,
    &SFActionAdiscRej,
    &SFActionAdiscBadALPA,
    &SFActionAdiscTimedOut,
    &SFActionDoPdisc,
    &SFActionPdiscAccept,
    &SFActionPdiscRej,
    &SFActionPdiscBadALPA,
    &SFActionPdiscTimedOut,
    &SFActionDoAbort,
    &SFActionAbortAccept,
    &SFActionAbortRej,
    &SFActionAbortBadALPA,
    &SFActionAbortTimedOut,
    &SFActionDoResetDevice,
    &SFActionResetDeviceAccept,
    &SFActionResetDeviceRej,
    &SFActionResetDeviceBadALPA,
    &SFActionResetDeviceTimedOut,
    &SFActionDoLS_RJT,
    &SFActionLS_RJT_Done,
    &SFActionDoPlogiAccept,
    &SFActionPlogiAccept_Done,
    &SFActionDoPrliAccept,
    &SFActionPrliAccept_Done,
    &SFActionDoELSAccept,
    &SFActionELSAccept_Done,
    &SFActionDoFCP_DR_ACC_Reply,
    &SFActionFCP_DR_ACC_Reply_Done,
    &SFActionLS_RJT_TimeOut,
    &SFActionPlogiAccept_TimeOut,
    &SFActionPrliAccept_TimeOut,
    &SFActionELSAccept_TimeOut,
    &SFActionFCP_DR_ACC_Reply_TimeOut,
    &SFActionDoRFT_ID,
    &SFActionRFT_IDAccept,
    &SFActionRFT_IDRej,
    &SFActionRFT_IDBadALPA,
    &SFActionRFT_IDTimedOut,
    &SFActionDoGID_FT,
    &SFActionGID_FTAccept,
    &SFActionGID_FTRej,
    &SFActionGID_FTBadALPA,
    &SFActionGID_FTTimedOut,
    &SFActionDoSCR,
    &SFActionSCRAccept,
    &SFActionSCRRej,
    &SFActionSCRBadALPA,
    &SFActionSCRTimedOut,
    &SFActionDoSRR,
    &SFActionSRRAccept,
    &SFActionSRRRej,
    &SFActionSRRBadALPA,
    &SFActionSRRTimedOut,
    &SFActionDoREC,
    &SFActionRECAccept,
    &SFActionRECRej,
    &SFActionRECBadALPA,
    &SFActionRECTimedOut,
    &SFActionDoADISCAccept,
    &SFActionADISCAccept_Done,
    &SFActionADISCAccept_TimeOut,
#ifdef _DvrArch_1_30_
    &SFActionDoFarpRequest,
    &SFActionFarpRequestDone,
    &SFActionFarpRequestTimedOut,
    &SFActionDoFarpReply,
    &SFActionFarpReplyDone,
#else /* _DvrArch_1_30_ was not defined */
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
#endif /* _DvrArch_1_30_ was not defined */
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused,
    &SFActionConfused

    };

stateActionScalar_t copiedSFStateActionScalar;


#define SFtestCompareBase 0x00000110

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t SFtestActionUpdate[] = {
                         0,          0,      agNULL,                 agNULL
                     };
#endif /* __State_Force_Static_State_Tables__ was not defined */


#ifndef USESTATEMACROS

/*+
  Function: SFActionConfused
   Purpose: Terminating State for error detection 
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: None
-*/
/* SFStateConfused                 0 */
extern void SFActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord ){

    fiLogString(thread->hpRoot,
                    "SFActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In Thread(%p) %s - State = %d",
                    "SFActionConfused",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionReset
   Purpose: Indicates sfstate is available. Terminating State.
 Called By: Any sfthread that completes.
     Calls: None
-*/
/* SFStateFree                     1 */
extern void SFActionReset( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    if(pDevThread)
    {
        fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevel,
                        "In %s - State = %d ALPA %X",
                        "SFActionReset",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        0,0,0,0,0,0);
    }

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionDoPlogi
   Purpose: Does PLOGI. Terminating State.
 Called By: SFEventDoPlogi.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInPLOGI
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventPlogiTimedOut
            Proccess_IMQ
-*/
/* SFStateDoPlogi                  2 */
extern void SFActionDoPlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t   *    hpRoot = thread->hpRoot;
    CThread_t  *   pCThread= CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    os_bit32 SFS_Len = 0;

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x",
                    "SFActionDoPlogi",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogConsoleLevel,
                    "ERQ Producer %X ERQ_Consumer_Index %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index),
                    osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index),
                    0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {
        pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "Do Plogi ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    if( pDevThread->Plogi_Reason_Code == PLOGI_REASON_DIR_LOGIN) pCThread->Fabric_pollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        SFS_Len = fiFillInPLOGI( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPlogiTimedOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

#ifndef OSLayer_Stub

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
        fiSetEventRecord(eventRecord,thread,SFEventPlogiAccept);
#endif  /* OSLayer_Stub */

    }
    else
    {

         fiLogDebugString(hpRoot ,
                        SFStateLogErrorLevel,
                        "%s Queues_Frozen - AL_PA %X FM Status %08X TL Status %08X CState %d",
                        "SFActionDoPlogi",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0);

        fiLogDebugString(hpRoot,
                        SFStateLogErrorLevel,
                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        0,0);
        /* Enable rescan for this device */
        pDevThread->Prev_Active_Device_FLAG = agDevSCSITarget;
        fiSetEventRecord(eventRecord,thread,SFEventPlogiTimedOut);
    }
}

/*+
  Function: SFActionPlogiAccept
   Purpose: PLOGI success state. Depending on Plogi_Reason_Code send appropriate
            event.
 Called By: SFEventPlogiAccept.
     Calls: fiTimerStop
            DevEventAL_PA_Self_OK
            DevEventPlogiSuccess
            DevEventDeviceResetDone
            DevEventAL_PA_Self_OK
-*/
/* SFStatePlogiAccept              3 */
extern void SFActionPlogiAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "(%p)In %s - State = %d CState %d ALPA %X CCnt %x DCnt %x",
                    "SFActionPlogiAccept",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->thread_hdr.currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0);

    switch( pDevThread->Plogi_Reason_Code)
    {
        case  PLOGI_REASON_VERIFY_ALPA:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_OK);
                break;
        case  PLOGI_REASON_DEVICE_LOGIN:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPlogiSuccess);
                break;
        case  PLOGI_REASON_SOFT_RESET:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDone);
                break;
        case  PLOGI_REASON_HEART_BEAT:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_OK);
                break;
        case  PLOGI_REASON_DIR_LOGIN:
                /* Don't do anything - Cthread will take over based on the SF State */
                CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;
                fiSetEventRecordNull(eventRecord);
                break;
        default:
                fiLogDebugString(thread->hpRoot,
                                SFStateLogErrorLevel,
                                "Plogi_Reason_Code Invalid %x",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pDevThread->Plogi_Reason_Code,
                                0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,SFEventReset);
    }

}

/*+
  Function: SFActionPlogiRej
   Purpose: PLOGI rejected state. Depending on Plogi_Reason_Code send appropriate
            event.
 Called By: SFEventPlogiAccept.
     Calls: fiTimerStop
            DevEventAL_PA_Self_BAD
            DevEventPlogiFailed
            DevEventDeviceResetDone
            
-*/
/* SFStatePlogiRej                 4 */
extern void SFActionPlogiRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    pSFThread->SF_REJ_RETRY_COUNT +=1;

    fiLogString(thread->hpRoot,
                    "%s AL_PA %X AC %X",
                    "SFActionPlogiRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    CFuncAll_clear( thread->hpRoot ),
                    0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d ALPA %X  CCnt %x DCnt %x",
                    "SFActionPlogiRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);

    switch( pDevThread->Plogi_Reason_Code)
    {
        case  PLOGI_REASON_VERIFY_ALPA:
        case  PLOGI_REASON_HEART_BEAT:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_BAD);
                break;
        case  PLOGI_REASON_DEVICE_LOGIN:
                /* Call this device a target so plogi gets retried */
                pDevThread->Prev_Active_Device_FLAG = agDevSCSITarget;
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPlogiFailed);
                break;
        case  PLOGI_REASON_SOFT_RESET:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDone);
                break;
        case  PLOGI_REASON_DIR_LOGIN:
                CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;
                fiSetEventRecordNull(eventRecord);
                break;
        default:
                fiLogDebugString(thread->hpRoot,
                                SFStateLogErrorLevel,
                                "Plogi_Reason_Code Invalid %x",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pDevThread->Plogi_Reason_Code,
                                0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,SFEventReset);

    }

}

/*+
  Function: SFActionPlogiBadALPA
   Purpose: PLOGI Bad ALPA state. This indcates missing device. Depending on 
            Plogi_Reason_Code send appropriate event.
 Called By: SFEventPlogiAccept.
     Calls: fiTimerStop
            DevEventAL_PA_Self_BAD
            DevEventPlogiFailed
            DevEventDeviceResetDone
            
-*/
/* SFStatePlogiBadALPA             5 */
extern void SFActionPlogiBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X  CCnt %x DCnt %x",
                    "SFActionPlogiBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);

    switch( pDevThread->Plogi_Reason_Code)
    {
        case  PLOGI_REASON_VERIFY_ALPA:
        case  PLOGI_REASON_HEART_BEAT:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_BAD);
                break;
        case  PLOGI_REASON_DEVICE_LOGIN:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPlogiFailed);
                break;
        case  PLOGI_REASON_SOFT_RESET:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevStateDeviceResetDone);
                break;
        case  PLOGI_REASON_DIR_LOGIN:
                CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;
                fiSetEventRecordNull(eventRecord);
                break;
        default:
                fiLogDebugString(thread->hpRoot,
                                SFStateLogErrorLevel,
                                "Plogi_Reason_Code Invalid %x",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pDevThread->Plogi_Reason_Code,
                                0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,SFEventReset);
    }
}

/*+
  Function: SFActionPlogiTimedOut
   Purpose: This indicates problem with device. Depending on Plogi_Reason_Code 
            send appropriate event. This completion state is used if the PLOGI
            was not sent or if SF_EDTOV has expired.
 Called By: SFEventPlogiAccept.
     Calls: fiTimerStop
            DevEventAL_PA_Self_BAD
            DevEventPlogiFailed
            DevEventDeviceResetDone
            
-*/
/* SFStatePlogiTimedOut            6 */
extern void SFActionPlogiTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot        = thread->hpRoot;
    SFThread_t  * pSFThread     = (SFThread_t * )thread;
    DevThread_t * pDevThread    = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogString(thread->hpRoot,
                    "%s  %X AC %X OtherAgilentHBA %X TO's %d",
                    "SFAPTO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    CFuncAll_clear( hpRoot ),
                    pDevThread->OtherAgilentHBA,
                    CThread_ptr(thread->hpRoot)->NumberOfPlogiTimeouts,
                    0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "(%p)In %s - State = %d CState %d ALPA %X CCnt %x DCnt %x CcurSta %d",
                    "SFActionPlogiTimedOut",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->thread_hdr.currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    CThread_ptr(thread->hpRoot)->thread_hdr.currentState,
                    0,0);

    fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "FM Status %08X TL Status %08X Interrupts %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "pCThread->HostCopy_IMQConsIndex %X  IMQProdIndex %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->HostCopy_IMQConsIndex,
                    CThread_ptr(thread->hpRoot)->FuncPtrs.GetIMQProdIndex(hpRoot),
                    0,0,0,0,0,0);


    switch( pDevThread->Plogi_Reason_Code)
    {
        case  PLOGI_REASON_VERIFY_ALPA:
        case  PLOGI_REASON_HEART_BEAT:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAL_PA_Self_BAD);
                break;
        case  PLOGI_REASON_DEVICE_LOGIN:
                if( pDevThread->DevInfo.CurrentAddress.AL_PA  > 0x10)
                {
                    if( CThread_ptr(thread->hpRoot)->NumberOfPlogiTimeouts < MAX_PLOGI_TIMEOUTS )
                    {
                        CThread_ptr(thread->hpRoot)->NumberOfPlogiTimeouts +=1;
                        CThread_ptr(thread->hpRoot)->ReScanForDevices = agTRUE;
                    }
                }
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPlogiFailed);
                break;
        case  PLOGI_REASON_SOFT_RESET:
                fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDone);
                break;
        case  PLOGI_REASON_DIR_LOGIN:
                CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;
                fiSetEventRecordNull(eventRecord);
                break;
        default:
                fiLogDebugString(thread->hpRoot,
                                SFStateLogErrorLevel,
                                "Plogi_Reason_Code Invalid %x",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pDevThread->Plogi_Reason_Code,
                                0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,SFEventReset);
    }

}

/*+
  Function: SFActionDoPrli
   Purpose: Does PRLI. Terminating State.
 Called By: SFEventDoPrli.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInPRLI
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventPrliTimedOut
-*/
/* SFStateDoPrli                   7 */
extern void SFActionDoPrli( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    os_bit32 SFS_Len = 0;

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevelOne,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x Cthread State %x",
                    "SFActionDoPrli",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->SFpollingCount,pDevThread->pollingCount,
                    pCThread->thread_hdr.currentState,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogConsoleLevelOne,
                    "ERQ Producer %X ERQ_Consumer_Index %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index),
                    osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index),
                    0,0,0,0,0);

    if( pSFThread->SF_REJ_RETRY_COUNT )
    {
        fiLogString(thread->hpRoot,
                        "%s  %X Retry %d Dev %x AC %d",
                        "SFActionDoPrli",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        pSFThread->SF_REJ_RETRY_COUNT,
                        pDevThread->PRLI_rejected,
                        CFuncAll_clear( hpRoot ),0,0,0,0);
    }

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {
        pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "Do Prli ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }


    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {
        fiSetEventRecordNull(eventRecord);

        WaitForERQ(hpRoot );
        SFS_Len = fiFillInPRLI( pSFThread );
        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );
        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPrliTimedOut;

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );
#ifndef OSLayer_Stub
        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
        fiSetEventRecord(eventRecord,thread,SFEventPrliAccept);
#endif  /* OSLayer_Stub */

    }
    else
    {

         fiLogDebugString(hpRoot ,
                        SFStateLogErrorLevel,
                        "%s Queues_Frozen - AL_PA %X FM Status %08X TL Status %08X CState %d",
                        "SFActionDoPrli",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0);

        fiLogDebugString(hpRoot,
                        SFStateLogErrorLevel,
                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        0,0);

        fiSetEventRecord(eventRecord,thread,SFEventPrliTimedOut);
    }

}

/*+
  Function: SFActionPrliAccept
   Purpose: PRLI success state. Device will be added to active list.
 Called By: SFEventPrliAccept.
     Calls: fiTimerStop
            DevEventPrliSuccess
-*/
/* SFStatePrliAccept               8 */
extern void SFActionPrliAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x",
                    "SFActionPrliAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);


    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPrliSuccess);

}

/*+
  Function: SFActionPrliRej
   Purpose: PRLI rejected state. If we get rejected retry upto FC_MAX_PRLI_REJECT_RETRY
            times.
 Called By: SFEventPrliRej.
     Calls: fiTimerStop
            SFEventDoPrli
            DevEventPrliFailed
-*/
/* SFStatePrliRej                  9 */
extern void SFActionPrliRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t  * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );
    /*+ Check This DRL Make sure reason code is updated in all ELS cases -*/

    fiLogString(thread->hpRoot,
                    "%s AL_PA %X AC %X",
                    "SFActionPrliRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    CFuncAll_clear( thread->hpRoot ),
                    0,0,0,0,0,0);


    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x RtryCnt %d",
                    "SFActionPrliRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    pSFThread->SF_REJ_RETRY_COUNT,
                    0,0,0);

    pSFThread->SF_REJ_RETRY_COUNT +=1;

    if(! pDevThread->PRLI_rejected || ! CFuncAll_clear( thread->hpRoot ) )
    {
        fiLogString(thread->hpRoot,
                        "%s  %X Retry %d Dev %x AC %d",
                        "SFActionPrliRej",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        pSFThread->SF_REJ_RETRY_COUNT,
                        pDevThread->PRLI_rejected,
                        CFuncAll_clear( thread->hpRoot ),
                        0,0,0,0);
        if( pSFThread->SF_REJ_RETRY_COUNT > FC_MAX_PRLI_REJECT_RETRY )
        {
            pDevThread->PRLI_rejected = agTRUE;
        }
        fiSetEventRecord(eventRecord,thread,SFEventDoPrli);
    }
    else
    {
        fiLogString(thread->hpRoot,
                        "A %s  %X Retry %d Dev %x",
                        "SFActionPrliRej",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        pSFThread->SF_REJ_RETRY_COUNT,
                        pDevThread->PRLI_rejected,
                        CFuncAll_clear( thread->hpRoot ),
                        0,0,0,0);
        if( pSFThread->SF_REJ_RETRY_COUNT < FC_MAX_PRLI_REJECT_RETRY )
        {
            fiSetEventRecord(eventRecord,thread,SFEventDoPrli);
        }
        else
        {
            fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPrliFailed);
        }
    }
}

/*+
  Function: SFActionPrliBadALPA
   Purpose: If we get a bad ALPA here its a qute trick since it takes microseconds
            from PLOGI to now. Device has failed.
 Called By: SFEventPrliBadALPA.
     Calls: fiTimerStop
            DevEventPrliFailed
-*/
/* SFStatePrliBadAlpa              10 */
extern void SFActionPrliBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogString(thread->hpRoot,
                    "%s  %X",
                    "SFActionPrliBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x",
                    "SFActionPrliBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPrliFailed);

}

/*+
  Function: SFActionPrliTimedOut
   Purpose: PRLI timeout state. If we get timed out retry upto FC_MAX_PRLI_REJECT_RETRY
            times.
 Called By: SFEventPrliTimedOut.
     Calls: fiTimerStop
            SFEventDoPrli
            DevEventPrliFailed
-*/
/* SFStatePrliTimedOut             11 */
extern void SFActionPrliTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot        = thread->hpRoot;
    SFThread_t * pSFThread   = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogString(thread->hpRoot,
                    "%s  %X AC %X",
                    "SFActionPrliTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    CFuncAll_clear( hpRoot ),0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d ALPA %X CCnt %x DCnt %x CcurSta %d RtryCnt %d",
                    "SFActionPrliTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    CThread_ptr(hpRoot)->thread_hdr.currentState,
                    pSFThread->SF_REJ_RETRY_COUNT,
                    0,0);

    fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "FM Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    pSFThread->SF_REJ_RETRY_COUNT +=1;
    if(pSFThread->SF_REJ_RETRY_COUNT > FC_MAX_PRLI_REJECT_RETRY || ! CFuncAll_clear( thread->hpRoot ) )
    {
        fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventPrliFailed);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventDoPrli);
    }

}

/*+
  Function: SFActionDoFlogi
   Purpose: Does FLOGI. Terminating State. Set MYID register to enable area and domain use
            by channel.
 Called By: SFEventDoFlogi.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInFLOGI
            SF_IRB_Init
            osChipIOUpWriteBit32
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventFlogiTimedOut
-*/
/* SFStateDoFlogi                  12 */
extern void SFActionDoFlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot    = thread->hpRoot;
    CThread_t   * CThread  = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread = (SFThread_t * )thread;
    os_bit32      SFS_Len   =0;

    WaitForERQ(hpRoot );

    SFS_Len = fiFillInFLOGI( pSFThread );

    CThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, FC_Well_Known_Port_ID_Fabric_F_Port,IRB_DCM);

    fiSetEventRecordNull(eventRecord);

    if (! CThread->InitAsNport)
    {
        CThread->ChanInfo.CurrentAddress.Domain = 0;
        CThread->ChanInfo.CurrentAddress.Area   = 1;
        /* Chip Bug:  Must have non-zero Domain||Area to force FLOGI to AL_PA '00' */
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, (fiComputeCThread_S_ID(CThread) ));
    }

#ifndef OSLayer_Stub
    CThread->SFpollingCount++;
    CThread->FLOGI_pollingCount++;
    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_FLOGI_TOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventFlogiTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    ROLL(CThread->HostCopy_ERQProdIndex,
            CThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,CThread,thread,DoFuncSfCmnd);

#endif  /* OSLayer_Stub */

    fiLogDebugString(hpRoot ,
                    CStateLogConsoleERROR,
                    "Out %s - State = %d fiComputeCThread_S_ID %08X",
                    "SFActionDoFlogi",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeCThread_S_ID(CThread),
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionFlogiAccept
   Purpose: FLOGI  success state. Use Name server behavior. CActionDoFlogi detects 
            this state. fiLinkSvcProcess_FLOGI_Response_xxxCard processes this condition.
 Called By: SFEventFlogiAccept.
     Calls: fiTimerStop
-*/
/* SFStateFlogiAccept              13 */
extern void SFActionFlogiAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    if(CThread_ptr(thread->hpRoot)->FLOGI_pollingCount) CThread_ptr(thread->hpRoot)->FLOGI_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionFlogiAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);
}

/*+
  Function: SFActionFlogiRej
   Purpose: FLOGI  Rejected state.If we get rejected  switch did not "like" 
            some of our FLOGI parameters.CActionDoFlogi detects and adjusts 
            parameters acordingly
 Called By: SFEventFlogiRej
     Calls: fiTimerStop
-*/
/* SFStateFlogiRej                 14 */
extern void SFActionFlogiRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    if(CThread_ptr(thread->hpRoot)->FLOGI_pollingCount) CThread_ptr(thread->hpRoot)->FLOGI_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionFlogiRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionFlogiBadALPA
   Purpose: FLOGI  failed state. If we get Bad ALPA channel uses LOOP behavior.
 Called By: SFEventFlogiBadALPA.
     Calls: fiTimerStop
-*/
/* SFStateFlogiBadALPA             15 */
extern void SFActionFlogiBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    fiSetEventRecordNull(eventRecord);

    fiTimerStop(&pSFThread->Timer_Request );

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    if(CThread_ptr(thread->hpRoot)->FLOGI_pollingCount) CThread_ptr(thread->hpRoot)->FLOGI_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionFlogiBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionFlogiTimedOut
   Purpose: FLOGI in unknown state. If we get here retry is our only option.
 Called By: SFEventFlogiTimedOut.
     Calls: fiTimerStop
-*/
/* SFStateFlogiTimedOut            16 */
extern void SFActionFlogiTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    if(CThread_ptr(thread->hpRoot)->FLOGI_pollingCount) CThread_ptr(thread->hpRoot)->FLOGI_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionFlogiTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

}

/*+
  Function: SFActionDoLogo
   Purpose: Does LOGO. Terminating State.
 Called By: SFEventDoLogo.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInLOGO
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventLogoTimedOut
-*/
/* SFStateDoLogo                  17 */
extern void SFActionDoLogo( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    DevThread_t *   pDevThread  = pSFThread->parent.Device;
    os_bit32 SFS_Len =0;

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionDoLogo",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,pDevThread->pollingCount,0,0,0,0,0);

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);

        WaitForERQ(hpRoot );

        SFS_Len = fiFillInLOGO( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventLogoTimedOut;

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {

         fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "Logo CFunc_Queues_Frozen  Wrong LD %x IR %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    0,0, 0,0,0,0);

        fiSetEventRecord(eventRecord,thread,SFEventLogoTimedOut);
    }
}

/*+
  Function: SFActionLogoAccept
   Purpose: LOGO succeded. 
 Called By: SFEventLogoAccept.
     Calls: fiTimerStop
            DevEventLoggedOut
-*/
/* SFStateLogoAccept              18 */
extern void SFActionLogoAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionLogoAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventLoggedOut);

}

/*+
  Function: SFActionLogoRej
   Purpose: LOGO failed but we were not logged in OK. 
 Called By: SFEventLogoRej.
     Calls: fiTimerStop
            DevEventLoggedOut
-*/
/* SFStateLogoRej                 19 */
extern void SFActionLogoRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionLogoRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventLoggedOut);

}

/*+
  Function: SFActionLogoBadALPA
   Purpose: LOGO failed but device is gone OK. 
 Called By: SFEventLogoBadALPA.
     Calls: fiTimerStop
            DevEventLoggedOut
-*/
/* SFStateLogoBadALPA             20 */
extern void SFActionLogoBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionLogoBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);


    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventLoggedOut);

}

/*+
  Function: SFActionLogoTimedOut
   Purpose: LOGO failed but assume device is gone. 
 Called By: SFEventLogoBadALPA.
     Calls: fiTimerStop
            DevEventLoggedOut
-*/
/* SFStateLogoTimedOut            21 */
extern void SFActionLogoTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    /*+ Check This DRL possible problem in this case -*/
    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionLogoTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->LOOP_DOWN,
                    CThread_ptr(thread->hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(thread->hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(thread->hpRoot)->ERQ_FROZEN,
                    CThread_ptr(thread->hpRoot)->FCP_FROZEN,
                    CThread_ptr(thread->hpRoot)->ProcessingIMQ,
                    0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventLoggedOut);

}

/*+
  Function: SFActionDoPrlo
   Purpose: Does PRLO. Terminating State.
 Called By: None.
     Calls: WaitForERQ
            fiFillInPRLI
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoPrlo                   22 */
extern void SFActionDoPrlo( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    os_bit32 SFS_Len =0;
    /*+ Check This DRL incomplete  -*/
    WaitForERQ(hpRoot );
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);
    /* fiFillInPRLO( pSFThread ); */

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionDoPrlo",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,pDevThread->pollingCount,0,0,0,0,0);

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPrloTimedOut;


    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionPrloAccept
   Purpose: PRLO success. Not used.
 Called By: None.
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePrloAccept               23 */
extern void SFActionPrloAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPrloAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);


    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPrloRej
   Purpose: PRLO failed. Not used.
 Called By: None.
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePrloRej                  24 */
extern void SFActionPrloRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPrloRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);


    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPrloBadALPA
   Purpose: PRLO failed. Not used.
 Called By: None.
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePrloBadALPA              25 */
extern void SFActionPrloBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPrloBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPrloTimedOut
   Purpose: PRLO failed. Not used.
 Called By: None.
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePrloTimedOut             26 */
extern void SFActionPrloTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPrloTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionDoAdisc
   Purpose: Does ADISC. Terminating State.
 Called By: SFEventDoAdisc.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInAdisc
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventAdiscTimedOut
-*/
/* SFStateDoAdisc                  27 */
extern void SFActionDoAdisc( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    os_bit32 SFS_Len =0;

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    fiLogDebugString(hpRoot ,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionDoAdisc",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,pDevThread->pollingCount,0,0,0,0,0);



    if( CFuncAll_clear( hpRoot ) )
    {
        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        SFS_Len =fiFillInADISC( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventAdiscTimedOut;

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );
#ifndef OSLayer_Stub

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
        fiSetEventRecord(eventRecord,thread,SFEventAdiscAccept);
#endif /* OSLayer_Stub */

    }

    else
    {
         fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "Adisc CFunc_Queues_Frozen  Wrong LD %x IR %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    0,0, 0,0,0,0);

        fiSetEventRecord(eventRecord,thread,SFEventAdiscTimedOut);
    }

}

/*+
  Function: SFActionAdiscAccept
   Purpose: ADISC succeseful. Device address verified
 Called By: SFEventAdiscAccept.
     Calls: fiTimerStop
            DevEventAdiscDone_OK
-*/
/* SFStateAdiscAccept              28 */
extern void SFActionAdiscAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionAdiscAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAdiscDone_OK);
}

/*+
  Function: SFActionAdiscRej
   Purpose: ADISC failed. Device address is valid but login required.
            This will occur if to much time has elasped from link event 
            to ADISC attempt.
 Called By: SFEventAdiscRej.
     Calls: fiTimerStop
            DevEventAdiscDone_FAIL_ReLogin
-*/
/* SFStateAdiscRej                 29 */
extern void SFActionAdiscRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x X_ID %X",
                    "SFActionAdiscRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    pSFThread->X_ID,
                    0,0,0,0);



    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAdiscDone_FAIL_ReLogin);
}

/*+
  Function: SFActionAdiscBadALPA
   Purpose: ADISC failed. Device address is no longer valid.
 Called By: SFEventAdiscBadALPA.
     Calls: fiTimerStop
            DevEventAdiscDone_FAIL_No_Device
-*/
/* SFStateAdiscBadALPA             30 */
extern void SFActionAdiscBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionAdiscBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAdiscDone_FAIL_No_Device);

}

/*+
  Function: SFActionAdiscTimedOut
   Purpose: ADISC failed. Device address is treated as if it is no longer valid.
 Called By: SFEventAdiscTimedOut.
     Calls: fiTimerStop
            DevEventAdiscDone_FAIL_No_Device
-*/
/* SFStateAdiscTimedOut            31 */
extern void SFActionAdiscTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d SFcnt %x DCnt %x ACnt X_ID %X",
                    "SFActionAdiscTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    CThread_ptr(thread->hpRoot)->ADISC_pollingCount,
                    pSFThread->X_ID,
                    0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventAdiscDone_FAIL_No_Device);
}

/*+
  Function: SFActionDoPdisc
   Purpose: Should do pdisc. Terminating State.
 Called By: None.
     Calls: WaitForERQ
            fiFillInLOGO
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventLogoTimedOut
-*/
/* SFStateDoPdisc                  32 */
extern void SFActionDoPdisc( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;
    os_bit32 SFS_Len =0;


    WaitForERQ(hpRoot );
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);
    /* fiFillInPDISC( pSFThread ); */

    pCThread = CThread_ptr(hpRoot );

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    fiLogDebugString( hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionDoPdisc",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,pDevThread->pollingCount,0,0,0,0,0);

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPdiscTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionPdiscAccept
   Purpose: Pdisc successfull. 
 Called By: SFEventPdiscAccept
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePdiscAccept              33 */
extern void SFActionPdiscAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogConsoleLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPdiscAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPdiscRej
   Purpose: Pdisc failed. 
 Called By: SFEventPdiscRej
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePdiscRej                 34 */
extern void SFActionPdiscRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );


    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPdiscRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPdiscBadALPA
   Purpose: Pdisc failed. 
 Called By: SFEventPdiscBadALPA
     Calls: fiTimerStop
            SFEventReset
-*/
/* SFStatePdiscBadALPA             35 */
extern void SFActionPdiscBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x DCnt %x",
                    "SFActionPdiscBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionPdiscTimedOut
   Purpose: Pdisc failed. 
 Called By: SFEventPdiscBadTimedOut
     Calls: SFEventReset
-*/
/* SFStatePdiscTimedOut            36 */
extern void SFActionPdiscTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPdiscTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,SFEventReset);
}

/*+
  Function: SFActionDoAbort
   Purpose: Does ABTS. Terminating State. Aborts the Parent threads X_ID. Abort
            is used to discontue X_ID proccessing.
 Called By: SFEventDoAbort.
     Calls: CFuncAll_clear
            WaitForERQ
            fiFillInABTS
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventAbortTimedOut
-*/
/* SFStateDoAbort                  37 */
extern void SFActionDoAbort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot    = thread->hpRoot;
    CThread_t       * pCThread  = CThread_ptr(hpRoot);
    SFThread_t      * pSFThread = (SFThread_t * )thread;
    os_bit32 SFS_Len               = 0;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogConsoleLevelOne,
                      "In %s - State = %d (%p)",
                      "SFActionDoAbort",(char *)agNULL,
                      pSFThread,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    WaitForERQ(hpRoot );

    SFS_Len = fiFillInABTS( pSFThread );

    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pSFThread->parent.CDB->Device),IRB_DCM);

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventAbortTimedOut;

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );
#ifndef OSLayer_Stub

    ROLL(pCThread->HostCopy_ERQProdIndex,
        pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
    fiSetEventRecord(eventRecord,thread,SFEventAbortAccept);
#endif /* OSLayer_Stub */

    fiLogDebugString(thread->hpRoot,
                  SFStateLogConsoleLevelOne,
                  "Started  %s - State = %d (%p) Class %x Type %x State %x",
                  "SFActionDoAbort",(char *)agNULL,
                  pSFThread,(void *)agNULL,
                  (os_bit32)thread->currentState,
                  (os_bit32)pSFThread->SF_CMND_Class,
                  (os_bit32)pSFThread->SF_CMND_Type,
                  (os_bit32)pSFThread->SF_CMND_State,
                  0,0,0,0);
}

/*+
  Function: SFActionAbortAccept
   Purpose: ABTS successful. The device has aknowledged the X_ID as
            1) Known to the device.
            2) All further proccessing of X_ID is stopped
 Called By: SFEventAbortAccept.
     Calls: fiTimerStop
            CDBEventIoAbort
-*/
/* SFStateAbortAccept              38 */
extern void SFActionAbortAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t      * pSFThread     = (SFThread_t * )thread;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )pSFThread->parent.CDB;

    fiTimerStop(&pSFThread->Timer_Request );
    if( pCDBThread->CompletionStatus == osIOInvalid)
    {
        pCDBThread->CompletionStatus = osIOAborted;
    }

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d (%p) X_ID %X CDBState %d",
                      "SFActionAbortAccept",(char *)agNULL,
                      thread,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      pCDBThread->X_ID,
                      pCDBThread->thread_hdr.currentState,
                      0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventIoAbort);
}

/*+
  Function: SFActionAbortRej
   Purpose: ABTS failed. The device has denies knowledged of the X_ID.
 Called By: SFEventAbortRej.
     Calls: fiTimerStop
            CDBEventIoAbort
-*/
/* SFStateAbortRej                 39 */
extern void SFActionAbortRej( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t      * pSFThread     = (SFThread_t * )thread;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )pSFThread->parent.CDB;

    fiTimerStop(&pSFThread->Timer_Request );
    if( pCDBThread->CompletionStatus == osIOInvalid)
    {
        pCDBThread->CompletionStatus = osIOAbortFailed;
    }

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionAbortRej",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);
    /*
    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEvent_Abort_Rejected);
    */
    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventIoAbort);
}

/*+
  Function: SFActionAbortBadALPA
   Purpose: ABTS failed. The device is gone.
 Called By: SFEventAbortBadALPA.
     Calls: fiTimerStop
            CDBEventIoAbort
-*/
/* SFStateAbortBadALPA             40 */
extern void SFActionAbortBadALPA( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t      * pSFThread     = (SFThread_t * )thread;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )pSFThread->parent.CDB;

    if( pCDBThread->CompletionStatus == osIOInvalid)
    {
        pCDBThread->CompletionStatus = osIOAbortFailed;
    }
    fiTimerStop(&pSFThread->Timer_Request );
    /*+ Check This DRL If we get bad alpa device is gone -*/
    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionAbortBadALPA",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventIoAbort);

}

/*+
  Function: SFActionAbortTimedOut
   Purpose: ABTS failed. The exchange has problems.
 Called By: SFEventAbortTimedOut.
     Calls: fiTimerStop
            CDBEventIoAbort
-*/
/* SFStateAbortTimedOut            41 */
extern void SFActionAbortTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t * )pSFThread->parent.CDB;

    if( pCDBThread->CompletionStatus == osIOInvalid)
    {
        pCDBThread->CompletionStatus = osIOAbortFailed;
    }
    /*+ Check This DRL is this the right thing to do ? -*/
    fiLogDebugString(thread->hpRoot,
                        SFStateLogErrorLevel,
                        "In %s - State = %d X_ID %X",
                        "SFActionAbortTimedOut",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                       (os_bit32)thread->currentState,
                        pCDBThread->X_ID,
                        0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventIoAbort);

}

/*+
  Function: SFActionDoResetDevice
   Purpose: Does Task Management Reset for device. Terminating State.
 Called By: SFEventDoResetDevice.
     Calls: WaitForERQ
            fiFillInTargetReset
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventResetDeviceTimedOut
-*/
/* SFStateDoResetDevice                  42 */
extern void SFActionDoResetDevice( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    DevThread_t *   pDevThread  = pSFThread->parent.Device;
    os_bit32           RD_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d CCnt %x DCnt %x DCur %d",
                        "SFActionDoResetDevice",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->SFpollingCount,
                        pDevThread->pollingCount,
                        pDevThread->thread_hdr.currentState,
                        0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }

    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        RD_Len = fiFillInTargetReset(pSFThread);
        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, RD_Len, fiComputeDevThread_D_ID(pSFThread->parent.Device),IRB_DCM);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventResetDeviceTimedOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV / 2 );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

#ifndef OSLayer_Stub

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#else /* OSLayer_Stub */
        fiSetEventRecord(eventRecord,thread,SFEventResetDeviceAccept);
#endif /* OSLayer_Stub */

    }
    else
    {

         fiLogDebugString(hpRoot ,
                        SFStateLogErrorLevel,
                        "%s Queues_Frozen - AL_PA %X FM Status %08X TL Status %08X CState %d",
                        "SFActionDoResetDevice",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0);

        fiLogDebugString(hpRoot,
                        SFStateLogErrorLevel,
                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        0,0);

        fiSetEventRecord(eventRecord,thread,SFEventResetDeviceTimedOut);
    }
}

/*+
  Function: SFActionResetDeviceAccept
   Purpose: Task Management Reset successfull. 
 Called By: SFEventResetDeviceAccept.
     Calls: fiTimerStop
            DevEventDeviceResetDone
-*/
/* SFActionResetDeviceAccept              43 */
extern void SFActionResetDeviceAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogConsoleLevelOne,
                      "In %s - State = %d",
                      "SFActionResetDeviceAccept",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDone);
}

/*+
  Function: SFActionResetDeviceRej
   Purpose: Task Management Reset failed. 
 Called By: SFEventResetDeviceRej.
     Calls: fiTimerStop
            DevEventDeviceResetDoneFail
-*/
/* SFStateResetDeviceRej                 44 */
extern void SFActionResetDeviceRej( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionResetDeviceRej",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDoneFail);
}

/*+
  Function: SFActionResetDeviceBadALPA
   Purpose: Task Management Reset failed. Device is gone. 
 Called By: SFEventResetDeviceRej.
     Calls: fiTimerStop
            DevEventDeviceResetDoneFail
-*/
/* SFStateResetDeviceBadALPA             45 */
extern void SFActionResetDeviceBadALPA( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionResetDeviceBadALPA",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDoneFail);
}

/*+
  Function: SFActionResetDeviceTimedOut
   Purpose: Task Management Reset failed. Exchange had problems. 
 Called By: SFEventResetDeviceTimedOut.
     Calls: fiTimerStop
            DevEventDeviceResetDoneFail
-*/
/* SFStateResetDeviceTimedOut            46 */
extern void SFActionResetDeviceTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    DevThread_t * pDevThread = pSFThread->parent.Device;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    pDevThread->pollingCount--;
    /*+ Check This DRL if we get here did reset happen or not ? -*/
    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionResetDeviceTimedOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pDevThread->thread_hdr,DevEventDeviceResetDoneFail);

}

/*+
  Function: SFActionDoLS_RJT
   Purpose: Does Link services reject. Terminating State.
 Called By: SFEventDoResetDevice.
     Calls: WaitForERQ
            fiFillInLS_RJT
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventLS_RJT_Done
-*/
/* SFStateActionDoLS_RJT                  47 */
extern void SFActionDoLS_RJT( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d ",
                        "SFActionDoLS_RJT",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }

    pCThread->SFpollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInLS_RJT(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT),
                             FC_ELS_LS_RJT_Command_Not_Supported | FC_ELS_LS_RJT_Request_Not_Supported
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventLS_RJT_Done);
    }
}

/*+
  Function: SFActionLS_RJT_Done
   Purpose: Link services reject done. Target mode command
 Called By: SFEventLS_RJT_Done.
     Calls: TgtEventPLOGI_RJT_ReplyDone
-*/
/* SFStateLS_RJT_Done              48 */
extern void SFActionLS_RJT_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionLS_RJT_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPLOGI_RJT_ReplyDone);
}

/*+
  Function: SFActionDoPlogiAccept
   Purpose: Does PLOGI accept. If another device does PLOGI accept it. 
            Terminating State.
 Called By: TgtEventPLOGI_ACC_Reply.
     Calls: WaitForERQ
            fiFillInPLOGI_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventPlogiAccept_TimeOut
-*/
/* SFStateDoPlogiAccept   49 */
extern void SFActionDoPlogiAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogErrorLevel,
                        "In %s (%p) - State = %d ",
                        "SFActionDoPlogiAccept",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }


    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInPLOGI_ACC(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT)
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPlogiAccept_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );


        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {

       fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "%s AC %X",
                    "SFEventPlogiAccept_TimeOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CFuncAll_clear( hpRoot ),
                    0,0,0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,SFEventPlogiAccept_TimeOut);

    }
}

/*+
  Function: SFActionPlogiAccept_Done
   Purpose: PLOGI accept done. Target mode command
 Called By: SFEventLS_RJT_Done.
     Calls: fiTimerStop
            TgtEventPLOGI_ACC_ReplyDone
-*/
/* SFStatePlogiAccept_Done              50 */
extern void SFActionPlogiAccept_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPlogiAccept_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPLOGI_ACC_ReplyDone);
}

/*+
  Function: SFActionDoPrliAccept
   Purpose: Does PRLI accept. If another device does PRLI to us accept it. 
            Terminating State.
 Called By: TgtEventPRLI_ACC_Reply.
     Calls: WaitForERQ
            fiFillInPRLI_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventPrliAccept_TimeOut
-*/
/* SFStateDoPrliAccept   51 */
extern void SFActionDoPrliAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d ",
                        "SFActionDoPrliAccept",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }



    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {
        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInPRLI_ACC(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT)
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventPrliAccept_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventPrliAccept_TimeOut);
    }
}

/*+
  Function: SFActionPrliAccept_Done
   Purpose: PRLI accept done. Target mode command
 Called By: SFEventPrliAccept_Done.
     Calls: fiTimerStop
            TgtEventPRLI_ACC_ReplyDone
-*/
/* SFStatePrliAccept_Done              52 */
extern void SFActionPrliAccept_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPrliAccept_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPRLI_ACC_ReplyDone);
}

/*+
  Function: SFActionDoELSAccept
   Purpose: Does generic accept. If another device does ELS to us accept it. 
            Terminating State.
 Called By: TgtActionLOGO_ACC_Reply.
     Calls: WaitForERQ
            fiFillInELS_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventELSAccept_TimeOut
-*/
/* SFStateDoELSAccept   53 */
extern void SFActionDoELSAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogErrorLevel,
                        "In %s (%p) - State = %d ",
                        "SFActionDoELSAccept",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }



    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInELS_ACC(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT)
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventELSAccept_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventELSAccept_TimeOut);
    }
}

/*+
  Function: SFActionELSAccept_Done
   Purpose: Extended link services accept done. Target mode command
 Called By: SFEventELSAccept_Done.
     Calls: fiTimerStop
            TgtEventELS_ACC_ReplyDone
-*/
/* SFStateELSAccept_Done              54 */
extern void SFActionELSAccept_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionELSAccept_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventELS_ACC_ReplyDone);
}

/*+
  Function: SFActionDoFCP_DR_ACC_Reply
   Purpose: Does device reset accept. If another device does device reset accept it. 
            Terminating State.
 Called By: None.
     Calls: WaitForERQ
            fiFillInADISC_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventFCP_DR_ACC_Reply_TimeOut
-*/
/* SFStateDoFCP_DR_ACC_Reply   55 */
extern void SFActionDoFCP_DR_ACC_Reply( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32           Cmd_Len      = 0;
    FC_FCP_RSP_Payload_t  Payload;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d ",
                        "SFActionDoFCP_DR_ACC_Reply",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    Payload.Reserved_Bit32_0 = 0;
    Payload.Reserved_Bit32_1 = 0;
    Payload.FCP_RESID        = 0;
    Payload.FCP_SNS_LEN      = 0;
    Payload.FCP_RSP_LEN      = 0;

    Payload.FCP_STATUS.Reserved_Bit8_0 = 0;
    Payload.FCP_STATUS.Reserved_Bit8_1 = 0;
    Payload.FCP_STATUS.ValidityStatusIndicators = 0;
    Payload.FCP_STATUS.SCSI_status_byte = 0;

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }


    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInFCP_RSP_IU(pSFThread,
                                pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                                ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT),
                                FC_FCP_RSP_Payload_t_SIZE,
                                &Payload
                           );


        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventFCP_DR_ACC_Reply_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventFCP_DR_ACC_Reply_TimeOut);

    }
}

/*+
  Function: SFActionFCP_DR_ACC_Reply_Done
   Purpose: Task management reset accept reply done. Target mode command
 Called By: SFEventFCP_DR_ACC_Reply_Done.
     Calls: fiTimerStop
            TgtEventFCP_DR_ACC_ReplyDone
-*/
/* SFStateFCP_DR_ACC_Reply_Done         56             */
extern void SFActionFCP_DR_ACC_Reply_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogConsoleLevelOne,
                      "In %s - State = %d",
                      "SFActionFCP_DR_ACC_Reply_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventFCP_DR_ACC_ReplyDone);
}

/*+
  Function: SFActionLS_RJT_TimeOut
   Purpose: Link services reject timedout. Target mode command
 Called By: SFEventPlogiAccept_TimeOut.
     Calls: TgtEventPLOGI_RJT_ReplyDone
-*/
/*  SFStateLS_RJT_TimeOut       57       */
extern void SFActionLS_RJT_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionLS_RJT_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);
    /*+ Check This DRL is this right ? -*/
    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPLOGI_RJT_ReplyDone);
}

/*+
  Function: SFActionPlogiAccept_TimeOut
   Purpose: PLOGI accept timedout. Target mode command
 Called By: SFEventPlogiAccept_TimeOut.
     Calls: TgtEventPLOGI_ACC_ReplyDone
-*/
/*  SFStatePlogiAccept_TimeOut           58               */
extern void SFActionPlogiAccept_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPlogiAccept_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPLOGI_ACC_ReplyDone);
}

/*+
  Function: SFActionPrliAccept_TimeOut
   Purpose: PRLI accept timedout. Target mode command
 Called By: SFEventPrliAccept_TimeOut.
     Calls: TgtEventPRLI_ACC_ReplyDone
-*/
/* SFStatePrliAccept_TimeOut            59              */
extern void SFActionPrliAccept_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionPrliAccept_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventPRLI_ACC_ReplyDone);
}

/*+
  Function: SFActionELSAccept_TimeOut
   Purpose: Extended link services accept timedout. Target mode command
 Called By: SFEventPlogiAccept_TimeOut.
     Calls: TgtEventPRLI_ACC_ReplyDone
-*/
/*  SFStateELSAccept_TimeOut            60             */
extern void SFActionELSAccept_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionELSAccept_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventELS_ACC_ReplyDone);
}

/*+
  Function: SFActionFCP_DR_ACC_Reply_TimeOut
   Purpose: Task manangment reset timedout. Target mode command
 Called By: SFEventFCP_DR_ACC_Accept_TimeOut.
     Calls: TgtEventFCP_DR_ACC_ReplyDone
-*/
/*  SFStateFCP_DR_ACC_Reply_TimeOut      61              */
extern void SFActionFCP_DR_ACC_Reply_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    TgtThread_t * pTgtThread =  pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionFCP_DR_ACC_Reply_TimeOut",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventFCP_DR_ACC_ReplyDone);
}

#ifdef NAME_SERVICES
/*+
  Function: SFActionDoRFT_ID
   Purpose: Does Name server Register FC-4 types (RFT_ID). Terminating State.
 Called By: SFEventDoRFT_ID.
     Calls: WaitForERQ
            fiFillInRFT_ID
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventRFT_IDTimedOut
-*/
/* SFStateDoRFT_ID                  62 */
extern void SFActionDoRFT_ID( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot    = thread->hpRoot;
    CThread_t   * pCThread  = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread = (SFThread_t * )thread;
    os_bit32         SFS_Len   =0;

    WaitForERQ(hpRoot );

    SFS_Len = fiFillInRFT_ID( pSFThread );

#ifdef BROCADE_BUG
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, 0xfffc41,IRB_DCM);
#else /* BROCADE_BUG */
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, FC_Well_Known_Port_ID_Directory_Server,IRB_DCM);
#endif /* BROCADE_BUG */
    fiSetEventRecordNull(eventRecord);

#ifndef OSLayer_Stub
    pCThread->SFpollingCount++;

    pCThread->Fabric_pollingCount++;

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventRFT_IDTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#endif  /* OSLayer_Stub */
    fiLogDebugString(hpRoot ,
                    CStateLogConsoleERROR,
                    "In %s - State = %d fiComputeCThread_S_ID %08X",
                    "SFActionDoRFT_ID",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    (fiComputeCThread_S_ID(pCThread) | 0x100),0,0,0,0,0,0);
}

/*+
  Function: SFActionRFT_IDAccept
   Purpose: Name server Register FC-4 types (RFT_ID) successfull
            CActionDoRFT_ID checks the completions state of the action.
 Called By: SFStateRFT_IDAccept
     Calls: fiTimerStop
-*/
/* SFStateRFT_IDAccept              63 */
extern void SFActionRFT_IDAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionRFT_IDAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionRFT_IDRej
   Purpose: Name server Register FC-4 types (RFT_ID) rejected.
            CActionDoRFT_ID checks the completions state of the action.
 Called By: SFStateRFT_IDRej
     Calls: fiTimerStop
-*/
/* SFStateRFT_IDRej                 64 */
extern void SFActionRFT_IDRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionRFT_IDRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionRFT_IDBadALPA
   Purpose: Name server Register FC-4 types (RFT_ID) failed because switch disapeared.
            CActionDoRFT_ID checks the completions state of the action.
 Called By: SFStateRFT_IDBadALPA
     Calls: fiTimerStop
-*/
/* SFStateRFT_IDBadALPA             65 */
extern void SFActionRFT_IDBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    fiTimerStop(&pSFThread->Timer_Request );

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionRFT_IDBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionRFT_IDTimedOut
   Purpose: Name server Register FC-4 types (RFT_ID) failed.
            CActionDoRFT_ID checks the completions state of the action.
 Called By: SFStateRFT_IDBadALPA
     Calls: 
-*/
/* SFStateRFT_IDTimedOut            66 */
extern void SFActionRFT_IDTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionRFT_IDTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

}

/*+
  Function: SFActionDoGID_FT
   Purpose: Does Get Port Identifiers (GID_FT). Terminating State. 
 Called By: SFEventDoGID_FT in CActionDoGID_FT
     Calls: WaitForERQ
            fiFillInGID_FT
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoGID_ID                  67 */
extern void SFActionDoGID_FT( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot    = thread->hpRoot;
    CThread_t   * pCThread  = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread = (SFThread_t * )thread;
    os_bit32         SFS_Len   =0;


    WaitForERQ(hpRoot );

    SFS_Len = fiFillInGID_FT( pSFThread );

#ifdef BROCADE_BUG
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, 0xfffc41,IRB_DCM);
#else /* BROCADE_BUG */
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, FC_Well_Known_Port_ID_Directory_Server,IRB_DCM);
#endif /* BROCADE_BUG */

    fiSetEventRecordNull(eventRecord);
#ifndef OSLayer_Stub
    pCThread->SFpollingCount++;
    pCThread->Fabric_pollingCount++;

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventGID_FTTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#endif /* OSLayer_Stub */
    fiLogDebugString(hpRoot ,
                    CStateLogConsoleERROR,
                    "In %s - State = %d fiComputeCThread_S_ID %08X",
                    "SFActionDoGID_FT",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    (fiComputeCThread_S_ID(pCThread) | 0x100),0,0,0,0,0,0);
}

/*+
  Function: SFActionGID_FTAccept
   Purpose: Get Port Identifiers (GID_FT) successful. CActionDoGID_FT checks
            state to determine next action
 Called By: SFEventGID_FTAccept.
     Calls: fiTimerStop
-*/
/* SFStateGID_FTAccept              68 */
extern void SFActionGID_FTAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionGID_FTAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionGID_FTRej
   Purpose: Get Port Identifiers (GID_FT) failed. CActionDoGID_FT checks
            state to determine next action
 Called By: SFEventGID_FTRej.
     Calls: fiTimerStop
-*/
/* SFStateGID_FTRej                 69 */
extern void SFActionGID_FTRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionGID_FTRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionGID_FTBadALPA
   Purpose: Get Port Identifiers (GID_FT) failed. CActionDoGID_FT checks
            state to determine next action
 Called By: SFEventGID_FTBadALPA.
     Calls: fiTimerStop
-*/
/* SFStateGID_FTBadALPA             70 */
extern void SFActionGID_FTBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    fiTimerStop(&pSFThread->Timer_Request );

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionGID_FTBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionGID_FTTimedOut
   Purpose: Get Port Identifiers (GID_FT) failed. CActionDoGID_FT checks
            state to determine next action
 Called By: SFEventGID_FTTimedOut
     Calls: fiTimerStop
-*/
/* SFStateGID_FTTimedOut            71 */
extern void SFActionGID_FTTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionGID_FTTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

}

/*+
  Function: SFActionDoSCR
   Purpose: Does Name server State Change Register (SCR). Terminating State.
            CActionDoSCR starts this proccess.
 Called By: SFEventDoSCR.
     Calls: WaitForERQ
            fiFillInSCR
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventRFT_IDTimedOut
-*/
/* SFStateDoSCR              72 */
extern void SFActionDoSCR( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t     * hpRoot    = thread->hpRoot;
    CThread_t    * pCThread  = CThread_ptr(hpRoot);
    SFThread_t   * pSFThread = (SFThread_t * )thread;
    os_bit32      SFS_Len    = 0;


    WaitForERQ(hpRoot );

    SFS_Len = fiFillInSCR( pSFThread );

    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, FC_Well_Known_Port_ID_Fabric_Controller,IRB_DCM);

    fiSetEventRecordNull(eventRecord);
#ifndef OSLayer_Stub
    pCThread->SFpollingCount++;
    pCThread->Fabric_pollingCount++;
    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventSCRTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

#endif /* OSLayer_Stub */


    fiLogDebugString(hpRoot ,
                    CStateLogConsoleERROR,
                    "In %s - State = %d fiComputeCThread_S_ID %08X",
                    "SFActionDoSCR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    (fiComputeCThread_S_ID(pCThread) | 0x100),0,0,0,0,0,0);



}

/*+
  Function: SFActionSCRAccept
   Purpose: Name server State Change Register (SCR) was successful. 
            CActionDoSCR evalutes the state to determine the next action.
 Called By: SFEventSCRAccept
     Calls: fiTimerStop
-*/
/* SFStateSCRAccept              73 */
extern void SFActionSCRAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionSCRAccept",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionSCRRej
   Purpose: Name server State Change Register (SCR) failed. 
            CActionDoSCR evalutes the state to determine the next action.
 Called By: SFEventSCRRej
     Calls: fiTimerStop
-*/
/* SFStateSCRRej                 74 */
extern void SFActionSCRRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionSCRRej",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: SFActionSCRBadALPA
   Purpose: Name server State Change Register (SCR) failed. 
            CActionDoSCR evalutes the state to determine the next action.
 Called By: SFEventSCRBadALPA
     Calls: fiTimerStop
-*/
/* SFStateSCRBadALPA             75 */
extern void SFActionSCRBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;

    fiSetEventRecordNull(eventRecord);

    fiTimerStop(&pSFThread->Timer_Request );

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d CCnt %x",
                    "SFActionSCRBadALPA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->SFpollingCount,
                    0,0,0,0,0,0);

}

/*+
  Function: SFActionSCRTimedOut
   Purpose: Name server State Change Register (SCR) failed. 
            CActionDoSCR evalutes the state to determine the next action.
 Called By: SFEventSCRTimedOut
     Calls: 
-*/
/* SFStateSCRTimedOut            76 */
extern void SFActionSCRTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{

    fiSetEventRecordNull(eventRecord);

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    CThread_ptr(thread->hpRoot)->Fabric_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionSCRTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

}

#endif /* NAME_SERVICES */

/****************** FC Tape ******************************************/

/*+
  Function: SFActionDoSRR
   Purpose: Does Sequence Retransmission Request (SRR). FC Tape. Terminating State.
 Called By: SFEventDoSRR.
     Calls: WaitForERQ
            fiFillInSRR
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoSRR                  77 */
extern void SFActionDoSRR( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;
/*    FCHS_t      * FCHS       =  pCDBThread->FCP_CMND_Ptr;
*/
    os_bit32 SFS_Len = 0;
    os_bit32 RO=0;
/* Gets rejected    os_bit32 R_CTL= FC_Frame_Header_R_CTL_Lo_Solicited_Data >> FCHS_R_CTL_SHIFT;
*/
/*
    os_bit32 R_CTL= FC_Frame_Header_R_CTL_Lo_Solicited_Data >> FCHS_R_CTL_SHIFT;  Freaks out !

    os_bit32 R_CTL=  FC_Frame_Header_R_CTL_Lo_Unsolicited_Data >> FCHS_R_CTL_SHIFT; Rejected !

    os_bit32 R_CTL= FC_Frame_Header_R_CTL_Lo_Unsolicited_Command >> FCHS_R_CTL_SHIFT; Rejected !

    os_bit32 R_CTL= FC_Frame_Header_R_CTL_Lo_Solicited_Data >> FCHS_R_CTL_SHIFT;  Send data back !

 FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame                   0x00000000
 FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame                 0x20000000
 FC_Frame_Header_R_CTL_Hi_FC_4_Link_Data_Frame                     0x30000000
 FC_Frame_Header_R_CTL_Hi_Video_Data_Frame                         0x40000000
 FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame                    0x80000000 fc4link data reply - rej !
 FC_Frame_Header_R_CTL_Hi_Link_Control_Frame                       0xC0000000



 FC_Frame_Header_R_CTL_Lo_Uncategorized_Information                0x00000000
 FC_Frame_Header_R_CTL_Lo_Solicited_Data                           0x01000000 Send data back ! DATA
 FC_Frame_Header_R_CTL_Lo_Unsolicited_Control                      0x02000000 Rejected !
 FC_Frame_Header_R_CTL_Lo_Solicited_Control                        0x03000000
 FC_Frame_Header_R_CTL_Lo_Unsolicited_Data                         0x04000000 Send data back !
 FC_Frame_Header_R_CTL_Lo_Data_Descriptor                          0x05000000 XFER RDY
 FC_Frame_Header_R_CTL_Lo_Unsolicited_Command                      0x06000000 Rejected !
 FC_Frame_Header_R_CTL_Lo_Command_Status                           0x07000000 RSP


*/

    os_bit32 OXID;
    os_bit32 RXID;
    os_bit32 R_CTL;

    R_CTL = FC_Frame_Header_R_CTL_Lo_Data_Descriptor | FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame;

    R_CTL >>= FCHS_R_CTL_SHIFT;


    OXID = (X_ID_t)(((pCDBThread->X_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RXID = (X_ID_t)(((pCDBThread->X_ID & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);


    SFS_Len = fiFillInSRR( pSFThread, OXID, RXID, RO, R_CTL);

    WaitForERQ(hpRoot );
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pDevThread),IRB_DCM);

    /* OXID, RXID, Relative offset and R_CTL all need to be passed through the SF Thread or associated CDBThread
      For now, this is going to be all zeros */


    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    fiSetEventRecordNull(eventRecord);

    ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X SF XID %08X",
                    "SFActionDoSRR",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    pSFThread->X_ID,
                    0,0,0);

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventSRRTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );
    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

}

/*+
  Function: SFActionSRRAccept
   Purpose: Sequence Retransmission Request (SRR) successful. FC Tape.
 Called By: SFEventSRRAccept.
     Calls: fiTimerStop
            CDBEventSendSRR_Success
-*/
/* SFStateSRRAccept              78 */
extern void SFActionSRRAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X",
                    "SFActionSRRAccept",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendSRR_Success);

}

/*+
  Function: SFActionSRRRej
   Purpose: Sequence Retransmission Request (SRR) failed. FC Tape.
 Called By: SFEventSRRRej.
     Calls: fiTimerStop
            CDBEventSendSRR_Fail
-*/
/* SFStateSRRRej                 79 */
extern void SFActionSRRRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X",
                    "SFActionSRRRej",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendSRR_Fail);
}

/*+
  Function: SFActionSRRBadALPA
   Purpose: Sequence Retransmission Request (SRR) failed. FC Tape.
 Called By: SFEventSRRBadALPA.
     Calls: fiTimerStop
            CDBEventSendSRR_Fail
-*/
/* SFStateSRRBadALPA             80 */
extern void SFActionSRRBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X",
                    "SFActionSRRBadALPA",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendSRR_Fail);
}

/*+
  Function: SFActionSRRTimedOut
   Purpose: Sequence Retransmission Request (SRR) failed. FC Tape.
 Called By: SFEventSRRRej.
     Calls: fiTimerStop
            CDBEventSendSRR_Fail
-*/
/* SFStateSRRTimedOut            81 */
extern void SFActionSRRTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t * hpRoot = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    SFThread_t * pSFThread = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionSRRTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendSRR_Fail);
}

/*+
  Function: SFActionDoREC
   Purpose: Does Read Exchange Concise. Terminating State. FC Tape
            REC is done for IOs on FC Tape device that have timed out. 
 Called By: SFEventDoREC.
     Calls: WaitForERQ
            fiFillInREC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoREC                  82 */
extern void SFActionDoREC( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;
    os_bit32 SFS_Len = 0;
    os_bit32 OXID;
    os_bit32 RXID;

    OXID = (X_ID_t)(((pCDBThread->X_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RXID = (X_ID_t)(((pCDBThread->X_ID & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    /* OXID and RXID Should be gotten from the CDBThread */
    SFS_Len = fiFillInREC( pSFThread, OXID, RXID );

    WaitForERQ(hpRoot );
    pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeDevThread_D_ID(pDevThread),IRB_DCM);


    pCThread->SFpollingCount++;
    pDevThread->pollingCount++;

    fiLogDebugString( hpRoot,
                    SFStateLogErrorLevel,
                    "In(%p) %s - State = %d CCnt %x DCnt %x XID %08X SF XID %08X",
                    "SFActionDoREC",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    pCDBThread->X_ID,
                    pSFThread->X_ID,
                    0,0,0);

    fiSetEventRecordNull(eventRecord);

    ROLL(pCThread->HostCopy_ERQProdIndex,
        pCThread->Calculation.MemoryLayout.ERQ.elements);

    fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_RECTOV );

    pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
    pSFThread->Timer_Request.eventRecord_to_send.event = SFEventRECTimedOut;

    fiTimerStart( hpRoot,&pSFThread->Timer_Request );
    /* Big_Endian_code */
    SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);

}

/*+
  Function: SFStateRECAccept
   Purpose: Read Exchange Concise successful. FC Tape
            If the REC is accepted the device has aknowledged the X_ID is
            currently active.
 Called By: SFEventRECAccept.
     Calls: fiTimerStop
            CDBEventSendREC_Success
-*/
/* SFStateRECAccept              83 */
extern void SFActionRECAccept( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In (%p) %s - State = %d CCnt %x DCnt %x",
                    "SFActionRECAccept",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendREC_Success);
}

/*+
  Function: SFActionRECRej
   Purpose: Read Exchange Concise failed. FC Tape
            If the REC is rejected the device does not aknowledged the X_ID is
            currently active.
 Called By: SFEventRECRej.
     Calls: fiTimerStop
            CDBEventSendREC_Fail
-*/
/* SFStateRECRej                 84 */
extern void SFActionRECRej( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );


    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In (%p) %s - State = %d CCnt %x DCnt %x",
                    "SFActionRECRej",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);


    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendREC_Fail);
}

/*+
  Function: SFActionRECBadALPA
   Purpose: Read Exchange Concise failed. FC Tape
            The device is missing.
 Called By: SFEventRECBadALPA.
     Calls: fiTimerStop
            CDBEventSendREC_Fail
-*/
/* SFStateRECBadALPA             85 */
extern void SFActionRECBadALPA( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;
    /*+ Check This DRL if the device is gone is this the right thing to do ? -*/
    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In (%p) %s - State = %d CCnt %x DCnt %x",
                    "SFActionRECBadALPA",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendREC_Fail);
}

/*+
  Function: SFActionRECTimedOut
   Purpose: Read Exchange Concise failed. FC Tape
            This exchange has a problem.
 Called By: SFEventRECTimedOut.
     Calls: fiTimerStop
            CDBEventSendREC_Fail
-*/
/* SFStateRECTimedOut            86 */
extern void SFActionRECTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     = thread->hpRoot;
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    SFThread_t  * pSFThread  = (SFThread_t * )thread;
    CDBThread_t * pCDBThread = (CDBThread_t *)pSFThread->parent.CDB;
    DevThread_t * pDevThread = (DevThread_t *)pCDBThread->Device;

    pCThread->SFpollingCount--;
    pDevThread->pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In (%p) %s - State = %d CCnt %x DCnt %x",
                    "SFActionRECTimedOut",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->SFpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pCDBThread->thread_hdr,CDBEventSendREC_Fail);
}

/******************End FC Tape ******************************************/

/*+
  Function: SFActionDoADISCAccept
   Purpose: Does ADISC accept. If another device does ADISC accept it. Terminating State.
 Called By: SFEventDoADISCAccept.
     Calls: WaitForERQ
            fiFillInADISC_ACC
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
-*/
/* SFStateDoADISCAccept   87 */
extern void SFActionDoADISCAccept( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot      = thread->hpRoot;
    SFThread_t  * pSFThread   = (SFThread_t * )thread;
    TgtThread_t * pTgtThread  = pSFThread->parent.Target;
    os_bit32      Cmd_Len     = 0;


    fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "In %s (%p) - State = %d ",
                    "SFActionDoADISCAccept",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    if(ERQ_FULL(CThread_ptr(hpRoot)->HostCopy_ERQProdIndex,
                CThread_ptr(hpRoot)->FuncPtrs.GetERQConsIndex(hpRoot ),
                CThread_ptr(hpRoot)->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot ,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->HostCopy_ERQProdIndex,
                    CThread_ptr(hpRoot)->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }

    CThread_ptr(hpRoot)->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInADISC_ACC(pSFThread,
                             pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,
                             ((pTgtThread->TgtCmnd_FCHS.OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT)
                           );

        CThread_ptr(hpRoot)->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFStateADISCAccept_TimeOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(CThread_ptr(hpRoot)->HostCopy_ERQProdIndex,
            CThread_ptr(hpRoot)->Calculation.MemoryLayout.ERQ.elements);

        /* Big_Endian_code */
        SENDIO(hpRoot,CThread_ptr(hpRoot),thread,DoFuncSfCmnd);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventADISCAccept_TimeOut);
    }
}

/*+
  Function: SFActionADISCAccept_Done
   Purpose: ADISC accept was successfull.
 Called By: SFEventADISCAccept_Done.
     Calls: fiTimerStop
            TgtEventADISC_ReplyDone
-*/
/* SFStateADISCAccept_Done              88 */
extern void SFActionADISCAccept_Done( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionELSAccept_Done",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventADISC_ReplyDone);
}

/*+
  Function: SFActionADISCAccept_TimeOut
   Purpose: ADISC accept failed.
 Called By: SFEventADISCAccept_Done.
     Calls: TgtEventADISC_ReplyDone
-*/
/*  SFStateADISCAccept_TimeOut            89 */
extern void SFActionADISCAccept_TimeOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionELSAccept_TimeOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventADISC_ReplyDone);
}

#ifdef _DvrArch_1_30_

/*+
  Function: SFActionDoFarpRequest
   Purpose: Does Fibre Channel Address Resolution Protocol. Terminating State. IP interface
 Called By: fiFillInFARP_REQ_OffCard.
     Calls: WaitForERQ
            SF_IRB_Init
            fiTimerSetDeadlineFromNow
            fiTimerStart
            ROLL
            SENDIO
            SFEventFarpRequestTimedOut
-*/
/* SFStateDoFarp                  90 */
extern void SFActionDoFarpRequest( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t *)thread;
    os_bit32        SFS_Len     = 0;

    fiLogDebugString(hpRoot,
                    PktStateLogConsoleLevel,
                    "In %s - State = %d X_ID %X CCnt %x",
                    "SFActionDoFarpRequest",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pSFThread->X_ID,pCThread->SFpollingCount,0,0,0,0,0);

    pCThread->SFpollingCount++;


    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);

        WaitForERQ(hpRoot );
        /*+ Check This DRL Need function pointer and oncard version -*/
        SFS_Len = fiFillInFARP_REQ_OffCard( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, SFS_Len, fiComputeBroadcast_D_ID(pCThread), IRB_DCM);

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventFarpRequestTimedOut;

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);
    }
    else
    {

         fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "Farp CFunc_Queues_Frozen  Wrong LD %x IR %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    0,0, 0,0,0,0);

         fiSetEventRecord(eventRecord,thread,SFEventFarpRequestTimedOut);
    }
}

/*+
  Function: SFActionFarpRequestDone
   Purpose: Fibre Channel Address Resolution Protocol successful. IP interface
 Called By: fiFillInFARP_REQ_OffCard.
     Calls: fiTimerStop
            PktEventFarpSuccess
-*/
/* SFStateFarpRequestDone                91 */
extern void SFActionFarpRequestDone( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    PktThread_t *   pPktThread  = pSFThread->parent.IPPkt;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;
    fiTimerStop(&pSFThread->Timer_Request );

    fiLogDebugString(thread->hpRoot,
                      SFStateLogErrorLevel,
                      "In %s - State = %d",
                      "SFActionFarpRequestDone",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      (os_bit32)thread->currentState,
                      0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    fiSendEvent(&pPktThread->thread_hdr,PktEventFarpSuccess);
}

/*+
  Function: SFActionFarpRequestTimedOut
   Purpose: Fibre Channel Address Resolution Protocol. IP interface
 Called By: fiFillInFARP_REQ_OffCard.
     Calls: none
-*/
/*  SFStateFarpRequestTimedOut           92 */
extern void SFActionFarpRequestTimedOut( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionFarpRequestTimedOut",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: SFActionDoFarpReply
   Purpose: Reply to external Fibre Channel Address Resolution Protocol. IP interface
 Called By: ?.
     Calls: none
-*/
/*  SFStateDoFarpReply                   93 */
extern void SFActionDoFarpReply( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    *   hpRoot      = thread->hpRoot;
    CThread_t   *   pCThread    = CThread_ptr(hpRoot);
    SFThread_t  *   pSFThread   = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;
    os_bit32        Cmd_Len      = 0;


    fiLogDebugString(thread->hpRoot,
                        SFStateLogConsoleLevelOne,
                        "In %s (%p) - State = %d ",
                        "SFActionDoFarpReply",(char *)agNULL,
                        thread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        0,0,0,0,0,0,0);

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                pCThread->Calculation.MemoryLayout.ERQ.elements ))
    {

        fiLogDebugString(hpRoot,
                    SFStateLogErrorLevel,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(hpRoot ),
                    0,0,0,0,0,0);
    }


    pCThread->SFpollingCount++;

    if( CFuncAll_clear( hpRoot ) )
    {

        fiSetEventRecordNull(eventRecord);
        WaitForERQ(hpRoot );

        Cmd_Len = fiFillInFARP_REPLY_OffCard( pSFThread );

        pCThread->FuncPtrs.SF_IRB_Init(pSFThread, Cmd_Len, pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FCHS_S_ID_MASK,0);

        pSFThread->Timer_Request.eventRecord_to_send.thread= thread;
        pSFThread->Timer_Request.eventRecord_to_send.event = SFEventFarpReplyTimedOut;

        fiTimerSetDeadlineFromNow( hpRoot, &pSFThread->Timer_Request, SF_EDTOV );

        fiTimerStart( hpRoot,&pSFThread->Timer_Request );

        ROLL(pCThread->HostCopy_ERQProdIndex,
            pCThread->Calculation.MemoryLayout.ERQ.elements);

        SENDIO(hpRoot,pCThread,thread,DoFuncSfCmnd);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,SFEventFarpReplyTimedOut);
    }
}

/*+
  Function: SFActionFarpReplyDone
   Purpose: Reply to external Fibre Channel Address Resolution Protocol reply sent. IP interface
 Called By: ?.
     Calls: TgtEventFARP_ReplyDone
-*/
/*  SFStateFarpReplyDone                 94 */
extern void SFActionFarpReplyDone( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    SFThread_t * pSFThread = (SFThread_t * )thread;
    TgtThread_t *   pTgtThread  = pSFThread->parent.Target;

    CThread_ptr(thread->hpRoot)->SFpollingCount--;

    fiLogDebugString(thread->hpRoot,
                    SFStateLogErrorLevel,
                    "In %s - State = %d",
                    "SFActionFarpReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventFARP_ReplyDone);
}

#endif /* _DvrArch_1_30_ was defined */

/*+
  Function: SFFuncIRB_OffCardInit
   Purpose: Initialize off card (system memory) Io request block
 Called By: All sfaction do routines. When system memory is used.
     Calls: none
-*/
void SFFuncIRB_OffCardInit(SFThread_t  * SFThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit)
{
#ifndef __MemMap_Force_On_Card__
    CThread_t                  *CThread = CThread_ptr(SFThread->thread_hdr.hpRoot);
    fiMemMapMemoryDescriptor_t *ERQ     = &(CThread->Calculation.MemoryLayout.ERQ);
    IRB_t                      *pIrb;

    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
    pIrb += CThread->HostCopy_ERQProdIndex;

#ifdef _DvrArch_1_30_
    pIrb->Req_A.Bits__SFS_Len   = SFS_Len | IRB_SFA | DCM_Bit |
            ((D_ID & 0xff) == 0xff ? IRB_BRD : 0);
#else /* _DvrArch_1_30_ was not defined */
    pIrb->Req_A.Bits__SFS_Len   = SFS_Len | IRB_SFA | DCM_Bit;
#endif /* _DvrArch_1_30_ was not defined */
    pIrb->Req_A.SFS_Addr        = SFThread->SF_CMND_Lower32;
    pIrb->Req_A.D_ID             = D_ID << IRB_D_ID_SHIFT;
    pIrb->Req_A.MBZ__SEST_Index__Trans_ID = SFThread->X_ID;
    pIrb->Req_B.Bits__SFS_Len = 0;

/*
    fiLogDebugString(hpRoot,
                      SFStateLogErrorLevel,
                      "\t\t\tIRB %08X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pIrb->Req_A.Bits__SFS_Len,
                      0,0,0,0,0,0,0);
*/
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
  Function: SFFuncIRB_OnCardInit
   Purpose: Initialize on card  Io request block
 Called By: All sfaction do routines when card ram is used.
     Calls: none
-*/
void SFFuncIRB_OnCardInit(SFThread_t  * SFThread, os_bit32 SFS_Len, os_bit32 D_ID, os_bit32 DCM_Bit)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t     * hpRoot = SFThread->thread_hdr.hpRoot;

    CThread_t                  *CThread = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *ERQ     = &(CThread->Calculation.MemoryLayout.ERQ);
    os_bit32                       Irb_offset;

    Irb_offset =   ERQ->addr.CardRam.cardRamOffset;
    Irb_offset += (CThread->HostCopy_ERQProdIndex * sizeof(IRB_t));


    osCardRamWriteBit32(hpRoot,
                        Irb_offset + hpFieldOffset(IRB_t,Req_A.Bits__SFS_Len),
                        SFS_Len | IRB_SFA | DCM_Bit );

    osCardRamWriteBit32(hpRoot,
                        Irb_offset+hpFieldOffset(IRB_t,Req_A.SFS_Addr),
                        SFThread->SF_CMND_Lower32);

    osCardRamWriteBit32(hpRoot,
                        Irb_offset+hpFieldOffset(IRB_t,Req_A.D_ID),
                        D_ID << IRB_D_ID_SHIFT);
    osCardRamWriteBit32(hpRoot,
                        Irb_offset+hpFieldOffset(IRB_t,Req_A.MBZ__SEST_Index__Trans_ID),
                        SFThread->X_ID);
    osCardRamWriteBit32(hpRoot,
                        Irb_offset+hpFieldOffset(IRB_t,Req_B.Bits__SFS_Len),
                        0);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/* void ttttttt(void){} */


#endif /* USESTATEMACROS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\state.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/State.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/30/00 11:31a $ (Last Modified)

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#endif  /* _New_Header_file_Layout_ */

/*+
Function:  fiInstallStateMachine()

Purpose:   Copies State Machine data structure(s) updating the actions
           as requested.

Algorithm: After copying the State Machine data structure(s), the actionUpdate
           array is used to modify any action function pointers based on the
           value of compareBase.  The actionUpdate array contains records which
           contain a value to mask compareBase.  If the masked value matches
           the compareTo value for the record, all instances of the originalAction
           function pointer will be replaced by the replacementAction function
           pointer.

           Note that the originalAction function pointers must be found in the source
           of the State Machine data structure(s), not the copied data structure(s).
           This prevents ambiguities which would result if the replacementAction function
           pointers match any originalAction function pointers.
-*/

#ifndef __State_Force_Static_State_Tables__
void fiInstallStateMachine(
                            stateTransitionMatrix_t *srcStateTransitionMatrix,
                            stateActionScalar_t     *srcStateActionScalar,
                            stateTransitionMatrix_t *dstStateTransitionMatrix,
                            stateActionScalar_t     *dstStateActionScalar,
                            os_bit32                    compareBase,
                            actionUpdate_t           actionUpdate[]
                          )
{
    actionUpdate_t *oneActionUpdate;
    os_bit32           bitMask;
    action_t        originalAction;
    action_t        replacementAction;
    state_t         state;

    *dstStateTransitionMatrix = *srcStateTransitionMatrix;
    *dstStateActionScalar     = *srcStateActionScalar;

    oneActionUpdate = &actionUpdate[0];

    while ((bitMask = oneActionUpdate->bitMask) != 0)
    {
        if ((compareBase & bitMask) == oneActionUpdate->compareTo)
        {
            originalAction    = oneActionUpdate->originalAction;
            replacementAction = oneActionUpdate->replacementAction;

            for (state=0;state<maxStates;state++)
            {
                if (originalAction == srcStateActionScalar->newAction[state])
                {
                    dstStateActionScalar->newAction[state] = replacementAction;
                }
            }
        }

        oneActionUpdate++;
    }
}
#endif /* __State_Force_Static_State_Tables__ was not defined */

/*+
Function:  fiInitializeThread()

Purpose:   Initializes the fi_thread__t data structure to contain hpRoot, the thread
           type and (a) pointer(s) to the State Machine data structure(s).
-*/

void fiInitializeThread(
                         fi_thread__t                *thread,
                         agRoot_t                *hpRoot,
                         threadType_t             threadType,
                         state_t                  initialState,
                         stateTransitionMatrix_t *stateTransitionMatrix,
                         stateActionScalar_t     *stateActionScalar
                       )
{
    thread->hpRoot                = hpRoot;
    thread->threadType            = threadType;
    thread->currentState          = initialState;
    thread->stateTransitionMatrix = stateTransitionMatrix;
    thread->stateActionScalar     = stateActionScalar;
}

/*+
Function:  fiSendEvent()

Purpose:   Sends an event to a thread immediately as well as (recursively) sending
           any event returned via eventRecord from the action routine called.

Algorithm: The current state of the specified thread and the event passed in are used
           to compute a new state for the thread and to fetch a action routine function
           pointer.

           For the Moore State Machine Model, the actions occur in the states.  So, each
           element of the stateTransitionMatrix contains only the newState for the thread.
           The newAction (which corresponds to this newState) is retrieved from the
           stateActionScalar for this thread.

           In the call to the thread's newAction, an eventRecord_t is passed.  This can be
           used by the action routine to pass on an event to the same or a new thread.  By
           "returning" the event to send, recursion of fiSendEvent() is avoided.  This is
           necessary as stack depth is a critically limited resource in some environments.
-*/

void fiSendEvent(
                  fi_thread__t *thread,
                  event_t   event
                )
{
    eventRecord_t nextEventRecord;
    state_t       oldState;
    state_t       newState;
    action_t      newAction;

#ifdef LOG_STATE_TRANSITIONS
    os_bit32         StateInfo = 0;
#endif /* LOG_STATE_TRANSITIONS */

    oldState = thread->currentState;

    newState = thread->stateTransitionMatrix->newState[event][oldState];

    if(newState == 0)
    {
        fiLogString(thread->hpRoot,
                        "SConfused T %d S %d E %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                         (os_bit32)thread->threadType,
                        (os_bit32)oldState,
                        (os_bit32)event,
                        0,0,0,0,0);
    }

#ifndef osLogDebugString
    if (newState == 0)
    {
        fiLogDebugString(
                          thread->hpRoot,
                          fiSendEventErrorLogLevel,
                          "*** fiSendEvent Thread(%p) type %d Confused OldState %d Event %d NewState %d",
                          (char *)agNULL,
                          (char *)agNULL,
                          thread,(void *)agNULL,
                          (os_bit32)thread->threadType,
                          (os_bit32)oldState,
                          (os_bit32)event,
                          (os_bit32)newState,
                          (os_bit32)0,
                          (os_bit32)0,
                          (os_bit32)0,
                          (os_bit32)0
                        );
    }
#endif /* fiLogDebugString was not defined */

    thread->currentState = newState;

    newAction = thread->stateActionScalar->newAction[newState];

#ifndef Performance_Debug
    fiLogDebugString(
                      thread->hpRoot,
                      fiSendEventInfoLogLevel,
                      "fiSendEvent(callEvent): ThreadType = %x Thread = 0x%p Event = %d OldState = %d NewState = %d Action = 0x%p",
                      (char *)agNULL,(char *)agNULL,
                      thread,(void *)newAction,
                      (os_bit32)thread->threadType,
                      (os_bit32)event,
                      (os_bit32)oldState,
                      (os_bit32)newState,
                      (os_bit32)0,
                      (os_bit32)0,
                      (os_bit32)0,
                      (os_bit32)0
                    );
#endif /* Performance_Debug */

#ifdef LOG_STATE_TRANSITIONS
    osLogStateTransition(thread->hpRoot,  LogStateTransition(0, thread->threadType,thread->currentState, event) );
#endif /* LOG_STATE_TRANSITIONS */


    (*newAction)(
                  thread,
                  &nextEventRecord
                );

    while (nextEventRecord.thread != (fi_thread__t *)agNULL)
    {
        oldState = nextEventRecord.thread->currentState;

        newState = nextEventRecord.thread->stateTransitionMatrix->newState[nextEventRecord.event][oldState];

        nextEventRecord.thread->currentState = newState;

        if(newState == 0)
        {
            fiLogString(thread->hpRoot,
                            "NConfused T %d S %d E %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                             (os_bit32)nextEventRecord.thread->threadType,
                            (os_bit32)oldState,
                            (os_bit32)nextEventRecord.event,
                            0,0,0,0,0);
        }

#ifndef fiLogDebugString
        if (newState == 0)
        {
            fiLogDebugString(
                              thread->hpRoot,
                              fiSendEventErrorLogLevel,
                              "fiSendEvent(nextEvent) Thread(%p) type %d Confused OldState %d Event %d NewState %d",
                              (char *)agNULL,(char *)agNULL,
                              nextEventRecord.thread,(void *)agNULL,
                              (os_bit32)nextEventRecord.thread->threadType,
                              (os_bit32)oldState,
                              (os_bit32)nextEventRecord.event,
                              (os_bit32)newState,
                              (os_bit32)0,
		                      (os_bit32)0,
                              (os_bit32)0,
                              (os_bit32)0
                            );
        }
#endif /* fiLogDebugString was not defined */

        newAction = nextEventRecord.thread->stateActionScalar->newAction[newState];

#ifndef Performance_Debug
        fiLogDebugString(
                          thread->hpRoot,
                          fiSendEventInfoLogLevel,
                          "fiSendEvent(nextEvent): ThreadType = %x Thread = 0x%p Event = %d OldState = %d NewState = %d Action = 0x%p",
                          (char *)agNULL,(char *)agNULL,
                          nextEventRecord.thread,(void *)newAction,
                          (os_bit32)nextEventRecord.thread->threadType,
                          (os_bit32)nextEventRecord.event,
                          (os_bit32)oldState,
                          (os_bit32)newState,
	                      (os_bit32)0,
		                  (os_bit32)0,
                          (os_bit32)0,
                          (os_bit32)0
                        );

#endif /* Performance_Debug */

#ifdef LOG_STATE_TRANSITIONS
        osLogStateTransition(thread->hpRoot,  LogStateTransition(agTRUE, nextEventRecord.thread->threadType,nextEventRecord.thread->currentState, nextEventRecord.event) );
#endif /* LOG_STATE_TRANSITIONS */

        (*newAction)(
                      nextEventRecord.thread,
                      &nextEventRecord
                    );
    }
}

/*+
Function:  fiSetEventRecord()

Purpose:   Sets the fields of an eventRecord so that the specified event is
           delivered to the specified thread (presumably) upon return from the
           action routine which called fiSetEventRecord().
-*/

void fiSetEventRecord(
                       eventRecord_t *eventRecord,
                       fi_thread__t      *thread,
                       event_t        event
                     )
{
    eventRecord->thread = thread;
    eventRecord->event  = event;
}

/*+
  Function: State_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/* void State_c(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\timersvc.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/TimerSvc.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:33a  $ (Last Modified)

Purpose:

  This file implements Timer Services for the FC Layer.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/timersvc.h"
#include "../h/cstate.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "timersvc.h"
#include "cstate.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */

void fiTimerSvcInit(
                     agRoot_t *hpRoot
                   )
{
    CThread_t *CThread = CThread_ptr(hpRoot);

    fiLogDebugString(
                        hpRoot,
                        TimerServiceLogErrorLevel,
                        "fiTimerSvcInit",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0
                        );


    CThread->TimeBase.Lo = 0;
    CThread->TimeBase.Hi = 0;

    fiListInitHdr(
                   &(CThread->TimerQ)
                 );

/*
     We need to initialize the list since this is called from CActionInitialize during
     error recovery. We may have to walk the list and initialize all the elements in 
     the list to the sentinel value.

*/
	fiTimerInitializeRequest(&(CThread->Timer_Request));

}

void fiTimerInitializeRequest(
                               fiTimer_Request_t *Timer_Request
                             )
{
    fiListInitElement(
                       &(Timer_Request->TimerQ_Link)
                     );

    Timer_Request->Active = agFALSE;
}

void fiTimerSetDeadlineFromNow(
                                agRoot_t          *hpRoot,
                                fiTimer_Request_t *Timer_Request,
                                os_bit32              From_Now
                              )
{
    fiTime_t *TimeBase = &(CThread_ptr(hpRoot)->TimeBase);
    os_bit32     newLo    = TimeBase->Lo + From_Now;

    Timer_Request->Deadline.Lo = newLo;

    if (newLo < From_Now)
    {
        Timer_Request->Deadline.Hi = TimeBase->Hi + 1;
    }
    else
    {
        Timer_Request->Deadline.Hi = TimeBase->Hi;
    }
}

void fiTimerAddToDeadline(
                           fiTimer_Request_t *Timer_Request,
                           os_bit32              To_Add
                         )
{
    os_bit32 newLo = Timer_Request->Deadline.Lo + To_Add;

    if (newLo < To_Add)
    {
        Timer_Request->Deadline.Hi += 1;
    }
}

void fiTimerStart(
                   agRoot_t          *hpRoot,
                   fiTimer_Request_t *Timer_Request
                 )
{
    CThread_t         *CThread            = CThread_ptr(hpRoot);
    fiList_t          *TimerQ             = &(CThread->TimerQ);
    fiTimer_Request_t *Prev_Timer_Request = (fiTimer_Request_t *)(TimerQ->blink);

    osDebugBreakpoint(
                       hpRoot,
                       ((Timer_Request->Active == agFALSE) ? agFALSE : agTRUE),
                       "fiTimerStart(): Timer_Request->Active != agFALSE"
                     );
    if(Timer_Request->Active )
    { /* Assertion was true  */ 
        return;
    }



    while (   (Prev_Timer_Request != (fiTimer_Request_t *)TimerQ)
           && (   (Prev_Timer_Request->Deadline.Hi > Timer_Request->Deadline.Hi)
               || (   (Prev_Timer_Request->Deadline.Hi == Timer_Request->Deadline.Hi)
                   && (Prev_Timer_Request->Deadline.Lo > Timer_Request->Deadline.Lo))))
    {
        Prev_Timer_Request = (fiTimer_Request_t *)(Prev_Timer_Request->TimerQ_Link.blink);
    }

    fiLogDebugString(
              hpRoot,
              TimerServiceLogInfoLevel,
              "Adding Timer Request Thread = %p  Event  %x",
              (char *)agNULL,(char *)agNULL,
              Timer_Request->eventRecord_to_send.thread,(void *)agNULL,
              (os_bit32)Timer_Request->eventRecord_to_send.event,
              0,0,0,0,0,0,0
            );

    Timer_Request->Active = agTRUE;

    fiListEnqueueAtHead(
                         Timer_Request,
                         Prev_Timer_Request
                       );
}

void fiTimerStop(
                  fiTimer_Request_t *Timer_Request
                )
{
    osDebugBreakpoint(
                       (agRoot_t *)agNULL,
                       ((Timer_Request->Active == agTRUE) ? agFALSE : agTRUE),
                       "fiTimerStop(): Timer_Request->Active != agTRUE"
                     );

    fiLogDebugString(
                      (agRoot_t *)agNULL,
                      TimerServiceLogInfoLevel,
                      "Stop Timer Request Thread = %p  Event  %x",
                      (char *)agNULL,(char *)agNULL,
                      Timer_Request->eventRecord_to_send.thread,(void *)agNULL,
                      (os_bit32)Timer_Request->eventRecord_to_send.event,
                      0,0,0,0,0,0,0
                    );

    fiListDequeueThis(
                       &(Timer_Request->TimerQ_Link)
                     );

    Timer_Request->Active = agFALSE;
}

void fiTimerTick(
                  agRoot_t *hpRoot,
                  os_bit32     tickDelta
                )
{
    CThread_t         *CThread;
    fiList_t          *TimerQ;
    fiTimer_Request_t *Timer_Request;
    os_bit32              oldLo;
    os_bit32              newLo;

    CThread = CThread_ptr(hpRoot);

    /* Increment TimeBase */

    oldLo = CThread->TimeBase.Lo;
    newLo = oldLo + tickDelta;

    CThread->TimeBase.Lo = newLo;

    if (newLo < oldLo)
    {
        CThread->TimeBase.Hi += 1;
    }

    CFuncGreenLed(hpRoot, CThread->Green_LED_State);

    CThread->Green_LED_State = ! CThread->Green_LED_State;

    fiLogDebugString(
                      hpRoot,
                      TimerServiceLogConsoleLevel,
                      "fcTimerTick TimeBase.Hi = 0x%08X TimeBase.Lo = 0x%08X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      CThread->TimeBase.Hi,
                      CThread->TimeBase.Lo,
                      0,0,0,0,0,0
                    );

    /* Deliver Timer Events for Requests which are past their Deadlines */

    TimerQ        = &(CThread->TimerQ);
    Timer_Request = (fiTimer_Request_t *)(TimerQ->flink);

    while (   (Timer_Request != (fiTimer_Request_t *)TimerQ)
           && (   (Timer_Request->Deadline.Hi < CThread->TimeBase.Hi)
               || (   (Timer_Request->Deadline.Hi == CThread->TimeBase.Hi)
                   && (Timer_Request->Deadline.Lo <= CThread->TimeBase.Lo))))
    {

         fiLogDebugString(
                      hpRoot,
                      TimerServiceLogErrorLevel,
                      "Timer Popped Thread = %p  Event %d",
                      (char *)agNULL,(char *)agNULL,
                      Timer_Request->eventRecord_to_send.thread,(void *)agNULL,
                      (os_bit32)Timer_Request->eventRecord_to_send.event,
                      0,0,0,0,0,0,0
                    );


        fiListDequeueThis(
                           Timer_Request
                         );

        Timer_Request->Active = agFALSE;

        fiSendEvent(
                     Timer_Request->eventRecord_to_send.thread,
                     Timer_Request->eventRecord_to_send.event
                   );

        Timer_Request = (fiTimer_Request_t *)(TimerQ->flink);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\tlstruct.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/TLStruct.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:34a  $ (Last Modified)

Purpose:

  This file validates the typedef declarations in ../H/TLStruct.H

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/tlstruct.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "tlstruct.h"
#endif  /* _New_Header_file_Layout_ */

/*+
Function:  TLStructASSERTs()

Purpose:   Returns the number of TLStruct.H typedefs which are not the correct size.

Algorithm: Each typedef in TLStruct.H is checked for having the correct size.  While
           this property doesn't guarantee correct packing of the fields within, it
           is a pretty good indicator that the typedef has the intended layout.

           The total number of typedefs which are not of correct size is returned from
           this function.  Hence, if the return value is non-zero, the declarations
           can not be trusted to match the TachyonTL specification.
-*/

os_bit32 TLStructASSERTs(
                       void
                     )
{
    os_bit32 to_return = 0;

    if ( sizeof(ChipConfig_t)                   !=                   ChipConfig_t_SIZE ) to_return++;
    if ( sizeof(ChipIOLo_t)                     !=                     ChipIOLo_t_SIZE ) to_return++;
    if ( sizeof(ChipIOUp_t)                     !=                     ChipIOUp_t_SIZE ) to_return++;
    if ( sizeof(ChipMem_t)                      !=                      ChipMem_t_SIZE ) to_return++;
    if ( sizeof(ERQProdIndex_t)                 !=                 ERQProdIndex_t_SIZE ) to_return++;
    if ( sizeof(ERQConsIndex_t)                 !=                 ERQConsIndex_t_SIZE ) to_return++;
    if ( sizeof(IMQProdIndex_t)                 !=                 IMQProdIndex_t_SIZE ) to_return++;
    if ( sizeof(IMQConsIndex_t)                 !=                 IMQConsIndex_t_SIZE ) to_return++;
    if ( sizeof(SFQProdIndex_t)                 !=                 SFQProdIndex_t_SIZE ) to_return++;
    if ( sizeof(SFQConsIndex_t)                 !=                 SFQConsIndex_t_SIZE ) to_return++;
    if ( sizeof(FCHS_t)                         !=                         FCHS_t_SIZE ) to_return++;
    if ( sizeof(X_ID_t)                         !=                         X_ID_t_SIZE ) to_return++;
    if ( sizeof(SG_Element_t)                   !=                   SG_Element_t_SIZE ) to_return++;
    if ( sizeof(USE_t)                          !=                          USE_t_SIZE ) to_return++;
    if ( sizeof(IWE_t)                          !=                          IWE_t_SIZE ) to_return++;
    if ( sizeof(IRE_t)                          !=                          IRE_t_SIZE ) to_return++;
    if ( sizeof(TWE_t)                          !=                          TWE_t_SIZE ) to_return++;
    if ( sizeof(TRE_t)                          !=                          TRE_t_SIZE ) to_return++;
    if ( sizeof(SEST_t)                         !=                         SEST_t_SIZE ) to_return++;
    if ( sizeof(IRB_Part_t)                     !=                     IRB_Part_t_SIZE ) to_return++;
    if ( sizeof(IRB_t)                          !=                          IRB_t_SIZE ) to_return++;
    if ( sizeof(CM_Unknown_t)                   !=                   CM_Unknown_t_SIZE ) to_return++;
    if ( sizeof(CM_Outbound_t)                  !=                  CM_Outbound_t_SIZE ) to_return++;
    if ( sizeof(CM_Error_Idle_t)                !=                CM_Error_Idle_t_SIZE ) to_return++;
    if ( sizeof(CM_Inbound_t)                   !=                   CM_Inbound_t_SIZE ) to_return++;
    if ( sizeof(CM_ERQ_Frozen_t)                !=                CM_ERQ_Frozen_t_SIZE ) to_return++;
    if ( sizeof(CM_FCP_Assists_Frozen_t)        !=        CM_FCP_Assists_Frozen_t_SIZE ) to_return++;
    if ( sizeof(CM_Frame_Manager_t)             !=             CM_Frame_Manager_t_SIZE ) to_return++;
    if ( sizeof(CM_Inbound_FCP_Exchange_t)      !=      CM_Inbound_FCP_Exchange_t_SIZE ) to_return++;
    if ( sizeof(CM_Class_2_Frame_Header_t)      !=      CM_Class_2_Frame_Header_t_SIZE ) to_return++;
    if ( sizeof(CM_Class_2_Sequence_Received_t) != CM_Class_2_Sequence_Received_t_SIZE ) to_return++;
    if ( sizeof(Completion_Message_t)           !=           Completion_Message_t_SIZE ) to_return++;

    return to_return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\tgtstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/TGTSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/30/00 12:20p $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/cdbState.C

--*/

#ifndef __TgtState_H__
#define __TgtState_H__

#define  TgtStateConfused                      0
#define  TgtStateIdle                          1
#define  TgtStateIncoming                      2
#define  TgtStatePLOGI_RJT_Reply               3
#define  TgtStatePLOGI_RJT_ReplyDone           4

#define  TgtStatePLOGI_ACC_Reply               5
#define  TgtStatePLOGI_ACC_ReplyDone           6

#define  TgtStatePRLI_ACC_Reply                7
#define  TgtStatePRLI_ACC_ReplyDone            8

#define  TgtStateLOGO_ACC_Reply                9
#define  TgtStateELS_ACC_ReplyDone            10

#define  TgtStateFCP_DR_ACC_Reply             11
#define  TgtStateFCP_DR_ACC_ReplyDone         12
#define  TgtStateELSAcc                       13
#define  TgtStateADISCAcc_Reply               14
#define  TgtStateADISCAcc_ReplyDone           15

#define  TgtStateFARP_Reply                   16
#define  TgtStateFARP_ReplyDone               17

#define  TgtStatePRLOAcc_Reply                18
#define  TgtStatePRLOAcc_ReplyDone            19

#define  TgtStateMAXState                     TgtStatePRLOAcc_ReplyDone 


#define  TgtEventConfused                      0
#define  TgtEventIdle                          1
#define  TgtEventIncoming                      2
#define  TgtEventPLOGI_RJT_Reply               3
#define  TgtEventPLOGI_RJT_ReplyDone           4

#define  TgtEventPLOGI_ACC_Reply               5
#define  TgtEventPLOGI_ACC_ReplyDone           6

#define  TgtEventPRLI_ACC_Reply                7
#define  TgtEventPRLI_ACC_ReplyDone            8

#define  TgtEventLOGO_ACC_Reply                9
#define  TgtEventELS_ACC_ReplyDone             10

#define  TgtEventFCP_DR_ACC_Reply              11
#define  TgtEventFCP_DR_ACC_ReplyDone          12

#define  TgtEventELSAcc                        13

#define  TgtEventADISC_Reply                   14
#define  TgtEventADISC_ReplyDone               15

#define  TgtEventFARP_Reply                    16
#define  TgtEventFARP_ReplyDone                17
#define  TgtEventPRLO_Reply                    18
#define  TgtEventPRLO_ReplyDone                19

#define  TgtEventMAXEvent                      TgtEventPRLO_ReplyDone


STATE_PROTO(TgtActionConfused          );
STATE_PROTO(TgtActionIdle              );
STATE_PROTO(TgtActionIncoming          );

STATE_PROTO(TgtActionPLOGI_RJT_Reply       );
STATE_PROTO(TgtActionPLOGI_RJT_ReplyDone   );

STATE_PROTO(TgtActionPLOGI_ACC_Reply    );
STATE_PROTO(TgtActionPLOGI_ACC_ReplyDone);

STATE_PROTO(TgtActionPRLI_ACC_Reply     );
STATE_PROTO(TgtActionPRLI_ACC_ReplyDone );

STATE_PROTO(TgtActionLOGO_ACC_Reply    );
STATE_PROTO(TgtActionELS_ACC_ReplyDone);

STATE_PROTO(TgtActionFCP_DR_ACC_Reply     );
STATE_PROTO(TgtActionFCP_DR_ACC_ReplyDone );

STATE_PROTO(TgtActionELSAcc);
STATE_PROTO(TgtActionFCP_DR_ACC_ReplyDone);
STATE_PROTO(TgtActionFCP_DR_ACC_Reply);
STATE_PROTO(TgtActionELS_ACC_ReplyDone);
STATE_PROTO(TgtActionLOGO_ACC_Reply);
STATE_PROTO(TgtActionPRLI_ACC_ReplyDone);
STATE_PROTO(TgtActionPRLI_ACC_Reply);
STATE_PROTO(TgtActionPLOGI_ACC_ReplyDone);
STATE_PROTO(TgtActionPLOGI_ACC_Reply);
STATE_PROTO(TgtActionPLOGI_RJT_ReplyDone);
STATE_PROTO(TgtActionPLOGI_RJT_Reply);

STATE_PROTO(TgtActionADISCAcc_Reply);
STATE_PROTO(TgtActionADISCAcc_ReplyDone);

STATE_PROTO(TgtActionFARP_Reply);
STATE_PROTO(TgtActionFARP_ReplyDone);

STATE_PROTO(TgtActionPRLOAcc_Reply);
STATE_PROTO(TgtActionPRLOAcc_ReplyDone);


extern stateTransitionMatrix_t TgtStateTransitionMatrix;
extern stateActionScalar_t TgtStateActionScalar;

#ifdef USESTATEMACROS

#define TgtSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                   \
    CThread_t  * pCThread=CThread_ptr(hpRoot);          \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;    \
    DevThread_t * pDevThread=pCDBThread->Device;        \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (void * )agNULL,(void * )agNULL,  \
                      (char *)agNULL,(char *)agNULL,        \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\

#ifdef TestTgtStateMachine
char * TgtStateString[]=
{
    "TgtStateConfused             ",
    "TgtStateIdle                 ",
    "TgtStateIncoming             ",
    "TgtStatePLOGI_RJT_Reply      ",
    "TgtStatePLOGI_RJT_ReplyDone  ",
    "TgtStatePLOGI_ACC_Reply      ",
    "TgtStatePLOGI_ACC_ReplyDone  ",
    "TgtStatePRLI_ACC_Reply       ",
    "TgtStatePRLI_ACC_ReplyDone   ",
    "TgtStateLOGO_ACC_Reply       ",
    "TgtStateELS_ACC_ReplyDone    ",
    "TgtStateFCP_DR_ACC_Reply     ",
    "TgtStateFCP_DR_ACC_ReplyDone ",
    "TgtStateELSAcc               ",
    "TgtStateADISCAcc_Reply       ",
    "TgtStateADISCAcc_ReplyDone   ",
    agNULL
};

char * TgtEventString[]=
{

    "TgtEventConfused             ",
    "TgtEventIdle                 ",
    "TgtEventIncoming             ",
    "TgtEventPLOGI_RJT_Reply      ",
    "TgtEventPLOGI_RJT_ReplyDone  ",
    "TgtEventPLOGI_ACC_Reply      ",
    "TgtEventPLOGI_ACC_ReplyDone  ",
    "TgtEventPRLI_ACC_Reply       ",
    "TgtEventPRLI_ACC_ReplyDone   ",
    "TgtEventLOGO_ACC_Reply       ",
    "TgtEventELS_ACC_ReplyDone    ",
    "TgtEventFCP_DR_ACC_Reply     ",
    "TgtEventFCP_DR_ACC_ReplyDone ",
    "TgtEventELSAcc               ",
    "TgtEventADISC_Reply          ",
    "TgtEventADISC_ReplyDone      ",
     agNULL
};

char * TgtActionString[]=
{
    "TgtActionConfused             ",
    "TgtActionIdle                 ",
    "TgtActionIncoming             ",
    "TgtActionPLOGI_RJT_Reply      ",
    "TgtActionPLOGI_RJT_ReplyDone  ",
    "TgtActionPLOGI_ACC_Reply      ",
    "TgtActionPLOGI_ACC_ReplyDone  ",
    "TgtActionPRLI_ACC_Reply       ",
    "TgtActionPRLI_ACC_ReplyDone   ",
    "TgtActionLOGO_ACC_Reply       ",
    "TgtActionELS_ACC_ReplyDone    ",
    "TgtActionFCP_DR_ACC_Reply     ",
    "TgtActionFCP_DR_ACC_ReplyDone ",
    "TgtActionELSAcc               ",
    "TgtActionADISCAcc_Reply       ",
    "TgtActionADISCAcc_ReplyDone   ",
    agNULL
};


#endif /* TestTgtStateMachine */


#endif /* USESTATEMACROS */

#endif /*  __TgtState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\tlstruct.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/TLStruct.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 9/11/00 6:18p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures specific to TachyonTL/TS

Reference Documents:

  Tachyon TL/TS User's Manual - Revision 6.0 - September 1998
  Tachyon XL User Manual - Revision 4.0 - September 1998

--*/

#ifndef __TLStruct_H__
#define __TLStruct_H__


/* _TACHYON_XL is defined to enable XL2 specific features/changes */
 
#define	__TACHYON_XL
#define	__TACHYON_XL2


/*+
PCI Configuration Space Registers
-*/

typedef struct ChipConfig_s
               ChipConfig_t;

#define ChipConfig_t_SIZE                                  0x00000100

struct ChipConfig_s {
                      os_bit32 DEVID_VENDID;
                      os_bit32 CFGSTAT_CFGCMD;
                      os_bit32 CLSCODE_REVID;
                      os_bit32 BIST_HDRTYPE_LATTIM_CLSIZE;
                      os_bit8  Reserved_1[0x13-0x10+1];
                      os_bit32 IOBASEL;
                      os_bit32 IOBASEU;
                      os_bit32 MEMBASE;
                      os_bit32 RAMBASE;
                      os_bit32 SROMBASE;
                      os_bit8  Reserved_2[0x2B-0x28+1];
                      os_bit32 SVID;
                      os_bit32 ROMBASE;
                      os_bit32 Reserved_3__CAP_PTR;
                      os_bit8  Reserved_4[0x3B-0x38+1];
                      os_bit32 MAXLAT_MINGNT_INTPIN_INTLINE;
                      os_bit32 PCIMCTR__ROMCTR__Reserved_5__Reserved_6;
                      os_bit32 INTSTAT_INTEN_INTPEND_SOFTRST;
                      os_bit8  Reserved_7[0x4F-0x48+1];
                      os_bit32 PMC__CAP_NEXT_PTR__CAP_ID;
                      os_bit32 Reserved_8__PMCSR;
                      os_bit8  Reserved_9[0xFF-0x58+1];
                    };

#define ChipConfig_DEVID_VENDID                            hpFieldOffset(ChipConfig_t,DEVID_VENDID)

#define ChipConfig_DEVID_MASK                              0xFFFF0000
#define ChipConfig_DEVID_TachyonTL                         0x10280000
#define ChipConfig_DEVID_TachyonTL33                       ChipConfig_DEVID_TachyonTL
#define ChipConfig_DEVID_TachyonTS                         0x102A0000
#define ChipConfig_DEVID_TachyonTL66                       ChipConfig_DEVID_TachyonTS
#define ChipConfig_DEVID_TachyonXL                         0x10290000
#define ChipConfig_DEVID_TachyonT2                         ChipConfig_DEVID_TachyonXL
#define ChipConfig_DEVID_TachyonXL2                        0x10290000

#define ChipConfig_VENDID_MASK                             0x0000FFFF
#define ChipConfig_VENDID_Agilent_Technologies             0x000015BC
#define ChipConfig_VENDID_Hewlett_Packard                  0x0000103C

#define ChipConfig_CFGSTAT_CFGCMD                          hpFieldOffset(ChipConfig_t,CFGSTAT_CFGCMD)

#define ChipConfig_CFGSTAT_MASK                            0xFFFF0000
#define ChipConfig_CFGSTAT_PER                             0x80000000
#define ChipConfig_CFGSTAT_SSE                             0x40000000
#define ChipConfig_CFGSTAT_RMA                             0x20000000
#define ChipConfig_CFGSTAT_RTA                             0x10000000
#define ChipConfig_CFGSTAT_STA                             0x08000000
#define ChipConfig_CFGSTAT_DST_MASK                        0x06000000
#define ChipConfig_CFGSTAT_DST_VALUE                       0x02000000
#define ChipConfig_CFGSTAT_DPE                             0x01000000
#define ChipConfig_CFGSTAT_FBB                             0x00800000
#define ChipConfig_CFGSTAT_UDF                             0x00400000
#define ChipConfig_CFGSTAT_66M                             0x00200000
#define ChipConfig_CFGSTAT_CPL                             0x00100000

#define ChipConfig_CFGCMD_MASK                             0x0000FFFF
#define ChipConfig_CFGCMD_FBB                              0x00000200
#define ChipConfig_CFGCMD_SEE                              0x00000100
#define ChipConfig_CFGCMD_WCC                              0x00000080
#define ChipConfig_CFGCMD_PER                              0x00000040
#define ChipConfig_CFGCMD_VGA                              0x00000020
#define ChipConfig_CFGCMD_MWI                              0x00000010
#define ChipConfig_CFGCMD_SPC                              0x00000008
#define ChipConfig_CFGCMD_MST                              0x00000004
#define ChipConfig_CFGCMD_MEM                              0x00000002
#define ChipConfig_CFGCMD_IOA                              0x00000001

#define ChipConfig_CLSCODE_REVID                           hpFieldOffset(ChipConfig_t,CLSCODE_REVID)

#define ChipConfig_CLSCODE_MASK                            0xFFFFFF00
#define ChipConfig_CLSCODE_VALUE                           0x0C040000

#define ChipConfig_REVID_MASK                              0x000000FF
#define ChipConfig_REVID_Major_MASK                        0x0000001C
#define ChipConfig_REVID_Major_MASK_Shift                  2
#define ChipConfig_REVID_Minor_MASK                        0x00000003
#define ChipConfig_REVID_Major_Minor_MASK                  (ChipConfig_REVID_Major_MASK | ChipConfig_REVID_Minor_MASK)
#define ChipConfig_REVID_1_0                               0x00000004
#define ChipConfig_REVID_2_0                               0x00000008
#define ChipConfig_REVID_2_2                               0x0000000A

#define ChipConfig_BIST_HDRTYPE_LATTIM_CLSIZE              hpFieldOffset(ChipConfig_t,BIST_HDRTYPE_LATTIM_CLSIZE)

#define ChipConfig_BIST_MASK                               0xFF000000
#define ChipConfig_BIST_Not_Supported                      0x00000000

#define ChipConfig_HDRTYPE_MASK                            0x00FF0000
#define ChipConfig_HDRTYPE_Single_Function                 0x00000000

#define ChipConfig_LATTIM_MASK                             0x0000FF00

#define ChipConfig_CLSIZE_MASK                             0x000000FF
#define ChipConfig_CLSIZE_32_Byte                          0x00000008

#define ChipConfig_IOBASEL                                 hpFieldOffset(ChipConfig_t,IOBASEL)

#define ChipConfig_IOBASEL_IO_Space                        0x00000001

#define ChipConfig_IOBASEU                                 hpFieldOffset(ChipConfig_t,IOBASEU)

#define ChipConfig_IOBASEU_IO_Space                        0x00000001

#define ChipConfig_MEMBASE                                 hpFieldOffset(ChipConfig_t,MEMBASE)

#define ChipConfig_RAMBASE                                 hpFieldOffset(ChipConfig_t,RAMBASE)

#define ChipConfig_SROMBASE                                hpFieldOffset(ChipConfig_t,SROMBASE)

#define ChipConfig_SVID                                    hpFieldOffset(ChipConfig_t,SVID)

/*
 * HSIO has been allocated the following:
 *
 *   For TachyonTL,  SubsystemIDs 0x0001-0x000A
 *   For TachyonTS,  SubsystemIDs 0x0001-0x000A
 *   For TachyonXL2, SubsystemIDs 0x0001-0x000F
 */

#define ChipConfig_SubsystemID_MASK                        0xFFFF0000
#define ChipConfig_SubsystemID_HHBA5100A_or_HHBA5101A      0x00010000 /* HP (DB-9 or GBIC) HBA utilizing TachyonTL    */
#define ChipConfig_SubsystemID_HHBA5100A                   0x00020000 /* HP DB-9 HBA utilizing TachyonTL              */
#define ChipConfig_SubsystemID_HHBA5101A                   0x00030000 /* HP GBIC HBA utilizing TachyonTL              */
#define ChipConfig_SubsystemID_HHBA5101B                   0x00040000 /* HP GBIC HBA utilizing TachyonTL              */
#define ChipConfig_SubsystemID_HHBA5123                    0x00050000 /* HP Dual-GBIC HBA utilizing 2 TachyonTLs      */
#define ChipConfig_SubsystemID_HHBA5101B_BCC               0x00060000 /* HP GBIC HBA utilizing TachyonTL for BCC      */
#define ChipConfig_SubsystemID_HHBA5101C                   0x00070000 /* Agilent GBIC HBA utilizing TachyonTL         */
#define ChipConfig_SubsystemID_HHBA5121A                   0x00010000 /* HP GBIC HBA utilizing TachyonTS              */
#define ChipConfig_SubsystemID_HHBA5121B                   0x00020000 /* Agilent GBIC HBA utilizing TachyonTS         */
#define ChipConfig_SubsystemID_HHBA5220A                   0x00010000 /* Agilent Copper  2Gb HBA utilizing TachyonXL2 */
#define ChipConfig_SubsystemID_HHBA5221A                   0x00020000 /* Agilent Optical 2Gb HBA utilizing TachyonXL2 */

#define ChipConfig_SubsystemVendorID_MASK                  0x0000FFFF
#define ChipConfig_SubsystemVendorID_Agilent_Technologies  ChipConfig_VENDID_Agilent_Technologies
#define ChipConfig_SubsystemVendorID_Hewlett_Packard       ChipConfig_VENDID_Hewlett_Packard


#define ChipConfig_SubsystemVendorID_Adaptec               0x00009004
#define ChipConfig_SubsystemID_Adaptec                     0x91100000

#define ChipConfig_ROMBASE                                 hpFieldOffset(ChipConfig_t,ROMBASE)

#define ChipConfig_Reserved_3__CAP_PTR                     hpFieldOffset(ChipConfig_t,Reserved_3__CAP_PTR)

#define ChipConfig_CAP_PTR_MASK                            0x000000FF
#define ChipConfig_CAP_PTR_VALUE                           0x00000050

#define ChipConfig_MAXLAT_MINGNT_INTPIN_INTLINE            hpFieldOffset(ChipConfig_t,MAXLAT_MINGNT_INTPIN_INTLINE)

#define ChipConfig_MAXLAT_MASK                             0xFF000000
#define ChipConfig_MAXLAT_Not_Supported                    0x00000000

#define ChipConfig_MINGNT_MASK                             0x00FF0000
#define ChipConfig_MINGNT_VALUE                            0x00200000

#define ChipConfig_INTPIN_MASK                             0x0000FF00
#define ChipConfig_INTPIN_INTA_L                           0x00000100

#define ChipConfig_INTLINE_MASK                            0x000000FF
#define ChipConfig_INTLINE_Not_Used                        0x00000000

#define ChipConfig_PCIMCTR__ROMCTR__Reserved_5__Reserved_6 hpFieldOffset(ChipConfig_t,PCIMCTR__ROMCTR__Reserved_5__Reserved_6)

#define ChipConfig_PCIMCTR_MASK                            0xFF000000
#define ChipConfig_PCIMCTL_P64                             0x04000000

#define ChipConfig_ROMCTR_MASK                             0x00FF0000
#define ChipConfig_ROMCTR_PAR                              0x00400000
#define ChipConfig_ROMCTR_SVL                              0x00200000
#define ChipConfig_ROMCTR_256                              0x00100000
#define ChipConfig_ROMCTR_128                              0x00080000
#define ChipConfig_ROMCTR_ROM                              0x00040000
#define ChipConfig_ROMCTR_FLA                              0x00020000
#define ChipConfig_ROMCTR_VPP                              0x00010000

#define ChipConfig_INTSTAT_INTEN_INTPEND_SOFTRST           hpFieldOffset(ChipConfig_t,INTSTAT_INTEN_INTPEND_SOFTRST)

#define ChipConfig_INTSTAT_MASK                            0xFF000000
#define ChipConfig_INTSTAT_Reserved                        0xE0000000
#define ChipConfig_INTSTAT_MPE                             0x10000000
#define ChipConfig_INTSTAT_CRS                             0x08000000
#define ChipConfig_INTSTAT_INT                             0x04000000
#define ChipConfig_INTSTAT_DER                             0x02000000
#define ChipConfig_INTSTAT_PER                             0x01000000

#define ChipConfig_INTEN_MASK                              0x00FF0000
#define ChipConfig_INTEN_Reserved                          0x00E00000
#define ChipConfig_INTEN_MPE                               0x00100000
#define ChipConfig_INTEN_CRS                               0x00080000
#define ChipConfig_INTEN_INT                               0x00040000
#define ChipConfig_INTEN_DER                               0x00020000
#define ChipConfig_INTEN_PER                               0x00010000

#define ChipConfig_INTPEND_MASK                            0x0000FF00
#define ChipConfig_INTPEND_Reserved                        0x0000E000
#define ChipConfig_INTPEND_MPE                             0x00001000
#define ChipConfig_INTPEND_CRS                             0x00000800
#define ChipConfig_INTPEND_INT                             0x00000400
#define ChipConfig_INTPEND_DER                             0x00000200
#define ChipConfig_INTPEND_PER                             0x00000100

#define ChipConfig_SOFTRST_MASK                            0x000000FF
#define ChipConfig_SOFTRST_Reserved                        0x000000FC
#define ChipConfig_SOFTRST_DPE                             0x00000002
#define ChipConfig_SOFTRST_RST                             0x00000001

#define ChipConfig_PMC__CAP_NEXT_PTR__CAP_ID               hpFieldOffset(ChipConfig_t,PMC__CAP_NEXT_PTR__CAP_ID)

#define ChipConfig_PMC_MASK                                0xFFFF0000
#define ChipConfig_PMC_PME_MASK                            0xF8000000
#define ChipConfig_PMC_PME_Not_Supported                   0x00000000
#define ChipConfig_PMC_D2                                  0x04000000
#define ChipConfig_PMC_D1                                  0x02000000
#define ChipConfig_PMC_DSI                                 0x00200000
#define ChipConfig_PMC_APS                                 0x00100000
#define ChipConfig_PMC_CLK                                 0x00080000
#define ChipConfig_PMC_VER_MASK                            0x00070000

#define ChipConfig_CAP_NEXT_PTR_MASK                       0x0000FF00
#define ChipConfig_CAP_NEXT_PTR_No_Further                 0x00000000

#define ChipConfig_CAP_ID_MASK                             0x000000FF
#define ChipConfig_CAP_ID_Power_Management                 0x00000001

#define ChipConfig_Reserved_8__PMCSR                       hpFieldOffset(ChipConfig_t,Reserved_8__PMCSR)

#define ChipConfig_PMCSR_MASK                              0x0000FFFF
#define ChipConfig_PMCSR_PME                               0x00008000
#define ChipConfig_PMCSR_SCL_MASK                          0x00006000
#define ChipConfig_PMCSR_SEL_MASK                          0x00001E00
#define ChipConfig_PMCSR_PEN                               0x00000100
#define ChipConfig_PMCSR_PST_MASK                          0x00000003
#define ChipConfig_PMCSR_PST_Enable_DO_Power_State         0x00000000
#define ChipConfig_PMCSR_PST_Enable_D1_Power_State         0x00000001 /* Not supported */
#define ChipConfig_PMCSR_PST_Enable_D2_Power_State         0x00000002 /* Not supported */
#define ChipConfig_PMCSR_PST_Enable_D3_Power_State         0x00000003

/*+
Chip Registers
-*/

typedef struct ChipIOLo_s
               ChipIOLo_t;

#define ChipIOLo_t_SIZE                                    0x00000100

struct ChipIOLo_s {
                    os_bit32 ERQ_Base;
                    os_bit32 ERQ_Length;
                    os_bit32 ERQ_Producer_Index;
                    os_bit32 ERQ_Consumer_Index_Address;
                    os_bit32 ERQ_Consumer_Index;
                    os_bit8  Reserved_1[0x4F-0x14+1];
                    os_bit32 SFQ_Base;
                    os_bit32 SFQ_Length;
                    os_bit32 SFQ_Consumer_Index;
                    os_bit8  Reserved_2[0x7B-0x5C+1];          /* XL only  */
                    os_bit32 Interrupt_Delay_Timer;
                    os_bit32 IMQ_Base;
                    os_bit32 IMQ_Length;
                    os_bit32 IMQ_Consumer_Index;
                    os_bit32 IMQ_Producer_Index_Address;
                    os_bit8  Reserved_3[0xEF-0x90+1];
                    os_bit8  Reserved_4[0xFF-0xF0+1];
                  };

#define ChipIOLo_ERQ_Base                   hpFieldOffset(ChipIOLo_t,ERQ_Base)

#define ChipIOLo_ERQ_Length                 hpFieldOffset(ChipIOLo_t,ERQ_Length)

#define ChipIOLo_ERQ_Length_MASK            0x00000FFF
#define ChipIOLo_ERQ_Length_MIN             0x00000001 /*    2 */
#define ChipIOLo_ERQ_Length_MAX             0x00000FFF /* 4096 */
#define ChipIOLo_ERQ_Length_POWER_OF_2      agTRUE

#define ChipIOLo_ERQ_Producer_Index         hpFieldOffset(ChipIOLo_t,ERQ_Producer_Index)

#define ChipIOLo_ERQ_Producer_Index_MASK    0x00000FFF

#define ChipIOLo_ERQ_Consumer_Index_Address hpFieldOffset(ChipIOLo_t,ERQ_Consumer_Index_Address)

#define ChipIOLo_ERQ_Consumer_Index         hpFieldOffset(ChipIOLo_t,ERQ_Consumer_Index)

#define ChipIOLo_ERQ_Consumer_Index_MASK    0x00000FFF

#define ChipIOLo_SFQ_Base                   hpFieldOffset(ChipIOLo_t,SFQ_Base)

#define ChipIOLo_SFQ_Length                 hpFieldOffset(ChipIOLo_t,SFQ_Length)

#define ChipIOLo_SFQ_Length_MASK            0x00000FFF
#define ChipIOLo_SFQ_Length_MIN             0x0000001F /*   32 */
#define ChipIOLo_SFQ_Length_MAX             0x00000FFF /* 4096 */
#define ChipIOLo_SFQ_Length_POWER_OF_2      agTRUE

#define ChipIOLo_SFQ_Consumer_Index         hpFieldOffset(ChipIOLo_t,SFQ_Consumer_Index)

#define ChipIOLo_SFQ_Consumer_Index_MASK    0x00000FFF

#define ChipIOLo_Interrupt_Delay_Timer      hpFieldOffset (ChipIOLo_t, Interrupt_Delay_Timer)
#define ChipIOLo_Interrupt_Delay_Timer_MASK         0x0000000F

#define ChipIOUp_Interrupt_Delay_Timer_Immediate    0x00000000
#define ChipIOUp_Interrupt_Delay_Timer_125          0x00000001
#define ChipIOUp_Interrupt_Delay_Timer_250          0x00000002
#define ChipIOUp_Interrupt_Delay_Timer_375          0x00000003
#define ChipIOUp_Interrupt_Delay_Timer_500          0x00000004
#define ChipIOUp_Interrupt_Delay_Timer_625          0x00000005
#define ChipIOUp_Interrupt_Delay_Timer_750          0x00000006
#define ChipIOUp_Interrupt_Delay_Timer_875          0x00000007
#define ChipIOUp_Interrupt_Delay_Timer_1ms          0x00000008
#define ChipIOUp_Interrupt_Delay_Timer_1_125ms      0x00000009
#define ChipIOUp_Interrupt_Delay_Timer_1_250ms      0x0000000a
#define ChipIOUp_Interrupt_Delay_Timer_1_375ms      0x0000000b
#define ChipIOUp_Interrupt_Delay_Timer_1_500ms      0x0000000c
#define ChipIOUp_Interrupt_Delay_Timer_1_625ms      0x0000000d
#define ChipIOUp_Interrupt_Delay_Timer_1_875ms      0x0000000e



#define ChipIOLo_IMQ_Base                   hpFieldOffset(ChipIOLo_t,IMQ_Base)

#define ChipIOLo_IMQ_Length                 hpFieldOffset(ChipIOLo_t,IMQ_Length)

#define ChipIOLo_IMQ_Length_MASK            0x00000FFF
#define ChipIOLo_IMQ_Length_MIN             0x00000001 /*    2 */
#define ChipIOLo_IMQ_Length_MAX             0x00000FFF /* 4096 */
#define ChipIOLo_IMQ_Length_POWER_OF_2      agTRUE

#define ChipIOLo_IMQ_Consumer_Index         hpFieldOffset(ChipIOLo_t,IMQ_Consumer_Index)

#define ChipIOLo_IMQ_Consumer_Index_MASK    0x00000FFF

#define ChipIOLo_IMQ_Producer_Index_Address hpFieldOffset(ChipIOLo_t,IMQ_Producer_Index_Address)

typedef struct ChipIOUp_s
               ChipIOUp_t;

#define ChipIOUp_t_SIZE                                    0x00000100

struct ChipIOUp_s {
#ifdef __TACHYON_XL2
					os_bit32 Frame_Manager_Configuration_3;						
					os_bit32 Frame_Manager_Shadow_Status;						
                    os_bit8  Reserved_1[0x3F-0x08+1];
#else
                    os_bit8  Reserved_1[0x3F+1];
#endif	/* __TACHYON_XL2 */																	
                    os_bit32 SEST_Base;
                    os_bit32 SEST_Length;
                    os_bit8  Reserved_2[0x4B-0x48+1];
                    os_bit32 SEST_Linked_List_Head_Tail;
#ifdef __TACHYON_XL2
                    os_bit32 SPI_RAM_ROM_Address;
                    os_bit32 SPI_RAM_ROM_Data;
                    os_bit8  Reserved_3[0x67-0x58+1];
#else
                    os_bit8  Reserved_3[0x67-0x50+1];
#endif	/* __TACHYON_XL2 */																	
                    os_bit32 ScatterGather_List_Page_Length;
                    os_bit32 My_ID;
#ifdef __TACHYON_XL2
                    os_bit32 General_Purpose_IO;
                    os_bit8  Reserved_4[0x83-0x74+1];
#else
                    os_bit8  Reserved_4[0x83-0x70+1];
#endif	/* __TACHYON_XL2 */																	
                    os_bit32 TachLite_Configuration;
                    os_bit32 TachLite_Control;
                    os_bit32 TachLite_Status;
                    os_bit32 Reserved_5;                                       /* XL only  */
                    os_bit32 High_Priority_Send_1;                             /* XL only  */
                    os_bit32 High_Priority_Send_2;                             /* XL only  */
                    os_bit32 Inbound_Resource_Status_1;                        /* XL only  */
                    os_bit32 Inbound_Resource_Status_2;                        /* XL only  */
                    os_bit32 EE_Credit_Zero_Timer_Threshold;                   /* XL only  */
                    os_bit32 Upper_Data_Address;                               /* XL only  */
                    os_bit32 Upper_Control_Address;                            /* XL only  */
                    os_bit32 Dynamic_Half_Duplex_3;                            /* XL only  */
                    os_bit32 Dynamic_Half_Duplex_2;                            /* XL only  */
                    os_bit32 Dynamic_Half_Duplex_1;                            /* XL only  */
                    os_bit32 Dynamic_Half_Duplex_0;                            /* XL only  */
                    os_bit32 Frame_Manager_Configuration;
                    os_bit32 Frame_Manager_Control;
                    os_bit32 Frame_Manager_Status;
                    os_bit32 Frame_Manager_TimeOut_Values_1;
                    os_bit32 Frame_Manager_Link_Status_1;
                    os_bit32 Frame_Manager_Link_Status_2;
                    os_bit32 Frame_Manager_TimeOut_Values_2;
                    os_bit32 Frame_Manager_BBCredit_Zero_Timer;
                    os_bit32 Frame_Manager_World_Wide_Name_High;
                    os_bit32 Frame_Manager_World_Wide_Name_Low;
                    os_bit32 Frame_Manager_Received_ALPA;
                    os_bit32 Frame_Manager_Primitive;
                    os_bit32 Frame_Manager_Link_Status_3;                      /* XL only  */
                    os_bit32 Frame_Manager_Configuration_2;                    /* XL only  */
                    os_bit32 PCIMCTR__ROMCTR__Reserved_8__Reserved_9;
                    os_bit32 INTSTAT_INTEN_INTPEND_SOFTRST;
                  };

#ifdef __TACHYON_XL
#define ChipIOUp_Frame_Manager_Configuration_3                    hpFieldOffset(ChipIOUp_t,Frame_Manager_Configuration_3)
 
#define ChipIOUp_Frame_Manager_Configuration_3_AutoSpeed_Nego_In_Prog	0x40000000     

#define ChipIOUp_Frame_Manager_Configuration_3_EN_AutoSpeed_Nego		0x10000000 

#define ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS					0x04000000     
#define ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS					0x01000000 

#endif	/* __TACHYON_XL */																	

#define ChipIOUp_SEST_Base                                        hpFieldOffset(ChipIOUp_t,SEST_Base)

#define ChipIOUp_SPI_RAM_ROM_Address                              hpFieldOffset(ChipIOUp_t,SPI_RAM_ROM_Address);
#define ChipIOUp_SPI_RAM_ROM_Address_Access_RAM                   0x80000000
#define ChipIOUp_SPI_RAM_ROM_Data                                 hpFieldOffset(ChipIOUp_t,SPI_RAM_ROM_Data);
#define ChipIOUp_SPI_RAM_ROM_Data_Access_ROM_MASK                 0x000000FF


#define ChipIOUp_SEST_Length                                      hpFieldOffset(ChipIOUp_t,SEST_Length)

#define ChipIOUp_SEST_Length_MASK                                 0x0000FFFF
#define ChipIOUp_SEST_Length_MIN                                  0x00000001 /*     1 */
#define ChipIOUp_SEST_Length_MAX                                  0x00007FFF /* 32767 */
#define ChipIOUp_SEST_Length_POWER_OF_2                           agFALSE

#define ChipIOUp_SEST_Linked_List_Head_Tail                       hpFieldOffset(ChipIOUp_t,SEST_Linked_List_Head_Tail)

#define ChipIOUp_SEST_Linked_List_Head_MASK                       0xFFFF0000
#define ChipIOUp_SEST_Linked_List_Head_SHIFT                            0x10
#define ChipIOUp_SEST_Linked_List_Tail_MASK                       0x0000FFFF
#define ChipIOUp_SEST_Linked_List_Tail_SHIFT                            0x00

#define ChipIOUp_SEST_Linked_List_Tail_RESET_VALUE                (ChipIOUp_SEST_Linked_List_Head_MASK | ChipIOUp_SEST_Linked_List_Tail_MASK)

#define ChipIOUp_ScatterGather_List_Page_Length                   hpFieldOffset(ChipIOUp_t,ScatterGather_List_Page_Length)

#define ChipIOUp_ScatterGather_List_Page_Length_MASK              0x000000FF
#define ChipIOUp_ScatterGather_List_Page_Length_MIN               0x00000003 /*   4 */
#define ChipIOUp_ScatterGather_List_Page_Length_MAX               0x000000FF /* 256 */
#define ChipIOUp_ScatterGather_List_Page_Length_POWER_OF_2        agTRUE

#define ChipIOUp_My_ID                                            hpFieldOffset(ChipIOUp_t,My_ID)

#define ChipIOUp_My_ID_MASK                                       0x00FFFFFF

#define ChipIOUp_TachLite_Configuration                           hpFieldOffset(ChipIOUp_t,TachLite_Configuration)

#define ChipIOUp_TachLite_Configuration_M66EN                     0x80000000 /* Always set for TachyonTL */
#define ChipIOUp_TachLite_Configuration_OB_Thresh_MASK            0x00007C00
#define ChipIOUp_TachLite_Configuration_OB_Thresh_100             0x00000000
#define ChipIOUp_TachLite_Configuration_OB_Thresh_132             0x00002000
#define ChipIOUp_TachLite_Configuration_OB_Thresh_150             0x00002C00
#define ChipIOUp_TachLite_Configuration_OB_Thresh_200             0x00004000
#define ChipIOUp_TachLite_Configuration_OB_Thresh_264             0x00005000
#define ChipIOUp_TachLite_Configuration_OB_Thresh_528             0x00006800 /* Only valid for TachyonTS */
#define ChipIOUp_TachLite_Configuration_SIC                       0x00000040
#define ChipIOUp_TachLite_Configuration_FAD                       0x00000001

#define ChipIOUp_TachLite_Control                                 hpFieldOffset(ChipIOUp_t,TachLite_Control)

#define ChipIOUp_TachLite_Control_CRS                             0x80000000
#define ChipIOUp_TachLite_Control_ROF                             0x00040000
#define ChipIOUp_TachLite_Control_RIF                             0x00020000
#define ChipIOUp_TachLite_Control_REQ                             0x00010000
#define ChipIOUp_TachLite_Control_FIS                             0x00001000
#define ChipIOUp_TachLite_Control_FFA                             0x00000200
#define ChipIOUp_TachLite_Control_FEQ                             0x00000100
#define ChipIOUp_TachLite_Control_GP4                             0x00000010
#define ChipIOUp_TachLite_Control_GP3                             0x00000008
#define ChipIOUp_TachLite_Control_GP2                             0x00000004
#define ChipIOUp_TachLite_Control_GP1                             0x00000002
#define ChipIOUp_TachLite_Control_GP0                             0x00000001

#define ChipIOUp_TachLite_Control_GPIO_0_3_MASK                   (ChipIOUp_TachLite_Control_GP3 | ChipIOUp_TachLite_Control_GP2 | ChipIOUp_TachLite_Control_GP1 | ChipIOUp_TachLite_Control_GP0)
#define ChipIOUp_TachLite_Control_GPIO_ALL_MASK                   (ChipIOUp_TachLite_Control_GP4 | ChipIOUp_TachLite_Control_GPIO_0_3_MASK)

#define ChipIOUp_TachLite_Status                                  hpFieldOffset(ChipIOUp_t,TachLite_Status)

#define ChipIOUp_TachLite_Status_SFF                              0x80000000
#define ChipIOUp_TachLite_Status_IMF                              0x40000000
#define ChipIOUp_TachLite_Status_OFE                              0x20000000
#define ChipIOUp_TachLite_Status_IFE                              0x10000000
#define ChipIOUp_TachLite_Status_OFF                              0x00040000
#define ChipIOUp_TachLite_Status_IFF                              0x00020000
#define ChipIOUp_TachLite_Status_EQF                              0x00010000
#define ChipIOUp_TachLite_Status_Stop_Cnt_MASK                    0x0000F000
#define ChipIOUp_TachLite_Status_OPE                              0x00000800
#define ChipIOUp_TachLite_Status_IPE                              0x00000400
#define ChipIOUp_TachLite_Status_REVID_MASK                       0x000003E0
#define ChipIOUp_TachLite_Status_REVID_SHIFT                            0x05
#define ChipIOUp_TachLite_Status_GP4                              0x00000010
#define ChipIOUp_TachLite_Status_GP3                              0x00000008
#define ChipIOUp_TachLite_Status_GP2                              0x00000004
#define ChipIOUp_TachLite_Status_GP1                              0x00000002
#define ChipIOUp_TachLite_Status_GP0                              0x00000001
#define ChipIOUp_TachLite_Status_OLE                              0x08000000
#define ChipIOUp_TachLite_Status_ILE                              0x04000000
#define ChipIOUp_TachLite_Status_M66                              0x02000000


#define ChipIOUp_TachLite_Status_GPIO_0_3_MASK                    (ChipIOUp_TachLite_Status_GP3 | ChipIOUp_TachLite_Status_GP2 | ChipIOUp_TachLite_Status_GP1 | ChipIOUp_TachLite_Status_GP0)
#define ChipIOUp_TachLite_Status_GPIO_ALL_MASK                    (ChipIOUp_TachLite_Status_GP4 | ChipIOUp_TachLite_Status_GPIO_0_3_MASK)

#define ChipIOUp_Tachlite_High_Priority_Send_1                      hpFieldOffset(ChipIOUp_t, High_Priority_Send_1)

#define ChipIOUp_TachLite_High_Priority_Send_1_HP_Frame_Upper_Addr_MASK     0x7ff80000
#define ChipIOUp_Tachlite_High_Priority_Send_1_HP_Frame_Upper_Addr_SHIFT    0x13
#define ChipIOUp_Tachlite_High_Priority_Send_1_HP_Frame_Length_MASK         0x00000fff
#define ChipIOUp_Tachlite_High_Priority_Send_1_HP_Frame_Length_SHIFT        0x0

   
#define ChipIOUp_Inbound_Resource_Status                          hpFieldOffset(ChipIOUp_t,Inbound_Resource_Status_1)

#define ChipIOUp_Inbound_Resource_Status_SEST_LRU_Count_MASK      0xFF000000
#define ChipIOUp_Inbound_Resource_Status_SEST_LRU_Count_SHIFT           0x18

#define ChipIOUp_Inbound_Resource_Status_2                          hpFieldOffset(ChipIOUp_t,Inbound_Resource_Status_2)

#define ChipIOUp_Inbound_Resource_Status_Discarded_Frame_Counter_MASK      0x000000FF
#define ChipIOUp_Inbound_Resource_Status_Discarded_Frame_Counter_SHIFT           0x0

#define ChipIOUp_EE_Credit_Zero_Timer_Threshold                   hpFieldOffset(ChipIOUp_t,EE_Credit_Zero_Timer_Threshold)

#define ChipIOUp_EE_Credit_Zero_Timer_Threshold_MASK              0x0fffffff
#define ChipIOUp_EE_Credit_Zero_Timer_Threshold_SHIFT             0x0

#define ChipIOUp_Upper_Data_Address                               hpFieldOffset(ChipIOUp_t,ChipIOUp_Upper_Data_Address)
#define ChipIOUp_Upper_Control_Address                            hpFieldOffset(ChipIOUp_t,ChipIOUp_Upper_Control_Address)

#define ChipIOUp_Inbound_Resource_Status_Discarded_Frame_Counter_MASK      0x000000FF
#define ChipIOUp_Inbound_Resource_Status_Discarded_Frame_Counter_SHIFT           0x0


#define ChipIOUp_Frame_Manager_Configuration                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Configuration)

#define ChipIOUp_Frame_Manager_Configuration_AL_PA_MASK           0xFF000000
#define ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT                0x18
#define ChipIOUp_Frame_Manager_Configuration_BB_Credit_MASK       0x00FF0000
#define ChipIOUp_Frame_Manager_Configuration_BB_Credit_SHIFT            0x10
#define ChipIOUp_Frame_Manager_Configuration_NPI                  0x00008000
#define ChipIOUp_Frame_Manager_Configuration_ILB                  0x00004000
#define ChipIOUp_Frame_Manager_Configuration_ELB                  0x00002000
#define ChipIOUp_Frame_Manager_Configuration_SAP                  0x00001000
#define ChipIOUp_Frame_Manager_Configuration_TD                   0x00000800
#define ChipIOUp_Frame_Manager_Configuration_FA                   0x00000400
#define ChipIOUp_Frame_Manager_Configuration_AQ                   0x00000200
#define ChipIOUp_Frame_Manager_Configuration_HA                   0x00000100
#define ChipIOUp_Frame_Manager_Configuration_SA                   0x00000080
#define ChipIOUp_Frame_Manager_Configuration_BLM                  0x00000040
#define ChipIOUp_Frame_Manager_Configuration_RF                   0x00000020
#define ChipIOUp_Frame_Manager_Configuration_IF                   0x00000010
#define ChipIOUp_Frame_Manager_Configuration_LR                   0x00000008
#define ChipIOUp_Frame_Manager_Configuration_ENP                  0x00000004
#define ChipIOUp_Frame_Manager_Configuration_BLI                  0x00000001

#define ChipIOUp_TachLite_Configuration_DAM                       0x10000000
#define ChipIOUp_Tachlite_Configuration_RDE                       0x08000000     
#define ChipIOUp_Tachlite_Configuration_SDF                       0x04000000
#define ChipIOUp_Tachlite_Configuration_FC2                       0x01000000 
#define ChipIOUp_Tachlite_Configuration_CAE                       0x00000200
#define ChipIOUp_Tachlite_Configuration_SIC                       0x00000040
#define ChipIOUp_Tachlite_Configuration_FAB                       0x00000020
#define ChipIOUp_Tachlite_Configuration_FUA                       0x00000008                     
#define ChipIOUp_Tachlite_Configuration_DOF                       0x00000004
#define ChipIOUp_Tachlite_Configuration_INO                       0x00000002
#define ChipIOUp_TachLite_Configuration_FAD                       0x00000001                                             



#define ChipIOUp_Frame_Manager_Control                            hpFieldOffset(ChipIOUp_t,Frame_Manager_Control)

#define ChipIOUp_Frame_Manager_Control_SAS                        0x00000080
#define ChipIOUp_Frame_Manager_Control_SQ                         0x00000040
#define ChipIOUp_Frame_Manager_Control_SP                         0x00000020
#define ChipIOUp_Frame_Manager_Control_CL                         0x00000008
#define ChipIOUp_Frame_Manager_Control_CMD_MASK                   0x00000007
#define ChipIOUp_Frame_Manager_Control_CMD_NOP                    0x00000000
#define ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop              0x00000001
#define ChipIOUp_Frame_Manager_Control_CMD_Host_Control           0x00000002
#define ChipIOUp_Frame_Manager_Control_CMD_Exit_Host_Control      0x00000003
#define ChipIOUp_Frame_Manager_Control_CMD_Link_Reset             0x00000004
#define ChipIOUp_Frame_Manager_Control_CMD_Offline                0x00000005
#define ChipIOUp_Frame_Manager_Control_CMD_Initialize             0x00000006
#define ChipIOUp_Frame_Manager_Control_CMD_Clear_LF               0x00000007

#define ChipIOUp_Frame_Manager_Status                             hpFieldOffset(ChipIOUp_t,Frame_Manager_Status)

#define ChipIOUp_Frame_Manager_Status_LP                          0x80000000
#define ChipIOUp_Frame_Manager_Status_TP                          0x40000000
#define ChipIOUp_Frame_Manager_Status_NP                          0x20000000
#define ChipIOUp_Frame_Manager_Status_BYP                         0x10000000
#define ChipIOUp_Frame_Manager_Status_FLT                         0x04000000
#define ChipIOUp_Frame_Manager_Status_OS                          0x02000000
#define ChipIOUp_Frame_Manager_Status_LS                          0x01000000
#define ChipIOUp_Frame_Manager_Status_DRS                         0x00400000
#define ChipIOUp_Frame_Manager_Status_LPE                         0x00200000
#define ChipIOUp_Frame_Manager_Status_LPB                         0x00100000
#define ChipIOUp_Frame_Manager_Status_OLS                         0x00080000
#define ChipIOUp_Frame_Manager_Status_LST                         0x00040000
#define ChipIOUp_Frame_Manager_Status_LPF                         0x00020000
#define ChipIOUp_Frame_Manager_Status_BA                          0x00010000
#define ChipIOUp_Frame_Manager_Status_PRX                         0x00008000
#define ChipIOUp_Frame_Manager_Status_PTX                         0x00004000
#define ChipIOUp_Frame_Manager_Status_LG                          0x00002000
#define ChipIOUp_Frame_Manager_Status_LF                          0x00001000
#define ChipIOUp_Frame_Manager_Status_CE                          0x00000800
#define ChipIOUp_Frame_Manager_Status_EW                          0x00000400
#define ChipIOUp_Frame_Manager_Status_LUP                         0x00000200
#define ChipIOUp_Frame_Manager_Status_LDN                         0x00000100
#define ChipIOUp_Frame_Manager_Status_LSM_MASK                    0x000000F0
#define ChipIOUp_Frame_Manager_Status_LSM_Monitor                 0x00000000
#define ChipIOUp_Frame_Manager_Status_LSM_ARB                     0x00000010
#define ChipIOUp_Frame_Manager_Status_LSM_ARB_Won                 0x00000020
#define ChipIOUp_Frame_Manager_Status_LSM_Open                    0x00000030
#define ChipIOUp_Frame_Manager_Status_LSM_Opened                  0x00000040
#define ChipIOUp_Frame_Manager_Status_LSM_Xmit_CLS                0x00000050
#define ChipIOUp_Frame_Manager_Status_LSM_Rx_CLS                  0x00000060
#define ChipIOUp_Frame_Manager_Status_LSM_Xfer                    0x00000070
#define ChipIOUp_Frame_Manager_Status_LSM_Initialize              0x00000080
#define ChipIOUp_Frame_Manager_Status_LSM_O_I_Init_Finish         0x00000090
#define ChipIOUp_Frame_Manager_Status_LSM_O_I_Protocol            0x000000A0
#define ChipIOUp_Frame_Manager_Status_LSM_O_I_Lip_Received        0x000000B0
#define ChipIOUp_Frame_Manager_Status_LSM_Host_Control            0x000000C0
#define ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail               0x000000D0
#define ChipIOUp_Frame_Manager_Status_LSM_Offline                 0x000000E0
#define ChipIOUp_Frame_Manager_Status_LSM_Old_Port                0x000000F0
#define ChipIOUp_Frame_Manager_Status_PSM_MASK                    0x0000000F
#define ChipIOUp_Frame_Manager_Status_PSM_Offline                 0x00000000
#define ChipIOUp_Frame_Manager_Status_PSM_OL1                     0x00000001
#define ChipIOUp_Frame_Manager_Status_PSM_OL2                     0x00000002
#define ChipIOUp_Frame_Manager_Status_PSM_OL3                     0x00000003
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_1              0x00000004
#define ChipIOUp_Frame_Manager_Status_PSM_LR1                     0x00000005
#define ChipIOUp_Frame_Manager_Status_PSM_LR2                     0x00000006
#define ChipIOUp_Frame_Manager_Status_PSM_LR3                     0x00000007
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_2              0x00000008
#define ChipIOUp_Frame_Manager_Status_PSM_LF1                     0x00000009
#define ChipIOUp_Frame_Manager_Status_PSM_LF2                     0x0000000A
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_3              0x0000000B
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_4              0x0000000C
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_5              0x0000000D
#define ChipIOUp_Frame_Manager_Status_PSM_Reserved_6              0x0000000E
#define ChipIOUp_Frame_Manager_Status_PSM_ACTIVE                  0x0000000F

#define ChipIOUp_Frame_Manager_TimeOut_Values_1                   hpFieldOffset(ChipIOUp_t,Frame_Manager_TimeOut_Values_1)
#define Chip_Frame_Manager_TimeOut_Values_1(rt_tov, ed_tov)  (( rt_tov << ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT) | ( ed_tov <<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)) 
#define Chip_Frame_Manager_TimeOut_Values_1_RT_TOV_Default_After_Reset 100
#define Chip_Frame_Manager_TimeOut_Values_1_ED_TOV_Default_After_Reset 500
#define Chip_Frame_Manager_TimeOut_Values_1_ED_TOV_Default 2000

#define ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_MASK       0x01FF0000
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT            0x10
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_100ms      (100<<ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_Default    ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_100ms
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_MASK       0x0000FFFF
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT            0x00
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_500ms      (500<<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_2000ms      (2000<<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_4000ms      (4000<<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_Default    ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_500ms

#define ChipIOUp_Frame_Manager_Link_Status_1                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Link_Status_1)

#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_MASK  0xFF000000
#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_SHIFT       0x18
#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_AdjustToChar( x ) (( x & ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_SHIFT )
#define ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_MASK     0x00FF0000
#define ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_SHIFT          0x10
#define ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_AdjustToChar( x )    (( x & ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_SHIFT )

#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_MASK    0x0000FF00
#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_SHIFT         0x08
#define ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_SHIFT )

#define ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_MASK       0x000000FF
#define ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_SHIFT            0x00
#define ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_SHIFT )

#define ChipIOUp_Frame_Manager_Link_Status_2                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Link_Status_2)

#define ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_MASK         0xFF000000
#define ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_SHIFT              0x18
#define ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_SHIFT )
#define ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_MASK         0x00FF0000
#define ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_SHIFT              0x10
#define ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_SHIFT )
#define ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_MASK         0x0000FF00
#define ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_SHIFT              0x08
#define ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_SHIFT )
#define ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_MASK       0x000000FF
#define ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_SHIFT            0x00
#define ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_AdjustToChar( x )  (( x & ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_SHIFT )

#define ChipIOUp_Frame_Manager_TimeOut_Values_2                   hpFieldOffset(ChipIOUp_t,Frame_Manager_TimeOut_Values_2)
#define Chip_Frame_Manager_TimeOut_Values_2(lp_tov, al_time)  (( lp_tov << ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT) | ( al_time << ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT)) 
#define Chip_Frame_Manager_TimeOut_Values_2_LP_TOV_Default_After_Reset  500
#define Chip_Frame_Manager_TimeOut_Values_2_AL_Time_Default_After_Reset 15
#define Chip_Frame_Manager_TimeOut_Values_2_LP_TOV_Default Chip_Frame_Manager_TimeOut_Values_1_ED_TOV_Default

#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_MASK       0xFFFF0000
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT            0x10
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_2s         ((2*1000)<<ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_500ms      (( 500)<<ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_Default    ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_2s
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_MASK      0x000001FF
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT           0x00
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_15ms      (15<<ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_1000ms    (1000<<ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT)
#define ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_Default   ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_15ms

#define ChipIOUp_Frame_Manager_BBCredit_Zero_Timer                hpFieldOffset(ChipIOUp_t,Frame_Manager_BBCredit_Zero_Timer)

#define ChipIOUp_Frame_Manager_BBCredit_Zero_Timer_MASK           0x00FFFFFF

#define ChipIOUp_Frame_Manager_World_Wide_Name_High               hpFieldOffset(ChipIOUp_t,Frame_Manager_World_Wide_Name_High)

#define ChipIOUp_Frame_Manager_World_Wide_Name_Low                hpFieldOffset(ChipIOUp_t,Frame_Manager_World_Wide_Name_Low)

#define ChipIOUp_Frame_Manager_Received_ALPA                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Received_ALPA)

#define ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK        0x00FF0000
#define ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT             0x10
#define ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_MASK        0x0000FF00
#define ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT             0x08
#define ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK       0x000000FF
#define ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_SHIFT            0x00

#define ChipIOUp_Frame_Manager_Primitive                          hpFieldOffset(ChipIOUp_t,Frame_Manager_Primitive)

#define ChipIOUp_Frame_Manager_Primitive_MASK                     0x00FFFFFF

#define ChipIOUp_Frame_Manager_Link_Status_3                      hpFieldOffset(ChipIOUp_t,Frame_Manager_Link_Status_3)
#define ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_MASK         0x000000FF
#define ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_SHIFT        0x0
#define ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_AdjustToChar( x ) (( x & ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_MASK ) >> ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_SHIFT )

#define ChipIOUp_Frame_Manager_Configuration_2                    hpFieldOffset(ChipIOUp_t,Frame_Manager_Configuration_2)

#define ChipIOUp_Frame_Manager_Configuration_2_LAA_MASK           0xFF000000
#define ChipIOUp_Frame_Manager_Configuration_2_LAA_SHIFT          0x18
#define ChipIOUp_Frame_Manager_Configuration_2_XTP_MASK           0x00C00000
#define ChipIOUp_Frame_Manager_Configuration_2_XTP                0x0
#define ChipIOUp_Frame_Manager_Configuration_2_XTZ_MASK           0x00400000
#define ChipIOUp_Frame_Manager_Configuration_2_XTZ_SHIFT          0x14
#define ChipIOUp_Frame_Manager_Configuration_2_XTZ                0x3
#define ChipIOUp_Frame_Manager_Configuration_2_XRP_MASK           0x000C0000
#define ChipIOUp_Frame_Manager_Configuration_2_XRP                0x0
#define ChipIOUp_Frame_Manager_Configuration_2_XRZ_MASK           0x00040000
#define ChipIOUp_Frame_Manager_Configuration_2_XRZ_SHIFT          0xF
#define ChipIOUp_Frame_Manager_Configuration_2_XRZ                0x1

#define ChipIOUp_Frame_Manager_Configuration_2_XEM_MASK           0x00006000
#define ChipIOUp_Frame_Manager_Configuration_2_XEM_SHIFT          0xC
#define ChipIOUp_Frame_Manager_Configuration_2_XEM                0x0

#define ChipIOUp_Frame_Manager_Configuration_2_XLP                0x00001000

#define ChipIOUp_Frame_Manager_Configuration_2_ATV_MASK           0x000000C0
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_SHIFT          0x5
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_Single_Frame   0x0
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_25_Percent     0x1
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_50_Percent     0x2
#define ChipIOUp_Frame_Manager_Configuration_2_ATV_75_Percent     0x3

#define ChipIOUp_Frame_Manager_Configuration_2_ICB                0x00000010
#define ChipIOUp_Frame_Manager_Configuration_2_DCI                0x00000008
#define ChipIOUp_Frame_Manager_Configuration_2_NBC                0x00000004
#define ChipIOUp_Frame_Manager_Configuration_2_DAC                0x00000001



#define ChipIOUp_PCIMCTR__ROMCTR__Reserved_8__Reserved_9          hpFieldOffset(ChipIOUp_t,PCIMCTR__ROMCTR__Reserved_8__Reserved_9)

#define ChipIOUp_PCIMCTR_MASK                                     0xFF000000
#define ChipIOUp_PCIMCTL_P64                                      0x04000000

#define ChipIOUp_ROMCTR_MASK                                      0x00FF0000
#define ChipIOUp_ROMCTR_PAR                                       0x00400000
#define ChipIOUp_ROMCTR_SVL                                       0x00200000
#define ChipIOUp_ROMCTR_256                                       0x00100000
#define ChipIOUp_ROMCTR_128                                       0x00080000
#define ChipIOUp_ROMCTR_ROM                                       0x00040000
#define ChipIOUp_ROMCTR_FLA                                       0x00020000
#define ChipIOUp_ROMCTR_VPP                                       0x00010000

#define ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST                    hpFieldOffset(ChipIOUp_t,INTSTAT_INTEN_INTPEND_SOFTRST)

#define ChipIOUp_INTSTAT_MASK                                     0xFF000000
#define ChipIOUp_INTSTAT_Reserved                                 0xE0000000
#define ChipIOUp_INTSTAT_MPE                                      0x10000000
#define ChipIOUp_INTSTAT_CRS                                      0x08000000
#define ChipIOUp_INTSTAT_INT                                      0x04000000
#define ChipIOUp_INTSTAT_DER                                      0x02000000
#define ChipIOUp_INTSTAT_PER                                      0x01000000

#define ChipIOUp_INTEN_MASK                                       0x00FF0000
#define ChipIOUp_INTEN_Reserved                                   0x00E00000
#define ChipIOUp_INTEN_MPE                                        0x00100000
#define ChipIOUp_INTEN_CRS                                        0x00080000
#define ChipIOUp_INTEN_INT                                        0x00040000
#define ChipIOUp_INTEN_DER                                        0x00020000
#define ChipIOUp_INTEN_PER                                        0x00010000

#define ChipIOUp_INTPEND_MASK                                     0x0000FF00
#define ChipIOUp_INTPEND_Reserved                                 0x0000E000
#define ChipIOUp_INTPEND_MPE                                      0x00001000
#define ChipIOUp_INTPEND_CRS                                      0x00000800
#define ChipIOUp_INTPEND_INT                                      0x00000400
#define ChipIOUp_INTPEND_DER                                      0x00000200
#define ChipIOUp_INTPEND_PER                                      0x00000100

#define ChipIOUp_SOFTRST_MASK                                     0x000000FF
#define ChipIOUp_SOFTRST_Reserved                                 0x000000FC
#define ChipIOUp_SOFTRST_DPE                                      0x00000002
#define ChipIOUp_SOFTRST_RST                                      0x00000001

typedef struct ChipMem_s
               ChipMem_t;

#define ChipMem_t_SIZE                                     0x00000200

struct ChipMem_s {
                   ChipIOLo_t Lo;
                   ChipIOUp_t Up;
                 };

#define ChipMem_ERQ_Base                                          hpFieldOffset(ChipMem_t,Lo.ERQ_Base)

#define ChipMem_ERQ_Length                                        hpFieldOffset(ChipMem_t,Lo.ERQ_Length)

#define ChipMem_ERQ_Length_MASK                                   ChipIOLo_ERQ_Length_MASK
#define ChipMem_ERQ_Length_MIN                                    ChipIOLo_ERQ_Length_MIN
#define ChipMem_ERQ_Length_MAX                                    ChipIOLo_ERQ_Length_MAX
#define ChipMem_ERQ_Length_POWER_OF_2                             ChipIOLo_ERQ_Length_POWER_OF_2

#define ChipMem_ERQ_Producer_Index                                hpFieldOffset(ChipMem_t,Lo.ERQ_Producer_Index)

#define ChipMem_ERQ_Producer_Index_MASK                           ChipIOLo_ERQ_Producer_Index_MASK

#define ChipMem_ERQ_Consumer_Index_Address                        hpFieldOffset(ChipMem_t,Lo.ERQ_Consumer_Index_Address)

#define ChipMem_ERQ_Consumer_Index                                hpFieldOffset(ChipMem_t,Lo.ERQ_Consumer_Index)

#define ChipMem_ERQ_Consumer_Index_MASK                           ChipIOLo_ERQ_Consumer_Index_MASK

#define ChipMem_SFQ_Base                                          hpFieldOffset(ChipMem_t,Lo.SFQ_Base)

#define ChipMem_SFQ_Length                                        hpFieldOffset(ChipMem_t,Lo.SFQ_Length)

#define ChipMem_SFQ_Length_MASK                                   ChipIOLo_SFQ_Length_MASK
#define ChipMem_SFQ_Length_MIN                                    ChipIOLo_SFQ_Length_MIN
#define ChipMem_SFQ_Length_MAX                                    ChipIOLo_SFQ_Length_MAX
#define ChipMem_SFQ_Length_POWER_OF_2                             ChipIOLo_SFQ_Length_POWER_OF_2

#define ChipMem_SFQ_Consumer_Index                                hpFieldOffset(ChipMem_t,Lo.SFQ_Consumer_Index)

#define ChipMem_SFQ_Consumer_Index_MASK                           ChipIOLo_SFQ_Consumer_Index_MASK

#define ChipMem_IMQ_Base                                          hpFieldOffset(ChipMem_t,Lo.IMQ_Base)

#define ChipMem_IMQ_Length                                        hpFieldOffset(ChipMem_t,Lo.IMQ_Length)

#define ChipMem_IMQ_Length_MASK                                   ChipIOLo_IMQ_Length_MASK
#define ChipMem_IMQ_Length_MIN                                    ChipIOLo_IMQ_Length_MIN
#define ChipMem_IMQ_Length_MAX                                    ChipIOLo_IMQ_Length_MAX
#define ChipMem_IMQ_Length_POWER_OF_2                             ChipIOLo_IMQ_Length_POWER_OF_2

#define ChipMem_IMQ_Consumer_Index                                hpFieldOffset(ChipMem_t,Lo.IMQ_Consumer_Index)

#define ChipMem_IMQ_Consumer_Index_MASK                           ChipIOLo_IMQ_Consumer_Index_MASK

#define ChipMem_IMQ_Producer_Index_Address                        hpFieldOffset(ChipMem_t,Lo.IMQ_Producer_Index_Address)

#define ChipMem_SEST_Base                                         hpFieldOffset(ChipMem_t,Up.SEST_Base)

#define ChipMem_SEST_Length                                       hpFieldOffset(ChipMem_t,Up.SEST_Length)

#define ChipMem_SEST_Length_MASK                                  ChipIOUp_SEST_Length_MASK
#define ChipMem_SEST_Length_MIN                                   ChipIOUp_SEST_Length_MIN
#define ChipMem_SEST_Length_MAX                                   ChipIOUp_SEST_Length_MAX
#define ChipMem_SEST_Length_POWER_OF_2                            ChipIOUp_SEST_Length_POWER_OF_2

#define ChipMem_SEST_Linked_List_Head_Tail                        hpFieldOffset(ChipMem_t,Up.SEST_Linked_List_Head_Tail)

#define ChipMem_SEST_Linked_List_Head_MASK                        ChipIOUp_SEST_Linked_List_Head_MASK
#define ChipMem_SEST_Linked_List_Head_SHIFT                       ChipIOUp_SEST_Linked_List_Head_SHIFT
#define ChipMem_SEST_Linked_List_Tail_MASK                        ChipIOUp_SEST_Linked_List_Tail_MASK
#define ChipMem_SEST_Linked_List_Tail_SHIFT                       ChipIOUp_SEST_Linked_List_Tail_SHIFT
#define ChipMem_SEST_Linked_List_Tail_RESET_VALUE                 ChipIOUp_SEST_Linked_List_Tail_RESET_VALUE

#define ChipMem_ScatterGather_List_Page_Length                    hpFieldOffset(ChipMem_t,Up.ScatterGather_List_Page_Length)

#define ChipMem_ScatterGather_List_Page_Length_MASK               ChipIOUp_ScatterGather_List_Page_Length_MASK
#define ChipMem_ScatterGather_List_Page_Length_MIN                ChipIOUp_ScatterGather_List_Page_Length_MIN
#define ChipMem_ScatterGather_List_Page_Length_MAX                ChipIOUp_ScatterGather_List_Page_Length_MAX
#define ChipMem_ScatterGather_List_Page_Length_POWER_OF_2         ChipMem_ScatterGather_List_Page_Length_POWER_OF_2

#define ChipMem_My_ID                                             hpFieldOffset(ChipMem_t,Up.My_ID)

#define ChipMem_My_ID_MASK                                        ChipIOUp_My_ID_MASK

#define ChipMem_TachLite_Configuration                            hpFieldOffset(ChipMem_t,Up.TachLite_Configuration)

#define ChipMem_TachLite_Configuration_M66EN                      ChipIOUp_TachLite_Configuration_M66EN
#define ChipMem_TachLite_Configuration_OB_Thresh_MASK             ChipIOUp_TachLite_Configuration_OB_Thresh_MASK
#define ChipMem_TachLite_Configuration_OB_Thresh_100              ChipIOUp_TachLite_Configuration_OB_Thresh_100
#define ChipMem_TachLite_Configuration_OB_Thresh_132              ChipIOUp_TachLite_Configuration_OB_Thresh_132
#define ChipMem_TachLite_Configuration_OB_Thresh_150              ChipIOUp_TachLite_Configuration_OB_Thresh_150
#define ChipMem_TachLite_Configuration_OB_Thresh_200              ChipIOUp_TachLite_Configuration_OB_Thresh_200
#define ChipMem_TachLite_Configuration_OB_Thresh_264              ChipIOUp_TachLite_Configuration_OB_Thresh_264
#define ChipMem_TachLite_Configuration_OB_Thresh_528              ChipIOUp_TachLite_Configuration_OB_Thresh_528

#define ChipMem_Tachlite_Configuration_DAM                        ChipIOUp_TachLite_Configuration_DAM


/* XL only bits in the configuration register defined below */
#define ChipMem_Tachlite_Configuration_RDE                        ChipIOUp_Tachlite_Configuration_RDE
#define ChipMem_Tachlite_Configuration_SDF                        ChipIOUp_Tachlite_Configuration_SDF
#define ChipMem_Tachlite_Configuration_FC2                        ChipIOUp_Tachlite_Configuration_FC2 
#define ChipMem_Tachlite_Configuration_CAE                        ChipIOUp_Tachlite_Configuration_CAE
#define ChipMem_Tachlite_Configuration_SIC                        ChipIOUp_Tachlite_Configuration_SIC
#define ChipMem_Tachlite_Configuration_FAB                        ChipIOUp_Tachlite_Configuration_FAB
#define ChipMem_Tachlite_Configuration_FUA                        ChipIOUp_Tachlite_Configuration_FUA 
#define ChipMem_Tachlite_Configuration_DOF                        ChipIOUp_Tachlite_Configuration_DOF 
#define ChipMem_Tachlite_Configuration_INO                        ChipIOUp_Tachlite_Configuration_INO
#define ChipMem_TachLite_Configuration_SIC                        ChipIOUp_TachLite_Configuration_SIC
#define ChipMem_TachLite_Configuration_FAD                        ChipIOUp_TachLite_Configuration_FAD

#define ChipMem_TachLite_Control                                  hpFieldOffset(ChipMem_t,Up.TachLite_Control)

#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_ROF                              ChipIOUp_TachLite_Control_ROF
#define ChipMem_TachLite_Control_RIF                              ChipIOUp_TachLite_Control_RIF
#define ChipMem_TachLite_Control_REQ                              ChipIOUp_TachLite_Control_REQ
#define ChipMem_TachLite_Control_FIS                              ChipIOUp_TachLite_Control_FIS
#define ChipMem_TachLite_Control_FFA                              ChipIOUp_TachLite_Control_FFA
#define ChipMem_TachLite_Control_FEQ                              ChipIOUp_TachLite_Control_FEQ
#define ChipMem_TachLite_Control_GP4                              ChipIOUp_TachLite_Control_GP4
#define ChipMem_TachLite_Control_GP3                              ChipIOUp_TachLite_Control_GP3
#define ChipMem_TachLite_Control_GP2                              ChipIOUp_TachLite_Control_GP2
#define ChipMem_TachLite_Control_GP1                              ChipIOUp_TachLite_Control_GP1
#define ChipMem_TachLite_Control_GP0                              ChipIOUp_TachLite_Control_GP0
#define ChipMem_TachLite_Control_GPIO_0_3_MASK                    ChipIOUp_TachLite_Control_GPIO_0_3_MASK
#define ChipMem_TachLite_Control_GPIO_ALL_MASK                    ChipIOUp_TachLite_Control_GPIO_ALL_MASK


/* XL only bits in the control register */

#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_ROF                              ChipIOUp_TachLite_Control_ROF
#define ChipMem_TachLite_Control_RIF                              ChipIOUp_TachLite_Control_RIF
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS
#define ChipMem_TachLite_Control_CRS                              ChipIOUp_TachLite_Control_CRS


#define ChipMem_TachLite_Status                                   hpFieldOffset(ChipMem_t,Up.TachLite_Status)

#define ChipMem_TachLite_Status_SFF                               ChipIOUp_TachLite_Status_SFF
#define ChipMem_TachLite_Status_IMF                               ChipIOUp_TachLite_Status_IMF
#define ChipMem_TachLite_Status_OFE                               ChipIOUp_TachLite_Status_OFE
#define ChipMem_TachLite_Status_IFE                               ChipIOUp_TachLite_Status_IFE
#define ChipMem_TachLite_Status_OFF                               ChipIOUp_TachLite_Status_OFF
#define ChipMem_TachLite_Status_IFF                               ChipIOUp_TachLite_Status_IFF
#define ChipMem_TachLite_Status_EQF                               ChipIOUp_TachLite_Status_EQF
#define ChipMem_TachLite_Status_Stop_Cnt_MASK                     ChipIOUp_TachLite_Status_Stop_Cnt_MASK
#define ChipMem_TachLite_Status_OPE                               ChipIOUp_TachLite_Status_OPE
#define ChipMem_TachLite_Status_IPE                               ChipIOUp_TachLite_Status_IPE
#define ChipMem_TachLite_Status_REVID_MASK                        ChipIOUp_TachLite_Status_REVID_MASK
#define ChipMem_TachLite_Status_REVID_SHIFT                       ChipIOUp_TachLite_Status_REVID_SHIFT
#define ChipMem_TachLite_Status_GP4                               ChipIOUp_TachLite_Status_GP4
#define ChipMem_TachLite_Status_GP3                               ChipIOUp_TachLite_Status_GP3
#define ChipMem_TachLite_Status_GP2                               ChipIOUp_TachLite_Status_GP2
#define ChipMem_TachLite_Status_GP1                               ChipIOUp_TachLite_Status_GP1
#define ChipMem_TachLite_Status_GP0                               ChipIOUp_TachLite_Status_GP0
#define ChipMem_TachLite_Status_GPIO_0_3_MASK                     ChipIOUp_TachLite_Status_GPIO_0_3_MASK
#define ChipMem_TachLite_Status_GPIO_ALL_MASK                     ChipIOUp_TachLite_Status_GPIO_ALL_MASK
#define ChipMem_TachLite_Status_OLE                               ChipIOUp_TachLite_Status_OLE 
#define ChipMem_TachLite_Status_ILE                               ChipIOUp_TachLite_Status_ILE  
#define ChipMem_TachLite_Status_M66                               ChipIOUp_TachLite_Status_M66   


#define ChipMem_Inbound_Resource_Status                           hpFieldOffset(ChipMem_t,Up.Inbound_Resource_Status)

#define ChipMem_Inbound_Resource_Status_SEST_LRU_Count_MASK       ChipIOUp_Inbound_Resource_Status_SEST_LRU_Count_MASK
#define ChipMem_Inbound_Resource_Status_SEST_LRU_Count_SHIFT      ChipIOUp_Inbound_Resource_Status_SEST_LRU_Count_SHIFT

#define ChipMem_Frame_Manager_Configuration                       hpFieldOffset(ChipMem_t,Up.Frame_Manager_Configuration)

#define ChipMem_Frame_Manager_Configuration_AL_PA_MASK            ChipIOUp_Frame_Manager_Configuration_AL_PA_MASK
#define ChipMem_Frame_Manager_Configuration_AL_PA_SHIFT           ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT
#define ChipMem_Frame_Manager_Configuration_BB_Credit_MASK        ChipIOUp_Frame_Manager_Configuration_BB_Credit_MASK
#define ChipMem_Frame_Manager_Configuration_BB_Credit_SHIFT       ChipIOUp_Frame_Manager_Configuration_BB_Credit_SHIFT
#define ChipMem_Frame_Manager_Configuration_NPI                   ChipIOUp_Frame_Manager_Configuration_NPI
#define ChipMem_Frame_Manager_Configuration_ILB                   ChipIOUp_Frame_Manager_Configuration_ILB
#define ChipMem_Frame_Manager_Configuration_ELB                   ChipIOUp_Frame_Manager_Configuration_ELB
#define ChipMem_Frame_Manager_Configuration_TD                    ChipIOUp_Frame_Manager_Configuration_TD
#define ChipMem_Frame_Manager_Configuration_FA                    ChipIOUp_Frame_Manager_Configuration_FA
#define ChipMem_Frame_Manager_Configuration_AQ                    ChipIOUp_Frame_Manager_Configuration_AQ
#define ChipMem_Frame_Manager_Configuration_HA                    ChipIOUp_Frame_Manager_Configuration_HA
#define ChipMem_Frame_Manager_Configuration_SA                    ChipIOUp_Frame_Manager_Configuration_SA
#define ChipMem_Frame_Manager_Configuration_BLM                   ChipIOUp_Frame_Manager_Configuration_BLM
#define ChipMem_Frame_Manager_Configuration_RF                    ChipIOUp_Frame_Manager_Configuration_RF
#define ChipMem_Frame_Manager_Configuration_IF                    ChipIOUp_Frame_Manager_Configuration_IF
#define ChipMem_Frame_Manager_Configuration_LR                    ChipIOUp_Frame_Manager_Configuration_LR
#define ChipMem_Frame_Manager_Configuration_ENP                   ChipIOUp_Frame_Manager_Configuration_ENP
#define ChipMem_Frame_Manager_Configuration_BLI                   ChipIOUp_Frame_Manager_Configuration_BLI

#define ChipMem_Frame_Manager_Control                             hpFieldOffset(ChipMem_t,Up.Frame_Manager_Control)

#define ChipMem_Frame_Manager_Control_SAS                         ChipIOUp_Frame_Manager_Control_SAS
#define ChipMem_Frame_Manager_Control_SQ                          ChipIOUp_Frame_Manager_Control_SQ
#define ChipMem_Frame_Manager_Control_SP                          ChipIOUp_Frame_Manager_Control_SP
#define ChipMem_Frame_Manager_Control_CL                          ChipIOUp_Frame_Manager_Control_CL
#define ChipMem_Frame_Manager_Control_CMD_MASK                    ChipIOUp_Frame_Manager_Control_CMD_MASK
#define ChipMem_Frame_Manager_Control_CMD_NOP                     ChipIOUp_Frame_Manager_Control_CMD_NOP
#define ChipMem_Frame_Manager_Control_CMD_Exit_Loop               ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop
#define ChipMem_Frame_Manager_Control_CMD_Host_Control            ChipIOUp_Frame_Manager_Control_CMD_Host_Control
#define ChipMem_Frame_Manager_Control_CMD_Exit_Host_Control       ChipIOUp_Frame_Manager_Control_CMD_Exit_Host_Control
#define ChipMem_Frame_Manager_Control_CMD_Link_Reset              ChipIOUp_Frame_Manager_Control_CMD_Link_Reset
#define ChipMem_Frame_Manager_Control_CMD_Offline                 ChipIOUp_Frame_Manager_Control_CMD_Offline
#define ChipMem_Frame_Manager_Control_CMD_Initialize              ChipIOUp_Frame_Manager_Control_CMD_Initialize
#define ChipMem_Frame_Manager_Control_CMD_Clear_LF                ChipIOUp_Frame_Manager_Control_CMD_Clear_LF

#define ChipMem_Frame_Manager_Status                              hpFieldOffset(ChipMem_t,Up.Frame_Manager_Status)

#define ChipMem_Frame_Manager_Status_LP                           ChipIOUp_Frame_Manager_Status_LP
#define ChipMem_Frame_Manager_Status_TP                           ChipIOUp_Frame_Manager_Status_TP
#define ChipMem_Frame_Manager_Status_NP                           ChipIOUp_Frame_Manager_Status_NP
#define ChipMem_Frame_Manager_Status_BYP                          ChipIOUp_Frame_Manager_Status_BYP
#define ChipMem_Frame_Manager_Status_FLT                          ChipIOUp_Frame_Manager_Status_FLT
#define ChipMem_Frame_Manager_Status_OS                           ChipIOUp_Frame_Manager_Status_OS
#define ChipMem_Frame_Manager_Status_LS                           ChipIOUp_Frame_Manager_Status_LS
#define ChipMem_Frame_Manager_Status_LPE                          ChipIOUp_Frame_Manager_Status_LPE
#define ChipMem_Frame_Manager_Status_LPB                          ChipIOUp_Frame_Manager_Status_LPB
#define ChipMem_Frame_Manager_Status_OLS                          ChipIOUp_Frame_Manager_Status_OLS
#define ChipMem_Frame_Manager_Status_LST                          ChipIOUp_Frame_Manager_Status_LST
#define ChipMem_Frame_Manager_Status_LPF                          ChipIOUp_Frame_Manager_Status_LPF
#define ChipMem_Frame_Manager_Status_BA                           ChipIOUp_Frame_Manager_Status_BA
#define ChipMem_Frame_Manager_Status_PRX                          ChipIOUp_Frame_Manager_Status_PRX
#define ChipMem_Frame_Manager_Status_PTX                          ChipIOUp_Frame_Manager_Status_PTX
#define ChipMem_Frame_Manager_Status_LG                           ChipIOUp_Frame_Manager_Status_LG
#define ChipMem_Frame_Manager_Status_LF                           ChipIOUp_Frame_Manager_Status_LF
#define ChipMem_Frame_Manager_Status_CE                           ChipIOUp_Frame_Manager_Status_CE
#define ChipMem_Frame_Manager_Status_EW                           ChipIOUp_Frame_Manager_Status_EW
#define ChipMem_Frame_Manager_Status_LUP                          ChipIOUp_Frame_Manager_Status_LUP
#define ChipMem_Frame_Manager_Status_LDN                          ChipIOUp_Frame_Manager_Status_LDN
#define ChipMem_Frame_Manager_Status_LSM_MASK                     ChipIOUp_Frame_Manager_Status_LSM_MASK
#define ChipMem_Frame_Manager_Status_LSM_Monitor                  ChipIOUp_Frame_Manager_Status_LSM_Monitor
#define ChipMem_Frame_Manager_Status_LSM_ARB                      ChipIOUp_Frame_Manager_Status_LSM_ARB
#define ChipMem_Frame_Manager_Status_LSM_ARB_Won                  ChipIOUp_Frame_Manager_Status_LSM_ARB_Won
#define ChipMem_Frame_Manager_Status_LSM_Open                     ChipIOUp_Frame_Manager_Status_LSM_Open
#define ChipMem_Frame_Manager_Status_LSM_Opened                   ChipIOUp_Frame_Manager_Status_LSM_Opened
#define ChipMem_Frame_Manager_Status_LSM_Xmit_CLS                 ChipIOUp_Frame_Manager_Status_LSM_Xmit_CLS
#define ChipMem_Frame_Manager_Status_LSM_Rx_CLS                   ChipIOUp_Frame_Manager_Status_LSM_Rx_CLS
#define ChipMem_Frame_Manager_Status_LSM_Xfer                     ChipIOUp_Frame_Manager_Status_LSM_Xfer
#define ChipMem_Frame_Manager_Status_LSM_Initialize               ChipIOUp_Frame_Manager_Status_LSM_Initialize
#define ChipMem_Frame_Manager_Status_LSM_O_I_Init_Finish          ChipIOUp_Frame_Manager_Status_LSM_O_I_Init_Finish
#define ChipMem_Frame_Manager_Status_LSM_O_I_Protocol             ChipIOUp_Frame_Manager_Status_LSM_O_I_Protocol
#define ChipMem_Frame_Manager_Status_LSM_O_I_Lip_Received         ChipIOUp_Frame_Manager_Status_LSM_O_I_Lip_Received
#define ChipMem_Frame_Manager_Status_LSM_Host_Control             ChipIOUp_Frame_Manager_Status_LSM_Host_Control
#define ChipMem_Frame_Manager_Status_LSM_Loop_Fail                ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail
#define ChipMem_Frame_Manager_Status_LSM_Offline                  ChipIOUp_Frame_Manager_Status_LSM_Offline
#define ChipMem_Frame_Manager_Status_LSM_Old_Port                 ChipIOUp_Frame_Manager_Status_LSM_Old_Port
#define ChipMem_Frame_Manager_Status_PSM_MASK                     ChipIOUp_Frame_Manager_Status_PSM_MASK
#define ChipMem_Frame_Manager_Status_PSM_Offline                  ChipIOUp_Frame_Manager_Status_PSM_Offline
#define ChipMem_Frame_Manager_Status_PSM_OL1                      ChipIOUp_Frame_Manager_Status_PSM_OL1
#define ChipMem_Frame_Manager_Status_PSM_OL2                      ChipIOUp_Frame_Manager_Status_PSM_OL2
#define ChipMem_Frame_Manager_Status_PSM_OL3                      ChipIOUp_Frame_Manager_Status_PSM_OL3
#define ChipMem_Frame_Manager_Status_PSM_Reserved_1               ChipIOUp_Frame_Manager_Status_PSM_Reserved_1
#define ChipMem_Frame_Manager_Status_PSM_LR1                      ChipIOUp_Frame_Manager_Status_PSM_LR1
#define ChipMem_Frame_Manager_Status_PSM_LR2                      ChipIOUp_Frame_Manager_Status_PSM_LR2
#define ChipMem_Frame_Manager_Status_PSM_LR3                      ChipIOUp_Frame_Manager_Status_PSM_LR3
#define ChipMem_Frame_Manager_Status_PSM_Reserved_2               ChipIOUp_Frame_Manager_Status_PSM_Reserved_2
#define ChipMem_Frame_Manager_Status_PSM_LF1                      ChipIOUp_Frame_Manager_Status_PSM_LF1
#define ChipMem_Frame_Manager_Status_PSM_LF2                      ChipIOUp_Frame_Manager_Status_PSM_LF2
#define ChipMem_Frame_Manager_Status_PSM_Reserved_3               ChipIOUp_Frame_Manager_Status_PSM_Reserved_3
#define ChipMem_Frame_Manager_Status_PSM_Reserved_4               ChipIOUp_Frame_Manager_Status_PSM_Reserved_4
#define ChipMem_Frame_Manager_Status_PSM_Reserved_5               ChipIOUp_Frame_Manager_Status_PSM_Reserved_5
#define ChipMem_Frame_Manager_Status_PSM_Reserved_6               ChipIOUp_Frame_Manager_Status_PSM_Reserved_6
#define ChipMem_Frame_Manager_Status_PSM_ACTIVE                   ChipIOUp_Frame_Manager_Status_PSM_ACTIVE

#define ChipMem_Frame_Manager_TimeOut_Values_1                    hpFieldOffset(ChipMem_t,Up.Frame_Manager_TimeOut_Values_1)

#define ChipMem_Frame_Manager_TimeOut_Values_1_RT_TOV_MASK        ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_MASK
#define ChipMem_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT       ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_SHIFT
#define ChipMem_Frame_Manager_TimeOut_Values_1_RT_TOV_100ms       ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_100ms
#define ChipMem_Frame_Manager_TimeOut_Values_1_RT_TOV_Default     ChipIOUp_Frame_Manager_TimeOut_Values_1_RT_TOV_Default
#define ChipMem_Frame_Manager_TimeOut_Values_1_ED_TOV_MASK        ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_MASK
#define ChipMem_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT       ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT
#define ChipMem_Frame_Manager_TimeOut_Values_1_ED_TOV_500ms       ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_500ms
#define ChipMem_Frame_Manager_TimeOut_Values_1_ED_TOV_Default     ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_Default

#define ChipMem_Frame_Manager_Link_Status_1                       hpFieldOffset(ChipMem_t,Up.Frame_Manager_Link_Status_1)

#define ChipMem_Frame_Manager_Link_Status_1_Loss_of_Signal_MASK   ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_MASK
#define ChipMem_Frame_Manager_Link_Status_1_Loss_of_Signal_SHIFT  ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_SHIFT
#define ChipMem_Frame_Manager_Link_Status_1_Bad_RX_Char_MASK      ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_MASK
#define ChipMem_Frame_Manager_Link_Status_1_Bad_RX_Char_SHIFT     ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_SHIFT
#define ChipMem_Frame_Manager_Link_Status_1_Loss_of_Sync_MASK     ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_MASK
#define ChipMem_Frame_Manager_Link_Status_1_Loss_of_Sync_SHIFT    ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_SHIFT
#define ChipMem_Frame_Manager_Link_Status_1_Link_Fail_MASK        ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_MASK
#define ChipMem_Frame_Manager_Link_Status_1_Link_Fail_SHIFT       ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_SHIFT

#define ChipMem_Frame_Manager_Link_Status_2                       hpFieldOffset(ChipMem_t,Up.Frame_Manager_Link_Status_2)

#define ChipMem_Frame_Manager_Link_Status_2_Rx_EOFa_MASK          ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_MASK
#define ChipMem_Frame_Manager_Link_Status_2_Rx_EOFa_SHIFT         ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_SHIFT
#define ChipMem_Frame_Manager_Link_Status_2_Dis_Frm_MASK          ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_MASK
#define ChipMem_Frame_Manager_Link_Status_2_Dis_Frm_SHIFT         ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_SHIFT
#define ChipMem_Frame_Manager_Link_Status_2_Bad_CRC_MASK          ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_MASK
#define ChipMem_Frame_Manager_Link_Status_2_Bad_CRC_SHIFT         ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_SHIFT
#define ChipMem_Frame_Manager_Link_Status_2_Proto_Err_MASK        ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_MASK
#define ChipMem_Frame_Manager_Link_Status_2_Proto_Err_SHIFT       ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_SHIFT

#define ChipMem_Frame_Manager_TimeOut_Values_2                    hpFieldOffset(ChipMem_t,Up.Frame_Manager_TimeOut_Values_2)

#define ChipMem_Frame_Manager_TimeOut_Values_2_LP_TOV_MASK        ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_MASK
#define ChipMem_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT       ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_SHIFT
#define ChipMem_Frame_Manager_TimeOut_Values_2_LP_TOV_2s          ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_2s
#define ChipMem_Frame_Manager_TimeOut_Values_2_LP_TOV_Default     ChipIOUp_Frame_Manager_TimeOut_Values_2_LP_TOV_Default
#define ChipMem_Frame_Manager_TimeOut_Values_2_AL_Time_MASK       ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_MASK
#define ChipMem_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT      ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_SHIFT
#define ChipMem_Frame_Manager_TimeOut_Values_2_AL_Time_15ms       ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_15ms
#define ChipMem_Frame_Manager_TimeOut_Values_2_AL_Time_Default    ChipIOUp_Frame_Manager_TimeOut_Values_2_AL_Time_Default

#define ChipMem_Frame_Manager_BBCredit_Zero_Timer                 hpFieldOffset(ChipMem_t,Up.Frame_Manager_BBCredit_Zero_Timer)

#define ChipMem_Frame_Manager_BBCredit_Zero_Timer_MASK            ChipIOUp_Frame_Manager_BBCredit_Zero_Timer_MASK

#define ChipMem_Frame_Manager_World_Wide_Name_High                hpFieldOffset(ChipMem_t,Up.Frame_Manager_World_Wide_Name_High)

#define ChipMem_Frame_Manager_World_Wide_Name_Low                 hpFieldOffset(ChipMem_t,Up.Frame_Manager_World_Wide_Name_Low)

#define ChipMem_Frame_Manager_Received_ALPA                       hpFieldOffset(ChipMem_t,Up.Frame_Manager_Received_ALPA)

#define ChipMem_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK         ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK
#define ChipMem_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT        ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT
#define ChipMem_Frame_Manager_Received_ALPA_Bad_ALPA_MASK         ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_MASK
#define ChipMem_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT        ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT
#define ChipMem_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK        ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK
#define ChipMem_Frame_Manager_Received_ALPA_LIPf_ALPA_SHIFT       ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_SHIFT

#define ChipMem_Frame_Manager_Primitive                           hpFieldOffset(ChipMem_t,Up.Frame_Manager_Primitive)

#define ChipMem_Frame_Manager_Primitive_MASK                      ChipIOUp_Frame_Manager_Primitive_MASK

#define ChipMem_PCIMCTR__ROMCTR__Reserved_8__Reserved_9           hpFieldOffset(ChipMem_t,Up.PCIMCTR__ROMCTR__Reserved_8__Reserved_9)

#define ChipMem_PCIMCTR_MASK                                      ChipIOUp_PCIMCTR_MASK
#define ChipMem_PCIMCTL_P64                                       ChipIOUp_PCIMCTL_P64

#define ChipMem_ROMCTR_MASK                                       ChipIOUp_ROMCTR_MASK
#define ChipMem_ROMCTR_PAR                                        ChipIOUp_ROMCTR_PAR
#define ChipMem_ROMCTR_SVL                                        ChipIOUp_ROMCTR_SVL
#define ChipMem_ROMCTR_256                                        ChipIOUp_ROMCTR_256
#define ChipMem_ROMCTR_128                                        ChipIOUp_ROMCTR_128
#define ChipMem_ROMCTR_ROM                                        ChipIOUp_ROMCTR_ROM
#define ChipMem_ROMCTR_FLA                                        ChipIOUp_ROMCTR_FLA
#define ChipMem_ROMCTR_VPP                                        ChipIOUp_ROMCTR_VPP

#define ChipMem_INTSTAT_INTEN_INTPEND_SOFTRST                     hpFieldOffset(ChipMem_t,Up.INTSTAT_INTEN_INTPEND_SOFTRST)

#define ChipMem_INTSTAT_MASK                                      ChipIOUp_INTSTAT_MASK
#define ChipMem_INTSTAT_Reserved                                  ChipIOUp_INTSTAT_Reserved
#define ChipMem_INTSTAT_MPE                                       ChipIOUp_INTSTAT_MPE
#define ChipMem_INTSTAT_CRS                                       ChipIOUp_INTSTAT_CRS
#define ChipMem_INTSTAT_INT                                       ChipIOUp_INTSTAT_INT
#define ChipMem_INTSTAT_DER                                       ChipIOUp_INTSTAT_DER
#define ChipMem_INTSTAT_PER                                       ChipIOUp_INTSTAT_PER

#define ChipMem_INTEN_MASK                                        ChipIOUp_INTEN_MASK
#define ChipMem_INTEN_Reserved                                    ChipIOUp_INTEN_Reserved
#define ChipMem_INTEN_MPE                                         ChipIOUp_INTEN_MPE
#define ChipMem_INTEN_CRS                                         ChipIOUp_INTEN_CRS
#define ChipMem_INTEN_INT                                         ChipIOUp_INTEN_INT
#define ChipMem_INTEN_DER                                         ChipIOUp_INTEN_DER
#define ChipMem_INTEN_PER                                         ChipIOUp_INTEN_PER

#define ChipMem_INTPEND_MASK                                      ChipIOUp_INTPEND_MASK
#define ChipMem_INTPEND_Reserved                                  ChipIOUp_INTPEND_Reserved
#define ChipMem_INTPEND_MPE                                       ChipIOUp_INTPEND_MPE
#define ChipMem_INTPEND_CRS                                       ChipIOUp_INTPEND_CRS
#define ChipMem_INTPEND_INT                                       ChipIOUp_INTPEND_INT
#define ChipMem_INTPEND_DER                                       ChipIOUp_INTPEND_DER
#define ChipMem_INTPEND_PER                                       ChipIOUp_INTPEND_PER

#define ChipMem_SOFTRST_MASK                                      ChipIOUp_SOFTRST_MASK
#define ChipMem_SOFTRST_Reserved                                  ChipIOUp_SOFTRST_Reserved
#define ChipMem_SOFTRST_DPE                                       ChipIOUp_SOFTRST_DPE
#define ChipMem_SOFTRST_RST                                       ChipIOUp_SOFTRST_RST

/*+
ERQ Producer/Consumer Index Types
-*/

typedef os_bit32 ERQProdIndex_t;
typedef os_bit32 ERQConsIndex_t;

#define ERQProdIndex_t_SIZE                                0x00000004
#define ERQConsIndex_t_SIZE                                0x00000004

/*+
IMQ Producer/Consumer Index Types
-*/

typedef os_bit32 IMQProdIndex_t;
typedef os_bit32 IMQConsIndex_t;

#define IMQProdIndex_t_SIZE                                0x00000004
#define IMQConsIndex_t_SIZE                                0x00000004

/*+
SFQ Producer/Consumer Index Types
-*/

typedef os_bit32 SFQProdIndex_t;
typedef os_bit32 SFQConsIndex_t;

#define SFQProdIndex_t_SIZE                                0x00000004
#define SFQConsIndex_t_SIZE                                0x00000004

/*+
Configuration Parameters
-*/

#define TachyonXL_Max_Frame_Payload           0x0800
#define TachyonTL_Max_Frame_Payload           0x3F0  /* 0x0400 */
#define TachyonTL_BB_Credit                     0x00
#define TachyonTL_Nport_BB_Credit               0x04
#define TachyonTL_Total_Concurrent_Sequences    0xFF
#define TachyonTL_Open_Sequences_per_Exchange 0x0001
#define TachyonTL_RO_Valid_by_Category        ( FC_N_Port_Common_Parms_RO_Valid_for_Category_0111 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0110 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0101 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0100 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0011 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0010 | \
                                                FC_N_Port_Common_Parms_RO_Valid_for_Category_0001 )


/*+
Fibre Channel Header Structure (FCHS)
-*/

typedef struct FCHS_s
               FCHS_t;

#define FCHS_t_SIZE                                        0x00000020

struct FCHS_s
       {
         os_bit32 MBZ1;
         os_bit32 SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp;
         os_bit32 R_CTL__D_ID;
         os_bit32 CS_CTL__S_ID;
         os_bit32 TYPE__F_CTL;
         os_bit32 SEQ_ID__DF_CTL__SEQ_CNT;
         os_bit32 OX_ID__RX_ID;
         os_bit32 RO;
       };

#define FCHS_SOF_MASK        0xF0000000
#define FCHS_SOF_SOFc1       0x30000000
#define FCHS_SOF_SOFi1       0x50000000
#define FCHS_SOF_SOFi2       0x60000000
#define FCHS_SOF_SOFi3       0x70000000
#define FCHS_SOF_SOFt        0x80000000
#define FCHS_SOF_SOFn1       0x90000000
#define FCHS_SOF_SOFn2       0xA0000000
#define FCHS_SOF_SOFn3       0xB0000000

#define FCHS_EOF_MASK        0x0F000000
#define FCHS_EOF_EOFdt       0x01000000
#define FCHS_EOF_EOFdti      0x02000000
#define FCHS_EOF_EOFni       0x03000000
#define FCHS_EOF_EOFa        0x04000000
#define FCHS_EOF_EOFn        0x05000000
#define FCHS_EOF_EOFt        0x06000000

#define FCHS_MBZ2_MASK       0x00FF8000

#define FCHS_UAM             0x00004000

#define FCHS_CLS             0x00002000

#define FCHS_LCr_MASK        0x00001C00
#define FCHS_LCr_SHIFT             0x0A

#define FCHS_MBZ3_MASK       0x00000200

#define FCHS_TFV             0x00000100

#define FCHS_Timestamp_MASK  0x000000FF
#define FCHS_Timestamp_SHIFT       0x00

#define FCHS_R_CTL_MASK      0xFF000000
#define FCHS_R_CTL_SHIFT           0x18

#define FCHS_D_ID_MASK       0x00FFFFFF
#define FCHS_D_ID_SHIFT            0x00

#define FCHS_CS_CTL_MASK     0xFF000000
#define FCHS_CS_CTL_SHIFT          0x18

#define FCHS_S_ID_MASK       0x00FFFFFF
#define FCHS_S_ID_SHIFT            0x00

#define FCHS_TYPE_MASK       0xFF000000
#define FCHS_TYPE_SHIFT            0x18

#define FCHS_F_CTL_MASK      0x00FFFFFF
#define FCHS_F_CTL_SHIFT           0x00

#define FCHS_SEQ_ID_MASK     0xFF000000
#define FCHS_SEQ_ID_SHIFT          0x18

#define FCHS_DF_CTL_MASK     0x00FF0000
#define FCHS_DF_CTL_SHIFT          0x10

#define FCHS_SEQ_CNT_MASK    0x0000FFFF
#define FCHS_SEQ_CNT_SHIFT         0x00

#define FCHS_OX_ID_MASK      0xFFFF0000
#define FCHS_OX_ID_SHIFT           0x10

#define FCHS_RX_ID_MASK      0x0000FFFF
#define FCHS_RX_ID_SHIFT           0x00

/*+
ExchangeID type (OX_ID or RX_ID)
-*/

#define X_ID_Invalid        0xFFFF
#define X_ID_ReadWrite_MASK 0x8000
#define X_ID_Read           0x8000
#define X_ID_Write          0x0000

typedef os_bit16 X_ID_t;

#define X_ID_t_SIZE                                        0x00000002

/*+
Scatter-Gather List Element (Local or Extended)
-*/

typedef struct SG_Element_s
               SG_Element_t;

#define SG_Element_t_SIZE                                  0x00000008

struct SG_Element_s
       {
         os_bit32 U32_Len;
         os_bit32 L32;
       };

#define SG_Element_U32_MASK       0xFFF80000
#define SG_Element_U32_SHIFT            0x13

#define SG_Element_Len_MASK       0x0007FFFF
#define SG_Element_Len_SHIFT            0x00
#define SG_Element_Len_MAX        0x0007FFF0

#define SG_Element_Chain_Res_MASK 0x80000000

/*+
Unknown SEST Entry ("USE")
-*/

typedef struct USE_s
               USE_t;

#define USE_t_SIZE                                         0x00000040

struct USE_s
       {
         os_bit32        Bits;
         os_bit32        Unused_DWord_1;
         os_bit32        Unused_DWord_2;
         os_bit32        Unused_DWord_3;
         os_bit32        LOC;
         os_bit32        Unused_DWord_5;
         os_bit32        Unused_DWord_6;
         os_bit32        Unused_DWord_7;
         os_bit32        Unused_DWord_8;
         os_bit32        Unused_DWord_9;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define USE_VAL                 0x80000000

#define USE_DIR                 0x40000000

#define USE_INI                 0x08000000

#define USE_Entry_Type_MASK     (USE_DIR | USE_INI)
#define USE_Entry_Type_IWE      USE_INI
#define USE_Entry_Type_IRE      (USE_DIR | USE_INI)
#define USE_Entry_Type_TWE      USE_DIR
#define USE_Entry_Type_TRE      0

#define USE_LOC                 0x80000000

#define USE_First_SG_Offset     (hpFieldOffset(USE_t,First_SG))

#define USE_Number_of_Local_SGs ((sizeof(USE_t) - USE_First_SG_Offset)/sizeof(SG_Element_t))

/*+
Initiator Write Entry (IWE)
-*/

typedef struct IWE_s
               IWE_t;

#define IWE_t_SIZE                                         0x00000040

struct IWE_s
       {
         os_bit32        Bits__MBZ1__LNK__MBZ2__FL__MBZ3__Hdr_Len;
         os_bit32        Hdr_Addr;
         os_bit32        Remote_Node_ID__RSP_Len;
         os_bit32        RSP_Addr;
         os_bit32        LOC__0xF__MBZ4__Buff_Off;
         os_bit32        Buff_Index__Link;
         os_bit32        MBZ5__RX_ID;
         os_bit32        Data_Len;
         os_bit32        Exp_RO;
         os_bit32        Exp_Byte_Cnt;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define IWE_VAL                  0x80000000

#define IWE_DIR                  0x40000000

#define IWE_DCM                  0x20000000

#define IWE_DIN                  0x10000000

#define IWE_INI                  0x08000000

#define IWE_DAT                  0x04000000

#define IWE_RSP                  0x02000000

#define IWE_CTS                  0x01000000

#define IWE_DUR                  0x00800000

#define IWE_MBZ1_MASK            0x00600000

#define IWE_LNK                  0x00100000

#define IWE_MBZ2_MASK            0x000C0000

#define IWE_FL_MASK              0x00030000
#define IWE_FL_128_Bytes         0x00000000
#define IWE_FL_512_Bytes         0x00010000
#define IWE_FL_1024_Bytes        0x00020000
#define IWE_FL_2048_Bytes        0x00030000

#define IWE_MBZ3_MASK            0x0000F000

#define IWE_Hdr_Len_MASK         0x00000FFF
#define IWE_Hdr_Len_SHIFT              0x00

#define IWE_Remote_Node_ID_MASK  0xFFFFFF00
#define IWE_Remote_Node_ID_SHIFT       0x08

#define IWE_RSP_Len_MASK         0x000000FF
#define IWE_RSP_Len_SHIFT              0x00

#define IWE_LOC                  0x80000000

#define IWE_0xF_MASK             0x78000000
#define IWE_0xF_ALWAYS           0x78000000

#define IWE_MBZ4_MASK            0x07F80000

#define IWE_Buff_Off_MASK        0x0007FFFF
#define IWE_Buff_Off_SHIFT             0x00

#define IWE_Buff_Index_MASK      0xFFFF0000
#define IWE_Buff_Index_SHIFT           0x10

#define IWE_Link_MASK            0x0000FFFF
#define IWE_Link_SHIFT                 0x00
#define IWE_Link_Initializer     0x0000FFFF

#define IWE_MBZ5_MASK            0xFFFF0000

#define IWE_RX_ID_MASK           0x0000FFFF
#define IWE_RX_ID_SHIFT                0x00

/*+
Initiator Read Entry (IRE)
-*/

typedef struct IRE_s
               IRE_t;

#define IRE_t_SIZE                                         0x00000040

struct IRE_s
       {
         os_bit32        Bits_MBZ1_EQL_MBZ2;
         os_bit32        MBZ3;
         os_bit32        Remote_Node_ID__RSP_Len;
         os_bit32        RSP_Addr;
         os_bit32        LOC__MBZ4__Buff_Off;
         os_bit32        Buff_Index__MBZ5;
         os_bit32        Exp_RO;
         os_bit32        Byte_Count;
         os_bit32        MBZ6;
         os_bit32        Exp_Byte_Cnt;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define IRE_VAL                  0x80000000

#define IRE_DIR                  0x40000000

#define IRE_DCM                  0x20000000

#define IRE_DIN                  0x10000000

#define IRE_INI                  0x08000000

#define IRE_DAT                  0x04000000

#define IRE_RSP                  0x02000000

#define IRE_MBZ1_MASK            0x01F00000

#define IRE_EQL                  0x00080000

#define IRE_MBZ2_MASK            0x0007FFFF

#define IRE_Remote_Node_ID_MASK  0xFFFFFF00
#define IRE_Remote_Node_ID_SHIFT       0x08

#define IRE_RSP_Len_MASK         0x000000FF
#define IRE_RSP_Len_SHIFT              0x00

#define IRE_LOC                  0x80000000

#define IRE_MBZ4_MASK            0x7FF80000

#define IRE_Buff_Off_MASK        0x0007FFFF
#define IRE_Buff_Off_SHIFT             0x00

#define IRE_Buff_Index_MASK      0xFFFF0000
#define IRE_Buff_Index_SHIFT           0x10

#define IRE_MBZ5_MASK            0x0000FFFF

/*+
Target Write Entry (TWE)
-*/

typedef struct TWE_s
               TWE_t;

#define TWE_t_SIZE                                         0x00000040

struct TWE_s
       {
         os_bit32        Bits_MBZ1;
         os_bit32        MBZ2;
         os_bit32        Remote_Node_ID__MBZ3;
         os_bit32        MBZ4;
         os_bit32        LOC__MBZ5__Buff_Off;
         os_bit32        Buff_Index__MBZ6;
         os_bit32        Exp_RO;
         os_bit32        Byte_Count;
         os_bit32        MBZ7;
         os_bit32        Exp_Byte_Cnt;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define TWE_VAL                  0x80000000

#define TWE_DIR                  0x40000000

#define TWE_DCM                  0x20000000

#define TWE_DIN                  0x10000000

#define TWE_INI                  0x08000000

#define TWE_DAT                  0x04000000

#define TWE_MBZ1_MASK            0x03FFFFFF

#define TWE_Remote_Node_ID_MASK  0xFFFFFF00
#define TWE_Remote_Node_ID_SHIFT       0x08

#define TWE_MBZ3_MASK            0x000000FF

#define TWE_LOC                  0x80000000

#define TWE_MBZ5_MASK            0x7FF80000

#define TWE_Buff_Off_MASK        0x0007FFFF
#define TWE_Buff_Off_SHIFT             0x00

#define TWE_Buff_Index_MASK      0xFFFF0000
#define TWE_Buff_Index_SHIFT           0x10

#define TWE_MBZ6_MASK            0x0000FFFF

/*+
Target Read Entry (TRE)
-*/

typedef struct TRE_s
               TRE_t;

#define TRE_t_SIZE                                         0x00000040

struct TRE_s
       {
         os_bit32        Bits__MBZ1__FL__MBZ2__Hdr_Len;
         os_bit32        Hdr_Addr;
         os_bit32        Remote_Node_ID__RSP_Len;
         os_bit32        RSP_Addr;
         os_bit32        LOC__0xF__MBZ3__Buff_Off;
         os_bit32        Buff_Index__MBZ4;
         os_bit32        MBZ5;
         os_bit32        Data_Len;
         os_bit32        MBZ6;
         os_bit32        MBZ7;
         SG_Element_t First_SG;
         SG_Element_t Second_SG;
         SG_Element_t Third_SG;
       };

#define TRE_VAL                  0x80000000

#define TRE_DIR                  0x40000000

#define TRE_DCM                  0x20000000

#define TRE_DIN                  0x10000000

#define TRE_INI                  0x08000000

#define TRE_DAT                  0x04000000

#define TRE_RSP                  0x02000000

#define TRE_CTS                  0x01000000

#define TRE_MBZ1_MASK            0x00FC0000

#define TRE_FL_MASK              0x00030000
#define TRE_FL_128_Bytes         0x00000000
#define TRE_FL_512_Bytes         0x00010000
#define TRE_FL_1024_Bytes        0x00020000

#define TRE_MBZ2_MASK            0x0000F000

#define TRE_Hdr_Len_MASK         0x00000FFF
#define TRE_Hdr_Len_SHIFT              0x00

#define TRE_Remote_Node_ID_MASK  0xFFFFFF00
#define TRE_Remote_Node_ID_SHIFT       0x08

#define TRE_RSP_Len_MASK         0x000000FF
#define TRE_RSP_Len_SHIFT              0x00

#define TRE_LOC                  0x80000000

#define TRE_0xF_MASK             0x78000000
#define TRE_0xF_ALWAYS           0x78000000

#define TRE_MBZ3_MASK            0x07F80000

#define TRE_Buff_Off_MASK        0x0007FFFF
#define TRE_Buff_Off_SHIFT             0x00

#define TRE_Buff_Index_MASK      0xFFFF0000
#define TRE_Buff_Index_SHIFT           0x10

#define TRE_MBZ4_MASK            0x0000FFFF

/*+
SCSI Exchange State Table (SEST) Entry
-*/

typedef union SEST_u
              SEST_t;

#define SEST_t_SIZE                                        0x00000040

union SEST_u
      {
        USE_t USE;
        IWE_t IWE;
        IRE_t IRE;
        TWE_t TWE;
        TRE_t TRE;
      };

/*+
I/O Request Block (IRB) - Exchange Request Queue (ERQ) Entry
-*/

typedef struct IRB_Part_s
               IRB_Part_t;

#define IRB_Part_t_SIZE                                    0x00000010

struct IRB_Part_s
       {
         os_bit32 Bits__SFS_Len;
         os_bit32 SFS_Addr;
         os_bit32 D_ID;
         os_bit32 MBZ__SEST_Index__Trans_ID;
       };

#define IRB_SBV              0x80000000

#define IRB_CTS              0x40000000

#define IRB_DCM              0x20000000

#define IRB_DIN              0x10000000

#define IRB_DNC              0x08000000

#define IRB_SFA              0x04000000

#define IRB_BRD              0x01000000

#define IRB_SFS_Len_MASK     0x00000FFF
#define IRB_SFS_Len_SHIFT          0x00

#define IRB_D_ID_MASK        0xFFFFFF00
#define IRB_D_ID_SHIFT             0x08

#define IRB_MBZ_MASK         0xFFFF8000

#define IRB_SEST_Index_MASK  0x00007FFF
#define IRB_SEST_Index_SHIFT       0x00

#define IRB_Trans_ID_MASK    0x00007FFF
#define IRB_Trans_ID_SHIFT         0x00

typedef struct IRB_s
               IRB_t;

#define IRB_t_SIZE                                         0x00000020

struct IRB_s
       {
         IRB_Part_t Req_A;
         IRB_Part_t Req_B;
       };

/*+
Unknown Completion Message
-*/

typedef struct CM_Unknown_s
               CM_Unknown_t;

#define CM_Unknown_t_SIZE                                  0x00000020

struct CM_Unknown_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Unknown_INT                               0x00000100

#define CM_Unknown_CM_Type_MASK                      0x000000FF
#define CM_Unknown_CM_Type_Outbound                  0x00000000
#define CM_Unknown_CM_Type_Error_Idle                0x00000001
#define CM_Unknown_CM_Type_Inbound                   0x00000004
#define CM_Unknown_CM_Type_ERQ_Frozen                0x00000006
#define CM_Unknown_CM_Type_FCP_Assists_Frozen        0x00000007
#define CM_Unknown_CM_Type_Frame_Manager             0x0000000A
#define CM_Unknown_CM_Type_Inbound_FCP_Exchange      0x0000000C
#define CM_Unknown_CM_Type_Class_2_Frame_Header      0x0000000D
#define CM_Unknown_CM_Type_Class_2_Sequence_Received 0x0000000E

#define CM_Unknown_CM_Type_InvalidType               0x00000002

/*+
Outbound Completion Message
-*/

typedef struct CM_Outbound_s
               CM_Outbound_t;

#define CM_Outbound_t_SIZE                                 0x00000020

struct CM_Outbound_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 SEQ_CNT__RX_ID;
         os_bit32 Bits__SEST_Index__Trans_ID;
         os_bit32 More_Bits;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Outbound_INT              0x00000100

#define CM_Outbound_CM_Type_MASK     0x000000FF

#define CM_Outbound_SEQ_CNT_MASK     0xFFFF0000
#define CM_Outbound_SEQ_CNT_SHIFT          0x10

#define CM_Outbound_RX_ID_MASK       0x0000FFFF
#define CM_Outbound_RX_ID_SHIFT            0x00

#define CM_Outbound_SPC              0x80000000

#define CM_Outbound_DPC              0x40000000

#define CM_Outbound_RPC              0x20000000

#define CM_Outbound_SPE              0x10000000

#define CM_Outbound_SEST_Index_MASK  0x00007FFF
#define CM_Outbound_SEST_Index_SHIFT       0x00

#define CM_Outbound_Trans_ID_MASK    0x00007FFF
#define CM_Outbound_Trans_ID_SHIFT         0x00

#define CM_Outbound_INV              0x40000000

#define CM_Outbound_FTO              0x20000000

#define CM_Outbound_HPE              0x10000000

#define CM_Outbound_LKF              0x08000000

#define CM_Outbound_ASN              0x02000000

/*+
Error Idle Completion Message
-*/

typedef struct CM_Error_Idle_s
               CM_Error_Idle_t;

#define CM_Error_Idle_t_SIZE                               0x00000020

struct CM_Error_Idle_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Error_Idle_INT          0x00000100

#define CM_Error_Idle_CM_Type_MASK 0x000000FF

/*+
Inbound Completion Message
-*/

typedef struct CM_Inbound_s
               CM_Inbound_t;

#define CM_Inbound_t_SIZE                                  0x00000020

struct CM_Inbound_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 SFQ_Prod_Index;
         os_bit32 Frame_Length;
         os_bit32 LKF_Type;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Inbound_INT                  0x00000100

#define CM_Inbound_CM_Type_MASK         0x000000FF

#define CM_Inbound_SFQ_Prod_Index_MASK  0x00000FFF
#define CM_Inbound_SFQ_Prod_Index_SHIFT       0x00

#define CM_Inbound_LKF                  0x40000000

#define CM_Inbound_Type_MASK            0x0000000F
#define CM_Inbound_Type_Unassisted_FCP  0x00000001
#define CM_Inbound_Type_Bad_FCP         0x00000002
#define CM_Inbound_Type_Unknown_Frame   0x00000003

/*+
ERQ Frozen Completion Message
-*/

typedef struct CM_ERQ_Frozen_s
               CM_ERQ_Frozen_t;

#define CM_ERQ_Frozen_t_SIZE                               0x00000020

struct CM_ERQ_Frozen_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_ERQ_Frozen_INT          0x00000100

#define CM_ERQ_Frozen_CM_Type_MASK 0x000000FF

/*+
FCP Assists Frozen Completion Message
-*/

typedef struct CM_FCP_Assists_Frozen_s
               CM_FCP_Assists_Frozen_t;

#define CM_FCP_Assists_Frozen_t_SIZE                       0x00000020

struct CM_FCP_Assists_Frozen_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_FCP_Assists_Frozen_INT          0x00000100

#define CM_FCP_Assists_Frozen_CM_Type_MASK 0x000000FF

/*+
Frame Manager Completion Message
-*/

typedef struct CM_Frame_Manager_s
               CM_Frame_Manager_t;

#define CM_Frame_Manager_t_SIZE                            0x00000020

struct CM_Frame_Manager_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Unused_DWord_1;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Frame_Manager_INT          0x00000100

#define CM_Frame_Manager_CM_Type_MASK 0x000000FF

/*+
Inbound FCP Exchange Completion Message
-*/

typedef struct CM_Inbound_FCP_Exchange_s
               CM_Inbound_FCP_Exchange_t;

#define CM_Inbound_FCP_Exchange_t_SIZE                     0x00000020

struct CM_Inbound_FCP_Exchange_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 Bits__SEST_Index;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Inbound_FCP_Exchange_INT              0x00000100

#define CM_Inbound_FCP_Exchange_CM_Type_MASK     0x000000FF

#define CM_Inbound_FCP_Exchange_LKF              0x40000000

#define CM_Inbound_FCP_Exchange_CNT              0x20000000

#define CM_Inbound_FCP_Exchange_OVF              0x10000000

#define CM_Inbound_FCP_Exchange_RPC              0x08000000

#define CM_Inbound_FCP_Exchange_SEST_Index_MASK  0x00007FFF
#define CM_Inbound_FCP_Exchange_SEST_Index_SHIFT       0x00

/*+
Class 2 Frame Header Completion Message
-*/

typedef struct CM_Class_2_Frame_Header_s
               CM_Class_2_Frame_Header_t;

#define CM_Class_2_Frame_Header_t_SIZE                     0x00000020

struct CM_Class_2_Frame_Header_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 SOF_EOF_Timestamp;
         os_bit32 R_CTL__D_ID;
         os_bit32 CS_CTL__S_ID;
         os_bit32 TYPE__F_CTL;
         os_bit32 SEQ_ID__DF_CTL__SEQ_CNT;
         os_bit32 OX_ID__RX_ID;
         os_bit32 RO;
       };

#define CM_Class_2_Frame_Header_INT             0x00000100

#define CM_Class_2_Frame_Header_CM_Type_MASK    0x000000FF

#define CM_Class_2_Frame_Header_SOF_MASK        0xF0000000
#define CM_Class_2_Frame_Header_SOF_SOFc1       0x30000000
#define CM_Class_2_Frame_Header_SOF_SOFi1       0x50000000
#define CM_Class_2_Frame_Header_SOF_SOFi2       0x60000000
#define CM_Class_2_Frame_Header_SOF_SOFi3       0x70000000
#define CM_Class_2_Frame_Header_SOF_SOFt        0x80000000
#define CM_Class_2_Frame_Header_SOF_SOFn1       0x90000000
#define CM_Class_2_Frame_Header_SOF_SOFn2       0xA0000000
#define CM_Class_2_Frame_Header_SOF_SOFn3       0xB0000000

#define CM_Class_2_Frame_Header_EOF_MASK        0x0F000000
#define CM_Class_2_Frame_Header_EOF_EOFdt       0x01000000
#define CM_Class_2_Frame_Header_EOF_EOFdti      0x02000000
#define CM_Class_2_Frame_Header_EOF_EOFni       0x03000000
#define CM_Class_2_Frame_Header_EOF_EOFa        0x04000000
#define CM_Class_2_Frame_Header_EOF_EOFn        0x05000000
#define CM_Class_2_Frame_Header_EOF_EOFt        0x06000000

#define CM_Class_2_Frame_Header_Timestamp_MASK  0x000000FF
#define CM_Class_2_Frame_Header_Timestamp_SHIFT       0x00

#define CM_Class_2_Frame_Header_R_CTL_MASK      0xFF000000
#define CM_Class_2_Frame_Header_R_CTL_SHIFT           0x18

#define CM_Class_2_Frame_Header_D_ID_MASK       0x00FFFFFF
#define CM_Class_2_Frame_Header_D_ID_SHIFT            0x00

#define CM_Class_2_Frame_Header_CS_CTL_MASK     0xFF000000
#define CM_Class_2_Frame_Header_CS_CTL_SHIFT          0x18

#define CM_Class_2_Frame_Header_S_ID_MASK       0x00FFFFFF
#define CM_Class_2_Frame_Header_S_ID_SHIFT            0x00

#define CM_Class_2_Frame_Header_TYPE_MASK       0xFF000000
#define CM_Class_2_Frame_Header_TYPE_SHIFT            0x18

#define CM_Class_2_Frame_Header_F_CTL_MASK      0x00FFFFFF
#define CM_Class_2_Frame_Header_F_CTL_SHIFT           0x00

#define CM_Class_2_Frame_Header_SEQ_ID_MASK     0xFF000000
#define CM_Class_2_Frame_Header_SEQ_ID_SHIFT          0x18

#define CM_Class_2_Frame_Header_DF_CTL_MASK     0x00FF0000
#define CM_Class_2_Frame_Header_DF_CTL_SHIFT          0x10

#define CM_Class_2_Frame_Header_SEQ_CNT_MASK    0x0000FFFF
#define CM_Class_2_Frame_Header_SEQ_CNT_SHIFT         0x00

#define CM_Class_2_Frame_Header_OX_ID_MASK      0xFFFF0000
#define CM_Class_2_Frame_Header_OX_ID_SHIFT           0x10

#define CM_Class_2_Frame_Header_RX_ID_MASK      0x0000FFFF
#define CM_Class_2_Frame_Header_RX_ID_SHIFT           0x00

/*+
Class 2 Sequence Received Completion Message
-*/

typedef struct CM_Class_2_Sequence_Received_s
               CM_Class_2_Sequence_Received_t;

#define CM_Class_2_Sequence_Received_t_SIZE                0x00000020

struct CM_Class_2_Sequence_Received_s
       {
         os_bit32 INT__CM_Type;
         os_bit32 SEST_Index;
         os_bit32 Unused_DWord_2;
         os_bit32 Unused_DWord_3;
         os_bit32 Unused_DWord_4;
         os_bit32 Unused_DWord_5;
         os_bit32 Unused_DWord_6;
         os_bit32 Unused_DWord_7;
       };

#define CM_Class_2_Sequence_Received_INT              0x00000100

#define CM_Class_2_Sequence_Received_CM_Type_MASK     0x000000FF

#define CM_Class_2_Sequence_Received_SEST_Index_MASK  0x00007FFF
#define CM_Class_2_Sequence_Received_SEST_Index_SHIFT       0x00

/*+
Union of all Completion Message types
-*/

typedef union Completion_Message_u
              Completion_Message_t;

#define Completion_Message_t_SIZE                          0x00000020

union Completion_Message_u
      {
        CM_Unknown_t                   Unknown;
        CM_Outbound_t                  Outbound;
        CM_Error_Idle_t                Error_Idle;
        CM_Inbound_t                   Inbound;
        CM_ERQ_Frozen_t                ERQ_Frozen;
        CM_FCP_Assists_Frozen_t        FCP_Assists_Frozen;
        CM_Frame_Manager_t             Frame_Manager;
        CM_Inbound_FCP_Exchange_t      Inbound_FCP_Exchange;
        CM_Class_2_Frame_Header_t      Class_2_Frame_Header;
        CM_Class_2_Sequence_Received_t Class_2_Sequence_Received;
      };

/*+
Function:  TLStructASSERTs()

Purpose:   Returns the number of TLStruct.H typedefs which are not the correct size.

Algorithm: Each typedef in TLStruct.H is checked for having the correct size.  While
           this property doesn't guarantee correct packing of the fields within, it
           is a pretty good indicator that the typedef has the intended layout.

           The total number of typedefs which are not of correct size is returned from
           this function.  Hence, if the return value is non-zero, the declarations
           can not be trusted to match the TachyonTL specification.
-*/

osGLOBAL os_bit32 TLStructASSERTs(
                              void
                            );

#endif /* __TLStruct_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\tgtstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/TGTSTATE.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/30/00 3:26p  $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/timersvc.h"

#include "../h/sfstate.h"
#include "../h/tgtstate.h"
#include "../h/cstate.h"
#include "../h/devstate.h"
#include "../h/cfunc.h"
#include "../h/queue.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "timersvc.h"

#include "sfstate.h"
#include "tgtstate.h"
#include "cstate.h"
#include "devstate.h"
#include "cfunc.h"
#include "queue.h"
#endif  /* _New_Header_file_Layout_ */

stateTransitionMatrix_t TgtStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...             */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1 TgtEventIdle                                         */
    0,            TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
      TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
        TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
          TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
            TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
              TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                  TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                    TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                      TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                        TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                          TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                            TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
    TgtStateIdle,
      TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
        TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
          TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
            TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
              TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
                TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,TgtStateIdle,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2 TgtEventIncoming                                    */
    0,TgtStateIncoming,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 3 TgtEventPLOGI_Reply                                 */
    0,0,TgtStatePLOGI_RJT_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 4 TgtEventPLOGI_ReplyDone                             */
    0,0,0,TgtEventPLOGI_RJT_ReplyDone,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 5 TgtEventPLOGI_ACC_Reply                                                    */
    0,0,TgtStatePLOGI_ACC_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 6 TgtEventPLOGI_ACC_ReplyDone                                                    */
    0,0,0,0,0, TgtStatePLOGI_ACC_ReplyDone,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7 TgtEventPRLI_ACC_Reply                              */
    0,0,TgtStatePRLI_ACC_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8 TgtEventPRLI_ACC_ReplyDone                          */
    0,0,0,0,0, 0,0,TgtStatePRLI_ACC_ReplyDone,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9 TgtEventLOGO_ACC_Reply                              */
    0,0,TgtStateLOGO_ACC_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10 TgtEventELS_ACC_ReplyDone                         */
    0,0,0,0,0, 0,0,0,0,TgtStateELS_ACC_ReplyDone, 0,0,0,TgtStateELS_ACC_ReplyDone,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11 TgtEventFCP_DR_ACC_Reply                           */
    0,0,TgtStateFCP_DR_ACC_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12 TgtEventFCP_DR_ACC_ReplyDone                       */
    0,0,0,0,0, 0,0,0,0,0, 0,TgtStateFCP_DR_ACC_ReplyDone,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13 TgtEventELSAcc */                                                  
    0,0,TgtStateELSAcc,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14 TgtEventADISC_Reply                                */
    0,0,TgtStateADISCAcc_Reply,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15 TgtEventADISC_ReplyDone                            */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,TgtStateADISCAcc_ReplyDone, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16   TgtEventFARP_Reply                               */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17   TgtEventFARP_ReplyDone                           */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18   TgtEventPRLO_Reply                               */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19   TgtEventPRLO_ReplyDone                           */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 20                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 30                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

stateTransitionMatrix_t copiedTgtStateTransitionMatrix;

stateActionScalar_t TgtStateActionScalar = {
    &TgtActionConfused,
    &TgtActionIdle,
    &TgtActionIncoming,
    &TgtActionPLOGI_RJT_Reply,
    &TgtActionPLOGI_RJT_ReplyDone,
    &TgtActionPLOGI_ACC_Reply,
    &TgtActionPLOGI_ACC_ReplyDone,
    &TgtActionPRLI_ACC_Reply,
    &TgtActionPRLI_ACC_ReplyDone,
    &TgtActionLOGO_ACC_Reply,
    &TgtActionELS_ACC_ReplyDone,
    &TgtActionFCP_DR_ACC_Reply,
    &TgtActionFCP_DR_ACC_ReplyDone,
    &TgtActionELSAcc,
    &TgtActionADISCAcc_Reply,
    &TgtActionADISCAcc_ReplyDone,
    &TgtActionFARP_Reply,
    &TgtActionFARP_ReplyDone,
    &TgtActionPRLOAcc_Reply,
    &TgtActionPRLOAcc_ReplyDone,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    &TgtActionConfused,
    };

stateActionScalar_t copiedTgtStateActionScalar;

#ifdef USESTATEMACROS

TgtSTATE_FUNCTION_TERMINATE(TgtActionConfused);

#endif /* USESTATEMACROS */

#define testTgtCompareBase 0x00000110


#ifndef USESTATEMACROS

/*+
  Function: TgtActionConfused
   Purpose: Terminating State for error detection 
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: None
-*/
/* TgtStateConfused 0  */
extern void TgtActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    fiLogString(thread->hpRoot,
                    "TgtActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogErrorLevel,
                    "In %s - State = %d",
                    "TgtActionConfused",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: TgtActionIdle
   Purpose: "Free" state for target threads.Terminating State  
 Called By: All target threads complete to this state.
     Calls: TgtThreadFree
-*/
/* TgtStateIdle 1  */
extern void TgtActionIdle( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionIdle",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                   "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->LOOP_DOWN,
                    CThread_ptr(thread->hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(thread->hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(thread->hpRoot)->ERQ_FROZEN,
                    CThread_ptr(thread->hpRoot)->FCP_FROZEN,
                    CThread_ptr(thread->hpRoot)->ProcessingIMQ,
                    0,0);

    fiSetEventRecordNull(eventRecord);

    TgtThreadFree(thread->hpRoot, pTgtThread );

}

/*+
  Function: TgtActionIncoming
   Purpose: Parsing state for target threads. This state determines appropriate action
            for all external messages. All known ELS types have an entry, most do nothing.
 Called By: 
     Calls: TgtThreadFree
            TgtEventPLOGI_ACC_Reply
            TgtEventIdle
            CFunc_LOGO_Completion
            TgtEventLOGO_ACC_Reply
            TgtEventELSAcc
            TgtEventPRLI_ACC_Reply
            TgtEventADISC_Reply
            CEventRSCNErrorBackIOs
            TgtEventConfused
            SFThreadAlloc
-*/
/* TgtStateIncoming 2  */
extern void TgtActionIncoming( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot                 = thread->hpRoot;
    CThread_t       * pCThread               = CThread_ptr(hpRoot);
    TgtThread_t     * pTgtThread             = ( TgtThread_t  * )thread;
    event_t           event_to_send          = 0;
    os_bit32          FCHS_TYPE;
    os_bit32          FC_ELS_Type;
    X_ID_t            OX_ID                  = 0;
    FC_Port_ID_t      Port_ID;
    FC_ELS_Unknown_Payload_t  * Payload      = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)&(pTgtThread->TgtCmnd_FCHS) + sizeof(FCHS_t));
    FC_ELS_FAN_Payload_t      * FAN_PayLoad  = (FC_ELS_FAN_Payload_t *)Payload;
    FC_ELS_LOGO_Payload_t     * LOGO_Payload = (FC_ELS_LOGO_Payload_t *)Payload;
    os_bit32                  * pPayload     = (os_bit32 *)Payload;
    SFThread_t                * pSFThread    = (SFThread_t *)agNULL;

    FCHS_t                 *FCHS     = &(pTgtThread->TgtCmnd_FCHS);
    os_bit32                D_ID     = (FCHS->R_CTL__D_ID & FCHS_D_ID_MASK) >> FCHS_D_ID_SHIFT;


    FCHS_TYPE = pTgtThread->TgtCmnd_FCHS.TYPE__F_CTL & FCHS_TYPE_MASK;

    if( pCThread->DeviceSelf ==(DevThread_t *) agNULL )
    {
        fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

        FC_ELS_Type = hpSwapBit32(Payload->ELS_Type);
        FC_ELS_Type &= FC_ELS_Type_MASK;

        fiLogDebugString(hpRoot,
                    TgtStateLogConsoleLevel,
                    "%s In %s - State = %d FC_ELS_Type %x Payload->ELS_Type %x",
                    "Don't Have AL_PA !!", 
                    "TgtActionIncoming",
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    FC_ELS_Type & FC_ELS_Type_MASK,
                    hpSwapBit32(Payload->ELS_Type),
                    0,0,0,0,0);
        if( FC_ELS_Type == FC_ELS_Type_PLOGI)
        {
            
            fiLogDebugString(hpRoot,
                        TgtStateLogConsoleLevel,
                        "In %s - State = %d FC_ELS_Type %x (%s)%x OX_ID__RX_ID %08X DID %x",
                        "TgtActionIncoming",
                        "FC_ELS_Type_PLOGI",
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        FC_ELS_Type,
                        Payload->ELS_Type,
                        FCHS->OX_ID__RX_ID,
                        D_ID,
                        0,0,0);
            if(D_ID  != 0 && D_ID != 0xff)
            {

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, D_ID);

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                        (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( D_ID <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ));

                Port_ID.Struct_Form.reserved = 0;
                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
                Port_ID.Struct_Form.AL_PA  = (os_bit8)D_ID;

                pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

                pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                            Port_ID.Struct_Form.Domain,
                                                            Port_ID.Struct_Form.Area,
                                                            Port_ID.Struct_Form.AL_PA,
                                                           (FC_Port_Name_t *)(&pCThread->ChanInfo.PortWWN));

                fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
                fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

                pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)D_ID;
            }
            else
            {
                return;
            }
        
        }
        else
        {
            return;
        }
    }

    if (FCHS_TYPE == FC_Frame_Header_TYPE_ELS)
    {
        /* Process incoming ELS */

        FC_ELS_Type = hpSwapBit32(Payload->ELS_Type);
        FC_ELS_Type &= FC_ELS_Type_MASK;


        switch(FC_ELS_Type)
        {
            case FC_ELS_Type_PLOGI:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x OX_ID__RX_ID %08X",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_PLOGI",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                FCHS->OX_ID__RX_ID,
                                                0,0,0,0);

                                       event_to_send = TgtEventPLOGI_ACC_Reply;  break;
            case FC_ELS_Type_LS_RJT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_LS_RJT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ACC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ACC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                        fiLogDebugString( hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                                                "FC_ELS_Type_ACC",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                hpSwapBit32( *(pPayload+2)),
                                                hpSwapBit32( *(pPayload+3)),
                                                hpSwapBit32( *(pPayload+4)),
                                                hpSwapBit32( *(pPayload+5)),
                                                hpSwapBit32( *(pPayload+6)),
                                                hpSwapBit32( *(pPayload+7)));
                                        fiLogDebugString( hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->MBZ1,
                                                FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                                FCHS->R_CTL__D_ID,
                                                FCHS->CS_CTL__S_ID,
                                                0,0,0,0 );

                                        fiLogDebugString( hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->TYPE__F_CTL,
                                                FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                                FCHS->OX_ID__RX_ID,
                                                FCHS->RO,
                                                0,0,0,0 );


                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_FLOGI:
                                        fiLogString( hpRoot,
                                                    "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                    "TgtActionIncoming",
                                                    "FC_ELS_Type_FLOGI",
                                                    (void *)agNULL,(void *)agNULL,
                                                    (os_bit32)thread->currentState,
                                                    FC_ELS_Type,
                                                    Payload->ELS_Type,
                                                    0,0,0,0,0);

                                        pSFThread = pCThread->SFThread_Request.SFThread;
                                        if(pSFThread != agNULL )
                                        {
                                            fiLogString( hpRoot,
                                                        "SF %p State %d",
                                                        (char *)agNULL,(char *)agNULL,
                                                        pSFThread,(void *)agNULL,
                                                        pSFThread->thread_hdr.currentState,
                                                        0,0,0,0,0,0,0);
                                            pCThread->FlogiRcvdFromTarget = agTRUE;
                                            if(pSFThread->thread_hdr.currentState == SFStateDoFlogi)
                                            {
                                                fiTimerStop(&pSFThread->Timer_Request );
                                                fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiTimedOut);
                                            }
                                        }
                                        else
                                        {
                                            fiLogString( hpRoot,
                                                        "%s From Other !",
                                                        "FC_ELS_Type_FLOGI",(char *)agNULL,
                                                        (void *)agNULL,(void *)agNULL,
                                                        0,0,0,0,0,0,0,0);

                                        }
                                        event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_LOGO:
                                        OX_ID = (X_ID_t)(( FCHS->OX_ID__RX_ID & FC_Frame_Header_OX_ID_MASK ) >> FC_Frame_Header_OX_ID_SHIFT );
                                        OX_ID &= 0x7fff;
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d %s ELS %x %08X OX_ID %3X",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_LOGO",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                LOGO_Payload->ELS_Type,
                                                LOGO_Payload->N_Port_Identifier,
                                                OX_ID,
                                                0,0,0,0);
                                                
                                        fiLogDebugString(
                                                hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->MBZ1,
                                                FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                                FCHS->R_CTL__D_ID,
                                                FCHS->CS_CTL__S_ID,
                                                0,0,0,0 );

                                        fiLogDebugString(
                                                hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->TYPE__F_CTL,
                                                FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                                FCHS->OX_ID__RX_ID,
                                                FCHS->RO,
                                                0,0,0,0 );

                                       CFunc_LOGO_Completion( hpRoot,  OX_ID);
                                       event_to_send = TgtEventLOGO_ACC_Reply; break;
            case FC_ELS_Type_ABTX:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ABTX",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RCS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RCS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RES:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RES",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RSS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RSS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RSI:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RSI",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ESTS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ESTS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ESTC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ESTC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ADVC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ADVC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RTV:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RTV",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RLS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RLS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_ECHO:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ECHO",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventELSAcc; break;
            case FC_ELS_Type_TEST:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_TEST",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RRQ:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RRQ",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_PRLI:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_PRLI",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventPRLI_ACC_Reply;   break;
            case FC_ELS_Type_PRLO:

                                        fiLogString(hpRoot,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_PRLO",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);

                                        fiLogString(hpRoot,
                                                "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                                                "FC_ELS_Type_ACC",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                hpSwapBit32( *(pPayload+2)),
                                                hpSwapBit32( *(pPayload+3)),
                                                hpSwapBit32( *(pPayload+4)),
                                                hpSwapBit32( *(pPayload+5)),
                                                hpSwapBit32( *(pPayload+6)),
                                                hpSwapBit32( *(pPayload+7)));
                                        fiLogString(hpRoot,
                                                "    FCHS 0 %08X 1 %08X 2 %08X 3 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->MBZ1,
                                                FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                                FCHS->R_CTL__D_ID,
                                                FCHS->CS_CTL__S_ID,
                                                0,0,0,0 );

                                        fiLogString(hpRoot,
                                                "    FCHS 4 %08X 5 %08X 6 %08X 7 %08X",
                                                (char *)agNULL,
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                FCHS->TYPE__F_CTL,
                                                FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                                FCHS->OX_ID__RX_ID,
                                                FCHS->RO,
                                                0,0,0,0 );


                                       event_to_send = TgtEventPLOGI_RJT_Reply; break;
            case FC_ELS_Type_SCN:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_SCN",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RSCN:
                                     
	                                    fiLogDebugString(hpRoot,
	                                            TgtStateLogConsoleLevel,
	                                            "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
	                                            "TgtActionIncoming",
	                                            "FC_ELS_Type_RSCN",
                                                (void *)agNULL,(void *)agNULL,
	                                            (os_bit32)thread->currentState,
	                                            FC_ELS_Type,
	                                            Payload->ELS_Type,
	                                            0,0,0,0,0);
                                        if( ( (hpSwapBit32(*(pPayload+1)) ) & 0xffff ) == 8 )
                                        fiLogDebugString(
                                                hpRoot,
                                                CTLogConsoleLevelInfo,
                                                "%s %08X %08X",
                                                "RSCN",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                0,0,0,0,0,0);
                                        else
                                        fiLogDebugString(
                                                hpRoot,
                                                CTLogConsoleLevelInfo,
                                                "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                                                "RSCN",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                hpSwapBit32( *(pPayload+2)),
                                                hpSwapBit32( *(pPayload+3)),
                                                hpSwapBit32( *(pPayload+4)),
                                                hpSwapBit32( *(pPayload+5)),
                                                hpSwapBit32( *(pPayload+6)),
                                                hpSwapBit32( *(pPayload+7)));
 

                                        /* If we are in CStateNormal, error back IOs by sending
                                         * CEventRSCNErrorBackIos to Cthread. 
                                         * For now, we will not look at the payload and just rediscover
                                         * everything by quering the name server again.
                                         */
                                        if((pCThread->thread_hdr.currentState == CStateNormal ) &&
                                          (pCThread->thread_hdr.subState != CSubStateResettingDevices))
                                        {
                                            fiSendEvent(&pCThread->thread_hdr,CEventRSCNErrorBackIOs);
                                        }

	                                   event_to_send = TgtEventELSAcc; 
                                    break;
            case FC_ELS_Type_TPLS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_TPLS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_TPRLO:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_TPRLO",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_GAID:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_GAID",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_FACT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_FACT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_FDACT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_FDACT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_NACT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_NACT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_NDACT:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_NDACT",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_QoSR:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_QoSR",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_RVCS:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_RVCS",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_PDISC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_PDISC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;
            case FC_ELS_Type_FDISC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_FDISC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                       event_to_send = TgtEventIdle; break;

            case FC_ELS_Type_ADISC:
                                        fiLogDebugString(hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "In %s - State = %d FC_ELS_Type %x (%s) Payload->ELS_Type %x",
                                                "TgtActionIncoming",
                                                "FC_ELS_Type_ADISC",
                                                (void *)agNULL,(void *)agNULL,
                                                (os_bit32)thread->currentState,
                                                FC_ELS_Type,
                                                Payload->ELS_Type,
                                                0,0,0,0,0);
                                        fiLogDebugString( hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                                                "FC_ELS_Type_ADISC",
                                                (char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                hpSwapBit32( *(pPayload+0)),
                                                hpSwapBit32( *(pPayload+1)),
                                                hpSwapBit32( *(pPayload+2)),
                                                hpSwapBit32( *(pPayload+3)),
                                                hpSwapBit32( *(pPayload+4)),
                                                hpSwapBit32( *(pPayload+5)),
                                                hpSwapBit32( *(pPayload+6)),
                                                hpSwapBit32( *(pPayload+7)));

                                       event_to_send = TgtEventADISC_Reply; break;

            case FC_ELS_Type_FAN:
                                       fiLogDebugString(hpRoot,
	                                            TgtStateLogConsoleLevel,
	                                            "In %s - State = %d (%s) ELS_Type %x",
	                                            "TgtActionIncoming",
	                                            "FC_ELS_Type_FAN",
                                                (void *)agNULL,(void *)agNULL,
	                                            (os_bit32)thread->currentState,
	                                            Payload->ELS_Type,
	                                            0,0,0,0,0,0);
                                       fiLogDebugString(thread->hpRoot,
                                                TgtStateLogConsoleLevel,
                                                "Domain %02X Area %02X ALPA %02X Found CCnt %x",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                pCThread->ChanInfo.CurrentAddress.Domain,
                                                pCThread->ChanInfo.CurrentAddress.Area,
                                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                                pCThread->CDBpollingCount,
                                                0,0,0,0);

	                                     fiLogDebugString(hpRoot,
	                                            TgtStateLogConsoleLevel,
	                                            "Type %X FabricLoopAddress %8X",
	                                            agNULL,
	                                            agNULL,
                                                (void *)agNULL,(void *)agNULL,
	                                            FAN_PayLoad->ELS_Type,
                                                FAN_PayLoad->FabricLoopAddress,
	                                            0,0,0,0,0,0);

	                                    event_to_send = TgtEventIdle; 
                                        
                                        if((pCThread->thread_hdr.currentState == CStateNormal ) &&
                                          (pCThread->thread_hdr.subState != CSubStateResettingDevices))
                                        {
                                            fiSendEvent(&pCThread->thread_hdr,CEventRSCNErrorBackIOs);
                                        }


                                    break;


           default:
                                   fiLogString(hpRoot,
                                                "%s Payload->ELS_Type %08X !!!",
                                                "TgtEventConfused",(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                (hpSwapBit32(Payload->ELS_Type) & FC_ELS_Type_MASK),
                                                0,0,0,0,0,0,0);

                                        event_to_send = TgtEventConfused;
        }


        if( event_to_send == TgtEventIdle )
        {
            fiLogString(hpRoot,
                        "%s ELS_Type %08X ETS %d",
                        "TgtActionIncoming",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (hpSwapBit32(Payload->ELS_Type) & FC_ELS_Type_MASK),
                        event_to_send,
                        0,0,0,0,0,0);
            fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

        }
        else
        {
            pTgtThread->SFThread_Request.eventRecord_to_send.event = event_to_send;
            pTgtThread->SFThread_Request.eventRecord_to_send.thread = thread;

            fiSetEventRecordNull(eventRecord);

            SFThreadAlloc(thread->hpRoot, & pTgtThread->SFThread_Request );
        }
    }
    else if (FCHS_TYPE == FC_Frame_Header_TYPE_SCSI_FCP)
    {
        /* Process incoming FCP_SCSI */

        if( *((os_bit32 *)Payload + 0) == 0            &&
            *((os_bit32 *)Payload + 1) == 0            &&
            *((os_bit32 *)Payload + 2) == 0x00200000   &&
            *((os_bit32 *)Payload + 3) == 0            &&
            *((os_bit32 *)Payload + 4) == 0            &&
            *((os_bit32 *)Payload + 5) == 0            &&
            *((os_bit32 *)Payload + 6) == 0            &&
            *((os_bit32 *)Payload + 7) == 0                )
        {
            /* Process incoming Target Reset */

            fiLogString(hpRoot,
                             "Device Reset from someone  !!!!",
                             (char *)agNULL,(char *)agNULL,
                             (void *)agNULL,(void *)agNULL,
                             0,0,0,0,0,0,0,0);

            CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
            pCThread->LinkDownTime = pCThread->TimeBase;
/**/
            pTgtThread->SFThread_Request.eventRecord_to_send.event = TgtEventFCP_DR_ACC_Reply;
            pTgtThread->SFThread_Request.eventRecord_to_send.thread = thread;

            fiSetEventRecordNull(eventRecord);
            SFThreadAlloc(thread->hpRoot, & pTgtThread->SFThread_Request );
        }
        else
        {
            fiLogDebugString(hpRoot,
                             CFuncLogConsoleERROR,
                             "Unsupported FCP ",
                             (char *)agNULL,(char *)agNULL,
                             (void *)agNULL,(void *)agNULL,
                             0,0,0,0,0,0,0,0);

            fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);
        }
    }
    else
    {
        /* Discard */

        fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);
    }
}

/*+
  Function: TgtActionPLOGI_RJT_Reply
   Purpose: Does PLOGI reject reply
 Called By: 
     Calls: SFEventDoLS_RJT
-*/
/* TgtStatePLOGI_RJT_Reply 3 */
extern void TgtActionPLOGI_RJT_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    /*+ Check This DRL Do we need this ? -*/
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPLOGI_RJT_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    /* Send SF event LS Rej */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoLS_RJT);

}

/*+
  Function: TgtActionPLOGI_RJT_ReplyDone
   Purpose: Completeion state for  PLOGI reject reply
 Called By: 
     Calls: SFThreadFree
            TgtEventIdle
-*/
/*TgtStatePLOGI_RJT_ReplyDone 4 */
extern void TgtActionPLOGI_RJT_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    /*+ Check This DRL Do we need this ? -*/
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPLOGI_RJT_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/*+
  Function: TgtActionPLOGI_ACC_Reply
   Purpose: Sends  PLOGI accept
 Called By: 
     Calls: CFuncMatchALPAtoThread
            SFEventDoPlogiAccept
            fiTimerStart
-*/
/* TgtStatePLOGI_ACC_Reply 5 */
extern void TgtActionPLOGI_ACC_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t   * pTgtThread = ( TgtThread_t  * )thread;
    FC_Port_ID_t    FCHS_SID;
    DevThread_t   * pDevThread=agNULL;

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    FCHS_SID.Bit32_Form = pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK;

    pDevThread = CFuncMatchALPAtoThread(thread->hpRoot, FCHS_SID );

    fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "In %s SFThread (%p) DevThread (%p)",
                    "TgtActionPLOGI_ACC_Reply",(char *)agNULL,
                    pTgtThread->SFThread_Request.SFThread,pDevThread,
                    0,0,0,0,0,0,0,0);

    if (pDevThread)
    {

        fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "In %s - State = %d ALPA %X TGT SFThread (%p) Req State %x SF State %d",
                        "TgtActionPLOGI_ACC_Reply",(char *)agNULL,
                        pTgtThread->SFThread_Request.SFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pDevThread->DevInfo.CurrentAddress.AL_PA,
                        (os_bit32)pTgtThread->SFThread_Request.State,
                        (os_bit32)pTgtThread->SFThread_Request.SFThread->thread_hdr.currentState,
                        0,0,0,0);

        if( pDevThread->SFThread_Request.SFThread)
        {
            fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "   %s Device  SFThread (%p) Req State %x SF State %d",
                            "TgtActionPLOGI_ACC_Reply",(char *)agNULL,
                            pDevThread->SFThread_Request.SFThread,(void *)agNULL,
                            (os_bit32)pDevThread->SFThread_Request.State,
                            (os_bit32)pDevThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            0,0,0,0,0,0);
        }

        if( pDevThread->SFThread_Request.State == SFThread_Request_Granted )
        {

            fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "%s Setting timer ",
                            "TgtActionPLOGI_ACC_Reply",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

            fiSetEventRecordNull(eventRecord);
            fiTimerSetDeadlineFromNow( thread->hpRoot, &pTgtThread->Timer_Request, 100 );
            pTgtThread->Timer_Request.eventRecord_to_send.thread = ((fi_thread__t *)pTgtThread->SFThread_Request.SFThread);
            pTgtThread->Timer_Request.eventRecord_to_send.event = SFEventDoPlogiAccept;
            fiTimerStart( thread->hpRoot,&pTgtThread->Timer_Request );
        }
        else
        {
            fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoPlogiAccept);
        }
    }
    else
    {
        if( pTgtThread->SFThread_Request.SFThread)
        {
            fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "%s %s SFThread (%p) Req State %x SF State %d",
                            "TgtActionPLOGI_ACC_Reply","No Device",
                            pTgtThread->SFThread_Request.SFThread,(void *)agNULL,
                            (os_bit32)pTgtThread->SFThread_Request.State,
                            (os_bit32)pTgtThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            0,0,0,0,0,0);
        }
        fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoPlogiAccept);
    }
}

/*+
  Function: TgtActionPLOGI_ACC_ReplyDone
   Purpose: Frees resources after  PLOGI accept completes
 Called By: 
     Calls: SFThreadFree
            TgtEventIdle
-*/
/*TgtStatePLOGI_ACC_ReplyDone 6 */
extern void TgtActionPLOGI_ACC_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPLOGI_ACC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t * )agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/*+
  Function: TgtActionPRLI_ACC_Reply
   Purpose: Sends  PRLI accept
 Called By: 
     Calls: CFuncMatchALPAtoThread
            SFEventDoPrliAccept
            fiTimerStart
-*/
/* TgtStatePRLI_ACC_Reply 7 */
extern void TgtActionPRLI_ACC_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPRLI_ACC_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    /*  */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoPrliAccept);

}

/*+
  Function: TgtActionPRLI_ACC_ReplyDone
   Purpose: Frees resources after  PRLI accept completes
 Called By: 
     Calls: SFThreadFree
            TgtEventIdle
-*/
/* TgtStatePRLI_ACC_ReplyDone 8 */
extern void TgtActionPRLI_ACC_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPRLI_ACC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->LOOP_DOWN,
                    CThread_ptr(thread->hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(thread->hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(thread->hpRoot)->ERQ_FROZEN,
                    CThread_ptr(thread->hpRoot)->FCP_FROZEN,
                    CThread_ptr(thread->hpRoot)->ProcessingIMQ,
                    0,0);

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);
}

/*+
  Function: TgtActionLOGO_ACC_Reply
   Purpose: Sends  LOGO accept
 Called By: 
     Calls: CFuncMatchALPAtoThread
            SFEventDoPrliAccept
            fiTimerStart
-*/
/* TgtStateLOGO_ACC_Reply 9 */
extern void TgtActionLOGO_ACC_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t   * pTgtThread = ( TgtThread_t  * )thread;
    FC_Port_ID_t    FCHS_SID;
    DevThread_t   * pDevThread=agNULL;

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    FCHS_SID.Bit32_Form = pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK;

    pDevThread = CFuncMatchALPAtoThread(thread->hpRoot, FCHS_SID );

    /* If we recieve a LOGO from a device that we do not know of, send an 
     * ACC for now and get done with it. Maybe we should really send a 
     * LS_RJT, but since we send an ACC for a PLOGI from any device, we 
     * got to be consistant. */
    if (pDevThread)
    {

        fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "In %s - State = %d ALPA %X TGT SFThread (%p) Req State %x SF State %d",
                        "TgtActionLOGO_ACC_Reply",(char *)agNULL,
                        pTgtThread->SFThread_Request.SFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pDevThread->DevInfo.CurrentAddress.AL_PA,
                        (os_bit32)pTgtThread->SFThread_Request.State,
                        (os_bit32)pTgtThread->SFThread_Request.SFThread->thread_hdr.currentState,
                        0,0,0,0);

/*
        if( pDevThread->SFThread_Request.SFThread)
        {
            fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Device    SFThread (%p) Req State %x SF State %d",
                            (void *)agNULL,(void *)agNULL,
                            pDevThread->SFThread_Request.SFThread,(char *)agNULL,
                            (os_bit32)pDevThread->SFThread_Request.State,
                            (os_bit32)pDevThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            0,0,0,0,0,0);
        }
*/
        pDevThread->DevInfo.LoggedIn   = agFALSE;
/**/
        if( CThread_ptr(thread->hpRoot)->thread_hdr.currentState == CStateNormal ||
            CThread_ptr(thread->hpRoot)->thread_hdr.currentState == CStateFindDevice )
        {
            
/*  DRL           fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
*/
            fiSendEvent(&CThread_ptr(thread->hpRoot)->thread_hdr,CEventExternalLogout);

        }
    }
    /*
    fiSendEvent(&CThread_ptr(thread->hpRoot)->thread_hdr,CEventAsyncLoopEventDetected);
  */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoELSAccept);

}

/*TgtStateELS_ACC_ReplyDone 10 */
extern void TgtActionELS_ACC_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionELS_ACC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "Loop_Reset_Event_to_Send %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(thread->hpRoot)->Loop_Reset_Event_to_Send,
                    0,0,0,0,0,0,0);

#ifdef NeedToReset
    fiSendEvent(&(CThread_ptr(thread->hpRoot)->thread_hdr),(event_t) CThread_ptr(thread->hpRoot)->Loop_Reset_Event_to_Send);
#endif /* NeedToReset */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/*+
  Function: TgtActionFCP_DR_ACC_Reply
   Purpose: Sends accept Reply to Task manangement reset.
 Called By: 
     Calls: CFuncMatchALPAtoThread
            SFEventDoFCP_DR_ACC_Reply
-*/
/* TgtStateFCP_DR_ACC_Reply  11 */
extern void TgtActionFCP_DR_ACC_Reply ( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t   * pTgtThread = ( TgtThread_t  * )thread;
    FC_Port_ID_t    FCHS_SID;
    DevThread_t   * pDevThread=agNULL;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionFCP_DR_ACC_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    FCHS_SID.Bit32_Form = pTgtThread->TgtCmnd_FCHS.CS_CTL__S_ID & FC_Frame_Header_S_ID_MASK;

    pDevThread = CFuncMatchALPAtoThread(thread->hpRoot, FCHS_SID );


    /*  */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoFCP_DR_ACC_Reply);

}

/*+
  Function: TgtActionFCP_DR_ACC_ReplyDone
   Purpose: Frees resources for reply to task manangement reset.
     Calls: SFThreadFree
            TgtEventIdle
-*/
/*TgtStateFCP_DR_ACC_ReplyDone 12 */
extern void TgtActionFCP_DR_ACC_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionFCP_DR_ACC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}


/* TgtStateELSAcc 13 */
extern void TgtActionELSAcc( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionELSAcc",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    /* Send SF event LS Rej */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoELSAccept);

}

/*+
  Function: TgtActionFCP_DR_ACC_ReplyDone
   Purpose: Does reply to ADISC.
     Calls: SFEventDoADISCAccept
-*/
/* TgtStateADISCAcc_Reply                14  */
extern void TgtActionADISCAcc_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionADISC_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pTgtThread->SFThread_Request.SFThread->parent.Target = pTgtThread;

    /*  */
    fiSetEventRecord(eventRecord,&(pTgtThread->SFThread_Request.SFThread->thread_hdr),SFEventDoADISCAccept);

}

/*+
  Function: TgtActionFCP_DR_ACC_ReplyDone
   Purpose: Frees resources for reply to ADISC.
     Calls: SFThreadFree
            TgtEventIdle
-*/
/* TgtStateADISCAcc_ReplyDone            15 */
extern void TgtActionADISCAcc_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionADISC_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t * )agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/*+
  Function: TgtActionFARP_Reply
   Purpose: Does reply to .
     Calls: 
-*/
/* TgtStateFARP_Reply 16  */
extern void TgtActionFARP_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    fiLogString(thread->hpRoot,
                    "TgtActionFARP_Reply",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogErrorLevel,
                    "In %s - State = %d",
                    "TgtActionFARP_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: TgtActionFARP_ReplyDone
   Purpose: Does reply to .
     Calls: 
-*/
/* TgtEventFARP_ReplyDone                17 */
extern void TgtActionFARP_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    fiLogString(thread->hpRoot,
                    "TgtActionFARP_ReplyDone",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogErrorLevel,
                    "In %s - State = %d",
                    "TgtActionFARP_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}
/*+
  Function: TgtActionPRLOAcc_Reply
   Purpose: Does reply to PRLO.
     Calls: SFEventDoAccept
-*/
/* TgtStatePRLOAcc_Reply                18                  */
extern void TgtActionPRLOAcc_Reply( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPRLOAcc_Reply",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    pSFThread->parent.Target = pTgtThread;

    /*  */
    fiSetEventRecord(eventRecord,&(pSFThread->thread_hdr),SFEventReset);

}

/*+
  Function: TgtActionPRLOAcc_ReplyDone
   Purpose: Frees resources for reply to ADISC.
     Calls: SFThreadFree
            TgtEventIdle
-*/
/* TgtStatePRLOAcc_ReplyDone            19 */
extern void TgtActionPRLOAcc_ReplyDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    TgtThread_t     * pTgtThread = ( TgtThread_t  * )thread;
    SFThread_t      * pSFThread  = pTgtThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    TgtStateLogConsoleLevel,
                    "In %s - State = %d",
                    "TgtActionPRLOAcc_ReplyDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if(pSFThread != (SFThread_t * )agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree(thread->hpRoot, &pTgtThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiSetEventRecord(eventRecord,&pTgtThread->thread_hdr,TgtEventIdle);

}

/* void tgtstate(void){}  */

#endif /* USESTATEMACROS  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\timersvc.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/TimerSvc.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/TimerSvc.C

--*/

#ifndef __TimerSvc_H__
#define __TimerSvc_H__

osGLOBAL void fiTimerSvcInit(
                            agRoot_t *hpRoot
                          );

osGLOBAL void fiTimerInitializeRequest(
                                      fiTimer_Request_t *Timer_Request
                                    );

osGLOBAL void fiTimerSetDeadlineFromNow(
                                       agRoot_t          *hpRoot,
                                       fiTimer_Request_t *Timer_Request,
                                       os_bit32              From_Now
                                     );

osGLOBAL void fiTimerAddToDeadline(
                                  fiTimer_Request_t *Timer_Request,
                                  os_bit32              To_Add
                                );

osGLOBAL void fiTimerStart(
                          agRoot_t          *hpRoot,
                          fiTimer_Request_t *Timer_Request
                        );

osGLOBAL void fiTimerStop(
                         fiTimer_Request_t *Timer_Request
                       );

osGLOBAL void fiTimerTick(
                         agRoot_t *hpRoot,
                         os_bit32     tickDelta
                       );

#endif /* __TimerSvc_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\state.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/State.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/16/00 3:00p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/State.C

--*/

#ifndef __State_H__
#define __State_H__

/*+
Defining __State_Force_Static_State_Tables__ disables use of Dynamic State Tables
-*/

#ifndef __State_Force_Static_State_Tables__
#define __State_Force_Static_State_Tables__
#endif /* __State_Force_Static_State_Tables__ was not defined */

/*+
Data stuctures used by State Machine
-*/

typedef os_bit8 event_t;
typedef os_bit8 state_t;

typedef struct thread_s
               fi_thread__t;

typedef struct eventRecord_s
               eventRecord_t;

struct eventRecord_s {
                       fi_thread__t *thread;
                       event_t   event;
                     };

typedef void (*action_t)(
                          fi_thread__t      *thread,
                          eventRecord_t *nextEventRecord
                        );

#define maxEvents 128
#define maxStates 128

typedef struct stateTransitionMatrix_s
               stateTransitionMatrix_t;

struct stateTransitionMatrix_s {
                                 state_t newState[maxEvents][maxStates];
                               };

typedef struct stateActionScalar_s
               stateActionScalar_t;

struct stateActionScalar_s {
                             action_t newAction[maxStates];
                           };

/**
 *
 * To initialize a State Transition Matrix:
 *
 *   stateTransitionMatrix_t stateTransitionMatrix = {
 *                                                     newStateA,
 *                   < event 0 transitions >            newStateB,
 *                                                       newStateC,
 *                                                        ... < for all "maxStates" states >
 *                                                     newStateZ,
 *                   < event 1 transitions >            newStateY,
 *                                                       newStateX,
 *                                                        ... < for all "maxStates" states >
 *    < one for each of "maxEvents" events >           ...
 *                                                   };
 *
 * To initialize a State Action Scalar:
 *
 *   stateActionScalar_t stateActionScalar = {
 *                                             newActionA,
 *                                             newActionB,
 *                                             newActionC,
 *        < one for each State/Action pair >   ...,
 *                                             newActionX,
 *                                             newActionY,
 *                                             newActionZ,
 *                                             ...
 *                                           };
 *
 **/

#ifndef __State_Force_Static_State_Tables__
typedef struct actionUpdate_s
               actionUpdate_t;

struct actionUpdate_s {
                        os_bit32    bitMask;
                        os_bit32    compareTo;
                        action_t originalAction;
                        action_t replacementAction;
                      };
#endif /* __State_Force_Static_State_Tables__ was not defined */

/**
 *
 * To initialize an Action Update Table:
 *
 *   actionUpdate_t testActionUpdate[] = {
 *                                         bitMask1, compareTo1, &originalAction1(), &replacementAction1(),
 *                                         bitMask2, compareTo2, &originalAction2(), &replacementAction2(),
 *                                         ...
 *                                         bitMaskN, compareToN, &originalActionN(), &replacementActionN(),
 *                                         0,        0,          (void *)agNULL,       (void *)agNULL
 *                                       };
 *
 **/

#define threadType_Unknown 0

typedef os_bit32 threadType_t;

struct thread_s {
                  agRoot_t                *hpRoot;
                  threadType_t             threadType;
                  state_t                  currentState;
                  state_t                  subState;
                  stateTransitionMatrix_t *stateTransitionMatrix;
                  stateActionScalar_t     *stateActionScalar;
                };

/*+
State Machine Logging Levels
-*/

#define fiSendEventInfoLogLevel  (2 * osLogLevel_Info_MIN)
#define fiSendEventErrorLogLevel osLogLevel_Error_MIN

/*+
Function prototypes
-*/

/*+
Function:  fiInstallStateMachine()

Purpose:   Copies State Machine data structure(s) updating the actions
           as requested.

Algorithm: After copying the State Machine data structure(s), the actionUpdate
           array is used to modify any action function pointers based on the
           value of compareBase.  The actionUpdate array contains records which
           contain a value to mask compareBase.  If the masked value matches
           the compareTo value for the record, all instances of the originalAction
           function pointer will be replaced by the replacementAction function
           pointer.

           Note that the originalAction function pointers must be found in the source
           of the State Machine data structure(s), not the copied data structure(s).
           This prevents ambiguities which would result if the replacementAction function
           pointers match any originalAction function pointers.
-*/

#ifndef __State_Force_Static_State_Tables__
osGLOBAL void fiInstallStateMachine(
                                   stateTransitionMatrix_t *srcStateTransitionMatrix,
                                   stateActionScalar_t     *srcStateActionScalar,
                                   stateTransitionMatrix_t *dstStateTransitionMatrix,
                                   stateActionScalar_t     *dstStateActionScalar,
                                   os_bit32                    compareBase,
                                   actionUpdate_t           actionUpdate[]
                                 );
#endif /* __State_Force_Static_State_Tables__ was not defined */

/*+
Function:  fiInitializeThread()

Purpose:   Initializes the fi_thread__t data structure to contain hpRoot, the thread
           type and (a) pointer(s) to the State Machine data structure(s).
-*/

osGLOBAL void fiInitializeThread(
                                fi_thread__t                *thread,
                                agRoot_t                *hpRoot,
                                threadType_t             threadType,
                                state_t                  initialState,
                                stateTransitionMatrix_t *stateTransitionMatrix,
                                stateActionScalar_t     *stateActionScalar
                              );

/*+
Function:  fiSendEvent()

Purpose:   Sends an event to a thread immediately as well as (recursively) sending
           any event returned via eventRecord from the action routine called.

Algorithm: The current state of the specified thread and the event passed in are used
           to compute a new state for the thread and to fetch a action routine function
           pointer.

           For the Moore State Machine Model, the actions occur in the states.  So, each
           element of the stateTransitionMatrix contains only the newState for the thread.
           The newAction (which corresponds to this newState) is retrieved from the
           stateActionScalar for this thread.

           In the call to the thread's newAction, an eventRecord_t is passed.  This can be
           used by the action routine to pass on an event to the same or a new thread.  By
           "returning" the event to send, recursion of fiSendEvent() is avoided.  This is
           necessary as stack depth is a critically limited resource in some environments.
-*/

osGLOBAL void fiSendEvent(
                         fi_thread__t *thread,
                         event_t   event
                       );

/*+
Function:  fiSetEventRecord()

Purpose:   Sets the fields of an eventRecord so that the specified event is
           delivered to the specified thread (presumably) upon return from the
           action routine which called fiSetEventRecord().
-*/

osGLOBAL void fiSetEventRecord(
                              eventRecord_t *eventRecord,
                              fi_thread__t      *thread,
                              event_t        event
                            );

/*+
Macro:     fiSetEventRecordNull()

Purpose:   Sets the fields of an eventRecord so that the no event is delivered
           to any thread (presumably) upon return from the action routine which
           called fiSetEventRecordNull().
-*/

#define fiSetEventRecordNull(eventRecord) \
    ((eventRecord_t *)(eventRecord))->thread = (fi_thread__t *)agNULL

/* */

#define STATE_PROTO(x)  extern void x( fi_thread__t *thread,\
                                     eventRecord_t *eventRecord )


#define LogStateTransition( set, threadType, currentState, event)  ((set ? 0x80000000 : 0 ) |(threadType   << 16   ) | (currentState << 8    ) | event )


#endif /* __State_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\aha154x\aha154x.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    aha154x.c

Abstract:

    This is the port driver for the Adaptec 1540B SCSI Adapter.

Author:

    Mike Glass
    Tuong Hoang (Adaptec)
    Renato Maranon (Adaptec)
    Bill Williams (Adaptec)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "miniport.h"
#include "aha154x.h"           // includes scsi.h

VOID
ScsiPortZeroMemory(
    IN PVOID Destination,
    IN ULONG Length
    );

//
// This conditionally compiles in the code to force the DMA transfer speed
// to 5.0.
//

#define FORCE_DMA_SPEED 1

//
// Function declarations
//
// Functions that start with 'A154x' are entry points
// for the OS port driver.
//

ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    );

ULONG
A154xDetermineInstalled(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN OUT PSCAN_CONTEXT Context,
    OUT PBOOLEAN Again
    );


VOID
A154xClaimBIOSSpace(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN PBASE_REGISTER baseIoAddress,
    IN PSCAN_CONTEXT Context,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    );

ULONG
A154xFindAdapter(
    IN PVOID HwDeviceExtension,
    IN PSCAN_CONTEXT Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );


BOOLEAN
A154xAdapterState(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN BOOLEAN SaveState
    );


BOOLEAN
A154xHwInitialize(
    IN PVOID DeviceExtension
    );

#if defined(_SCAM_ENABLED)
//
// Issues SCAM command to HA
//
BOOLEAN
PerformScamProtocol(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    );
#endif

BOOLEAN
A154xStartIo(
    IN PVOID DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
A154xInterrupt(
    IN PVOID DeviceExtension
    );

BOOLEAN
A154xResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    );

SCSI_ADAPTER_CONTROL_STATUS
A154xAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

BOOLEAN
GetHostAdapterBoardId (
    IN PVOID HwDeviceExtension,
    OUT PUCHAR BoardId
    );

//
// This function is called from A154xStartIo.
//

VOID
BuildCcb(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

//
// This function is called from BuildCcb.
//

VOID
BuildSdl(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

//
// This function is called from A154xInitialize.
//

BOOLEAN
AdapterPresent(
    IN PVOID HwDeviceExtension
    );

//
// This function is called from A154xInterrupt.
//

UCHAR
MapError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCCB Ccb
    );

BOOLEAN
ScatterGatherSupported (
   IN PHW_DEVICE_EXTENSION HwDeviceExtension
   );

BOOLEAN SendUnlockCommand(
    IN PVOID HwDeviceExtension,
    IN UCHAR locktype
    );

BOOLEAN UnlockMailBoxes(
    IN PVOID HwDeviceExtension
    );

ULONG
AhaParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    );

//
// This function determines whether adapter is an AMI
//
BOOLEAN
A4448IsAmi(
    IN PHW_DEVICE_EXTENSION  HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    ULONG portNumber
    );


ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object

Return Value:

    Status from ScsiPortInitialize()

--*/

{
    HW_INITIALIZATION_DATA hwInitializationData;
    SCAN_CONTEXT context;
    ULONG isaStatus;
    ULONG mcaStatus;
    ULONG i;

    DebugPrint((1,"\n\nSCSI Adaptec 154X MiniPort Driver\n"));

    //
    // Zero out structure.
    //

    for (i=0; i<sizeof(HW_INITIALIZATION_DATA); i++) {
    ((PUCHAR)&hwInitializationData)[i] = 0;
    }

    //
    // Set size of hwInitializationData.
    //

    hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitializationData.HwInitialize = A154xHwInitialize;
    hwInitializationData.HwResetBus = A154xResetBus;
    hwInitializationData.HwStartIo = A154xStartIo;
    hwInitializationData.HwInterrupt = A154xInterrupt;
    hwInitializationData.HwFindAdapter = A154xFindAdapter;
    hwInitializationData.HwAdapterState = A154xAdapterState;
    hwInitializationData.HwAdapterControl = A154xAdapterControl;

    //
    // Indicate no buffer mapping but will need physical addresses.
    //

    hwInitializationData.NeedPhysicalAddresses = TRUE;

    //
    // Specify size of extensions.
    //

    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = sizeof(HW_LU_EXTENSION);

    //
    // Specifiy the bus type.
    //

    hwInitializationData.AdapterInterfaceType = Isa;
    hwInitializationData.NumberOfAccessRanges = 2;

    //
    // Ask for SRB extensions for CCBs.
    //

    hwInitializationData.SrbExtensionSize = sizeof(CCB);

    //
    // The adapter count is used by the find adapter routine to track how
    // which adapter addresses have been tested.
    //

    context.adapterCount = 0;
    context.biosScanStart = 0;

    isaStatus = ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &context);

    //
    // Now try to configure for the Mca bus.
    // Specifiy the bus type.
    //

    hwInitializationData.AdapterInterfaceType = MicroChannel;
    context.adapterCount = 0;
    context.biosScanStart = 0;
    mcaStatus = ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &context);

    //
    // Return the smaller status.
    //

    return(mcaStatus < isaStatus ? mcaStatus : isaStatus);

} // end A154xEntry()


ULONG
A154xFindAdapter(
    IN PVOID HwDeviceExtension,
    IN PSCAN_CONTEXT Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Register base address
    ConfigInfo - Configuration information structure describing HBA
    This structure is defined in PORT.H.

Return Value:

    ULONG

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG length;
    ULONG status;
    UCHAR adapterTid;
    UCHAR dmaChannel;
    UCHAR irq;
    UCHAR bit;
    UCHAR hostAdapterId[4];

#if defined(_SCAM_ENABLED)
    UCHAR temp, i;
        UCHAR BoardID;
        UCHAR EepromData;
#endif

    //
    // Inform SCSIPORT that we are a WMI data provider and have we GUIDs
    // to register.
    //

    ConfigInfo->WmiDataProvider = TRUE;
    A154xWmiInitialize(deviceExtension);

    //
    // Determine if there are any adapters installed.  Determine installed
    // will initialize the BaseIoAddress if an adapter is found.
    //

    status = A154xDetermineInstalled(deviceExtension,
            ConfigInfo,
            Context,
            Again);

    //
    // If there are no adapters found then return.
    //

    if (status != SP_RETURN_FOUND) {
        return(status);
    }

    //
    // Issue adapter command to get IRQ, DMA channel, and adapter SCSI ID.
    // But first, check for PnP non-default values.  If any of these values
    // are default, then we do 'em all to save code space, since the same
    // command is used.
    //
    // Returns 3 data bytes:
    //
    // Byte 0   Dma Channel
    //
    // Byte 1   Interrupt Channel
    //
    // Byte 2   Adapter SCSI ID
    //

    if (((ConfigInfo->DmaChannel+1) == 0) ||            // default DMA channel ?
        (ConfigInfo->BusInterruptLevel == 0) ||         // default IRQ ?
        ((ConfigInfo->InitiatorBusId[0]+1) == 0)        // default adapter ID ?
        ) {



        if (!WriteCommandRegister(deviceExtension, AC_RET_CONFIGURATION_DATA, TRUE)) {
            DebugPrint((1,"A154xFindAdapter: Get configuration data command failed\n"));
            return SP_RETURN_ERROR;
        }

        //
        // Determine DMA channel.
        //

        if (!ReadCommandRegister(deviceExtension,&dmaChannel,TRUE)) {
            DebugPrint((1,"A154xFindAdapter: Can't read dma channel\n"));
            return SP_RETURN_ERROR;
        }

        if (ConfigInfo->AdapterInterfaceType != MicroChannel) {

            WHICH_BIT(dmaChannel,bit);

            ConfigInfo->DmaChannel = bit;

            DebugPrint((2,"A154xFindAdapter: DMA channel is %x\n",
            ConfigInfo->DmaChannel));

        } else {
            ConfigInfo->InterruptMode = LevelSensitive;
        }

        //
        // Determine hardware interrupt vector.
        //

        if (!ReadCommandRegister(deviceExtension,&irq,TRUE)) {
            DebugPrint((1,"A154xFindAdapter: Can't read adapter irq\n"));
            return SP_RETURN_ERROR;
        }

        WHICH_BIT(irq, bit);

        ConfigInfo->BusInterruptLevel = (UCHAR) 9 + bit;

        //
        // Determine what SCSI bus id the adapter is on.
        //

        if (!ReadCommandRegister(deviceExtension,&adapterTid,TRUE)) {
            DebugPrint((1,"A154xFindAdapter: Can't read adapter SCSI id\n"));
            return SP_RETURN_ERROR;
        }

        //
        // Wait for HACC interrupt.
        //

        SpinForInterrupt(deviceExtension,FALSE);  // eddy

        //
        // Use PnP fields
        //
    } else {
        adapterTid = ConfigInfo->InitiatorBusId[0];
    }

    //
    // Set number of buses.
    //

    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = adapterTid;
    deviceExtension->HostTargetId = adapterTid;

    //
    // Set default CCB command to scatter/gather with residual counts.
    // If the adapter rejects this command, then set the command
    // to scatter/gather without residual.
    //

    deviceExtension->CcbScatterGatherCommand = SCATTER_GATHER_COMMAND;

    if ((ConfigInfo->MaximumTransferLength+1) == 0)
        ConfigInfo->MaximumTransferLength = MAX_TRANSFER_SIZE;

        //
        // NumberOfPhysicalBreaks incorrectly defined.
        // Must be set to MAX_SG_DESCRIPTORS.
        //

    if ((ConfigInfo->NumberOfPhysicalBreaks+1) == 0)
        ConfigInfo->NumberOfPhysicalBreaks = MAX_SG_DESCRIPTORS;
        //ConfigInfo->NumberOfPhysicalBreaks = MAX_SG_DESCRIPTORS - 1;

    if (!ConfigInfo->ScatterGather)
        ConfigInfo->ScatterGather = ScatterGatherSupported(HwDeviceExtension);

    if (!ConfigInfo->ScatterGather) {
        //ConfigInfo->NumberOfPhysicalBreaks = 1;
        DebugPrint((1,"Aha154x: Scatter/Gather not supported!\n"));
    }

    ConfigInfo->Master = TRUE;

    //
    // Allocate a Noncached Extension to use for mail boxes.
    //

    deviceExtension->NoncachedExtension =
    ScsiPortGetUncachedExtension(deviceExtension,
                     ConfigInfo,
                     sizeof(NONCACHED_EXTENSION));

    if (deviceExtension->NoncachedExtension == NULL) {

        //
        // Log error.
        //

        ScsiPortLogError(deviceExtension,
                         NULL,
                         0,
                         0,
                         0,
                         SP_INTERNAL_ADAPTER_ERROR,
                         7 << 8);

        return(SP_RETURN_ERROR);
    }

    //
    // Convert virtual to physical mailbox address.
    //

    deviceExtension->NoncachedExtension->MailboxPA =
       ScsiPortConvertPhysicalAddressToUlong(
        ScsiPortGetPhysicalAddress(deviceExtension,
                 NULL,
                 deviceExtension->NoncachedExtension->Mbo,
                 &length));

    //
    // Set default bus on time.  Then check for an override parameter.
    //

    deviceExtension->BusOnTime = 0x07;
    if (ArgumentString != NULL) {

        length = AhaParseArgumentString(ArgumentString, "BUSONTIME");

        //
        // Validate that the new bus on time is reasonable before attempting
        // to set it.
        //

        if (length >= 2 && length <= 15) {

            deviceExtension->BusOnTime = (UCHAR) length;
            DebugPrint((1,"A154xFindAdapter: Setting bus on time: %ld\n", length));
        }
    }

    //
    // Set maximum cdb length to zero unless the user has overridden the value
    //

    if( ArgumentString != NULL) {

        length = AhaParseArgumentString(ArgumentString, "MAXCDBLENGTH");

        //
        // Validate the maximum cdb length before attempting to set it
        //

        if (length >= 6 && length <= 20) {

            deviceExtension->MaxCdbLength = (UCHAR) length;
            DebugPrint((1, "A154xFindAdapter: Setting maximum cdb length: %ld\n", length));
        }

    } else {

        GetHostAdapterBoardId(HwDeviceExtension,&hostAdapterId[0]);

        if(hostAdapterId[BOARD_ID] < 'E') {

            deviceExtension->MaxCdbLength = 10;
            DebugPrint((1, "A154xFindAdapter: Old firmware - Setting maximum cdb length: %ld\n", length));

        } else {

            length = deviceExtension->MaxCdbLength = 0;
            DebugPrint((1, "A154xFindAdapter: Setting maximum cdb length: %ld\n", length));

        }

    }

#if defined(_SCAM_ENABLED)
        //
        // Get info to determine if miniport must issues SCAM command.
        //
    DebugPrint((1,"A154x => Start SCAM enabled determination.", length));

    deviceExtension->PerformScam = FALSE;

    do {
        //
        // Fall through do loop if a command fails.
        //
        if (!WriteCommandRegister(deviceExtension,AC_ADAPTER_INQUIRY,FALSE)) {
            break;
        }

        if ((ReadCommandRegister(deviceExtension,&BoardID,TRUE)) == FALSE) {
            break;
        }

        //
        // Don't care about three other bytes
        //
        for (i=0; i < 0x3; i++) {
            if ((ReadCommandRegister(deviceExtension,&temp,TRUE)) == FALSE) {
                            break;
            }
        }

        SpinForInterrupt(HwDeviceExtension,FALSE);

        //
        // Check to see that three 'extra bytes' were read.
        //
        if (i != 0x3)
            break;

        if (BoardID >= 'F') {

            if (!WriteCommandRegister(deviceExtension,AC_RETURN_EEPROM,FALSE)) {
                break;
            }

            //
            // Flag Byte => set returns configured options
            //
            if (!WriteCommandRegister(deviceExtension,0x01,FALSE)) {
                break;
            }
            //
            // Data length => reading one byte.
            //
            if (!WriteCommandRegister(deviceExtension,0x01,FALSE)) {
                break;

            }
            //
            // Data offset => read SCSI_BUS_CONTROL_FLAG
            //
            if (!WriteCommandRegister(deviceExtension,SCSI_BUS_CONTROL_FLAG,FALSE)) {
                break;
            }

            //
            // Read it!
            //
            if ((ReadCommandRegister(deviceExtension,&EepromData,TRUE)) == FALSE) {
                break;
            }

            SpinForInterrupt(HwDeviceExtension,FALSE);

            //
            // SCAM only if it's enabled in SCSISelect.
            //
            if (EepromData | SCAM_ENABLED) {
                DebugPrint((1,"A154x => SCAM Enabled\n"));
                deviceExtension->PerformScam = TRUE;
            }
        }
    } while (FALSE);

#endif

    DebugPrint((3,"A154xFindAdapter: Configuration completed\n"));
    return SP_RETURN_FOUND;
} // end A154xFindAdapter()



BOOLEAN
A154xAdapterState(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN BOOLEAN SaveState
    )
/*++

Routine Description:

    This function is called after FindAdapter with SaveState set to TRUE,
    inidicating that the adapter state should be saved.  Before Chicago
    exits, this function is again called with SaveState set to FALSE,
    indicating the adapter should be restored to the same state it was
    when this function was first called.  By saving its real mode state
    and restoring it during protected mode exit will give the adapter
    a higher chance of working back in real mode.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Register base address
    SaveState - Flag to indicate whether to perform SAVE or RESTORE.
                                     TRUE == SAVE, FALSE == RESTORE.

Return Value:

    TRUE                SAVE/RESTORE operation was successful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR idx;
    UCHAR cfgsz = sizeof(RM_CFG);
    PRM_CFG SaveCfg;

    deviceExtension = HwDeviceExtension;
    SaveCfg = &deviceExtension->RMSaveState;

    //
    // SAVE real mode state
    //
    if (SaveState) {
        //
        // Read off config data from AHA154X...
        //
        if (!WriteCommandRegister(deviceExtension, AC_RETURN_SETUP_DATA, TRUE))
            return FALSE;

        if (!WriteDataRegister(deviceExtension, cfgsz))
            return FALSE;

        for (idx=0;idx<cfgsz;idx++) {
            if (!(ReadCommandRegister(HwDeviceExtension,(PUCHAR)(SaveCfg),TRUE)))
                return FALSE;
            ((PUCHAR)SaveCfg)++;
        }

        //
        // ...and wait for interrupt
        //

        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        //
        // RESTORE state to real mode
        //
    } else {
        //
        // If mailbox count was not zero, re-initialize mailbox addresses
        // saved from real mode
        //

        if (SaveCfg->NumMailBoxes) {

        if (!WriteCommandRegister(deviceExtension, AC_MAILBOX_INITIALIZATION, TRUE))
            return FALSE;
        if (!WriteDataRegister(deviceExtension, SaveCfg->NumMailBoxes))
            return FALSE;
        if (!WriteDataRegister(deviceExtension, SaveCfg->MBAddrHiByte))
            return FALSE;
        if (!WriteDataRegister(deviceExtension, SaveCfg->MBAddrMiByte))
            return FALSE;
        if (!WriteDataRegister(deviceExtension, SaveCfg->MBAddrLoByte))
            return FALSE;

        //
        // ... and wait for interrupt.
        //

        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        }

        //
        // Restore transfer speed gotten from real mode...
        //

        if (!WriteCommandRegister(deviceExtension, AC_SET_TRANSFER_SPEED, TRUE))
            return FALSE;

        if (!WriteDataRegister(deviceExtension, SaveCfg->TxSpeed))
            return FALSE;

        //
        // ... and wait for interrupt.
        //

        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        //
        // Restore setting for bus on time from real mode...
        //

        if (!WriteCommandRegister(deviceExtension, AC_SET_BUS_ON_TIME, TRUE))
            return FALSE;

        if (!WriteDataRegister(deviceExtension, SaveCfg->BusOnTime))
            return FALSE;

        //
        // ...and wait for interrupt
        //
        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        //
        // Restore setting for bus off time from real mode...
        //

        if (!WriteCommandRegister(deviceExtension, AC_SET_BUS_OFF_TIME, TRUE))
            return FALSE;

        if (!WriteDataRegister(deviceExtension, SaveCfg->BusOffTime))
            return FALSE;

        //
        // ...and wait for interrupt
        //
        if (!SpinForInterrupt(deviceExtension,TRUE))
            return FALSE;

        //
        // Reset any pending interrupts
        //
        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

    }
    return TRUE;

} // end A154xAdapterState()


SCSI_ADAPTER_CONTROL_STATUS
A154xAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )

/*++

Routine Description:

    This routine is called at various time's by SCSIPort and is used
        to provide a control function over the adapter. Most commonly, NT
        uses this entry point to control the power state of the HBA during
        a hibernation operation.

Arguments:

    HwDeviceExtension - HBA miniport driver's per adapter storage
    Parameters  - This varies by control type, see below.
    ControlType - Indicates which adapter control function should be
                  executed. Conrol Types are detailed below.

Return Value:

     ScsiAdapterControlSuccess - requested ControlType completed successfully
     ScsiAdapterControlUnsuccessful - requested ControlType failed

--*/


{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
    ULONG AdjustedMaxControlType;

    ULONG Index;
    UCHAR Retries;
    //
    // Default Status
    //
    SCSI_ADAPTER_CONTROL_STATUS Status = ScsiAdapterControlSuccess;

    //
    // Structure defining which functions this miniport supports
    //

    BOOLEAN SupportedConrolTypes[A154X_TYPE_MAX] = {
        TRUE,   // ScsiQuerySupportedControlTypes
        TRUE,   // ScsiStopAdapter
        TRUE,   // ScsiRestartAdapter
        FALSE,  // ScsiSetBootConfig
        FALSE   // ScsiSetRunningConfig
        };

    //
    // Execute the correct code path based on ControlType
    //
    switch (ControlType) {

        case ScsiQuerySupportedControlTypes:
            //
            // This entry point provides the method by which SCSIPort determines the
            // supported ControlTypes. Parameters is a pointer to a
            // SCSI_SUPPORTED_CONTROL_TYPE_LIST structure. Fill in this structure
            // honoring the size limits.
            //
            ControlTypeList = Parameters;
            AdjustedMaxControlType =
                (ControlTypeList->MaxControlType < A154X_TYPE_MAX) ?
                ControlTypeList->MaxControlType :
                                                                                                                                                                                 A154X_TYPE_MAX;
            for (Index = 0; Index < AdjustedMaxControlType; Index++) {
                ControlTypeList->SupportedTypeList[Index] =
                    SupportedConrolTypes[Index];
            }
            break;

        case ScsiStopAdapter:
            //
            // This entry point  is called by SCSIPort when it needs to stop/disable
            // the HBA. Parameters is a pointer to the HBA's HwDeviceExtension. The adapter
            // has already been quiesced by SCSIPort (i.e. no outstanding SRBs). Hence the adapter
            // should abort/complete any internally generated commands, disable adapter interrupts
            // and optionally power down the adapter.
            //

            //
            // Before we stop the adapter, we need to save the adapter's state
            // information for reinitialization purposes. For this adpater the
            // HwSaveState entry point will suffice.
            //
            if (A154xAdapterState(HwDeviceExtension, NULL, TRUE) == FALSE) {
                //
                // Adapter is unable to save it's state information, we must fail this
                // request since the process of restarting the adapter will not succeed.
                //
                return ScsiAdapterControlUnsuccessful;
            }

            //
            // It is not possible to disable interrupts on the 1540 series of cards. The alternative is to
            // reset the adapter, clear any remaining interrupts and return success. If it is impossible to
            // queiese the interrupt line, we may not honor the request to stop the adapter. It should be
            // noted that while this solution is not perfect, the typical usage of the 1540 series of adapters
            // renders the likelihood of asyncnronous interrupts nil.
            //
            Retries = 0x0;

            do {
                //
                // Reset the adapter
                //
                ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_HARD_RESET);

                //
                // Wait for idle with timeout (500ms timer)
                //
                for (Index = 0; Index < 500000; Index++) {

                    if (ScsiPortReadPortUchar(&baseIoAddress->StatusRegister) & IOP_SCSI_HBA_IDLE) {

                        //
                        // Upon reaching this point, the adapter has been reset and idled. If there are no interrupts
                        // pending, we can leave having given ourselves the greatest level of assurance that no
                        // future interrupts await.
                        //
                        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

                        if (!(ScsiPortReadPortUchar(&baseIoAddress->InterruptRegister) & IOP_ANY_INTERRUPT)) {
                            //
                            // Sucess!
                            //
                            return Status;
                        }
                    }

                    //
                    // one ms delay
                    //
                    ScsiPortStallExecution(1);
                }
                //
                // Operation should be retried a few times in case it fails.
                //
            } while (Retries < 10);

            break;

            case ScsiRestartAdapter:
                //
                // This entry point is called by SCSIPort when it needs to re-enable
                // a previously stopped adapter. In the generic case, previously
                // suspended IO operations should be restarted and the adapter's
                // previous configuration should be reinstated. Our hardware device
                // extension and uncached extensions have been preserved so no
                // actual driver software reinitialization is necesarry.
                //

                //
                // The adapter's firmware configuration is returned via HwAdapterState.
                //
                if (A154xAdapterState(HwDeviceExtension, NULL, FALSE) == FALSE) {
                    //
                    // Adapter is unable to restore it's state information, we must fail this
                    // request since the process of restarting the adapter will not succeed.
                    //
                    Status = ScsiAdapterControlUnsuccessful;
                }

                A154xResetBus(deviceExtension, SP_UNTAGGED);
                break;

            case ScsiSetBootConfig:
                Status = ScsiAdapterControlUnsuccessful;
                break;

            case ScsiSetRunningConfig:
                Status = ScsiAdapterControlUnsuccessful;
                break;

            case ScsiAdapterControlMax:
                Status = ScsiAdapterControlUnsuccessful;
                break;

            default:
                Status = ScsiAdapterControlUnsuccessful;
                break;
    }

    return Status;
}


BOOLEAN
AdaptecAdapter(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN ULONG   IoPort,
    IN BOOLEAN Mca
    )

/*++

Routine Description:

    This routine checks the Special Options byte of the Adapter Inquiry
    command to see if it is one of the two values returned by Adaptec
    Adapters.  This avoids claiming adapters from BusLogic and DTC.

Arguments:

    HwDeviceExtension - miniport driver's adapter extension.

Return Values:

    TRUE if the adapter looks like an Adaptec.
    FALSE if not.

--*/

{
    UCHAR byte;
    UCHAR specialOptions;
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;

    if (Mca == TRUE) {
        INIT_DATA initData;
        LONG slot;
        LONG i;

        for (slot = 0; slot < NUMBER_POS_SLOTS; slot++) {
            i = ScsiPortGetBusData(HwDeviceExtension,
                       Pos,
                       0,
                       slot,
                       &initData.PosData[slot],
                       sizeof(POS_DATA));
            if (i < (sizeof(POS_DATA))) {
                initData.PosData[slot].AdapterId = 0xffff;
            }
        }

        for (slot = 0; slot < NUMBER_POS_SLOTS; slot++) {
            if (initData.PosData[slot].AdapterId == POS_IDENTIFIER) {
                switch (initData.PosData[slot].IoPortInformation & POS_PORT_MASK) {
                    case POS_PORT_130:
                        if (IoPort == 0x0130) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_134:
                        if (IoPort == 0x0134) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_230:
                        if (IoPort == 0x0230) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_234:
                        if (IoPort == 0x234) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_330:
                        if (IoPort == 0x330) {
                            return TRUE;
                        }
                        break;
                    case POS_PORT_334:
                        if (IoPort == 0x334) {
                            return TRUE;
                        }
                        break;
                }
            }
        }
        return FALSE;
    }

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,
        IOP_INTERRUPT_RESET);

    if (!WriteCommandRegister(HwDeviceExtension,AC_ADAPTER_INQUIRY,FALSE)) {
        return FALSE;
    }

    //
    // Byte 0.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Get the special options byte.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&specialOptions,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Get the last two bytes and clear the interrupt.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return FALSE;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Wait for HACC interrupt.
    //

    SpinForInterrupt(HwDeviceExtension,FALSE);   // eddy


    if ((specialOptions == 0x30) || (specialOptions == 0x42)) {
        return TRUE;
    }

    return FALSE;
}

ULONG
A154xDetermineInstalled(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN OUT PSCAN_CONTEXT Context,
    OUT PBOOLEAN Again
    )

/*++

Routine Description:

    Determine if Adaptec 154X SCSI adapter is installed in system
    by reading the status register as each base I/O address
    and looking for a pattern.  If an adapter is found, the BaseIoAddres is
    initialized.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

    ConfigInfo - Supplies the known configuraiton information.

    AdapterCount - Supplies the count of adapter slots which have been tested.

    Again - Returns whehter the  OS specific driver should call again.

Return Value:

    Returns a status indicating whether a driver is present or not.

--*/

{
    PBASE_REGISTER baseIoAddress;
    PUCHAR ioSpace;
    UCHAR  portValue;
    ULONG  ioPort;

    //
    // Check for configuration information passed in from system.
    //

    if ((*ConfigInfo->AccessRanges)[0].RangeLength != 0) {

        ULONG i;
        PACCESS_RANGE ioRange = NULL;

        for(i = 0; i < ConfigInfo->NumberOfAccessRanges; i++) {

            ioRange = &((*ConfigInfo->AccessRanges)[i]);

            //
            // Search for an io port range.
            //

            if(ioRange->RangeInMemory == FALSE) {
                break;
            }
        }

        if (ioRange == NULL) {
            return SP_RETURN_BAD_CONFIG;
        }

        if(ioRange->RangeInMemory) {

            //
            // No i/o range found for the card in the provided config.  Bail
            //

            *Again = TRUE;
            return SP_RETURN_BAD_CONFIG;
        }

        ioSpace = ScsiPortGetDeviceBase(HwDeviceExtension,
                                        ConfigInfo->AdapterInterfaceType,
                                        ConfigInfo->SystemIoBusNumber,
                                        ioRange->RangeStart,
                                        ioRange->RangeLength,
                                        TRUE);

        if(ioSpace == NULL) {
            return SP_RETURN_ERROR;
        }

        baseIoAddress = (PBASE_REGISTER) ioSpace;

        HwDeviceExtension->BaseIoAddress = baseIoAddress;

        *Again = FALSE;

        return (ULONG)SP_RETURN_FOUND;

    } else {

        //
        // The following table specifies the ports to be checked when searching for
        // an adapter.  A zero entry terminates the search.
        //

        CONST ULONG AdapterAddresses[7] = {0X330, 0X334, 0X234, 0X134, 0X130, 0X230, 0};

        //
        // Scan possible base addresses looking for adapters.
        //

        while (AdapterAddresses[Context->adapterCount] != 0) {

            //
            // Get the system physical address for this card.  The card uses
            // I/O space.
            //

            ioPort = AdapterAddresses[Context->adapterCount];

            ioSpace =
                ScsiPortGetDeviceBase(HwDeviceExtension,
                                      ConfigInfo->AdapterInterfaceType,
                                      ConfigInfo->SystemIoBusNumber,
                                      ScsiPortConvertUlongToPhysicalAddress(ioPort),
                                      0x4,
                                      TRUE);

            //
            // Get next base address.
            //

            baseIoAddress = (PBASE_REGISTER) ioSpace;

            HwDeviceExtension->BaseIoAddress = baseIoAddress;

            //
            // Update the Adapter count
            //

            (Context->adapterCount)++;

            //
            // Check to see if adapter present in system.
            //

            portValue = ScsiPortReadPortUchar((PUCHAR)baseIoAddress);

            //
            // Check for Adaptec adapter.
            // The mask (0x29) are bits that may or may not be set.
            // The bit 0x10 (IOP_SCSI_HBA_IDLE) should be set.
            //

            if ((portValue & ~0x29) == IOP_SCSI_HBA_IDLE) {

                if (!AdaptecAdapter(
                        HwDeviceExtension,
                        ioPort,
                        (BOOLEAN)(ConfigInfo->AdapterInterfaceType == MicroChannel ? TRUE : FALSE))) {

                    DebugPrint((1,"A154xDetermineInstalled: Clone command completed successfully - \n not our board;"));

                    ScsiPortFreeDeviceBase(HwDeviceExtension, ioSpace);
                    continue;

                //
                // Run AMI4448 detection code.
                //

                } else if (A4448IsAmi(HwDeviceExtension,
                                      ConfigInfo,
                                      AdapterAddresses[(Context->adapterCount) - 1])) {

                    DebugPrint ((1,
                                 "A154xDetermineInstalled: Detected AMI4448\n"));
                    ScsiPortFreeDeviceBase(HwDeviceExtension, ioSpace);
                    continue;
                }

                //
                // An adapter has been found. Request another call.
                //

                *Again = TRUE;

                //
                // Fill in the access array information.
                //

                (*ConfigInfo->AccessRanges)[0].RangeStart =
                    ScsiPortConvertUlongToPhysicalAddress(
                        AdapterAddresses[Context->adapterCount - 1]);
                (*ConfigInfo->AccessRanges)[0].RangeLength = 4;
                (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

                //
                // Check if BIOS is enabled and claim that memory range.
                //

                A154xClaimBIOSSpace(HwDeviceExtension,
                                    baseIoAddress,
                                    Context,
                                    ConfigInfo);

                return (ULONG)SP_RETURN_FOUND;

            } else {
                ScsiPortFreeDeviceBase(HwDeviceExtension, ioSpace);
            }
        }
    }

    //
    // The entire table has been searched and no adapters have been found.
    // There is no need to call again and the device base can now be freed.
    // Clear the adapter count for the next bus.
    //

    *Again = FALSE;
    Context->adapterCount = 0;
    Context->biosScanStart = 0;

     return SP_RETURN_NOT_FOUND;

} // end A154xDetermineInstalled()

VOID
A154xClaimBIOSSpace(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension,
    IN PBASE_REGISTER  BaseIoAddress,
    IN OUT PSCAN_CONTEXT Context,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )

/*++

Routine Description:

    This routine is called from A154xDetermineInstalled to find
    and claim BIOS space.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    BaseIoAddress - IO address of adapter
    ConfigInfo - Miniport configuration information

Return Value:

    None.

--*/

{

    UCHAR  inboundData, byte;
    ULONG  baseBIOSAddress;
    ULONG  i, j;
    PUCHAR biosSpace, biosPtr;
    UCHAR  aha154xBSignature[16] =
           { 0x06, 0x73, 0x01, 0xC3, 0x8A, 0xE7, 0xC6, 0x06,
             0x42, 0x00, 0x00, 0xF9, 0xC3, 0x88, 0x26, 0x42 };

    //
    // Reset interrupt just in case.
    //

    ScsiPortWritePortUchar(&BaseIoAddress->StatusRegister,
                           IOP_INTERRUPT_RESET);

    //
    // The Adapter Inquiry command will return 4 bytes describing
    // the firmware revision level.
    //

    if (WriteCommandRegister(HwDeviceExtension,
                             AC_ADAPTER_INQUIRY,TRUE) == FALSE) {
        return;
    }

    if ((ReadCommandRegister(HwDeviceExtension,
                             &inboundData,TRUE)) == FALSE) {
        return;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&byte,TRUE)) == FALSE) {
        return;
    }

    //
    // Wait for HACC by hand.
    //

    SpinForInterrupt(HwDeviceExtension, FALSE);

    //
    // If the 1st bytethe adapter inquiry command is 0x41,
    // then the adapter is an AHA154XB; if 0x44 or 0x45 then
    // it is an AHA154XC or CF respectively
    //
    // if we've already checked all the possible locations for
    // an AHA154XB bios don't waste time mapping the ports
    //

    if ((inboundData == 0x41)&&(Context->biosScanStart < 6)) {

        //
        // Get the system physical address for this BIOS section.
        //

        biosSpace =
            ScsiPortGetDeviceBase(HwDeviceExtension,
                                  ConfigInfo->AdapterInterfaceType,
                                  ConfigInfo->SystemIoBusNumber,
                                  ScsiPortConvertUlongToPhysicalAddress(0xC8000),
                                  0x18000,
                                  FALSE);

        //
        // Loop through all BIOS base possibilities.  Use the context information
        // to pick up where we left off the last time around.
        //

        for (i = Context->biosScanStart; i < 6; i ++) {

            biosPtr = biosSpace + i * 0x4000 + 16;

            //
            // Compare the second 16 bytes to BIOS header

            for (j = 0; j < 16; j++) {

                if (aha154xBSignature[j] != ScsiPortReadRegisterUchar(biosPtr)) {
                    break;
                }

                biosPtr++;
            }

            if (j == 16) {

                //
                // Found the BIOS. Set up ConfigInfo->AccessRanges
                //

                (*ConfigInfo->AccessRanges)[1].RangeStart =
                    ScsiPortConvertUlongToPhysicalAddress(0xC8000 + i * 0x4000);
                (*ConfigInfo->AccessRanges)[1].RangeLength = 0x4000;
                (*ConfigInfo->AccessRanges)[1].RangeInMemory = TRUE;

                DebugPrint((1,
                           "A154xClaimBiosSpace: 154XB BIOS address = %lX\n",
                           0xC8000 + i * 0x4000 ));
                break;
            }
        }

        Context->biosScanStart = i + 1;
        ScsiPortFreeDeviceBase(HwDeviceExtension, (PVOID)biosSpace);

    } else {

        if ((inboundData == 0x44) || (inboundData == 0x45)) {

            //
            // Fill in BIOS address information
            //

            ScsiPortWritePortUchar(&BaseIoAddress->StatusRegister,
                                   IOP_INTERRUPT_RESET);

            if (WriteCommandRegister(HwDeviceExtension,
                                     AC_RETURN_SETUP_DATA,TRUE) == FALSE) {
                return;
            }

            //
            // Send length of incoming transfer for the Return Setup Data
            //

            if (WriteDataRegister(HwDeviceExtension,0x27) == FALSE) {
                return;
            }

            //
            // Magic Adaptec C rev byte.
            //

            for (i = 0; i < 0x27; i++) {
                if ((ReadCommandRegister(HwDeviceExtension,
                                         &inboundData,TRUE)) == FALSE) {
                    return;
                }
            }

            //
            // Interrupt handler is not yet installed so wait for HACC by hand.
            //

            SpinForInterrupt(HwDeviceExtension, FALSE);

            inboundData >>= 4;
            inboundData &= 0x07;        // Filter BIOS bits out
            baseBIOSAddress = 0xC8000;

            if (inboundData != 0x07 && inboundData != 0x06) {

                baseBIOSAddress +=
                    (ULONG)((~inboundData & 0x07) - 2) * 0x4000;

                (*ConfigInfo->AccessRanges)[1].RangeStart =
                    ScsiPortConvertUlongToPhysicalAddress(baseBIOSAddress);
                (*ConfigInfo->AccessRanges)[1].RangeLength = 0x4000;
                (*ConfigInfo->AccessRanges)[1].RangeInMemory = TRUE;

                DebugPrint((1,
                           "A154xClaimBiosSpace: 154XC BIOS address = %lX\n",
                           baseBIOSAddress));
            }
        }
    }

    return;
}



BOOLEAN
A154xHwInitialize(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine is called from ScsiPortInitialize
    to set up the adapter so that it is ready to service requests.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PNONCACHED_EXTENSION noncachedExtension =
    deviceExtension->NoncachedExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR status;
    ULONG i;

    DebugPrint((2,"A154xHwInitialize: Reset aha154X and SCSI bus\n"));

    //
    // Reset SCSI chip.
    //

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_HARD_RESET);

    //
    // Inform the port driver that the bus has been reset.
    //

    ScsiPortNotification(ResetDetected, HwDeviceExtension, 0);

    ScsiPortStallExecution(500*1000);

    //
    // Wait up to 5000 microseconds for adapter to initialize.
    //

    for (i = 0; i < 5000; i++) {

        ScsiPortStallExecution(1);

        status = ScsiPortReadPortUchar(&deviceExtension->BaseIoAddress->StatusRegister);

        if (status & IOP_SCSI_HBA_IDLE) {
            break;
        }
    }

    //
    // Check if reset failed or succeeded.
    //

    if (!(status & IOP_SCSI_HBA_IDLE) || !(status & IOP_MAILBOX_INIT_REQUIRED)) {
        DebugPrint((1,"A154xInitialize: Reset SCSI bus failed\n"));
        return FALSE;
    }

    //
    // Unlock mailboxes in case the adapter is a 1540B with 1Gb support
    // or 1540C with extended translation enabled.
    //

    status = UnlockMailBoxes(deviceExtension);
    (VOID) SpinForInterrupt(deviceExtension,FALSE);  // eddy

    //
    // Zero out mailboxes.
    //

    for (i=0; i<MB_COUNT; i++) {

        PMBO mailboxOut;
        PMBI mailboxIn;

        mailboxIn = &noncachedExtension->Mbi[i];
        mailboxOut = &noncachedExtension->Mbo[i];

        mailboxOut->Command = mailboxIn->Status = 0;
    }

    //
    // Zero preivous indexes.
    //

    deviceExtension->MboIndex = 0;
    deviceExtension->MbiIndex = 0;

    DebugPrint((3,"A154xHwInitialize: Initialize mailbox\n"));

    if (!WriteCommandRegister(deviceExtension,AC_MAILBOX_INITIALIZATION, TRUE)) {
        DebugPrint((1,"A154xHwInitialize: Can't initialize mailboxes\n"));
        return FALSE;
    }

    //
    // Send Adapter number of mailbox locations.
    //

    if (!WriteDataRegister(deviceExtension, MB_COUNT)) {
        return FALSE;
    }

    //
    // Send the most significant byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte2)) {
        return FALSE;
    }

    //
    // Send the middle byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte1)) {
        return FALSE;
    }

    //
    // Send the least significant byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte0)) {
        return FALSE;
    }

#ifdef FORCE_DMA_SPEED
    //
    // Set the DMA transfer speed to 5.0 MB/second. This is because
    // faster transfer speeds cause data corruption on 486/33 machines.
    // This overrides the card jumper setting.
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_TRANSFER_SPEED, TRUE)) {

        DebugPrint((1,"Can't set dma transfer speed\n"));

    } else if (!WriteDataRegister(deviceExtension, DMA_SPEED_50_MBS)) {

        DebugPrint((1,"Can't set dma transfer speed\n"));
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
        return TRUE;
    }
#endif

    //
    // Override default setting for bus on time. This makes floppy
    // drives work better with this adapter.
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_BUS_ON_TIME, TRUE)) {

        DebugPrint((1,"Can't set bus on time\n"));

    } else if (!WriteDataRegister(deviceExtension, deviceExtension->BusOnTime)) {

        DebugPrint((1,"Can't set bus on time\n"));
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
        return TRUE;
    }


    //
    // Override the default CCB timeout of 250 mseconds to 500 (0x1F4).
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_SELECTION_TIMEOUT, TRUE)) {
        DebugPrint((1,"A154xHwInitialize: Can't set CCB timeout\n"));
    }
    else {
        if (!WriteDataRegister(deviceExtension,0x01)) {
            DebugPrint((1,"A154xHwInitialize: Can't set timeout selection enable\n"));
        }

        if (!WriteDataRegister(deviceExtension,0x00)) {
            DebugPrint((1,"A154xHwInitialize: Can't set second byte\n"));
        }

        if (!WriteDataRegister(deviceExtension,0x01)) {
            DebugPrint((1,"A154xHwInitialize: Can't set MSB\n"));
        }

        if (!WriteDataRegister(deviceExtension,0xF4)) {
            DebugPrint((1,"A154xHwInitialize: Can't set LSB\n"));
        }
    }


    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
        return TRUE;
    }

#if defined(_SCAM_ENABLED)
    //
    // SCAM because A154xHwInitialize reset's the SCSI bus.
    //

    PerformScamProtocol(deviceExtension);
#endif

    return TRUE;

} // end A154xHwInitialize()

#if defined(_SCAM_ENABLED)

BOOLEAN
PerformScamProtocol(
    IN PHW_DEVICE_EXTENSION deviceExtension
        )

{

    if (deviceExtension->PerformScam) {

        DebugPrint((1,"AHA154x => Starting SCAM operation.\n"));

        if (!WriteCommandRegister(deviceExtension, AC_PERFORM_SCAM, TRUE)) {

            DebugPrint((0,"AHA154x => Adapter time out, SCAM command failure.\n"));

            ScsiPortLogError(deviceExtension,
                             NULL,
                             0,
                             deviceExtension->HostTargetId,
                             0,
                             SP_INTERNAL_ADAPTER_ERROR,
                             0xA << 8);
            return FALSE;

        } else {

            DebugPrint((1,"AHA154x => SCAM Performed OK.\n"));
            return TRUE;
        }
    } else {

        DebugPrint((1,"AHA154x => SCAM not performed, non-SCAM adapter.\n"));
        return FALSE;
    }

} //End PerformScamProtocol
#endif


BOOLEAN
A154xStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver synchronized
    with the kernel. The mailboxes are scanned for an empty one and
    the CCB is written to it. Then the doorbell is rung and the
    OS port driver is notified that the adapter can take
    another request, if any are available.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PNONCACHED_EXTENSION noncachedExtension =
    deviceExtension->NoncachedExtension;
    PMBO mailboxOut;
    PCCB ccb;
    PHW_LU_EXTENSION luExtension;

    ULONG i = deviceExtension->MboIndex;
    ULONG physicalCcb;
    ULONG length;

    DebugPrint((3,"A154xStartIo: Enter routine\n"));

    //
    // Check if command is a WMI request.
    //

    if (Srb->Function == SRB_FUNCTION_WMI) {

       //
       // Process the WMI request and return.
       //

       return A154xWmiSrb(HwDeviceExtension, (PSCSI_WMI_REQUEST_BLOCK) Srb);
    }

    //
    // Check if command is an ABORT request.
    //

    if (Srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

        //
        // Verify that SRB to abort is still outstanding.
        //

        luExtension =
            ScsiPortGetLogicalUnit(deviceExtension,
                       Srb->PathId,
                       Srb->TargetId,
                       Srb->Lun);

        if ((luExtension == NULL) ||
            (luExtension->CurrentSrb == NULL)) {

            DebugPrint((1, "A154xStartIo: SRB to abort already completed\n"));

            //
            // Complete abort SRB.
            //

            Srb->SrbStatus = SRB_STATUS_ABORT_FAILED;

            ScsiPortNotification(RequestComplete,
                 deviceExtension,
                Srb);
            //
            // Adapter ready for next request.
            //

            ScsiPortNotification(NextRequest,
                deviceExtension,
                NULL);

            return TRUE;
        }

        //
        // Get CCB to abort.
        //

        ccb = Srb->NextSrb->SrbExtension;

        //
        // Set abort SRB for completion.
        //

        ccb->AbortSrb = Srb;

    } else {

        ccb = Srb->SrbExtension;

        //
        // Save SRB back pointer in CCB.
        //

        ccb->SrbAddress = Srb;
    }

    //
    // Make sure that this request isn't too long for the adapter.  If so
    // bounce it back as an invalid request
    //

    if ((deviceExtension->MaxCdbLength) &&
        (deviceExtension->MaxCdbLength < Srb->CdbLength)) {

        DebugPrint((1,"A154xStartIo: Srb->CdbLength [%d] > MaxCdbLength [%d].  Invalid request\n",
                    Srb->CdbLength,
                    deviceExtension->MaxCdbLength
                  ));

        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

        ScsiPortNotification(RequestComplete,
            deviceExtension,
            Srb);

        ScsiPortNotification(NextRequest,
            deviceExtension,
            NULL);

        return TRUE;
    }

    //
    // Get CCB physical address.
    //

    physicalCcb = ScsiPortConvertPhysicalAddressToUlong(
        ScsiPortGetPhysicalAddress(deviceExtension, NULL, ccb, &length));

    //
    // Find free mailboxOut.
    //

    do {

        mailboxOut = &noncachedExtension->Mbo[i % MB_COUNT];
        i++;

    } while (mailboxOut->Command != MBO_FREE);

    //
    // Save the next free location.
    //

    deviceExtension->MboIndex = (UCHAR) (i % MB_COUNT);

    DebugPrint((3,"A154xStartIo: MBO address %lx, Loop count = %d\n", mailboxOut, i));

    //
    // Write CCB to mailbox.
    //

    FOUR_TO_THREE(&mailboxOut->Address,
          (PFOUR_BYTE)&physicalCcb);

    switch (Srb->Function) {

        case SRB_FUNCTION_ABORT_COMMAND:

            DebugPrint((1, "A154xStartIo: Abort request received\n"));

            //
            // Race condition (what if CCB to be aborted
            // completes after setting new SrbAddress?)
            //

            mailboxOut->Command = MBO_ABORT;

            break;

        case SRB_FUNCTION_RESET_BUS:

            //
            // Reset aha154x and SCSI bus.
            //

            DebugPrint((1, "A154xStartIo: Reset bus request received\n"));

            if (!A154xResetBus(
                deviceExtension,
                Srb->PathId
                )) {

                DebugPrint((1,"A154xStartIo: Reset bus failed\n"));

                Srb->SrbStatus = SRB_STATUS_ERROR;

            } else {

                Srb->SrbStatus = SRB_STATUS_SUCCESS;
            }


            ScsiPortNotification(RequestComplete,
                deviceExtension,
                Srb);

            ScsiPortNotification(NextRequest,
                deviceExtension,
                NULL);

            return TRUE;

        case SRB_FUNCTION_EXECUTE_SCSI:

            //
            // Get logical unit extension.
            //

            luExtension =
            ScsiPortGetLogicalUnit(deviceExtension,
                       Srb->PathId,
                       Srb->TargetId,
                       Srb->Lun);

            //
            // Move SRB to logical unit extension.
            //

            luExtension->CurrentSrb = Srb;

            //
            // Build CCB.
            //

            BuildCcb(deviceExtension, Srb);

            mailboxOut->Command = MBO_START;

            break;

        case SRB_FUNCTION_RESET_DEVICE:

            DebugPrint((1,"A154xStartIo: Reset device not supported\n"));

            //
            // Drop through to default.
            //

        default:

            //
            // Set error, complete request
            // and signal ready for next request.
            //

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

            ScsiPortNotification(RequestComplete,
                deviceExtension,
                Srb);

            ScsiPortNotification(NextRequest,
                deviceExtension,
                NULL);

            return TRUE;

    } // end switch

    //
    // Tell 154xb a CCB is available now.
    //

    if (!WriteCommandRegister(deviceExtension,AC_START_SCSI_COMMAND, FALSE)) {

        //
        // Let request time out and fail.
        //

        DebugPrint((1,"A154xStartIo: Can't write command to adapter\n"));

        deviceExtension->PendingRequest = TRUE;

    } else {

        //
        // Command(s) submitted. Clear pending request flag.
        //

        deviceExtension->PendingRequest = FALSE;

        //
        // Adapter ready for next request.
        //

        ScsiPortNotification(NextRequest,
            deviceExtension,
            NULL);
        }

    return TRUE;

} // end A154xStartIo()


BOOLEAN
A154xInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This is the interrupt service routine for the adaptec 154x SCSI adapter.
    It reads the interrupt register to determine if the adapter is indeed
    the source of the interrupt and clears the interrupt at the device.
    If the adapter is interrupting because a mailbox is full, the CCB is
    retrieved to complete the request.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE if MailboxIn full

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PNONCACHED_EXTENSION noncachedExtension =
    deviceExtension->NoncachedExtension;
    PCCB ccb;
    PSCSI_REQUEST_BLOCK srb;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    PMBI mailboxIn;
    ULONG physicalCcb;
    PHW_LU_EXTENSION luExtension;
    ULONG residualBytes;
    ULONG i;

    UCHAR InterruptFlags;

    InterruptFlags = ScsiPortReadPortUchar(&baseIoAddress->InterruptRegister);

    //
    // Determine cause of interrupt.
    //

    if(InterruptFlags == 0) {

        DebugPrint((4,"A154xInterrupt: Spurious interrupt\n"));

        return FALSE;
    }

    if (InterruptFlags & IOP_COMMAND_COMPLETE) {

        //
        // Adapter command completed.
        //

        DebugPrint((2,"A154xInterrupt: Adapter Command complete\n"));
        DebugPrint((3,"A154xInterrupt: Interrupt flags %x\n", InterruptFlags));
        DebugPrint((3,"A154xInterrupt: Status %x\n",
            ScsiPortReadPortUchar(&baseIoAddress->StatusRegister)));

        //
        // Clear interrupt on adapter.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

        return TRUE;

    } else if (InterruptFlags & IOP_MBI_FULL) {

        DebugPrint((3,"A154xInterrupt: MBI Full\n"));

        //
        // Clear interrupt on adapter.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

    } else if (InterruptFlags & IOP_SCSI_RESET_DETECTED) {

        DebugPrint((1,"A154xInterrupt: SCSI Reset detected\n"));

        //
        // Clear interrupt on adapter.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

        //
        // Notify of reset.
        //

        ScsiPortNotification(ResetDetected,
                 deviceExtension,
                 NULL);

#if defined(_SCAM_ENABLED)
        //
        // Interrupt handler where reset is detected
        //
        PerformScamProtocol(deviceExtension);
#endif

        return TRUE;

    }

    //
    // Determine which MailboxIn location contains the CCB.
    //

    for (i=0; i<MB_COUNT; i++) {

        mailboxIn = &noncachedExtension->Mbi[deviceExtension->MbiIndex];

        //
        // Look for a mailbox entry with a legitimate status.
        //

        if (mailboxIn->Status != MBI_FREE) {

            //
            // Point to the next in box.
            //

            deviceExtension->MbiIndex = (deviceExtension->MbiIndex + 1) % MB_COUNT;

            //
            // MBI found. Convert CCB to big endian.
            //

            THREE_TO_FOUR((PFOUR_BYTE)&physicalCcb,
                &mailboxIn->Address);

            DebugPrint((3, "A154xInterrupt: Physical CCB %lx\n", physicalCcb));

            //
            // Check if physical CCB is zero.
            // This is done to cover for hardware errors.
            //

            if (!physicalCcb) {

                DebugPrint((1,"A154xInterrupt: Physical CCB address is 0\n"));

                //
                // Indicate MBI is available.
                //

                mailboxIn->Status = MBI_FREE;

                continue;
            }

            //
            // Convert Physical CCB to Virtual.
            //

            ccb = ScsiPortGetVirtualAddress(deviceExtension, ScsiPortConvertUlongToPhysicalAddress(physicalCcb));


            DebugPrint((3, "A154xInterrupt: Virtual CCB %lx\n", ccb));

            //
            // Make sure the virtual address was found.
            //

            if (ccb == NULL) {

                //
                // A bad physcial address was return by the adapter.
                // Log it as an error.
                //

                ScsiPortLogError(
                    HwDeviceExtension,
                    NULL,
                    0,
                    deviceExtension->HostTargetId,
                    0,
                    SP_INTERNAL_ADAPTER_ERROR,
                    5 << 8
                    );

                //
                // Indicate MBI is available.
                //

                mailboxIn->Status = MBI_FREE;

                continue;
            }

            //
            // Get SRB from CCB.
            //

            srb = ccb->SrbAddress;

            //
            // Get logical unit extension.
            //

            luExtension =
                ScsiPortGetLogicalUnit(deviceExtension,
                                       srb->PathId,
                                       srb->TargetId,
                                       srb->Lun);

            //
            // Make sure the luExtension was found and it has a current request.
            //

            if (luExtension == NULL || (luExtension->CurrentSrb == NULL &&
                mailboxIn->Status != MBI_NOT_FOUND)) {

                //
                // A bad physcial address was return by the adapter.
                // Log it as an error.
                //

                ScsiPortLogError(
                    HwDeviceExtension,
                    NULL,
                    0,
                    deviceExtension->HostTargetId,
                    0,
                    SP_INTERNAL_ADAPTER_ERROR,
                    (6 << 8) | mailboxIn->Status
                    );

                //
                // Indicate MBI is available.
                //

                mailboxIn->Status = MBI_FREE;

                continue;
            }

            //
            // Check MBI status.
            //

            switch (mailboxIn->Status) {

                case MBI_SUCCESS:

                    srb->SrbStatus = SRB_STATUS_SUCCESS;

                    //
                    // Check for data underrun if using scatter/gather
                    // command with residual bytes.
                    //

                    if (deviceExtension->CcbScatterGatherCommand == SCATTER_GATHER_COMMAND) {

                        //
                        // Update SRB with number of bytes transferred.
                        //

                        THREE_TO_FOUR((PFOUR_BYTE)&residualBytes,
                            &ccb->DataLength);

                        if (residualBytes != 0) {

                            ULONG transferLength = srb->DataTransferLength;

                            DebugPrint((2,
                                       "A154xInterrupt: Underrun occured. Request length = %lx, Residual length = %lx\n",
                                       srb->DataTransferLength,
                                       residualBytes));

                            //
                            // Update SRB with bytes transferred and
                            // underrun status.
                            //

                            srb->DataTransferLength -= residualBytes;
                            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;

                            if ((LONG)(srb->DataTransferLength) < 0) {

                                DebugPrint((0,
                                           "A154xInterrupt: Overrun occured. Request length = %lx, Residual length = %lx\n",
                                           transferLength,
                                           residualBytes));
                                //
                                // Seems to be a FW bug in some revs. where
                                // residual comes back as a negative number, yet the
                                // request is successful.
                                //

                                srb->DataTransferLength = 0;
                                srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;


                                //
                                // Log the event and then the residual byte count.
                                //

                                ScsiPortLogError(HwDeviceExtension,
                                                 NULL,
                                                 0,
                                                 deviceExtension->HostTargetId,
                                                 0,
                                                 SP_PROTOCOL_ERROR,
                                                 0xb);

                                ScsiPortLogError(HwDeviceExtension,
                                                 NULL,
                                                 0,
                                                 deviceExtension->HostTargetId,
                                                 0,
                                                 SP_PROTOCOL_ERROR,
                                                 residualBytes);

                            }
                        }
                    }

                    luExtension->CurrentSrb = NULL;

                    break;

                case MBI_NOT_FOUND:

                    DebugPrint((1, "A154xInterrupt: CCB abort failed %lx\n", ccb));

                    srb = ccb->AbortSrb;

                    srb->SrbStatus = SRB_STATUS_ABORT_FAILED;

                    //
                    // Check if SRB still outstanding.
                    //

                    if (luExtension->CurrentSrb) {

                        //
                        // Complete this SRB.
                        //

                        luExtension->CurrentSrb->SrbStatus = SRB_STATUS_TIMEOUT;

                        ScsiPortNotification(RequestComplete,
                            deviceExtension,
                            luExtension->CurrentSrb);

                        luExtension->CurrentSrb = NULL;
                    }

                    break;

                case MBI_ABORT:

                    DebugPrint((1, "A154xInterrupt: CCB aborted\n"));

                    //
                    // Update target status in aborted SRB.
                    //

                    srb->SrbStatus = SRB_STATUS_ABORTED;

                    //
                    // Call notification routine for the aborted SRB.
                    //

                    ScsiPortNotification(RequestComplete,
                        deviceExtension,
                        srb);

                    luExtension->CurrentSrb = NULL;

                    //
                    // Get the abort SRB from CCB.
                    //

                    srb = ccb->AbortSrb;

                    //
                    // Set status for completing abort request.
                    //

                    srb->SrbStatus = SRB_STATUS_SUCCESS;

                    break;

                case MBI_ERROR:

                        DebugPrint((2, "A154xInterrupt: Error occurred\n"));

                        srb->SrbStatus = MapError(deviceExtension, srb, ccb);

                        //
                        // Check if ABORT command.
                        //

                        if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

                            //
                            // Check if SRB still outstanding.
                            //

                            if (luExtension->CurrentSrb) {

                                //
                                // Complete this SRB.
                                //

                                luExtension->CurrentSrb->SrbStatus = SRB_STATUS_TIMEOUT;

                                ScsiPortNotification(RequestComplete,
                                                     deviceExtension,
                                                     luExtension->CurrentSrb);

                            }

                            DebugPrint((1,"A154xInterrupt: Abort command failed\n"));
                        }

                        luExtension->CurrentSrb = NULL;

                        break;

                    default:

                        //
                        // Log the error.
                        //

                        ScsiPortLogError(
                            HwDeviceExtension,
                            NULL,
                            0,
                            deviceExtension->HostTargetId,
                            0,
                            SP_INTERNAL_ADAPTER_ERROR,
                            (1 << 8) | mailboxIn->Status
                            );

                        DebugPrint((1, "A154xInterrupt: Unrecognized mailbox status\n"));

                        mailboxIn->Status = MBI_FREE;

                        continue;

                } // end switch

                //
                // Indicate MBI is available.
                //

                mailboxIn->Status = MBI_FREE;

                DebugPrint((2, "A154xInterrupt: SCSI Status %x\n", srb->ScsiStatus));

                DebugPrint((2, "A154xInterrupt: Adapter Status %x\n", ccb->HostStatus));

                //
                // Update target status in SRB.
                //

                srb->ScsiStatus = ccb->TargetStatus;

                //
                // Signal request completion.
                //

                ScsiPortNotification(RequestComplete,
                                     (PVOID)deviceExtension,
                                     srb);

        } else {

            break;

        } // end if ((mailboxIn->Status == MBI_SUCCESS ...

    } // end for (i=0; i<MB_COUNT; i++) {

    if (deviceExtension->PendingRequest) {

        //
        // The last write command to the adapter failed.  Try and start it now.
        //

        deviceExtension->PendingRequest = FALSE;

        //
        // Tell 154xb a CCB is available now.
        //

        if (!WriteCommandRegister(deviceExtension,AC_START_SCSI_COMMAND, FALSE)) {

            //
            // Let request time out and fail.
            //

            DebugPrint((1,"A154xInterrupt: Can't write command to adapter\n"));

            deviceExtension->PendingRequest = TRUE;

        } else {

            //
            // Adapter ready for next request.
            //

             ScsiPortNotification(NextRequest,
                                  deviceExtension,
                                  NULL);
        }
    }

    return TRUE;

} // end A154xInterrupt()


VOID
BuildCcb(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Build CCB for 154x.

Arguments:

    DeviceExtenson
    SRB

Return Value:

    Nothing.

--*/

{
    PCCB ccb = Srb->SrbExtension;

    DebugPrint((3,"BuildCcb: Enter routine\n"));

    //
    // Set target id and LUN.
    //

    ccb->ControlByte = (UCHAR)(Srb->TargetId << 5) | Srb->Lun;

    //
    // Set CCB Operation Code.
    //

    ccb->OperationCode = DeviceExtension->CcbScatterGatherCommand;

    //
    // Set transfer direction bit.
    //

    if (Srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

        //
        // Check if both direction bits are set. This is an
        // indication that the direction has not been specified.
        //

        if (!(Srb->SrbFlags & SRB_FLAGS_DATA_IN)) {
            ccb->ControlByte |= CCB_DATA_XFER_OUT;
        }

    } else if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {
        ccb->ControlByte |= CCB_DATA_XFER_IN;
    } else {

        //
        // if no data transfer, we must set ccb command to to INITIATOR
        // instead of SCATTER_GATHER and zero ccb data pointer and length.
        //

        ccb->OperationCode = DeviceExtension->CcbInitiatorCommand;
        ccb->DataPointer.Msb = 0;
        ccb->DataPointer.Mid = 0;
        ccb->DataPointer.Lsb = 0;
        ccb->DataLength.Msb = 0;
        ccb->DataLength.Mid = 0;
        ccb->DataLength.Lsb = 0;
    }

    //
    // 01h disables auto request sense.
    //

    ccb->RequestSenseLength = 1;

    //
    // Set CDB length and copy to CCB.
    //

    ccb->CdbLength = (UCHAR)Srb->CdbLength;

    ScsiPortMoveMemory(ccb->Cdb, Srb->Cdb, ccb->CdbLength);

    //
    // Set reserved bytes to zero.
    //

    ccb->Reserved[0] = 0;
    ccb->Reserved[1] = 0;

    ccb->LinkIdentifier = 0;

    //
    // Zero link pointer.
    //

    ccb->LinkPointer.Msb = 0;
    ccb->LinkPointer.Lsb = 0;
    ccb->LinkPointer.Mid = 0;

    //
    // Build SDL in CCB if data transfer.
    //

    if (Srb->DataTransferLength > 0) {
        BuildSdl(DeviceExtension, Srb);
    }

    //
    // Move 0xff to Target Status to indicate
    // CCB has not completed.
    //

    ccb->TargetStatus = 0xFF;

    return;

} // end BuildCcb()


VOID
BuildSdl(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine builds a scatter/gather descriptor list for the CCB.

Arguments:

    DeviceExtension
    Srb

Return Value:

    None

--*/

{
    PVOID dataPointer = Srb->DataBuffer;
    ULONG bytesLeft = Srb->DataTransferLength;
    PCCB ccb = Srb->SrbExtension;
    PSDL sdl = &ccb->Sdl;
    ULONG physicalSdl;
    ULONG physicalAddress;
    ULONG length;
    ULONG four;
    PTHREE_BYTE three;
    ULONG i = 0;

    DebugPrint((3,"BuildSdl: Enter routine\n"));

    //
    // Get physical SDL address.
    //

    physicalSdl = ScsiPortConvertPhysicalAddressToUlong(
        ScsiPortGetPhysicalAddress(DeviceExtension, NULL,
        sdl, &length));

   //
   // Create SDL segment descriptors.
   //

   do {

        DebugPrint((3, "BuildSdl: Data buffer %lx\n", dataPointer));

        //
        // Get physical address and length of contiguous
        // physical buffer.
        //

        physicalAddress =
            ScsiPortConvertPhysicalAddressToUlong(
            ScsiPortGetPhysicalAddress(DeviceExtension,
                    Srb,
                    dataPointer,
                    &length));

        DebugPrint((3, "BuildSdl: Physical address %lx\n", physicalAddress));
        DebugPrint((3, "BuildSdl: Data length %lx\n", length));
        DebugPrint((3, "BuildSdl: Bytes left %lx\n", bytesLeft));

        //
        // If length of physical memory is more
        // than bytes left in transfer, use bytes
        // left as final length.
        //

        if  (length > bytesLeft) {
            length = bytesLeft;
        }

        //
        // Convert length to 3-byte big endian format.
        //

        four = length;
        three = &sdl->Sgd[i].Length;
        FOUR_TO_THREE(three, (PFOUR_BYTE)&four);

        //
        // Convert physical address to 3-byte big endian format.
        //

        four = (ULONG)physicalAddress;
        three = &sdl->Sgd[i].Address;
        FOUR_TO_THREE(three, (PFOUR_BYTE)&four);
        i++;

        //
        // Adjust counts.
        //

        dataPointer = (PUCHAR)dataPointer + length;
        bytesLeft -= length;

    } while (bytesLeft);

        //##BW
        //
        // For data transfers that have less than one scatter gather element, convert
        // CCB to one transfer without using SG element. This will clear up the data
        // overrun/underrun problem with small transfers that reak havoc with scanners
        // and CD-ROM's etc. This is the method employed in ASPI4DOS to avoid similar
        // problems.
        //
        if (i == 0x1) {
                //
                // Only one element, so convert...
                //

                //
                // The above Do..While loop performed all necessary conversions for the
                // SRB buffer, so we copy over the length and address directly into the
                // CCB
                //
                ccb->DataLength  = sdl->Sgd[0x0].Length;
                ccb->DataPointer = sdl->Sgd[0x0].Address;

                //
                // Change the OpCode from SG command to initiator command and we're
                // done. Easy, huh?
                //
                ccb->OperationCode = SCSI_INITIATOR_COMMAND; //##BW _OLD_ command?

        } else {
                //
                // Multiple SG elements, so continue as normal.
                //

            //
            // Write SDL length to CCB.
            //

            four = i * sizeof(SGD);
            three = &ccb->DataLength;
            FOUR_TO_THREE(three, (PFOUR_BYTE)&four);

            DebugPrint((3,"BuildSdl: SDL length is %d\n", four));

            //
            // Write SDL address to CCB.
            //

            FOUR_TO_THREE(&ccb->DataPointer,
                (PFOUR_BYTE)&physicalSdl);

            DebugPrint((3,"BuildSdl: SDL address is %lx\n", sdl));

            DebugPrint((3,"BuildSdl: CCB address is %lx\n", ccb));
        }

    return;

} // end BuildSdl()


BOOLEAN
A154xResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    Reset Adaptec 154X SCSI adapter and SCSI bus.
    Initialize adapter mailbox.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PNONCACHED_EXTENSION noncachedExtension =
    deviceExtension->NoncachedExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR status;
    ULONG i;

    DebugPrint((2,"ResetBus: Reset aha154X and SCSI bus\n"));

    //
    // Complete all outstanding requests with SRB_STATUS_BUS_RESET.
    //

    ScsiPortCompleteRequest(deviceExtension,
                (UCHAR) PathId,
                0xFF,
                0xFF,
                (ULONG) SRB_STATUS_BUS_RESET);

    //
    // Read status register.
    //

    status = ScsiPortReadPortUchar(&baseIoAddress->StatusRegister);

    //
    // If value is normal then reset device only.
    //

    if ((status & ~IOP_MAILBOX_INIT_REQUIRED) != IOP_SCSI_HBA_IDLE) {

        //
        // Reset SCSI chip.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_HARD_RESET);

        ScsiPortStallExecution(500 * 1000);

        //
        // Wait up to 5000 microseconds for adapter to initialize.
        //

        for (i = 0; i < 5000; i++) {

            ScsiPortStallExecution(1);

            status = ScsiPortReadPortUchar(&deviceExtension->BaseIoAddress->StatusRegister);

            if (status & IOP_SCSI_HBA_IDLE) {
                break;
            }
        }
    }

    //
    // Zero out mailboxes.
    //

    for (i=0; i<MB_COUNT; i++) {

        PMBO mailboxOut;
        PMBI mailboxIn;

        mailboxIn = &noncachedExtension->Mbi[i];
        mailboxOut = &noncachedExtension->Mbo[i];

        mailboxOut->Command = mailboxIn->Status = 0;
    }

    //
    // Zero previous indexes.
    //

    deviceExtension->MboIndex = 0;
    deviceExtension->MbiIndex = 0;

    if (deviceExtension->PendingRequest) {

        deviceExtension->PendingRequest = FALSE;

        //
        // Adapter ready for next request.
        //

        ScsiPortNotification(NextRequest,
                 deviceExtension,
                 NULL);
    }

    if (!(status & IOP_SCSI_HBA_IDLE)) {
        return(FALSE);
    }

    //
    // Unlock mailboxes in case the adapter is a 1540B with 1Gb support
    // or 1540C with extended translation enabled.  Maiboxes cannot be
    // initialized until unlock code is sent.

    status = UnlockMailBoxes(deviceExtension);

    if (!SpinForInterrupt(deviceExtension,FALSE)) {
        DebugPrint((1,"A154xResetBus: Failed to unlock mailboxes\n"));
        return FALSE;
    }

    DebugPrint((3,"ResetBus: Initialize mailbox\n"));

    if (!WriteCommandRegister(deviceExtension,AC_MAILBOX_INITIALIZATION, TRUE)) {
        DebugPrint((1,"A154xResetBus: Can't initialize mailboxes\n"));
        return FALSE;
    }

    //
    // Send Adapter number of mailbox locations.
    //

    if (!WriteDataRegister(deviceExtension,MB_COUNT)) {
        return FALSE;
    }

    //
    // Send the most significant byte of the mailbox physical address.
    /