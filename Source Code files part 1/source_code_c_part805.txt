      LineLength     (LINE ,PFILE);
void              InsertLine     (LINE, char *, PFILE);
LINE      __cdecl zprintf        (PFILE, LINE, char const *, ...);
int               gettextline    (char ,LINE ,char *,PFILE, char);
int               getcolorline   (flagType, LINE, struct lineAttr *, PFILE);
void              puttextline    (flagType, flagType, LINE, char *, PFILE);
void              putcolorline   (flagType, LINE, struct lineAttr *, PFILE);
void              BlankLines     (LINE ,PVOID);
void              BlankColor     (LINE, PVOID);
void              growline       (LINE ,PFILE);
void              InsLine        (flagType, LINE ,LINE ,PFILE);
flagType          fInsSpace      (COL ,LINE ,int ,PFILE, linebuf);
flagType          fInsSpaceColor (COL ,LINE ,int ,PFILE, linebuf, struct lineAttr *);
void              delspace       (COL ,LINE ,int ,PFILE, linebuf);
int               fcolcpy        (struct lineAttr * , struct lineAttr * );
void              ShiftColor     (struct lineAttr [], COL, int);
void              SetColor       (PFILE, LINE, COL, COL, int);
void              CopyColor      (PFILE, PFILE, LINE, COL, COL, LINE, COL);
void              SetColorBuf    (struct lineAttr *, COL, int, int);
flagType          fGetColorPos   (struct lineAttr **, COL *);
void              ColorToPhys    (struct lineAttr *, LINE, PFILE);
void              ColorToLog     (struct lineAttr *, char *);

void              SetHiLite      (PFILE, rn, int);
void              ClearHiLite    (PFILE, flagType);
flagType          UpdHiLite      (PFILE, LINE, COL, COL, struct lineAttr **);
void              UpdOneHiLite   (struct lineAttr *, COL, COL, flagType, INT_PTR);
void              rnOrder        (rn *);

void              BoxToStream    (ARG *);
void              StreamToBox    (ARG *);

void              AckReplace     (LINE, flagType);
void              AckMove        (LINE, LINE);
void              DoAssignLine   (LINE);
void              UpdToolsIni    (char *);
LINE              FindMatchLine  (char *, char *, char *, int, LINE *);

void              GetCurPath     (char *);
flagType          SetCurPath     (char *);

flagType          ExpungeFile    (void);
void              FreeFileVM     (PFILE);
PFILE             pFileLRU       (PFILE);


void              saveflip       (void);
void              restflip       (void);
void              movewin        (COL ,LINE);
void              SortWin        (void);
int               WinInsert      (PWND);
char              Adjacent       (int ,int);
char              WinClose       (int);
char              fDoWord        (void);
PCMD              zloop          (flagType);
flagType          zspawnp        (char const *, flagType);
flagType          DoCancel       (void);
char              testmeta       (void);
char *            ZMakeStr       (const char *);
void              TCcursor       (char ,char);

#define sout(x,y,p,clr)         ((int)x + MepWrite(y, x, p, strlen(p), clr, FALSE, fReDraw))
#define soutb(x,y,p,clr)        ((int)x + MepWrite(y, x, p, strlen(p), clr, TRUE, fReDraw))
#define vout(x,y,p,c,clr)       ((int)x + MepWrite(y, x, p, c, clr, FALSE, fReDraw))
#define voutb(x,y,p,c,clr)      ((int)x + MepWrite(y, x, p, c, clr, TRUE, fReDraw))

#define consoleMoveTo(y, x)     consoleSetCursor(MepScreen, y, x)


int               coutb          (int ,int ,char *,int ,struct lineAttr *);
void              ToRaw          (void);
void              ToCooked       (void);
char *            VideoTag       (void);
char *            whiteskip      (char const *);
char *            whitescan      (char const *);
int               RemoveTrailSpace (char *);
char *            DoubleSlashes  (char *);
char *            UnDoubleSlashes(char *);
flagType __cdecl  FmtAssign      (char *, ...);
flagType          SendCmd        (PCMD);
void              RecordCmd      (PCMD);
void              RecordString   (char *);
void              AppendMacroToRecord (PCMD);
flagType          fSyncFile      (PFILE, flagType);
void              RemoveInstances(PFILE);
int               FileStatus     (PFILE, char *);
void              SetModTime     (PFILE);
time_t            ModTime        (char *);
void              LengthCheck    (LINE, int, char *);
void              IntError       (char *);
#if 0
flagType          CheckForDirt   (void);
#else
flagType          fSaveDirtyFiles(void);
#endif
flagType          InitExt        (char *);
LINE              DoInit         (char *, char *, LINE);
char *            IsTag          (char *);
LINE              LocateTag      (PFILE, char *);
char *            GetIniVar      (char *, char *);
int               loadini        (flagType);
int               init           (void);
void              WriteTMPFile   (void);
flagType          ReadTMPFile    ();
void              RemoveTop      (void);
flagType          dosearch       (flagType, ARG *, flagType, flagType);
int               REsearchS      (PFILE, flagType, flagType, flagType, flagType, char *, fl *);
void                     mgrep1file     (char *, struct findType *, void *);
void                     mrepl1file     (char *, struct findType *, void *);
flagType         mgrep1env  (char *, va_list);
flagType          fFileAdvance   (void);
LINE              SetFileList    (void);
void              TopLoop        (void);
void              LeaveZ         (void);
DECLSPEC_NORETURN void              CleanExit      (int, flagType);
flagType          fPushEnviron   (char *, flagType);
flagType          fIsNum         (char *);
void              InitNames      (char *);
void              ParseCmd       (char *, char **, char **);
flagType          fIsBlank       (PFILE, LINE);
flagType          fVideoAdjust   (int, int);


flagType __cdecl  disperr        (int, ...);
flagType __cdecl  dispmsg        (int, ...);
int      __cdecl  domessage      (char *, ...);
int      __cdecl  printerror     (char *,...);
char *            GetMsg         (unsigned, char *);
void              CreateUndoList (PFILE);
void              LinkAtHead     (PVOID, union Rec *,PFILE);
int               FreeUndoRec    (flagType,PFILE);
int               UnDoRec        (PFILE);
void		  LogReplace	 (PFILE, LINE, LINEREC *, struct colorRecType *);
void              LogInsert      (PFILE, LINE, LINE);
void              LogDelete      (PFILE, LINE, LINE);
void              LogBoundary    (void);
int               ReDoRec        (PFILE);
flagType          fIdleUndo      (flagType);
void              FlushUndoBuffer (void);
void              RemoveUndoList (PFILE);
flagType          fundoable      (flagType);
LINE              updateLine     (PFILE, LINE);
LINE              unupdateLine   (PFILE, LINE);

int                      ZFormat        (REGISTER char *, const REGISTER char *, va_list);

/*  Declarations controlled by C runtime
 */
int                      CtrlC          (ULONG);
void __cdecl            main           (int ,char * *);

#if defined (DEBUG)

void *                   DebugMalloc        (int, BOOL, char *, int);
void *                   DebugRealloc       (void *, int, BOOL, char *, int);
void                     DebugFree          (void *, char *, int);
unsigned                 DebugMemSize       (void *, char *, int);

#endif
/*
 *          Debugging assertion support
 */
#ifdef DEBUG
void              _assertexit    (char *, char *, int);
void              _heapdump      (char *);
flagType          _pfilechk      (void);
flagType          _pinschk       (PINS);
void *            _nearCheck     (void *, char *, char *, int);
#endif

void *                   ZeroMalloc     (int);
void *                   ZeroRealloc    (void *, int);
unsigned                 MemSize        (void *);

/*  Assembly declarations
 */
int                      fstrnicmp      (char *, char *, int);
char *               fstrcpy        (char *, char *);
int                      fstrlen        (char *);
int               zfstrcmp       (char *, char *);
int               fstricmp       (char *, char *);
int               iHash          (long, int);

int               Untab         (int, const char*, int, char*, char);
COL               AlignChar     (COL, const char*);

void              KbHookAsm      (void);
flagType          SetKBType      (void);
void              GetScreenSize (int *, int *);
flagType          SetScreenSize (int, int);
void              SetVideoState  (int);
void              SaveScreen     (void);
void              RestoreScreen  (void);
void                                     WindowChange ( ROW     Rows,  COLUMN   Cols);
int               LineOut        (int, int, const char *, int, int);
int               LineOutB       (int, int, const char *, int, int);
void              HWInit         (void);
void              HWReset        (void);
flagType          Idle           (void);
//void            Yield          (void);
//char *                  lsearch        (char *, int, char *, int);

int               DosLoadModuleHack (char *, int, char *, unsigned int *);
void                     IdleThread     ( void );
int               OS2toErrno     (int);
char *            OS2toErrText   (int, char *);

flagType          fMapEnv        (char *pSrc, char *pDst, int cbDst);
flagType          fSetEnv        (char *p);
void              showenv        (PFILE pFile);
/*
 * Extension Load/Auto-Load
 */
#if defined (HELP_HACK )
char *                  HelpLoad(void);
#endif
char *           load       (char *, flagType);
void             AutoLoadExt    (void);
flagType         AutoLoadDir    (char *, va_list);
void                     AutoLoadFile   (char *, struct findType *, void *);

/*
 * Printing
 */

flagType          DoPrint        (PFILE, flagType);
PFILE             GetTmpFile     (void);


void                     CleanPrint     (char *, flagType);



/*
 * Background Threads
 */

BTD*              BTCreate      (char *);
flagType          BTAdd         (BTD *, PFUNCTION, char *);
flagType          BTKill        (BTD *);
flagType          BTKillAll     (void);
flagType          BTWorking     (void);
void              BTIdle        (void);
void                     BThread       (BTD *);


/*
 * List handling module
 */
void              ListWalker     (PCMD, flagType (         *)(PCMD, char *, PMI, int), flagType);
char *            ScanList       (PCMD, flagType);
char *            ScanMyList     (PCMD, PMI, buffer, flagType);
flagType          fParseList     (PMI,char *);
flagType          fScanPush      (PMI);
flagType          fScanPop       (PMI);
PCMD              GetListHandle  (char *, flagType);
void              AddStrToList   (PCMD, char *);
flagType          fInList        (PCMD, char *, flagType);
flagType          fDelStrFromList(PCMD, char *, flagType);
flagType          CheckAndDelStr (PCMD, char *, PMI, int);
char *            GetListEntry   (PCMD, int, flagType);
int               ListLen        (PCMD, flagType);
flagType          fEmptyList     (PCMD);
void              InitParse      (PCMD, PMI);
void              Listize        (char *);
char *            CanonFilename  (char * src, char * dst);
flagType          fEnvar         (char *);
void              ClearList      (PCMD);
/*
 * real tabs
 */
char *                   pLog           (char*, COL, flagType);
int               cbLog          (char *);
COL               colPhys        (char *, char *);
COL               DecCol         (COL, char *);
COL               IncCol         (COL, char *);


FILEHANDLE  MepFOpen    (LPBYTE FileName,  ACCESSMODE  Access, SHAREMODE  Share, BOOL fCreate);
void        MepFClose   (FILEHANDLE Handle );
DWORD       MepFRead    (PVOID  pBuffer, DWORD  Size, FILEHANDLE  Handle);
DWORD       MepFWrite   (PVOID pBuffer,  DWORD Size, FILEHANDLE  Handle);
DWORD       MepFSeek    (FILEHANDLE  Handle, DWORD  Distance,  MOVEMETHOD  MoveMethod);

#pragma intrinsic( memset,      memcpy )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\arg.c ===
/*** arg.c - argument handler
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip out near/far
*
*************************************************************************/
#include "mep.h"


typedef flagType (*FUNCSAVED)(CMDDATA, ARG *, flagType);

PVOID   vaHiLiteSave    = (PVOID)(-1L);
fl      flLastArg;
fl      flLastCursor;

//
// Globals set by SendCmd and used by repeat to repeat the last command
//
flagType    fOKSaved = FALSE;
FUNCSAVED   funcSaved;
CMDDATA     argDataSaved;
ARG         argSaved;
flagType    fMetaSaved;



/*** doarg - perform arg processing
*
*  doarg is the editor function that is used to indicate the beginning of
*  an argument to an editor function.
*
* Input:
*  Standard Editting Function (Everything ignored).
*
* Output:
*  Returns the value returned by editor function that terminates arg. If
*  invalid arg was found, then the return is FALSE.
*
*************************************************************************/
flagType
doarg (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    return Arg (FALSE);
    argData; pArg; fMeta;
}



/*** resetarg - throw away all arg input and restore cursor position.
*
*  Several functions (cancel, invalid args) discard the current arg context.
*  We parse the current arg input and then reset the cursor to the original
*  position.
*
* Input:
*  nothing
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
resetarg (void)
{
    UpdateHighLight (-1, -1L, FALSE);
    pInsCur->pFile->vaHiLite = vaHiLiteSave;
    vaHiLiteSave = (PVOID)(-1L);
    if (argcount)
        pInsCur->flCursorCur = flArg;
    argcount = 0;
}



/*** fCursor - decide if an editor function is a cursor movement function
*
*  When reading in an argument, editor functions that move the cursor are
*  allowed as long as no text has been input.  fCursor defines that set
*  of allowed functions.
*
* Input:
*  pCmd 	= pointer to the internal editor function
*
* Output:
*  Returns TRUE if pCmd is a cursor movement function
*
*************************************************************************/
flagType
fCursor (
    PCMD pCmd
    ) {
    return (flagType) TESTFLAG (pCmd->argType, CURSORFUNC);
}



/*** fWindow - decide if an editor function is a window movement function
*
*  After highlighting text, we are allowed to move the window about via
*  window movement functions without removing the highlight.  fWindow
*  defines that set of window functions.
*
* Input:
*  pf		= pointer to the internal editor function
*
* Output:
*  Returns TRUE if pf is a window movement function
*
*************************************************************************/
flagType fWindow (
    PCMD pCmd
    ) {
    return (flagType) TESTFLAG (pCmd->argType, WINDOWFUNC);
}



/*** Arg - perform all low-level arg processing
*
*  Arg () is responsible for the display of the arg, handling all cursor
*  movement, handling textarg input.
*
* Input:
*  fToText	= TRUE => go immediately to text arg processing, else allow
*		  allow cursor movement
*  fRestore	= TRUE => Establish a test selection before continuing
* Output:
*  Returns value returned by editor function that terminates arg. If invalid
*  arg was found, then the return is FALSE.
*
*************************************************************************/
flagType
Arg (
    flagType fRestore
    ) {
    REGISTER PCMD pFunc = NULL;
    char     p[20];
    char     tbuf[20];

    /*
     * We are being called for a lastselect.  Restore the
     * text selection stored in pInsCur and continue
     */
    if (fRestore) {
	vaHiLiteSave = pInsCur->pFile->vaHiLite;
	ClearHiLite (pInsCur->pFile, FALSE);
	flArg = pInsCur->flArg;
	cursorfl (pInsCur->flCursor);
	UpdateHighLight (XCUR(pInsCur), YCUR(pInsCur), TRUE);
	argcount++;
    } else {
	IncArg ();
    }

    if (!mtest()) {
        dispmsg (MSG_ARGCOUNT,argcount);
    }

    /*
     * Loop to do do cursor movements and display any extra arg indicators
     */

    fInSelection = TRUE;

    while (TRUE) {
        if ((pFunc = zloop (ZL_BRK)) == NULL) {
	    return FALSE;
        } else if ((PVOID)pFunc->func == (PVOID)doarg) {
	    argcount++;
            if (!mtest()) {
                dispmsg (MSG_ARGCOUNT,argcount);
            }
        } else if (fCursor (pFunc) || (PVOID)pFunc->func == (PVOID)meta) {
	    fRetVal = SendCmd (pFunc);
	    UpdateHighLight ( XCUR(pInsCur), YCUR(pInsCur), TRUE);
        } else {
            break;
        }
    }

    fInSelection = FALSE;

    /*
     * Get text arg, if needed.
     * Note that we only accept textarg if no cursor movement occured
     */
    if (   (((PVOID)pFunc->func == (PVOID)graphic) ||
            ((PVOID)pFunc->func == (PVOID)quote))
	&& (pInsCur->flCursorCur.lin == flArg.lin)
	&& (pInsCur->flCursorCur.col == flArg.col)
       ) {
	fTextarg = TRUE;
	sprintf(p,GetMsg(MSG_ARGCOUNT, tbuf), argcount);
	strcat (p, ": ");
	textbuf[0] = '\0';
	pFunc = getstring (textbuf, p, pFunc, FALSE);
    }

    /*
     * If textarg ended in valid function, execute it.
     */
    if (pFunc != NULL) {
	if (!fTextarg) {
	    pInsCur->flArg = flArg;
	    pInsCur->flCursor = pInsCur->flCursorCur;
        }
	return (SendCmd (pFunc));
    }

    return FALSE;
}



/*** IncArg - Increment the arg count
*
* If first arg, save current highlight info on th file, and clear any
* highlighting on screen. Set flArg to be the arg start position, and
* highlight that position.
*
* Input:
*   Nothing
*
* Output:
*   Nothing
*
*************************************************************************/
void IncArg (
) {
    if (!argcount++) {
	vaHiLiteSave = pInsCur->pFile->vaHiLite;
	ClearHiLite (pInsCur->pFile, FALSE);
	flArg = pInsCur->flCursorCur;
	UpdateHighLight (XCUR(pInsCur)+1, YCUR(pInsCur), TRUE);
    }
}



/**** fGenArg - generate the argument based upon editor state
*
*  fGenArg is called to convert the combination of arg, cursor, and
*  additional text into an argument structure to be handed to the editor
*  functions.
*
* Input:
*  pArg 	= pointer to arg structure that will be filled in
*  flags	= bit vector indicating type of arg processing required
*
* Globals:
*  argcount	= number of times ARG has been hit
*  fBoxArg	= Determines argument type (non-CW)
*  SelMode	= Determines argument type (CW)
*  flArg	= File location of arg cursor (may be updated)
*  fTextarg	= TRUE => textarg is present
*  pInsCur	= used for current user cursor location
*  textbuf	= buffer containing any text argument
*
* Output:
*  Returns TRUE if a valid argument was parsed off, FALSE otherwise
*
*************************************************************************/
flagType
fGenArg (
    REGISTER ARG *pArg,
    unsigned int flags
    ) 
{
    int cArg = argcount;
    long numVal  = 0;			/* value of numarg		*/
    flagType fTextArgLocal = fTextarg;

    fTextarg = FALSE;
    argcount = 0;
    if (cArg == 0) {
	if (TESTFLAG (flags, NOARG)) {
	    pArg->argType = NOARG;
	    pArg->arg.noarg.y = YCUR(pInsCur);
	    pArg->arg.noarg.x = XCUR(pInsCur);
	    return TRUE;
        } else {
            return FALSE;
        }
    } else {
	fl  L_flLow;
	fl  L_flHigh;
	fl  flCur;

	flCur = pInsCur->flCursorCur;

	cursorfl (flArg);
	/*  Specially handle text arguments.  User may specify a
	 *  number or a mark that will define the other endpoint
	 *  of an arg region.
	 */
	if (fTextArgLocal) {
	    if (TESTFLAG (flags, NUMARG) && fIsNum (textbuf)) {

		numVal = atol (textbuf);
		if (numVal != 0)
		    flArg.lin = lmax ((LINE)0, flArg.lin + numVal + (numVal > 0 ? -1 : 1));
		fTextArgLocal = FALSE;
            } else if (TESTFLAG (flags,MARKARG) && FindMark (textbuf, &flArg, FALSE)) {
                fTextArgLocal = FALSE;
            }
        }

	L_flLow.col  = min  (flArg.col, flCur.col);
	L_flHigh.col = max  (flArg.col, flCur.col);
	L_flLow.lin  = lmin (flArg.lin, flCur.lin);
	L_flHigh.lin = lmax (flArg.lin, flCur.lin);

	/*  flArg represents the location of one part of an argument
	 *  and the current cursor position represent the location of the
	 *  other end.	Based upon the flags, we ascertain what type of
	 *  argument is intended.
	 */
	if (fTextArgLocal) {
	    if (TESTFLAG (flags, TEXTARG)) {
		pArg->argType = TEXTARG;
		pArg->arg.textarg.cArg = cArg;
		pArg->arg.textarg.y = flCur.lin;
		pArg->arg.textarg.x = flCur.col;
		pArg->arg.textarg.pText = (char *) textbuf;
		return TRUE;
            } else {
                return FALSE;
            }
        } else if (flCur.col == flArg.col && flCur.lin == flArg.lin && numVal == 0) {
	    if (TESTFLAG (flags, NULLARG)) {
		pArg->argType = NULLARG;
		pArg->arg.nullarg.cArg = cArg;
		pArg->arg.nullarg.y = flCur.lin;
		pArg->arg.nullarg.x = flCur.col;
		return TRUE;
            } else if (TESTFLAG (flags, NULLEOL | NULLEOW)) {
		fInsSpace (flArg.col, flArg.lin, 0, pFileHead, textbuf);
                if (TESTFLAG (flags, NULLEOW)) {
                    *whitescan (pLog(textbuf, flArg.col, TRUE)) = 0;
                }
		strcpy (&textbuf[0], pLog (textbuf, flArg.col, TRUE));
		pArg->argType = TEXTARG;
		pArg->arg.textarg.cArg = cArg;
		pArg->arg.textarg.y = flCur.lin;
		pArg->arg.textarg.x = flCur.col;
		pArg->arg.textarg.pText = (char *) textbuf;
		return TRUE;
            } else {
                return FALSE;
            }
        } else if (TESTFLAG (flags, BOXSTR) && flCur.lin == flArg.lin) {
	    fInsSpace (L_flHigh.col, flArg.lin, 0, pFileHead, textbuf);
	    *pLog (textbuf, L_flHigh.col, TRUE) = 0;
	    strcpy (&textbuf[0], pLog (textbuf, L_flLow.col, TRUE));
	    pArg->argType = TEXTARG;
	    pArg->arg.textarg.cArg = cArg;
	    pArg->arg.textarg.y = flArg.lin;
	    pArg->arg.textarg.x = flArg.col;
	    pArg->arg.textarg.pText = (char *) textbuf;
	    return TRUE;
        } else if (fBoxArg) {
	    if (TESTFLAG (flags, LINEARG) && flArg.col == flCur.col) {
		pArg->argType = LINEARG;
		pArg->arg.linearg.cArg = cArg;
		pArg->arg.linearg.yStart = L_flLow.lin;
		pArg->arg.linearg.yEnd	 = L_flHigh.lin;
		return TRUE;
            } else if (TESTFLAG (flags, BOXARG) && flArg.col != flCur.col) {
		pArg->argType = BOXARG;
		pArg->arg.boxarg.cArg = cArg;
		pArg->arg.boxarg.yTop = L_flLow.lin;
		pArg->arg.boxarg.yBottom = L_flHigh.lin;
		pArg->arg.boxarg.xLeft = L_flLow.col;
		pArg->arg.boxarg.xRight = L_flHigh.col-1;
		return TRUE;
            } else {
                return FALSE;
            }
        } else if (TESTFLAG (flags, STREAMARG)) {
            pArg->argType = STREAMARG;
            pArg->arg.streamarg.cArg = cArg;
            if (flCur.lin > L_flLow.lin) {
                pArg->arg.streamarg.yStart = flArg.lin;
                pArg->arg.streamarg.xStart = flArg.col;
                pArg->arg.streamarg.yEnd = flCur.lin;
                pArg->arg.streamarg.xEnd = flCur.col;
            } else if (flArg.lin == flCur.lin) {
                pArg->arg.streamarg.yStart = pArg->arg.streamarg.yEnd = flArg.lin;
                pArg->arg.streamarg.xStart = L_flLow.col;
                pArg->arg.streamarg.xEnd = L_flHigh.col;
            } else {
                pArg->arg.streamarg.yStart = flCur.lin;
                pArg->arg.streamarg.xStart = flCur.col;
                pArg->arg.streamarg.yEnd = flArg.lin;
                pArg->arg.streamarg.xEnd = flArg.col;
            }
            return TRUE;
        } else {
            return FALSE;
        }
    }
}



/*** BadArg - inform the user that an invalid arg was input
*
*  Clear arg & print standard error message.
*
* Input:
*  none
*
* Output:
*  Returns FALSE
*
*************************************************************************/
flagType
BadArg ()
{
    resetarg ();
    return disperr (MSGERR_INV_ARG);
}



/*** SendCmd - take a CMD and call it with the appropriate argument parsing
*
*  If the function to be executed is not a window movement command nor a
*  cursor movement command, we remove any highlighting that is present. For
*  cleanliness, we pass a NOARG to cursor and window functions if none is
*  specified. If the function takes args, we decode them. Any errors report
*  back at this point. Finally, we dispatch to the function, sending him the
*  appropriate argument.
*
* Input:
*  pCmd 	    = pointer to command to execute.
*
* Output:
*  Returns value returned by command
*
*************************************************************************/
flagType
SendCmd (
PCMD pCmd
) {
    ARG arg;
    flagType L_fMeta = (flagType) (TESTFLAG (pCmd->argType, KEEPMETA) ? FALSE : testmeta ());
    flagType fArg  = (flagType) argcount;

    arg.argType = NOARG;
    arg.arg.noarg.x = XCUR(pInsCur);
    arg.arg.noarg.y = YCUR(pInsCur);

    if (TESTFLAG(pCmd->argType, GETARG)) {
	if (!fGenArg (&arg, pCmd->argType)) {
            if (fArg) {
		BadArg ();
            } else {
                disperr (MSGERR_ARG_REQ);
            }
	    return FALSE;
        }
        if (!fCursor (pCmd) && ! fWindow (pCmd)) {

            //  Not a coursor position.
            //  discard any pre-existing highlighting.

            PVOID        vaSave;

	    vaSave = pInsCur->pFile->vaHiLite;
	    pInsCur->pFile->vaHiLite = vaHiLiteSave;
            vaHiLiteSave = (PVOID)(-1L);
	    ClearHiLite (pInsCur->pFile, TRUE);

	    pInsCur->pFile->vaHiLite = vaSave;
        } else if (vaHiLiteSave == (PVOID)(-1L)) {

            // Preserve pre-existing hilighting

	    vaHiLiteSave = pInsCur->pFile->vaHiLite;
	    ClearHiLite (pInsCur->pFile, FALSE);
        }
	resetarg ();
    }

    if (   TESTFLAG (pCmd->argType, MODIFIES)
        && (TESTFLAG (pFileHead->flags, READONLY) || fGlobalRO)) {
        return disperr (MSGERR_NOEDIT);
    }

    if (!fMetaRecord || (PVOID)pCmd->func == (PVOID)record) {
        if (((PVOID)pCmd->func != (PVOID)repeat) && !mtest()) {
            if (argSaved.argType == TEXTARG) {
                FREE (argSaved.arg.textarg.pText);
            }
            funcSaved    = (FUNCSAVED)pCmd->func;
	    argDataSaved = pCmd->arg;
	    argSaved	 = arg;
	    fMetaSaved	 = L_fMeta;
            if (arg.argType == TEXTARG) {
		argSaved.arg.textarg.pText = ZMakeStr (arg.arg.textarg.pText);
            }
	    fOKSaved = TRUE;
        }
	return (*pCmd->func) (pCmd->arg, (ARG *)&arg, L_fMeta);
    }

    return FALSE;
}



/*** repeat - repeat the last command
*
*  repeat is the editor function that is used to repeat the last executed function
*
* Input:
*  Standard Editting Function. (Everything ignored)
*
* Output:
*  Returns .....
*
*************************************************************************/
flagType
repeat (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    return fOKSaved
	    ? (*funcSaved) (argDataSaved, (ARG *) &argSaved, fMetaSaved)
            : disperr (MSGERR_NOREP);

    argData; pArg; fMeta;
}


/*** lasttext - perform arg processing on the dialog line
*
*  TextArg is the editor function that is used to allow reediting of a text
*  arg on the dialog line.
*
*  If used with a selection, the first line of the selection is presented
*  for editing.
*
* Input:
*  Standard Editting Function.
*
* Output:
*  Returns .....
*
* Globals:
*  textbuf	= buffer containing any the argument
*
*************************************************************************/
flagType
lasttext (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    REGISTER PCMD pFunc = NULL;
    int 	  cArg	= 0;
    char	  p[20];
    char	  tbuf[20];

    switch (pArg->argType) {
	case NULLARG:
	    cArg = pArg->arg.nullarg.cArg;

	case NOARG:
	    cArg ++;
	    break;

	case BOXARG:
	    fInsSpace (pArg->arg.boxarg.xRight, pArg->arg.boxarg.yTop, 0, pFileHead, textbuf);
	    *pLog (textbuf, pArg->arg.boxarg.xRight+1, TRUE) = 0;
	    strcpy (textbuf, pLog (textbuf, pArg->arg.boxarg.xLeft, TRUE));
	    cArg = pArg->arg.boxarg.cArg;
	    break;

	case LINEARG:
	    GetLine (pArg->arg.linearg.yStart, textbuf, pFileHead);
	    cArg = pArg->arg.linearg.cArg;
	    break;

	case STREAMARG:
	    fInsSpace (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart, 0, pFileHead, textbuf);
            if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
                *pLog (textbuf, pArg->arg.streamarg.xEnd+1, TRUE) = 0;
            }
	    strcpy (textbuf, pLog (textbuf, pArg->arg.streamarg.xStart, TRUE));
	    cArg = pArg->arg.streamarg.cArg;
	    break;

	default:
	    break;
    }

    while (cArg--) {
        IncArg();
    }

    sprintf(p,GetMsg(MSG_ARGCOUNT, tbuf), argcount);
    strcat (p, ": ");
    if (pFunc = getstring (textbuf, p, NULL, GS_INITIAL)) {
	fTextarg = TRUE;
	return (SendCmd (pFunc));
    } else {
        return FALSE;
    }

    argData; fMeta;
}


/*** promptarg - Prompt the use for a textarg on the dialog line
*
*  If used with a selection, the first line of the selection is used
*  as prompt string.
*
* Input:
*  Standard Editting Function.
*
* Output:
*  Returns .....
*
* Globals:
*  textbuf	= buffer containing any the argument
*
*************************************************************************/
flagType
promptarg (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    REGISTER PCMD pFunc = NULL;
    linebuf	  lbPrompt;
    int 	  cArg = 0;

    switch (pArg->argType) {
	case BOXARG:
	    fInsSpace (pArg->arg.boxarg.xRight, pArg->arg.boxarg.yTop, 0, pFileHead, lbPrompt);
	    *pLog (lbPrompt, pArg->arg.boxarg.xRight+1, TRUE) = 0;
	    strcpy (lbPrompt, pLog (lbPrompt, pArg->arg.boxarg.xLeft, TRUE));
	    cArg = pArg->arg.boxarg.cArg;
	    break;

	case LINEARG:
	    GetLine (pArg->arg.linearg.yStart, lbPrompt, pFileHead);
	    cArg = pArg->arg.linearg.cArg;
	    break;

	case STREAMARG:
	    fInsSpace (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart, 0, pFileHead, lbPrompt);
            if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
                *pLog (lbPrompt, pArg->arg.streamarg.xEnd+1, TRUE) = 0;
            }
	    strcpy (lbPrompt, pLog (lbPrompt, pArg->arg.streamarg.xStart, TRUE));
	    cArg = pArg->arg.streamarg.cArg;
	    break;

        case TEXTARG:
	    strcpy ((char *) lbPrompt, pArg->arg.textarg.pText);
	    cArg = pArg->arg.textarg.cArg;
	    break;

	default:
	    break;
    }

    while (cArg--) {
        IncArg();
    }

    textbuf[0] = '\0';

    pFunc = getstring (textbuf, lbPrompt, NULL, GS_NEWLINE | GS_KEYBOARD);
    if (pFunc && ((PVOID)pFunc->func != (PVOID)cancel)) {
	fTextarg = TRUE;
	return TRUE;
    } else {
        return FALSE;
    }

    argData; fMeta;
}



/*** UpdateHighLight - Highlight screen during <arg> text selection.
*
*  Maintains screen highlighting information.
*
* Input:
*  x, y 	= position of cursor. (y == -1L causes highlighting to be
*		  removed)
*  fBoxToLine	= TRUE => Turn boxarg into a linearg if arg and cursor
*		  columns are the same
*
* Global:
*  flArg	= Position in file when <arg> was hit.
*
* Output:
*
*************************************************************************/
void
UpdateHighLight (
    COL      x,
    LINE     y,
    flagType fBoxToLine
    ) {

    static fl flCursor          = {-1, -1L};
    rn      rnHiLite;

    /*
     * if remove request, clear it out
     */
    if (y == -1L) {
        ClearHiLite (pInsCur->pFile,TRUE);
        flCursor.lin = -1L;
    } else if (fBoxArg) {
        /*
         * Transition points where we remove highlighting before updating new
         * highlighting:
         *
         *  currently columns are equal, and new highlight would not be.
         *  currently columns are not equal, and new highlight would be.
         *  New cursor position differs in BOTH x and y positions from old.
         *  new position equals the arg position
         */
        if (   ((flCursor.col == flArg.col) && (x != flCursor.col))
                || ((flCursor.col != flArg.col) && (x == flArg.col))
                || ((flCursor.col != x) && (flCursor.lin != y))
                || ((flArg.col == x) && (flArg.lin == y))
            ) {
            ClearHiLite (pInsCur->pFile,TRUE);
        }
        flCursor.lin = y;
        flCursor.col = x;
        /*
         * define New Highlight square
         */
        rnHiLite.flFirst = flArg;
        rnHiLite.flLast  = flCursor;
        /*
         * Ending column is off-by-one. If unequal, adjust accordingly.
         */
        if (rnHiLite.flFirst.col < rnHiLite.flLast.col) {
            rnHiLite.flLast.col--;
        } else if (   (rnHiLite.flFirst.col == rnHiLite.flLast.col)
             && (rnHiLite.flFirst.lin != rnHiLite.flLast.lin)) {
            /*
             * If columns are same, and lines are different, then highlight entire lines.
             */

            rnHiLite.flFirst.col = 0;
            rnHiLite.flLast.col  = sizeof(linebuf);
	}
        SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
    } else {  /* !fBoxArg */

        /*
         *  If we're on the arg line, we can just clear the highlighting
         *  and redraw.
         */
	if (y == flArg.lin) {
	    ClearHiLite (pInsCur->pFile, TRUE);

	    rnHiLite.flFirst = flArg;
	    rnHiLite.flLast.col = x;
	    rnHiLite.flLast.lin = y;

            if (x > flArg.col) {
                rnHiLite.flLast.col--;
            }

	    SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
        } else {
            /*
             *  We're not on the arg line.  If we have changed lines, we have
             *  to eliminate the range that specifies the line we're on.
             *  Currently, this means we have to clear the entire hiliting and
             *  regenerate.
             *  If we have not changed lines, only the current line will be updated
             */

	    if (flCursor.lin != y) {
		ClearHiLite (pInsCur->pFile, TRUE);

                /*
                 *  First, generate the arg line
                 */
		rnHiLite.flFirst    = flArg;
		rnHiLite.flLast.lin = flArg.lin;

                if (y < flArg.lin) {
		    rnHiLite.flLast.col = 0;
                } else {
                    rnHiLite.flLast.col = sizeof(linebuf);
                }

		SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);

                /*
                 *  Now generate the block between the arg and the current
                 *  lines.
                 */
		rnHiLite.flFirst.col = 0;
		rnHiLite.flLast.col  = sizeof(linebuf);

		if (y < flArg.lin) {
		    rnHiLite.flFirst.lin = y + 1;
		    rnHiLite.flLast.lin  = flArg.lin - 1;
                } else {
		    rnHiLite.flFirst.lin = flArg.lin + 1;
		    rnHiLite.flLast.lin  = y - 1;
                }

                if (rnHiLite.flLast.lin - rnHiLite.flFirst.lin >= 0) {
                    SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
                }
	    }

            /*
             *  Now do the current line
             */
	    rnHiLite.flFirst.lin = y;
	    rnHiLite.flLast.lin  = y;
	    rnHiLite.flLast.col  = x;

            if (y < flArg.lin) {
		rnHiLite.flFirst.col = sizeof(linebuf);
            } else {
		rnHiLite.flFirst.col = 0;
		rnHiLite.flLast.col--;
            }

	    SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
	}
	flCursor.col = x;
	flCursor.lin = y;
    }

    fBoxToLine;
}


/*** BoxStream - Editor command - toggles box/stream modes
*
*  Toggles the user between box and stream selection modes.
*
* Input:
*  Standard Editting function. (Though everything is ignored)
*
* Output:
*   Returns TRUE if we are now in box mode, FALSE for stream.
*
*************************************************************************/
flagType
BoxStream (
    CMDDATA   argData,
    ARG * pArg,
    flagType  fMeta
    ) {

    fBoxArg = (flagType) !fBoxArg;
    if (argcount) {
        UpdateHighLight (-1, -1L, TRUE);
        UpdateHighLight (XCUR(pInsCur), YCUR(pInsCur), TRUE);
    }
    return fBoxArg;

    argData; pArg; fMeta;
}


/*** lastselect - Restore last text selection
*
* Purpose:
*
*   To quickly restore the user text selection after a function has been
*   executed.  This function does not exit until the user completes their
*   selection.
*
* Input:
*
*   The usual editor command arguments.  None is used.
*
* Output:
*
*   Returns FALSE if we are already in text selection mode, TRUE otherwise.
*
* Notes:
*
*   The items we must save and restore are:
*
*		flArg	 - Spot where user hit <arg>
*		flCursor - Spot where cursor was last
*
*   Note that the boxstream state and the argcount are not preserved.
*
*   We rely on Arg () to set up for us.
*
*************************************************************************/

flagType
lastselect (
    CMDDATA   argData,
    ARG * pArg,
    flagType  fMeta
    ) {
    if (argcount) {
        return FALSE;
    }

    Arg (TRUE);

    return TRUE;

    argData; pArg;  fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\build.c ===
/*** build.c - utilities for build process
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip out near/far
*
*
*************************************************************************/
#include "mep.h"


/***
*
* Structures & Types
*
*************************************************************************/
/*
 * BUILDCMD - Build command linked list element
 */
struct BuildCmdType {
    struct BuildCmdType *pNext; 	/* next in list 		*/
    int     flags;			/* command type 		*/
    char    *pRule;			/* pointer to rule/filename	*/
    char    *pCmd;			/* pointer to command text	*/
    };

typedef struct BuildCmdType BUILDCMD;

/***
*
* Module data
*
*************************************************************************/
static	BUILDCMD    *pBuildCmdHead	= NULL; /* head of linked list	*/
static	BUILDCMD    *pBuildCmdCur	= NULL; /* most recent lookup	*/

/*** fSetMake - Define Build Command
*
*  Defines the filename extensions (.C, .BAS, etc) to which a given tool
*  command line applies OR the tool class which a command line defines.
*
* Input:
*  SetType =	MAKE_SUFFIX	= define suffix rule
*		MAKE_FILE	= define command for specfic file
*		MAKE_TOOL	= define tool command line
*		MAKE_DEBUG	= definition is for DEBUG, else RELEASE
*
*  fpszCmd =	Formatted  command  string.  Uses current extmake formatting
*		rules. (%s, etc.)
*
*  fpszExt =	If MAKE_EXT	= suffixes (i.e. ".c.obj")
*		If MAKE_FILE	= filename (must include ".")
*		If MAKE_TOOL	= tool name (no "." allowed)
*
* Output:
*  Returns TRUE on success. FALSE on any error.
*
*************************************************************************/
flagType
fSetMake (
    int      SetType,
    char *fpszCmd,
    char *fpszExt
    ) 
{
    buffer  L_buf;

    assert (fpszCmd && fpszExt && SetType);
    while (*fpszCmd == ' ') {
        fpszCmd++;
    }
    if (fGetMake (SetType, (char *)L_buf, fpszExt)) {
        /*
         * If it already existed, then just free teh previous definitions, in
         * preparation for replacement.
         */
        assert (pBuildCmdCur->pCmd);
        assert (pBuildCmdCur->pRule);
        pBuildCmdCur->pCmd  = ZEROREALLOC (pBuildCmdCur->pCmd, strlen(fpszCmd)+1);
        pBuildCmdCur->pRule = ZEROREALLOC (pBuildCmdCur->pRule,strlen(fpszExt)+1);
	strcpy ((char *)pBuildCmdCur->pCmd, fpszCmd);
	strcpy ((char *)pBuildCmdCur->pRule,fpszExt);
    } else {
        /*
         * It didn't already exist, so create a new struct at the head of the list,
         * to be filled in below.
         */
        pBuildCmdCur = (BUILDCMD *)ZEROMALLOC (sizeof(BUILDCMD));
        pBuildCmdCur->pNext = pBuildCmdHead;
	pBuildCmdCur->pCmd  = ZMakeStr (fpszCmd);
	pBuildCmdCur->pRule = ZMakeStr (fpszExt);
        pBuildCmdHead = pBuildCmdCur;
    }
    pBuildCmdCur->flags = SetType;
    return TRUE;
}



/*** fGetMake - Return Build Command
*
*  Returns the	command line which applies to a file or filename extension.
*
* Input:
*  GetType =	    MAKE_SUFFIX     = return suffix rule
*		    MAKE_FILE	    = return command for specfic file
*		    MAKE_TOOL	    = return tool command line
*		    MAKE_DEBUG	    = definition is for DEBUG, else RELEASE
*
*  fpszCmdDst =     Location  to place the formatted command string. Must be
*		    BUFLEN bytes long.
*
*  fpszExt =	    If MAKE_EXT     = suffixes	(i.e.  ".c.obj") for desired
*				      command.
*		    If MAKE_FILE    = filename for desired command
*		    If MAKE_TOOL    = name of tool
*
* Output:
*  Returns 0 on any error, else returns the GetType.
*
*************************************************************************/
int
fGetMake (
    int     GetType,
    char *fpszCmdDst,
    char *fpszExt
    ) {
    assert (fpszCmdDst && fpszExt && GetType);
    /*
     * Here we just walk the linked list looking for an entry whose flags match,
     * and, if a file or suffix rule, whose rule matches.
     */
    for (pBuildCmdCur = pBuildCmdHead;
         pBuildCmdCur;
         pBuildCmdCur = pBuildCmdCur->pNext) {

        if (pBuildCmdCur->flags == GetType) {
	    if (!_stricmp((char *)pBuildCmdCur->pRule,fpszExt)) {
		strcpy (fpszCmdDst,(char *)pBuildCmdCur->pCmd);
                return pBuildCmdCur->flags;
            }
        }
    }
    return 0;
}


/*** hWalkMake - return make commands one at a time.
*
*  Allow an external anyone to walk the command list.
*
* Input
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
unsigned
short
hWalkMake (
    unsigned short handle,
    int     *Type,
    char    *pszRuleDest,
    char    *pszCmdDest
    ) {

    if (handle) {
        pBuildCmdCur = ((BUILDCMD *)handle)->pNext;
    } else {
        pBuildCmdCur = pBuildCmdHead;
    }

    if (pBuildCmdCur) {
        *Type = pBuildCmdCur->flags;
        strcpy (pszRuleDest, pBuildCmdCur->pRule);
        strcpy (pszCmdDest,  pBuildCmdCur->pCmd);
    }
    return (unsigned short) pBuildCmdCur;
}


/*** fShowMake - Show current build commands
*
*  Append a textual representation of the current build commands to the
*  passed pFile
*
* Input:
*  pFile	= File handle to be added to
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
ShowMake (
    PFILE   pFile
    ) 
{
    buffer  L_buf;

    assert (pFile);
    /*
     * Here we just walk the linked list and append lines with the info
     */
    for (pBuildCmdCur = pBuildCmdHead;
         pBuildCmdCur;
         pBuildCmdCur = pBuildCmdCur->pNext) {

        if (TESTFLAG (pBuildCmdCur->flags, MAKE_FILE)) {
            sprintf (L_buf, "    extmake:[%s]", pBuildCmdCur->pRule);
        } else if (TESTFLAG (pBuildCmdCur->flags, MAKE_SUFFIX)) {
            sprintf (L_buf, "    extmake:%s", pBuildCmdCur->pRule);
        } else if (TESTFLAG (pBuildCmdCur->flags, MAKE_TOOL)) {
            sprintf (L_buf, "    extmake:*%s", pBuildCmdCur->pRule);
        } else if (TESTFLAG (pBuildCmdCur->flags, MAKE_BLDMACRO)) {
            sprintf (L_buf, "    extmake:$%s", pBuildCmdCur->pRule);
        } else {
            assert (FALSE);
        }
        sprintf (strend(L_buf), "%s %s"
                    , TESTFLAG (pBuildCmdCur->flags, MAKE_DEBUG) ? ",D" : RGCHEMPTY
                    , pBuildCmdCur->pCmd
                );
        AppFile (L_buf, pFile);
    }
}


/*** SetExt - assign a particular compile action to a particular action.
*
*  This is called during any initialization to cause a string to be
*  associated with a particular compile action.
*
* Input:
*  val		= char pointer to a string of the form:
*		    .ext string 	    = define .ext.obj rule
*		    .ext.ext string	    = define .ext.ext rule
*		    filename.ext string     = define rule for filename.ext
*		    command string	    = define rule for command
*
*		  During build any %s's in the string are replaced with the
*		  name of the file being compiled.
*
* Output:
*  Returns TRUE, or FALSE if any errors are found.
*
*************************************************************************/
char *
SetExt (
    char *val
    ) {

    buffer  extbuf;                         /* buffer to work on extension  */
    REGISTER int maketype   = 0;            /* type of build command        */
    char    *pCompile;                      /* pointer to command portion   */
    char    *pExt;                          /* pointer to extension portion */
    REGISTER char *pT;                      /* temp pointer                 */
    buffer  tmpval = {0};                   /* (near) buffer to work on     */

    assert (val);
    strncat ((char *) tmpval, val, sizeof(tmpval)-1);
    /*
     * seperate the extension part from the command part. If there is no command,
     * that's an error.
     */
    ParseCmd (tmpval, &pExt, &pCompile);
    if (*pCompile == '\0') {
        return "extmake: Command missing";
    }
    /*
     * CONSIDER: this syntax is somewhat ugly, and unclean to parse
     *
     * Copy the extension part to a local buffer, so we can work on it. Set make
     * type based on the following rules:
     *
     *      Starts with dot:            --> suffix rule.
     *      Starts with "*"             --> tool rule.
     *      Starts with "$"             --> build macro
     *      Starts with "["             --> filename rule.
     *      "text"                      --> Special old-style "tool rule" for TEXT
     *      text <= 3 characters        --> old style suffix rule
     *
     *      In all cases: contains ",d" --> DEBUG rule.
     */
    _strlwr (pExt);
    strcpy (extbuf, pExt);

    if (pT = strstr (extbuf,",d")) {
        maketype = MAKE_DEBUG;
        *pT = 0;
    }

    if (extbuf[0] == '.') {
        maketype |= MAKE_SUFFIX;
    } else if (extbuf[0] == '[') {
        strcpy (extbuf, extbuf+1);
        maketype |= MAKE_FILE;
        if (pT = strchr (extbuf,']')) {
            *pT = 0;
        }
    } else if (extbuf[0] == '*') {
        strcpy (extbuf, extbuf+1);
        maketype |= MAKE_TOOL;
    } else if (extbuf[0] == '$') {
        strcpy (extbuf, extbuf+1);
        maketype |= MAKE_BLDMACRO;
    } else if (!_stricmp (extbuf, "text")) {
        maketype |= MAKE_TOOL;
    } else if (strlen(extbuf) <= 3) {
        ((unsigned short *)extbuf)[0] = (unsigned short)'.';
        strcat (extbuf,pExt);
        strcat (extbuf,".obj");
        maketype |= MAKE_SUFFIX;
    } else  {
        return "extmake: Bad syntax in extension";
    }

    if (fSetMake (maketype, (char *)pCompile, (char *)extbuf)) {
        return NULL;
    } else {
        return "extmake: Error in command line";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\cmd.c ===
/*** cmd.c - handle simple keyboard interactions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"



#define DEBFLAG CMD

struct cmdDesc	cmdUnassigned = {   "unassigned",   unassigned,     0, FALSE };

/*** unassigned - function assigned to unassigned keystrokes
*
*  display an informative message about the unassigned key
*
* Input:
*  Standard editing function
*
* Output:
*  Returns FALSE
*
*************************************************************************/
flagType
unassigned (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) 
{
    buffer L_buf;

    CodeToName ( (WORD)argData, L_buf);
    if (L_buf[0]) {
        printerror ("%s is not assigned to any editor function",L_buf);
    }

    return FALSE;

    pArg; fMeta;
}



/*** confirm - ask our dear user a yes/no question
*
* Purpose:
*  Asks the user a yes/no question, and gets his single character response. If
*  in a macro, the reponse may also come from the macro stream, or from the
*  passed "if in a macro" default response.
*
* Input:
*  fmtstr	= prompt format string
*  arg		= prompt format parameters
*
* Output:
*  TRUE if 'y', else FALSE.
*
*************************************************************************/
flagType
confirm (
    char *fmtstr,
    char *arg
    ) {
    return (flagType)(askuser ('n', 'y', fmtstr, arg) == 'y');
}


/*** askuser - ask our dear user a question
*
* Purpose:
*  Asks the user a question, and gets his single character response. If in
*  a macro, the reponse may also come from the macro stream, or from the
*  passed "if in a macro" default response.
*
* Input:
*  defans	= default answer for non-alpha responses
*  defmac	= default answer if executing in a macro and no "<" is present
*  fmtstr	= prompt format string
*  arg		= prompt format parameters
*
* Output:
*   the lowercase character response.  If the user presses <cancel>, the
*   integer -1 is returned.
*
*************************************************************************/
int
askuser (
    int defans,
    int defmac,
    char *fmtstr,
    char *arg
    ) {
    int c;
    int x;
    PCMD  pcmd;

    switch (c = fMacResponse()) {
    case 0:
        if ((c = defmac) == 0) {
            goto askanyway;
        }
        break;

    default:
        break;

    case -1:
    askanyway:
	DoDisplay ();
	consoleMoveTo( YSIZE, x = domessage (fmtstr, arg));
	c = (int)((pcmd = ReadCmd())->arg & 0xff);
	SETFLAG (fDisplay,RCURSOR);
        if ((PVOID)pcmd->func == (PVOID)cancel) {
	    sout (x, YSIZE, "cancelled", infColor);
	    return -1;
        } else {
            if (!isalpha (c)) {
                c = defans;
            }
	    vout (x, YSIZE, (char *)&c, 1, infColor);
        }
	break;
    }
    return tolower(c);
}


/*** FlushInput - remove all typeahead.
*
*  FlushInput is called when some action invalidates all input.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
FlushInput (
    void
    ) {
    register BOOL MoreInput;
    while (MoreInput = TypeAhead()) {
        ReadCmd ();
    }
}

/*** fSaveDirtyFile - Prompt the user to save or lose dirty files
*
* Purpose:
*
*   Called just before exit to give the user control over soon-to-be-lost
*   editing changes.
*
* Input: None.
*
* Output:
*
*   Returns TRUE if the user wants to exit, FALSE if not.
*
*************************************************************************/
flagType
fSaveDirtyFiles (
    void
    ) {

    REGISTER PFILE pFile;
    int cDirtyFiles = 0;
    flagType fAgain;
    buffer L_buf;

    assert (_pfilechk());
    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if ((FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY) {
            if (++cDirtyFiles == 2) {
                do {
                    fAgain = FALSE;
                    switch (askuser (-1, -1, GetMsg (MSG_SAVEALL, L_buf), NULL)) {
                        case 'y':
                            SaveAllFiles ();
                            return TRUE;

                        case 'n':
                            break;

                        case -1:
                            return FALSE;

                        default:
                            fAgain = TRUE;
                    }
                } while (fAgain);
            }

            do {
                fAgain = FALSE;
                switch (askuser (-1, -1, GetMsg (MSG_SAVEONE, L_buf), pFile->pName)) {
                    case 'y':
                        FileWrite (pFile->pName, pFile);

                    case 'n':
                        break;

                    case -1:
                        return FALSE;

                    default:
                        fAgain = TRUE;
                }
            } while (fAgain);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\compile.c ===
/*** compile.c - perform asynch compile
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"


static char    szFencePost[]   = "+++   M ";
static LINE    yComp	       = 0;   /* last line viewed in compile log */

/*** compile - <compile> editor function
*
*  Implements the <compile> editor function:
*	compile 		= display compile status
*	arg compile		= compile using command based on file extension
*	arg text compile	= compile using command associated with text
*	arg arg text compile	= compile using "text" as command
*	[arg] arg meta compile	= Kill current background compile
*
* Input:
*  Standard editing function.
*
* Output:
*  Returns TRUE if compile succesfully started or queued.
*
*************************************************************************/
flagType
compile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
) {
    static char szStatus[]	= "no compile in progress";
    
    buffer	pCmdBuf;		    /* compile command to execute   */
    buffer	pFileBuf;		    /* current filename.ext	    */
    buffer	pMsgBuf;

    int 	rc;			    /* Used to pick up return codes */


    switch (pArg->argType) {
    
        case NOARG:

	    domessage (fBusy(pBTDComp) ? szStatus+3 : szStatus);
	    return (flagType) (fBusy(pBTDComp));
    
        case NULLARG:

            if (fMeta) {
                return (flagType) BTKill (pBTDComp);
            }

	    /*
	     * no text was entered, we use default settings according to filename
	     * or extension. Form filename.ext in pFileBuf, get filename extension
	     * into pCmdBuf, and append .obj for the suffix rule.
	     */
	    fileext (pFileHead->pName, pFileBuf);
	    extention (pFileBuf, pCmdBuf);

	    /*
	     * if we don't find a command specifically for this file, or a
	     * command for this suffix rule, trying both DEBUG and non-debug
	     * in both cases, print error and return.
	     */
	    if (!(fGetMake (MAKE_FILE, (char *)pMsgBuf, (char *)pFileBuf))) {
            //if (!(fGetMake (MAKE_SUFFIX, (char *)pMsgBuf, (char *)pCmdBuf))) {
                strcat (pCmdBuf, ".obj");
                if (!(fGetMake (MAKE_SUFFIX, (char *)pMsgBuf, (char *)pCmdBuf))) {
                    return disperr (MSGERR_CMPCMD2, pFileBuf);
                }
            //}
        }

	    /*
	     * pMsgBuf has the user specified compile command, pFileBuf has
	     * the filename. sprintf them together into pCmdBuf.
	     */
	    UnDoubleSlashes (pMsgBuf);
            if ( (rc = sprintf (pCmdBuf, pMsgBuf, pFileBuf)) == 0) {
                return disperr (rc, pMsgBuf);
            }
	    break;
    
        case TEXTARG:
	   /*
	    * text was entered. If 1 arg, use the command associated with "text",
	    * else use the text itself.
	    */
	    strcpy ((char *) buf, pArg->arg.textarg.pText);
	    if (pArg->arg.textarg.cArg == 1) {
		if (!fGetMake (MAKE_TOOL, (char *)pMsgBuf, (char *)"text")) {
                    return disperr (MSGERR_CMPCMD);
                }
		UnDoubleSlashes (pMsgBuf);
                if (rc = sprintf (pCmdBuf, pMsgBuf, buf)) {
                    return disperr (rc, pMsgBuf);
                }
            } else {
                strcpy (pCmdBuf, buf);
            }
	    break;
    
        default:
	    assert (FALSE);
    }
    /*
     * At this point, pCmdBuf has the formatted command we are to exec off, and
     * pFileBuf has the filename.ext of the current file. (pMsgBuf is free)
     */

    AutoSave ();
    Display ();

    /*
     * If there's no activity underway and the log file is not empty and
     * the user wants to flush it: Let's flush !
     */
    if (   !fBusy(pBTDComp)
	&& (pBTDComp->pBTFile)
	&& (pBTDComp->pBTFile->cLines)
	&& (confirm ("Delete current contents of compile log ? ", NULL))
	   ) {
	DelFile (pBTDComp->pBTFile, FALSE);
	yComp = 0;
    }

    /*
     * The log file will be updated dynamically
     */
    UpdLog(pBTDComp);

    /*
     * Send jobs
     */
    if (pBTDComp->cBTQ > MAXBTQ-2) {
        return disperr (MSGERR_CMPFULL);
    }

    if ( BTAdd (pBTDComp, (PFUNCTION)DoFence, pCmdBuf)
        && BTAdd (pBTDComp, NULL,    pCmdBuf)) {
	return dispmsg (MSG_QUEUED, pCmdBuf);
    } else {
        return disperr (MSGERR_CMPCANT);
    }

    argData;
}
    

/*** nextmsg - <nextmsg> editor function
*
*  Implements the <nextmsg> editor function:
*	nextmsg 		= move to next compile error within "pasture"
*	arg numarg nextmsg	= move to "nth" next compile error within the
*				  pasture, where "n" may be a signed long.
*	arg nextmsg		= move to next compile error within the pasture
*				  that does not refer to current file
*	meta nextmsg		= jump the fence into the next pasture.
*				  Discard previous pasture.
*	arg arg nextmsg 	= if current file is compile log, then set
*				  the current location for next error to the
*				  current line in the log. If the file is NOT
*				  the compile log, and it is visible in a
*				  window, change focus to that window. If the
*				  file is NOT visible, then split the current
*				  window to make it visible. If we cannot
*				  split, then do nothing.
*
*  Attempt to display the next error message from the compile. Also make
*  sure that if being displayed, the <compile> psuedo file moves with us.
*
* Input:
*  Standard editing function.
*
* Output:
*  Returns TRUE if message read, or function yCompeted. FALSE if no more
*  messages or no log to begin with.
*
*************************************************************************/

struct msgType {
    char    *pattern;
    int     cArgs;
    };

static struct msgType CompileMsg [] =
{   {	"%s %ld %d:",	    3	    },	    /* Zibo grep		     */
    {	"%[^( ](%ld,%d):",  3	    },	    /* new masm 		     */
    {	"%[^( ](%ld):",     2	    },	    /* cmerge/masm		     */
    {	"%[^: ]:%ld:",	    2	    },	    /* bogus unix GREP		     */
    {	"\"%[^\" ]\", line %ld:", 2 },	    /* random unix CC		     */
    {	NULL,		    0	 }  };

flagType
nextmsg (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    FILEHANDLE  fh;                    /* handle for locating file         */
    flagType	fHopping   = FALSE;	/* TRUE = hopping the fence	    */
    pathbuf	filebuf;		/* filename from error message	    */
    fl		flErr;			/* location of error		    */
    flagType	fLook;			/* look at this error message?	    */
    int 	i;			/* everyone's favorite index        */
    LINE	oMsgNext    = 1;	/* relative message number desired  */
    char	*p;			/* temp pointer 		    */
    char	*pText; 		/* pointer into text buffer	    */
    rn		rnCur;			/* range highlighted in log	    */
    pathbuf	tempbuf;		/* text arg buffer		    */
    linebuf	L_textbuf;		/* text arg buffer		    */
    
    /*
     * if there's no log, there's no work.
     */
    if (!PFILECOMP || !PFILECOMP->cLines) {
        return FALSE;
    }
    
    switch (pArg->argType) {
    
        case NULLARG:
            /*
             * arg arg: if current file is <compile>, set yComp to current position
             * therein & get next message. If more than one window, move to the next
             * window in the system before doing that.
             */
            if (pArg->arg.nullarg.cArg >= 2) {
		if (pFileHead == PFILECOMP) {
		    yComp = lmax (YCUR(pInsCur) - 1, 0L);
                    if (cWin > 1) {
                        pArg->argType = NOARG;
                        window (0, pArg, FALSE);
                    }
                    break;
                }
                /*
                 * If the file is visible, the we can just make it current, adn we're done.
                 */
		else for (i=cWin; i; ) {
		    pInsCur = WININST(&WinList[--i]);
		    if (pInsCur->pFile == PFILECOMP) {
                        SetWinCur (i);
			return TRUE;
                    }
                }
                /*
                 * The file is not visible, see if we can split the window and go to it.
                 */
		if ((WINYSIZE(pWinCur) > 20) && (cWin < MAXWIN)) {
		    if (SplitWnd (pWinCur, FALSE, WINYSIZE(pWinCur) / 2)) {
			newscreen ();
			SETFLAG (fDisplay, RCURSOR|RSTATUS);
                        SetWinCur (cWin-1);
			fChangeFile (FALSE, rgchComp);
			flErr.lin = 0;
			flErr.col = 0;
			cursorfl (flErr);
			return TRUE;
                    }
                }
		return FALSE;
            }
            /*
             * Null arg: get the first line of the next file. That is signified by the
             * special case offset of 0.
             */
            else {
                oMsgNext = 0;
            }

        case NOARG:
            /*
             * meta: hop to next fence. Begin deleting lines util a fence is reached, or
             * until there are no more lines. Set up to then read the next message line.
             */
            if (fMeta) {
                do {
		    DelLine (FALSE, PFILECOMP, 0L, 0L);
		    GetLine (0L, L_textbuf, PFILECOMP);
                } while (strncmp (L_textbuf, szFencePost, sizeof(szFencePost)-1)
                   && PFILECOMP->cLines);
                yComp = 0;
            }
            /*
             * No arg: we just get the next line (offset = 1)
             */
	    break;
        
        case TEXTARG:
            /*
             * text arg is an absolute or relative message number. If it is absolute, (no
             * leading plus or minus sign), we reset yComp to 0 to get the n'th line
             * from the begining of the log.
             */
	    strcpy ((char *)L_textbuf, pArg->arg.textarg.pText);
            pText = L_textbuf;
            if (*pText == '+') {
                pText++;
            }
            if (!fIsNum (pText)) {
                return BadArg ();
            }
            if (isdigit(L_textbuf[0])) {
                yComp = 0;
            }
            oMsgNext = atol (pText);
            break;
        
        default:
    	    assert (FALSE);
    }
    /*
     * Ensure that the compile log file has no highlighting.
     */

    ClearHiLite (PFILECOMP, TRUE);

    /*
     * This loop gets executed once per line in the file as we pass over them. We
     * break out of the loop when the desired error line is found, or we run out
     * of messages
     *
     * Entry:
     *  yComp    = line # previously viewed. (0 if no messages viewed yet)
     *  oMsgNext = relative message number we want to view, or 0, indicating
     *             first message of next file.
     */
    while (TRUE) {
        /*
         * Move to check next line.
         */
        if (oMsgNext >= 0) {
    	    yComp++;
        } else if (oMsgNext < 0) {
            yComp--;
        }
        /*
         * read current line from the log file & check for fences & end of file. If
         * we encounter a fence or off the end, declare that there are no more
         * messages in this pasture.
         */

	NoUpdLog(pBTDComp);

	GetLine (lmax (yComp,1L), L_textbuf, PFILECOMP);
	if (   (yComp <= 0L)
	    || (yComp > PFILECOMP->cLines)
	    || !strncmp (L_textbuf, szFencePost, sizeof(szFencePost)-1)
	   ) {
	    UpdLog(pBTDComp);
            if (!fBusy(pBTDComp) || (yComp <= 0L)) {
                yComp = 0;
            }
            domessage ("No more compilation messages" );
            return FALSE;
        }
        /*
         * Attempt to isolate file, row, column from the line.
         */
        for (i = 0; CompileMsg[i].pattern != NULL; i++) {
            flErr.lin = 0;
            flErr.col = 0;
            if (sscanf (L_textbuf, CompileMsg[i].pattern, filebuf, &flErr.lin,
                    &flErr.col) == CompileMsg[i].cArgs) {
                break;
            }
        }
        /*
         * If A validly formatted line was found, and we can find a message (After :)
         * then skip spaces prior to the error message (pointed to by p), pretty up
         * the file, convert it to canonicalized form
         */
        if (   CompileMsg[i].pattern 
            && (*(p = strbscan (L_textbuf+strlen(filebuf), ":"))) 
           ) {
	    p = whiteskip (p+1);
            if (filebuf[0] != '<') {
		rootpath (filebuf, tempbuf);
            } else {
                strcpy (tempbuf, filebuf);
            }
            /*
             * Adjust the error message counter such that we'll display the "nth" message
             * we encounter. Set flag to indicate whether we should look at this
             * error message.
             */
	    fLook = FALSE;
	    if (oMsgNext > 0) {
                if (!--oMsgNext) {
                    fLook = TRUE;
                }
            } else if (oMsgNext < 0) {
                if (!++oMsgNext) {
                    fLook = TRUE;
                }
            } else {
                fLook = (flagType) _strcmpi (pFileHead->pName, tempbuf);
            }
    
	    if (fLook) {
                /*
                 * if about to change to new file, check for existance first, and if found,
                 * autosave our current file.
                 */
                if (_strcmpi(pFileHead->pName, tempbuf)) {
                    fh = MepFOpen(tempbuf, ACCESSMODE_READ, SHAREMODE_RW, FALSE);
                    if (fh == NULL) {
                        return disperr (MSGERR_CMPSRC, tempbuf);
                    }
                    MepFClose (fh);
		    AutoSave ();
                }
                /*
                 * Change the current file to that listed in the error message. If successfull,
                 * then also change our cursor location to that of the error.
                 */
		if (filebuf[0] != 0) {
            memset(buf, 0, sizeof(buf));
            strncat(buf, tempbuf, sizeof(buf)-1);
                    if (!fChangeFile (FALSE, buf)) {
                        return FALSE;
                    }
		    if (flErr.lin--) {
                        if (flErr.col) {
			    flErr.col--;
                        } else {
			    cursorfl (flErr);
			    flErr.col = dobol ();
                        }
			cursorfl (flErr);
                    }
                }
                /*
                 * Update the contents of the compile log, if it happens to be displayed.
                 */
		rnCur.flLast.lin = rnCur.flFirst.lin = lmax (yComp,0L);
		rnCur.flFirst.col = 0;
		rnCur.flLast.col = sizeof(linebuf);
		SetHiLite (PFILECOMP, rnCur, HGCOLOR);
		UpdateIf (PFILECOMP, lmax (yComp,0L), FALSE);
                /*
                 * Place the actual error message text on the dialog line.
                 */
                if ((int)strlen(p) >= XSIZE) {
                    p[XSIZE] = '\0';
                }
		domessage( "%s", p );
		return TRUE;
            }
        }
    }

    argData;
}


/*** DoFence - Build Fence message line & put it in the log file
*
*  Builds the line output to the compile log which seperates succesive
*  compiles and puts it into the log file.
*
*  "+++ PWB Compile: [drive:pathname] command"
*
* Input:
*  pCmd 	= ptr to command to execute (Series of null terminated strings)
*
* Output:
*  Returns nothing
*
* Remarks: - Under OS/2, since we're called by the background thread, we
*	     need to switch stack checking off
*	   - The background thread calls this routime at idle time
*
*************************************************************************/

// #pragma check_stack (off)

void
DoFence (
    char *pCmd,
    flagType fKilled
    ) {
    linebuf pFenceBuf;

    if (!fKilled) {
	AppFile (BuildFence ("Compile", pCmd, pFenceBuf), pBTDComp->pBTFile);
	UpdateIf (pBTDComp->pBTFile, pBTDComp->pBTFile->cLines - 1, FALSE);
    }
}


// #pragma check_stack ()


/*** BuildFence - Build Fence message line
*
*  Builds the line output to the compile log which seperates succesive
*  compiles.
*
*  "+++ PWB Compile: [drive:pathname] command"
*
* Input:
*  pFunction	= pointer to function name being dealt with
*  pCmd 	= ptr to command to execute (Series of null terminated strings)
*  pFenceBuf	= ptr to buffer in wich to put constructed fence
*
* Output:
*  Returns nothing
*
* Remarks: - Under OS/2, since we're called by the background thread, we
*	     need to switch stack checking off
*	   - The background thread calls this routime at idle time
*
*************************************************************************/

// #pragma check_stack (off)

char *
BuildFence (
    char const *pFunction,
    char const *pCmd,
    char       *pFenceBuf
    ) {
    strcpy (pFenceBuf, szFencePost);
    strcat (pFenceBuf, pFunction);
    strcat (pFenceBuf, ": [");
    GetCurPath (strend (pFenceBuf));
    strcat (pFenceBuf, "] ");
    strcat (pFenceBuf, pCmd);
    return (pFenceBuf);
}

// #pragma check_stack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\assign.c ===
/****  assign.c - keyboard reassignment and switch setting
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*        26-Nov-1991 mz        Strip out near/far
*
*
*************************************************************************/
#include "mep.h"


#define DEBFLAG CMD

/****************************************************************************
 *                                                                          *
 *  Assignment types.  Used by UpdToolsIni                                  *
 *                                                                          *
 ****************************************************************************/

#define ASG_MACRO   0
#define ASG_KEY     1
#define ASG_SWITCH  2


/*** NameToFunc - map a user-specified function name into internal structure
 *
 *  Given a name of a function, find it in the system table or in the set
 *  of defined macros.        Return the pointer to the command structure
 *
 *  Since, with user-defined extensions as well as macros, there is the
 *  possibility of name collision (effectively masking one function) we allow
 *  disambiguation by specifying an extension name ala .DEF file format:
 *
 *        func       - look up func in macro table and then in extensions
 *                     in order of installation
 *        exten.func - look up func in exten only.
 *
 *  pName    = char pointer to potential name
 *
 *  Returns pointer to command structure if found, NULL otherwise
 *
 *************************************************************************/
PCMD
FindNameInCmd (
    char    *pName,
    PCMD    pCmd
    ) {
    while (pCmd->name) {
        if (!_stricmp (pName, pCmd->name)) {
            return pCmd;
        }
        pCmd++;
    }
    return NULL;
}


PCMD
NameToFunc (
    char    *pName
    ) {

    /*        see if an extension override is present
     */
    {
        char *pExt = pName;
        PCMD pCmd;
        int i;

        pName = strbscan (pExt, ".");
        if (*pName != '\0') {
            *pName++ = '\0';
            for (i = 0; i < cCmdTab; i++) {
                if (!_stricmp (pExt, pExtName[i])) {
                    pCmd = FindNameInCmd (pName, cmdSet[i]);
                    pName[-1] = '.';
                    return pCmd;
                }
            }
            return NULL;
        }
        pName = pExt;
    }

    {
        REGISTER int k;

        for (k = 0; k < cMac; k++) {
            if (!_stricmp (pName, rgMac[k]->name)) {
                return rgMac[k];
            }
        }
    }


    {
        int i;
        REGISTER PCMD pCmd;

        /* look up function name in table */
        for (i = 0; i < cCmdTab; i++) {
            if ((pCmd = FindNameInCmd (pName, cmdSet[i])) != NULL) {
                return pCmd;
            }
        }
        return NULL;
    }
}



/*** DoAssign - make assignment
*
* Purpose:
*  Executes the keystroke and macro assignment strings passed to it by either
*  the assign command processor, or the tools.ini file processor.
*
* Input:
*  asg  = Pointer to asciiz assignment string.  The line is assumed
*         to be clean (see GetTagLine).
*
* Output:
*  TRUE is assignment made
*
*************************************************************************/
flagType
DoAssign (
    char    *asg
    ) {

    REGISTER char *p;
    flagType fRet;

    asg = whiteskip (asg);
    RemoveTrailSpace (asg);

    if (*(p = strbscan(asg,":")) == 0) {
        return disperr (MSG_ASN_MISS, asg);
    }

    *p++ = 0;
    _strlwr (asg);
    RemoveTrailSpace (asg);
    p = whiteskip (p);

    if (*p == '=') {
        fRet = SetMacro (asg, p = whiteskip (p+1));
    } else {
        fNewassign = TRUE;
        if (NameToFunc (asg) == NULL) {
            fRet = SetSwitch (asg, p);
        } else {
            fRet = SetKey (asg, p);
            if (!fRet) {
                if (*p == '\0') {
                    disperr (MSG_ASN_MISSK, asg);
                } else {
                    disperr (MSG_ASN_UNKKEY, p);
                }
            }
        }
    }
    return fRet;
}


/*** SetMacro - define a keystroke macro
*
* Input:
*  name         = lowercase macro name
*  p            = sequence of editor functions and/or quoted text
*
* Output:
*
*************************************************************************/
flagType
SetMacro (
    char const *name,
    char const *p
    ) {

    REGISTER PCMD pFunc;
    int i, j;

    /* MACRO-NAME:=functions */
    /* see if macro already defined */
    for (i = 0; i < cMac; i++) {
        if (!strcmp (rgMac[i]->name, name)) {
            for (j = 0; j < cMacUse; j++) {
                if ((char *) mi[j].beg == rgMac[j]->name) {
                    return disperr (MSG_ASN_INUSE, name);
                }
            }
            break;
        }
    }

    if (i != cMac) {
        /*
         * redefining a macro: realloc exiting text
         */
        rgMac[i]->arg = (CMDDATA)ZEROREALLOC ((char *) rgMac[i]->arg, strlen(p)+1);
        strcpy ((char *) rgMac[i]->arg, p);
        return TRUE;
    }

    if (cMac >= MAXMAC) {
        return disperr (MSG_ASN_MROOM, name);
    }

    pFunc = (PCMD) ZEROMALLOC (sizeof (*pFunc));
    pFunc->arg = (UINT_PTR) ZMakeStr (p);
    pFunc->name = ZMakeStr (name);
    pFunc->func = macro;
    pFunc->argType = KEEPMETA;
    rgMac[cMac++] = pFunc;


    return TRUE;
}


/*** assign - assign editting function
*
*  Handle key, switch and macro assignments
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
assign (
    CMDDATA argData,
    REGISTER ARG *pArg,
    flagType fMeta
    ) {

    fl      flNew;
    linebuf abuf;
    char * pBuf = NULL;

    switch (pArg->argType) {

    case NOARG:
        GetLine (pArg->arg.noarg.y, abuf, pFileHead);
        return DoAssign (abuf);

    case TEXTARG:
        strcpy ((char *) abuf, pArg->arg.textarg.pText);
        if (!strcmp(abuf, "?")) {
            AutoSave ();
            return fChangeFile (FALSE, rgchAssign);
            }
        return DoAssign (abuf);

    /*  NULLARG is transformed into text to EOL */
    case LINEARG:
        flNew.lin = pArg->arg.linearg.yStart;
        while (    flNew.lin <= pArg->arg.linearg.yEnd &&
                (pBuf = GetTagLine (&flNew.lin, pBuf, pFileHead))) {
            if (!DoAssign (pBuf)) {
                flNew.col = 0;
                cursorfl (flNew);
                if (pBuf) {
                    FREE (pBuf);
                }
                return FALSE;
            }
        }
        if (pBuf) {
            FREE (pBuf);
        }
        return TRUE;

    /*  STREAMARG is illegal    */
    case BOXARG:
        for (flNew.lin = pArg->arg.boxarg.yTop; flNew.lin <= pArg->arg.boxarg.yBottom; flNew.lin++) {
            fInsSpace (pArg->arg.boxarg.xRight, flNew.lin, 0, pFileHead, abuf);
            abuf[pArg->arg.boxarg.xRight+1] = 0;
            if (!DoAssign (&abuf[pArg->arg.boxarg.xLeft])) {
                flNew.col = pArg->arg.boxarg.xLeft;
                cursorfl (flNew);
                return FALSE;
            }
        }
        return TRUE;
    }

    return FALSE;

    argData; fMeta;
}


/*** FindSwitch - lookup switch
*
*  Locate switch descriptor, given it's name
*
* Input:
*  p = pointer to text switch name
*
* Output:
*  Returns PSWI, or NULL if not found.
*
*************************************************************************/
PSWI
FindSwitch (
    char *p
    ) {

    REGISTER PSWI pSwi;
    int i;

    for (i = 0; i < cCmdTab; i++) {
        for (pSwi = swiSet[i]; pSwi != NULL && pSwi->name != NULL; pSwi++) {
            if (!strcmp (p, pSwi->name)) {
                return pSwi;
            }
        }
    }
    return NULL;
}


/*** SetSwitch - Set a switch to a particular value
*
*  Given a switch name, and a value to set it to, perform the assignment
*
* Input:
*  p             = pointer to switch name (possibly prefexed by "no" if a
*                  boolean
*  val           = new value to set switch to
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
SetSwitch (
    char    *p,
    char    *val
    ) {

    PSWI    pSwi;
    int     i;
    flagType f;
    char    *pszError;
    fl      flNew;                          /* new location of cursor       */

    f = TRUE;

    /*  figure out if no is a prefix or not
     */

    if ((pSwi = FindSwitch (p)) == NULL) {
        if (!_strnicmp ("no", p, 2)) {
            p += 2;
            f = FALSE;
            if ((pSwi = FindSwitch (p)) != NULL && pSwi->type != SWI_BOOLEAN) {
                pSwi = NULL;
            }
        }
    }

    if (pSwi == NULL) {
        return disperr (MSG_ASN_NOTSWI, p);
    }

    switch (pSwi->type & 0xFF) {
    case SWI_BOOLEAN:
        if (*val == 0) {
            *pSwi->act.fval = f;
            return TRUE;
        } else if (!f) {
            printerror ("Boolean switch style conflict");
            return FALSE;
        } else if (!_stricmp (val, "no")) {
            *pSwi->act.fval = FALSE;
            return TRUE;
        } else if (!_stricmp (val, "yes")) {
            *pSwi->act.fval = TRUE;
            return TRUE;
        }
        break;

    case SWI_NUMERIC:
        if (!f) {
            if (*val == 0) {
                val = "0";
            } else {
                break;
            }
        }
        if (*val != 0) {
            *pSwi->act.ival = ntoi (val, pSwi->type >> 8);
            return TRUE;
        }
        break;

    case SWI_SCREEN:
        /* change screen parameters */
        i = atoi (val);
        if (i == 0) {
            return disperr (MSG_ASN_ILLSET);
        }
        if ((cWin > 1) &&
            (((pSwi->act.ival == (int *)&XSIZE) && (i != XSIZE)) ||
             ((pSwi->act.ival == (int *)&YSIZE) && (i != YSIZE)))) {
            disperr (MSG_ASN_WINCHG);
            delay (1);
            return FALSE;
        }
        if ((pSwi->act.ival == (int *)&XSIZE && !fVideoAdjust (i, YSIZE)) ||
            (pSwi->act.ival == (int *)&YSIZE && !fVideoAdjust (XSIZE, i))) {
            return disperr (MSG_ASN_UNSUP);
        }
        SetScreen ();
        if (pInsCur && (YCUR(pInsCur) - YWIN(pInsCur) > YSIZE)) {
            flNew.col = XCUR(pInsCur);
            flNew.lin = YWIN(pInsCur) + YSIZE - 1;
            cursorfl (flNew);
        }
        domessage (NULL);
        return TRUE;

    case SWI_SPECIAL:
        /* perform some special initialization */
        if ( ! (*pSwi->act.pFunc) (val) ) {
            return disperr (MSG_ASN_INVAL, pSwi->name, val);
        }
        return TRUE;

    case SWI_SPECIAL2:
        /* perform special initialization with possible error return string */
        if (pszError = (*pSwi->act.pFunc2) (val)) {
            printerror (pszError);
            return FALSE;
        }
        return TRUE;

    default:
        break;
    }

    return FALSE;
}


/*** AckReplace - Acknowledge changes to <assign> file.
*
* Purpose:
*
*   To be called whenever a line in the current file changes. Allows
*   special handling for some files.
*
* Input:
*   line  - Number of the line that changed
*   fUndo - TRUE if this replacement is an <undo> operation.
*
* Output: None
*
* Notes:
*
*   Currently, this means making changes to <assign> take effect immediately.
*   If the user has changed the current line without leaving it, we flag
*   the change so it will take place after they leave.        If the user is
*   elsewhere, the change takes place now.
*
*************************************************************************/

static flagType fChanged = FALSE;

void
AckReplace (
    LINE line,
    flagType fUndo
    ) {


    if (pInsCur->pFile == pFileAssign) {
        if (YCUR(pInsCur) == line || fUndo) {
            fChanged = (flagType)!fUndo;
        } else {
            DoAssignLine (line);
        }
    }
}



/*** AckMove - Possibly parse line in <assign> file.
*
* Purpose:
*
*   To be called whenever the cursor moves to a new line in the current
*   file.  This allows special line processing to take place after a
*   line has been changed.
*
* Input:
*   lineOld -        Number of line we're moving from.
*   lineNew -        Number of line we're moving to.
*
* Output: None.
*
* Notes:
*
*        Currently, this makes the <assign> file work.  If the line we are
*   moving from has changed, we make the assignment.  We rely on AckReplace
*   to set fChanged ONLY when the affected file is <assign>.
*
*************************************************************************/

void
AckMove (
    LINE lineOld,
    LINE lineNew
    ) {
    if (pInsCur->pFile== pFileAssign && fChanged && lineOld != lineNew ) {
        fChanged = FALSE;
        DoAssignLine (lineOld);
    }
}



/*** DoAssignLine - Take line from current file and <assign> with it
*
* Purpose:
*
*   Used by the Ack* functions to perform an <assign> when the time is
*   right.
*
* Input:
*   line -  Line in the file to read.
*
* Output: None
*
*************************************************************************/

#define CINDEX(clr)        ((&clr-&ColorTab[0])+isaUserMin)

void
DoAssignLine (
    LINE line
    ) {
    fl      flNew;
    char    *pch;
    struct lineAttr rgColor[2];

    flNew.lin = line;
    if ((pch = GetTagLine (&flNew.lin, NULL, pInsCur->pFile)) &&
        flNew.lin == line+1) {
        if (!DoAssign(pch)) {
            flNew.col = XCUR(pInsCur);
            flNew.lin--;
            cursorfl (flNew);
            DelColor (line, pInsCur->pFile);
        } else {
            /*
             * Hilite the changed line so we can find it again
             */
            rgColor[0].attr = rgColor[1].attr = (unsigned char)CINDEX(hgColor);
            rgColor[0].len  = (unsigned char)slSize.col;
            rgColor[1].len  = 0xFF;
            PutColor (line, rgColor, pInsCur->pFile);
        }
    }
}



/*** UpdToolsIni - Update one entry in the tools.ini file
*
* Purpose:
*
*   Used for automatic updates, such as when the <assign> file is saved.
*
*   The posible values for asgType are:
*
*        ASG_MACRO   - This is a macro assignment.
*        ASG_KEY     - This assigns a function to a key.
*        ASG_SWITCH  - THis assigns a value to a switch.
*
* Input:
*   pszValue   - Complete string to enter, as in "foo:value".
*   asgType    - Type of assignment.
*
* Output: None
*
* Notes:
*
*   If necessary, the string will be broken across several lines using
*   the continuation character.
*
*   UNDONE: This "effort" has not been made"
*   Every effort is made to preserve the user's tools.ini format.  To this
*   end:
*
*        o When an entry already exists for the given switch or function,
*          the new value is written over the old value, with the first
*          non-space character of each coinciding.
*
*        o If an entry does not exist, a new entry is made at the end
*          of the section, and is indented to match the previous entry.
*
*   We find an existing string by searching through the tagged sections
*   in the same order in which they are read, then pick the last instance
*   of the string.  In other words, the assignment we replace will be
*   the one that was actually used.  This order is assumed to be:
*
*                    [NAME]
*                    [NAME-os version]
*                    [NAME-video type]
*                    [NAME-file extension]
*                    [NAME-..] (if no file extension section)
*
*   If we are not replacing an existing string, we add the new string at
*   the end of the [MEP] section.
*
*   The string pszAssign is altered.
*
*************************************************************************/

void
UpdToolsIni (
    char * pszAssign
    ) {

    char * pchLeft;
    char * pchRight;
    int asgType;
    LINE lReplace, lAdd = 0L, l;
    linebuf lbuf;
    flagType fTagFound = TRUE;

    if (pFileIni == NULL || pFileIni == (PFILE)-1) {
        /*
        ** We assume here that pFileIni has no
        ** value because there is no TOOLS.INI file
        */
        if (CanonFilename ("$INIT:tools.ini", lbuf)) {
            pFileIni = AddFile (lbuf);
            assert (pFileIni);
            pFileIni->refCount++;
            SETFLAG (FLAGS(pFileIni), DOSFILE);
            FileRead (lbuf, pFileIni, FALSE);
        } else {
            return;
        }
    }

    /* First, figure out what is what */
    pchLeft = whiteskip (pszAssign);
    pchRight = strchr (pchLeft, ':');
    *pchRight++ = '\0';
    if (*pchRight == '=') {
        asgType = ASG_MACRO;
        pchRight++;
    } else {
        asgType = NameToFunc (pchLeft) ? ASG_KEY : ASG_SWITCH;
    }
    pchRight = whiteskip (pchRight);


    // First, let's search through the [NAME] section.  If
    // we are replacing, we search for the line to replace.
    // If we are not, we are simply trying to find the end.
    //
    lReplace = 0L;

    if (0L < (l = FindMatchLine (NULL, pchLeft, pchRight, asgType, &lAdd))) {
        lReplace = l;
    } else {
        fTagFound = (flagType)!l;
    }

    //sprintf (lbuf, "%d.%d", _osmajor, _osminor);
    //if (_osmajor >= 10 && !_osmode) {
    //    strcat (lbuf, "R");
    //}
    if (0L < (l = FindMatchLine (lbuf, pchLeft, pchRight, asgType, &lAdd))) {
        lReplace = l;
    } else {
        fTagFound = (flagType)(fTagFound || (flagType)!l);
    }

    if (0L < (l = FindMatchLine (VideoTag(), pchLeft, pchRight, asgType, &lAdd))) {
        lReplace = l;
    } else {
        fTagFound = (flagType)(fTagFound || (flagType)!l);
    }

    // UNDONE: This should try to read the extension section
    // currently "active".  What it does is read the extension
    // section appropriate to the current file.  If these are
    // not the same, it fails.
    //
    if (extention (pInsCur->pFile->pName, lbuf)) {
        if (0L < (l = FindMatchLine (lbuf, pchLeft, pchRight, asgType, &lAdd))) {
            lReplace = l;
        } else if (l == -1L) {
            if (0L < (l = FindMatchLine ("..", pchLeft, pchRight, asgType, &lAdd))) {
                lReplace = l;
            } else {
                fTagFound = (flagType)(fTagFound || (flagType)!l);
            }
        }
    }


    // If we are not supposed to replace a line,
    // or if we are but we can't find a suitable
    // line, we simply insert the new line
    //
    strcpy (lbuf, pchLeft);
    if (asgType == ASG_MACRO) {
        strcat (lbuf, ":= ");
    } else {
        strcat (lbuf, ": ");
    }
    strcat (lbuf, pchRight);

    if (!fTagFound) {
        lAdd = 1L;
        InsLine (FALSE, 0L, 1L, pFileIni);
        sprintf (buf, "[%s]", pNameEditor);
        PutTagLine (pFileIni, buf, 0L, 0);
    }

    if (lReplace == 0L) {
        assert (lAdd <= pFileIni->cLines);
        InsLine (FALSE, lAdd, 1L, pFileIni);
    } else {
        lAdd = lReplace;
    }

    PutLine (lAdd, lbuf, pFileIni);
}


/*** FindMatchLine - Find a line to replace in TOOLS.INI
*
* Purpose:
*
*   Called from UpdToolsIni to find the right place to update
*
* Input:
*   pszTag  -        Which tagged section to look in
*   pszLeft -        Left side of the assignment
*   pszRight-        Right side of the assignment
*   asgType -        Type of assignment (one of ASG_*)
*   plAdd   -        Returns line number of place to insert a new line
*
* Output:
*
*   Returns line number in pFileIni of matchine line, 0L if there is
*   no match and -1L if the specified tag does not exist.
*
*************************************************************************/

LINE
FindMatchLine (
    char * pszTag,
    char * pszLeft,
    char * pszRight,
    int    asgType,
    LINE * plAdd
    ) {

    char pszTagBuf[80];
    char * pchRight, * pchLeft;
    LINE lCur, lNext, lReplace = 0L;
    flagType fUser = FALSE;
    flagType fExtmake = FALSE;
    int cchExt;

    strcpy (pszTagBuf, pNameEditor);
    if (pszTag) {
        strcat (pszTagBuf, "-");
        strcat (pszTagBuf, pszTag);
    }

    if ((LINE)0 == (lNext = LocateTag (pFileIni, pszTagBuf))) {
        return -1L;
    }

    if (!_stricmp (pszLeft, "user")) {
        fUser = TRUE;
    } else if (!_stricmp (pszLeft, "extmake")) {
        pchRight = whitescan (pszRight);
        cchExt = (int)(pchRight - pszRight);
        fExtmake = TRUE;
    }

    // Get each line in the current section, checking the right
    // or left side for a match with the passed-in string.
    //
    pchLeft = NULL;
    while (lCur = lNext, pchLeft = GetTagLine (&lNext, pchLeft, pFileIni)) {
        pchRight = strbscan (pchLeft, ":");
        *pchRight = '\0';
        if (pchRight[1] == '=') {
            if (asgType != ASG_MACRO) {
                continue;
            }
            pchRight++;
        } else if (asgType == ASG_MACRO) {
                continue;
        }
        pchRight = whiteskip (pchRight);

        switch (asgType) {
            case ASG_KEY:
                if (!_stricmp (pszRight, pchRight)) {
                    lReplace = lCur;
                }
                break;

            case ASG_SWITCH:
                if (!_stricmp (pszLeft, pchLeft)) {
                    lReplace = lCur;
                }
                break;

            case ASG_MACRO:
                if (fUser) {
                    continue;
                }

                if (!_stricmp (pszLeft, pchLeft)) {
                    if (!(fExtmake && _strnicmp (pszRight, pchRight, cchExt))) {
                        lReplace = lCur;
                    }
                }
                break;

            default:
                assert (FALSE);
        }
    }

    if (!pszTag) {
        *plAdd = lCur;
    }
    return lReplace;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\cdelete.c ===
/*** cdelete.c - delete the previous character in a line
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"

/*** cdelete - character delete function
*
* Input:
*  Standard editing function
*
* Output:
*  Returns TRUE on deletion
*
*************************************************************************/
flagType
cdelete (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    return DoCDelete (FALSE);

    argData; pArg; fMeta;
}


/*** emacsdel - emacs character delete function
*
* Input:
*  Standard editing function
*
* Output:
*  Returns TRUE on deletion
*
*************************************************************************/
flagType
emacscdel (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    return DoCDelete (TRUE);

    argData; pArg; fMeta;

}


/*** DoCDelete - perform character deletion
*
*  Delete the character at the current cursor location
*
* Input:
*  fEmacs	- EMACs type delete flag
*
* Output:
*  Returns TRUE on deletion
*
*************************************************************************/
flagType
DoCDelete (
    flagType fEmacs
    ) {

    fl      fl;                             /* file loc to position at      */
    int     x;
    char    *p;
    linebuf tempbuf;
    struct lineAttr rgla[sizeof(linebuf)];
    flagType fColor;

    fl.col = XCUR(pInsCur);
    fl.lin = YCUR(pInsCur);
    /*
     * xCursor is zero. If yCursor is also zero (top of file), we can't move
     * back, so nothing to delete. Otherwise, move to end of previous line, and
     * if emacs & insert mode, join the lines.
     */
    if (fl.col == 0) {
        if (fl.lin == 0) {
            return FALSE;
        } else {
            fl.lin--;
            fl.col = LineLength (fl.lin, pFileHead);
            if (fInsert && fEmacs) {
                DelStream (pFileHead, fl.col, fl.lin, 0, fl.lin + 1);
            }
        }
    } else {
        /*
         * column is non-zero, so back it up one.
         */
        GetLine (fl.lin, tempbuf, pFileHead);
        x = cbLog (tempbuf);
        fl.col = DecCol (fl.col, tempbuf);
        /*
         * we're in the middle of a line. If in insert mode, back up the cursor, and
         * delete the character there.
         */
        if (fInsert) {
            DelBox (pFileHead, fl.col, fl.lin, fl.col, fl.lin);
        } else {
            /*
             * we're in the middle of a line, but not insert mode. Get the text of the
             * line & pointer to character.
             */
            p = pLog (tempbuf, fl.col, TRUE);
            /*
             * If emacs, and we're actually IN text, then replace the character with a
             * space.
             */
            if (fEmacs) {
                if (fl.col+1 <= x && *p != ' ') {
                    *p = ' ';
                    // SetColor (pFileHead, fl.lin, fl.col, 1, fgColor);
                    PutLine (fl.lin, tempbuf, pFileHead);
                }
            }
            /*
             * if we're beyond the end of the line, just position to the end of the line.
             */
            else if (fl.col+1 > x) {
                fl.col = x;
            }
            /*
             * if the first non-blank character is PAST the current position, then just
             * position at the begining of the line.
             */
            else if ((colPhys (tempbuf, whiteskip (tempbuf)) > fl.col)) {
                fl.col = 0;
            }
            /*
             * finaly, when all else fails, back up, and replace the character under the
             * cursor with a space.
             */
            else if (*p != ' ') {
                *pLog (tempbuf,fl.col,TRUE) = ' ';
                if (fColor = GetColor (fl.lin, rgla, pFileHead)) {
                    ShiftColor (rgla, fl.col, -1);
                    ColorToLog (rgla, buf);
                }
                PutLine (fl.lin, tempbuf, pFileHead);
                if (fColor) {
                    PutColor (fl.lin, rgla, pFileHead);
                }
            }
        }
    }
    cursorfl (fl);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\console.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.c

Abstract:

    Interface to the console for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/

#include <string.h>
#include "mep.h"
#include "mouse.h"




//
//  EVENT BUFFER
//
//   The event buffer is used to store event records from the input
//   queue.
//
#define     INITIAL_EVENTS	32
#define     MAX_EVENTS		64
#define     EVENT_INCREMENT	4

#define     ADVANCE		TRUE
#define     NOADVANCE		FALSE
#define     WAIT		TRUE
#define     NOWAIT		FALSE

//
//  For accessing fields of an event record
//
#define     EVENT_TYPE(p)   ((p)->EventType)
#define     EVENT_DATA(p)   ((p)->Event)

//
//  For casting event records
//
#define     PMOUSE_EVT(p)   (&(EVENT_DATA(p).MouseEvent))
#define     PWINDOW_EVT(p)  (&(EVENT_DATA(p).WindowBufferSizeEvent))
#define     PKEY_EVT(p)     (&(EVENT_DATA(p).KeyEvent))
#define     PMENU_EVT(p)    (&(EVENT_DATA(p).MenuEvent))
#define     PFOCUS_EVT(p)   (&(EVENT_DATA(p).FocusEvent))
//
//  The event buffer structure
//
typedef struct EVENT_BUFFER {
    DWORD		MaxEvents;		    //	Max number of events in buffer
    DWORD		NumberOfEvents; 	    //	Number of events in buffer
    DWORD		EventIndex;		    //	Event Index
    BOOL		BusyFlag;		    //	Busy flag
    CRITICAL_SECTION	CriticalSection;	    //	To maintain integrity
    CRITICAL_SECTION	PeekCriticalSection;	    //	While peeking
    PINPUT_RECORD	EventBuffer;		    //	Event Buffer
} EVENT_BUFFER, *PEVENT_BUFFER;





//
//  Screen attributes
//
#define     BLACK_FGD	    0
#define     BLUE_FGD	    FOREGROUND_BLUE
#define     GREEN_FGD	    FOREGROUND_GREEN
#define     CYAN_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN)
#define     RED_FGD	    FOREGROUND_RED
#define     MAGENTA_FGD     (FOREGROUND_BLUE | FOREGROUND_RED)
#define     YELLOW_FGD	    (FOREGROUND_GREEN | FOREGROUND_RED)
#define     WHITE_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED)

#define     BLACK_BGD	    0
#define     BLUE_BGD	    BACKGROUND_BLUE
#define     GREEN_BGD	    BACKGROUND_GREEN
#define     CYAN_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN)
#define     RED_BGD	    BACKGROUND_RED
#define     MAGENTA_BGD     (BACKGROUND_BLUE | BACKGROUND_RED)
#define     YELLOW_BGD	    (BACKGROUND_GREEN | BACKGROUND_RED)
#define     WHITE_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED)



//
//  The AttrBg and AttrFg arrays are used for mapping DOS attributes
//  to the new attributes.
//
WORD AttrBg[ ] = {
    BLACK_BGD,				    // black
    BLUE_BGD,				    // blue
    GREEN_BGD,				    // green
    CYAN_BGD,				    // cyan
    RED_BGD,				    // red
    MAGENTA_BGD,			    // magenta
    YELLOW_BGD, 			    // brown
    WHITE_BGD,				    // light gray
    BACKGROUND_INTENSITY | BLACK_BGD,	    // dark gray
    BACKGROUND_INTENSITY | BLUE_BGD,	    // light blue
    BACKGROUND_INTENSITY | GREEN_BGD,	    // light green
    BACKGROUND_INTENSITY | CYAN_BGD,	    // light cyan
    BACKGROUND_INTENSITY | RED_BGD,	    // light red
    BACKGROUND_INTENSITY | MAGENTA_BGD,     // light magenta
    BACKGROUND_INTENSITY | YELLOW_BGD,	    // light yellow
    BACKGROUND_INTENSITY | WHITE_BGD	    // white
};

WORD AttrFg[  ] = {
    BLACK_FGD,				    // black
    BLUE_FGD,				    // blue
    GREEN_FGD,				    // green
    CYAN_FGD,				    // cyan
    RED_FGD,				    // red
    MAGENTA_FGD,			    // magenta
    YELLOW_FGD, 			    // brown
    WHITE_FGD,				    // light gray
    FOREGROUND_INTENSITY | BLACK_FGD,	    // dark gray
    FOREGROUND_INTENSITY | BLUE_FGD,	    // light blue
    FOREGROUND_INTENSITY | GREEN_FGD,	    // light green
    FOREGROUND_INTENSITY | CYAN_FGD,	    // light cyan
    FOREGROUND_INTENSITY | RED_FGD,	    // light red
    FOREGROUND_INTENSITY | MAGENTA_FGD,     // light magenta
    FOREGROUND_INTENSITY | YELLOW_FGD,	    // light yellow
    FOREGROUND_INTENSITY | WHITE_FGD	    // white
};

//
//  GET_ATTRIBUTE performs the mapping from old attributes to new attributes
//
#define GET_ATTRIBUTE(x)    (AttrFg[x & 0x000F ] | AttrBg[( x & 0x00F0 ) >> 4])


//
//  The LINE_INFO structure contains information about each line in the
//  screen buffer.
//
typedef struct _LINE_INFO {

    BOOL    Dirty;              //  True if has not been displayed
    BOOL    Garbage;            //  True if contents are garbage
    int     colMinChanged;      //  if dirty, smallest col changed
    int     colMaxChanged;      //  if dirty, biggest col changed
    PCHAR_INFO  Line;           //  Pointer to the line.

} LINE_INFO, *PLINE_INFO;

#define ResetLineInfo(pli)               \
    {   pli->Dirty          = FALSE;     \
        pli->Garbage        = TRUE;      \
        pli->colMinChanged  = 10000;     \
        pli->colMaxChanged  = -1;        \
	}

//
//  The SCREEN_DATA structure contains the information about individual
//  screens.
//
typedef struct SCREEN_DATA {
    HANDLE              ScreenHandle;       //  Handle to screen
    PLINE_INFO          LineInfo;           //  Array of line info.
    PCHAR_INFO          ScreenBuffer;       //  Screen buffer
    ULONG               MaxBufferSize;      //  Max. buffer size
    ATTRIBUTE           AttributeOld;       //  Attribute - original
    WORD                AttributeNew;       //  Attribute - converted
    ROW                 FirstRow;           //  First row to update
    ROW                 LastRow;            //  Last row to update
    CRITICAL_SECTION	CriticalSection;    //	To maintain integrity
    DWORD               CursorSize;         //  Cursor Size
    SCREEN_INFORMATION	ScreenInformation;  //	Screen information
} SCREEN_DATA, *PSCREEN_DATA;


//
//  Static global data
//
static EVENT_BUFFER	EventBuffer;		    //	Event buffer
static HANDLE		hInput; 		    //	handle to stdin
static HANDLE		hOutput;		    //	handle to stdout
static HANDLE		hError; 		    //	handle to stderr
static PSCREEN_DATA	OutputScreenData;	    //	Screen data for hOutput
static PSCREEN_DATA	ActiveScreenData;	    //	Points to current screen data
static BOOL		Initialized = FALSE;	    //	Initialized flag


#if defined (DEBUG)
    static char DbgBuffer[128];
#endif


//
//  Local Prototypes
//
BOOL
InitializeGlobalState (
    void
    );


PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    );

BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    );

PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    );

void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    );

BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    );

BOOL
MenuEvent (
    PMENU_EVENT_RECORD pEvent
    );

BOOL
FocusEvent (
    PFOCUS_EVENT_RECORD pEvent
    );

BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    );


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    );


BOOL
InitializeGlobalState (
    void
    )
/*++

Routine Description:

    Initializes our global state data.

Arguments:

    None.

Return Value:

    TRUE if success
    FALSE otherwise.

--*/
{


    //
    //	Initialize the event buffer
    //
    InitializeCriticalSection( &(EventBuffer.CriticalSection) );
    InitializeCriticalSection( &(EventBuffer.PeekCriticalSection) );
    EventBuffer.NumberOfEvents	= 0;
    EventBuffer.EventIndex	= 0;
    EventBuffer.BusyFlag	= FALSE;
    EventBuffer.EventBuffer = MALLOC( INITIAL_EVENTS * sizeof(INPUT_RECORD) );

    if ( !EventBuffer.EventBuffer ) {
	return FALSE;
    }

    EventBuffer.MaxEvents = INITIAL_EVENTS;


    //
    //	Get handles to stdin, stdout and stderr
    //
    hInput  = GetStdHandle( STD_INPUT_HANDLE );
    hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    hError  = GetStdHandle( STD_ERROR_HANDLE );


    //
    //	Initialize the screen data for hOutput
    //
    if ( !(OutputScreenData = MakeScreenData( hOutput )) ) {
	return FALSE;
    }


    //
    //	Current screen is hOutput
    //
    ActiveScreenData = OutputScreenData;


    return (Initialized = TRUE);

}





PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    )
/*++

Routine Description:

    Allocates memory for a SCREEN_DATA information and initializes it.

Arguments:

    ScreenHandle    -	Supplies handle of screen.

Return Value:

    POINTER to allocated SCREEN_DATA structure

--*/
{
    PSCREEN_DATA		ScreenData;	//  Pointer to screen data
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.


    //
    //	Allocate space for the screen data.
    //
    if ( !(ScreenData = (PSCREEN_DATA)MALLOC(sizeof(SCREEN_DATA))) ) {
	return NULL;
    }

    //
    //	Allocate space for our copy of the screen buffer.
    //
    GetConsoleScreenBufferInfo( ScreenHandle,
				&ScrInfo );

    ScreenData->MaxBufferSize = ScrInfo.dwSize.Y    *
				ScrInfo.dwSize.X;

    ScreenData->ScreenBuffer = (PCHAR_INFO)MALLOC( ScreenData->MaxBufferSize *
						    sizeof(CHAR_INFO));

    if ( !ScreenData->ScreenBuffer ) {
        FREE( ScreenData );
        return NULL;
    }

    //
    //	Allocate space for the LineInfo array
    //
    ScreenData->LineInfo = (PLINE_INFO)MALLOC( ScrInfo.dwSize.Y * sizeof( LINE_INFO ) );
    if ( !ScreenData->LineInfo ) {
        FREE( ScreenData->ScreenBuffer );
        FREE( ScreenData );
        return NULL;
    }


    //
    //	Memory has been allocated, now initialize the structure
    //
    ScreenData->ScreenHandle = ScreenHandle;

    ScreenData->ScreenInformation.NumberOfRows = ScrInfo.dwSize.Y;
    ScreenData->ScreenInformation.NumberOfCols = ScrInfo.dwSize.X;

    ScreenData->ScreenInformation.CursorRow = ScrInfo.dwCursorPosition.Y;
    ScreenData->ScreenInformation.CursorCol = ScrInfo.dwCursorPosition.X;

    ScreenData->AttributeNew = ScrInfo.wAttributes;
    ScreenData->AttributeOld = 0x00;

    ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow  = 0;

    InitializeCriticalSection( &(ScreenData->CriticalSection) );

    InitLineInfo( ScreenData );

    return ScreenData;
}





BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    )
/*++

Routine Description:

    Initializes the LineInfo array.

Arguments:

    ScreenData	    -	Supplies pointer to screen data.

Return Value:

    TRUE if initialized, false otherwise.

--*/
{

    ROW 	Row;
    COLUMN	Cols;
    PLINE_INFO	LineInfo;
    PCHAR_INFO	CharInfo;


    LineInfo = ScreenData->LineInfo;
    CharInfo = ScreenData->ScreenBuffer;
    Row      = ScreenData->ScreenInformation.NumberOfRows;
    Cols     = ScreenData->ScreenInformation.NumberOfCols;

    while ( Row-- ) {

        ResetLineInfo (LineInfo);

        LineInfo->Line      = CharInfo;

        LineInfo++;
        CharInfo += Cols;

    }

    return TRUE;
}





PSCREEN
consoleNewScreen (
    void
    )
/*++

Routine Description:

    Creates a new screen.

Arguments:

    None.

Return Value:

    Pointer to screen data.

--*/
{
    PSCREEN_DATA		ScreenData;	   //  Screen data
    HANDLE			NewScreenHandle;
    SMALL_RECT			NewSize;
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.
    CONSOLE_CURSOR_INFO 	CursorInfo;

    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if ( !InitializeGlobalState() ) {
	    return NULL;
	}
    }

    //
    //	Create a new screen buffer
    //
    NewScreenHandle = CreateConsoleScreenBuffer(GENERIC_WRITE | GENERIC_READ,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL,
						CONSOLE_TEXTMODE_BUFFER,
						NULL );

    if (NewScreenHandle == INVALID_HANDLE_VALUE) {
	//
	//  No luck
	//
	return NULL;
    }

    //
    //	We want the new window to be the same size as the current one, so
    //	we resize it.
    //
    GetConsoleScreenBufferInfo( ActiveScreenData->ScreenHandle,
				&ScrInfo );

    NewSize.Left    = 0;
    NewSize.Top     = 0;
    NewSize.Right   = ScrInfo.srWindow.Right - ScrInfo.srWindow.Left;
    NewSize.Bottom  = ScrInfo.srWindow.Bottom - ScrInfo.srWindow.Top;

    SetConsoleWindowInfo( NewScreenHandle, TRUE, &NewSize );

    //
    //	Now we create a screen data structure for it.
    //
    if ( !(ScreenData = MakeScreenData(NewScreenHandle)) ) {
	CloseHandle(NewScreenHandle);
	return NULL;
    }


    CursorInfo.bVisible = TRUE;
    ScreenData->CursorSize = CursorInfo.dwSize = 25;

    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
			   &CursorInfo );

    //
    //	We are all set. We return a pointer to the
    //	screen data.
    //
    return (PSCREEN)ScreenData;
}





BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Closes a screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if screen closed.
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    //
    //	We cannot close the active screen
    //
    if ( !ScreenData || (ScreenData == ActiveScreenData) ) {
	return FALSE;
    }

    if (ScreenData->ScreenHandle != INVALID_HANDLE_VALUE) {
	CloseHandle(ScreenData->ScreenHandle);
    }

    FREE( ScreenData->LineInfo );
    FREE( ScreenData->ScreenBuffer );
    FREE( ScreenData );

    return TRUE;
}





PSCREEN
consoleGetCurrentScreen (
    void
    )
/*++

Routine Description:

    Returns the current screen.

Arguments:

    none.

Return Value:

    Pointer to currently active screen data.

--*/
{
    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if (!InitializeGlobalState()) {
	    return NULL;
	}
    }

    return (PSCREEN)ActiveScreenData;
}





BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if the active screen set
    FALSE otherwise.

--*/
{
    BOOL	    ScreenSet	  = TRUE;
    PSCREEN_DATA    CurrentScreen = ActiveScreenData;


    EnterCriticalSection( &(CurrentScreen->CriticalSection) );

    ScreenSet = SetConsoleActiveScreenBuffer( ((PSCREEN_DATA)pScreen)->ScreenHandle);

    if (ScreenSet) {
	ActiveScreenData = (PSCREEN_DATA)pScreen;
    }

    LeaveCriticalSection( &(CurrentScreen->CriticalSection) );

    return ScreenSet;
}





BOOL
consoleGetScreenInformation (
    PSCREEN            pScreen,
    PSCREEN_INFORMATION    pScreenInfo
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen	-   Supplies pointer to screen data.
    pScreenInfo -   Supplies pointer to screen info buffer

Return Value:

    TRUE if the screen info returned
    FALSE otherwise.

--*/
{

    PSCREEN_DATA ScreenData = (PSCREEN_DATA)pScreen;

    if (!ScreenData) {
	return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    memcpy(pScreenInfo, &(ScreenData->ScreenInformation), sizeof(SCREEN_INFORMATION));

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}



BOOL
consoleSetScreenSize (
    PSCREEN pScreen,
    ROW Rows,
    COLUMN  Cols
    )
/*++

Routine Description:

    Sets the screen size

Arguments:

    pScreen	-   Supplies pointer to screen data.
    Rows	-   Number of rows
    Cols	-   Number of columns

Return Value:

    TRUE if screen size changed successfully
    FALSE otherwise.

--*/
{

    PSCREEN_DATA		ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_SCREEN_BUFFER_INFO	ScreenBufferInfo;
    SMALL_RECT			ScreenRect;
    COORD			ScreenSize;
    USHORT			MinRows;
    USHORT			MinCols;
    ULONG			NewBufferSize;
    BOOL			WindowSet   = FALSE;
    BOOL			Status	    = FALSE;

    //
    //	Won't attempt to resize larger than the largest window size
    //
    ScreenSize = GetLargestConsoleWindowSize( ScreenData->ScreenHandle );

    if ( (Rows > (ROW)ScreenSize.Y) || (Cols > (COLUMN)ScreenSize.X) ) {
        return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    //
    //	Obtain the current screen information.
    //
    if ( GetConsoleScreenBufferInfo( ScreenData->ScreenHandle, &ScreenBufferInfo ) ) {

        //
        //  If the desired buffer size is smaller than the current window
        //  size, we have to resize the current window first.
        //
        if ( ( Rows < (ROW)
                   (ScreenBufferInfo.srWindow.Bottom -
                ScreenBufferInfo.srWindow.Top + 1) ) ||
             ( Cols < (COLUMN)
                   (ScreenBufferInfo.srWindow.Right -
                ScreenBufferInfo.srWindow.Left + 1) ) ) {

            //
            //  Set the window to a size that will fit in the current
            //  screen buffer and that is no bigger than the size to
            //  which we want to grow the screen buffer.
            //
            MinRows = (USHORT)min( (int)Rows, (int)(ScreenBufferInfo.dwSize.Y) );
            MinCols = (USHORT)min( (int)Cols, (int)(ScreenBufferInfo.dwSize.X) );

            ScreenRect.Top  = 0;
            ScreenRect.Left = 0;
            ScreenRect.Right    = (SHORT)MinCols - (SHORT)1;
            ScreenRect.Bottom   = (SHORT)MinRows - (SHORT)1;

            WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

            if ( !WindowSet ) {
                //
                //  ERROR
                //
                goto Done;
            }
        }

        //
        //  Set the screen buffer size to the desired size.
        //
        ScreenSize.X = (WORD)Cols;
        ScreenSize.Y = (WORD)Rows;

        if ( !SetConsoleScreenBufferSize( ScreenData->ScreenHandle, ScreenSize ) ) {

            //
            //  ERROR
            //
            //
            //  Return the window to its original size. We ignore the return
            //  code because there is nothing we can do about it.
            //
            SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &(ScreenBufferInfo.srWindow) );
            goto Done;
        }

        //
        //  resize the screen buffer. Note that the contents of the screen
        //  buffer are not valid anymore. Someone else will have to update
        //  them.
        //
        NewBufferSize = Rows * Cols;

        if (ScreenData->MaxBufferSize < NewBufferSize ) {
            void *pv = REALLOC( ScreenData->ScreenBuffer, NewBufferSize * sizeof(CHAR_INFO));
            if (!pv) {
                Status = FALSE;
                goto Done;
            }
            ScreenData->ScreenBuffer = pv;
            ScreenData->MaxBufferSize = NewBufferSize;
            pv = REALLOC( ScreenData->LineInfo, Rows * sizeof( LINE_INFO ) );
            if (!pv) {
                Status = FALSE;
                goto Done;
            }
            ScreenData->LineInfo = pv;
        }

        //
        //  Set the Window Size. We know that we can grow the window to this size
        //  because we tested the size against the largest window size at the
        //  beginning of the function.
        //
        ScreenRect.Top      = 0;
        ScreenRect.Left     = 0;
        ScreenRect.Right    = (SHORT)Cols - (SHORT)1;
        ScreenRect.Bottom   = (SHORT)Rows - (SHORT)1;

        WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

        if ( !WindowSet ) {
            //
            //  We could not resize the window. We will leave the
            //  resized screen buffer.
            //
            //  ERROR
            //
            InitLineInfo( ScreenData );
            goto Done;
        }

        //
        //  Update the screen size
        //
        ScreenData->ScreenInformation.NumberOfRows = Rows;
        ScreenData->ScreenInformation.NumberOfCols = Cols;

        InitLineInfo( ScreenData );

        //
        //  Done
        //
        Status = TRUE;

    } else {

        //
        //  ERROR
        //
        Status = FALSE;
    }

Done:
    //
    //	Invalidate the entire screen buffer
    //
    ScreenData->FirstRow    = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow     = 0;

    LeaveCriticalSection( &(ScreenData->CriticalSection) );
    return Status;

}




BOOL
consoleSetCursor (
    PSCREEN pScreen,
    ROW Row,
    COLUMN  Col
    )
/*++

Routine Description:

    Moves the cursor to a certain position.

Arguments:

    pScreen -	Supplies pointer to screen data
    Row     -	Supplies row coordinate
    Col     -	Supplies column coordinate

Return Value:

    TRUE if moved
    FALSE otherwise.

--*/
{

    PSCREEN_DATA    ScreenData	= (PSCREEN_DATA)pScreen;
    COORD	    Position;
    BOOL	    Moved	= FALSE;


    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if ((Row != ScreenData->ScreenInformation.CursorRow) ||
	(Col != ScreenData->ScreenInformation.CursorCol) ) {

	assert( Row < ScreenData->ScreenInformation.NumberOfRows);
	assert( Col < ScreenData->ScreenInformation.NumberOfCols);

	Position.Y = (SHORT)Row;
	Position.X = (SHORT)Col;

	if ( SetConsoleCursorPosition( ScreenData->ScreenHandle,
				       Position )) {
	    //
	    //	Cursor moved, update the data
	    //
	    ScreenData->ScreenInformation.CursorRow    =   Row;
	    ScreenData->ScreenInformation.CursorCol    =   Col;

	    Moved = TRUE;
	}
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Moved;
}




BOOL
consoleSetCursorStyle (
    PSCREEN pScreen,
    ULONG   Style
    )

/*++

Routine Description7:

    Sets the cursor style. The two available styles are: underscrore and
    box

Arguments:

    Style	-   New cursor style

Return Value:

    True if cursor style set

--*/

{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;

    CursorInfo.bVisible = TRUE;

    if ( Style == CURSOR_STYLE_UNDERSCORE ) {

	CursorInfo.dwSize = 25;

    } else if ( Style == CURSOR_STYLE_BOX ) {

	CursorInfo.dwSize = 100;

    } else {

	return FALSE;

    }

    ScreenData->CursorSize = CursorInfo.dwSize;

    return SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				  &CursorInfo );

}





ULONG
consoleWriteLine (
    PSCREEN     pScreen,
    PVOID       pBuffer,
    ULONG       BufferSize,
    ROW         Row,
    COLUMN      Col,
    ATTRIBUTE   Attribute,
    BOOL        Blank
    )
/*++

Routine Description7:

    Writes a buffer to the screen with the specified attribute and blanks
    to end of row.

Arguments:

    pScreen	-   Supplies pointer to screen data
    pBuffer	-   Supplies pointer to buffer
    BufferSize	-   Supplies the size of the buffer
    Row 	-   Supplies row coordinate
    Col 	-   Supplies column coordinate
    Attr	-   Supplies the attribute
    Blank	-   TRUE if we should blank to end of last row written.

Return Value:

    Number of bytes written

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    PLINE_INFO	    LineInfo;
    PCHAR_INFO	    CharInfo;
    CHAR_INFO	    Char;
    WORD	    Attr;

    char *	    p = (char *)pBuffer;

    COLUMN      ColsLeft;   //  Available columns
    COLUMN      InfoCols;   //  Columns taken from buffer
    COLUMN      BlankCols;  //  Columns to be blanked
    COLUMN	    Column;	    //	Counter;

    //
    //	We will ignore writes outside of the screen buffer
    //
    if ( ( Row >= ScreenData->ScreenInformation.NumberOfRows ) ||
         ( Col >= ScreenData->ScreenInformation.NumberOfCols ) ) {
        return TRUE;
    }

    //
    //	Ignore trivial writes
    //
    if (BufferSize == 0 && !Blank) {
        return TRUE;
    }


    EnterCriticalSection( &(ScreenData->CriticalSection) );


    //
    //	We will truncate writes that are too long
    //
    if ( (Col + BufferSize) >= ScreenData->ScreenInformation.NumberOfCols ) {
        BufferSize = ScreenData->ScreenInformation.NumberOfCols - Col;
    }

    LineInfo = ScreenData->LineInfo + Row;
    CharInfo = LineInfo->Line + Col;

    ColsLeft  = ScreenData->ScreenInformation.NumberOfCols - Col;
    InfoCols  = min( BufferSize, ColsLeft );
    BlankCols = Blank ? (ColsLeft - InfoCols) : 0;

    //
    //	Set the attribute
    //
    if ( Attribute != ScreenData->AttributeOld ) {
        ScreenData->AttributeOld  = Attribute;
        ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }
    Attr = ScreenData->AttributeNew;

    //
    //	set up default attribute
    //
    Char.Attributes = Attr;

    //
    //	set up number of columns to draw
    //
    Column = InfoCols;

    //
    //	draw chars in all specified columns
    //
    while ( Column-- ) {

        //
        //  use character from input string
        //
        Char.Char.AsciiChar = *p++;

        //
        //  update change portions of line info
        //
        if (LineInfo->Garbage ||
            CharInfo->Attributes != Char.Attributes ||
            CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

            LineInfo->colMinChanged = min (LineInfo->colMinChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->Dirty = TRUE;
	    }

        //
        //  set up new character
        //
        *CharInfo++ = Char;
    }


    //
    //	Blank to end of line
    //
    Char.Attributes     = Attr;
    Char.Char.AsciiChar = ' ';
    Column              = BlankCols;

    while ( Column-- ) {

        //
        //  update change portions of line info
        //
        if (LineInfo->Garbage ||
            CharInfo->Attributes != Char.Attributes ||
            CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

            LineInfo->colMinChanged = min (LineInfo->colMinChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->Dirty = TRUE;
        }

        *CharInfo++ = Char;
    }


    //
    //	Update row information
    //
    if ( Row < ScreenData->FirstRow ) {
        ScreenData->FirstRow = Row;
    }
    if ( Row > ScreenData->LastRow ) {
        ScreenData->LastRow = Row;
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return (ULONG)(InfoCols + BlankCols);
}





BOOL
consoleShowScreen (
    PSCREEN     pScreen
    )
/*++

Routine Description:

    Moves data from our screen buffer to the console screen buffer.

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if done
    FALSE otherwise

--*/
{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;
    PLINE_INFO		LineInfo;
    BOOL		Shown	   = FALSE;
    ROW 		FirstRow;
    ROW 		LastRow;
    COLUMN		LastCol;

    COORD		Position;
    COORD		Size;
    SMALL_RECT		Rectangle;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if ( ScreenData->FirstRow <= ScreenData->LastRow ) {

	Size.X = (SHORT)(ScreenData->ScreenInformation.NumberOfCols);
	Size.Y = (SHORT)(ScreenData->ScreenInformation.NumberOfRows);

	FirstRow = ScreenData->FirstRow;
	LineInfo = ScreenData->LineInfo + FirstRow;

	LastCol  = ScreenData->ScreenInformation.NumberOfCols-1;

	//
	//  Find next dirty block
	//
	while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
	    FirstRow++;
	    LineInfo++;
	}

	while ( FirstRow <= ScreenData->LastRow ) {

	    int colLeft, colRight;

	    //
	    //	Get the block
	    //

	    LastRow  = FirstRow;

	    //
	    //	set up for left/right boundary accrual
	    //

	    colLeft = LastCol + 1;
	    colRight = -1;

	    while ( (LastRow <= ScreenData->LastRow) && LineInfo->Dirty ) {

		//
		//  accrue smallest bounding right/left margins
		//

		colLeft = min (colLeft, LineInfo->colMinChanged);
		colRight = max (colRight, LineInfo->colMaxChanged);

		//
		//  reset line information
		//

		ResetLineInfo (LineInfo);

		//
		//  advance to next row
		//

		LastRow++;
		LineInfo++;
	    }
	    LastRow--;


	    //
	    //	Write the block
	    //
	    assert( FirstRow <= LastRow );

	    Position.X = (SHORT)colLeft;
	    Position.Y = (SHORT)FirstRow;

	    Rectangle.Top    = (SHORT)FirstRow;
	    Rectangle.Bottom = (SHORT)LastRow;
	    Rectangle.Left = (SHORT) colLeft;
	    Rectangle.Right = (SHORT) colRight;

	    //
	    //	Performance hack: making the cursor invisible speeds
	    //	screen updates.
	    //
	    CursorInfo.bVisible = FALSE;
	    CursorInfo.dwSize	= ScreenData->CursorSize;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    Shown = WriteConsoleOutput( ScreenData->ScreenHandle,
					ScreenData->ScreenBuffer,
					Size,
					Position,
					&Rectangle );

#if defined (DEBUG)
	    if ( !Shown ) {
		char DbgB[128];
		sprintf(DbgB, "MEP: WriteConsoleOutput Error %d\n", GetLastError() );
		OutputDebugString( DbgB );
	    }
#endif
	    assert( Shown );

	    CursorInfo.bVisible = TRUE;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    FirstRow = LastRow + 1;

	    //
	    //	Find next dirty block
	    //
	    while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
		FirstRow++;
		LineInfo++;
	    }
	}

	ScreenData->LastRow  = 0;
	ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;

    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Shown;

}





BOOL
consoleClearScreen (
    PSCREEN     pScreen,
    BOOL        ShowScreen
    )
/*++

Routine Description:

	Clears the screen

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if screen cleared
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    ROW 	    Rows;
    BOOL	    Status = TRUE;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    Rows = ScreenData->ScreenInformation.NumberOfRows;

    while ( Rows-- ) {
	consoleWriteLine( pScreen, NULL, 0, Rows, 0, ScreenData->AttributeOld, TRUE );
    }

    if (ShowScreen) {
	Status = consoleShowScreen( pScreen );
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Status;
}



BOOL
consoleScrollVert (
    PSCREEN      pScreen,
    ROW          Top,
    COLUMN       Left,
    ROW          Bottom,
    COLUMN       Right,
    INT          Rows
    )
/*++

Routine Description:

    Scrolls

Arguments:

    pScreen     -   Supplies pointer to screen data
    Top         -   Supplies top row
    Left        -   Supplies left column
    Bottom      -   Supplies bottom row
    Right       -   Supplies right column
    Rows        -   Number of rows to scroll

Return Value:

    TRUE if scrolled
    FALSE otherwise

--*/

{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    SMALL_RECT      Rect;
    COORD           Coord;
    CHAR_INFO       CharInfo;
    BOOLEAN         Ok = TRUE;
    PLINE_INFO      LineInfo;
    ROW             R;

    if ( Rows ) {

        EnterCriticalSection( &(ScreenData->CriticalSection) );

        //
        //  If there is something to flush, we flush it now
        //
        if ( ScreenData->FirstRow <= ScreenData->LastRow ) {
            consoleShowScreen( pScreen );
        }


        //
        //  Scroll
        //
    Coord.X = (SHORT)Left;
	Coord.Y = (SHORT)Top;

	Rect.Left   = (SHORT)Left;
	Rect.Top    = (SHORT)Top;
	Rect.Right  = (SHORT)Right;
	Rect.Bottom = (SHORT)Bottom;

        if ( Rows > 0 ) {

            Rect.Top    += (short)Rows;

        } else {

            Rect.Bottom += (short)Rows;
            Coord.Y     -= (short)Rows;
        }


        CharInfo.Char.AsciiChar  = ' ';
        CharInfo.Attributes = ScreenData->AttributeNew;

        Ok = ScrollConsoleScreenBuffer(
                ScreenData->ScreenHandle,
                &Rect,
                NULL,
                Coord,
                &CharInfo
                ) != FALSE;

        //
        //  Mark all the lines in our buffer as containing garbage
        //
        LineInfo = ScreenData->LineInfo + Top;
        R        = Bottom - Top + 1;

        while ( R-- ) {
            LineInfo->Garbage = TRUE;
            LineInfo++;
        }

        LeaveCriticalSection( &(ScreenData->CriticalSection) );
    }

    return Ok;
}






BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    )
/*++

Routine Description:

    Sets the console attribute

Arguments:

    pScreen	-   Supplies pointer to screen data
    Attribute	-   Supplies the attribute

Return Value:

    TRUE if Attribute set
    FALSE otherwise

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if (Attribute != ScreenData->AttributeOld) {
	ScreenData->AttributeOld = Attribute;
	ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}









BOOL
consoleFlushInput (
    void
    )
/*++

Routine Description:

    Flushes input events.

Arguments:

    None.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    EventBuffer.NumberOfEvents = 0;

    return FlushConsoleInputBuffer( hInput );
}







BOOL
consoleGetMode (
    PKBDMODE pMode
    )
/*++

Routine Description:

    Get current console mode.

Arguments:

    pMode   -	Supplies a pointer to the mode flag variable

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    return GetConsoleMode( hInput,
			   pMode );
}






BOOL
consoleSetMode (
    KBDMODE Mode
    )
/*++

Routine Description:

    Sets the console mode.

Arguments:

    Mode    -	Supplies the mode flags.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    return SetConsoleMode( hInput,
			   Mode );
}


BOOL
consoleIsKeyAvailable (
    void
    )
/*++

Routine Description:

    Returns TRUE if a key is available in the event buffer.

Arguments:

    None.

Return Value:

    TRUE if a key is available in the event buffer
    FALSE otherwise

--*/

{
    BOOL	    IsKey = FALSE;
    PINPUT_RECORD   pEvent;
    DWORD	    Index;

    EnterCriticalSection( &(EventBuffer.CriticalSection) );

    for ( Index = EventBuffer.EventIndex; Index < EventBuffer.NumberOfEvents; Index++ ) {

	pEvent = EventBuffer.EventBuffer + EventBuffer.EventIndex;

	if ( ((EVENT_TYPE(pEvent)) == KEY_EVENT) &&
	     (PKEY_EVT(pEvent))->bKeyDown ) {
	    IsKey = TRUE;
	    break;
	}
    }

    LeaveCriticalSection( &(EventBuffer.CriticalSection) );

    return IsKey;
}




BOOL
consoleDoWindow (
    void
    )

/*++

Routine Description:

    Responds to a window event

Arguments:

    None.

Return Value:

    TRUE if window changed
    FALSE otherwise

--*/

{

    PINPUT_RECORD   pEvent;

    pEvent = NextEvent( NOADVANCE, NOWAIT );

    if (( EVENT_TYPE(pEvent) ) == WINDOW_BUFFER_SIZE_EVENT) {

	pEvent = NextEvent( ADVANCE, WAIT );
	WindowEvent(PWINDOW_EVT(pEvent));
    }

    return FALSE;

}





BOOL
consolePeekKey (
    PKBDKEY Key
    )

/*++

Routine Description:

    Gets the next key from the input buffer if the buffer is not empty.


Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/

{

    PINPUT_RECORD   pEvent;
    BOOL	    Done    = FALSE;
    BOOL	    IsKey   = FALSE;

    EnterCriticalSection(&(EventBuffer.PeekCriticalSection));

    do {

	pEvent = NextEvent( NOADVANCE, NOWAIT );

	if ( pEvent ) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)){
		    IsKey = TRUE;
		    Done  = TRUE;
		}
		break;

	    case MOUSE_EVENT:
		Done = TRUE;
		break;


	    case WINDOW_BUFFER_SIZE_EVENT:
		Done = TRUE;
		break;

        case MENU_EVENT:
        case FOCUS_EVENT:
        Done = TRUE;
        break;

	    default:
		assert( FALSE );
		break;
	    }

	    if ( !Done ) {
		NextEvent( ADVANCE, NOWAIT );
	    }

	} else {
	    Done = TRUE;
	}

    } while ( !Done );

    LeaveCriticalSection(&(EventBuffer.PeekCriticalSection));

    return IsKey;

}






BOOL
consoleGetKey (
    PKBDKEY        Key,
     BOOL           fWait
    )
/*++

Routine Description:

    Gets the next key from  the input buffer.

Arguments:

    Key     -	Supplies a pointer to a key structure
    fWait   -	Supplies a flag:
		if TRUE, the function blocks until a key is ready.
		if FALSE, the function returns immediately.

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/
{

    PINPUT_RECORD   pEvent;

    do {
	pEvent = NextEvent( ADVANCE, fWait );

	if (pEvent) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)) {
		    return TRUE;
		}
		break;

	    case MOUSE_EVENT:
		MouseEvent(PMOUSE_EVT(pEvent));
		break;

	    case WINDOW_BUFFER_SIZE_EVENT:
		WindowEvent(PWINDOW_EVT(pEvent));
		break;

        case MENU_EVENT:
        MenuEvent(PMENU_EVT(pEvent));
        break;

        case FOCUS_EVENT:
        FocusEvent(PFOCUS_EVT(pEvent));
        break;

	    default:
		break;
	    }
	}
    } while (fWait);

    return FALSE;
}


BOOL
consolePutKey (
    PKBDKEY     Key
    )
/*++

Routine Description:

    Puts a key in the console's input buffer

Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;

    InputRecord.EventType   =	KEY_EVENT;

    InputRecord.Event.KeyEvent.bKeyDown 	  =   FALSE;
    InputRecord.Event.KeyEvent.wRepeatCount	  =   0;
    InputRecord.Event.KeyEvent.wVirtualKeyCode	  =   Key->Scancode;
    InputRecord.Event.KeyEvent.wVirtualScanCode   =   0;
    InputRecord.Event.KeyEvent.uChar.UnicodeChar  =   Key->Unicode;
    InputRecord.Event.KeyEvent.dwControlKeyState  =   Key->Flags;

    if ( PutEvent( &InputRecord )) {
	InputRecord.Event.KeyEvent.bKeyDown	  =   TRUE;
	return PutEvent( &InputRecord );
    }
    return FALSE;
}


BOOL
consolePutMouse(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Puts a mose event in the console's input buffer

Arguments:

    Row 	-   Supplies the row
    Col 	-   Supplies the column
    MouseFlags	-   Supplies the flags

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;
    COORD	    Position;
    DWORD	    Flags;

    InputRecord.EventType   =	MOUSE_EVENT;

    Position.Y = (WORD)(Row - 1);
    Position.X = (WORD)(Col - 1);

    Flags = 0;

    if ( MouseFlags & MOUSE_CLICK_LEFT ) {
	Flags |= FROM_LEFT_1ST_BUTTON_PRESSED;
    }
    if ( MouseFlags & MOUSE_CLICK_RIGHT ) {
	Flags |= RIGHTMOST_BUTTON_PRESSED;
    }
    if ( MouseFlags & MOUSE_DOUBLE_CLICK ) {
	Flags |= DOUBLE_CLICK;
    }

    InputRecord.Event.MouseEvent.dwMousePosition    =	Position;
    InputRecord.Event.MouseEvent.dwButtonState	    =	Flags;
    InputRecord.Event.MouseEvent.dwControlKeyState  =	0;
    InputRecord.Event.MouseEvent.dwEventFlags	    =	0;

    return PutEvent( &InputRecord );
}



BOOL
consoleIsBusyReadingKeyboard (
    )
/*++

Routine Description:

    Determines if the console is busy reading the keyboard

Arguments:

    None

Return Value:

    TRUE if console is busy reading the keyboard.

--*/
{
    BOOL    Busy;

    EnterCriticalSection(&(EventBuffer.CriticalSection));
    Busy = EventBuffer.BusyFlag;
    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return Busy;
}



BOOL
consoleEnterCancelEvent (
    )
{

    INPUT_RECORD    Record;
    DWORD           dw;

    Record.EventType = KEY_EVENT;
    Record.Event.KeyEvent.bKeyDown            = TRUE;
    Record.Event.KeyEvent.wRepeatCount	      = 0;
    Record.Event.KeyEvent.wVirtualKeyCode     = VK_CANCEL;
    Record.Event.KeyEvent.wVirtualScanCode    = 0;
    Record.Event.KeyEvent.uChar.AsciiChar     = 0;
    Record.Event.KeyEvent.dwControlKeyState   = 0;

    PutEvent( &Record );

    Record.Event.KeyEvent.bKeyDown = TRUE;
    WriteConsoleInput( hInput, &Record, 1, &dw );

    return TRUE;
}


PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    )
/*++

Routine Description:

    Returns pointer to next event record.

Arguments:

    fAdvance	-   Supplies a flag:
		    if TRUE: Advance to next event record
		    if FALSE: Do not advance to next event record

    fWait	-   Supplies a flag:
		    if TRUE, the  blocks until an event is ready.
		    if FALSE, return immediately.

Return Value:

    Pointer to event record, or NULL.

--*/
{
    PINPUT_RECORD  pEvent;
    BOOL Success;

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If the busy flag is set, then the buffer is in the process of
    //	being read. Only one thread should want to wait, so it is
    //	safe to simply return.
    //
    if ( EventBuffer.BusyFlag ) {
    	assert( !fWait );
	    LeaveCriticalSection(&(EventBuffer.CriticalSection));
    	return NULL;
    }

    if (EventBuffer.NumberOfEvents == 0) {

	//
	//  No events in buffer, read as many as we can
	//
	DWORD NumberOfEvents;

	//
	//  If the buffer is too big, resize it
	//
	if ( EventBuffer.MaxEvents > MAX_EVENTS ) {
        PVOID pv = REALLOC( EventBuffer.EventBuffer,
					       MAX_EVENTS * sizeof( INPUT_RECORD ) );
        if (!pv) {
            LeaveCriticalSection(&(EventBuffer.CriticalSection));
            return NULL;
        }
	    EventBuffer.EventBuffer = pv;

	    EventBuffer.MaxEvents = MAX_EVENTS;
	    assert( EventBuffer.EventBuffer );
	    CleanExit( 1, 0 );
	}

	Success = PeekConsoleInput( hInput,
				    EventBuffer.EventBuffer,
				    EventBuffer.MaxEvents,
				    &NumberOfEvents);

	if ((!Success || (NumberOfEvents == 0)) && (!fWait)) {
	    //
	    //	No events available and don't want to wait,
	    //	return.
	    //
	    LeaveCriticalSection(&(EventBuffer.CriticalSection));
	    return NULL;
	}

	//
	//  Since we will block, we have to leave the critical section.
	//  We set the Busy flag to indicate that the buffer is being
	//  read.
	//
	EventBuffer.BusyFlag = TRUE;
	LeaveCriticalSection(&(EventBuffer.CriticalSection));

	Success = ReadConsoleInput (hInput,
				    EventBuffer.EventBuffer,
				    EventBuffer.MaxEvents,
				    &EventBuffer.NumberOfEvents);

	EnterCriticalSection(&(EventBuffer.CriticalSection));

	EventBuffer.BusyFlag = FALSE;

	if (!Success) {
#if defined( DEBUG )
	    OutputDebugString(" Error: Cannot read console events\n");
	    assert( Success );
#endif
	    EventBuffer.NumberOfEvents = 0;
	}
	EventBuffer.EventIndex = 0;
    }

    pEvent = EventBuffer.EventBuffer + EventBuffer.EventIndex;

    //
    //	If Advance flag is set, we advance the pointer to the next
    //	record.
    //
    if (fAdvance) {
	if (--(EventBuffer.NumberOfEvents)) {

	    switch (EVENT_TYPE(pEvent)) {

	    case KEY_EVENT:
	    case MOUSE_EVENT:
        case WINDOW_BUFFER_SIZE_EVENT:
        case MENU_EVENT:
        case FOCUS_EVENT:
		(EventBuffer.EventIndex)++;
		break;

	    default:
#if defined( DEBUG)
		sprintf(DbgBuffer, "WARNING: unknown event type %X\n", EVENT_TYPE(pEvent));
		OutputDebugString(DbgBuffer);
#endif
		(EventBuffer.EventIndex)++;
		break;
	    }
	}
    }


    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return pEvent;
}





void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes mouse events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None..

--*/
{
    static  BOOL    Pressed = FALSE;
	    DWORD   MouseFlags;

    //
    //	We only know left and right mouse buttons
    //
    pEvent->dwButtonState &= ( FROM_LEFT_1ST_BUTTON_PRESSED | RIGHTMOST_BUTTON_PRESSED );

    //
    //  Let the editor handle the mouse event
    //
    MouseFlags = 0x00;
    if ( pEvent->dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED ) {
        MouseFlags |=  MOUSE_CLICK_LEFT;
    }
    if ( pEvent->dwButtonState & RIGHTMOST_BUTTON_PRESSED ) {
        MouseFlags |=  MOUSE_CLICK_RIGHT;
    }
    if ( pEvent->dwEventFlags & DOUBLE_CLICK ) {
        MouseFlags |=  MOUSE_DOUBLE_CLICK;
    }

    DoMouse( pEvent->dwMousePosition.Y+1,
        pEvent->dwMousePosition.X+1,
        MouseFlags );

    Pressed = (BOOL)pEvent->dwButtonState;
}





BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    )
/*++

Routine Description:

    Processes window size change events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{

    ROW     Rows;
    COLUMN  Cols;
    ULONG   NewBufferSize;
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.

    UNREFERENCED_PARAMETER( pEvent );

    GetConsoleScreenBufferInfo( ActiveScreenData->ScreenHandle,
				&ScrInfo );

    Rows = ScrInfo.dwSize.Y;
    Cols = ScrInfo.dwSize.X;

    if ( Rows > ActiveScreenData->ScreenInformation.NumberOfRows ||
	 Cols > ActiveScreenData->ScreenInformation.NumberOfCols ) {

	//
	//  resize the screen buffer. Note that the contents of the screen
	//  buffer are not valid anymore. Someone else will have to update
	//  them.
	//
	NewBufferSize = Rows * Cols;

	if (ActiveScreenData->MaxBufferSize < NewBufferSize ) {
        PVOID pv = REALLOC( ActiveScreenData->ScreenBuffer, NewBufferSize * sizeof(CHAR_INFO));
        if (!pv) {
            return FALSE;
        } 
	    ActiveScreenData->ScreenBuffer = pv;
	    ActiveScreenData->MaxBufferSize = NewBufferSize;
        pv = REALLOC( ActiveScreenData->LineInfo, Rows * sizeof( LINE_INFO ) );
        if (!pv) {
            return FALSE;
        }
	    ActiveScreenData->LineInfo = pv;
	}

	//
	//  Set the size
	//
	ActiveScreenData->ScreenInformation.NumberOfRows = Rows;
	ActiveScreenData->ScreenInformation.NumberOfCols = Cols;

	ActiveScreenData->FirstRow = ActiveScreenData->ScreenInformation.NumberOfRows;
	ActiveScreenData->LastRow  = 0;

	InitLineInfo( ActiveScreenData );

	//
	//  Let the editor respond the the event
	//
	WindowChange( Rows, Cols );
	return TRUE;
    }

    return FALSE;
}


BOOL
MenuEvent (
    PMENU_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes menu events

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER( pEvent );
    return TRUE;
}

BOOL
FocusEvent (
    PFOCUS_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes focus events

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER( pEvent );
    return TRUE;

}


BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    )
/*++

Routine Description:

    Processes key events.

Arguments:

    pEvent  -	Supplies pointer to event record
    pKey    -	Supplies pointer to key structure to fill out.

Return Value:

    TRUE if key structured filled out, FALSE otherwise.

--*/
{
    // static BOOL AltPressed = FALSE;

    if (pEvent->bKeyDown) {

	WORD  Scan = pEvent->wVirtualKeyCode;

	//
	//  Pressing the ALT key generates an event, but we filter this
	//  out.
	//
    //if (Scan == VK_MENU) {
    //    return FALSE;
    //}
    if ( Scan == VK_MENU && pEvent->uChar.UnicodeChar == 0 ) {
        return FALSE;
    }

	if (Scan != VK_NUMLOCK &&   // NumLock
	    Scan != VK_CAPITAL &&   // Caps Lock
	    Scan != VK_SHIFT   &&   // Shift
	    Scan != VK_CONTROL ) {  // Ctrl

	    pKey->Unicode   = pEvent->uChar.UnicodeChar;
	    pKey->Scancode  = pEvent->wVirtualKeyCode;
	    pKey->Flags     = pEvent->dwControlKeyState;

//#if defined (DEBUG)
//   sprintf(DbgBuffer, "  KEY: Scan %d Unicode %x\n", pKey->Scancode, pKey->Unicode );
//   OutputDebugString(DbgBuffer);
//#endif
	    return TRUE;

	} else {

	    return FALSE;

	}

    } else {

	return FALSE;

    }
}


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    )
{

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If no space at beginning of buffer, resize and shift right
    //
    if ( EventBuffer.EventIndex == 0 ) {
        PVOID pv = REALLOC( EventBuffer.EventBuffer,
					   (EventBuffer.MaxEvents + EVENT_INCREMENT) * sizeof(INPUT_RECORD));
        if (!pv) {
            CleanExit(1,0);
        }

    	EventBuffer.EventBuffer = pv;

	    memmove( EventBuffer.EventBuffer + EVENT_INCREMENT,
		     EventBuffer.EventBuffer ,
    		 EventBuffer.NumberOfEvents * sizeof(INPUT_RECORD) );

	    EventBuffer.EventIndex = EVENT_INCREMENT;
    }

    //
    //	Add event
    //
    EventBuffer.EventIndex--;
    EventBuffer.NumberOfEvents++;

    memcpy( EventBuffer.EventBuffer + EventBuffer.EventIndex,
	    InputRecord,
	    sizeof(INPUT_RECORD ));

    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\cursor.c ===
/*** cursor.c -  cursor movement functions
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"
#include "keys.h"

void
GetTextCursor (
    COL  *px,
    LINE *py
    ) {
    *px = XCUR(pInsCur);
    *py = YCUR(pInsCur);
}


/*** docursor/cursorfl - Move cursor to new location, adjust windows as needed
*
* Purpose:
*
*   This moves the cursor to a new file position in the current file.
*   If this position is not visible, the current window is readjusted.
*   The rules for vertical adjustment are:
*
*	If the new location is within 'vscroll' lines of the current
*	window, scroll by vscroll lines in the appropriate direction.
*
*	If the new location is further away, adjust the window so that
*	the new location is 'hike' lines from the top.
*
*   The rules for horizontal adjustment is:
*
*	If the new location is within 'hscroll' lines of the current
*	window, scroll by hscroll lines in the appropriate direction
*
*	If the new location is further away, adjust the window so that
*	the new location is 'hscroll' lines from the edge that's in
*	the direction we moved.
*
*   cursorfl is the same as docursor, but takes an fl instead.
*
*   if realtabs is on, cursor is snapped to right hand column of underlying
*   tab characters.
*
* Input:
*  x		- new file column   (docursor only)
*  y		- new file line     (docursor only)
*  fl		- new file position (cursorfl only)
*
* Globals:
*  pWinCur	- Window and
*  pInsCur	-	     file to operate in.
*
* Output:
*   Returns nothing
*
*************************************************************************/
void
docursor (
    COL  x,
    LINE y
    ) {

    fl  fl;

    fl.col = x;
    fl.lin = y;
    cursorfl(fl);
}


void
cursorfl (
    fl  flParam
    ) {
    fl	flNew;			/* New cursor position, window relative */
    fl	flWin;			/* Window position after adjustments	*/
    sl	slScroll;		/* h & vscroll, scaled to window size	*/
    linebuf	L_buf;

    flParam.col = max( 0, flParam.col );
	flParam.lin = lmax( (LINE)0, flParam.lin );

	/*
     * if real tabs are on, snap to right of any tab we might be over
     */
    if (fRealTabs && fTabAlign) {
        GetLine (flParam.lin, L_buf, pFileHead);
        if (flParam.col < cbLog(L_buf)) {
            flParam.col = AlignChar (flParam.col, L_buf);
        }
    }

    slScroll.col = XSCALE (hscroll);
    slScroll.lin = YSCALE (vscroll);

    flWin = pInsCur->flWindow;

    /* Check for horizontal window adjustments                      */

    flNew.col = flParam.col - flWin.col;
    if (flNew.col < 0) {            /* We went off the left edge    */
        flWin.col -= slScroll.col;
        if (flNew.col < -slScroll.col) { /* One hscroll wont do it    */
            flWin.col += flNew.col + 1;
        }
    } else if (flNew.col >= WINXSIZE(pWinCur)) {   /* off the right edge   */
        flWin.col += slScroll.col;
        if (flNew.col >= WINXSIZE(pWinCur) + slScroll.col) {  /* ...more than hscroll */
            flWin.col += flNew.col - WINXSIZE(pWinCur);
        }
    }

    /* Check for vertical window adjustments                        */

	flNew.lin = flParam.lin - flWin.lin;					/* Too far off, use hike		*/

	if (flNew.lin < -slScroll.lin || flNew.lin >= WINYSIZE(pWinCur) + slScroll.lin) {

        flWin.lin = flParam.lin - YSCALE(hike);
    } else if (flNew.lin < 0) {                      /* Off the top                  */
        flWin.lin -= slScroll.lin;
    } else if (flNew.lin >= WINYSIZE(pWinCur)) {     /* Off the bottom               */
        flWin.lin += slScroll.lin;
    }

    flWin.col = max (0, flWin.col);         /* Can't move window beyond 0   */
    flWin.lin = lmax ((LINE)0, flWin.lin);

    doscreen (flWin.col, flWin.lin, flParam.col, flParam.lin);
}

/*** doscreen - update screen window and cursor locations
*
* Purpose:
*  Performs reasonable bounds checking on the input parameters, and sets the
*  window position and cursor location to values which are legal
*  approximiations for out of range values.
*
* Input:
*  wx,wy	= Proposed new window position (top left corner of screen)
*  cx,cy	= Proposed new cursor position
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
doscreen(
    REGISTER COL  wx,
    REGISTER LINE wy,
    COL  cx,
    LINE cy
    ) {

    COL dx;
    LINE dy, yOld;
    LINE First, Last;

    /*
     * limit window x position to somewhere near our max line length
     * limit window y position to last line of the file (only if we know the
     * length)
     */
    wx =  max( 0, min( wx, (COL)sizeof(linebuf)-(WINXSIZE(pWinCur) - XSCALE (hscroll))));
    wy = lmax( (LINE)0, TESTFLAG (pFileHead->flags, REAL) ? lmin( wy, pFileHead->cLines - 1 ) : wy );

    /*
     * dx,dy is window movement delta, if a change, save it.
     */
    dx = wx - XWIN(pInsCur);
    dy = wy - YWIN(pInsCur);

    if ( dx || dy ) {
        saveflip ();


        if ( dy > 0 ) {

            First = YWIN(pInsCur) + WINYSIZE(pWinCur);
            Last  = YWIN(pInsCur) + WINYSIZE(pWinCur) + dy;

        } else {

            First = YWIN(pInsCur) + dy;
            Last  = YWIN(pInsCur);
        }
    }

    XCUR(pInsCur) =  min (max( wx, min( cx, wx+WINXSIZE(pWinCur)-1 ) ), sizeof(linebuf)-2);
    yOld = YCUR(pInsCur);
    YCUR(pInsCur) = lmax( wy, lmin( cy, wy+WINYSIZE(pWinCur)-1 ) );
    AckMove (yOld, YCUR(pInsCur));
    XWIN(pInsCur) = wx;
    YWIN(pInsCur) = wy;

    if ( dx || dy ) {
        SETFLAG (fDisplay, RSTATUS);

	//  If we're not in a macro and it makes sense to scroll quickly
	//  do it

	if ( !mtest () && dy  && !fInSelection &&
            (Last < pFileHead->cLines-1) && (abs(dy) < WINYSIZE(pWinCur)) ) {


	    consoleSetAttribute( MepScreen, fgColor );
	    consoleScrollVert( MepScreen, WINYPOS(pWinCur), WINXPOS(pWinCur),
			       WINYPOS(pWinCur)+WINYSIZE(pWinCur)-1,
			       WINXPOS(pWinCur)+WINXSIZE(pWinCur)-1, dy  );

	    //	We've scrolled the window.  However, the update state in
	    //	fChange[] is out of date.  We need to scroll it in parallel
	    //	However, since the fChange array is for the SCREEN and not
	    //	for the window, we can't simply SCROLL it.  Perhaps, one day,
	    //	we can make it per-window but for now, we just force
	    //	a synchronous update which can be ugly in a macro.

            redraw( pFileHead, First, Last);
	    DoDisplay ();

        } else {
            newwindow ();
        }
    }
    SETFLAG (fDisplay, RCURSOR);
}


/*** dobol - returns column position of first non-blank character
*
* Input:
*  none
*
* Global:
*  pInsCur	- Current instance
*  pFileHead	- Current file
*
* Output:
*  Returns column of first non-blank character
*
*************************************************************************/
int
dobol (
    void
    ) {

    REGISTER char *p = buf;

    GetLine (YCUR(pInsCur), p, pFileHead);
    return colPhys (p, (whiteskip (p)));
}

int
doeol (
    void
    ) {
    return LineLength (YCUR(pInsCur), pFileHead);
}


/*** doftab - tab function
*
*  Moves the cursor ahead one tab stop. If realtabs and tab align are on,
*  moves to first tab stop off of the current character.
*
* Input:
*  col	    = current column
*
* Output:
*  Returns new column
*
*************************************************************************/
int
doftab (
    int     col
    ) 
{
    REGISTER int newcol;

    if (tabstops) {
        newcol = col + tabstops - (col%tabstops);

        if (fRealTabs && fTabAlign) {
            linebuf L_buf;

            GetLine (YCUR(pInsCur), L_buf, pFileHead);
            while (col >= AlignChar(newcol,L_buf))
            newcol += tabstops;
	}
        return newcol;
    } else {
        return col;
    }
}


int
dobtab (
    REGISTER int col
    ) {
    return col - (tabstops ? (1 + (col-1)%tabstops) : 0);
}


flagType
left (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    int x = XCUR(pInsCur);

    docursor(fMeta ? XWIN(pInsCur) :  XCUR(pInsCur)-1, YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg;
}



flagType
right (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    linebuf  L_buf;

    if (fMeta) {
	docursor (XWIN(pInsCur)+WINXSIZE(pWinCur)-1, YCUR(pInsCur));
    } else if (fRealTabs && fTabAlign) {
	GetLine (YCUR(pInsCur), L_buf, pFileHead);
	docursor(colPhys(L_buf, pLog(L_buf,XCUR(pInsCur),FALSE)+1), YCUR(pInsCur));
    } else {
        docursor (XCUR(pInsCur)+1, YCUR(pInsCur));
    }
    return (flagType)(XCUR(pInsCur) < LineLength (YCUR(pInsCur), pFileHead));

    argData; pArg;
}



flagType
up (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {


    LINE	    y = YCUR(pInsCur);
    LINE	    LinesUp = 1;
    KBDKEY	    Key;
    EDITOR_KEY	    KeyInfo;

    //
    //	Check if there are more up keys and add them up.
    //	Do this only if NOT in a macro
    //

    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x110)
		LinesUp++;
	    else
	    if (KeyInfo.KeyCode == 0x111 && LinesUp > 0)
		LinesUp--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }

    while ( LinesUp-- )
	docursor (XCUR(pInsCur), fMeta ? YWIN(pInsCur) : YCUR(pInsCur)-1 );

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg;
}



flagType
down (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
	) {

    LINE	    y = YCUR(pInsCur);
    LINE	    LinesDown = 1;
    KBDKEY	    Key;
    EDITOR_KEY	    KeyInfo;

    //
    //	Check if there are more up keys and add them up.
    //	Do this only if NOT in a macro
    //
    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x111)
		LinesDown++;
	    else
	    if (KeyInfo.KeyCode == 0x110 && LinesDown > 0)
		LinesDown--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }

    while ( LinesDown--)
	docursor (XCUR(pInsCur), fMeta ? YWIN(pInsCur)+WINYSIZE(pWinCur)-1 : YCUR(pInsCur)+1);

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg;
}



flagType
begline (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor (fMeta ? 0 : dobol(), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg;
}



flagType
endline (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor (fMeta ? WINXSIZE(pWinCur) : doeol(), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg;
}



flagType
home (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    fl	flBefore;

    flBefore = pInsCur->flCursorCur;

    if (fMeta) {
	docursor (XWIN(pInsCur)+WINXSIZE(pWinCur)-1,
		  YWIN(pInsCur)+WINYSIZE(pWinCur)-1 );
    } else {
        cursorfl (pInsCur->flWindow);
    }
    return (flagType)((flBefore.col != XCUR(pInsCur)) || (flBefore.lin != YCUR(pInsCur)));
    argData; pArg;  fMeta;
}



flagType
tab (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor( doftab( XCUR(pInsCur)), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg; fMeta;
}



flagType
backtab (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor (dobtab (XCUR(pInsCur)), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg; fMeta;
}



flagType
fIsBlank (
    PFILE pFile,
    LINE line
    ) {
    linebuf L_buf;

    return (flagType)(gettextline (TRUE, line, L_buf, pFile, ' ') == 0
		      || (*whiteskip (L_buf) == 0));
}



/*  ppara - move cursor forward by paragraphs
 *
 *  <ppara> moves forward to the beginning of the next paragraph.  This
 *  is defined as moving to line i where line i-1 is blank, line i
 *  is non-blank and line i is after the one the cursor is on.	If we are
 *  beyond end-of-file, the cursor is not moved.
 *
 *  <meta><ppara> moves forward to the first blank line beyond the current/
 *  next paragraph.  This is defined as moving to line i where line i-1 is
 *  non-blank, line i is blank and line i is after the one the cursor is on.
 *  If we are beyond end-of-file, the cursor is not moved.
 */
flagType
ppara (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    LINE y;
    LINE y1 = YCUR(pInsCur);

    if (YCUR(pInsCur) >= pFileHead->cLines) {
        return FALSE;
    }

    if (!fMeta) {
        for (y = YCUR(pInsCur) + 1; y < pFileHead->cLines; y++) {
            if (fIsBlank (pFileHead, y-1) && !fIsBlank (pFileHead, y)) {
                break;
            }
        }
    } else {
        for (y = YCUR(pInsCur) + 1; y < pFileHead->cLines; y++) {
            if (!fIsBlank (pFileHead, y-1) && fIsBlank (pFileHead, y)) {
                break;
            }
        }
    }

    docursor (0, y);
    return (flagType)(y1 != YCUR(pInsCur));

    argData; pArg;
}




/*  mpara - move cursor backward by paragraphs
 *
 *  <mpara> moves backward to the beginning of the previous paragraph.	This
 *  is defined as moving to line i where line i-1 is blank, line i
 *  is non-blank and line i is before the one the cursor is on.  If we are
 *  at the beginning of the file, the cursor is not moved.
 *
 *  <meta><mpara> moves backward to the first blank line before the current/
 *  next paragraph.  This is defined as moving to line i where line i-1 is
 *  non-blank, line i is blank and line i is before the one the cursor is on.
 *  If we are at the beginning of the file, the cursor is not moved.
 */
flagType
mpara (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    LINE y;
    LINE y1 = YCUR(pInsCur);

    if (YCUR(pInsCur) == 0) {
        return FALSE;
    }

    if (!fMeta) {
        for (y = YCUR(pInsCur) - 1; y > 0; y--) {
            if (fIsBlank (pFileHead, y-1) && !fIsBlank (pFileHead, y)) {
                break;
            }
        }
    } else {
        for (y = YCUR(pInsCur) - 1; y > 0; y--) {
            if (!fIsBlank (pFileHead, y-1) && fIsBlank (pFileHead, y)) {
                break;
            }
        }
    }

    docursor (0, y);
    return (flagType)(y1 != YCUR(pInsCur));

    argData; pArg;
}



/*** ppage - moves the cursor down by pages
*
* Purpose: <ppage> moves the cursor one page forward. The size of the
*	    page is actually the vertical size of the current window.
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at end
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/

flagType
ppage (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
	) {

    LINE	    y = YCUR(pInsCur);
    LINE	    PagesDown = 1;
    KBDKEY	    Key;
    EDITOR_KEY	    KeyInfo;

    //
    //	Check if there are more  keys and add them up.
    //	Do this only if NOT in a macro
    //

    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x113)
		PagesDown++;
	    else
	    if (KeyInfo.KeyCode == 0x112 && PagesDown > 0)
		PagesDown--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }


    if (PagesDown > 0)
	doscreen (XWIN(pInsCur), YWIN(pInsCur)+(PagesDown * WINYSIZE(pWinCur)),
		  XCUR(pInsCur), YCUR(pInsCur)+(PagesDown * WINYSIZE(pWinCur)) );

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg; fMeta;
}



/*** mppage - moves the cursor up page by page
*
* Purpose: <mpage> moves the cursor one page backwards. The size of the
*	    page is actually the vertical size of the current window.
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at top
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
mpage (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
	) {

    LINE	    y = YCUR(pInsCur);
    LINE	    PagesUp = 1;
    KBDKEY	    Key;
    EDITOR_KEY	KeyInfo;

    //
    //	Check if there are more  keys and add them up.
    //	Do this only if NOT in a macro
    //
    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x112)
		PagesUp++;
	    else
	    if (KeyInfo.KeyCode == 0x113 && PagesUp > 0)
		PagesUp--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }


    if (PagesUp > 0)
	doscreen (XWIN(pInsCur), YWIN(pInsCur)-(PagesUp * WINYSIZE(pWinCur)),
		  XCUR(pInsCur), YCUR(pInsCur)-(PagesUp * WINYSIZE(pWinCur)));

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg; fMeta;
}



/*** endfile - Sets the cursor at end of file
*
* Purpose:
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at end
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
endfile (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    fl	flBefore;

    flBefore = pInsCur->flCursorCur;
    doscreen (0, pFileHead->cLines - YSCALE (hike), 0, pFileHead->cLines );
    return (flagType)((flBefore.col != XCUR(pInsCur)) || (flBefore.lin != YCUR(pInsCur)));

    argData; pArg; fMeta;
}



/*** begfile - Sets the cursor at top of file
*
* Purpose:
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at top
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
begfile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    fl	flBefore;

    flBefore = pInsCur->flCursorCur;
    doscreen( 0, (LINE)0, 0, (LINE)0 );
    return (flagType)((flBefore.col != XCUR(pInsCur)) || (flBefore.lin != YCUR(pInsCur)));

    argData; pArg; fMeta;
}


flagType
savecur (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    pInsCur->flSaveWin = pInsCur->flWindow;
    pInsCur->flSaveCur = pInsCur->flCursorCur;
    return pInsCur->fSaved = TRUE;

    argData; pArg; fMeta;
}



flagType
restcur (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    if (pInsCur->fSaved) {
	pInsCur->flWindow = pInsCur->flSaveWin;
	pInsCur->flCursorCur = pInsCur->flSaveCur;
	pInsCur->fSaved = FALSE;
        SETFLAG (fDisplay, RSTATUS | RCURSOR);
	newwindow ();
	return TRUE;
    } else {
        return FALSE;
    }

    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\dline.c ===
/*** dline.c - return one display line
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"


/*** fInRange - return true if the arguments are in order
*
* Input:
*
* Output:
*
*************************************************************************/
flagType
fInRange (
    long a,
    long x,
    long b
    ) {
    return (flagType) (((a <= x) && (x <= b)) || ((a >= x) && (x >= b)));
}



/*
 * Characters used in window borders
 */

#define DHBAR	((char)0xCD)
#define DVBAR	((char)0xBA)
#define DLTEE	((char)0xB9)
#define DUTEE	((char)0xCA)
#define DRTEE	((char)0xCC)
#define DDTEE	((char)0xCB)
#define DCRSS	((char)0xCE)

/*** DisplayLine - Get's the i'th display line of a window
*
*  Gets exactly what needs to be shown in the i'th line of the screen.
*  This takes care of showing trailing spaces, drawing borders, etc...
*
* Input:
*  yScrLine	- Get i'th line showing in the window
*  pchScrLine	- pointer to line buffer where the screen line is to be put
*  pplaScrLine	- pointer to pointer to place to put color info
*  pchFileLine	- pointer to line buffer
*  pplaFileLine - pointer to pointer to place to put color info
*
* Note:
*  If there is only one window on the screen then we only need one line
*  buffer and one color buffer. DoText should have taken care of this so
*  pchFileLine and *pplaFileLine should be both NULL.
*
* Output:
*  Returns Length of string in pchScrLine
*
****************************************************************************/
int
DisplayLine (
    int               yScrLine,
    char             *pchScrLine,
    struct lineAttr **pplaScrLine,
    char             *pchFileLine,
    struct lineAttr **pplaFileLine
    ) {

    int 	     iWnd;
    REGISTER PWND    pWnd;
    PINS	     pIns;
    PFILE	     pFile;

    int 	     cch;
    REGISTER char   *pch;

    /*
     * one window, speed hack:
     *
     * if there is only one window, just grab the line, append any trailing
     * space display, move the applicable portion of the line to the head of
     * the buffer, space fill out to the window width, and get the color info
     * for the line.
     */
    if (cWin == 1) {

	/*
	 * we always get the detab'ed (non-RAW) line for displaying.
	 */
	cch = gettextline (FALSE,
			   yScrLine + YWIN(pInsCur),
			   pchScrLine,
			   pFileHead,
			   tabDisp);
	ShowTrailDisp (pchScrLine, cch);

	/*
	 * Scroll left to match instance
	 */
	if (XWIN(pInsCur)) {
	    cch = max (0, min (cch - XWIN(pInsCur), XSIZE));
	    memmove( pchScrLine, (pchScrLine + XWIN(pInsCur)), cch );
        } else {
            cch = min (cch, XSIZE);
        }

	/*
	 * Pad end of line with blanks
	 */
        if (cch < XSIZE) {
	    memset ((char *) pchScrLine + cch, ' ', XSIZE - cch);
        }
	pchScrLine[XSIZE] = 0;

	/*
	 * Get color and hiliting info from the file
	 * (UpdHilite takes care of left scroll)
	 */
	GetColorUntabbed ((LINE)(yScrLine + YWIN(pInsCur)), *pplaScrLine, pFileHead);
	UpdHiLite (pFileHead,
		   (LINE) (yScrLine + YWIN(pInsCur)),
		   XWIN(pInsCur),
		   XWIN(pInsCur) + XSIZE - 1,
		   pplaScrLine);
	return XSIZE;
    }

    /*
     * Multiple windows
     *
     * initially set up the line to be all dashes (horizontal screen split)
     * with window borders color
     */
    memset ((char *) (pchScrLine), DHBAR, XSIZE);
    pchScrLine[XSIZE] = 0;
    (*pplaScrLine)->len   = 0xff;
    (*pplaScrLine)->attr  = WDCOLOR;

    /*
     * for each active window
     */
    for (iWnd = 0, pWnd = WinList; iWnd < cWin; iWnd++, pWnd++) {
	/*
	 * if the display line is in the window
	 */
	if (fInRange ((long) WINYPOS(pWnd),
		      (long) yScrLine,
		      (long) (WINYPOS(pWnd) + WINYSIZE(pWnd) - 1))) {
	    /*
	     * Do window on right
	     */
            if (WINXPOS(pWnd)) {
		switch ((char)(*(pch = pchScrLine + WINXPOS(pWnd) - 1) & 0xFF)) {
		    case DHBAR:
			*pch = DLTEE;
			break;
		    case DRTEE:
			*pch = DVBAR;
			break;
		    case DUTEE:
			*pch = DLTEE;
			break;
		    case DCRSS:
			*pch = DLTEE;
			break;
                }
            }
	    /*
	     * blank the window
	     */
	    memset ((char *) pchScrLine + WINXPOS(pWnd), ' ', WINXSIZE(pWnd));
	    UpdOneHiLite (*pplaScrLine,
			  WINXPOS(pWnd),
			  WINXSIZE(pWnd),
			  TRUE,
			  FGCOLOR);

	    /*
	     * retrieve the window instance and current file
	     */
	    pIns = pWnd->pInstance;
	    pFile = pIns->pFile;

	    /*
	     * get the correct line from the file
	     */
	    cch = gettextline (FALSE,
			       (LINE) (yScrLine - WINYPOS(pWnd) + YWIN(pIns)),
			       pchFileLine,
			       pFile,
			       tabDisp);
	    ShowTrailDisp (pchFileLine, cch);

	    /*
	     * if line is visible
	     */
	    if (cch >= XWIN (pIns)) {

		/*
		 * move the visible portion of the line into the buffer
		 */
		memmove((char*)( pchScrLine + WINXPOS( pWnd )),
			(char*)( pchFileLine + XWIN( pIns )),
			min (cch-XWIN(pIns), WINXSIZE(pWnd)));

		/*
		 * Get color and hiliting info from the file
		 * (UpdHilite takes care of left scroll)
		 */
		GetColorUntabbed ((LINE) (yScrLine - WINYPOS(pWnd) + YWIN(pIns)),
			  *pplaFileLine,
			  pFile);
		UpdHiLite (pFile,
			   (LINE) (yScrLine - WINYPOS(pWnd) + YWIN(pIns)),
			   XWIN(pIns),
			   XWIN(pIns) + WINXSIZE(pWnd) - 1,
			   pplaFileLine);

		/*
		 * Put it in the screen buffer
		 */
		UpdOneHiLite (*pplaScrLine,
			      WINXPOS(pWnd),
			      WINXSIZE(pWnd),
			      FALSE,
			      (INT_PTR) *pplaFileLine);
            }
	    /*
	     * do window left
	     */
	    switch ((char)(*(pch = pchScrLine + WINXPOS(pWnd) + WINXSIZE(pWnd)) & 0xFF)) {
		case DHBAR:
		    *pch = DRTEE;
		    break;
		case DLTEE:
		    *pch = DVBAR;
		    break;
		case DCRSS:
		    *pch = DRTEE;
		    break;
            }
        } else {
            /*
             * test for break immediately above
             */
            if (WINYPOS(pWnd) + WINYSIZE(pWnd) == yScrLine) {
                switch ((char)(*(pch = pchScrLine + WINXPOS(pWnd) + WINXSIZE(pWnd)) & 0xFF)) {
                    case DHBAR:
                        *pch = DUTEE;
                        break;
                    case DDTEE:
                        *pch = DCRSS;
                        break;
                }
            } else {
                /*
                 * test for break immediately below
                 */
                if (WINYPOS(pWnd)-1 == yScrLine) {
                    switch ((char)(*(pch = pchScrLine + WINXPOS(pWnd) + WINXSIZE(pWnd)) & 0xFF)) {
                        case DHBAR:
                            *pch = DDTEE;
                            break;
                        case DUTEE:
                            *pch = DCRSS;
                            break;
                    }
                }
            }
        }
    }
    pchScrLine[XSIZE] = 0;
    return XSIZE;
}



/*** SetTrailDisp - set character displayed for trailing spaces.
*
* Input:
*
* Output:
*
*************************************************************************/
flagType
SetTrailDisp (
    char * val
    ) {
    buffer locval = {0};

    strncat ((char *) locval, val, sizeof(locval)-1);

    trailDisp = (char) atoi (locval);

    newscreen ();
    return TRUE;
}



/*** ShowTrailDisp
*
* Input:
*
* Output:
*
*************************************************************************/
void
ShowTrailDisp (
    buffer buf,
    int len
    ) {
    REGISTER char * p;

    if (trailDisp) {
        p = &buf[len];
        while (p > buf && p[-1] == ' ') {
            *--p = trailDisp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\display.c ===
/*** display.c - display the current file
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#define INCL_SUB
#define INCL_MESSAGES

#include "mep.h"
#include <stdarg.h>
#include "keyboard.h"

#define DEBFLAG DISP



/*** Display & DoDisplay - update the physical display
*
*  We examine all the hints left around for us by the editing and attempt to
*  make a minimal set of changes to the screen. We will do this until one of
*  the following conditions exist:
*
*   - the screen is completely updated
*   - there is a keystroke waiting for us
*
*  When one occurs, we return.
*
*  The hints that are left around are as follows:
*
*   fDisplay is a bit field indicating what part of the general display needs
*   to be updated. The fields (and the corresponding areas) are:
*
*	RTEXT	    the window on the file(s)
*	RSTATUS     the status line on the bottom of the screen
*	RCURSOR     the cursor
*	RHIGH	    the region [xhlStart,yhlStart] [xhlEnd,yhlEnd] is to be
*		    highlighted on the screen.
*
*  fChange[i] is a bit field for each line of the display indicating how the
*  line might have changed. The fields are:
*
*      FMODIFY	   the line has changed somewhat; ideally, we merely compare
*		       each character in the new line (retrieved with GetLine)
*		       with the one kept in the screen shadow array.
*
*  Display checks first to see if we are in a macro, and returns if we are.
*  DoDisplay does not check.
*
* Input:
*  none, other than various globals mentioned above.
*
* Output:
*  screen updated or key hit (or macro in progress for Display).
*
*************************************************************************/

void
Display (
    void
    ) {
    if (!mtest ()) {
        DoDisplay ();
    }
}



void
DoDisplay (
    void
	) {

    int Row, Col;

    if (pFileHead == NULL) {
        return;
    }

    if (TESTFLAG (fDisplay, RCURSOR)) {

        Row = YCUR(pInsCur) - YWIN(pInsCur) + WINYPOS(pWinCur);
        Col = XCUR(pInsCur) - XWIN(pInsCur) + WINXPOS(pWinCur);

	if ( Row >= YSIZE || Col >= XSIZE ) {
            docursor( XCUR(pInsCur), YCUR(pInsCur) );
        }
    }

	/*
     * If text needs updating, do so. Return immediately if a keystroke was
     * pressed.
	 */
	if (TESTFLAG (fDisplay, RTEXT) && !DoText (0, YSIZE)) {
		return;
    }

	if ((fDisplayCursorLoc && TESTFLAG (fDisplay, RCURSOR)) ||
	    TESTFLAG (fDisplay, RSTATUS)) {
        DoStatus ();
    }

    if (TESTFLAG (fDisplay, RCURSOR)) {

        Row = YCUR(pInsCur) - YWIN(pInsCur) + WINYPOS(pWinCur);
        Col = XCUR(pInsCur) - XWIN(pInsCur) + WINXPOS(pWinCur);

        consoleMoveTo( Row, Col );
		RSETFLAG (fDisplay, RCURSOR);
	}
}


/*** DoText - Update window text
*
* Purpose:
*  Update given window until entirely accurate or until there are      *
*  are keystrokes waiting to be entered.  Use the hints in fDisplay    *
*  and fChange to guide the update.				       *
*
* Input:
*  yLow        0-based beginning line number of display update
*  yHigh       0-based ending line number of display update
*
* Output:
*  Returns TRUE if successfully updated screen					*
*	   FALSE if keystrokes are awaiting					*
*
*************************************************************************/

flagType
DoText (
    int yLow,
    int yHigh
    ) {

	REGISTER int		yCur;
	int 				yMin = -1;
	int 				yMax = 0;

	flagType			fReturn = TRUE;

	struct lineAttr 	*plaFile = NULL;
	struct lineAttr 	*plaScr  = NULL;
	struct lineAttr 	*plaFileLine;
	struct lineAttr 	*plaScrLine;

	char				*pchFileLine = NULL;
	char				pchScrLine[ 2 * sizeof(linebuf) * (1 + sizeof(struct lineAttr))];
	int 				cchScrLine;

	// int				chkpnt = yHigh - yLow > 25 ? 20 : 5;
	int					chkpnt = yHigh - yLow > 25 ? 10 : 3;


	fReDraw = FALSE;

	plaScr = (struct lineAttr *) (pchScrLine + sizeof(linebuf));
    if (cWin > 1) {
		pchFileLine = pchScrLine + sizeof(linebuf) * (1 + sizeof(struct lineAttr));
		plaFile = (struct lineAttr *) (pchFileLine + sizeof(linebuf));
    }

    /*
     * For each line in the window, if the line is marked changed, update it.
     */
	for (yCur = yLow; yCur < yHigh; ) {

		if (TESTFLAG(fChange[yCur], FMODIFY)) {
            if (yMin == -1) {
                yMin = yCur;
            }
			yMax = yCur;

			/*
			 * get and display the line
			 */
			plaScrLine	= plaScr;
			plaFileLine = plaFile;
			cchScrLine = DisplayLine (yCur, pchScrLine, &plaScrLine, pchFileLine, &plaFileLine);
			coutb (0, yCur, pchScrLine, cchScrLine, plaScrLine);

			RSETFLAG(fChange[yCur],FMODIFY);
			/*
			 * if it is time to check, and there is a character waiting, stop
			 * the update process, and go process it
			 */
			if ( (yCur % chkpnt == 0) && TypeAhead() ) {
				fReturn = FALSE;
				break;
			}
		}
		yCur++;
	}

    if (fReturn) {
        RSETFLAG (fDisplay, RTEXT);
	}
	//
	//	Update the screen
	//
    fReDraw = TRUE;
	vout(0,0,NULL,0,0);
	return fReturn;
}



/*** DoStatus - Update the status line
*
* Purpose:
*  Creates and displays the status line on the bottom of the screen.
*
* Input:
*  None, other than the various globals that go into the status line.
*
* Output:
*  Returns status line output
*
*************************************************************************/

#define CINDEX(clr)     (unsigned char) ((&clr-&ColorTab[0])+isaUserMin)

void
DoStatus (
    void
    ) {
    struct lineAttr rglaStatus[10];		/* color array for status line	*/
    int 	    cch;
    int         ilaStatus  = 0;        /* index into color array       */
    int         i;
    char        *pchEndBuf;           /* save for end of buffer       */
    char        L_buf[512];

    /*
     * Start with filename, and file type
     */
    strcpy (L_buf, pFileHead->pName);
    strcat (L_buf, " (");
    strcpy ((char *)strend(L_buf), GetFileTypeName ());

    /*
     * Add other file characterisctics
     */
    if (!TESTFLAG (FLAGS (pFileHead), DOSFILE)) {
        strcat (L_buf," NL");
    }

    if (TESTFLAG (FLAGS (pFileHead), TEMP)) {
        strcat (L_buf, " temp");
    }

    if ((TESTFLAG (FLAGS (pFileHead), READONLY)) | fGlobalRO) {
        strcat (L_buf, " No-Edit");
    }

    if (TESTFLAG (FLAGS (pFileHead), DISKRO)) {
        strcat (L_buf, " RO-File");
    }

    rglaStatus[ilaStatus].attr = CINDEX(staColor);
    rglaStatus[ilaStatus++].len = (unsigned char) strlen (L_buf);

    if (TESTFLAG (FLAGS(pFileHead), DIRTY)) {
    strcat (L_buf, " modified");
    rglaStatus[ilaStatus].attr = CINDEX(errColor);
    rglaStatus[ilaStatus++].len = 9;
    }

    pchEndBuf = strend (L_buf);
    sprintf (strend(L_buf), ") Length=%ld ", pFileHead->cLines);

    /*
     * Add current location
     */
    if (fDisplayCursorLoc) {
    sprintf (strend(L_buf), "Cursor=(%ld,%d)", YCUR(pInsCur)+1, XCUR(pInsCur)+1);
    } else {
        sprintf (strend(L_buf), "Window=(%ld,%d)", YWIN(pInsCur)+1, XWIN(pInsCur)+1);
    }
    rglaStatus[ilaStatus].attr = CINDEX(staColor);
    rglaStatus[ilaStatus++].len = (unsigned char) (strend(L_buf) - pchEndBuf);

    /*
     * Add global state indicators
     */
    if (fInsert | fMeta | fCtrlc | fMacroRecord) {
    rglaStatus[ilaStatus].attr = CINDEX(infColor);
    rglaStatus[ilaStatus].len = 0;
    if (fInsert) {
        strcat (L_buf, " insert");
        rglaStatus[ilaStatus].len += 7;
        }
    if (fMeta) {
        strcat (L_buf, " meta");
        rglaStatus[ilaStatus].len += 5;
        }
    if (fCtrlc) {
        strcat (L_buf, " cancel");
        rglaStatus[ilaStatus].len += 7;
        fCtrlc = FALSE;
        FlushInput ();
        }
    if (fMacroRecord) {
        strcat (L_buf, " REC");
        rglaStatus[ilaStatus].len += 4;
        }
    ilaStatus++;
    }

    rglaStatus[ilaStatus].attr = CINDEX(staColor);
    rglaStatus[ilaStatus].len = 0xff;
    pchEndBuf = L_buf;

    /*
     * if the net result is too long, eat the first part of the filename with
     * an elipses (Leave room for BC as well).
     */
    cch = strlen(L_buf) - (XSIZE - 4);

    if (cch > 0) {
        pchEndBuf = L_buf + cch;
        pchEndBuf[0] = '.';
        pchEndBuf[1] = '.';
        pchEndBuf[2] = '.';

        i = 0;

        while ( cch && i <= ilaStatus  ) {

            if ( (int)rglaStatus[i].len > cch ) {

                rglaStatus[i].len -= (unsigned char)cch;
                cch = 0;

            } else {

                cch -= rglaStatus[i].len;
                rglaStatus[i].len = 0;

            }

            i++;
        }
    }

    fReDraw = FALSE;
    coutb (0, YSIZE+1, pchEndBuf, strlen(pchEndBuf), rglaStatus);

    fReDraw = TRUE;
    voutb (XSIZE-2, YSIZE+1, BTWorking() ? "BP" : "  ", 2, errColor);

    RSETFLAG (fDisplay,  RSTATUS);
}



/*** newscreen - Mark entire screen dirty
*
*  Forces entire screen to be redrawn.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
newscreen (
    void
    ) {

	REGISTER int iLine = YSIZE;

	while (iLine--) {
		SETFLAG ( fChange[iLine], FMODIFY );
	}

	SETFLAG (fDisplay, RTEXT);
}



/*** redraw - Mark a range of lines in file dirty
*
*  Marks a range of lines in a file as needing to be updated. Each window that
*  they occur in is marked.
*
* Input:
*  pFile	     = File handle containing dirty lines
*  linFirst, linLast = Range of lines to mark
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
redraw (
    PFILE pFile,
    LINE  linFirst,
    LINE  linLast
    ) {

    LINE	  linFirstUpd, linLastUpd;
    REGISTER PINS pInsTmp;

    int                         iWinTmp;
    REGISTER struct windowType *pWinTmp;

	if (linFirst > linLast) {
	linFirstUpd = linLast;
	linLast     = linFirst;
	linFirst    = linFirstUpd;
    }

    for (iWinTmp = 0, pWinTmp = WinList; iWinTmp < cWin; iWinTmp++, pWinTmp++) {
        if (pWinTmp->pInstance) {
            if (pFile == pWinTmp->pInstance->pFile) {
                pInsTmp = pWinTmp->pInstance;
                linFirstUpd = WINYPOS(pWinTmp) + lmax (0L, linFirst-YWIN(pInsTmp)-1);
                linLastUpd  = WINYPOS(pWinTmp) + lmin ((long) (WINYSIZE(pWinTmp) - 1), linLast - YWIN(pInsTmp));
                while (linFirstUpd <= linLastUpd) {
                    SETFLAG (fChange[linFirstUpd++],FMODIFY);
                }
            }
        }
    }
	SETFLAG (fDisplay, RTEXT);
}



/*** newwindow - Mark current window dirty
*
*  Mark all lines in the current window as needing to be updated
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
newwindow (
    void
    ) {

    REGISTER int iLine;

	//
    // We ignore the next two assertions, because of a more involved problem of
    // screen size being set up AFTER  instances and window layout have been read
    // in on start up. This means that for a short period of time, these
    // conditions might actually exist. We check for the error and limit the
    // access of the fchange array for now.
    //
    //    assert (MEMSIZE (fChange) >= WINYSIZE (pWinCur));
    //    assert (WINYSIZE (pWinCur) + WINYPOS (pWinCur) <= YSIZE);

    for (iLine = 0; iLine < WINYSIZE (pWinCur); iLine++) {
        if (iLine + WINYPOS(pWinCur) < YSIZE) {
            SETFLAG (fChange[iLine + WINYPOS(pWinCur)],FMODIFY);
        }
    }
	SETFLAG (fDisplay, RTEXT);
}



/*** noise
*
* Input:
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
noise (
    REGISTER LINE lin
    ) {

    char szTinyBuf[10];

    if (lin && cNoise) {
		if ((lin % cNoise) == 0) {
            sprintf (szTinyBuf, " %ld", lin);
			soutb (XSIZE-10, YSIZE+1, szTinyBuf, fgColor);
        }
    }

}



/*** dispmsg - display retrieved message on help/status line
*
*  Places a message on the help/status line. It is removed the next time
*  activity occurrs on that line.
*
*  In the CW version, the resulting (formatted) message is placed in the
*  local heap, and actually displayed by the WndProc for the help window.
*
* Input:
*  iMsg 	= index for message string to be retrieved and displayed.
*		  The string may have embedded printf formatting. If iMsg
*		  is zero, the status line is cleared.
*  ...		= variable number of args per the formatted string
*
* Output:
*  Returns TRUE
*
*************************************************************************/
flagType
__cdecl
dispmsg (
    int     iMsg,
    ...
    ) {

	buffer	fmtstr;				/* retrieved formatting string		*/
    //buffer  textbuf;            /* formatted output line            */
    char    L_textbuf[ 512 ];
	int 	len;				/* Length of message				*/
    va_list Argument;

    va_start(Argument, iMsg);

    if (fMessUp = (flagType)iMsg) {
		GetMsg (iMsg, fmtstr);
		ZFormat (L_textbuf, fmtstr, Argument);
		len = strlen(L_textbuf);
        if (len > (XSIZE-1)) {
			//
			//	message is too long, we will truncate it
			//
            L_textbuf[XSIZE-1] = '\0';
		}
	} else {
		L_textbuf[0] = ' ';
		L_textbuf[1] = '\0';
    }

    fReDraw = TRUE;
    soutb (0, YSIZE, L_textbuf, infColor);

    va_end(Argument);

    return TRUE;
}



/*** disperr - display error message on status line
*
*  prints a formatted error message on the status line, and then waits for a
*  keystroke. Once hit, the message is cleared.
*
* Input:
*  iMsg 	= index for message string to be retrieved and displayed.
*		  The string may have embedded printf formatting.
*  ...		= variable number of args per the formatted string
*
* Output:
*  returns FALSE
*
*************************************************************************/
flagType
__cdecl
disperr (
    int     iMsg,
    ...
    ) {

    buffer  pszFmt;			/* retrieved formatting string	*/
    buffer  bufLocal;			/* formatted output line	*/
    va_list Arguments;

    assert (iMsg);
    GetMsg (iMsg, pszFmt);

    va_start(Arguments, iMsg);

    ZFormat (bufLocal, pszFmt, Arguments);

    fReDraw = TRUE;
    bell ();
    FlushInput ();
    soutb (0, YSIZE, bufLocal, errColor);
    if (fErrPrompt) {
		asserte (*GetMsg (MSG_PRESS_ANY, bufLocal));
        soutb (XSIZE-strlen(bufLocal)-1, YSIZE, bufLocal, errColor);
        SetEvent( semIdle );
		ReadChar ();
        WaitForSingleObject(semIdle, INFINITE);
		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
		soutb(0, YSIZE, bufLocal, errColor);
    } else {
        delay (1);
    }

    va_end(Arguments);

    return FALSE;
}



/*** domessage - display a message on the help-status line
*
*  Places a message on the help/status line. It is removed the next time
*  activity occurrs on that line.
*
*  In the CW version, the resulting (formatted) message is placed in the
*  local heap, and actually displayed by the WndProc for the help window.
*
* Input:
*  pszFmt	- Printf formatting string
*  ...		- variable number of args as per the formatting string
*
* Output:
*  Returns nothing
*
* UNDONE: all calls to domessage should be replaced by calls to dispmsg
*
*************************************************************************/
int
__cdecl
domessage (
    char    *pszFmt,
    ...
	) {


#define NEEDED_SPACE_AFTER_MESSAGE      12

    char    bufLocal[512];
	va_list Arguments;
	int 	Length;
	char   *Msg;

    va_start(Arguments, pszFmt);

    if (fMessUp = (flagType)(pszFmt != NULL)) {
        ZFormat (bufLocal, pszFmt, Arguments);
	} else {
		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
    }

    fReDraw = TRUE;

	va_end(Arguments);

	//
	//	We have to make sure that the message is not too long for
	//	this line. If it is, se only display the last portion of it.
	//
	Length = strlen( bufLocal );

	if ( Length > XSIZE - NEEDED_SPACE_AFTER_MESSAGE ) {
		Msg = (char *)bufLocal + (Length - ( XSIZE - NEEDED_SPACE_AFTER_MESSAGE ));
		Length =  XSIZE - NEEDED_SPACE_AFTER_MESSAGE;
	} else {
		Msg = (char *)bufLocal;
	}

	soutb( 0, YSIZE, Msg, infColor );

	return	Length;

}



/*** printerror - print error message on status line
*
*  prints a formatted error message on the status line, and then waits for a
*  keystroke. Once hit, the message is cleared.
*
* Input:
*  printf style parameters
*
* Output:
*  Number of characters output in error message
*
*************************************************************************/
int
__cdecl
printerror (
    char *pszFmt,
    ...
    ) {

    buffer       bufLocal;
    va_list      Arguments;
    REGISTER int cch;

    va_start(Arguments, pszFmt);

    ZFormat (bufLocal, pszFmt, Arguments);

    fReDraw = TRUE;
    bell ();
    FlushInput ();
    cch = soutb (0, YSIZE, bufLocal, errColor);
    if (fErrPrompt) {
		asserte (*GetMsg (MSG_PRESS_ANY, bufLocal));
        soutb (XSIZE-strlen(bufLocal)-1, YSIZE, bufLocal, errColor);
        SetEvent( semIdle );
		ReadChar ();
        WaitForSingleObject(semIdle, INFINITE);
		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
		soutb(0, YSIZE, bufLocal, errColor);
    } else {
        delay (1);
    }

    va_end(Arguments);

    return cch;
}



/*** bell
*
* Input:
*
* Output:
*
*************************************************************************/
void
bell (
    void
    ) {

    printf ("%c", BELL);

}



/*** makedirty
*
*
* Input:
*
* Output:
*
*************************************************************************/
void
makedirty (
    REGISTER PFILE pFileDirty
    ) {
    if (!TESTFLAG(FLAGS(pFileDirty),DIRTY)) {
        if (pFileDirty == pFileHead) {
            SETFLAG (fDisplay, RSTATUS);
        }
	SETFLAG (FLAGS(pFileDirty), DIRTY);
    }
}



/*** delay
*
* Input:
*
* Output:
*
*************************************************************************/
void
delay (
    int cSec
    ) {

    time_t lTimeNow, lTimeThen;

    if (mtest () && !mlast ()) {
        return;
    }
    time (&lTimeThen);
    do {
        if (TypeAhead ()) {
            return;
        }
	Sleep (100);
	time (&lTimeNow);
    } while (lTimeNow - lTimeThen < cSec + 1);
}



/*** SetScreen
*
* Purpose:
*   SetScreen () - Set up the editor's internal structures to match the screen
*   size described by ySize and xSize.	Set the hardware to the mode in
*   Zvideo.
*
* Input:
*
* Output:
*
*************************************************************************/
void
SetScreen (
    void
    ) {
    fChange = ZEROREALLOC (fChange, YSIZE * sizeof (*fChange));
    SETFLAG (fDisplay, RSTATUS);
    if (cWin == 1) {
	WINXSIZE(pWinCur) = XSIZE;
	WINYSIZE(pWinCur) = YSIZE;
    }
    newscreen ();
	// SetVideoState(Zvideo);
}



/*** HighLight
*
*
* Input:
*
* Output:
*
*************************************************************************/
void
HighLight (
    COL  colFirst,
    LINE linFirst,
    COL  colLast,
    LINE linLast
    ) {

    rn	rnCur;

    rnCur.flFirst.lin = linFirst;
    rnCur.flFirst.col = colFirst;
    rnCur.flLast.lin  = linLast;
    rnCur.flLast.col  = colLast;

    SetHiLite (pFileHead, rnCur, INFCOLOR);
}



/*** AdjustLines - change all information relevant to deletion/insertion of
*		   lines in a file.
*
* Purpose:
*  When we are deleting or inserting lines, there is some updating that we
*  need to do to retain some consistency in the user's view of the screen.
*  The updating consists of:
*
*      Adjusting all window instances of this window to prevent "jumping".
*      We enumerate all window instances.  If the top of the window is
*      above or inside the deleted/inserted range, do nothing.	If the top of
*      the window is below the inserted/deleted range, we modify the cursor
*      and window position to prevent the window from moving on the text
*      being viewed.
*
*      Ditto for all flip positions
*
* Input:
*  pFile       file that is being modified
*  lin	       beginning line of modification
*  clin        number of lines being inserted (> 0) or deleted (< 0)
*
* Output:
*
*************************************************************************/
void
AdjustLines (
    PFILE pFile,
    LINE  lin,
    LINE  clin
    ) {

    int 	  iWin;
    REGISTER PINS pInsTmp;

    /* walk all instances looking for one whose pFile matches
     */

    for (iWin = 0; iWin < cWin; iWin++) {
        for (pInsTmp = WININST(WinList + iWin);  pInsTmp != NULL; pInsTmp = pInsTmp->pNext) {
	    if (pInsTmp != pInsCur && pInsTmp->pFile == pFile) {
		/* adjust current position if necessary
		 */
		if (YWIN(pInsTmp) >= lin) {
		    YWIN(pInsTmp) = lmax ((LINE)0, YWIN(pInsTmp) + clin);
		    YCUR(pInsTmp) = lmax ((LINE)0, YCUR(pInsTmp) + clin);
                }
		/* adjust flip position if necessary
		 */
		if (YOLDWIN(pInsTmp) >= lin) {
		    YOLDWIN(pInsTmp) = lmax ((LINE)0, YOLDWIN(pInsTmp) + clin);
		    YOLDCUR(pInsTmp) = lmax ((LINE)0, YOLDCUR(pInsTmp) + clin);
                }
            }
        }
    }
}




/*** UpdateIf - Move the cursor position if a particlar file is displayed
*
*  Used to update the view on windows which are not necessarily the current
*  window. Examples: tying together the compile error log with the current
*  view on the source code.
*
* Input:
*  pFileChg	= pointer to the file whose display is to be updated.
*  yNew 	= New cursor line position.
*  fTop 	= cursor line should be positionned at top/bottom of the window
*
* Output:
*  Returns TRUE if on-screen and updated.
*
*************************************************************************/
flagType
UpdateIf (
    PFILE    pFileChg,
    LINE     linNew,
    flagType fTop
    ) {

    PINS     L_pInsCur;
    PWND     pWndFound	 = NULL;
    flagType fFound	= FALSE;

    /*
     * If this is the top file, we don't want to do anything
     */
    if (pFileChg == pFileHead) {
        return FALSE;
    }

    /*
     * Walk the window list, and check to see if the top instance (file
     * currently in view) is the one we care about. If so, update its cursor
     * and window position.
     */
    while (pWndFound = IsVispFile (pFileChg, pWndFound)) {
	if (pWndFound != pWinCur) {
	    L_pInsCur = WININST(pWndFound);
	    YCUR(L_pInsCur) = linNew;
	    XCUR(L_pInsCur) = 0;
	    YWIN(L_pInsCur) = fTop ?
			YCUR(L_pInsCur) :
			lmax (0L, YCUR(L_pInsCur) - (WINYSIZE(pWndFound)-1));
	    XWIN(L_pInsCur) = 0;
	    fFound = TRUE;
        }
    }

    /*
     * If any visible instances of the file were discovered above, redraw the
     * entire file, such that all windows will be updated, regardless of view.
     */
    if (fFound) {
        redraw (pFileChg, 0L, pFileChg->cLines);
    }

    return fFound;
}



/*** IsVispFile - See if pfile is visibke
*
*  Determines if a particular pFile is currently visible to the user, and
*  returns a pointer to the window first found in.
*
* Input:
*  pFile	= pFile of interest
*  pWin 	= pWin to start at, or NULL to start at begining
*
* Output:
*  Returns pWin of first window found, or NULL
*
*************************************************************************/
PWND
IsVispFile (
    PFILE           pFile,
    REGISTER PWND   pWnd
    ) {

    /*
     * If NULL starting pWnd specified, then start at first one.
     */
    if (!pWnd++) {
        pWnd = &WinList[0];
    }

    /*
     * for all remaining windows currently active, check top instance for pFile
     * of interest
     */
    for (; pWnd < &WinList[cWin]; pWnd++) {
        if (WININST(pWnd)->pFile == pFile) {
            return pWnd;
        }
    }
    return NULL;
}





/*** GetMsg - Message Retriever
*
* Purpose:
*  Get an error message from the message segment and copy it to a
*  buffer, returning a pointer to the buffer.
*
* Input:
*  iMsg 	 = Message number to get
*  pchDst	 = pointer to place to put it
*
* Output:
*  returns pDest
*
* Exceptions:
*  None
*
*************************************************************************/
char *
GetMsg (
    unsigned  iMsg,
    char     *pchDst
    ) {

    char *pch;
    WORD   i;

    for (i=0; (MsgStr[i].usMsgNo != (WORD)iMsg) && (MsgStr[i].usMsgNo != 0); i++);
    pch = MsgStr[i].pMsgTxt;

    strcpy ((char *)pchDst, pch);

    return pchDst;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\env.c ===
/*  env.c - manipulate editor environment
 *
 *  Modifications:
 *
 *	26-Nov-1991 mz	Strip off near/far
 *
 */

#include "mep.h"

/*  environment - function to perform environment manipulation
 *
 *  set environment
 *  display environment
 *  perform env substitution
 *
 *  fn	sets environment
 *  meta fn does env substitution
 *
 *  noarg	    sets current line into env
 *  textarg	    sets text into env		    single ? displays env
 *  nullarg	    sets to eol into env
 *  linearg	    sets each line into env
 *  streamarg	    sets each fragment into env
 *  boxarg	    sets each fragment into env
 *
 *  meta noarg	    maps current line
 *  meta textarg    illegal
 *  meta nullarg    maps to eol
 *  meta linearg    maps each line
 *  meta streamarg  maps each fragment
 *  meta boxarg     maps each fragment
 *
 *  argData	keystroke
 *  pArg	definition of arguments
 *  fMeta	TRUE => meta was invoked
 *
 *  Returns:	TRUE if operation was successful
 *		FALSE otherwise
 */

static char *pmltl = "Mapped line %ld too long";



flagType
environment (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ){

    linebuf ebuf, ebuf1;
    LINE l;
    int ol;

    if (!fMeta) {
	/*  Perform environment modifications
	 */
        switch (pArg->argType) {

	case NOARG:
	    GetLine (pArg->arg.noarg.y, ebuf, pFileHead);
            return fSetEnv (ebuf);

	case TEXTARG:
	    strcpy ((char *) ebuf, pArg->arg.textarg.pText);
            return fSetEnv (ebuf);

	case NULLARG:
	    fInsSpace (pArg->arg.nullarg.x, pArg->arg.nullarg.y, 0, pFileHead, ebuf);
            return fSetEnv (&ebuf[pArg->arg.nullarg.x]);

	case LINEARG:
	    for (l = pArg->arg.linearg.yStart; l <= pArg->arg.linearg.yEnd; l++) {
		GetLine (l, ebuf, pFileHead);
		if (!fSetEnv (ebuf)) {
		    docursor (0, l);
		    return FALSE;
                }
            }
            return TRUE;

	case BOXARG:
	    for (l = pArg->arg.boxarg.yTop; l <= pArg->arg.boxarg.yBottom; l++) {
		fInsSpace (pArg->arg.boxarg.xRight, l, 0, pFileHead, ebuf);
		ebuf[pArg->arg.boxarg.xRight+1] = 0;
		if (!fSetEnv (&ebuf[pArg->arg.boxarg.xLeft])) {
		    docursor (pArg->arg.boxarg.xLeft, l);
		    return FALSE;
                }
            }
            return TRUE;

        }
    } else {
	/*  Perform environment substitutions
	 */
        switch (pArg->argType) {

	case NOARG:
	    GetLine (pArg->arg.noarg.y, ebuf, pFileHead);
	    if (!fMapEnv (ebuf, ebuf, sizeof(ebuf))) {
		printerror (pmltl, pArg->arg.noarg.y+1);
		return FALSE;
            }
	    PutLine (pArg->arg.noarg.y, ebuf, pFileHead);
            return TRUE;

	case TEXTARG:
            return BadArg ();

	case NULLARG:
	    fInsSpace (pArg->arg.nullarg.x, pArg->arg.nullarg.y, 0, pFileHead, ebuf);
	    if (!fMapEnv (&ebuf[pArg->arg.nullarg.x],
			  &ebuf[pArg->arg.nullarg.x],
			  sizeof(ebuf) - pArg->arg.nullarg.x)) {
		printerror (pmltl, pArg->arg.nullarg.y+1);
		return FALSE;
            }
	    PutLine (pArg->arg.nullarg.y, ebuf, pFileHead);
            return TRUE;

	case LINEARG:
	    for (l = pArg->arg.linearg.yStart; l <= pArg->arg.linearg.yEnd; l++) {
		GetLine (l, ebuf, pFileHead);
		if (!fMapEnv (ebuf, ebuf, sizeof (ebuf))) {
		    printerror (pmltl, l+1);
		    docursor (0, l);
		    return FALSE;
                }
		PutLine (l, ebuf, pFileHead);
            }
            return TRUE;

	case BOXARG:
	    for (l = pArg->arg.boxarg.yTop; l <= pArg->arg.boxarg.yBottom; l++) {
		fInsSpace (pArg->arg.boxarg.xRight, l, 0, pFileHead, ebuf);
		ol = pArg->arg.boxarg.xRight + 1 - pArg->arg.boxarg.xLeft;
		memmove ( ebuf1, &ebuf[pArg->arg.boxarg.xLeft], ol);
		ebuf1[ol] = 0;
		if (!fMapEnv (ebuf1, ebuf1, sizeof (ebuf1)) ||
		    strlen (ebuf1) + strlen (ebuf) - ol >= sizeof (ebuf)) {
		    printerror (pmltl, l+1);
		    docursor (0, l);
		    return FALSE;
                }
		strcat (ebuf1, &ebuf[pArg->arg.boxarg.xRight + 1]);
		strcpy (&ebuf[pArg->arg.boxarg.xLeft], ebuf1);
		PutLine (l, ebuf, pFileHead);
            }
            return TRUE;

        }
    }

    return FALSE;
    argData;
}




/*  fMapEnv - perform environment substitutions
 *
 *  pSrc	character pointer to pattern string
 *  pDst	character pointer to destination buffer
 *  cbDst	amount of space in destination
 *
 *  Returns	TRUE if successful substitution
 *		FALSE if length overflow
 */
flagType
fMapEnv (
    char *pSrc,
    char *pDst,
    int cbDst
    ) {

    buffer tmp;
    char *pTmp, *p, *pEnd, *pEnv;
    int l;

    /*	when we find a $()-surrounded token, we'll null-terminate it using p
     *	and attempt to find it in the environment.  If we find it, we replace
     *	it.  If we don't find it, we drop it out.
     */

    pTmp = tmp;
    pEnd = pTmp + cbDst;

    while (*pSrc  != 0) {
    if (pSrc[0] == '$' && pSrc[1] == '(' && *(p = strbscan (pSrc + 2, ")")) != '\0') {
            *p = '\0';
            //pEnv = getenv(pSrc + 2);
            pEnv = getenvOem(pSrc + 2);
	    *p = ')';
            if (pEnv != NULL) {
                if ((l = strlen (pEnv)) + pTmp > pEnd) {
                    free(pEnv);
		    return FALSE;
                } else {
		    strcpy (pTmp, pEnv);
		    pTmp += l;
                }
                free(pEnv);
            }
	    pSrc = p + 1;
	    continue;
        }
        if (pTmp > pEnd) {
	    return FALSE;
        } else {
            *pTmp++ = *pSrc++;
        }
    }
    *pTmp = '\0';
    strcpy (pDst, tmp);
    return TRUE;
}




/*  fSetEnv - take some text and set it in the environment
 *
 *  We ignore leading/trailing blanks.	"VAR=blah" is done with quotes removed.
 *
 *  p		character pointer to text
 *
 *  returns	TRUE if successfully set
 *		FALSE otherwise
 */
flagType
fSetEnv (
    char *p
    ){
    char *p1;

    p = whiteskip (p);
    RemoveTrailSpace (p);
    /*	Handle quoting
     */
    p1 = strend (p) - 1;

    if (strlen (p) > 2 && *p == '"' && *p1 == '"') {
	p++;
	*p1 = 0;
    }

    if (!strcmp (p, "?")) {
	AutoSave ();
	return fChangeFile (FALSE, "<environment>");
    }

    if ((p = ZMakeStr (p)) == NULL) {
        return FALSE;
    }

//    if (putenv (p)) {
    if (putenvOem (p)) {
        FREE (p);
	return FALSE;
    }

    FREE (p);
    return TRUE;
}




/*  showenv - dump the environment into a file
 *
 *  pFile	file where output goes
 */
void
showenv (
    PFILE pFile
    ){

    int i;

    DelFile (pFile, FALSE);
    for (i = 0; environ[i] != NULL; i++) {
        AppFile (environ[i], pFile);
    }
    RSETFLAG (FLAGS(pFile), DIRTY);
    SETFLAG (FLAGS(pFile), READONLY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\event.c ===
/*** event.c - handle events for z extensions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"

EVT *pEVTHead	    = NULL;	    /* head of event chain	    */


/*** DeclareEvent - post the ocurrance of an event, and pass message
*
* Called by the various pieces of code that actualy detect event ocurrance,
* this routine traverses the event handler list, and invokes the event handler
* for each with matching criteria.
*
* event 	- Event Type.
* pargs 	- Pointer to any args to be passed to the handling routine
*
* Returns	- TRUE if the event has been consumed, and should be further
*		  ignored by the caller. Else FALSE.
*
*************************************************************************/
flagType
DeclareEvent (
    unsigned event,
    EVTargs *pargs
    ) {

    EVT *pEVTCur;

    //
    // For each in chain, if:
    //      - event type matches
    //      - focus is not specified, (all files) or matches the current focus
    //      - if it's a keyboard event, either no key was specified, or the
    //        matching key was specified
    // then we invoke the handler.
    //
    for (pEVTCur = pEVTHead; pEVTCur; pEVTCur = pEVTCur->pEVTNext) {
	assert (pEVTCur->pEVTNext != pEVTCur);
        if (pEVTCur->evtType != event) {
            //
            //  Skip events that don't match
            //
        } else if (pEVTCur->focus != NULL && pEVTCur->focus != pFileHead) {
            //
            //  Skip events that aren't for this file
            //
        } else if ((event == EVT_KEY || event == EVT_RAWKEY) &&
            pEVTCur->arg.arg.key.LongData != 0 && pEVTCur->arg.arg.key.LongData != pargs->arg.key.LongData) {
            //
            //  Skip events that don't match keystrokes
            //
        } else if (pEVTCur->func (pargs) != 0) {
            //
            //  Event handler eats event, don't propogate it
            //
            return TRUE;
        }
    }
    return FALSE;
}




/* RegisterEvent - Register Event handler
 *
 * Called by the extension that wishes to recieve event notification. Just
 * places ptr at head of list.
 *
 * pEVTDef	- Pointer to Event Definition struct.
 *
 */
void
RegisterEvent (
    EVT *pEVTDef
    ) {
    pEVTDef->pEVTNext = pEVTHead;
    pEVTHead = pEVTDef;
}



/* DeRegisterEvent - DeRegister Event handler
 *
 * Called by the extension that wishes to stop recieving event notification.
 * Just removes struct from list.
 *
 * pEVTDef	- Pointer to Event Definition struct.
 *
 */
void
DeRegisterEvent (
    EVT *pEVTDef
    ) {

    EVT *pEVTCur;

    if (pEVTHead) {
        if (pEVTHead == pEVTDef) {
	    pEVTHead = pEVTDef->pEVTNext;
        } else {
	    for (pEVTCur=pEVTHead; pEVTCur; pEVTCur=pEVTCur->pEVTNext) {
		if (pEVTCur->pEVTNext == pEVTDef) {
		    pEVTCur->pEVTNext = pEVTDef->pEVTNext;
		    break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\delete.c ===
/*  sdelete.c - stream delete of characters
 *
 *  Modifications:
 *	26-Nov-1991 mz	Strip off near/far
 */

#include "mep.h"


flagType
delete (
    CMDDATA argType,
    ARG * pArg,
    flagType fMeta
    ) {
    switch (pArg->argType) {
	case BOXARG:
	case LINEARG:
	    ldelete (argType, pArg, fMeta);
	    break;

	default:
	    sdelete (argType, pArg, fMeta);
	    break;
    }
    return TRUE;
}



flagType
sdelete (
    CMDDATA argType,
    ARG * pArg,
    flagType fMeta
    ) {

    fl  fl;

    switch (pArg->argType) {

    case NOARG:
	/* reduce line by one character.  No length overflow is possible */
	DelBox (pFileHead, XCUR (pInsCur), YCUR (pInsCur), XCUR (pInsCur), YCUR (pInsCur));
        return TRUE;

    /*	TEXTARG illegal 	    */
    case NULLARG:
        if (!fMeta) {
	    pick (pArg->arg.nullarg.x, pArg->arg.nullarg.y,
                  0, pArg->arg.nullarg.y+1, STREAMARG);
        }
	DelStream (pFileHead, pArg->arg.nullarg.x, pArg->arg.nullarg.y,
                   0, pArg->arg.nullarg.y+1);
        return TRUE;

    case LINEARG:
    case BOXARG:
	BoxToStream (pArg);

    case STREAMARG:
        if (!fMeta) {
	    pick (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
                  pArg->arg.streamarg.xEnd,   pArg->arg.streamarg.yEnd, STREAMARG);
        }
	DelStream (pFileHead,
		   pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
		   pArg->arg.streamarg.xEnd, pArg->arg.streamarg.yEnd);
	fl.col = pArg->arg.streamarg.xStart;
	fl.lin = pArg->arg.streamarg.yStart;
	cursorfl (fl);
	return TRUE;
    }

    return FALSE;

    argType;
}



/*** BoxToStream - Convert a box/line arg to a stream arg
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
BoxToStream (
    ARG * pArg
    ) {

    ARG arg;

    arg = *pArg;

    pArg->argType = STREAMARG;

    if (arg.argType == LINEARG) {
        pArg->arg.streamarg.yStart = arg.arg.linearg.yStart;
        pArg->arg.streamarg.yEnd   = arg.arg.linearg.yEnd;
        pArg->arg.streamarg.xStart = pArg->arg.streamarg.xEnd = flArg.col;
    } else {
        pArg->arg.streamarg.yStart = arg.arg.boxarg.yTop;
        pArg->arg.streamarg.yEnd   = arg.arg.boxarg.yBottom;

        if ((flArg.lin == arg.arg.boxarg.yTop    &&
             flArg.col == arg.arg.boxarg.xLeft)   ||
            (flArg.lin == arg.arg.boxarg.yBottom  &&
             flArg.col == arg.arg.boxarg.xRight + 1)) {
            pArg->arg.streamarg.xStart = arg.arg.boxarg.xLeft;
            pArg->arg.streamarg.xEnd   = arg.arg.boxarg.xRight + 1;
        } else {
            pArg->arg.streamarg.xStart = arg.arg.boxarg.xRight + 1;
            pArg->arg.streamarg.xEnd   = arg.arg.boxarg.xLeft;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\file.c ===
/*** file.c - file management
*
*   The internal file structure uses a combination of local memory
*   (managed by LMAlloc and free) and virtual memory (managed by malloc/ffree
*   and (pb|VA)To(pb|VA)).
*
*   We maintain one record for each file that Z has "in memory".  If a file
*   appears in multiple windows, there is only one record for that file.
*   Each window is treated as a separate instance of the editor, with a
*   separate record for each file that is present in that window.
*
*   Graphically, this appears as follows:
*
*    WinList (set of windows on the screen) 0 ... cWin-1
*   +---------------+---------------+---------------+---------------+
*   |   Window 1    |   Window 2    |   Window 3    |   Window 4    |
*   |               |               |               |               |
*   |windowType     |               |               |               |
*   |               |               |               |               |
*   |pInstance-+    |pInstance-+    |pInstance-+    |pInstance-+    |
*   +----------|----+----------|----+----------|----+----------|----+
*              |               v               v               |
*              v              ...             ...              v
*     +-------------+          pFileHead              +-------------+
*     |instanceType |              |                  |instanceType |
*     |             |   +----------+-----------+      |             |
*   +--pNext        |   |          v           |    +--pNext        |
*   | |pFile------------+   +-------------+    |    | |pFile        |
*   | +-------------+       |fileType     |    |    | +-------------+
*   |                       |             |    |    |
*   +------+              +--pFileNext    |    |    +------+
*          |           +-----pName        |    |           |
*          v           |  | +-------------+    |           v
*     +-------------+  |  |                    |      +-------------+
*     |instanceType |  |  |                    |      |instanceType |
*     |             |  |  |                    |      |             |
*   +--pNext        |  |  +--------+           |    +--pNext        |
*   | |pFile----+   |  |           |           +-------pFile        |
*   | +---------|---+  |           v                | +-------------+
*   |           |      |    +-------------+         |
*   +------+    v      |    |fileType     |         +------+
*          |   ...     |    |             |                |
*          v           |  +--pFileNext    |                v
*         ...          |  | |pName        |               ...
*          +-----------+  | +-------------+
*          |              |
*          v              |
*       +--------+        |
*       |filename|        +--------+
*       +--------+                 |
*                                  v
*                                 ...
*
*   Modifications:
*
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/
#define INCL_DOSFILEMGR

#include "mep.h"

#define DIRTY       0x01                /* file had been modified       */
#define FAKE        0x02                /* file is a pseudo file        */
#define REAL        0x04                /* file has been read from disk */
#define DOSFILE     0x08                /* file has CR-LF               */
#define TEMP        0x10                /* file is a temp file          */
#define NEW         0x20                /* file has been created by editor*/
#define REFRESH     0x40                /* file needs to be refreshed   */
#define READONLY    0x80                /* file may not be editted      */



#define DEBFLAG FILEIO

/*** AutoSave - take current file and write it out if necessary
*
* AutoSave is called when it makes sense to be paranoid about saving the
* file.  We save the file only when autosaving is enabled and when the
* file is real and dirty.
*
* Input:
*  none
*
* Output:
*  none
*
*************************************************************************/
void
AutoSave (
    void
    ) {
    AutoSaveFile (pFileHead);
}


/*** AutoSaveFile - AutoSave a specific file
*
* Called when it makes sense to be paranoid about saving a specific file. We
* save the file only when autosaving is enabled and when the file is real and
* dirty.
*
* Input:
*  pFile        = File to be autosaved
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
AutoSaveFile (
    PFILE   pFile
    ) {
    if (fAutoSave && (FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY) {
        fSyncFile (pFile, TRUE);
        FileWrite (NULL, pFile);
    }
}



/*  GetFileTypeName - return the text corresponding to the file type
 *
 *  GetFileTypeName takes the file type as set in the file structure of the
 *  current file and returns the textual string corresponding to that type.
 *
 *  returns         character pointer to the type-specific text
 */
char *
GetFileTypeName (
    void
    ) {
    if (TESTFLAG (FLAGS (pFileHead),FAKE)) {
        return "pseudo";
    }
    return mpTypepName[FTYPE (pFileHead)];
}



/*  SetFileType - set the file type of a file based upon its extension
 *
 *  pFile           pointer to file whose type will be determined
 */
void
SetFileType (
    PFILE pFile
    ) {
    pathbuf fext;
    REGISTER int i;

    extention (pFile->pName, fext);

    for (i = 0; ftypetbl[i].ext; i++) {
        if (!strcmp (ftypetbl[i].ext, (char *)&fext[1])) {
            break;
        }
    }

    FTYPE(pFile) = ftypetbl[i].ftype;
}




/*  fChangeFile  - change the current file, drive or directory.  We form the
 *  canonicalized name and attempt to find it in our internal list.  If
 *  present, then things are simple:  relink it to the head of the current
 *  window instance set.  If not present, then we need to read it in.
 *
 *  The actual algorithm is much simpler:
 *
 *      If file not in file list then
 *          create new entry in file list
 *      Find file in file list
 *      If file not in window instance list then
 *          add file to top of window instance list
 *      while files in window instance list do
 *          select top file
 *          if file is in memory then
 *              change succeeded
 *          else
 *          if read in succeeds then
 *              change succeeded
 *          pop off top file
 *      change failed
 *
 *
 *  fShort      TRUE => allow searching for short names
 *  name        name of file.
 *
 *  Returns:    TRUE if change succeeded
 *              FALSE otherwise
 */
flagType
fChangeFile (
    flagType  fShort,
    char      *name
    ) {

    PFILE    pFileTmp;
    pathbuf  bufCanon;
    flagType fRead;

    //
    //  Turn file name into canonical form
    //

    if (!CanonFilename (name, bufCanon)) {

        //
        // We may have failed because a drive or directory
        // went away.  If the file named is on the file
        // list, we remove it.
        //

        printerror ("Cannot access %s - %s", name, error () );

        pFileTmp = FileNameToHandle (name, (fShort && fShortNames) ? name : NULL);
        if (pFileTmp != NULL) {
            RemoveFile (pFileTmp);
        }

        return FALSE;
    }

    //
    //  name     has the input name
    //  bufCanon has the full "real" name
    //
    //  Check to see if the file is in the current file set
    //

    pFileTmp = FileNameToHandle (bufCanon, (fShort && fShortNames) ? name : NULL);

    if (pFileTmp == NULL) {

        //
        //  File not loaded.  If it is a directory, change to it
        //

        if (strlen (bufCanon) == 2 && bufCanon[1] == ':') {
            bufCanon[2] = '\\';
        }

        if (_chdir (bufCanon) != -1) {
            domessage ("Changed directory to %s", bufCanon);
            return TRUE;
        }

        //
        //  Must be a file.  Create a new internal file for it
        //
        pFileTmp = AddFile (bufCanon);
    }

    //
    //  Bring the found file to the top of the MRU list
    //

    pFileToTop (pFileTmp);

    //
    // if the file is not currently in memory, read it in
    //
    domessage (NULL);

    if (((FLAGS (pFileHead) & (REAL|REFRESH)) == REAL)
        || (fRead = FileRead (pFileHead->pName, pFileHead, TRUE))) {

        //  If we just read in the file AND the file is new then
        //  reset cached location to TOF.
        //
        if (fRead && TESTFLAG (FLAGS (pFileHead), NEW)) {
            YCUR(pInsCur) = 0;
            XCUR(pInsCur) = 0;
        }
        fSyncFile (pFileHead, TRUE);
        cursorfl (pInsCur->flCursorCur);
        fInitFileMac (pFileHead);

        //
        //  Set the window's title
        //
        //char     *p;
        //p = pFileHead->pName + strlen(pFileHead->pName);
        //
        //while ( p > pFileHead->pName && *p != '\\' ) {
        //    p--;
        //}
        //if ( *p == '\\' ) {
        //    p++;
        //}
        //sprintf( bufCanon, "%s - %s", pNameEditor, p );
        //SetConsoleTitle( bufCanon );
        return TRUE;
    }

    // The file was not successfully read in.  Remove this instance and
    // return the indicated error.
    //
    RemoveTop ();

    return FALSE;
}




/*** fInitFileMac - Initialize macros associated with a file
*
*  Sets the curfile family of macros, and attempts to read any extension-
*  specific section from tools.ini.
*
* Input:
*  pFileNew     = File to set information for
*
* Output:
*  Returns TRUE if TOOLS.INI section found, else FALSE
*
*************************************************************************/
flagType
fInitFileMac (
    PFILE   pFileNew
    ) {

    char  fbuf[ 512 ];

    strcpy (fbuf, pFileNew->pName);
    FmtAssign ("curFile:=\"%s\"", DoubleSlashes (fbuf));

    filename (pFileNew->pName, fbuf);
    FmtAssign ("curFileNam:=\"%s\"", fbuf);

    if (!extention (pFileNew->pName, fbuf)) {
        fbuf[0] = '.';
        fbuf[1] = '\0';
    }
    FmtAssign ("curFileExt:=\"%s\"", fbuf);

    return InitExt (fbuf);
}




/*  AddFile - create a named file buffer
 *
 *  Create and initialize a named buffer.  The contents are initially
 *  empty.
 *
 *  p           character pointer to name
 *
 *  returns     file handle to internal file structure
 */
PFILE
AddFile (
    char *p
    ) {

    PFILE pFileTmp;
    PFILE pFileSrch;

#ifdef DEBUG
    /*
     * assert we're not attempting to add a duplicate entry
     */
    for (pFileTmp = pFileHead;
         pFileTmp != NULL;
         pFileTmp = pFileTmp->pFileNext) {

        assert (_stricmp ((char *)(pFileTmp->pName), p));
    }
#endif

    pFileTmp = (PFILE) ZEROMALLOC (sizeof (*pFileTmp));
#ifdef DEBUG
    pFileTmp->id = ID_PFILE;
#endif
    pFileTmp->pName = ZMakeStr (p);

    /*
     * Everything that we explicitly set NULL, we can assume, as LMAlloc init's
     * the allocated PFILE to all nulls.
     *
     *  pFileTmp->pFileNext = NULL;
     *  pFileTmp->cLines = 0;
     *  pFileTmp->refCount = 0;
     *  FLAGS(pFileTmp) = FALSE;
     *  pFileTmp->cUndo = 0;
     */
    pFileTmp->plr      = NULL;
    pFileTmp->pbFile   = NULL;
    pFileTmp->vaColor  = (PVOID)(-1L);
    pFileTmp->vaHiLite = (PVOID)(-1L);
        pFileTmp->vaMarks  = NULL;
    pFileTmp->vaUndoCur = pFileTmp->vaUndoHead = pFileTmp->vaUndoTail = (PVOID)(-1L);

    CreateUndoList (pFileTmp);
    /*
     * Place the file at the end of the pFile list
     */
    if (pFileHead == NULL) {
        pFileHead = pFileTmp;
    } else {
        for (pFileSrch = pFileHead;
             pFileSrch->pFileNext;
             pFileSrch = pFileSrch->pFileNext) {
            ;
        }
        pFileSrch->pFileNext = pFileTmp;
    }

    SetFileType (pFileTmp);

    return pFileTmp;
}




/*  IncFileRef - note a new reference to a file
 */
void
IncFileRef (
    PFILE pFile
    ) {
    pFile -> refCount++;
}





/*  DecFileRef - remove a reference to a file
 *
 *  When the reference count goes to zero, we remove the file from the memory
 *  set
 */
void
DecFileRef (
    PFILE pFileTmp
    ) {
    if (--(pFileTmp->refCount) <= 0) {
        RemoveFile (pFileTmp);
    }
}



/*  FileNameToHandle - return handle corresponding to the file name
 *
 *  FileNameToHandle is used to locate the buffer pointer corresponding to
 *  a specified file.  Short names are allowed.  If the input name is 0-length
 *  we return the current file.
 *
 *  pName       character pointer to name being located.  Case is significant.
 *  pShortName  short name of file.  This may be NULL
 *
 *  Returns     handle to specified file (if found) or NULL.
 */
PFILE
FileNameToHandle (
    char const *pName,
    char const *pShortName
    ) {

    PFILE pFileTmp;

    if (pName[0] == 0) {
        return pFileHead;
    }

    for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext)
        if (!_stricmp (pName, pFileTmp->pName))
            return pFileTmp;

    if ( pShortName != NULL ) {
        for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext) {
            REGISTER char *pFileName = pFileTmp->pName;
            pathbuf nbuf;

            if (filename (pFileName, nbuf) &&
                !_stricmp (nbuf, pShortName)) {
                return pFileTmp;
            }
        }
    }
    //for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext) {
    //REGISTER char *pFileName = pFileTmp->pName;
    //pathbuf nbuf;
    //
    //if (!stricmp (pName, pFileName) ||
    //    (pShortName != NULL &&
    //     filename (pFileName, nbuf) &&
    //         !stricmp (nbuf, pShortName))) {
    //        return pFileTmp;
    //    }
    //}
    return NULL;
}



/*** pFileToTop - make the specified file the top of the current window
*
* Search  the instance list in the current window for the file. If it is
* found, relink it to be the top one. Otherwise, allocate a new instance for
* it  and  place it at the top of the instance list. Also bring the file to
* the top of the pFileHead file list. Ensure that it is on the list to begin
* with.
*
* Input:
*  pFileTmp     = file to bring to top
*
* OutPut:
*  Returns FALSE if the pFile is invalid or NULL
*
*************************************************************************/
flagType
pFileToTop (
    PFILE pFileTmp
    ) {

    EVTargs e;
    PINS    pInsLast        = (PINS) &pInsCur;
    PINS    pInsTmp         = pInsCur;
    PFILE   pFilePrev;

    assert (_pfilechk());
    assert (_pinschk(pInsCur));

    /*
     * if we're about to lose focus, declare it
     */
    if (pFileTmp != pFileHead) {
        e.pfile = pFileHead;
        DeclareEvent (EVT_LOSEFOCUS,(EVTargs *)&e);
    }

    /*
     * Move file to head of file list. Ensure, at the same time, that the file
     * is in fact ON the list, and declare the event if in fact it is moved.
     */
    if (pFileTmp != pFileHead) {
        for (pFilePrev = pFileHead;
                         pFilePrev && (pFilePrev->pFileNext != pFileTmp);
             pFilePrev = pFilePrev->pFileNext ) {
            ;

        }

        if (!pFilePrev) {
            return FALSE;
        }

        pFilePrev->pFileNext = pFileTmp->pFileNext;
        pFileTmp->pFileNext = pFileHead;
        pFileHead = pFileTmp;

        e.pfile = pFileHead;
        DeclareEvent (EVT_GETFOCUS,(EVTargs *)&e);
    }

    /*
     * pFileTmp now points to a file structure for the correct file. Try to find
     * an instance of the file in the current window. If not in the instance
     * list, allocate it. If it is in the instance list, remove it.
     */
    while (pInsTmp != NULL) {
        if (pInsTmp->pFile == pFileTmp) {
            break;
        }
        pInsLast = pInsTmp;
        pInsTmp = pInsTmp->pNext;
    }

    if (pInsTmp == NULL) {
        pInsTmp = (PINS) ZEROMALLOC (sizeof (*pInsTmp));
        pInsTmp->pFile = pFileTmp;
#ifdef DEBUG
        pInsTmp->id = ID_INSTANCE;
#endif
        IncFileRef (pFileTmp);
    } else {
        pInsLast->pNext = pInsTmp->pNext;
    }
    /*
     * Regardless, then, of where it came from, place the new instance back onto
     * the head of the list
     */
    pInsTmp->pNext = pInsCur;
    WININST(pWinCur) = pInsCur = pInsTmp;

    SETFLAG(fDisplay, RCURSOR | RSTATUS);
    newscreen ();

    return TRUE;

}



/*  RemoveTop - removes the top file in the current instance list
 *              If there is no next file, leave
 */
void
RemoveTop (
    void
    ) {
    PINS    pInsTmp = pInsCur;

    WININST(pWinCur) = pInsCur = pInsCur->pNext;
    FREE ((char *) pInsTmp);
    DecFileRef (pFileHead);
    if (pInsCur) {
        pFileToTop (pInsCur->pFile);
    }
}




/*** RemoveFile  - free up all resources attached to a particular file
*
* Purpose:
*
*   To free all memory used to keep track of a file.  If the file still
*   appears in some instance lists, it is removed from them.
*
* Input:
*
*   pFileRem - File in question
*
* Output:
*
*   Returns TRUE.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
RemoveFile (
    PFILE    pFileRem
    ) {

    PFILE pFilePrev = (PFILE) &pFileHead;
    PFILE pFileTmp = pFileHead;

    if (pFileRem->refCount > 0) {
        RemoveInstances (pFileRem);
    }

    while (pFileTmp != pFileRem) {
        pFilePrev = pFileTmp;
        pFileTmp = pFileTmp->pFileNext;
        if (pFileTmp == NULL) {
            IntError ("RemoveFile can't find file");
        }
    }


    /*
     * It's important that pFileNext be the first field in a pfile, and we assert
     * that here. This allows us to not special case pFileHead, but adjust it by
     * treating it as the pFileNext of a non-existant structure.
     */
    assert ((void *)&(pFilePrev->pFileNext) == (void *)pFilePrev);
    pFilePrev->pFileNext = pFileTmp->pFileNext;

    FreeFileVM (pFileTmp);

    FREE (pFileTmp->pName);

#if DEBUG
    pFileTmp->id = 0;
#endif

    FREE ((char *) pFileTmp);

    if (pFileTmp == pFileIni) {
        pFileIni = NULL;
    }
}



/*** RemoveInstances - Remove all instances of a file
*
* Purpose:
*
*  Used by RemoveFile to make sure that there are no file instances
*  referring to a given file
*
* Input:
*  pFile        = File in question
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
RemoveInstances (
    PFILE   pFile
    ) {

    PINS    pIns;
    PINS    pInsPrev;
    PWND    pWndCur;

    for (pWndCur = &WinList[0];
         pWndCur < &WinList[cWin];
         pWndCur++) {

        pInsPrev = NULL;
        pIns = WININST(pWndCur);
        while (pIns) {

            /*
             * assert not an infinite loop
             */
            assert (!pInsPrev || (pIns != WININST (pWndCur)));

            if (pIns->pFile == pFile) {
                if (!pInsPrev) {
                    WININST (pWndCur) = pIns->pNext;
                } else {
                    pInsPrev->pNext = pIns->pNext;
                }
                {
                    PINS pInsTmp = pIns;
                    pIns = pIns->pNext;
                    FREE(pInsTmp);
                }
            } else {
                pInsPrev = pIns;
                pIns = pIns->pNext;
            }
        }
        assert (_pinschk (WININST (pWndCur)));
    }
    //
    // If the resulting instance list for the current window becomes empty,
    // bring up the <untitled> file in it.
    //
    if (!(pInsCur = WININST (pWinCur))) {
        fChangeFile (FALSE, RGCHUNTITLED);
    }
}




/*  fSyncFile - Attempt to make logical file and physical file the same
 *
 *  When editing in a network or multi-tasking environment, we need to make
 *  sure that changes made underneath us are properly reflected to the
 *  user.  We do this by snapshotting the time-of-last-write and periodically
 *  comparing it with the version on disk.  When a mismatch is found, we
 *  prompt the user and give him the opportunity to reread the file
 *
 *  pFileLoc    file structure of interest
 *  fPrompt     TRUE => prompt user for permission to refresh, else just
 *              refresh.
 *
 *  returns     TRUE iff the logical file and the physical file are the same.
 */
flagType
fSyncFile (
    PFILE pFileLoc,
    flagType fPrompt
    ) {
    if (pFileLoc == NULL) {
        pFileLoc = pFileHead;
    }

    switch (FileStatus (pFileLoc, NULL)) {

    case FILECHANGED:
        if (fPrompt) {
            if (!confirm ("%s has been changed.  Refresh? ", pFileLoc->pName)) {
                /* No, validate this edit session */
                SetModTime (pFileLoc);
                return FALSE;
            }
        }
        FileRead (strcpy( buf, pFileLoc->pName ), pFileLoc, TRUE);
        RSETFLAG (FLAGS (pFileLoc), DIRTY);
        SETFLAG (fDisplay, RSTATUS);
        return TRUE;

    case FILEDELETED:
        domessage ("File has been deleted");
        break;

    default:
        break;

    }
    return TRUE;
}




/*  FileStatus - compare logical info about a file with file on disk
 *
 *  Compare the last modified time with the last snapshot.  If the filename
 *  contains metachars, the file is not believed to have changed.  Further, if
 *  the file is a pseudo file, it cannot have changed.
 *
 *  pFile       file of interest (contains mod time)
 *  pName       name of file to examine (when writing to diff. name)
 *
 *  returns     FILECHANGED if timestamps differ
 *              FILEDELETED if file on disk does not exist
 *              FILESAME    if timestamps are the same
 */
int
FileStatus (
    PFILE pFile,
    char *pName
    ){

    time_t modtime;

    if (TESTFLAG(FLAGS(pFile),FAKE)) {
        return FILESAME;
    }

    if (pName == NULL) {
        pName = pFile->pName;
    }

    if (*strbscan (pName, "?*") != 0) {
        return FILESAME;
    }

    if ((modtime = ModTime (pName)) == 0L) {
        return FILEDELETED;
    }

    if (pFile->modify != modtime) {
        return FILECHANGED;
    }

    return FILESAME;
}




/*  SetModTime - Snapshot a file's last-modification time
 *
 *  pFile       file of interest
 */
void
SetModTime (
    PFILE pFile
    ) {
    pFile->modify = ModTime (pFile->pName);
}



/*  ModTime - Return the time of last modification for a file
 *
 *  If the file does not exist or contains meta chars, return 0 as the time-
 *  stamp.
 *
 *  pName       character pointer to file name
 *
 *  Returns     last modification time of file.
 */

time_t
ModTime (
    char *pName
    ) {

    struct _stat statbuf;

    if (*strbscan (pName, "?*")) {
        return 0L;
    }

    if (_stat (pName, &statbuf) == -1) {
        return 0L;
    }

    return statbuf.st_mtime;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\fileio.c ===
/*** fileio.c - perform low-level file input and output
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/
#include "mep.h"

#include <rm.h>

int fdeleteFile( char *p );

/*  Large-buffer I/O routines
 *
 *  It is best for Z to read in data in large blocks.  The fewer times we
 *  issue system calls, the better.  The VM code has conveniently allocated
 *  us some large amount of space for us.  All we need to do is maintain
 *  a pointer to the next characters to read/write and a count of the number
 *  of characters in the buffer
 *
 *  The data structures used are:
 *
 *      char *getlbuf;
 *          This is a long pointer to the beginning of the buffer.
 *      char *getlptr;
 *          This is a long pointer to the next char position in the buffer.
 *      unsigned int getlsize;
 *          This is the length of the buffer in bytes.
 *
 *  The routines provided to access this are:
 *
 *      zputsinit ();
 *          Initializes for subsequent zputs's.
 *      zputs (buf, len, fh);
 *          Writes out from buf length len using getlbuf and fh.
 *          Returns EOF if no more room.
 *      zputsflush (fh);
 *          Flushes out the buffer.  Returns EOF if no more room.
 */

char         *getlbuf   = NULL;
char        *getlptr    = NULL;
// unsigned int    getlsize    = 0;
unsigned int    getlc       = 0;

// BUGBUG
//  FileExists is used because of problems with stat() and
//  FindFirstFile() which are not easily reproducible.
flagType FileExists (char  *path );

// BUGBUG
//  MepMove is used because FAT does not provide rename functionality
#define rename  MepMove
int MepMove ( char *oldname,   char *newname);



/*  zputsinit - initialize for future zputs's
 *
 *  Set next-char pointer to beginning.  Set count of chars to 0
 */
void
zputsinit (
    void
    )
{
    getlptr = getlbuf;
    getlc = 0;
}





/*** zputs - output a string
*
* Input:
*  p            = character pointer to data to be output
*  len          = number of bytes to output
*  fh           = DOS file handle to use
*
* Output:
*  Returns EOF if out-of-space
*
*************************************************************************/
int
zputs (
    char        *p,
    int         len,
    FILEHANDLE  fh
    )
{
    REGISTER unsigned int c;

    while (len != 0) {
        c = len;
        if (c > (unsigned)(getlsize-getlc)) {
            c = (unsigned)(getlsize-getlc);
        }
        memmove (getlptr, (char*)p, c);
        len -= c;
        getlptr += c;
        getlc += c;
        p += c;
        if (getlc == getlsize) {
            if (zputsflush (fh) == EOF) {
                return EOF;
            }
        }
    }
    return !EOF;
}





/*** zputsflush - dump out buffered data
*
* Input:
*  fh           = DOS file handle to use for output
*
* Output:
*  Returns EOF if disk full
*
*************************************************************************/
int
zputsflush (
    FILEHANDLE     fh
    )
{

    ULONG   bytesWritten;

    // rjsa DosWrite (fh, getlbuf, getlc, &bytesWritten);
    bytesWritten = MepFWrite(getlbuf, getlc, fh);
    if (bytesWritten != getlc) {
        return EOF;
    }
    zputsinit ();
    return !EOF;
}





/* ReestimateLength - reestimate the length of a file based on
 * the current file position and length in bytes
 */
void
ReestimateLength (
    PFILE       pFile,
    FILEHANDLE  fh,
    long        len
    )
{
    LINE avg;

    if (pFile->cLines == 0) {
        avg = 400;
    } else {
        avg = (MepFSeek (fh, 0L, FROM_CURRENT) - getlc) / pFile->cLines;
        avg = len / avg;
    }

    growline (avg + 1, pFile);
}





/* read lines from the specified handle.
 */
LINE
readlines (
    PFILE       pFile,
    FILEHANDLE  fh
    )
{
    LINE    line        = 0;            /* line number being read in          */
    long    bufpos      = 0L;           /* position of beg of buffer in file  */
    unsigned int buflen = 0;            /* number of bytes of data in buffer  */
    long    cbFile;                     // length of file
    char    *pb;


    cbFile = MepFSeek(fh, 0L, FROM_END);

    MepFSeek (fh, 0L, FROM_BEGIN);

    pFile->pbFile = MALLOC (cbFile);

    if ( pFile->pbFile == NULL ) {
        //
        //      No heap space, cannot read file
        //
        disperr (MSGERR_NOMEM);
        return -1;
    }

    //  Assume a non-dos file until we see a CR-LF.
    RSETFLAG (FLAGS (pFile), DOSFILE);

    //  Read entire file into buffer and set up for scan
    buflen = MepFRead (pFile->pbFile, cbFile, fh);
    pb = pFile->pbFile;

    //  Loop, while there's more data to parse
    while (buflen != 0) {
        LINEREC vLine;                  // line record of current line
        REGISTER int iCharPos = 0;      // logical line length (tabs expanded)

        vLine.cbLine   = 0;
        vLine.vaLine   = (PVOID)pb;
        vLine.Malloced = FALSE;

        //  Loop, processing each character in the line
        //
        //  Special char handling is as follows:
        //  0.  Lines are broken at end of input
        //  1.  Lines are broken when they overflow line buffers
        //  2.  Lines are broken at \n's or \r\n's.
        //  3.  Lines are broken at \0's since the editor relies on asciiz
        //  4.  Embedded \r's are retained.

        while (TRUE) {
            int c;                      // char being processed

            //  if no more data, break current line.
            if (buflen == 0)
                break;

            //  if \n or \0 then eat it and break current line
            if (pb[0] == '\n' || pb[0] == '\0') {
                pb++;
                buflen--;
                break;
                }

            //  if \r\n then eat them and break current line
            if (pb[0] == '\r' && buflen > 1 && pb[1] == '\n') {
                pb += 2;
                buflen -= 2;
                SETFLAG (FLAGS (pFile), DOSFILE);
                break;
                }

            //  if no more room to expand in a buffer, break current line
            if (iCharPos >= sizeof (linebuf)-1)
                break;

            //  Get current character
            c = *pb++;
            buflen--;

            //  We have a character that we allow in the
            //  line.  Advance length of logical line.
            if (c != 0x09)
                iCharPos++;
            else {
                //  Expand a tab to the next logical position
                iCharPos += 8 - (iCharPos & 7);

                //  if the tab causes overflow in the line length
                //  back up over the tab and break the line
                if (iCharPos >= sizeof(linebuf)-1) {
                    pb--;
                    buflen++;
                    break;
                }
            }

            //  Advance length of physical line
            vLine.cbLine++;
        }

        //  If the user halted reading the file in, undo everything
        if (fCtrlc) {
            FlushInput ();
            DelFile (pFile, FALSE);
            return -1;
        }

        //  Give the user feedback about our progress
        noise (line);

        //  If we're within 10 lines of the end of the line array then
        if (line >= pFile->lSize-10) {
            LINE avg;
            //  reestimate the number of lines

            if (pFile->cLines == 0)
                //  Assume 400 lines if the file is now empty
                avg = 400;
            else {
                //  compute average line length so far
                avg = (int)(pb - pFile->pbFile) / pFile->cLines;

                //  extrapolate number of lines in entire file from this
                //  average
                avg = cbFile / avg;
            }
            growline (avg + 1, pFile);
        }

        if (pFile->cLines <= line) {
            growline (line+1, pFile);
            pFile->cLines = line+1;
        }

        pFile->plr[line++] = vLine;
    }

    if (line == 0)
        SETFLAG (FLAGS (pFile), DOSFILE);

    RSETFLAG (FLAGS(pFile), DIRTY);
    newscreen ();
    return line;
}





/*** FileRead - read in a file
*
*  The file structure is all set up; all that needs to be done is to fill in
*  the lines parts. We delete everything currently in the file. If the file
*  is designated as a pseudo file (first char is a <), then we go and check
*  for the specially named files. Otherwise we try to read in the file. If
*  that fails, and we can, we try to create it. If everything fails, we
*  return FALSE.
*
* Input:
*  name         = pointer to file name to read
*  pFile        = file structure to read the file into.
*  fAsk         = TRUE -> ask to create if it doesn't exist
*
* Output:
*  Returns TRUE on read in.
*  Modifies global fUserCanceledRead
*
* Notes:
*  Hack (terrible one): Under CW, FileRead sets fUserCanceledRead anytime
*  there has been an attempt to read a non existent file AND the user
*  has been prompted for file creation AND the user canceled the operation
*
*  This is used by fFileAdvance (ZEXIT.C) and ReadStateFile (STATFILE.C)
*
*************************************************************************/
flagType
FileRead (
    char    *name,
    PFILE   pFile,
    flagType fAsk
    )
{

    EVTargs     e;
    FILEHANDLE  fh;
    flagType    fNew = FALSE;
    char        *n;
    buffer      Buf;

    assert (pFile);


    e.pfile = pFile;
    e.arg.pfn = (char *)name;
    if (DeclareEvent (EVT_FILEREADSTART, (EVTargs *)&e)) {
        return TRUE;
    }

    if (!mtest ()) {
        dispmsg (MSG_NEXTFILE, name);
    }

    /* process special names */
    if (*name == '<') {
        fNew = LoadFake (name, pFile);
        DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
        return fNew;
    }

    DelFile (pFile, FALSE);

    if (*strbscan (name, "?*") != 0) {
        fNew = LoadDirectory (name, pFile);
        DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
        return fNew;
    }

    if ((fh = MepFOpen (name, ACCESSMODE_READ, SHAREMODE_RW, FALSE)) == NULL) {
        if (!fAsk) {
            DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
            return FALSE;
        }
        if (!confirm ("%s does not exist. Create? ", name)) {
            DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
            return FALSE;
        }
        if ((fh = MepFOpen (name, ACCESSMODE_WRITE, SHAREMODE_RW, TRUE)) == NULL) {
            n = name;
            if ( strlen(name) > 20 ) {
                strcpy( Buf, name + strlen(name)-20);
                Buf[0] = Buf[1] = Buf[2] = '.';
                n = Buf;
            }
            disperr (MSGERR_NOCREAT, n, error ());
            DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
            return FALSE;
        }
        SETFLAG (FLAGS (pFile), NEW);
        fNew = TRUE;
    }

    if (fNew) {
        PutLine((LINE)0, RGCHEMPTY, pFile);
        SETFLAG (FLAGS (pFile), DOSFILE);
    } else if (readlines (pFile, fh) == -1)  {
        DoCancel();
        MepFClose (fh);
        DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
        return FALSE;
    }

    MepFClose (fh);
    SETFLAG (FLAGS(pFile), REAL);
    RSETFLAG (FLAGS(pFile), READONLY);

    if (fReadOnly (name)) {
        SETFLAG (FLAGS(pFile), DISKRO);
        if (!fEditRO) {
            SETFLAG (FLAGS(pFile), READONLY);
        }
    } else {
        RSETFLAG (FLAGS(pFile), DISKRO);
    }

    SetModTime (pFile);
    CreateUndoList (pFile);
    (void)fReadMarks (pFile);

    DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);

    return TRUE;
}





/*  fReadOnly - see if a file is read-only
 *
 *  p           full name of file
 *
 *  Returns:    TRUE iff file is read only
 */
flagType
fReadOnly (
    char *p
    )
{

    DWORD   Attr;

    Attr = GetFileAttributes(p);

    if ( Attr != -1 && (Attr & FILE_ATTRIBUTE_READONLY) != 0)
        return TRUE;
    else
        return FALSE;
}


int
__cdecl
ZFormatArgs (REGISTER char * Buf, const char * Format, ...)
{
    va_list arglist;
    int result;

    va_start (arglist, Format);
    result = ZFormat (Buf, Format, arglist);
    va_end (arglist);
    return result;
}

/*** FileWrite - Write file to disk
*
*  Writes out the specified file. If no name was given then use the name
*  originally assigned to the file; else use the given name. We start by
*  writing to a temp file (extention .$). If this succeeds, we fdelete the
*  source (for undeleteability) and rename the temp to the source.
*
* Input:
*  savename     = name to save as.
*  pFile        = file to be saved
*
* Returns:
*
*************************************************************************/
flagType
FileWrite (
    char    *savename,
    PFILE   pFile
    )
{

    EVTargs     e;
    FILEHANDLE  fh;                            /* file handle for output       */
    LINE        i;
    int         len, blcnt;
    pathbuf     fullname, tmpname;
    char        linebuffer[sizeof(linebuf) + 2];
    char        *p;
    PCMD        pCmd;
    flagType    fNewName  = FALSE;
    char        *fileEOL;
    int         cbfileEOL;

    //
    //  If we are trying to save a FAKE file with a <name>,
    //  we call SaveFake for special processing.
    //

    if (TESTFLAG (FLAGS(pFile), FAKE) && !savename &&
        (pFile->pName[0] == '\0' || pFile->pName[0] == '<')) {
        return SaveFake (pFile->pName, pFile);
    }

    //if (TESTFLAG (FLAGS(pFile), FAKE) && savename &&
    //(savename[0] == '\0' || savename[0] == '<'))
    //    return SaveFake (savename, pFile);

    //
    //  get a canonical form of the output file name.  If no name was
    //  input, use the name in the file itself
    //

    if (!savename || !*savename) {
        strcpy (fullname, pFile->pName);
    } else  if (rootpath (savename, fullname)) {
        return disperr (MSGERR_OPEN, savename, "");
    }

    savename = fullname;

    //
    // See if it is a directory.  If so, we cannot save to it.
    //

    {
        DWORD att = GetFileAttributes (fullname);

        if (att != -1 && TESTFLAG (att, FILE_ATTRIBUTE_DIRECTORY))
        return disperr (MSGERR_SAVEDIR, fullname);
    }

    //
    //  If the file is read-only, display a message and let the user direct
    //  us to use the readonly program to rectify it.
    //

    if (fReadOnly (fullname)) {
        disperr (MSGERR_RONLY, fullname);
        if (ronlypgm != NULL) {
            if (strstr (ronlypgm, "%s") != NULL) {
                fileext (fullname, buf);
                sprintf (tmpname, ronlypgm, buf);
                }
            else
                ZFormatArgs (tmpname, ronlypgm, fullname);
            if (confirm("Invoke: \"%s\" (y/n)?", tmpname))
                if (zspawnp (tmpname, TRUE))
                    SetModTime (pFile);
            }

        //
        //  We've given the user one chance to fix the read-onlyness of the
        //  file.  We now prompt him until he gives us a writeable name or
        //  cancels.
        //
    if ( !savename || !*savename ) {
        strcpy( tmpname, pFile->pName );
    } else {
        strcpy( tmpname, savename );
    }
    //tmpname[0] = '\0';
    while (fReadOnly (fullname)) {

        pCmd = getstring (tmpname, "New file name: ", NULL,
                              GS_NEWLINE | GS_INITIAL | GS_KEYBOARD);

            if ( pCmd == NULL || (PVOID)pCmd->func == (PVOID)cancel)
                return FALSE;

            CanonFilename (tmpname, fullname);

            if (!TESTFLAG(FLAGS(pFile), FAKE))
                fNewName = TRUE;
            }
        }

    //
    //  fullname is the name of the file we are writing
    //

    upd (fullname, ".$", tmpname);

    //
    //  Send notification about the beginning of the write operation
    //

    e.pfile = pFile;
    e.arg.pfn = (char *)savename;
    if (DeclareEvent (EVT_FILEWRITESTART, (EVTargs *)&e))
        return TRUE;


    if (!(fh = MepFOpen(tmpname, ACCESSMODE_RW, SHAREMODE_READ, FALSE))) {
        if (!(fh = MepFOpen(tmpname, ACCESSMODE_RW, SHAREMODE_READ, TRUE))) {
            disperr (MSGERR_OPEN, tmpname, error ());
            DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
            return FALSE;
        }
    }

    dispmsg (MSG_SAVING, fullname);
    blcnt = 0;
    zputsinit ();
    fileEOL = TESTFLAG (FLAGS (pFile), DOSFILE) ? "\r\n" : "\n";
    cbfileEOL = strlen (fileEOL);

    for (i = 0; i < pFile->cLines; i++) {

        /*
         * always get the RAW line for output. No tab conversions here.
         */

        len = gettextline (TRUE, i, linebuffer, pFile, ' ');

        if (!mtest ()) {
            noise (i);
        }

        if (fCtrlc) {
            DoCancel();
            MepFClose (fh);
            _unlink (tmpname);
            DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
            return FALSE;
        }

        if (len) {
            while (blcnt--) {
                if (zputs (fileEOL, cbfileEOL, fh) == EOF) {
                    if (!fCtrlc) {
                        disperr (MSGERR_SPACE, tmpname);
                    } else {
                        FlushInput ();
                    }
                    MepFClose (fh);
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    return FALSE;
                }
            }
            blcnt = 0;
            if (zputs (linebuffer, len, fh) == EOF ||
                zputs (fileEOL, cbfileEOL, fh) == EOF) {

                if (!fCtrlc)
                    disperr (MSGERR_SPACE, tmpname);
                else
                    FlushInput ();
                MepFClose (fh);
                _unlink (tmpname);
                DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                return FALSE;
            }
        } else {
            blcnt++;
        }
    }

    if (zputsflush (fh) == EOF) {

        if (!fCtrlc) {
            disperr (MSGERR_SPACE, tmpname);
        } else {
            FlushInput ();
        }

        MepFClose (fh);
        _unlink (tmpname);
        DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
        return FALSE;
    }

    MepFClose (fh);

    /* fullname     NAME.EXT
     * tmpname      NAME.$
     * buf          temp buffer
     */
    rootpath (fullname, buf);
    strcpy (fullname, buf);

    /* fullname     full NAME.EXT
     * tmpname      NAME.$
     * buf          temp buffer
     */
    if (!_strcmpi (fullname, pFile->pName) && TESTFLAG (FLAGS (pFile), NEW)) {
        if (_unlink (fullname) == -1) {
            fileext (fullname, fullname);
            disperr (MSGERR_DEL, fullname, error ());
            _unlink (tmpname);
            DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
            return FALSE;
            }
        }
    else {
        switch (backupType) {

        case B_BAK:
            upd (fullname, ".bak", linebuffer);
            /* foo.bar => foo.bak */
            if (_unlink (linebuffer) == -1) {
                p = error ();
                if (FileExists(linebuffer)) {
                    fileext (linebuffer, linebuffer);
                    disperr (MSGERR_DEL, linebuffer, p);
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    return FALSE;
                }
            }
            if (rename (fullname, linebuffer) == -1) {
                p = error ();
                if (FileExists(fullname)) {
                    disperr (MSGERR_REN, fullname, linebuffer, p);
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    return FALSE;
                }
            }
            break;

        case B_UNDEL:
            /* remove foo.bar */
            i = fdeleteFile (fullname);
            if (i && i != 1) {
                _unlink (tmpname);
                DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                return disperr (MSGERR_OLDVER, fullname);
            }

        case B_NONE:
            if (_unlink (fullname) == -1) {
                p = error ();
                if (FileExists(fullname)) {
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    fileext (fullname, fullname);
                    return disperr (MSGERR_DEL, fullname, p);
                    }
                }
            }
        }

    if (rename (tmpname, fullname) == -1) {
        disperr (MSGERR_REN, tmpname, fullname, error ());
        _unlink (tmpname);
        DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
        return FALSE;
    }

    RSETFLAG (FLAGS (pFile), NEW);

    if (!_strcmpi (savename, pFile->pName) || fNewName) {
        if (fNewName) {
            /*
             * We gave a new name to this file and successfully saved it:
             * this becomes the new file's name
             */
            FREE (pFile->pName);
            pFile->pName = ZMakeStr (fullname);
        }
        RSETFLAG (FLAGS(pFile), (DIRTY | DISKRO));
        SETFLAG (fDisplay,RSTATUS);
        SetModTime( pFile );
    }

    WriteMarks (pFile);
    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);

    return TRUE;
}




/* fdeleteFile - Remove file the way RM does it - checks for undelcount
 *
 *      This code is extracted from Ztools. the only difference being that this
 *      checks for undelcount so our deleted stuff don't grow without bounds
 *
 * The delete operation is performed by indexing the file name in a separate
 * directory and then renaming the selected file into that directory.
 *
 * Returns:
 *
 *  0 if fdelete was successful
 *  1 if the source file did not exist
 *  2 if the source was read-only or if the rename failed
 *  3 if the index was not accessable
 */
int
fdeleteFile(
        char *p
    )
{
        char dir[MAXPATHLEN];                   /* deleted directory            */
        char idx[MAXPATHLEN];                   /* deleted index                        */
        char szRec[MAXPATHLEN];                 /* deletion entry in index      */
        char recbuf[MAXPATHLEN];
        int attr, fhidx;
        int errc;
        int count,c;

    fhidx = -1;

        //
        //      See if the file exists
        //
        if( ( attr = GetFileAttributes( p ) ) == -1) {
                errc = 1;
                goto Cleanup;
        }

        //
        //      What about read-only files?
        //
        if (TESTFLAG (attr, FILE_ATTRIBUTE_READONLY)) {
                errc = 2;
                goto Cleanup;
        }

        //
        //      Form an attractive version of the name
        //
    pname (p);

        //
        // generate deleted directory name, using defaults from input file
        //
    upd (p, RM_DIR, dir);

        //
        //      Generate index name
        //
    strcpy (idx, dir);
    pathcat (idx, RM_IDX);

        //
        // make sure directory exists (reasonably)
        //
        if( _mkdir (dir) == 0 ) {
                SetFileAttributes(dir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }

        //
        // extract filename/extention of file being deleted
        //
    fileext (p, szRec);

        //
        // try to open or create the index
        //
    if ((fhidx = _open (idx, O_CREAT | O_RDWR | O_BINARY,
                           S_IWRITE | S_IREAD)) == -1) {
                errc = 3;
                goto Cleanup;
        }

        if (!convertIdxFile (fhidx, dir)) {
                errc = 3;
                goto Cleanup;
    }

        //
        // scan the index and count how many copies of this file already exist
        //
        for (count=c=0; readNewIdxRec( fhidx, recbuf, c++ ); ) {
                if ( !strcmp( szRec, recbuf )) {
                        count++;
                }
        }

    if (count < cUndelCount) {

                //
                //      Determine new name
                //
                sprintf (strend (dir), "\\deleted.%03x",
                         _lseek (fhidx, 0L, SEEK_END) / RM_RECLEN);

                //
                //      Move the file into the directory
                //
                _unlink (dir);

                if (rename(p, dir) == -1) {
                        errc = 2;
                        goto Cleanup;
                }

                //
                //      Index the file
                //
                if (!writeNewIdxRec (fhidx, szRec)) {
                        rename( dir, p );
                        errc = 2;
                        goto Cleanup;
                }
        } else {

                char buf1[MAXPATHLEN], buf2[MAXPATHLEN], *p1;

                strcpy (buf1, dir);
                strcat (buf1, "\\deleted.");
                p1 = strend (buf1);
                *buf2 = 0;

                if (_lseek( fhidx, 0L, SEEK_SET ) == -1) {
                    errc = 2;
                    goto Cleanup;
                }

                for ( count=c=0; readNewIdxRec( fhidx, recbuf, c++ ); count++ ) {
                        if (!strcmp ( szRec, recbuf)) {
                                sprintf (p1, "%03x", count);
                if (! *buf2) {
                                        _unlink (buf1);
                } else {
                    rename (buf1, buf2);
                }
                                strcpy (buf2, buf1);
            }
        }
                rename (p, buf2);
        }

        errc = 0;

Cleanup:
        if ( fhidx != -1 ) {
                _close(fhidx);
        }

        return errc;
}




/*  SetBackup - assign the mode of file backup
 *
 *  This is called during initialization to set the backup type
 *
 *  val         char pointer to "undel", "none", "bak"
 *
 *  If any errors are found, SetBackup will return FALSE otherwise it returns
 *  TRUE.
 */
char *
SetBackup (
    char *val
    )
{
    buffer  bufLocal = {0};

    strncat ((char *) bufLocal, val, sizeof(bufLocal)-1);
    _strlwr (bufLocal);

    if (!strcmp (bufLocal, "undel")) {
        backupType = B_UNDEL;
    } else if (!strcmp (bufLocal, "bak")) {
        backupType = B_BAK;
    } else if (!strcmp (bufLocal, "none")) {
        backupType = B_NONE;
    } else {
        return "Backup type must be one of 'undel', 'bak or 'none'";
    }

    return NULL;
}





/*  SetFileTab - set the spacing of tab characters in the file
 *
 *  This is called during initialization to set the number of spaces per
 *  file tab character for output display.  This is for people
 *  who presume that 0x09 is not on 8-character boundaries.  The legal
 *  range for this value is 1-8.
 *
 *  val         char pointer to remainder of assignment
 *
 *  If any errors are found, SetFileTab will return FALSE, otherwise it returns
 *  TRUE.
 */
char *
SetFileTab (
    char *val
    )
{
    int i;
    buffer tmpval = {0};

    strncat ((char *) tmpval, val, sizeof(tmpval)-1);

    i = atoi (tmpval);

    if (i < 1 || i > 8) {
        return "filetab: Value must be between 1 and 8";
    }

    fileTab = i;
    newscreen ();
    return NULL;
}





/*  SetROnly - set the read-only program
 *
 *  This is called during initialization to set the program called when
 *  trying to write a read-only program.
 *
 *  val         char pointer to remainder of assignment
 *
 *  If any errors are found, SetROnly will return FALSE, otherwise it returns
 *  TRUE.
 */
flagType
SetROnly (
    char *pCmd
    )
{

    if (ronlypgm != NULL)
        FREE (ronlypgm);

    if (strlen (pCmd) != 0)
        ronlypgm = ZMakeStr (pCmd);
    else
        ronlypgm = NULL;

    return TRUE;
}





/*  SortedFileInsert - take the passed in line and insert it into the file
 *
 *  pFile       file for insertion
 *  pStr        pointer to string
 */
void
SortedFileInsert (
    PFILE pFile,
    char *pStr
    )
{
    linebuf L_buf;
    LINE    hi, lo, mid;
    int     d;

    hi = pFile->cLines-1;
    lo = 0;

    while (lo <= hi) {
        mid = (hi + lo) / 2;
        GetLine (mid, L_buf, pFile);
        d = strcmp (pStr, L_buf);
        if (d < 0) {
            hi = mid - 1;
        } else if (d == 0) {
            return;
        } else {
            lo = mid + 1;
        }
    }

    /*  lo is the line # for insertion
     */
    InsertLine (lo, pStr, pFile);
}





struct ldarg {
    PFILE pFile;
    int   linelen;
    };


/*  LoadDirectoryProc - take enumerated file and place into file
 *
 *  szFile      pointer to file name to place into file
 *  pfbuf       pointer to find buffer
 *  pData       pointer to data for insertion
 */
void
LoadDirectoryProc (
    char * szFile,
    struct findType *pfbuf,
    void *pData
    )
{
    struct ldarg *pldarg = (struct ldarg *)pData;

    pldarg->linelen = max (pldarg->linelen, (int)strlen(szFile));
    SortedFileInsert (pldarg->pFile, szFile);

    pfbuf;
}





/*  LoadDirectory - load the matching contents of the name into a fake file.
 *
 *  name        matching pattern for files
 *
 *  Returns:    TRUE always
 */

static char szNoMatchingFiles[] = "No matching files";

flagType
LoadDirectory (
    char *fname,
    PFILE pFile
    )
{
    struct ldarg ldarg;

    ldarg.linelen = 0;
    ldarg.pFile = pFile;

    /*  Make sure undo believes that this file is fake.
     */
    SETFLAG (FLAGS(pFile), FAKE + REAL);

    /*  We walk the matching files, entering the names into the file one at
     *  a time in sorted order and, at the same time, determine the max string
     *  length.
     *  We then use CopyBox to collapse the file.
     */

    /*  Enumerate all lines into file
     */
    forfile ((char *)fname, A_ALL, LoadDirectoryProc, &ldarg);

    /*  If file is empty, note it
     */
    if (pFile->cLines == 0) {
        AppFile (szNoMatchingFiles, pFile);
    } else {

        /*  File is pFile->cLines long with a max line len of
         *  ldarg.linelen.  Since we are gathering the thing in columns
         *  we will have pwinCur->xSize / (ldarg.linelen + 2) columns, each of
         *  which will have pFile->cLines / # cols lines.
         */
        int ccol;
        LINE cline, i;

        ccol = max (WINXSIZE(pWinCur) / (ldarg.linelen + 2), 1);
        cline = (pFile->cLines + ccol - 1) / ccol;
        ldarg.linelen = WINXSIZE(pWinCur) / ccol;

        /*  Now, for each of the columns, copy them into position.  Remember
         *  that one column is ALREADY in position.
         */
        for (i = 1; i < ccol; i++) {
            /*  copy lines cline..2*cline - 1
             *  columns 0..ldarg.linelen  to
             *  line 0, column ldarg.linelen*i
             */
            CopyBox (pFile, pFile, 0,                       cline,
                                   ldarg.linelen-1,         2 * cline - 1,
                                   ldarg.linelen * (int) i, (LINE)0);
            DelLine (TRUE, pFile, cline, 2 * cline - 1);
        }
    }
    RSETFLAG (FLAGS(pFile), DIRTY);
    return TRUE;
}





/*  LoadFake - load a fake or pseudo file into memory.  Fake files are used
 *  for two purposes:  as temporary buffers or for information displays.
 *
 *  name        name of pseudo file
 *
 *  Returns:    TRUE always.
 */
flagType
LoadFake (
    char *name,
    PFILE pFile
    )
{
    SETFLAG (FLAGS(pFile), FAKE | REAL | REFRESH | DOSFILE);
    if (!strcmp (name, rgchInfFile)) {
        showinf (pFile);
    } else if (!strcmp (name, rgchAssign)) {
        showasg (pFile);
    } else if (!strcmp (name, "<environment>")) {
        showenv (pFile);
    } else {
         RSETFLAG (FLAGS(pFile), REFRESH);
    }
    return TRUE;
}




/*** SaveFake - "Save" a pseudo-file.  Meaning depends on file
*
* Purpose:
*
*   In some cases, "saving" a pseudo-file means something.  Currently
*   we have:
*
*       <assign> - Update changed lines to TOOLS.INI.
*
* Input:
*   savename -
*   pFile    -
*
* Output:
*
*   Returns TRUE if file was saved, FALSE if not
*
*************************************************************************/
flagType
SaveFake (
    char * savename,
    PFILE pFile
    )
{
    struct  lineAttr rnBuf[10];
    LINE    l;

    if (!_stricmp (pFile->pName, rgchAssign)) {
        for (l = 0; l < pFile->cLines; l++) {
            if (GetColor (l, rnBuf, pFile)) {
                GetLine (l, buf, pFile);
                UpdToolsIni (buf);
                DelColor (l, pFile);
                redraw (pFile, l, l);
            }
        }
    } else {
        return FALSE;
    }

    return TRUE;

    savename;
}





/*** SaveAllFiles - Find all dirty files and save them to disk
*
* Purpose:
*
*   To save all dirty files, of course.
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
SaveAllFiles (
    void
    )
{
    PFILE pFile;
    int i;

    i = 0;
    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if ((FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY) {
            FileWrite (NULL, pFile);
            i++;
            }
        }

    domessage ("Save %d files", i);

}




FILEHANDLE
MepFOpen (
    LPBYTE      FileName,
    ACCESSMODE  Access,
    SHAREMODE   Share,
    BOOL        fCreate
    )
{
    FILEHANDLE  Handle;

    Handle = CreateFile(FileName, Access, Share, NULL, OPEN_EXISTING, 0, NULL);
    if ((Handle == INVALID_HANDLE_VALUE) && fCreate) {
        Handle = CreateFile(FileName, Access, Share, NULL, CREATE_NEW,
                             FILE_ATTRIBUTE_NORMAL, NULL);
    }
    if (Handle == INVALID_HANDLE_VALUE) {
        return (HANDLE)0;
    } else {
        return Handle;
    }
}




void
MepFClose (
    FILEHANDLE Handle
    )
{
    CloseHandle(Handle);
}



DWORD
MepFRead (
    PVOID       pBuffer,
    DWORD       Size,
    FILEHANDLE  Handle
    )
{
    DWORD BytesRead;
    if ( !ReadFile(Handle, pBuffer, Size, &BytesRead, NULL) ) {
        return 0;
    } else {
        return BytesRead;
    }
}




DWORD
MepFWrite (
    PVOID       pBuffer,
    DWORD       Size,
    FILEHANDLE  Handle
    )
{
    DWORD BytesWritten;

    if ( !WriteFile(Handle, pBuffer, Size, &BytesWritten, NULL) ) {
        return 0;
    } else {
        return BytesWritten;
    }
}


DWORD
MepFSeek (
    FILEHANDLE  Handle,
    DWORD       Distance,
    MOVEMETHOD  MoveMethod
    )
{
    assert (Handle != INVALID_HANDLE_VALUE);
    return SetFilePointer(Handle, Distance, NULL, MoveMethod);
}






flagType
FileExists (
    char    *path
    )
{
    return (flagType)((GetFileAttributes(path) == -1) ? FALSE : TRUE);
}


//
//  rename may be defined as MepMove, but now we want the real one, so
//  we undefine it.
//
#ifdef rename
#undef rename
#endif

int MepMove (
     char *oldname,
     char *newname
    )
{
    #define BUFFERSIZE (1024 * 32)

    FILE    *fhSrc, *fhDst;
    void    *buffer;
    size_t  BytesRead;
    size_t  BytesWritten;


    if (FileExists (newname)) {
        return -1;
    }

    //
    //  First, try the rename
    //
    if (rename(oldname, newname) == 0) {
        return 0;
    }

    //
    //  Cannot rename, try to copy
    //
        if (!(fhSrc = fopen(oldname, "r"))) {
                return -1;
        }

        if (!(fhDst = fopen(newname, "w"))) {
                fclose(fhSrc);
                return -1;
        }

    buffer = MALLOC(BUFFERSIZE);
    if ( !buffer ) {
        disperr (MSGERR_NOMEM);
        return -1;
    }

    do {
        BytesRead       = fread(buffer, 1, BUFFERSIZE, fhSrc);
        if (BytesRead) {
            BytesWritten    = fwrite(buffer, 1, BytesRead, fhDst);
        }

    } while (BytesRead);

    fclose(fhSrc);
    fclose(fhDst);

    FREE(buffer);

    return _unlink(oldname);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\insert.c ===
/*  sinsert.c - stream insert of characters
 *
 *  Modifications:
 *
 *	26-Nov-1991 mz	Strip off near/far
 */

#include "mep.h"


flagType
insert (
    CMDDATA argType,
    ARG * pArg,
    flagType fMeta
    ) {

    switch (pArg->argType) {

	case BOXARG:
	case LINEARG:
	    linsert (argType, pArg, fMeta);
	    break;

	default:
	    sinsert (argType, pArg, fMeta);
	    break;
    }
    return TRUE;
}



flagType
sinsert (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    switch (pArg->argType) {

    case NOARG:
	CopyBox (NULL, pFileHead, pArg->arg.noarg.x, pArg->arg.noarg.y,
				  pArg->arg.noarg.x, pArg->arg.noarg.y,
				  pArg->arg.noarg.x, pArg->arg.noarg.y);
        return TRUE;

    /*  TEXTARG illegal             */

    case NULLARG:
	flHigh.col = 0;
	flHigh.lin++;
	CopyStream (NULL, pFileHead, pArg->arg.nullarg.x, pArg->arg.nullarg.y,
				     0, 		  pArg->arg.nullarg.y + 1,
				     pArg->arg.nullarg.x, pArg->arg.nullarg.y);
        return TRUE;

    case LINEARG:
    case BOXARG:
	BoxToStream (pArg);

    case STREAMARG:
	CopyStream (NULL, pFileHead,
		    pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
		    pArg->arg.streamarg.xEnd,	pArg->arg.streamarg.yEnd,
		    pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart);
	return TRUE;

    DEFAULT_UNREACHABLE;
    }

    argData; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\getstr.c ===
/*** getstr.c - text argument handler
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "cmds.h"


#define ISWORD(c) (isalnum(c) || isxdigit(c) || c == '_' || c == '$')



/*** getstring - one line editor
*
*  This routine handles the entering and editting of single line responses
*  on the dialog line.
*
* Input:
*  pb	   = pointer to destination buffer for user's response
*  prompt  = pointer to prompt string
*  pFunc   = first editting function to process
*  flags   = GS_NEWLINE  entry must be terminated by newline, else any other
*			 non-recognized function will do.
*	     GS_INITIAL  entry is highlighted, and if first function is
*			 graphic, the entry is replaced by that graphic.
*	     GS_KEYBOARD entry must from the keyboard (critical situation ?)
*
* Output:
*  Returns pointer to command which terminated the entry
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
PCMD
getstring (
    char    *pb,
    char    *prompt,
    PCMD    pFunc,
    flagType flags
    ) {

    flagType fMetaTextArg;

    int xbeg;
    int iRespCur;	/* current position in response */

    if ((iRespCur = strlen(pb)) == 0) {
        RSETFLAG(flags, GS_INITIAL);
    }
    memset ((char *) pb+iRespCur, '\0', sizeof(linebuf) - iRespCur);

    if (pFunc != NULL) {
	xbeg = flArg.col;
    } else {
	iRespCur = 0;
	xbeg = XCUR(pInsCur);
    }

    fMetaTextArg = fMeta;

    /*
     * main editing loop. [Re]Display entry line & process editting action.
     */
    while (TRUE) {
	ScrollOut (prompt, pb, iRespCur, TESTFLAG(flags, GS_INITIAL) ? hgColor : fgColor, (flagType) TESTFLAG (flags, GS_KEYBOARD));
	RSETFLAG (fDisplay, RCURSOR);
        if (pFunc == NULL) {
	    if ((pFunc = (TESTFLAG (flags, GS_KEYBOARD) ? ReadCmd () : zloop (FALSE))) == NULL) {
		SETFLAG (fDisplay, RCURSOR);
		break;
            }
        }
	SETFLAG (fDisplay, RCURSOR);


        if ((PVOID)pFunc->func == (PVOID)newline ||
              (PVOID)pFunc->func == (PVOID)emacsnewl) {
            //
            //  newline functions: if allowed, terminate, else not allowed
            //  at all
            //
            if (!TESTFLAG(flags, GS_NEWLINE)) {
		bell ();
            } else {
                break;
            }
        } else if ((PVOID)pFunc->func == (PVOID)graphic ||
              (PVOID)pFunc->func == (PVOID)quote) {
            //
            //  graphic functions: place the graphic character into the
            //  response buffer. If erasing default response, then remove it
            //  from buffer.
            //
	    if (TESTFLAG(flags, GS_INITIAL)) {
		iRespCur = 0;
		memset ((char *) pb, '\0', sizeof(linebuf));
            }
            if (pFunc->func == quote) {
                while ((pFunc->arg = ReadCmd()->arg) == 0) {
                    ;
                }
            }
            if (fInsert) {
                memmove ((char*) pb+iRespCur+1, (char*)pb+iRespCur, sizeof(linebuf)-iRespCur-2);
            }
            pb[iRespCur++] = (char)pFunc->arg;
        } else if ((PVOID)pFunc->func == (PVOID)insertmode) {
            //
            //  insert command.
            //
	    insertmode (0, (ARG *) NULL, FALSE);
        } else if ((PVOID)pFunc->func == (PVOID)meta) {
            //
            //  meta command
            //
	    meta (0, (ARG *) NULL, FALSE);
        } else if ((PVOID)pFunc->func == (PVOID)left ||
              (PVOID)pFunc->func == (PVOID)cdelete ||
              (PVOID)pFunc->func == (PVOID)emacscdel) {
            //
            //  Cursor leftward-movement functions: update cursor position
            //  and optionally remove characters from buffer.
            //
	    if (iRespCur > 0) {
		iRespCur--;
                if ((PVOID)pFunc->func != (PVOID)left) {
                    if (fInsert) {
			memmove ( (char*) pb+iRespCur, (char*) pb+iRespCur+1, sizeof(linebuf)-iRespCur);
                    } else if (!pb[iRespCur+1]) {
			pb[iRespCur] = 0;
                    } else {
                        pb[iRespCur] = ' ';
                    }
                }
            }
        } else if ((PVOID)pFunc->func == (PVOID)right) {
            //
            //  Cursor right movement functions: update cursor position, and
            //  possibly get characters from current display.
            //
	    if (pFileHead && pb[iRespCur] == 0) {
		fInsSpace (xbeg+iRespCur, YCUR(pInsCur), 0, pFileHead, buf);
		pb[iRespCur] = buf[xbeg+iRespCur];
		pb[iRespCur+1] = 0;
            }
            iRespCur++;
        } else if ((PVOID)pFunc->func == (PVOID)begline ||
              (PVOID)pFunc->func == (PVOID)home) {
            //
            //  Home function: update cursor position
            //
	    iRespCur = 0;
        } else if ((PVOID)pFunc->func == (PVOID)endline) {
            //
            //  End function: update cursor position
            //
            iRespCur = strlen (pb);
        } else if ((PVOID)pFunc->func == (PVOID)delete ||
              (PVOID)pFunc->func == (PVOID)sdelete) {
            //
            //  Delete function: remove character
            //
            memmove ( (char*) pb+iRespCur, (char*) pb+iRespCur+1, sizeof(linebuf)-iRespCur);
        } else if ((PVOID)pFunc->func == (PVOID)insert ||
              (PVOID)pFunc->func == (PVOID)sinsert) {
            //
            //  Insert function: insert space
            //
	    memmove ( (char*) pb+iRespCur+1, (char*) pb+iRespCur, sizeof(linebuf)-iRespCur-1);
            pb[iRespCur] = ' ';
        } else if((PVOID)pFunc->func == (PVOID)doarg) {
            //
            //  Arg function: clear from current position to end
            //  of response.
            //
	    memset ((char *) pb+iRespCur, '\0', sizeof(linebuf) - iRespCur);
        } else if ((PVOID)pFunc->func == (PVOID)pword) {
            //
            //  Pword function: mive roght until the char to the left of
            //  the cursor is not part of a word, but the char under the
            //  cursor is.
            //
	    while (pb[iRespCur] != 0) {
		iRespCur++;
                if (!ISWORD (pb[iRespCur-1]) && ISWORD (pb[iRespCur])) {
                    break;
                }
            }
        } else if ((PVOID)pFunc->func == (PVOID)mword) {
            //
            //  Mword function
            //
            while (iRespCur > 0) {
		if (--iRespCur == 0 ||
                    (!ISWORD (pb[iRespCur-1]) && ISWORD (pb[iRespCur]))) {
                    break;
                }
            }
        } else if (TESTFLAG (pFunc->argType, CURSORFUNC)) {
            //
            //  Other cursor movement function: not allowed, so beep.
            //
            bell ();
        } else {
            //
            //  All other functions: if new line required to terminate,
            //  then beep, otherwise terminate and return the
            //  function terminated with.
            //
            if ((PVOID)pFunc != (PVOID)NULL) {
                if (TESTFLAG(flags, GS_NEWLINE) && (PVOID)pFunc->func != (PVOID)cancel) {
		    bell ();
                } else {
                    break;
                }
            }

        }
	/*
	 * process here to truncate any potential buffer overruns
	 */
        if (!TESTFLAG(pFunc->argType, KEEPMETA)) {
            fMeta = FALSE;
        }
	pFunc = NULL;
	if (iRespCur > sizeof(linebuf) - 2) {
	    iRespCur = sizeof(linebuf) - 2;
	    pb[iRespCur+1] = 0;
	    bell ();
        }
	RSETFLAG(flags, GS_INITIAL);
    }

    fMeta = fMetaTextArg ^ fMeta;
    return pFunc;
}




/*** ScrollOut - Update dialog line
*
*  Place a prompt, and a portion of the users response, onto the dialog of the
*  screen. Update the cursor position to the requested position relative to
*  the begining of the users response. Always ensure that that cursor position
*  is within the text actually displayed.
*
* Input:
*  szPrompt	- Text of prompt
*  szResp	- Text of users response
*  xCursor	- Current X position within reponse that is to get cursor
*  coResp	- Color to display response as
*  fVisible	- Forces display
*
* Globals:
*  hscroll	- Horizontal scroll amount
*  infColor	- Color that prompt will be displayed with
*  slSize	- Version 1 only, contains line on screen for output.
*
* Output:
*  Dialog line updated.
*
*************************************************************************/
void
ScrollOut (
    char     *szPrompt,                      /* prompt text                  */
    char     *szResp,                        /* users response string        */
    int      xCursor,                        /* Current pos w/in response    */
    int      coResp,                         /* response color               */
    flagType fVisible                        /* force display                */
    ) {

    int     cbPrompt;			/* length of the prompt string	*/
    int     cbResp;			/* length of the text displayed */
    int     cbDisp;			/* This position must be disp'd */
    int     xOff;			/* offset of string trailer	*/

#define LXSIZE	 XSIZE

    if (!mtest () || mlast () || fVisible) {
	cbPrompt = strlen (szPrompt);
        cbResp   = strlen (szResp);

	/*
	 * The distance of the new cursor position is calculated from the
	 * left edge of the text to be displayed. If there is more text
	 * than there is window, we also adjust the left edge based on hscroll.
	 */
        if (xOff = max (xCursor - (LXSIZE - cbPrompt - 1), 0)) {
            xOff += hscroll - (xOff % hscroll);
        }

        cbDisp = min (LXSIZE-cbPrompt, cbResp-xOff);

	/*
	 * output the prompt, the reponse string in the requested color,
	 * if required blank what's left, and finally update the cursor
	 * position.
	 */
	vout (0, YSIZE, szPrompt, cbPrompt, infColor);
        vout (cbPrompt, YSIZE, (char *)(szResp + xOff), cbDisp, coResp);
        if (cbPrompt + cbDisp < LXSIZE) {
            voutb (cbPrompt + cbDisp, YSIZE, " ", 1, fgColor);
        }
        consoleMoveTo( YSIZE, xCursor-xOff+cbPrompt);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\graphic.c ===
/*** graphic.c - simple single character editing
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"


struct cmdDesc cmdGraphic = {	"graphic",  graphic,	0, FALSE };

/*** graphic - Editor <graphic> function
*
* Purpose:
*   Inserts character in text at current cursor position. Delete
*   previously selected text if any.
*
* Input:
*   the usual
*
* Output:
*   TRUE if character successfully inserted (FALSE means line too long)
*
* Notes:
*
*************************************************************************/
flagType
graphic (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    delarg (pArg);
    return edit ( ((KEY_DATA *)&argData)->Ascii );

    fMeta;
}





/*** szEdit - insert a string at the current position.
*
* Purpose:
*   Inserts character in text at current cursor position.
*
* Input:
*   sz		= String to be entered
*
* Output:
*   FALSE if the line was too long, else true.
*
* Notes:
*
*************************************************************************/
flagType
szEdit (
    char *sz
    )
{
    while (*sz) {
        if (!edit (*sz++)) {
            return FALSE;
        }
    }
    return TRUE;
}





/*** edit
*
* Purpose:
*   Inserts character in text at current cursor position.
*
* Input:
*   c		= Character to be entered
*
* Output:
*   FALSE if the line was too long, else true.
*
* Notes:
*
*************************************************************************/
flagType
edit (
    char c
    )
{
    COL     dx;
    fl      fl;                             /* loc to place cursor at       */
    COL     tmpx;
    COL     x;

    /*
     * point at current location
     */
    fl.col = XCUR(pInsCur);
    fl.lin = YCUR(pInsCur);

    if (fWordWrap && xMargin > 0) {

        /*
         * if space entered just past right margin, then copy everything to the right
         * of the space to the next line.
         */
	if (c == ' ' && fl.col >= xMargin) {
	    tmpx = softcr ();
	    CopyStream (NULL, pFileHead, fl.col, fl.lin,
					 tmpx,	 fl.lin+1,
					 fl.col, fl.lin);
	    fl.lin++;
	    fl.col = tmpx;
	    cursorfl (fl);
	    return TRUE;
        } else if (fl.col >= xMargin + 5) {

	    /*	move backward to the beginning of the current word
	     *	and break it there.
	     *
	     *	Make sure we have a line that contains the cursor
	     */
            fInsSpace (fl.col, fl.lin, 0, pFileHead, buf);

	    /*	We'll go backwards to find the first place where
	     *	the char there is non-space and the char to
	     *	the left of it is a space.  We'll break the line at
	     *	that place.
	     */
            for (x = fl.col - 1; x > 1; x--) {
                if (buf[x-1] == ' ' && buf[x] != ' ') {
                    break;
                }
            }

	    /*	if we've found the appropriate word, break it there
	     */
	    if (x > 1) {
		dx = fl.col - x;
		tmpx = softcr ();
		CopyStream (NULL, pFileHead, x,    fl.lin,
					     tmpx, fl.lin + 1,
					     x,    fl.lin);
		fl.col = tmpx + dx;
		fl.lin++;
		cursorfl (fl);
            }
        }
    }

    if (Replace (c, fl.col, fl.lin, pFileHead, fInsert)) {
	right ((CMDDATA)0, (ARG *)NULL, FALSE);
	return TRUE;
    } else {
	LengthCheck (fl.lin, 0, NULL);
	return FALSE;
    }
}





/*** quote - Editor <quote> function
*
* Purpose:
*   Inserts character in text at current cursor position. Delete
*   previously selected text if any.
*
* Input:
*   the usual
*
* Output:
*   TRUE if character successfully inserted (FALSE means line too long)
*
*************************************************************************/
flagType
quote (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    char c;

    delarg (pArg);

    while ((c = (char)(ReadCmd()->arg)) == 0) {
        ;
    }
    return edit (c);

    argData; fMeta;
}




/*** delarg - deletes current selected area
*
* Purpose:
*   <graphic> and <quote> delete previously selected text. Here we do it
*
* Input:
*   pArg    pointer to current ARG structure
*
* Output:
*   None
*
* Notes:
*
*************************************************************************/
void
delarg (
    ARG * pArg
    )
{
    fl      fl;

    switch (pArg->argType) {

	case STREAMARG:
	    DelStream (pFileHead,
		       pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
		       pArg->arg.streamarg.xEnd,   pArg->arg.streamarg.yEnd   );
	    fl.col = pArg->arg.streamarg.xStart;
	    fl.lin = pArg->arg.streamarg.yStart;
            break;

	case LINEARG:
	    DelLine (TRUE, pFileHead,
		     pArg->arg.linearg.yStart, pArg->arg.linearg.yEnd);
	    fl.col = 0;
	    fl.lin = pArg->arg.linearg.yStart;
            break;

	case BOXARG:
	    DelBox (pFileHead,
		       pArg->arg.boxarg.xLeft,  pArg->arg.boxarg.yTop,
		       pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom);
	    fl.col = pArg->arg.boxarg.xLeft;
	    fl.lin = pArg->arg.boxarg.yTop;
	    break;

	default:
	    return;
    }
    cursorfl(fl);
}





/*** Replace - edit character in a file
*
* Purpose:
*   Replace will take the specified character and place it into the
*   specified position in the specified file.  If the edit is a NOP
*   (overstriking the same character) then no modification takes place
*
* Input:
*   c		character to edit in file
*   x, y	column, row of file to be changed
*   pFile	file being modified
*   fInsert	TRUE => character is inserted before the position
*
* Output:
*    TRUE => line was successfully edited, FALSE => line was too long
*
* Notes:
*
*************************************************************************/
flagType
Replace (
    char    c,
    COL     x,
    LINE    y,
    PFILE   pFile,
    flagType fInsert
    )
{
    linebuf L_buf;                             /* working buffer               */
    struct  lineAttr rgla[sizeof(linebuf)];
    flagType fColor = FALSE, fSpace = 0;
    char    *pxLog;

    fColor = GetColor (y, rgla, pFile);

    if (fInsSpaceColor (x, y, fInsert ? 1 : 0, pFile, L_buf, fColor ? rgla : NULL)) {

        pxLog = pLog (L_buf, x, TRUE);

        if (cbLog(L_buf) <= x) {

            /*
             * If the logical length of the buffer is less than what we need, then it was
             * at least space filled by fInsert, and we just need to append our character
             * to the buffer
             */

            *(unsigned int UNALIGNED *)pxLog = (unsigned int)(unsigned char)c;

        } else if (fInsert || (*pxLog != c)) {

            /*
             * if we're inserting, or the character we're overtyping is different, place
             * the character. Be sure to check the new logical length of the line as well,
             * in case it was a tab that overflowed it.
             */

            *pxLog = c;
            if (cbLog(L_buf) >= sizeof(linebuf)) {
                return FALSE;
            }
        }

        if (fInsert) {
            MarkCopyBox (pFile, pFile, x, y, sizeof(linebuf), y, x+1, y);
        }

        PutLine (y, L_buf, pFile);
        if (fColor) {
            ColorToLog (rgla, L_buf);
            PutColor (y, rgla, pFile);
        }
        return TRUE;
    }
    return FALSE;
}





/*** curdate, curday and curtime - editting functions
*
* Purpose:
*  insert current day/date/time into text being editted
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE if text entered.
*
*************************************************************************/
flagType
curdate (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    buffer  L_buf;
    time_t    ltime;
    char    *s;

    time (&ltime);
    s = ctime (&ltime);
    sprintf (L_buf, "%.2s-%.3s-%.4s", s+8, s+4, s+20);
    return szEdit (buf);

    argData; pArg; fMeta;
}




flagType
curday (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    buffer  L_buf;
    time_t ltime;
    char    *s;

    time (&ltime);
    s = ctime (&ltime);
    L_buf[0] = s[0];
    L_buf[1] = s[1];
    L_buf[2] = s[2];
    L_buf[3] = '/0';
    return szEdit (L_buf);

    argData; pArg; fMeta;
}





flagType
curtime (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    buffer  L_buf;
    time_t ltime;
    char    *s;

    time (&ltime);
    s = ctime (&ltime);
    L_buf[0] = *s+11;
    L_buf[1] = *s+12;
    L_buf[2] = *s+13;
    L_buf[3] = *s+14;
    L_buf[4] = *s+15;
    L_buf[5] = *s+16;
    L_buf[6] = *s+17;
    L_buf[7] = *s+18;
    L_buf[8] = '\0';
    return szEdit (L_buf);


    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\fscan.c ===
/*** fscan.c - iterate a function across all characters in a file
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	27-Nov-1991 mz	Strip procedure qualifiers
*
*************************************************************************/
#include "mep.h"

/*** fScan - Apply (*pevent)() until it returns TRUE
*
*  Starting one character to the right of (x, y) (left for !fFor), move
*  through the file forward (backward for !fFor) and call pevent on each
*  character. Also call once at the end of each line on the '\0' character.
*
* Input:
*  flStart	- location in pFileHead at which to start scan
*  pevent	- function to call for done signal
*  fFor 	- TRUE means go forward through file, FALSE backwards
*  fWrap	- TRUE means wrap around the ends of the file, ending at the
*		  starting position. The range to be scanned (defined below)
*		  must include the appropriate start/end of the file.
*
* Globals:
*  rnScan	- Region to confine scan to.
*
*  Returns TRUE if pevent returned true for some file position FALSE if we
*  ran out of scanning region first.
*
*  During the life of fScan, the following globals are valid, and maybe
*  used by pevent:
*
*      flScan	    - Position in file pevent should look at.
*      scanbuf	    - Contents of line to be looking at.
*      scanreal     - Un-Detabbed version of same.
*      scanlen	    - Number of characters in scanbuf.
*
*  The line in scanbuf is detabbed, howver the pevent routine is called once
*  per physical character, if fRealTabs is true.
*
*************************************************************************/
flagType
fScan (
    fl      flStart,
    flagType (*pevent) (void),
    flagType fFor,
    flagType fWrap
    ) {

    LINE    yLim;                           /* limitting line for scanning  */

    flScan = flStart;

    if (!fFor) {
        /*
         * backwards scan.
         *
         * dec current column. If it steps outside of rnScan, then back up a line, and
         * set the column to the right hand column.
         */
        if (--flScan.col < rnScan.flFirst.col) {
            flScan.lin--;
            flScan.col = rnScan.flLast.col;
        }
        /*
         * While we are within the line range of rnScan, check for CTRL-C aborts, and
         * get each line.
         */
        yLim = rnScan.flFirst.lin;
        while (flScan.lin >= yLim) {
            if (fCtrlc) {
                return (flagType)!DoCancel();
            }
            scanlen = GetLine (flScan.lin, scanreal, pFileHead) ;
            scanlen = Untab (fileTab, scanreal, scanlen, scanbuf, ' ');
            /*
             * ensure that the scan column position is within range, and then for every
             * column in the rane of the current line, call the pevent routine
             */
            flScan.col = min ( (  flScan.col < 0
                                ? rnScan.flLast.col
                                : flScan.col)
                              , scanlen);

            while (flScan.col >= rnScan.flFirst.col) {
                if ((*pevent)()) {
                    return TRUE;
                }
                if (fRealTabs) {
                    flScan.col = colPhys (scanreal, (pLog (scanreal, flScan.col, TRUE) - 1));
                } else {
                    flScan.col--;
                }
            }
            /*
             * display status to user. If we just scanned to begining of file, and we are
             * to wrap, then set the new stop limit as the old start position, and set the
             * next line to be scanned as the last in the file.
             */
            noise (flScan.lin--);
            if ((flScan.lin < 0) && fWrap) {
                yLim = flStart.lin;
                flScan.lin = pFileHead->cLines - 1;
            }
        }
    } else {
        /*
         * forwards scan. Same structure as above, only in the other direction.
         */
        flScan.col++;
        yLim = rnScan.flLast.lin;
        while (flScan.lin <= yLim) {
            if (fCtrlc) {
                return (flagType)!DoCancel();
            }
            scanlen = GetLine (flScan.lin, scanreal, pFileHead);
            scanlen = Untab (fileTab, scanreal, scanlen, scanbuf, ' ');
            scanlen = min (rnScan.flLast.col, scanlen);
            while (flScan.col <= scanlen) {
                if ((*pevent)()) {
                    return TRUE;
                }
                if (fRealTabs) {
                    flScan.col = colPhys (scanreal, (pLog (scanreal, flScan.col, TRUE) + 1));
                } else {
                    flScan.col++;
                }
            }
            flScan.col = rnScan.flFirst.col;
            noise (++flScan.lin);
            if (fWrap && (flScan.lin >= pFileHead->cLines)) {
                flScan.lin = 0;
                if (flStart.lin) {
                    yLim = flStart.lin - 1;
                } else {
                    break;
                }
            }
        }
    }
    return FALSE;
}




/*** setAllScan - set maximal scan range
*
*  Sets scan range such that fScan operates on the entire file.
*
* Input:
*  fDir 	= TRUE => scan will procede forwards, else backwards
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
setAllScan (
    flagType fDir
    ) {
    rnScan.flFirst.col = 0;
    rnScan.flFirst.lin = fDir ? YCUR(pInsCur) : 0;
    rnScan.flLast.col  = sizeof(linebuf)-1;
    rnScan.flLast.lin  = pFileHead->cLines - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\hilite.c ===
/*** hilite.c - editor multiple-file highlighting support
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Contains the common code to maintain multiple highlighted regions across
*   multiple files.
*
* Highlighting Overview
*
*   Each pFile contains a vm pointer to a linked list of blocks each of which
*   contain up to RNMAX ranges in the file currently highlighted. The ranges
*   are maintained in order of the first coordinate of the range (see below),
*   though they may overlap. Each block may not be completely full, due to the
*   insertion algorithm which maintains the order.
*
*		      +---------------+   +---------------+   +---------------+
*   pFile->vaHiLite-->|vaNext	      |-->|vaNext	  |-->|-1L	      |
*		      +---------------+   +---------------+   +---------------+
*		      |irnMac	      |   |irnMac	  |   |irnMac	      |
*		      +---------------+   +---------------+   +---------------+
*		      |rnHiLite[RNMAX]|   |rnHiLite[RNMAX]|   |rnHiLite[RNMAX]|
*		      +---------------+   +---------------+   +---------------+
*
*   Clearing all current highlighting for a file simply involves deallocating
*   the list of highlight ranges.
*
*   Adding a highlight region either updates an existing region (if the start
*   points are the same, and the new end point is the same in one direction and
*   greater in the other), or insertion of a new range in the sorted list. If
*   a block is full, when asertion is attempted in that block, the block will
*   be split in half, and a new block inserted into the linked list.
*
*   Each range is "normally" an ordered pair of coordinates (a range, or rn)
*   specifying the range of the file to be hilighted. However, Arg processing
*   always specifies that the first coordinate of this pair is the location at
*   which the user hit ARG, and the second is the travelling corrdinate as he
*   specifies the region on screen. For this reason, if the x coordinates are
*   in reverse order, the right-most coordinate is decremented by one to
*   reflect the correct highlighting for arguments.
*
*
* Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "mep.h"

#define RNMAX	20			/* max number of rns per block	*/
					/* MUST BE EVEN 		*/

/*
 * HiLiteBlock - block of highlighting information as kept in VM
 */
struct HiLiteBlock {
    PVOID   vaNext;                     /* va of next block, or -1      */
    int     irnMac;			/* number of rns in block	*/
    rn	    rnHiLite[RNMAX];		/* ranges with highlighting	*/
    char    coHiLite[RNMAX];		/* colors to be used		*/
    };



/*** SetHiLite - Mark a range in a file to be highlighted
*
*  Marks the specfied range in a file as needing to be highlighted. The next
*  time that portion of the file is updated on screen, the highlighting
*  attributes will be applied.
*
* Input:
*  pFile	= file to be highlighted
*  rnCur	= Range to be highlighted
*  coCur	= Color to use for highlighting
*
* Output:
*
*************************************************************************/
void
SetHiLite (
    PFILE   pFile,
    rn      rnCur,
    int     coCur
    ) {

    struct HiLiteBlock	hbCur;		 /* block being worked on	 */
    int 		irnCur; 	 /* index into block		 */
    PVOID               vaCur;           /* va of current block          */
    PVOID               vaNew;           /* va of new split block        */
    PVOID               vaNext;          /* va of next block             */

    /*
     * If the file does not yet have one, allocate the first highlight block
     */
    if (pFile->vaHiLite == (PVOID)(-1L)) {
	irnCur = 0;
        hbCur.vaNext = (PVOID)(-1L);
	hbCur.irnMac = 0;
        // PREFIX!  This MALLOC is not checked for failure
        vaCur = pFile->vaHiLite = MALLOC ((long)sizeof(hbCur));
    } else {
	vaCur = pFile->vaHiLite;
	while (1) {
            // rjsa VATopb (vaCur, (char *)&hbCur, sizeof(hbCur));
            memmove((char *)&hbCur, vaCur, sizeof(hbCur));
	    assert (hbCur.irnMac <= RNMAX);

	    /*
	     * search contents of current block for first range which occurs on
	     * the same or a later position than the new one.
	     */
	    for (irnCur = 0; irnCur<hbCur.irnMac; irnCur++) {
                if (hbCur.rnHiLite[irnCur].flFirst.lin > rnCur.flFirst.lin) {
                    break;
                }
		if (   (hbCur.rnHiLite[irnCur].flFirst.lin == rnCur.flFirst.lin)
                    && (hbCur.rnHiLite[irnCur].flFirst.col >= rnCur.flFirst.col)) {
                    break;
                }
            }
	    /*
	     * if we found something, exit the search, else move to next block,
	     * if there is one.
	     */
            if (irnCur != hbCur.irnMac) {
                break;
            }
            if (hbCur.vaNext == (PVOID)(-1L)) {
                break;
            }
            vaCur = hbCur.vaNext;
        }
    }

    /*
     * vaCur = va of block needing insertion/modification
     * irnCur = index of rn for same or later position
     * hbCur = contents of block last read
     *
     * if irnCur<RNMAX we operate on the current block, else we allocate a
     * new one, link it to the list, and place our new highlighted region
     * in it.
     */
    if (irnCur >= RNMAX) {
        // PREFIX! This MALLOC is not checked for failure
        hbCur.vaNext = MALLOC ((long)sizeof(hbCur));
        // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
        memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
        vaCur = hbCur.vaNext;
        hbCur.vaNext = (PVOID)(-1L);
		hbCur.irnMac = 1;
		hbCur.rnHiLite[0] = rnCur;
        // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
        memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
	return;
    }

    /*
     * If the upper first coordinate matches, and one of the second coordinates
     * then just update the second.
     */
    if (   (irnCur >= 0)
	&& (   (hbCur.rnHiLite[irnCur].flFirst.lin == rnCur.flFirst.lin)
	    && (hbCur.rnHiLite[irnCur].flFirst.col == rnCur.flFirst.col))
	&& (   (hbCur.rnHiLite[irnCur].flLast.lin == rnCur.flLast.lin)
	    || (hbCur.rnHiLite[irnCur].flLast.col == rnCur.flLast.col))
	&& (hbCur.coHiLite[irnCur] == (char)coCur)
	) {

	/*
	 * If the columns have changed, redraw the entire range (only the columns
	 * changed, but on all lines), otherwise just redraw those lines which
	 * have changed.
	 */
        if (hbCur.rnHiLite[irnCur].flLast.col != rnCur.flLast.col) {
            redraw (pFile,rnCur.flFirst.lin,rnCur.flLast.lin);
        } else {
            redraw (pFile,hbCur.rnHiLite[irnCur].flLast.lin,rnCur.flLast.lin);
        }
	hbCur.rnHiLite[irnCur].flLast = rnCur.flLast;
    } else {
	redraw (pFile,rnCur.flFirst.lin,rnCur.flLast.lin);

	/*
	 * if the block to be modified is full, then split it into two blocks.
	 */
	if (hbCur.irnMac == RNMAX) {
	    hbCur.irnMac = RNMAX/2;
	    vaNext = hbCur.vaNext;
            vaNew = hbCur.vaNext = MALLOC ((long)sizeof(hbCur));
            // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
            memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
	    memmove ((char *)&hbCur.rnHiLite[0],
		 (char *)&hbCur.rnHiLite[RNMAX/2]
		 ,(RNMAX/2)*sizeof(rn));
	    memmove ((char *)&hbCur.coHiLite[0],
		 (char *)&hbCur.coHiLite[RNMAX/2]
		 ,(RNMAX/2)*sizeof(char));
	    hbCur.vaNext = vaNext;
            // rjsa pbToVA ((char *)&hbCur, vaNew, sizeof(hbCur));
            memmove(vaNew, (char *)&hbCur, sizeof(hbCur));

	    /*
	     * select which of the two blocks (vaCur, the first half; or vaNew,
	     * the second) to operate on. ReRead the old block if required.
	     */
	    if (irnCur >= RNMAX/2) {
		vaCur = vaNew;
		irnCur -= RNMAX/2;
            } else {
                //rjsa VATopb (vaCur, (char *)&hbCur, sizeof(hbCur));
                memmove((char *)&hbCur, vaCur, sizeof(hbCur));
            }
        }

	/*
	 * Move the rn's that follow where we want to be, up by one,
	 * and insert ours.
	 */
        if (irnCur < hbCur.irnMac) {
	    memmove ((char *)&hbCur.rnHiLite[irnCur+1],
		 (char *)&hbCur.rnHiLite[irnCur]
                 ,(hbCur.irnMac - irnCur)*sizeof(rn));
        }
	memmove ((char *)&hbCur.coHiLite[irnCur+1],
	     (char *)&hbCur.coHiLite[irnCur]
	     ,(hbCur.irnMac - irnCur));
	hbCur.rnHiLite[irnCur] = rnCur;
	hbCur.coHiLite[irnCur] = (char)coCur;
	hbCur.irnMac++;
    }

    /*
     * update the block in vm
     */
    // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
    memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
}



/*** ClearHiLite - remove all highlighting from a file
*
*  Removes all highlighting information for a file, and marks those lines
*  affected as needing to be redrawn.
*
* Input:
*  pFile	= file affected.
*  fFree	= TRUE => free the VM used
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
ClearHiLite (
    PFILE   pFile,
    flagType fFree
    ) {

	struct HiLiteBlock	*hbCur, *hbNext;
    int 		irn;

	while (pFile->vaHiLite != (PVOID)(-1L)) {

		hbCur = ( struct HiLiteBlock *)(pFile->vaHiLite );

		assert (hbCur->irnMac <= RNMAX);

		/*
		 * for each of the highlight ranges in the block, mark the lines as
		 * needing to be redrawn, so that highlighting will be removed from
		 * the screen.
		 */
		for (irn = hbCur->irnMac; irn; ) {
			irn--;
			redraw (pFile
					,hbCur->rnHiLite[irn].flFirst.lin
					,hbCur->rnHiLite[irn].flLast.lin
					);
		}

		/*
		 * discard the vm used by the block, and point at the next block in
		 * the chain
		 */
		hbNext = hbCur->vaNext;
        if (fFree) {
            FREE(pFile->vaHiLite);
        }
		pFile->vaHiLite = hbNext;
    }
}



/*** UpdHiLite - Update a color buffer with highlighting information
*
*  Apply all highlighting ranges that apply to a particluar portion
*  of a line in a file to a color buffer. Ensure that areas outside
*  the highlight range are unaffected, and that areas within are
*  updated appropriately.
*
* Input:
*  pFile	= File being operated on
*  lin		= line
*  colFirst	= first col
*  colLast	= last col
*  ppla 	= Pointer to Pointer to lineattr array to be updated
*
* Output:
*  Returns TRUE if highlighting occurred.
*
*************************************************************************/
flagType
UpdHiLite (
    PFILE             pFile,
    LINE              lin,
    COL               colFirst,
    COL               colLast,
    struct lineAttr **ppla
    ) {

	struct HiLiteBlock	*hbCur;		 /* block being worked on	 */
    PVOID               vaCur;           /* va of current block          */
    int 		irnCur; 	 /* index into block		 */

    COL 		colHiFirst;
    COL 		colHiLast;
    COL 		colHiTmp;

    COL 		col;
    struct lineAttr    *pla;

    flagType		fRv = FALSE;	 /* highlighting occurred	 */

    /*
     * First we scroll it to the left (if needed)
     */
    if (colFirst) {
	for (col = 0, pla = *ppla;
	     col + pla->len <= colFirst;
             col += pla++->len) {
            ;
        }

        if (col < colFirst && pla->len != 0xff) {
            pla->len -= (unsigned char) (colFirst - col);
        }

	/*
	 * Take care here we modify THEIR pointer
	 */
	*ppla = pla;
    }

    /*
     * for all blocks of hiliting info
     */
    vaCur = pFile->vaHiLite;
	while (vaCur != (PVOID)(-1L)) {

		/*
		 * get block
		 */
		hbCur = (struct HiLiteBlock *)vaCur;
		assert (hbCur->irnMac <= RNMAX);

		/*
		 * for each range within the block
		 */
		for (irnCur = 0; irnCur<hbCur->irnMac; irnCur++) {
			/*
			 * is the range affecting the line we're looking for ?
			 */
			if (fInRange (hbCur->rnHiLite[irnCur].flFirst.lin
						 ,lin
						 ,hbCur->rnHiLite[irnCur].flLast.lin)) {

				/*
				 * Watch out: range coordinates might be inversed
				 */
				if (  (colHiFirst = hbCur->rnHiLite[irnCur].flFirst.col)
					> (colHiLast  = hbCur->rnHiLite[irnCur].flLast.col)) {

					colHiTmp   = colHiFirst - 1;
					colHiFirst = colHiLast;
					colHiLast  = colHiTmp;
                }


				/*
				 * is the range affecting the portion of line we're looking for ?
				 */
				if (!(colHiLast < colFirst || colHiFirst > colLast)) {
					/*
					 * Yes: signals work done and do the hilite
					 */
					fRv = TRUE;
					UpdOneHiLite (*ppla
								,max(colFirst, colHiFirst) - colFirst
								,min(colLast,	colHiLast ) - max(colFirst, colHiFirst) + 1
								,TRUE
								,(int) hbCur->coHiLite[irnCur]);
                }
            }
        }
		vaCur = hbCur->vaNext;
    }
    return fRv;
}



/*** UpdOneHiLite - Update the highlighting on one line of attributes
*
*  Modifies an existing attribute line to include highlighting.
*
* Input:
*  pla		   = Pointer to attribute information for line
*  colFirst	   = Starting column
*  colLast	   = Ending column
*  fattr (CW only) = TRUE: attr is color index
*		     FALSE: attr is pointer to lineAttr array
*  attr 	   = color index or pointer to lineAttr array to be used
*
* Output:
*  *pla updated
*
*************************************************************************/
void
UpdOneHiLite (
    struct lineAttr *pla,
    COL              colFirst,
    COL              len,
    flagType         fattr,
    INT_PTR          attr
    ) {

    struct lineAttr *plaFirstMod;   /* pointer to first cell to be modified    */
    struct lineAttr *plaLastMod;    /* pointer to last cell to be modified     */
    COL		     colLast = colFirst + len - 1;
    COL 	     colFirstMod;   /* starting column for first modified cell */
    COL 	     colLastMod;    /* starting column for last modified cell  */

    struct lineAttr *plaSrc;	    /* source pointer for moving cells	       */
    struct lineAttr *plaDst;	    /* destination pointer for moving cells    */
    struct lineAttr *plaSrcSav;     /* temporary pointer		       */

    struct lineAttr *plaExt;	    /* pointer to external array of lineAttr   */
    COL 	     colSrc;
    COL 	     colSrcEnd;

    struct lineAttr  rglaTmp[3];    /* buffer for creating cells	       */
    int 	     claTmp = 0;    /* number of cells to insert	       */

    /*
     * First we Find the first cell that will be affected by the change
     */
    for (colFirstMod = 0, plaFirstMod = pla;
	 colFirstMod + plaFirstMod->len <= colFirst;
         colFirstMod += plaFirstMod++->len) {
        ;
    }

    /*
     * Next we find the last cell that will be affected by the change
     */
    for (colLastMod = colFirstMod, plaLastMod = plaFirstMod;
	 colLastMod + plaLastMod->len <= colLast;
         colLastMod += plaLastMod++->len) {
        ;
    }

    /*
     * If the first affected cell doesn't start on our boundary, let's
     * create a new cell to be inserted
     */
    if (colFirstMod < colFirst) {
	rglaTmp[0].len	= (unsigned char) (colFirst - colFirstMod);
	rglaTmp[0].attr = plaFirstMod->attr;
	claTmp++;
    } else {
        rglaTmp[0].len = 0;
    }

    if (fattr) {
	/*
	 * Only one color for the updated range: we always create
	 * the cell of new color
	 */
	rglaTmp[1].len	= (unsigned char) (colLast - colFirst + 1);
	rglaTmp[1].attr = (unsigned char) attr;
	claTmp++;
    } else {
	/*
	 * Colors for the updated range come from an array of lineAttr
	 * We first get its address (this is a hack because 16 bit pointer
	 * can be cast to an int)
	 */
	plaExt = (struct lineAttr *) attr;

	/*
	 * Count the number of cells to copy.
	 */
	for (plaSrc = plaExt, colSrc = 0, colSrcEnd = colLast - colFirst + 1;
	     colSrc + plaSrc->len <= colSrcEnd;
             colSrc += plaSrc++->len, claTmp++) {
            ;
        }

	/*
	 * Build trailing cell if needed
	 */
	if (colSrc < colSrcEnd) {
            rglaTmp[1].len  = (unsigned char) (colSrcEnd - colSrc);
	    rglaTmp[1].attr = (unsigned char) plaSrc->attr;
	    claTmp++;
        } else {
            rglaTmp[1].len = 0;
        }
    }

    /*
     * If the last affected cell doesn't end on our boundary, we
     * create a new cell to be inserted. We take care of the final
     * cell.
     */
    if (colLastMod + plaLastMod->len > colLast + 1) {
	rglaTmp[2].len = (unsigned char) ((plaLastMod->len == 0xff) ?
	    0xff :
	    colLastMod + (int) plaLastMod->len - colLast - 1);
	rglaTmp[2].attr = plaLastMod->attr;
	claTmp++;
    } else {
        rglaTmp[2].len = 0;
    }

    /*
     * Then we move the info tail to its new place if needed
     *
     * UNDONE: Here we could use Move() instead of copying cell by cell
     */
    if (plaLastMod->len != 0xff) {
	plaDst = plaFirstMod + claTmp;
	plaSrc = plaLastMod + 1;
        if (plaDst < plaSrc) {
	    do {
		*plaDst++ = *plaSrc;
            } while (plaSrc++->len != 0xff);
        } else {
            for (plaSrcSav = plaSrc; plaSrc->len != 0xff; plaSrc++) {
                ;
            }
	    plaDst += plaSrc - plaSrcSav;
	    do {
		*plaDst-- = *plaSrc--;
            } while (plaSrc >= plaSrcSav);
        }
    }

    /*
     * Finally insert the created cells
     */
    for (plaDst = plaFirstMod, claTmp = 0; claTmp < 3; claTmp++) {
        if (claTmp == 1 && !fattr) {
	    /*
	     * UNDONE: Here we could use Move() instead of copying cell by cell
	     */
	    for (plaSrc = plaExt, colSrc = 0, colSrcEnd = colLast - colFirst + 1;
		 colSrc + plaSrc->len <= colSrcEnd;
                 plaDst++, colSrc += plaSrc++->len) {
                *plaDst = *plaSrc;
            }
        }
        if (rglaTmp[claTmp].len) {
            *plaDst++ = rglaTmp[claTmp];
        }
    }
}





/*** rnOrder - ensure that a range is in correct first/last order
*
*  Ensure that a range is in correct first/last order
*
* Input:
*  prn		= Pointer to range
*
* Output:
*  *prn updated
*
*************************************************************************/
void
rnOrder (
    rn      *prn
    ) {

    rn	    rnTmp;

    rnTmp.flFirst.lin = lmin (prn->flFirst.lin, prn->flLast.lin);
    rnTmp.flLast.lin  = lmax (prn->flFirst.lin, prn->flLast.lin);
    rnTmp.flFirst.col = min (prn->flFirst.col, prn->flLast.col);
    rnTmp.flLast.col  = max (prn->flFirst.col, prn->flLast.col);

    *prn = rnTmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\key.c ===
/*** key.c - keyboard handling routines
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*	03-Dec-1990 ramonsa addapted from old key.c
*	26-Nov-1991 mz	    Strip off near/far
*
*************************************************************************/
#define INCL_DOSSEMAPHORES
#include "mep.h"

#include "keyboard.h"
#include "keys.h"
#include "cmds.h"




//
//  CodeCmdMap
//
//      The KeyCode field in the KEY_INFO structure used within the editor
//  is just an index into this table.
//
//      This table contains pointers to the editor functions attached to
//  particular keystrokes.
//
PCMD CodeCmdMap [] =
    {

            //************************************************************
/*  Key  */ //
/* Index */ //  256 ASCII characters
            //
            //  BugBug this is from the old code, there is no reason to have
            //         256 entries here.
            //
/* 0000 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0004 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0008 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 000C */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0010 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0014 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0018 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 001C */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,

/* 0020 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0024 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0028 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 002C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0030 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0034 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0038 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 003C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0040 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0044 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0048 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 004C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0050 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0054 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0058 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 005C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0060 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0064 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0068 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 006C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0070 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0074 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0078 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 007C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0080 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0084 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0088 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 008C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0090 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0094 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0098 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 009C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 00A0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00A4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00A8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00AC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00B0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00B4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00B8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00BC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 00C0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00C4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00C8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00CC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00D0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00D4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00D8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00DC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 00E0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00E4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00E8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00EC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00F0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00F4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00F8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00FC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,


            //**********************************************************
            //
            //  Special Keys
            //
            //
            //  Function Keys (f1-f12)
            //
/* 0100 */  CMD_unassigned, CMD_setfile,    CMD_psearch,    CMD_msearch,
/* 0104 */  CMD_unassigned, CMD_window,     CMD_zexecute,   CMD_zexit,
/* 0108 */	CMD_meta,		CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  Numeric white keys (Numlock off)
            //
            //    Home          End             Left            Right
/* 010C */  CMD_begline,    CMD_endline,    CMD_left,       CMD_right,
            //    Up            Down            Pgup            Pgdown
/* 0110 */  CMD_up,         CMD_down,       CMD_mpage,      CMD_ppage,
            //    Ins           Del             Goto
/* 0114 */  CMD_insertmode, CMD_delete,     CMD_unassigned, CMD_unassigned,

            //
            //  Numeric white keys (Numlock on) 0-9
            //
/* 0118 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 011C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0120 */  CMD_graphic,    CMD_graphic,    CMD_unassigned, CMD_unassigned,

            //
            //  Numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 0124 */	CMD_graphic,	CMD_zpick,		CMD_graphic,	  CMD_graphic,
            //   NUMENTER
/* 0128 */  CMD_emacsnewl,  CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //  Named Keys :
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 012C */  CMD_unassigned, CMD_emacscdel,  CMD_tab,        CMD_unassigned,
            //  ESC         ENTER
/* 0130 */  CMD_cancel,     CMD_emacsnewl,  CMD_unassigned, CMD_unassigned,

            //
            //  Additional:
            //
/* 0134 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0138 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 013C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,



            //*************************************************************
            //
            //  ALT+ 0-9
            //
/* 0140 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0144 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0148 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ a-z
            //
/* 014C */  CMD_doarg,      CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0150 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0154 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0158 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 015C */	CMD_unassigned, CMD_record, 	CMD_unassigned, CMD_unassigned,
/* 0160 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0164 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ function keys (f1-f12)
            //
/* 0168 */  CMD_unassigned, CMD_zprint,     CMD_unassigned, CMD_unassigned,
/* 016C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0170 */	CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ lower case punctuation
            //
            //    `               -               =              [
/* 0174 */  CMD_unassigned, CMD_unassigned, CMD_assign,     CMD_unassigned,
            //    ]               \               ;              '
/* 0178 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    ,                .              /
/* 017C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ numeric white keys (Numlock off)
            //
            //    Home          End             Left            Right
/* 0180 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Up            Down            Pgup            Pgdown
/* 0184 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Ins           Del             Goto
/* 0188 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ numeric white keys (Numlock on) 0-9
            //
/* 018C */  CMD_noop,       CMD_noop,       CMD_noop,       CMD_noop,
/* 0190 */  CMD_noop,       CMD_noop,       CMD_noop,       CMD_noop,
/* 0194 */  CMD_noop,       CMD_noop,       CMD_noop,       CMD_unassigned,

            //
            //  ALT+ numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 0198 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //   NUMENTER
/* 019C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ named keys:
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 01A0 */  CMD_unassigned, CMD_undo,       CMD_unassigned, CMD_unassigned,
            //  ESC         ENTER
/* 01A4 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  Additional:
            //
/* 01A8 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01AC */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01B0 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,



            //*************************************************************
            //
            //  CTRL+ 0-9
            //
/* 01B4 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01B8 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01BC */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ a-z
            //
/* 01C0 */	CMD_mword,		CMD_boxstream,	CMD_ppage,		CMD_right,
/* 01C4 */	CMD_up, 		CMD_pword,		CMD_cdelete,	CMD_unassigned,
/* 01C8 */  CMD_unassigned, CMD_sinsert,    CMD_unassigned, CMD_replace,
/* 01CC */	CMD_mark,		CMD_linsert,	CMD_textarg,	CMD_quote,
/* 01D0 */	CMD_unassigned, CMD_mpage,		CMD_left,		CMD_tell,
/* 01D4 */	CMD_lastselect, CMD_insertmode, CMD_mlines, 	CMD_down,
/* 01D8 */  CMD_ldelete,    CMD_plines,     CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ function keys  (f1-f12)
            //
/* 01DC */  CMD_unassigned, CMD_unassigned, CMD_compile,    CMD_unassigned,
/* 01E0 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_zprint,
/* 01E4 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ lower case punctuation
            //
            //    `               -               =              [
/* 01E8 */	CMD_unassigned, CMD_unassigned, CMD_noop,		CMD_pbal,
            //    ]               \               ;              '
/* 01EC */  CMD_setwindow,  CMD_qreplace,   CMD_unassigned, CMD_unassigned,
            //    ,                .              /
/* 01F0 */	CMD_unassigned, CMD_noop,		CMD_unassigned, CMD_unassigned,


            //
            //  CTRL+ numeric white keys (Numlock off)
            //
			//	  Home			End 			Left			Right
/* 01F4 */	CMD_home,		CMD_unassigned,	CMD_mword,		CMD_pword,
            //    Up            Down            Pgup            Pgdown
/* 01F8 */	CMD_unassigned, CMD_unassigned, CMD_begfile,	CMD_endfile,
            //    Ins           Del             Goto
/* 01FC */  CMD_zpick,      CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ numeric white keys (Numlock on) (0-9)
            //
/* 0200 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0204 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0208 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 020C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //   NUMENTER
/* 0210 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ named keys
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 0214 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
			//	ESC 		ENTER
/* 0218 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  Additional:
            //
/* 021C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0220 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0224 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,



            //*************************************************************
            //
            //  SHIFT+ function keys  (f1-f12)
            //
/* 0228 */  CMD_information,CMD_unassigned, CMD_nextmsg,    CMD_unassigned,
/* 022C */  CMD_unassigned, CMD_searchall,  CMD_refresh,    CMD_zinit,
/* 0230 */  CMD_zspawn,     CMD_information,CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ numeric white keys (Numlock off)
            //
            //    Home          End             Left            Right
/* 0234 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Up            Down            Pgup            Pgdown
/* 0238 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Ins           Del             Goto
/* 023C */  CMD_put,        CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ numeric white keys (Numlock on) (0-9)
            //
/* 0240 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0244 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0248 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 024C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //   NUMENTER
/* 0250 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ named keys
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 0254 */	CMD_graphic,	CMD_unassigned, CMD_backtab,	CMD_unassigned,
            //  ESC         ENTER
/* 0258 */  CMD_unassigned, CMD_emacsnewl,  CMD_unassigned, CMD_unassigned,


            NULL
};

#define LAST_CODE 0x25b


typedef struct KEYNAME {
    WORD    KeyCode;                    // Key Code
    char    *pName;                     // name of key
} KEYNAME, *PKEYNAME;


//
//  CodeNameMap
//
//      This table maps KeyCodes to their corresponding printable name
//  and vice-versa.
//
KEYNAME CodeNameMap[] =
{

    {   0x0100, "f1"            },      {   0x0101, "f2"            },
    {   0x0102, "f3"            },      {   0x0103, "f4"            },
    {   0x0104, "f5"            },      {   0x0105, "f6"            },
    {   0x0106, "f7"            },      {   0x0107, "f8"            },
    {   0x0108, "f9"            },      {   0x0109, "f10"           },
    {   0x010A, "f11"           },      {   0x010B, "f12"           },

    {   0x010C, "home"          },      {   0x010D, "end"           },
    {   0x010E, "left"          },      {   0x010F, "right"         },
    {   0x0110, "up"            },      {   0x0111, "down"          },
    {   0x0112, "pgup"          },      {   0x0113, "pgdn"          },
    {   0x0114, "ins"           },      {   0x0115, "del"           },
    {   0x0116, "goto"          },

    {   0x0118, "num0"          },      {   0x0119, "num1"          },
    {   0x011A, "num2"          },      {   0x011B, "num3"          },
    {   0x011C, "num4"          },      {   0x011D, "num5"          },
    {   0x011E, "num6"          },      {   0x011F, "num7"          },
    {   0x0120, "num8"          },      {   0x0121, "num9"          },

    {   0x0124, "num-"          },      {   0x0125, "num+"          },
    {   0x0126, "num*"          },      {   0x0127, "num/"          },
    {   0x0128, "numenter"      },

    {   0x012C, "space"         },      {   0x012D, "bksp"          },
    {   0x012E, "tab"           },      {   0x012F, "bktab"         },
    {   0x0130, "esc"           },      {   0x0131, "enter"         },

    {   0x0140, "alt+0"         },      {   0x0141, "alt+1"         },
    {   0x0142, "alt+2"         },      {   0x0143, "alt+3"         },
    {   0x0144, "alt+4"         },      {   0x0145, "alt+5"         },
    {   0x0146, "alt+6"         },      {   0x0147, "alt+7"         },
    {   0x0148, "alt+8"         },      {   0x0149, "alt+9"         },

    {   0x014C, "alt+a"         },      {   0x014D, "alt+b"         },
    {   0x014E, "alt+c"         },      {   0x014F, "alt+d"         },
    {   0x0150, "alt+e"         },      {   0x0151, "alt+f"         },
    {   0x0152, "alt+g"         },      {   0x0153, "alt+h"         },
    {   0x0154, "alt+i"         },      {   0x0155, "alt+j"         },
    {   0x0156, "alt+k"         },      {   0x0157, "alt+l"         },
    {   0x0158, "alt+m"         },      {   0x0159, "alt+n"         },
    {   0x015A, "alt+o"         },      {   0x015B, "alt+p"         },
    {   0x015C, "alt+q"         },      {   0x015D, "alt+r"         },
    {   0x015E, "alt+s"         },      {   0x015F, "alt+t"         },
    {   0x0160, "alt+u"         },      {   0x0161, "alt+v"         },
    {   0x0162, "alt+w"         },      {   0x0163, "alt+x"         },
    {   0x0164, "alt+y"         },      {   0x0165, "alt+z"         },

    {   0x0168, "alt+f1"        },      {   0x0169, "alt+f2"        },
    {   0x016A, "alt+f3"        },      {   0x016B, "alt+f4"        },
    {   0x016C, "alt+f5"        },      {   0x016D, "alt+f6"        },
    {   0x016E, "alt+f7"        },      {   0x016F, "alt+f8"        },
    {   0x0170, "alt+f9"        },      {   0x0171, "alt+f10"       },
    {   0x0172, "alt+f11"       },      {   0x0173, "alt+f12"       },

    {   0x0174, "alt+`"         },      {   0x0175, "alt+-"         },
    {   0x0176, "alt+="         },      {   0x0177, "alt+["         },
    {   0x0178, "alt+]"         },      {   0x0179, "alt+\\"        },
    {   0x017A, "alt+;"         },      {   0x017B, "alt+'"         },
    {   0x017C, "alt+,"         },      {   0x017D, "alt+."         },
    {   0x017E, "alt+/"         },

    {   0x0180, "alt+home"      },      {   0x0181, "alt+end"       },
    {   0x0182, "alt+left"      },      {   0x0183, "alt+right"     },
    {   0x0184, "alt+up"        },      {   0x0185, "alt+down"      },
    {   0x0186, "alt+pgup"      },      {   0x0187, "alt+pgdn"      },
    {   0x0188, "alt+ins"       },      {   0x0189, "alt+del"       },
    {   0x018A, "alt+goto"      },

    {   0x018C, "alt+num0"      },      {   0x018D, "alt+num1"      },
    {   0x018E, "alt+num2"      },      {   0x018F, "alt+num3"      },
    {   0x0190, "alt+num4"      },      {   0x0191, "alt+num5"      },
    {   0x0192, "alt+num6"      },      {   0x0193, "alt+num7"      },
    {   0x0194, "alt+num8"      },      {   0x0195, "alt+num9"      },

    {   0x0198, "alt+num-"      },      {   0x0199, "alt+num+"      },
    {   0x019A, "alt+num*"      },      {   0x019B, "alt+num/"      },
    {   0x019C, "alt+numenter"  },

    {   0x01A0, "alt+space"     },      {   0x01A1, "alt+bksp"      },
    {   0x01A2, "alt+tab"       },      {   0x01A3, "alt+bktab"     },
    {   0x01A4, "alt+esc"       },      {   0x01A5, "alt+enter"     },

	{	0x01B4, "ctrl+0"		},		{	0x01B5, "ctrl+1"		},
	{	0x01B6, "ctrl+@"		},
    {   0x01B6, "ctrl+2"        },      {   0x01B7, "ctrl+3"        },
	{	0x01B8, "ctrl+4"		},		{	0x01B9, "ctrl+5"		},
	{	0x01BA, "ctrl+^"		},
    {   0x01BA, "ctrl+6"        },      {   0x01BB, "ctrl+7"        },
    {   0x01BC, "ctrl+8"        },      {   0x01BD, "ctrl+9"        },

    {   0x01C0, "ctrl+a"        },      {   0x01C1, "ctrl+b"        },
    {   0x01C2, "ctrl+c"        },      {   0x01C3, "ctrl+d"        },
    {   0x01C4, "ctrl+e"        },      {   0x01C5, "ctrl+f"        },
    {   0x01C6, "ctrl+g"        },      {   0x01C7, "ctrl+h"        },
    {   0x01C8, "ctrl+i"        },      {   0x01C9, "ctrl+j"        },
    {   0x01CA, "ctrl+k"        },      {   0x01CB, "ctrl+l"        },
    {   0x01CC, "ctrl+m"        },      {   0x01CD, "ctrl+n"        },
    {   0x01CE, "ctrl+o"        },      {   0x01CF, "ctrl+p"        },
    {   0x01D0, "ctrl+q"        },      {   0x01D1, "ctrl+r"        },
    {   0x01D2, "ctrl+s"        },      {   0x01D3, "ctrl+t"        },
    {   0x01D4, "ctrl+u"        },      {   0x01D5, "ctrl+v"        },
    {   0x01D6, "ctrl+w"        },      {   0x01D7, "ctrl+x"        },
    {   0x01D8, "ctrl+y"        },      {   0x01D9, "ctrl+z"        },

    {   0x01DC, "ctrl+f1"       },      {   0x01DD, "ctrl+f2"       },
    {   0x01DE, "ctrl+f3"       },      {   0x01DF, "ctrl+f4"       },
    {   0x01E0, "ctrl+f5"       },      {   0x01E1, "ctrl+f6"       },
    {   0x01E2, "ctrl+f7"       },      {   0x01E3, "ctrl+f8"       },
    {   0x01E4, "ctrl+f9"       },      {   0x01E5, "ctrl+f10"      },
    {   0x01E6, "ctrl+f11"      },      {   0x01E7, "ctrl+f12"      },

    {   0x01E8, "ctrl+`"        },      {   0x01E9, "ctrl+-"        },
    {   0x01EA, "ctrl+="        },      {   0x01EB, "ctrl+["        },
    {   0x01EC, "ctrl+]"        },      {   0x01ED, "ctrl+\\"       },
    {   0x01EE, "ctrl+;"        },      {   0x01EF, "ctrl+'"        },
    {   0x01F0, "ctrl+,"        },      {   0x01F1, "ctrl+."        },
    {   0x01F2, "ctrl+/"        },

    {   0x01F4, "ctrl+home"     },      {   0x01F5, "ctrl+end"      },
    {   0x01F6, "ctrl+left"     },      {   0x01F7, "ctrl+right"    },
    {   0x01F8, "ctrl+up"       },      {   0x01F9, "ctrl+down"     },
    {   0x01FA, "ctrl+pgup"     },      {   0x01FB, "ctrl+pgdn"     },
    {   0x01FC, "ctrl+ins"      },      {   0x01FD, "ctrl+del"      },
    {   0x01FE, "ctrl+goto"     },

    {   0x0200, "ctrl+num0"     },      {   0x0201, "ctrl+num1"     },
    {   0x0202, "ctrl+num2"     },      {   0x0203, "ctrl+num3"     },
    {   0x0204, "ctrl+num4"     },      {   0x0205, "ctrl+num5"     },
    {   0x0206, "ctrl+num6"     },      {   0x0207, "ctrl+num7"     },
    {   0x0208, "ctrl+num8"     },      {   0x0209, "ctrl+num9"     },

    {   0x020C, "ctrl+num-"     },      {   0x020D, "ctrl+num+"     },
    {   0x020E, "ctrl+num*"     },      {   0x020F, "ctrl+num/"     },
    {   0x0210, "ctrl+numenter" },

    {   0x0214, "ctrl+space"    },      {   0x0215, "ctrl+bksp"     },
    {   0x0216, "ctrl+tab"      },      {   0x0217, "ctrl+bktab"    },
	{	0x0218, "ctrl+esc"		},		{	0x0219, "ctrl+enter"	},

    {   0x0228, "shift+f1"      },      {   0x0229, "shift+f2"      },
    {   0x022A, "shift+f3"      },      {   0x022B, "shift+f4"      },
    {   0x022C, "shift+f5"      },      {   0x022D, "shift+f6"      },
    {   0x022E, "shift+f7"      },      {   0x022F, "shift+f8"      },
    {   0x0230, "shift+f9"      },      {   0x0231, "shift+f10"     },
    {   0x0232, "shift+f11"     },      {   0x0233, "shift+f12"     },

    {   0x0234, "shift+home"    },      {   0x0235, "shift+end"     },
    {   0x0236, "shift+left"    },      {   0x0237, "shift+right"   },
    {   0x0238, "shift+up"      },      {   0x0239, "shift+down"    },
    {   0x023A, "shift+pgup"    },      {   0x023B, "shift+pgdn"    },
    {   0x023C, "shift+ins"     },      {   0x023D, "shift+del"     },
    {   0x023E, "shift+goto"    },

    {   0x0240, "shift+num0"    },      {   0x0241, "shift+num1"    },
    {   0x0242, "shift+num2"    },      {   0x0243, "shift+num3"    },
    {   0x0244, "shift+num4"    },      {   0x0245, "shift+num5"    },
    {   0x0246, "shift+num6"    },      {   0x0247, "shift+num7"    },
    {   0x0248, "shift+num8"    },      {   0x0249, "shift+num9"    },

    {   0x024C, "shift+num-"    },      {   0x024D, "shift+num+"    },
    {   0x024E, "shift+num*"    },      {   0x024F, "shift+num/"    },
    {   0x0250, "shift+numenter"},

    {   0x0254, "shift+space"   },      {   0x0255, "shift+bksp"    },
    {   0x0256, "shift+tab"     },      {   0x0257, "shift+bktab"   },
    {   0x0258, "shift+esc"     },      {   0x0259, "shift+enter"   },


    {   0x0000, NULL        }
};

char UnknownKey [] = "???";


/*** ReadCmd - read the next command from the keyboard.
*
*  ReadCmd is used whenever an editor function is being read. It reads a
*  keystroke and looks it up in the key definition table and returns the
*  matching function.
*
* Input:
*  none
*
* Globals:
*  keyCmd	= last key hit. Updated.
*
* Output:
*  Returns a pointer to function. If not a macro, the function's arg is the
*  keystroke actually used. In addition, the key used is placed in wKeyCmd.
*
*************************************************************************/
PCMD
ReadCmd (
    void
    ) {

    WORD    i;                              /* key code                 */
    EVTargs e;                              /* arg struct for declaring event*/

    do {
        if (!TypeAhead () ) {

            SetEvent( semIdle );

            keyCmd = TranslateKey (ReadChar ());

        WaitForSingleObject(semIdle, INFINITE);
        } else {
            keyCmd = TranslateKey (ReadChar ());
        }
        e.arg.key = keyCmd.KeyInfo;
    } while (DeclareEvent (EVT_RAWKEY, (EVTargs *)&e));

    if (fCtrlc && keyCmd.KeyCode == 0) {
        return NameToFunc ("cancel");
    }

    i = keyCmd.KeyCode;

    if (i > 0 && i <= LAST_CODE) {
        if ((PVOID)CodeCmdMap[i]->func != (PVOID)macro) {
            if ( (PVOID)CodeCmdMap[i]->func == (PVOID)(unassigned) ) {
                CodeCmdMap[i]->arg = (long)keyCmd.KeyCode;
            } else {
                CodeCmdMap[i]->arg = keyCmd.KeyInfo.LongData;
            }
		}
		return CodeCmdMap[i];
    }

	return (PCMD) &cmdUnassigned;
}



/*** FreeMacs - Unassign all keys assigned to macros
*
*  This routine is used to unassign all keys that are assigned to macro
*  definitions. Called immediately prior to releasing all macro definitions.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
FreeMacs (
    void
    ) {
    int     i       = 0;

    while (CodeCmdMap[i]) {
        if ((PVOID)CodeCmdMap[i]->func == (PVOID)macro) {
            CodeCmdMap[i] = CMD_unassigned;
        }
        i++;
    }
}









/*** CodeToName - convert a key codeinto a printable name for the keystroke
*
* Purpose:
*
*   If the index is >= 0x0100, we use the text corresponding to the key in
*   the special key table.  If the index is <= 0x00FF, we look up the
*   key (= index) in the special key table and use the corresponding string.
*   If the key is < 0x0020, we display it as ^ followed by a letter.  If
*   the key is >= 0x0080, we display the key as alt-ddd.  Otherwise, the
*   index itself is a printable character.
*
* Input:
*
*   index	Index of keystroke of interest
*
* Output:
*
*   p		buffer to place readable name
*
*************************************************************************/
void
CodeToName (
    WORD Code,
    char *p
    ) {

    WORD i = 0;
    char * pName = NULL;

    while (CodeNameMap[i].pName != NULL) {
        if (CodeNameMap[i].KeyCode == (WORD)Code) {
            pName = CodeNameMap[i].pName;
            break;
        }
        i++;
    }

    if (pName) {
        strcpy(p, pName);
    } else {
        *p = '\0';
    }
}





/*** NameToCode - convert a key name into a key code
*
* Purpose:
*
*   If the name is one character, then index = first char of name.  If name
*   is two characters and begins with ^, then index = control-second
*   character.	If the name is alt-ddd, then use ddd as the index.
*   Otherwise, look up name in key table, convert the found keystroke to an
*   index and return that index.
*
* Input:
*
*   pName	character pointer to name being indexed
*
* Output:
*
*   Returns     0-based index of matching key or 0 if not found
*
*************************************************************************/
WORD
NameToCode (
    char *pName
    )
{

    WORD i      = (WORD)strlen (pName);
    WORD Code   = 0;
    char L_Name[20] = {0};

    if (i == 1) {
        //
        //  Code is ascii
        //
        return (WORD)(pName[0]);
    } else if (i == 2 && pName[0] == '^') {
        sprintf(L_Name, "ctrl+%c", pName[1]);
    } else {
        strncat(L_Name, pName, sizeof(L_Name)-1);
    }

    i = 0;
    while (CodeNameMap[i].pName != NULL) {
        if (!strcmp(L_Name, CodeNameMap[i].pName)) {
            Code = CodeNameMap[i].KeyCode;
            break;
        }
        i++;
    }

    if (Code) {
        return Code;
    } else {
        return 0;
    }
}




/*** SetKey - associate an editor function with a keystroke
*
* SetKey is used to create a keyboard assignment. Any current assignment to
* the keystroke is discarded and each time that particular keystroke is
* seen, the corresponding editor function will be invoked.
*
* Input:
*  name		= local pointer to name of string being assigned
*  p		= pointer to keystroke
*
* Output:
*  Returns TRUE if a successful assignment was made.
*
*************************************************************************/
flagType
SetKey (
    char    *name,
    char    *p
    )
{

    WORD    Code;
    buffer  keybuf = {0};
    PCMD    pCmd;

    if (strlen(strncat (keybuf, p, sizeof(keybuf)-1)) > 1) {
        _strlwr (keybuf) ;
    }
    Code = NameToCode (keybuf);
    if (Code) {
        if (pCmd = NameToFunc (name)) {
            CodeCmdMap[Code] = pCmd;
            return TRUE;
        }
    }
    return FALSE;
}



/*** FuncOut - append into a file current key assignments
*
* Purpose:
*
* Input:
*
*   pFunc	pointer to command structure
*   pFile	file to place text
*
* Output: None.
*
*************************************************************************/
void
FuncOut (
    PCMD pFunc,
    PFILE pFile
    ) {

    WORD     i;
    char     *p;
    flagType fFirst;

    if ((PVOID)pFunc->func != (PVOID)graphic && (PVOID)pFunc->func != (PVOID)unassigned) {
        sprintf (buf, "%20Fs:", pFunc->name);
        p = buf + 21;
        fFirst = TRUE;

        for (i = 0; CodeCmdMap[i] != NULL; i++) {
            if (CodeCmdMap[i] == pFunc) {
                CodeToName (i, p);
                AppFile (buf, pFile);
                fFirst = FALSE;
            }
        }

        if (fFirst) {
            sprintf (p, "is unassigned");
            buf[0] = ';';
            AppFile (buf, pFile);
        }
    }
}




/*** FuncToKeys - return all key names for a key attached to the given function
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
char *
FuncToKeys (
    PCMD pFunc,
    char * dst
    ) {

    WORD     i;
    flagType f = FALSE;

    for (i = 0; CodeCmdMap[i] != NULL; i++) {
        if (CodeCmdMap[i] == pFunc) {
            if (f) {
                sprintf (strend (dst), " and ");
            }
	    f = TRUE;
            CodeToName (i, strend (dst));
        }
    }

    if (!f) {
        sprintf (strend (dst), "is unassigned");
    }

    return dst;
}




/*** FuncToKey - return a key name for a key attached to the given function
*
* Purpose:
*
*   used only by showasg ()
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
char *
FuncToKey (
    PCMD pFunc,
    char * dst
    ) {

    WORD i;

    dst[0] = '\0';

    for (i = 0; CodeCmdMap[i] != NULL; i++) {
        if (CodeCmdMap[i] == pFunc) {
            CodeToName (i, dst);
            break;
        }
    }
    return dst;
}




/*** UnassignedOut - Dump the names of all unassigned keys to a file
*
* Purpose:
*
*   Used by showasg to generate the table of unassigned keys.
*
* Input:
*   pFile - File to dump to.
*
* Output: None
*
*************************************************************************/
void
UnassignedOut (
    PFILE pFile
    ) {

    WORD i, col = 0;
    char KeyName[20];

    buf[0] = ';';

    for (i = 0; CodeCmdMap[i] != NULL; i++) {
        if ((PVOID)CodeCmdMap[i]->func == (PVOID)unassigned) {
            CodeToName (i, KeyName);
	    sprintf (buf + col * 16 + 1, "%14s |", KeyName);
	    if (col++ == 4) {
		AppFile (buf, pFile);
		col = 0;
            }
        }
    }
}





/****************************************************************************
 *									    *
 *  SetKeyboard - Handle 'keyboard:' editor switch			    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	In order to support the extra keys on the IBM Enhanced keyboards,   *
 *	it is necessary to use a separate INT 16H service to characters.    *
 *	This can cause two problems:					    *
 *									    *
 *	    1. If the keyboard is mistakenly identified as enhanced when    *
 *	       it is not, unpredictable bad things may happen.		    *
 *									    *
 *	    2. Mouse menus don't support the enhanced keyboard BIOS call.   *
 *	       There may be other programs that do not either.		    *
 *									    *
 *	The user can then set 'keyboard:compatible' to solve the problem.   *
 *	This will prevent the user of F11, F12 and the grey keys.	    *
 *									    *
 *	Switch values are:						    *
 *									    *
 *	    keyboard:enhanced	-  Use INT 16H, AH = 10H		    *	*
 *	    keyboard:compatible -  Use INT 16H, AH = 0			    *	*
 *	    keyboard:		-  Detect keyboard type and use that	    *
 *									    *
 *  INPUT:								    *
 *									    *
 *	lpszVal     String following the colon				    *
 *									    *
 *  OUTPUT:								    *
 *									    *
 *	Int16_CmdBase  Set to 0 or 10H					    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	TRUE if lpszVal is acceptable					    *
 *	FALSE if lpszVal is not recognized				    *
 *	FALSE if lpszVal is 'enhanced', but we detect a compatible keyboard *
 *									    *
 ****************************************************************************/
char *
SetKeyboard (
    char *lpszVal
    ) {

    return NULL;

    lpszVal;
}



/*** ReadCmdAndKey - Read a key, return the command and key name
*
* Purpose:
*
*   This is used only by the <tell> function.  Waits for a key press,
*   then fills 'buf' with the name of the key.
*
* Input:
*   buf - Place for the key name
*
* Output:
*
*   buf  -  Gets filled with keyname.
*
*   Returns the PCMD attached to the key.
*
*************************************************************************/
PCMD
ReadCmdAndKey (
    char * buf
    ) {

    WORD        i;
    EVTargs     e;
    PCMD        pCmd;
    EDITOR_KEY  k;

    do {
        if (!TypeAhead () ) {

            SetEvent( semIdle);
            k = TranslateKey (ReadChar ());
        WaitForSingleObject( semIdle, INFINITE);
        } else {
            k = TranslateKey (ReadChar ());
        }
        e.arg.key = k.KeyInfo;
    } while (DeclareEvent (EVT_RAWKEY, (EVTargs *)&e));

    if (i = k.KeyCode) {
        CodeToName (i, buf);
        pCmd = CodeCmdMap[i];
    } else {
	strcpy (buf, UnknownKey);
	pCmd = CMD_unassigned;
    }

    return pCmd;
}

//
//	No-op, provided for compatibility with other versions of MEP, which do
//	not map the entire keyboard
//
flagType
noop (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
	argData; pArg; fMeta;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\keyboard.c ===
#include    "mep.h"
#include    "keyboard.h"

void
mepInitKeyboard (
    void
    ) {

    KBDMODE    Mode;

    Mode = CONS_ENABLE_ECHO_INPUT | CONS_ENABLE_WINDOW_INPUT | CONS_ENABLE_MOUSE_INPUT ;
    consoleSetMode(Mode);
}



void
KbHook (
    void
    ){

	KBDMODE Mode = OriginalScreenMode & ~(CONS_ENABLE_LINE_INPUT | CONS_ENABLE_PROCESSED_INPUT | CONS_ENABLE_ECHO_INPUT );
	consoleSetMode(Mode);
	consoleFlushInput();
}



void
KbUnHook (
    void
	){

	consoleSetMode(OriginalScreenMode);
}




KBDMODE
KbGetMode (
    void
    ){

    KBDMODE Mode;

	consoleGetMode(&Mode);
    return Mode;
}



void
KbSetMode (
    KBDMODE Mode
    ){

	consoleSetMode(Mode);
}



BOOL
TypeAhead (
    void
    ) {
	return consoleIsKeyAvailable();
}





KBDKEY
ReadChar (
    void
    ) {

	KBDKEY	kbdi;
	consoleGetKey(&kbdi, TRUE);
	return kbdi;
}



void
GetScreenSize (
    int*    pYsize,
    int*    pXsize
    ) {

    SCREEN_INFORMATION  ScreenInformation;
    consoleGetScreenInformation( MepScreen, &ScreenInformation );
    *pYsize = (int)(ScreenInformation.NumberOfRows);
	*pXsize = (int)(ScreenInformation.NumberOfCols);

}




flagType
SetScreenSize (
    int     YSize,
    int     XSize
    ) {

	if (consoleSetScreenSize( MepScreen, YSize, XSize)) {
		return TRUE;
	}
	return FALSE;
}    




void
SetVideoState (
    int     handle
    ) {

	consoleClearScreen(MepScreen, TRUE);

    handle;
}    







void
SaveScreen (
    void
    ) {
	//KBDMODE Mode = OriginalScreenMode & ~(CONS_ENABLE_LINE_INPUT | CONS_ENABLE_PROCESSED_INPUT | CONS_ENABLE_ECHO_INPUT );
	//consoleSetMode(Mode);
	consoleSetCurrentScreen(MepScreen);
}




void
RestoreScreen (
    void
    ) {
    //consoleSetMode(OriginalScreenMode);
	consoleSetCurrentScreen(OriginalScreen);
}



void
WindowChange (
	ROW 	Rows,
	COLUMN	Cols
	)
{

	char bufLocal[2];

	if ( (cWin > 1) && (( Rows > (ROW)(YSIZE+2) ) || ( Cols > (COLUMN)(XSIZE) )) ) {
		//
		//	Won't allow to grow the screen if we have more than one window.
		//
		consoleSetScreenSize(MepScreen, YSIZE+2, XSIZE );
		disperr (MSG_ASN_WINCHG);
		return;
	}

	// EnterCriticalSection( &ScreenCriticalSection );

	// consoleClearScreen( MepScreen, FALSE );


   if ( Rows == (ROW)YSIZE+3 ) {
		//
		//	Erase the status line.
		//

		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
		soutb(0, YSIZE+1, bufLocal, fgColor);
	}

	YSIZE = Rows-2;
	XSIZE = Cols;
	// LeaveCriticalSection( &ScreenCriticalSection );
	SetScreen();
	Display();
}


/*	SetCursorSize - set the cursor size
 *
 */
char *
SetCursorSizeSw (
    char *val
    )
{
	int 	i;
	buffer	tmpval = {0};

    strncat ((char *) tmpval, val, sizeof(tmpval)-1);

    i = atoi (tmpval);

	if (i != 0 && i != 1) {
		return "CursorSize: Value must be 0 or 1";
    }

	CursorSize = i;

	return SetCursorSize( CursorSize );

}


char *
SetCursorSize (
	int Size
    )
{
	ULONG	CursorStyle;

	if ( Size == 0 ) {
		CursorStyle = CURSOR_STYLE_UNDERSCORE;
	} else {
		CursorStyle = CURSOR_STYLE_BOX;
	}

	if ( !consoleSetCursorStyle( MepScreen, CursorStyle ) ) {
		return "CursorSize: Cannot set Cursor size";
	}

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\lang.c ===
/*** lang.c - Language dependent routines
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/
#include "mep.h"

typedef int ( __cdecl *STRCMP) (const char *, const char *);


/* return index+1 of first string s that is in table */
int
tblFind (
    char * tbl[],
    char * s,
    flagType fCase
    )
{
    int    i;
    STRCMP f;

    f = fCase ? (STRCMP)FNADDR(strcmp) : (STRCMP)FNADDR(_stricmp);
    for (i=0; tbl[i]; i++) {
        if (!(*f) (tbl[i], s)) {
            return i+1;
        }
    }
    return 0;
}




flagType
parseline (
    char *pbuf,
    char **ppbegtok,
    char **ppendtok
    ) {

    char *p1, *p2;

    p1 = whiteskip (pbuf);
    if (!*p1) {
	return FALSE;
    } else if (*(p2 = whitescan (p1))) {
	*p2++ = 0;
	p2 += strlen( p2 ) - 1;
	while (*p2)
            if (*p2 == ' ') {
		break;
            } else {
                p2--;
            }
        if (!*++p2) {
            p2 = NULL;
        }
    } else {
        p2 = NULL;
    }
    *ppbegtok = p1;
    *ppendtok = p2;
    return TRUE;
}




//
// csoftcr - perform C soft CR processing.
//
// Algorithm:
//  Given that you have just entered a newline at the end of a line:
//      If the original line begins with "}", tab back once.
//      else If the original line ends with "{" or begins with a C keyword, tab
//           in once.
//      else If the line >preceding< the original line >doen't< end with "{"
//           but does begin with a C keyword, tab back once.
//
//  C keywords used are: if, else, for, while, do, case, default.
//
int
csoftcr (
    COL  x,
    LINE y,
    char *pbuf
    ) {

    char *pbeg, *pend;

    if (parseline (pbuf, &pbeg, &pend)) {
        if (*pbeg == '}') {
	    return dobtab (x);
        } else if ( (pend && *pend == '{' ) || tblFind (cftab, pbeg, TRUE ) ) {
	    return doftab (x);
        } else if (y) {
	    GetLineUntabed (y-1, pbuf, pFileHead);
            if (parseline (pbuf, &pbeg, &pend)) {
                if ( !(pend && *pend == '{') && tblFind (cftab, pbeg, TRUE) ) {
                    return dobtab (x);
                }
            }
        }
    }
    return -1;
}




//
// softcr - perform semi-intelegent indenting.
//
// Algorithm:
//  Given that you have just entered a newline at the end of a line:
//      Move to the first non-blank position on the line.
//      If a C file, attempt to get new x position.
//      If not found, move to the first non-blank position on the following
//          line.
//      If that line was blank, stay in the original first non-blank position.
//
int
softcr (
    void
    ) {

    linebuf pbuf;
    char *p;
    int x1, x2;


    if (!fSoftCR) {
        return 0;
    }

    GetLineUntabed (YCUR(pInsCur), pbuf, pFileHead);

    if (*(p=whiteskip(pbuf)) == 0) {
        p = pbuf;
    }
    x1 = (int)(p - pbuf);

    switch (FTYPE(pFileHead)) {

    case CFILE:
	x2 = csoftcr (x1, YCUR(pInsCur), pbuf);
        break;

    default:
	x2 = -1;
        break;

    }

    if (x2 >= 0) {
        return x2;
    }

    GetLineUntabed (YCUR(pInsCur)+1, pbuf, pFileHead);
    if (pbuf[0] != 0) {
        if (*(p=whiteskip (pbuf)) != 0) {
            return (int)(p - pbuf);
        }
    }
    return x1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\ldelete.c ===
/*** LDELETE.C
*
*       Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"

flagType
ldelete (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    fl      fl;
    int     l;

    if (pArg->argType == STREAMARG) {
        StreamToBox (pArg);
    }

    switch (pArg->argType) {

    case NOARG:
        if (!fMeta) {
            pick (0, pArg->arg.noarg.y, 0, pArg->arg.noarg.y, LINEARG);
        }
	DelLine (TRUE, pFileHead, pArg->arg.noarg.y, pArg->arg.noarg.y);
	break;

    case NULLARG:
	l = LineLength (pArg->arg.nullarg.y, pFileHead);
        if (!fMeta) {
	    pick (min (l, pArg->arg.nullarg.x),   pArg->arg.nullarg.y,
		  max (l, pArg->arg.nullarg.x)-1, pArg->arg.nullarg.y,
                  BOXARG);
        }
	DelBox (pFileHead, min (l, pArg->arg.nullarg.x),   pArg->arg.nullarg.y,
			   max (l, pArg->arg.nullarg.x)-1, pArg->arg.nullarg.y);
	return TRUE;

    case LINEARG:
        if (!fMeta) {
	    pick (0, pArg->arg.linearg.yStart,
                  0, pArg->arg.linearg.yEnd, LINEARG);
        }
	DelLine (TRUE, pFileHead, pArg->arg.linearg.yStart,
				  pArg->arg.linearg.yEnd);
	fl.col = pInsCur->flCursorCur.col;
	fl.lin = pArg->arg.linearg.yStart;
	cursorfl (fl);
	break;

    case BOXARG:
        if (!fMeta) {
	    pick (pArg->arg.boxarg.xLeft,  pArg->arg.boxarg.yTop,
                  pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom, BOXARG);
        }
	DelBox (pFileHead, pArg->arg.boxarg.xLeft,    pArg->arg.boxarg.yTop,
			   pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom);
	fl.col = pArg->arg.boxarg.xLeft;
	fl.lin = pArg->arg.boxarg.yTop;
	cursorfl (fl);
	break;

    default:
	return FALSE;
    }
    return TRUE;

    argData;
}




/*** StreamToBox - Convert a stream arg to a box/line arg
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
StreamToBox (
    ARG * pArg
    ) {

    ARG arg;

    arg = *pArg;

    if (arg.arg.streamarg.xStart == arg.arg.streamarg.xEnd) {
        pArg->argType = LINEARG;

        pArg->arg.linearg.yStart = arg.arg.streamarg.yStart;
        pArg->arg.linearg.yEnd   = arg.arg.streamarg.yEnd;
    } else {
        pArg->argType = BOXARG;

        pArg->arg.boxarg.yTop    = arg.arg.streamarg.yStart;
        pArg->arg.boxarg.yBottom = arg.arg.streamarg.yEnd;

        if (arg.arg.streamarg.xEnd > arg.arg.streamarg.xStart) {
            pArg->arg.boxarg.xLeft  = arg.arg.streamarg.xStart;
            pArg->arg.boxarg.xRight = arg.arg.streamarg.xEnd - 1;
        } else {
            pArg->arg.boxarg.xLeft  = arg.arg.streamarg.xEnd;
            pArg->arg.boxarg.xRight = arg.arg.streamarg.xStart -1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\linsert.c ===
/*** linsert.c - line insert
*
*   Modifications:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/
#include "mep.h"


flagType
linsert (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    linebuf lbuf;
    int l;

    if (pArg->argType == STREAMARG) {
        StreamToBox (pArg);
    }

    switch (pArg->argType) {
    case NOARG:
	CopyLine (NULL, pFileHead, pArg->arg.noarg.y, pArg->arg.noarg.y,
				   pArg->arg.noarg.y);
        return TRUE;

    /*  TEXTARG illegal             */

    case NULLARG:
	GetLine (pArg->arg.nullarg.y, lbuf, pFileHead);
	strcpy (lbuf, whiteskip (lbuf));
	l = strlen (lbuf) + 1;
        if (l + pArg->arg.nullarg.x > sizeof(linebuf)) {
            LengthCheck (pArg->arg.nullarg.y, 0, NULL);
        }
	memmove ((char *) lbuf + pArg->arg.nullarg.x,(char *) lbuf, 
	      sizeof(linebuf) - l - pArg->arg.nullarg.x);
	memset ((char *) lbuf, ' ', pArg->arg.nullarg.x);
	PutLine (pArg->arg.nullarg.y, lbuf, pFileHead);
        return TRUE;

    case LINEARG:
	CopyLine (NULL, pFileHead, pArg->arg.linearg.yStart, pArg->arg.linearg.yEnd,
				   pArg->arg.linearg.yStart);
        return TRUE;

    case BOXARG:
	CopyBox (NULL, pFileHead, pArg->arg.boxarg.xLeft, pArg->arg.boxarg.yTop,
				  pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom,
				  pArg->arg.boxarg.xLeft, pArg->arg.boxarg.yTop);
	return TRUE;

    DEFAULT_UNREACHABLE;
    }

    argData; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\list.c ===
/***  LIST.C  File list handling functions
*
*       Copyright <C> 1988, Microsoft Corporation
*
*   In order to operate on a list of files, instead of just the current
*   file, we use a file list.  This is a name, much like a macro name, whose
*   value is a bunch of strings and/or lists.  We can think of a typical
*   list this way:
*
*	    list:= "one two three" sub1 "four" sub2 "five"
*	    sub1:= "subone subtwo" sub2 "subthree"
*	    sub2:= "whatever something nothing"
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "mep.h"

/****************************************************************************
 *
 *  LISTS:
 *
 *	A list is kept as a macro.  The interface defined here assumes
 *	the existence of M macro handling.
 *
 ****************************************************************************/

#define LITERAL 1

static buffer bufList;
static MI ScanStack[MAXUSE];
static int scanSP;


/*** ListWalker - Given a list head, call back with each list member
*
* Purpose:
*
*   To walk through a list and call back to a function with information
*   about each list element.  This function is used when the caller needs
*   access to the list itself.	When a copy of the list's elements is
*   sufficient, ScanList is preferred.
*
*   This function should not be used outside of this module.
*
* Input:
*   Parameters:
*	imac -> Index of list
*	pfn  -> Call back function
*
* Output:   None
*
* Notes:
*
*   The callback function takes four arguments:
*
*	pcmd -	The handle of the list currently being searched.  This is
*		important because it may be different from the original
*		during a recursive scan.
*
*	str  -	A buffer containing a copy of the current string
*
*	pmi  -	A pointer to the macro instance structure.  This contains:
*
*		    -> text - A pointer just beyond the current element
*		    -> beg  - The start of the current list.
*
*	i    - The index of the current element within the current sublist.
*
*************************************************************************/
void
ListWalker (
    PCMD     pcmd,
    flagType (*pfn)(PCMD, char *, PMI, int),
    flagType fRecurse
    ) {

    MI L_mi;
    int i;

    if (pcmd == NULL) {
        return;
    }

    assert ((PVOID)pcmd->func == (PVOID)macro);

    InitParse (pcmd, &L_mi);
    for (i = 0; fParseList (&L_mi, bufList); i++) {
        if (!fRecurse || TESTFLAG (L_mi.flags, LITERAL)) {
            if (!TESTFLAG (L_mi.flags, LITERAL)) {
                Listize (bufList);
            }
            if (!(*pfn)(pcmd, bufList, &L_mi, i)) {
                return;
            }
        }else {
            ListWalker (GetListHandle (bufList, FALSE), pfn, TRUE);
        }
    }
}





/*** ScanList - External list scanner, does not require keeping an instance
*
* Purpose:
*   To scan through a list.  Calling with a list handle will return the
*   first element of the list.	To get the rest of the list, call with
*   NULL until NULL is returned.
*
* Input:
*   Parameters:
*	pcmdStart -> Handle of list to start scanning, or NULL to get
*		     next element.
*	fRecurse  -> TRUE means go down sublists, FALSE means return
*		     sublist names with '@' prepended.
*
* Output:
*   Returns Pointer to next element, or NULL if there are no more.
*
* Note:
*   Does not allow multiple simultaneous scans.
*
*************************************************************************/
char *
ScanList (
    PCMD pcmdStart,
    flagType fRecurse
    ) {
    static MI L_mi;

    return ScanMyList (pcmdStart, &L_mi, bufList, fRecurse);
}





/*** ScanMyList - Real list scanner
*
* Purpose:
*   To scan through a list.  Calling with a list handle will return the
*   first element of the list.	To get the rest of the list, call with
*   NULL until NULL is returned.
*
* Input:
*   Parameters:
*	pcmdStart -> Handle of list to start scanning, or NULL to get
*		     next element.
*	pmi	  -> pointer to instance MI structure
*	bufScan   -> pointer to instance buffer
*	fRecurse  -> TRUE means go down sublists, FALSE means return
*		     sublist names with '@' prepended.
* Output:
*   Returns Pointer to next element, or NULL if there are no more.
*
* Note:
*   Allows multiple simultaneous scans.
*
*************************************************************************/
char *
ScanMyList (
    PCMD         pcmdStart,
    REGISTER PMI pmi,
    buffer       bufScan,
    flagType     fRecurse
    ) {

    if (pcmdStart) {
	scanSP = -1;		/* Clear list stack		      */
	InitParse (pcmdStart, pmi);
    }

    while (!fParseList(pmi, bufScan)) {  /* Pop till we find something   */
        if (!(fRecurse && fScanPop (pmi))) {
            return NULL;    /* We're completely done                */
        }
    }

    /* Push lists till we hit a string      */

    while (!TESTFLAG(pmi->flags, LITERAL)) {
	if (fRecurse) {
	    if (pcmdStart = GetListHandle (bufScan, FALSE)) {
		if (!fScanPush (pmi)) { /* Stack overflow */
		    printerror ("List Error: Nested too deeply at '%s'", bufScan);
		    return NULL;
                }
		InitParse (pcmdStart, pmi);
            } else {  /* Error! List does not exist */
		printerror ("List Error: '%s' does not exist", bufScan);
		return NULL;
            }

            if (!fParseList (pmi, bufScan)) {
                if (!fScanPop (pmi)) {
                    return NULL;
                }
            }
        } else {
	    Listize (bufScan);
	    break;
        }
    }
    return bufScan;
}




/*** fParseList - Return next list element
*
* Purpose:
*
*   To read a list.
*
* Input:
*   Parameters:
*	pmi ->	macroInstance.	Points to a macro value and the
*		element to be returned.
*
* Output:
*   Parameters:
*	pmi ->	The current element field is advanced.	The flags
*		field indicates whether we found a literal or a
*		sublist.
*	buf ->	Place to put the element.  If this is NULL, we do not
*		return the element.
*
*   Returns TRUE if something was found.
*
*************************************************************************/
flagType
fParseList (
    REGISTER PMI pmi,
    REGISTER char * buf
    ) {

    assert (pmi);
    assert (pmi->text);

    /* CONSIDER: DO we really want to ignore empty quote pairs? */
    /* Scan through any number of double quote pairs */
    while (*(pmi->text = whiteskip (pmi->text)) == '"') {
	pmi->flags ^= LITERAL;
	pmi->text++;
    }

    if (*pmi->text == '\0') {
        return FALSE;
    }

    if (buf) {	/* Copy to whitspace, " or end of string */
	while (!strchr ("\"\t ", *pmi->text)) {
            if (*pmi->text == '\\') {
                /* Backslashes protect characters */
                pmi->text++;
            }
	    *buf++ = *pmi->text++;
        }
	*buf = '\0';
    }
    return TRUE;
}





/****************************************************************************
 *
 *  List Stack Management.
 *
 *	ScanList uses a stack of MI's to keep track
 *	of what has been scanned so far.  The stack elements are kept in
 *	a private stack defined here.
 *
 ****************************************************************************/


/*** fScanPush - Save current list scan state
*
* Purpose:
*
*   Called by ScanList to save its place so a sublist can be scanned
*
* Input:
*   Parameters:
*	pmi ->	Pointer to instance to save.
*
* Output:
*   Returns FALSE for a stack overflow, TRUE otherwise.
*
*************************************************************************/
flagType
fScanPush (
    PMI pmi
    ) {

    if (scanSP >= (MAXUSE-1)) {
        return FALSE;
    }

    ScanStack[++scanSP] = *pmi;
    assert (scanSP >= 0);
    return TRUE;
}




/*** fScanPop - Restore previous scan state
*
* Purpose:
*
*   Restore state after scanning a sublist
*
* Input: None.
*
* Output:
*   Parameters:
*	pmi -> Place to put previous state
*
*   Returns TRUE if a meaningful pop took place, FALSE if there was no
*   previous state.
*
*************************************************************************/
flagType
fScanPop (
    PMI pmi /* register here increases code size */
    ) {

    if (scanSP < 0) {
        return FALSE;
    }

    *pmi = ScanStack[scanSP--];
    return TRUE;
}




/*** GetListHandle - Create a handle for the given list name
*
* Purpose:
*
*   It's much easier to deal with lists if the user can carry around something
*   that tells us how to access a list quickly.  Therefore, we use this to
*   take a literal name and return a PCMD of the macro
*
* Input:
*   Parameters:
*	sz  ->	Name to look for.
*
* Output:
*
*   Returns PLHEAD
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
PCMD
GetListHandle (
    char * sz,  /* register doesn't help */
    flagType fCreate
    )
{

    REGISTER PCMD * prgMac;

    for (prgMac = rgMac; prgMac < &rgMac[cMac]; prgMac++) {
        if (!strcmp ((*prgMac)->name, sz)) {
            return *prgMac;
        }
    }

    if (!fCreate) {
        return NULL;
    }

    SetMacro (sz, rgchEmpty);

    return rgMac[cMac-1];
}




/*** AddStrToList - Add a list item to the end of a list
*
* Purpose:
*
*   This is how we build lists, n'est-ce pas?
*
* Input:
*   Parameters:
*	pcmd->	List to append to
*	sz  ->	Item to add.  If this item begins with a @, then we add
*		a list (not the contents, the name).
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*   If the original string ends in a double quote ("), we assume that
*   this is a closing quote; the string ends with a literal.  If the
*   original ends with anything else, we assume that it is the end of
*   a list name.  If the string passed in begins with a '@', the rest
*   of the string is a list name.
*
*   To append a list to either type of original, we append a space and
*   the list name.
*
*   To append a literal to a literal terminated original, we replace the
*   original's double quote with a space, append the new string, then
*   append a double quote.
*
*   To append a literal to a list terminated original, we append a space
*   and double quote, the new string, then a double quote.
*
*   Backslashes are doubled.  This allows the list to be read by the
*   macro processor.
*
*************************************************************************/
void
AddStrToList (
    PCMD pcmd,
    char * sz   /* register doesn't help */
    ) {

    flagType fString = TRUE;	/* TRUE -> sz is a string, FALSE a list */
    flagType fQuote = FALSE;	/* TRUE means original ends in string	*/
    int len;			/* Length of original string		*/
    int lensz;			/* Length of new string 		*/
    int fudge = 0;		/* Additional spaces or quotes		*/
    REGISTER char * pchOld;	/* Original list			*/
    pathbuf szPathName; 	/* Place to put fully qualified filename*/

    if (!pcmd) {
        return;
    }

    // The user should not be able to pass in a non-macro PCMD.  The
    // user can specify a name for a list, and that name must be
    // translated into a PCMD by GetListHandle.  That function will
    // not return a PCMD for anything other than a macro.
    //
    assert ((PVOID)pcmd->func == (PVOID)macro);

    pchOld = (char *)pcmd->arg;

    len = RemoveTrailSpace (pchOld);

    if (sz[0] == '@') { /* We simply append this to the original    */
        sz[0] = ' ';
        fString = FALSE;
        strcpy (szPathName, sz);
    } else {
        CanonFilename (sz, szPathName);
        DoubleSlashes (szPathName);

        if (len && pchOld[len-1] == '"') {
            fQuote = TRUE;          /* We're appending a literal to */
            fudge = 1;              /* a list ending in a literal   */
            pchOld[len-1] = ' ';
        } else {
            fudge = 3;          /* Appending literal to non-literal */
        }
    }

    lensz = strlen (szPathName);

    /* Now generate new string  */

    pcmd->arg = (CMDDATA)ZEROREALLOC ((char *)pcmd->arg, len + lensz + fudge + 1);
    strcpy ((char *)pcmd->arg, pchOld);

    if (fString && !fQuote) {
        strcat ((char *)pcmd->arg, " \"");
    }

    strcat ((char *)pcmd->arg, szPathName);

    if (fString) {
        strcat ((char *)pcmd->arg, "\"");
    }
}




/***  fInList - Check to see if a string is already in the list
*
* Purpose:
*
*   To see if an element is in a list.
*
* Input:
*   Parameters:
*	pcmd -> List to look in
*	pch  -> Literal to look for
*
* Output:
*
*   Returns TRUE iff pch is in pcmd
*
*************************************************************************/
flagType
fInList (
    PCMD pcmd,
    char * pch,
    flagType fRecurse
    ) {

    char * pchList; /* register here increases code size */
    MI L_mi;

    for (pchList = ScanMyList (pcmd, &L_mi, bufList, fRecurse);
         pchList;
         pchList = ScanMyList (NULL, &L_mi, bufList, fRecurse)) {
        if (!_stricmp (pchList, pch)) {
            return TRUE;
        }
    }
    return FALSE;
}



/*** fDelStrFromList -
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
fDelStrFromList (
    PCMD pcmd,
    char * pch,
    flagType fRecurse
    ) {

    buf[0] = 0;
    strncat(buf, pch, sizeof(buf)-1);
    ListWalker (pcmd, CheckAndDelStr, fRecurse);

    return (flagType)(buf[0] == '\0');
}




/*** CheckAndDelStr - If str matches buf, remove it
*
* Purpose:
*
*   ListWalker callback function for fDelStrFromList.  Deletes a string from
*   a list.
*
* Input:
*   Parameters:
*	pcmd -> List to remove from
*	pch  -> Copy of the element to remove
*	pmi  -> Scan state
*	i    -> Index into pcmd of the element.
*
* Output:
*
*   Returns TRUE if successful
*
* Notes:
*
*   We use ListWalker instead of ScanList because we need access to the
*   list position itself, not a copy of the element.
*
*************************************************************************/
flagType
CheckAndDelStr(
    PCMD pcmd,
    char * pch,
    PMI pmi,            /* register doesn't help */
    int  i
    ) {

    char * pchNext; /* register doesn't help */

    if (!strcmp (pch, buf)) {
        DoubleSlashes (buf);
        pchNext = strbscan (pmi->text, " \t\"");
	memmove (pmi->text - strlen(buf), pchNext, strlen (pchNext) + 1);
        buf[0] = '\0';  /* signal success */
        return FALSE;
    }

    return TRUE;

    pcmd; i;
}




/*** GetListEntry - Given an index into a list, get the index'th element
*
* Purpose:
*
*   To get a particular list element when its position is known.
*
* Input:
*   Parameters:
*	pcmd  -> The list.
*	iList -> The index.
*
* Output:
*
*   Returns pointer to the element, or NULL if there is no iList'th element
*
*************************************************************************/
char *
GetListEntry (
    PCMD pcmd,
    int iList,
    flagType fRecurse
    ) {

    int i;
    REGISTER char * pchList;
    MI L_mi;

    for (pchList = ScanMyList (pcmd, &L_mi, bufList, fRecurse), i = 0;
         pchList && i < iList;
         pchList = ScanMyList (NULL, &L_mi, bufList, fRecurse), i++) {
        ;
    }
    return pchList;
}





/*** ListLen - Return the number of elements in the list
*
* Purpose:
*
*   To count the elements in a list. Useful when you don't want to toast
*   ScanList.
*
* Input:
*   Parameters:
*	pcmd -> The list.
*
* Output:
*
*   Returns Number of items in list.
*
*************************************************************************/
int
ListLen (
    PCMD pcmd,
    flagType fRecurse
    ) {

    MI L_mi;
    int i = 0;

    if (ScanMyList (pcmd, &L_mi, bufList, fRecurse)) {
        do {
            i++;
        }while (ScanMyList (NULL, &L_mi, bufList, fRecurse));
    }
    return i;
}




/*** fEmptyList - Test the list for being empty
*
* Purpose:
*
*   The fastest way to check for an empty list.  Useful when you don't
*   want to toast ScanList.
*
* Input:
*   Parameters:
*	pcmd -> The list, of course.
*
* Output:
*
*   Returns TRUE for empty list.
*
*************************************************************************/
flagType
fEmptyList (
    PCMD pcmd
    ) {

    MI L_mi;

    return (flagType)(NULL != ScanMyList (pcmd, &L_mi, bufList, FALSE));
}





/*** InitParse - set a search instance to the beginning of a list
*
* Purpose:
*
*   To set up a parsing instance to the beginning of a list.
*
* Input:
*   Parameters:
*	pcmd -> List
*	pmi  -> instance
*
* Output: None.
*
*************************************************************************/
void
InitParse (
    PCMD pcmd,
    PMI pmi     /* register doesn't help */
    ) {

    pmi->beg = pmi->text = (char *)pcmd->arg;
    pmi->flags = 0;
}




/*** Listize - Prepend a '@' to the argument
*
* Purpose:
*
*   To turn a string into a list name.	Works in place, assumes there is
*   room for it.
*
* Input:
*   Parameters:
*	sz -> Name to mess with
*
* Output: None.
*
*************************************************************************/
void
Listize (
    REGISTER char * sz
    ) {

    memmove ( sz+1, sz,strlen (sz)+1);
    sz[0] = '@';
}



/*** CanonFilename - Replace a simple filename with a full pathname
*
* Purpose:
*
*   To get a full pathname for a file.	The file need not exist.
*   The simple filename may be of the form $ENV:name or $(ENV):name.
*
* Input:
*
*   szName   -> Relative path/filename.
*   pchCanon -> Result.
*
* Output:
*
*   Returns pointer to full, lower-case pathaname with drive.
*
* Notes:
*
*   If szName has an $ENV specification and ENV is not defined, the
*   file is searched for in the root.
*   If given drive is a ghost drive, let the system prompt for a disk
*   change.
*
*************************************************************************/
char *
CanonFilename (
    char * szName,
    char * pchCanon
    ) {

    pathbuf L_buf;

    if ( strlen(szName) < sizeof(L_buf) ) {
        if (szName[0] == '<' || szName[0] == '\0') {
            strcpy (pchCanon, szName);
            return pchCanon;
        }

        strcpy (L_buf, szName);

        if ( szName
         && (szName[0] != '$' || findpath(szName, L_buf, TRUE))
             && !rootpath (L_buf, pchCanon)) {

            _strlwr (pchCanon);
            return pchCanon;
        }
    }
    return NULL;

}





/*** fEnvar - Check a filename for having a $ENV at the front
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
fEnvar (
    char * szName
    ) {
    return (flagType)((szName[0] == '$') && strchr (szName, ':'));
}




/*** ClearList - Make a list empty
*
* Purpose:
*
*   To quickly empty an existing list.
*
* Input:
*   pcmd -> List to clear
*
* Output: None
*
*************************************************************************/
void
ClearList (
    PCMD pcmd
    ) {
    SetMacro ((char *)pcmd->name, rgchEmpty);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\load.c ===
/*** load.c - handle z extensions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*  (The following discussion is applicable ONLY to Z running on DOS 3.x and
*  before).
*
*  Z is extended by reading special EXE files into memory and performing
*  some simple links between Z and the module. The entry point as specified
*  in the EXE is called. This entry is defined by the extension library
*  (which calls the user routine WhenLoaded).
*
*  Issues:
*
*   Initialization
*       The WhenLoaded routine is called. Since it has full _access to all Z
*       functions, it's entry-point table needs to be defined beforehand.
*
*       Solved by having the entry-point table statically defined and
*       located through a well-known pointer in the image.
*
*   Entry points
*       Z services need to have entry points allowing data
*       references. All extension entry points needs to be too.
*
*       Extensions are done by mandate. Z services will have stub routines
*       that perform the calling sequence conversions.
*
*   Revision History:
*
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/
#define INCL_DOSMODULEMGR
#define INCL_DOSFILEMGR
#define INCL_DOSINFOSEG

#include "mep.h"
#include "keyboard.h"
#include "cmds.h"
#include "keys.h"

#include <stdlib.h>
#include <errno.h>


#include "mepext.h"

#define DEBFLAG LOAD




/*** extension stub routines
*
*  These routines are required under the following conditions:
*
*       - The exported entry point takes a different parameter list than the
*         "real" internal routine.
*
*       - The exported entry point takes pointers, and the
*         "real" routine takes pointers.
*
*  In general, we try to maintain the exported routines as close to thier
*  internal counterparts as is possible.
*
*************************************************************************/
void
E_DelLine (
    PFILE   pFile,
    LINE    yStart,
    LINE    yEnd
    ) {

    DelLine (TRUE, pFile, yStart, yEnd);
}

char *
E_getenv (char *p)
{
    return (getenvOem(p));
}

void
E_DelFile (PFILE pFile)
{
    DelFile (pFile, TRUE);
}


int
E_GetLine (
    LINE     line,
    char *buf,
    PFILE    pFile
    ) {

        int      i;
    flagType fTabsSave = fRealTabs;

    fRealTabs = FALSE;
        i = GetLine (line, buf, pFile);
    fRealTabs = fTabsSave;

    return i;
}



long
E_ReadChar (void)
{
    EDITOR_KEY  Key;

    Key = TranslateKey( ReadChar() );

    return Key.KeyInfo.LongData;
}


/*** E_FileNameToHandle - Extension interface
*
*  Equivalent to our FileNameToHandle routine, except that strings are
*  copied local before FileNameToHandle is actually called, and we do
*  attempt to ensure that the file has been read prior to returning.
*
* Input:
*  As per FileNameToHandle
*
* Output:
*  Returns PFILE if successfull, else NULL.
*
* Exceptions:
*  Since we may call FileRead, the actions that ocurr there also apply
*  here.
*
*************************************************************************/
PFILE
E_FileNameToHandle (
    char *pName,
    char *pShortName
    ) {

        PFILE   pFileNew;

        if (pFileNew = FileNameToHandle (pName, pShortName )) {
        if (TESTFLAG(FLAGS (pFileNew),REFRESH)) {
            FileRead (pFileNew->pName, pFileNew, TRUE);
        }
    }
    return pFileNew;
}


flagType
E_FileRead (
    char *name,
    PFILE   pFile
    ) {

        return FileRead (name, pFile, TRUE);
}

int
E_DoMessage (
    char *p
    ) {

    return (p != 0) ? domessage ("%s", p) : domessage(NULL);
}


void
MoveCur (
    COL     x,
    LINE    y
    ) {

    fl fl;

    fl.col = x;
    fl.lin = y;
    cursorfl (fl);
}



void
E_Free(
        void *  p
        )
{
        FREE( p );
}



void *
E_Malloc(
        size_t n
        )
{

        return MALLOC( n );
}






/* GetEditorObject - Extension gateway into Z internal data
 *
 * This routines allows the extension user to get >copies< of certain Z editor
 * internal data items.
 *
 * index        = index to data item desired
 * wParam       = word parameter
 * pDest        = pointer to the location to place whatever it is the user
 *                wanted.
 *
 * The index varies, based on the request type. For RQ_FILE and RQ_WIN, the
 * low byte of the index specifes the "nth most recent file" or "window #n".
 * Special case value of FF, causes wParam to be used as the file or window
 * handle. Window values are 1-8, 0 is current window.
 *
 * returns TRUE on successfull copy of data, else FALSE for bad request.
 */
flagType
GetEditorObject (
    unsigned index,
    void     *wParam,
    void     *pDest
    ) {

    unsigned lowbyte;
    PFILE    pFileCur;
    PWND     pWinLocal;

    lowbyte = index & 0x00ff;

    switch (index & 0xf000) {           /* upper nyble is request type  */

        case RQ_FILE:
        if (lowbyte == RQ_THIS_OBJECT) {
            pFileCur = (PFILE)wParam;
        } else if (lowbyte == RQ_FILE_INIT) {
            pFileCur = pFileIni;
        } else {
            pFileCur = pFileHead;
            while (lowbyte-- && pFileCur) {
               pFileCur = pFileCur->pFileNext;
            }
        }

        if (pFileCur == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */

        case RQ_FILE_HANDLE:
                    *(PFILE *)pDest = pFileCur;
            return TRUE;

        case RQ_FILE_NAME:
                    strcpy((char *)pDest,pFileCur->pName);
            return TRUE;

        case RQ_FILE_FLAGS:
                    *(int *)pDest = pFileCur->flags;
            return TRUE;
        }
        break;

    //
    // We support the direct manipulation of the ref count, so that extensions
    // can cause pFiles to be preserved even when explicitly arg-refresh'ed by
    // users
    //
    case RQ_FILE_REFCNT:
                //  What is pFileCur?
                pFileCur = pFileHead;
                *(int *)pDest = pFileCur->refCount;
                return TRUE;

        case RQ_WIN:
            if (lowbyte == RQ_THIS_OBJECT) {
            pWinLocal = (PWND)wParam;
        } else if (lowbyte == 0) {
            pWinLocal = pWinCur;
        } else if ((int)lowbyte <= cWin) {
            pWinLocal = &(WinList[lowbyte-1]);
        } else {
            pWinLocal = 0;
        }

        if (pWinLocal == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */

        case RQ_WIN_HANDLE:
                    *(PWND *)pDest = pWinLocal;
            return TRUE;

        case RQ_WIN_CONTENTS:
            //{
            //    char b[256];
            //    sprintf(b, "GetWinContents: Index %d Win 0x%x pFile 0x%x\n",
            //            lowbyte, pWinLocal, pWinLocal->pInstance->pFile );
            //    OutputDebugString(b);
            //}
            ((winContents *)pDest)->pFile           = pWinLocal->pInstance->pFile;
                    ((winContents *)pDest)->arcWin.axLeft   = (BYTE)pWinLocal->Pos.col;
                    ((winContents *)pDest)->arcWin.ayTop    = (BYTE)pWinLocal->Pos.lin;
                    ((winContents *)pDest)->arcWin.axRight  = (BYTE)(pWinLocal->Pos.col + pWinLocal->Size.col);
                    ((winContents *)pDest)->arcWin.ayBottom = (BYTE)(pWinLocal->Pos.lin + pWinLocal->Size.lin);
            ((winContents *)pDest)->flPos           = pWinLocal->pInstance->flWindow;
            return TRUE;
        }
            break;

        case RQ_COLOR:
        if (lowbyte >= 20) {
            *(unsigned char *)pDest = (unsigned char)ColorTab[lowbyte-20];
        }
            return TRUE;

        case RQ_CLIP:
            *(unsigned *)pDest = kindpick;
            return TRUE;

    }

    return FALSE;
}





/* SetEditorObject - Extension gateway into setting Z internal data
 *
 * This routines allows the extension user to set certain Z editor internal
 * data items.
 *
 * index        = index to data item desired
 * pSrc         = pointer to the location to get whatever it is the user
 *                wishes to set it to.
 *
 * returns TRUE on successfull copy of data, else FALSE for bad request.
 */
flagType
SetEditorObject(
    unsigned index,
    void     *wParam,
    void     *pSrc
    ) {

    unsigned lowbyte;
    PFILE    pFileCur;
    PWND     pWinLocal;

    lowbyte = index & 0xff;
    switch (index & 0xf000) {           /* upper nyble is request type  */

        case RQ_FILE:
            if (lowbyte == RQ_THIS_OBJECT) {
            pFileCur = (PFILE)wParam;
        } else {
            pFileCur = pFileHead;
            while (lowbyte-- && pFileCur) {
                pFileCur = pFileCur->pFileNext;
            }
        }

        if (pFileCur == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */

                case RQ_FILE_FLAGS:
                    pFileCur->flags = *(int *)pSrc;
                return TRUE;

        //
        // We support the direct manipulation of the ref count, so that extensions
        // can cause pFiles to be preserved even when explicitly arg-refresh'ed by
        // users
        //
                case RQ_FILE_REFCNT:
                    pFileCur->refCount = *(int *)pSrc;
                    return TRUE;
        }
            break;

        case RQ_WIN:
            if (lowbyte == RQ_THIS_OBJECT) {
            pWinLocal = (PWND)wParam;
        } else if (lowbyte == 0) {
            pWinLocal = pWinCur;
        } else if ((int)lowbyte <= cWin) {
            pWinLocal = &WinList[lowbyte-1];
        } else {
            pWinLocal = 0;
        }

        if (pWinLocal == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */
            case RQ_WIN_CUR:
                SetWinCur ((int)(pWinLocal - WinList));
                return TRUE;

            default:
                break;
        }

        case RQ_COLOR:
        if (lowbyte >= isaUserMin) {
            ColorTab[lowbyte-isaUserMin] = *(unsigned char *)pSrc;
        }
            break;

        case RQ_CLIP:
        kindpick = (WORD)wParam;
            return TRUE;
    }
    return FALSE;
}



/* NameToKeys - returns keys associated with function name
 *
 * pName        - pointer to function key name
 * pDest        - pointer to place for keys assigned (Can be same as pName)
 */
char *
NameToKeys (
    char *pName,
    char *pDest
    ) {

    buffer  lbuf = {0};
    PCMD    pCmd;

    strncat ((char *) lbuf, pName, sizeof(lbuf)-1);
    pCmd = NameToFunc (lbuf);
    lbuf[0] = 0;
    if (pCmd) {
        FuncToKeys(pCmd,lbuf);
    }
    strcpy (pDest, (char *) lbuf);

    return pDest;
}



/* E_KbHook - Hook keyboard, AND force next display to update screen
 */
int
E_KbHook(
    void
    ) {

    newscreen ();
    KbHook();
    return 1;
}




/* E_Error - Invalid entry
 */
int
E_Error(
    void
    ) {

    printerror ("Illegal Extension Interface Called");
    return 0;
}



/*** E_GetString - interface for prompting the user
*
*  Prompts the user for a string, and returns the result.
*
* Input:
*  fpb          = pointer to destination buffer for user's response
*  fpPrompt     = pointer to prompt string
*  fInitial     = TRUE => entry is highlighted, and if first function is
*                 graphic, the entry is replaced by that graphic.
*
* Output:
*  Returns TRUE if canceled, else FALSE
*
*************************************************************************/
flagType
E_GetString (
    char *fpb,
    char *fpPrompt,
    flagType fInitial
    ) {

        UNREFERENCED_PARAMETER( fInitial );

        return  (flagType)(CMD_cancel == getstring (fpb, fpPrompt, NULL, GS_NEWLINE | GS_INITIAL));

}

EXTTAB et =
    {   VERSION,
        sizeof (struct CallBack),
        NULL,
        NULL,
        {
            AddFile,
            BadArg,
            confirm,
            CopyBox,
            CopyLine,
            CopyStream,
            DeRegisterEvent,
            DeclareEvent,
            DelBox,
            E_DelFile,
            E_DelLine,
            DelStream,
            DoDisplay,
            E_DoMessage,
            fChangeFile,
            E_Free,
            fExecute,
            fGetMake,
            FileLength,
            E_FileNameToHandle,
            E_FileRead,
            FileWrite,
            FindSwitch,
            fSetMake,
            GetColor,
            GetTextCursor,
            GetEditorObject,
            E_getenv,
            E_GetLine,
            GetListEntry,
            E_GetString,
            E_KbHook,
            KbUnHook,
            E_Malloc,
            MoveCur,
            NameToKeys,
            NameToFunc,
            pFileToTop,
            PutColor,
            PutLine,
            REsearchS,
            E_ReadChar,
            ReadCmd,
            RegisterEvent,
            RemoveFile,
            Replace,
            ScanList,
            search,
            SetColor,
            SetEditorObject,
            SetHiLite,
            SetKey,
            SplitWnd
            }
        };


/*** SetLoad - load a new extension to Z
*
*  Since tools.ini really cannot execute editor commands as it is read,
*  we can get modules loaded by making the load operation a switch. SetLoad
*  is the mechanism by which things get loaded.
*
* Input:
*  val          = char pointer to remainder of assignment
*
* Output:
*  Returns pointer to error string if any errors are found, else NULL.
*
*************************************************************************/
char *
SetLoad (
    char *val
    ) {
    char    *pemsg;                         /* error returned by load       */

    if (pemsg = load (val, TRUE)) {
        return pemsg;
    } else {
        return NULL;
    }
}




/*** load - load, link, initialize Z extensions
*
*  Read the header into memory.
*  Allocate memory, perform relocations, link to resident, initialize.
*
* Input:
*  pName        = character pointer to name of file to be loaded
*  fLibPath     = TRUE => search 8 character basename under OS/2, allowing
*                 basename.DLL in LIBPATH.
*
* Output:
*  Returns C error code
*
*************************************************************************/
char *
load (
    char *pName,
    flagType fLibpath
    ) {

    pathbuf fbuf;                           /* full path (or user spec'd)   */
    pathbuf fname = {0};                    /* copy of input param          */
    int     i;                              /* everyone's favorite utility var*/
    EXTTAB  *pExt;                          /* pointer to the extension hdr */
    char    *pT;                            /* temp pointer to filename     */

    HANDLE  modhandle;                      /* library handle               */
    FARPROC pInit;                          /* pointer to init routine      */


    /*
     * barf if we have too many extensions
     */
    if (cCmdTab >= MAXEXT) {
        return sys_errlist[ENOMEM];
    }


    /*
     * make near copy of string
     */
    strncat ((char *) fname, pName, sizeof(fname)-1);

    /*
     * Form a fully qualified pathname in fbuf. If can't qualify, and there is
     * no extension, append ".PXT". If that fails, then just copy the text into
     * fbuf).
     */
    if (!findpath (fname, fbuf, FALSE)) {
        if (!(pT = strrchr (fname, '\\'))) {
            pT = fname;
        }
        if (!(strchr(pT, '.'))) {
            strcat (pT, ".pxt");
            if (!findpath (fname, fbuf, FALSE)) {
                strcpy (fbuf, fname);
            }
        } else {
            strcpy (fbuf, fname);
        }
    }

    /*
     * See if extension already loaded, by looking for the filename.ext in the
     * table. If already loaded, we're done.
     */
    filename (fbuf, fname);
    for (i = 1; i < cCmdTab; i++) {
        if (!strcmp (pExtName[i], fname)) {
            return 0;
        }
    }

    if (! (modhandle = LoadLibrary(fbuf))) {
        if (fLibpath) {
            filename(fbuf, fname);
            if (!(modhandle = LoadLibrary(fname))) {
                //
                // error here
                //
                sprintf( buf, "load:%s - Cannot load, Error: %d", fname, GetLastError() );
                return buf;
            }
        }
    }


    /*
     * One way or another, we succeeded. Now get the address of the ModInfo
     */
    if (!(pExt = (EXTTAB *)GetProcAddress(modhandle, "ModInfo"))) {
        FreeLibrary(modhandle);
        return buf;
        }

    //
    //  Version check.  Check to see if the extensions version is in our
    //  allowed range.  If it isn't, we fail due to a bad version.  If it
    //  is, we handle it specially
    //

    if (pExt->version < LOWVERSION || pExt->version > HIGHVERSION) {
        FreeLibrary(modhandle);
        return sys_errlist[ENOEXEC];
        }

    //
    //  For now, we will allow appending of entries.  Make sure that the
    //  number required by the extension is not more than we can supply
    //

    if (pExt->cbStruct > sizeof (struct CallBack)) {
        FreeLibrary(modhandle);
        return sys_errlist[ENOEXEC];
        }

    /*
     * get the current registers (for our DS), and get the entry point to the
     * .DLL.
     */
    if (!(pInit = GetProcAddress(modhandle, "EntryPoint"))) {
        FreeLibrary(modhandle);
        return buf;
    }
    /*
     * Copy to the extension's call table the table we have defined. Copy only
     * the number of entry points that the extension knows about, in case it is
     * less than we support.
     */
    memmove (&pExt->CallBack, &et.CallBack, pExt->cbStruct);

    /*
     * Now that we know the extension will be staying, set up the appropriate
     * info in our internal tables.
     */
    filename (fname, fbuf);
    pExtName[cCmdTab] = ZMakeStr (fbuf);
    swiSet[cCmdTab  ] = pExt->swiTable;
    cmdSet[cCmdTab++] = pExt->cmdTable;

    /*
     *  Finally, Initialize the extension
     */
    //assert (_heapchk() == _HEAPOK);
    (*pInit) ();
    //assert (_heapchk() == _HEAPOK);

    /*
     * use root extension name for TOOLS.INI initialization & Load any
     * extension-specific switches
     */
    filename (pExtName[cCmdTab-1], fname);
    DoInit (fname, NULL, 0L);

    return 0;
}







/*** AutoLoadExt - Automatically load extensions
*
*  Search for, and automatically load extensions.
*
*  On startup, this routine is called to search for and load extension which
*  match a particular name pattern:
*
*   Version 1.x,:   m*.mxt on PATH
*   Version 2.x,:   pwb*.mxt on PATH
*
*  Under OS/2, the normal load processing does NOT occur, such that M*.DLL
*  is NOT looked for on the path.
*
*  Any failures during these loads are NOT reported. It is assumed that any
*  files which match the pattern and cannot be loaded are not valid
*  extensions. The "load:" command executed anywhere else will report the
*  appropriate errors on explicit attempts to load the files.
*
* Input:
*  none
*
* Output:
*  Returns nothing.
*
*************************************************************************/
void
AutoLoadExt (
    void
    ) {
    char    *pathenv;    /* contents of PATH environment var*/
    va_list templist;

    memset( &templist, 0, sizeof(va_list) );
    AutoLoadDir (".", templist);
    // pathenv = getenv("PATH");
    pathenv = getenvOem("PATH");
    if (pathenv) {
        forsemi (pathenv, AutoLoadDir, NULL);
        free( pathenv );
    }
}




/*** AutoLoadDir - Scan one directory for Auto-Load files
*
*  Support routine for AutoLoadExt. Generally called by forsemi(). Scans a single
*  directory for files which can be autoloaded.
*
* Input:
*  dirname      = directory name.
*
* Output:
*  Returns nothing
*
*************************************************************************/
flagType
AutoLoadDir (
    char    *dirname,
    va_list dummy
    ) {

    buffer  patbuf = {0};
    /*
     * Construct the fully qualified pattern to be searched for, and use forfile.
     */
        strncat (patbuf, dirname, sizeof(patbuf)-1);
        if ( patbuf[0] != '\0' ) {
                if ( patbuf[strlen(patbuf) - 1] != '\\' ) {
                        strcat(patbuf, "\\");
                }
        }
    strcat (patbuf, rgchAutoLoad);
    forfile (patbuf, A_ALL, AutoLoadFile, NULL);
    return TRUE;
    dummy;
}





/*** AutoLoadFile - Auto-Load one extension
*
*  Called by forfile() when a match is found. Simply calls load() with
*  the filename.
*
* Input:
*  szFile       - filename to attempt to load
*
* Output:
*  Returns nothing.
*
*************************************************************************/
void
AutoLoadFile (
    char    *szFile,
    struct findType *pfbuf,
    void * dummy
    ) {

    load (szFile, FALSE);

    pfbuf; dummy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\macro.c ===
/*  macro.c - perform keystroke macro execution
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"


/*  macros are simply a list of editor functions interspersed with quoted
 *  strings.  The execution of a macro is nothing more than locating each
 *  individual function and calling it (calling graphic (c) for each quoted
 *  character c).  We maintain a stack of macros being executed; yes, there is
 *  a finite nesting limit.  Sue me.
 *
 *  Each editor function returns a state value:
 *	TRUE => the function in some way succeeded
 *	FALSE => the functin in some way failed
 *
 *  There are several macro-specific functions that can be used to take
 *  advantage of these values:
 *
 *
 *  :>label	defines a text label in a macro
 *
 *  =>label	All are transfers of control.  => is unconditional transfer,
 *  ->label	-> transfers if the previous operation failed and +> transfers
 *  +>label	if the previous operation succeeded.
 *		If the indicated label is not found, all macros are terminated
 *		with an error.	If no label follows the operator it is assumed
 *		to be an exit.
 */



/*  macro adds a new macro to the set being executed
 *
 *  argData	pointer to text of macro
 */
flagType
macro (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ){
    return fPushEnviron ((char *) argData, FALSE);

    pArg; fMeta;
}





/*  mtest returns TRUE if a macro is in progress
 */
flagType
mtest (
    void
    ) {
    return (flagType)(cMacUse > 0);
}





/* mlast returns TRUE if we are in a macro and the next command must come
 * from the keyboard
 */
flagType
mlast (
    void
    ) {
    return (flagType)(cMacUse == 1
                        &&  (   (mi[0].text[0] == '\0')
                                || (   (mi[0].text[0] == '\"')
                                    && (*whiteskip(mi[0].text + 1) == '\0')
                                   )
                            )
                    );
}





/*  fParseMacro - parses off next macro command
 *
 *  fParse macro takes a macro instance and advances over the next command,
 *  copying the command to a separate buffer.  We return a flag indicating
 *  the type of command found.
 *
 *  pMI 	pointer to macro instance
 *  pBuf	pointer to buffer where parsed command is placed
 *
 *  returns	flags of type of command found
 */
flagType
fParseMacro (
    struct macroInstanceType *pMI,
    char *pBuf
    ) {

    char *p;
    flagType fRet = FALSE;

    // Make sure the instance is initialized.  This means that ->text
    // is pointing to the first command in the macro.  If this is a graphic
    // character, skip over the " and set the GRAPH flag.
    //
    if (TESTFLAG (pMI->flags, INIT)) {
	pMI->text = whiteskip (pMI->text);
	if (*pMI->text == '"') {
	    pMI->text++;
	    SETFLAG (pMI->flags, GRAPH);
        }
	RSETFLAG (pMI->flags, INIT);
    }

    if (TESTFLAG (pMI->flags, GRAPH) && *pMI->text != '\0') {
        // We are inside quotes.  If we are now looking at
        // a \, skip to the next character.  Don't forget to check
        // for a \ followed by nothing.
        //
        if (*pMI->text == '\\') {
            if (*++pMI->text == 0) {
                return FALSE;
            }
        }
	*pBuf++ = *pMI->text++;
	*pBuf = 0;

        // If the next character is a ", move -> up to the following
        // command and signal that we're out of quotes.
        //
	if (*pMI->text == '"') {
	    RSETFLAG (pMI->flags, GRAPH);
	    pMI->text = whiteskip (pMI->text+1);
        }
	fRet = GRAPH;
    } else {
        // We are outside quotes.  First read through any
        // <x commands.
        //
        while (*(pMI->text) == '<') {
            pMI->text = whiteskip(whitescan(pMI->text));
        }

        // Now skip through whitespace to the command name.
        // Copy what we find into the caller's buffer.
        //
	p = whitescan (pMI->text);
	memmove ((char*) pBuf, (char *) pMI->text, (unsigned int)(p-pMI->text));
	pBuf[p-pMI->text] = '\0';

	pMI->text = whiteskip (p);  /* Find the next thing in the macro. */
    }

    // If the next thing is a quote, enter quote mode.
    //
    if (*pMI->text == '"') {
	SETFLAG (pMI->flags, GRAPH);
	pMI->text++;
    }
    return fRet;
}





/*** fMacResponse - peek ahead and eat any embedded macro response
*
* Purpose:
*  Scans ahead in the macro text for an item beginning with a "<", which
*  supplies a response to the question asked by a preceding function.
*
* Input:
*  None
*
* Output:
*  Returns NULL if not found, -1 if the user is to be prompted, and a character
*  if a character is supplied.
*
* Exceptions:
*  none
*
*************************************************************************/
int
fMacResponse (
    void
    ) {

    int     c;
    struct macroInstanceType *pMI;

    if (mtest()) {
        pMI = &mi[cMacUse-1];
        if ((TESTFLAG (pMI->flags, INIT | GRAPH)) == 0) {
            if (*(pMI->text) != '<')
                return 0;
            c = (int)*(pMI->text+1);
            if ((c == 0) || (c == ' ')) {
                return -1;
            }
            pMI->text = whiteskip(pMI->text+2);
            return c;
        }
    }
    return -1;
}




/*  fFindLabel finds a label in macro text
 *
 *  The goto macro functions call fFindLabel to find the appropriate label.
 *  We scan the text (skipping quoted text) to find the :> leader for the label.
 *
 *  pMI 	pointer to active macro instance
 *  lbl 	label to find (case is not significant) with goto operator
 *		=>, -> or +>  This will be modified.
 *
 *  returns	TRUE iff label was found
 */
flagType
fFindLabel (
    struct macroInstanceType *pMI,
    buffer lbl
    ) {

    buffer lbuf;

    lbl[0] = ':';
    pMI->text = pMI->beg;
    while (*pMI->text != '\0') {
        if (!TESTFLAG (fParseMacro (pMI, lbuf), GRAPH)) {
            if (!_stricmp (lbl, lbuf)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}




/*  mPopToTop - clear off intermediate macros up to a fence
 */
void
mPopToTop (
    void
    ) {

    while (cMacUse && !TESTFLAG (mi[cMacUse-1].flags, EXEC)) {
        cMacUse--;
    }
}




/*  mGetCmd returns the next command from the current macro, popping state
 *
 *  The command-reader code (cmd) calls mGetCmd when a macro is in progress.
 *  We are expected to return either a pointer to the function (cmdDesc) for
 *  the next function to execute or NULL if there the current macro is finished.
 *  We will adjust the state of the interpreter when a macro finishes.	Any
 *  errors detected result in ALL macros being terminated.
 *
 *  For infinite looping inside a macro, we will look for ^C too.
 *
 *  returns	NULL if current macro finishes
 *		pointer to function descriptor for next function to execute
 */
PCMD
mGetCmd (
    void
    ) {

    buffer mname;
    PCMD pFunc;
    struct macroInstanceType *pmi;

    if (cMacUse == 0) {
        IntError ("mGetCmd called with no macros in effect");
    }
    pmi = &mi[cMacUse-1];
    while ( pmi->text &&  *pmi->text != '\0') {
        //  Use heuristic to see if infinite loop
        //
        if (fCtrlc) {
            goto mGetCmdAbort;
        }


        if (TESTFLAG (fParseMacro (pmi, mname), GRAPH)) {
            pFunc = &cmdGraphic;
                pFunc->arg = mname[0];
            return pFunc;
            }

            /*
             * if end of macro, exit
             */
            if (!mname[0]) {
                break;
            }

        _strlwr (mname);

        pFunc = NameToFunc (mname);

            //  found an editor function / macro
            //
            if (pFunc != NULL) {
            return pFunc;
            }

        if (mname[1] != '>' ||
            (mname[0] != '=' && mname[0] != ':' &&
             mname[0] != '+' && mname[0] != '-')) {
            printerror ("unknown function %s", mname);
            goto mGetCmdAbort;
            }

        /* see if goto is to be taken */
        if (mname[0] == '=' ||
            (fRetVal && mname[0] == '+') ||
            (!fRetVal && mname[0] == '-')) {

            /* if exit from current macro, then exit scanning loop
             */
                if (mname[2] == '\0') {
                    break;
                }

            /* find label
             */
            if (!fFindLabel (pmi, mname)) {
            printerror ("Cannot find label %s", mname+2);
mGetCmdAbort:
            resetarg ();
            DoCancel ();
            mPopToTop ();
            break;
                }
            }
    }

    /*	we have exhausted the current macro.  If it was entered via EXEC
     *	we must signal TopLoop that the party's over
     */
    fBreak = (flagType)(TESTFLAG (mi[cMacUse-1].flags, EXEC));
    if ( cMacUse > 0 ) {
        cMacUse--;
    }
    return NULL;
}




/*  fPushEnviron - push a stream of commands into the environment
 *
 *  The command-reader of Z (zloop) will retrieve commands either from the
 *  stack of macros or from the keyboard if the stack of macros is empty.
 *  fPushEnviron adds a new context to the stack.
 *
 *  p		character pointer to command set
 *  f		flag indicating type of macro
 *
 *  returns	TRUE iff environment was successfully pushed
 */
flagType
fPushEnviron (
    char *p,
    flagType f
    ) {
    if (cMacUse == MAXUSE) {
	printerror ("Macros nested too deep");
	return FALSE;
    }
    mi[cMacUse].beg = mi[cMacUse].text = p;
    mi[cMacUse++].flags = (flagType)(f | INIT);
    return TRUE;
}





/*  fExecute - push a new macro into the environment
 *
 *  pStr	pointer to macro string to push
 *
 *  returns	value of last executed macro.
 */
flagType
fExecute (
    char *pStr
    ) {

    pStr = whiteskip (pStr);

    if (fPushEnviron (pStr, EXEC)) {
        TopLoop ();
    }

    return fRetVal;
}





/*  zexecute pushes a new macro to the set being executed
 *
 *  arg 	pointer to text of macro
 */
flagType
zexecute (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    LINE i;
    linebuf ebuf;

    switch (pArg->argType) {

    /*  NOARG illegal   */

    case TEXTARG:
	strcpy ((char *) ebuf, pArg->arg.textarg.pText);
	fMeta = fExecute (ebuf);
	break;

    /*  NULLARG converted to TEXTARG    */

    case LINEARG:
	fMeta = FALSE;
        for (i = pArg->arg.linearg.yStart; i <= pArg->arg.linearg.yEnd; i++) {
	    if (GetLine (i, ebuf, pFileHead) != 0) {
		fMeta = fExecute (ebuf);
                if (!fMeta) {
                    break;
                }
            }
        }
        break;

    /*	STREAMARG illegal   */
    /*  BOXARG illegal      */

    }
    Display ();
    return fMeta;
    argData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\mark.c ===
/*	mark.c - do marking and repositioning
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"

PFILE       pFileMark   = NULL;    /* mark file handle                     */
flagType    fCacheDirty = 0;       /* TRUE => cache has ben changed        */
PFILE       pFileCache  = NULL;    /* Cached file                          */
FILEMARKS * pfmCache    = NULL;    /* Cached marks                         */

/* Flags for mark.flags  */

#define MF_DIRTY    1	    /* Mark has changed, but is not written	*/
#define MF_TEMP     2
#define MF_DUMMY    4	    /* This is dummry last mark 		*/



/*** mark - <mark> editor function
*
* Purpose:
*
*		       <mark> - Goes to top of file
*		  <arg><mark> - Toggle last/current window position
*	 <arg> textarg <mark> - Goes to named mark
*   <arg><arg> textarg <mark> - Defines mark at cursor
*   <arg><arg> textarg <mark> - Removes named mark
*
* Input:
*
* Output:
*
*   Returns FALSE if you try to go to a non-existent mark, TRUE
*   otherwise.
*
*************************************************************************/
flagType
mark (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    buffer mbuf;

    switch (pArg->argType) {

    case NOARG:
        docursor (0, (LINE)0);
        return TRUE;

    case TEXTARG:
	strcpy ((char *) mbuf, pArg->arg.textarg.pText);
        if (fIsNum (mbuf)) {
            docursor (0, atol (mbuf)-1);
            return TRUE;
        }
        if (pArg->arg.textarg.cArg == 2) {
            if (fMeta) {
                DeleteMark (mbuf);
            } else {
                DefineMark (mbuf, pFileHead, pArg->arg.textarg.y+1, pArg->arg.textarg.x+1, FALSE);
            }
            return TRUE;
        } else {
            return GoToMark (mbuf);
        }

    case NULLARG:
        restflip();
        return TRUE;

    /*  LINEARG illegal             */
    /*  STREAMARG illegal           */
    /*  BOXARG illegal              */

    }

    return FALSE;
    argData;
}





/*** GoToMark - Move cursor to a mark
*
* Purpose:
*
*   Goes to the named mark.
*
* Input:
*   pszMark -	Name of mark to go to.
*
* Output:
*
*   Returns TRUE if mark exists, FALSE, otherwise.
*
*************************************************************************/
flagType
GoToMark (
    char * pszMark
    ) {

    PFILE pFile;
    fl fl;

    if (pFile = FindMark (pszMark, &fl, TRUE)) {
        if (TESTFLAG(FLAGS(pFile), REAL) ||
            FileRead (pFile->pName, pFile, FALSE)) {
            pFileToTop (pFile);
            cursorfl (fl);
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        printerror ("'%s': Mark not found", pszMark);
        return FALSE;
    }
}





/*** FindMark - Get a mark's file location - used from outside
*
* Purpose:
*
*   Find a mark
*
* Input:
*   pszMark - Mark to search for.
*   fCheckAllFiles - TRUE  => Search through all files for mark
*		     FALSE => Look in only the current file
*
* Output:
*   * pfl - fl of mark.
*
*   Returns pFile of file the mark is in, NULL if mark is not found.
*
*************************************************************************/
PFILE
FindMark (
    char * pszMark,
    fl * pfl,
    flagType fCheckAllFiles
    ) {

    REGISTER PFILE pFile;
    MARK UNALIGNED*  pm;
    char    szMark[BUFLEN];
    char    szFile[BUFLEN];
    linebuf lbuf;
    LINE    y, l;
    COL     x;

    // If we are checking the current file only,
    // make sure it's cached and check it.
    //
    if (!fCheckAllFiles) {
        if (fCacheMarks (pFileHead) &&
            (pm = FindLocalMark (pszMark, FALSE))) {
            *pfl = pm->fl;
            //return pFile;
            return pFileHead;
        } else {
            return NULL;
        }
    }

    // Now, trundle through the pFile list
    // looking at the marks we have already
    // read from the markfile.
    //
    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if (TESTFLAG (FLAGS(pFile), VALMARKS) && fCacheMarks (pFile)) {
            if (pm = FindLocalMark (pszMark, FALSE)) {
                *pfl = pm->fl;
                return pFile;
            }
        }
    }

    // None of the files we have read so far
    // has the mark defined. We'll make one
    // pass through the markfile to see if
    // it's there.
    //
    if (pFileMark) {
        for (l = 0L; l < pFileMark->cLines; l++) {
            GetLine (l, lbuf, pFileMark);
            if (sscanf (lbuf, " %[^ ] %[^ ] %ld %d ", szMark, buf, &y, &x) >= 3)
            if (!_stricmp (szMark, pszMark)) {
                CanonFilename (buf, szFile);
                if (!(pFile = FileNameToHandle (szFile, NULL))) {
                    pFile = AddFile (szFile);
                }
                (void)fReadMarks (pFile);
                pfl->lin = y - 1;
                pfl->col = x - 1;
                return pFile;
            }
        }
    }
    return NULL;
}




/*** FindLocalMark - Find a mark in a FILEMARKS structure
*
* Purpose:
*
*   To find a mark in the cached marks.  If found, a pointer into
*   the cache is returned,
*
* Input:
*   pszMark	- Mark Name
*   fDirtyOnly	- TRUE => Return only changed marks.
*
* Output:
*
*   Returns pointer to mark.
*
*************************************************************************/
MARK *
FindLocalMark (
    char * pszMark,
    flagType fDirtyOnly
    ) {

    REGISTER MARK UNALIGNED * pm;

    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY) ; (char *)pm += pm->cb) {
        if (!_stricmp (pszMark, pm->szName)) {
            if (fDirtyOnly && !TESTFLAG(pm->flags, MF_DIRTY)) {
                return NULL;
            } else {
                return (MARK *)pm;
            }
        }
        assert (pm->cb);
    }
    return NULL;
}





/*** GetMarkFromLoc - Return the first mark past a given location
*
* Purpose:
*
*   To get a pointer to a mark given its file location.
*
* Input:
*   x, y - Mark location
*
* Output:
*
*   Returns Pointer to the mark.
*
*************************************************************************/
MARK *
GetMarkFromLoc (
    LINE y,
    COL  x
    ) {

    REGISTER MARK UNALIGNED * pm;

    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY) ; (char *)pm += pm->cb) {
        if (pm->fl.lin > y || ((pm->fl.lin == y) && (pm->fl.col >= x))) {
            break;
        }
    }
    return (MARK *) pm;
}




/*** SetMarkFile - Change markfile
*
* Purpose:
*
*   Changes to a new markfile.
*
* Input:
*   val - String after the 'markfile' switch
*
* Output:
*
*   Returns Error string if error, NULL otherwise
*
* Notes:
*
*   We:
*
* UNDONE:o Magically ensure that the current markfile is up to date and
*	  saved to disk.  This means, at the very least, that there
*	  can be no dirty files.
*
*	o Remove the current markfile from the file list.
*
*	o Read in the new markfile.
*
*	o Invalidate all current marks.  This is just marking them
*	  invalid in the PFILE.
*
*
*************************************************************************/
char *
SetMarkFile (
    char *val
    ) {

    REGISTER PFILE pFile;
    buffer  tmpval = {0};
    pathbuf pathname;

    strncat ((char *) tmpval, val, sizeof(tmpval)-1);

    if (NULL == CanonFilename (tmpval, pathname)) {
        sprintf (buf, "'%s': name is malformed", tmpval);
        return buf;
    }

    if (!(pFile = FileNameToHandle (pathname, NULL))) {
        pFile = AddFile (pathname);
    }

    if (!TESTFLAG(FLAGS(pFile), REAL) && !FileRead (pathname, pFile, FALSE)) {
        RemoveFile (pFile);
        sprintf (buf, "'%s' - %s", pathname, error());
        return buf;
    }

    pFileMark = pFile;

    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if (!TESTFLAG(FLAGS(pFile), FAKE)) {
            RSETFLAG (FLAGS(pFile), VALMARKS);
        }
    }
    return NULL;
}





/*** MarkInsLine - Adjust marks after an InsLine
*
* Purpose:
*
*   After InsLine inserts a bunch of blank lines, it calls this to update
*   any marks that would be "moved down".
*
* Input:
*   line - line number at which insertion took place
*   n	 - Number of new lines
*   pFile- File this occurred in
*
* Output: None
*
*************************************************************************/
void
MarkInsLine (
    LINE line,
    LINE n,
    PFILE pFile
    ) {

    MARK UNALIGNED * pm;

    if (!fCacheMarks (pFile)) {
        return;
    }

    if (pm = GetMarkFromLoc (line, 0)) {
        AdjustMarks ((MARK *)pm, n);
    }
}





/*** MarkDelStream - Adjust Marks after a DelStream
*
* Purpose:
*
*   After DelStream or DelLines removes a stream (DelLine removes a
*   "stream" with the beginning and ending points at the left and right
*   edges of the file), this takes care of updating any remaining
*   marks.
*
* Input:
*   pFile  - Affected file
*   xStart - 0-based starting point
*   yStart
*   xEnd   - 0-based ending point
*   yEnd
*
* Output: None
*
*************************************************************************/
void
MarkDelStream (
    PFILE pFile,
    COL  xStart,
    LINE yStart,
    COL  xEnd,
    LINE yEnd
    ) {

    REGISTER MARK UNALIGNED * pm;
    MARK UNALIGNED *      pmStart = NULL;
    MARK UNALIGNED *      pmEnd = NULL;
    fl          flStart;
    fl          flEnd;
    flagType    fAgain = FALSE;

    if (!fCacheMarks (pFile)) {
        return;
    }

    /* yEnd++;  WHY? */
    flStart.lin = yStart;
    flStart.col = xStart;
    flEnd.lin = yEnd;
    flEnd.col = xEnd;

    for (pm = pfmCache->marks; pmEnd == NULL ; (char *)pm += pm->cb) {
        // Look for first mark past beginning
        // of stream. Assume for the moment that
        // it is inside the stream
        //
        if (pmStart == NULL) {
            if (flcmp (&flStart, (fl *) &pm->fl) < 1) {
                pmStart = pm;
            } else {
                continue;
            }
        }

        // A first mark has been found. We start
        // looking for the first mark past the end
        // of the stream.  If these are the same,
        // there are no marks to remove.
        //
        if (flcmp (&flEnd, (fl *) &pm->fl) < 1) {
            // We know that we will end up here
            // because the last "mark" is higher
            // than any real mark
            //
            if ((pmEnd = pm) != pmStart)
                // We're here if there were
                // any marks inside the deleted
                // stream
                //
                memmove ((char *)pmStart,
                         (char *)pmEnd,
                        (unsigned int)(((char *)pfmCache + pfmCache->cb) - (char *)pmEnd ));

            if (pmStart->fl.lin == yEnd) {
                pmStart->fl.col -= xEnd;
            }
            AdjustMarks ((MARK *)pmStart, yStart - (yEnd + 1));
        }

        assert (pm->cb ||
                (TESTFLAG(pm->flags, MF_DUMMY) &&
                pm->fl.lin == 0x7FFFFFFF &&
                pm->fl.col == 0x7FFF));
    }
}






/*** MarkDelBox - Adjust Marks after a DelBox
*
* Purpose:
*
*   After deleting a box of text, we must remove any marks that are
*   defined inside it, then shift left any marks that are to the
*   right of it.
*
* Input:
*   pFile - Affected file
*   xLeft, yTop - Upper left hand corner of box
*   xRight, yBottom - Lower right hand corner of box
*
* Output: None
*
*************************************************************************/
void
MarkDelBox (
    PFILE pFile,
    COL  xLeft,
    LINE yTop,
    COL  xRight,
    LINE yBottom
    ) {

    MARK UNALIGNED *   pm;
    MARK UNALIGNED *   pmStart = NULL;
    MARK UNALIGNED *   pmEnd = NULL;
    fl       flUpLeft;
    fl       flLoRight;
    flagType fAgain;
    flagType fInBox = FALSE;	/* Marks are within box top/bottom */

    if (!fCacheMarks (pFile)) {
        return;
    }

    /* yBottom++;  WHY? */
    flUpLeft.lin = yTop;
    flUpLeft.col = xLeft;
    flLoRight.lin = yBottom;
    flLoRight.col = xRight;


    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY) ; !fAgain && ((char *)pm += pm->cb)) {
        /* First, look for lowest possible mark */
        fAgain = FALSE;
        if (!fInBox) {
            if (flcmp (&flUpLeft, (fl *) &pm->fl) < 1) {
                fAgain = TRUE;
                fInBox = TRUE;
            } else {
                ;
            }
        } else if (flcmp ((fl *) &pm->fl, &flLoRight) < 1) {
            /* Now we're in range.  Check
            ** for being inside the box.
            */
            if (pm->fl.col >= xLeft) {
                if (pm->fl.col <= xRight) {
                    DelPMark ((MARK *) pm);
                    fAgain = TRUE;
                } else {   /* Mark to the right of box */
                    pm->fl.col -= xRight - xLeft + 1;
                }
            } else {
                ;
            }
        } else {
            if (pm->fl.lin == yBottom) {
                pm->fl.col -= xRight - xLeft + 1;
            } else {
                break;      /* We've gone past the box */
            }
        }
    }
}





/*** fReadMarks - Read marks from the current markfile
*
* Purpose:
*
*   Gets the current marks for a given file.
*
* Input:
*   pFile - File to read marks for.
*
* Output:
*
*   Returns TRUE if pFile has marks and they are in VM, FALSE otherwise.
*
*************************************************************************/
flagType
fReadMarks (
    PFILE pFile
    ) {

    FILEMARKS UNALIGNED * pfm = NULL;
    LINE        l;
    char        szMark[BUFLEN];
    char        szFile[BUFLEN];
    linebuf     lbuf;
    LINE        yMark;
    COL         xMark;


    if (TESTFLAG (FLAGS(pFile), VALMARKS)) {
		return (flagType)(pFile->vaMarks != NULL);
    }

    // psuedo files cannot have marks
    // saved in the markfile.
    //
    if (pFileMark == NULL || TESTFLAG(FLAGS(pFile), FAKE)) {
        return FALSE;
    }

    for (l = 0L; l < pFileMark->cLines; l++) {
        GetLine (l, lbuf, pFileMark);
        if (sscanf (lbuf, " %[^ ] %[^ ] %ld %d ", szMark, szFile, &yMark, &xMark) >= 3) {
            if (!_stricmp (szFile, pFile->pName)) {
                UpdMark ((FILEMARKS **) &pfm, szMark, yMark, xMark, FALSE);
            }
        }
    }

    // Now pfm points to a good FILEMARKS structure.
    // First, throw away current marks.  Then, if we
    // actually found some marks for this file, we
    // put them in VM.
    //
    return fFMtoPfile (pFile, (FILEMARKS *)pfm);
}




/*** WriteMarks - Write Marks back out to the markfile.
*
* Purpose:
*
*   To update the markfile if any marks have changed
*
* Input:
*   pFile - owner of the marks
*
* Output: None.
*
*************************************************************************/
void
WriteMarks (
    PFILE pFile
    ) {

    REGISTER MARK UNALIGNED * pm;
    char            szMark[BUFLEN];
    char            szFile[BUFLEN];
    linebuf         lbuf;
    LINE            yMark, l;
    COL             xMark;

    if (pFileMark == NULL || TESTFLAG(FLAGS(pFile), FAKE)) {
        return;
    }

    if (!fCacheMarks (pFile)) {
        return;
    }

    // First, we read the whole file looking for marks for
    // this file.  When we find one, we look it up in the
    // cache to find the new value and write it back
    // out.  Unchanged marks are not re-written.
    //
    for (l = 0L; l < pFileMark->cLines; l++) {
        GetLine (l, lbuf, pFileMark);
        if (sscanf (lbuf, " %[^ ] %[^ ] %ld %d ", szMark, szFile, &yMark, &xMark) >= 3) {
            if (!_stricmp (szFile, pFile->pName)) {
                if (pm = FindLocalMark (szMark, TRUE)) {
                    sprintf (lbuf, "%s %s %ld %d", szMark, szFile, pm->fl.lin+1, pm->fl.col+1);
                    PutLine (l, lbuf, pFileMark);
                    RSETFLAG (pm->flags, MF_DIRTY);
                }
            }
        }
    }

    // Now we read through the cache to find any new marks.  These
    // will be appended to the markfile.
    //
    for (   pm = pfmCache->marks;
            !TESTFLAG(pm->flags, MF_DUMMY);
            (char *)pm += pm->cb) {

        if (TESTFLAG (pm->flags, MF_DIRTY)) {
            sprintf (lbuf, "%s %s %ld %d", pm->szName,
                                          pFile->pName,
                                          pm->fl.lin + 1,
                                          pm->fl.col + 1);
            AppFile (lbuf, pFileMark);
        }
    }
}





/*** UpdMark - Add a mark to a FILEMARKS
*
* Purpose:
*
*   This creates the FILEMARKS structure, adds marks to it and
*   updates existing marks in it.  The caller does not need to
*   know which of these is going to happen.
*
* Input:
*   ppfm    - Pointer to a pointer to FILEMARKS.
*   pszMark - Mark name.
*   yMark   - Mark location (1-based)
*   xMark
*   fTemp   - TRUE => This marks should not be written to the markfile
*
* Output: None.  *ppfm may be changed
*
* Notes:
*
*   The first argument is a ** because the * will be updated when a
*   re-LMAlloc is required.
*
*************************************************************************/
void
UpdMark (
    FILEMARKS ** ppfm,
    char       * pszMark,
    LINE         yMark,
    COL          xMark,
    flagType     flags
    ) {

    FILEMARKS UNALIGNED * pfm;
    FILEMARKS UNALIGNED * pfmOld;         /* pfm prior to realloc     */
    REGISTER MARK UNALIGNED * pm;
    int      cbNewMark;
    fl       flMark;
    flagType fExist = FALSE;

    assert (ppfm);

    /* Convert to 0-based */
    flMark.lin = yMark-1;
    flMark.col = xMark-1;
    cbNewMark  = sizeof(MARK) + strlen(pszMark);

    // If we already have a FILEMARKS structure,
    // we look for the slot in pfm->marks
    // where the new mark will go.
    //
    if (pfm = *ppfm) {
        for (pm = pfm->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
            if (!_stricmp (pszMark, pm->szName)) {
                fExist = TRUE;
                break;
            }

            // Check for current mark coming later than
            // new mark
            //
            if (flcmp ((fl *) &pm->fl, &flMark) > 0) {
                break;
            }
        }
    } else {
        // New structure.  Allocate mem and create
        // a dummy mark.
        //
        pfm = (FILEMARKS *)ZEROMALLOC (sizeof(FILEMARKS));
        pfm->cb = sizeof(FILEMARKS);
        pm = pfm->marks;
        pm->cb = sizeof(MARK);
        pm->fl.lin = 0x7FFFFFFF;
        pm->fl.col = 0x7FFF;
        pm->szName[0] = '\0';
        pm->flags = MF_DUMMY;
    }

    // At this point, pfm points to the current FILEMARKS
    // structure, and pm points into that structure at
    // the place where the new mark will go, or the existing
    // mark be updated.
    //
    if (!fExist) {

        pfmOld = pfm;

        // First, get enough extra space for a new mark, adjusting pm
        // if a new alloc was required
        //
		pfm = (FILEMARKS *)ZEROREALLOC((PVOID)pfm, pfm->cb + cbNewMark);
        if (pfmOld != pfm) {
            pm = (MARK *)((char *)pfm + ((char *)pm - (char *)pfmOld));
        }

        // Now pm points to the location in pfm where
        // our new mark should go.  We will move the
        // original filemarks up to leave space for the
        // new one.
        //
        memmove ((char *)((char *)pm + cbNewMark),
                (char *)pm,
                (unsigned int)(pfm->cb - ((char *)pm - (char *)pfm)));

        strcpy (pm->szName, pszMark);
        pm->flags = 0;
        pm->cb = cbNewMark;

        pfm->cb += cbNewMark;
    }

    if (pfm == pfmCache) {
        fCacheDirty = TRUE;
    }
    pm->flags = flags;
    pm->fl = flMark;

    *ppfm = (FILEMARKS *)pfm;
}




/*** DefineMark - Add new mark / update existing mark
*
* Purpose:
*
*   This is called from the outside to create/update marks.
*
* Input:
*   pszMark - Mark's name
*   pFile   - File the mark will be in
*   y, x    - File location of the mark (1-based)
*   fTemp   - True -> the mark is temporary
*
* Output: None.
*
*************************************************************************/
void
DefineMark (
    char * pszMark,
    PFILE pFile,
    LINE y,
    COL  x,
    flagType fTemp
    ) {

    flagType fFirstMark = (flagType)!fCacheMarks (pFile);

    if (fFirstMark) {
        FreeCache ();
    }

    UpdMark (&pfmCache, pszMark, y, x, (flagType)(MF_DIRTY | (fTemp ? MF_TEMP : 0)));

    if (fFirstMark) {
	pFileCache = pFile;
	(void)fFMtoPfile (pFile, pfmCache);
    }
}





/*** DeleteMark - Remove a mark
*
* Purpose:
*
*   Un-define a mark.
*
* Input:
*   pszMark - Mark to remove
*
* Output: None
*
* Notes:
*
*   A message is displayed reporting on success or failure.
*
*************************************************************************/
void
DeleteMark (
    char * pszMark
    ) {

    REGISTER PFILE pFile;
    MARK UNALIGNED * pm;

    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if (TESTFLAG (FLAGS(pFile), VALMARKS) && fCacheMarks (pFile)) {
            if (pm = FindLocalMark (pszMark, FALSE)) {
                DelPMark ((MARK *)pm);
                domessage ("%s: mark deleted", pszMark);
                return;
            }
        }
    }
    printerror ("%s: Mark not found", pszMark);
}




/*** DelPMark - Remove a mark when a pointer to the MARK is known
*
* Purpose:
*
*   Physically remove a mark from a FILEMARKS structure
*
* Input:
*   pm - Pointer (into pfmCache) of mark to remove
*
* Output: None
*
*************************************************************************/
void
DelPMark (
    MARK * pm
    ) {

    MARK UNALIGNED * p;
    int cb;

    p   = pm;
    cb  = p->cb;

	memmove ((char *)pm,
		 (char *)((char *)pm + cb),
		(unsigned int)(((char *)pfmCache + pfmCache->cb) - ((char *)pm + cb)));

	pfmCache->cb -= cb;
}





/*** MarkCopyLine - Copy marks after a CopyLine call
*
* Purpose:
*
*   When CopyLine moves stuff from or to the clipboard, this moves marks
*   with it.
*
* Input:
*   pFileSrc - File moved from
*   pFileDst - File moved to
*   yStart   - First line from pFileSrc
*   yEnd     - Last number from pFileDst
*   yDst     - Target line in pFileDst
*
* Output: None
*
* Notes:
*
*   Marks are copied only from and to the clipboard.
*
*
*************************************************************************/
void
MarkCopyLine (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    LINE    yStart,
    LINE    yEnd,
    LINE    yDst
    ) {

    FILEMARKS * pfm;

    if (pFileSrc != pFilePick && pFileDst != pFilePick) {
        return;
    }

    if (NULL == (pfm = GetFMFromFile (pFileSrc, 0, yStart, sizeof(linebuf)-1, yEnd))) {
        return;
    }

    AddFMToFile (pFileDst, pfm, 0, yDst);

	if ( pfm ) {
		FREE (pfm);
	}
}




/*** MarkCopyBox - Copy marks after a CopyBox call
*
* Purpose:
*
*   When CopyBox moves stuff from or to the clipboard, this moves marks
*   with it.
*
* Input:
*   pFileSrc	    - File moved from
*   pFileDst	    - File moved to
*   xLeft, yTop     - Upper left corner of source box
*   xRight, yBottom - Lower right corner of source box
*   xDst, yDst	    - Upper left corner of target
*
* Output: None
*
* Notes:
*
*   Marks are copied only from and to the clipboard.
*
*************************************************************************/
void
MarkCopyBox (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    COL     xLeft,
    LINE    yTop,
    COL     xRight,
    LINE    yBottom,
    COL     xDst,
    LINE    yDst
    )
{

    FILEMARKS UNALIGNED * pfm;

    /* User is inserting blank region. */
    if (pFileSrc == NULL) {
        pFileSrc = pFileDst;
        xDst = xRight + 1;
        xRight = sizeof(linebuf);
    } else if (pFileSrc != pFileDst &&
        pFileSrc != pFilePick &&
        pFileDst != pFilePick) {
        return;
    }

    if (NULL == (pfm = GetFMFromFile (pFileSrc, xLeft, yTop, xRight, yBottom))) {
        return;
    }

    AddFMToFile (pFileDst, (FILEMARKS *)pfm, xDst, yDst);

	if ( pfm ) {
		FREE (pfm);
	}
}





/*** GetFMFromFile - Generate a FILEMARKS for marks in a file region
*
* Purpose:
*
*   Generates a subset of a FILEMARKS structure whose marks fall
*   within a certain range.  Needed by MarkCopy*.
*
* Input:
*   pFile	    - File to get marks from
*   xLeft, yTop     - Start of range
*   xRight, yBottom - End of range
*
* Output:
*
*   Returns Pointer to new structure, NULL if there are no marks in range
*
*************************************************************************/
FILEMARKS *
GetFMFromFile (
    PFILE   pFile,
    COL     xLeft,
    LINE    yTop,
    COL     xRight,
    LINE    yBottom
    )
{

    FILEMARKS UNALIGNED * pfm = NULL;
    REGISTER MARK UNALIGNED * pm;
    fl       flStart;
    fl       flEnd;
    flagType fInRange = FALSE;

    if (!fCacheMarks (pFile)) {
        return NULL;
    }

    flStart.lin = yTop;
    flStart.col = xLeft;
    flEnd.lin = yBottom;
    flEnd.col = xRight;

    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
        if ((fInRange || flcmp (&flStart, (fl *) &pm->fl) < 1) &&
            (flcmp ((fl *) &pm->fl, &flEnd) < 1)) {
            fInRange = TRUE;
            if ((pm->fl.col >= xLeft && pm->fl.col <= xRight)) {
                UpdMark (   (FILEMARKS **) &pfm,
                            pm->szName,
                            pm->fl.lin - yTop + 1,
                            pm->fl.col - xLeft + 1,
                            (flagType)pm->flags);
            }
        } else {
            break;  /* We're out of range again*/
        }
    }
    return (FILEMARKS *) pfm;
}




/*** AddFMToFile - Add a bunch of marks to a file
*
* Purpose:
*
*   Insert the marks from one FILEMARKS structure into another.  The
*   target structure is in pfmCache.
*
* Input:
*   pFile - Target file
*   pfm   - Source marks
*   cZero - # of columns to adjust source marks to fit into target file
*   zZero - # of lines to adjust source marks to fit into target file
*
* Output: None
*
*************************************************************************/
void
AddFMToFile (
    PFILE       pFile,
    FILEMARKS * pfm,
    COL         cZero,
    LINE        lZero
    )
{

    REGISTER MARK UNALIGNED * pm;

    if (lZero || cZero) {
        for (pm = pfm->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
            pm->fl.lin += lZero;
            pm->fl.col += cZero;
        }
    }

    if (!fCacheMarks (pFile)) {
        (void)fFMtoPfile (pFile, pfm);
        return;
    }

    for (pm = pfm->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
        UpdMark (&pfmCache, pm->szName, pm->fl.lin+1, pm->fl.col+1, (flagType)pm->flags);
    }
}





/*** FreeCache - Write a cache to VM
*
* Purpose:
*
*   To save the marks for a file into VM.
*
* Input: None
*
* Output: None
*
*************************************************************************/
void
FreeCache (
    void
    ) {

    if (pFileCache) {

        assert (pfmCache);

        if (fCacheDirty) {
			if (pFileCache->vaMarks != NULL) {
				FREE(pFileCache->vaMarks);
				pFileCache->vaMarks = NULL;
            }

            // PREFIX!  This MALLOC is not checked for failure
            memmove(pFileCache->vaMarks = MALLOC ((long)pfmCache->cb),
                    (char *)pfmCache,
                    pfmCache->cb);
        }

        FREE (pfmCache);
		pFileCache	= NULL;
		pfmCache	= NULL;
        fCacheDirty = FALSE;
    }
}






/*** fCacheMarks - Copy marks to a cache.  Save caches contents if nec.
*
* Purpose:
*
*   Before most mark operations can take place, the cache must contain
*   the marks for the given file.
*
* Input:
*   pFile - File to cache marks for.
*
* Output:
*
*   Returns FALSE if the file has no marks, TRUE otherwise.
*
* Notes:
*
*   On return the cache is usable whether or not the given file had marks.
*
*************************************************************************/
flagType
fCacheMarks (
    PFILE pFile
    ) {

	unsigned cbCache;
    FILEMARKS UNALIGNED *Marks;

    assert (pFile);

    // First we make sure that the VM version of
    // marks is updated for this file.  fReadMarks
    // return TRUE iff the file has marks and they
    // are in VM.
    //
    if (fReadMarks (pFile)) {

        // The marks are ready to be cached.  First,
        // let's see if they are already chached.
        //
        if (pFileCache == pFile) {
            return TRUE;
        }

        // They're not. If the cache is currently
        // being used, we save it and clear it.
        //
        FreeCache ();

        // Finally, alloc a new cache, plop
        // the marks into it and mark the
        // cache in use.
		//
		Marks = (FILEMARKS *)(pFile->vaMarks);
                // PREFIX! This MALLOC is not checked for failure
		pfmCache = (FILEMARKS *)ZEROMALLOC (cbCache = (unsigned)(Marks->cb) );

        memmove((char *)pfmCache, pFile->vaMarks, cbCache);

        pFileCache  = pFile;
        fCacheDirty = FALSE;

        return TRUE;
    } else { /* No marks, return FALSE */
        return FALSE;
    }
}






/*** AdjustMarks - Change later marks when one has changed
*
* Purpose:
*
*   To update marks in a FILEMARKS structure after some lines have been
*   added or removed.
*
* Input:
*   pm	   - pointer to first mark that has changed.
*   yDelta - Number of lines to change by.  May be negative
*
* Output: None
*
*************************************************************************/
void
AdjustMarks (
    REGISTER MARK * pm,
    LINE yDelta
    ) {

    REGISTER MARK UNALIGNED * pm1;

    assert (pm);

    pm1 = pm;
    for (;!TESTFLAG(pm1->flags, MF_DUMMY); (char *)pm1 += pm1->cb) {
        pm1->fl.lin += yDelta;
        SETFLAG (pm1->flags, MF_DIRTY);
    }
    fCacheDirty = TRUE;
}






/*** fFMtoPfile - Attach a FILEMARKS structure to a pFile.
*
* Purpose:
*
*   To attach some marks to a file.
*
* Input:
*   pFile   - File to get the marks
*   pfm     - The marks
*
* Output:
*
*   Returns TRUE if there were any marks, FALSE if not.
*
*************************************************************************/
flagType
fFMtoPfile (
    PFILE       pFile,
    FILEMARKS * pfm
    ) {

    SETFLAG (FLAGS(pFile), VALMARKS);

	if (pFile->vaMarks != NULL) {
		FREE(pFile->vaMarks);
		pFile->vaMarks = NULL;
    }
	return (flagType)((pFile->vaMarks = FMtoVM (pfm)) != NULL);
}





/*** fFMtoPfile - Copy a FILEMARKS structure into VM, return address
*
* Purpose:
*
*   To convert a local FILEMARKS structure into a VM copy.  Allocates
*   the VM and frees the local memory.
*
* Input:
*   pfm -   Pointer to FILEMARKS.  May be NULL.
*
* Output:
*
*
*************************************************************************/
PVOID
FMtoVM (
    FILEMARKS * pfm
    ) {

	PVOID l = NULL;

	if (pfm) {

        l = MALLOC ((long)(pfm->cb));
        if (l)
    		memmove(l, (char *)pfm, pfm->cb);

		//
		//	I do not free pfm here because this should be done by the
		//	caller.
		//
		// if (pfm != pfmCache) {
		//	  FREE (pfm);
		// }

	}

    return l;
}




/*** GetMarkRange - Get a VM copy of a range of marks
*
* Purpose:
*
*   Used by <undo> to get the marks attached to a piece of a file.
*
* Input:
*   pFile - File to check
*   xLeft, yTop - Upper left corner of range
*   xRight, yBottom - Lower right corner of range
*
* Output:
*
*	Returns VM address of structure
*
*************************************************************************/
PVOID
GetMarkRange (
    PFILE pFile,
    LINE  yStart,
    LINE  yEnd
    ) {
    return FMtoVM (GetFMFromFile (pFile, 0, yStart, sizeof(linebuf), yEnd));
}




/*** PutMarks - Put marks back into a file.
*
* Purpose:
*
*   Used by <undo> to restore marks to a file.
*
* Input:
*   pfm -   Pointer to FILEMARKS.  May be NULL.
*
* Output:
*
*
*************************************************************************/
void
PutMarks (
    PFILE pFile,
    PVOID vaMarks,
    LINE  y
    ) {

    FILEMARKS UNALIGNED * pfm;
	FILEMARKS * Marks;
    unsigned cb;

	if ( vaMarks ) {

		Marks = ((FILEMARKS *)vaMarks);

		pfm = (FILEMARKS *)ZEROMALLOC (cb = (unsigned)Marks->cb);
		memmove((char *)pfm, vaMarks, cb);

		AddFMToFile (pFile, (FILEMARKS *) pfm, 0, y);
	}
}





/*** flcmp - Returns relative position of two FL's
*
* Purpose:
*
*   Useful for comparing the positions of two marks.
*
* Input:
*   pfl1    - "Left side" mark
*   pfl2    - "Right side" mark
*
* Output:
*
*   Returns:
*
*	< 0	*pfl1 < *pfl2
*	= 0	*pfl1 = *pfl2
*	> 0	*pfl1 > *pfl2
*
*
*************************************************************************/
int
flcmp (
    REGISTER fl * pfl1,
    REGISTER fl * pfl2
    ) {

    REGISTER fl UNALIGNED * fl1 = pfl1;
    REGISTER fl UNALIGNED * fl2 = pfl2;

    if (fl1->lin < fl2->lin) {
        return -1;
    } else if (fl1->lin == fl2->lin) {
        return fl1->col - fl2->col;
    } else {
        return 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\newline.c ===
/*  newline.c - move to the next line
 *
 *  Modifications:
 *	26-Nov-1991 mz	Strip off near/far
 */

#include "mep.h"



/* move to a new line unless in insert mode, then we split the current line
 */
flagType
emacsnewl (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    int tmpx;

    if (fInsert && !argcount) {
	tmpx = softcr ();
	CopyStream (NULL, pFileHead, XCUR (pInsCur), YCUR (pInsCur),
				     tmpx,	     YCUR (pInsCur)+1,
                     XCUR (pInsCur), YCUR (pInsCur));

    redraw( pFileHead, YCUR(pInsCur)-1, YCUR(pInsCur)+1 );

	docursor (tmpx, YCUR (pInsCur)+1);
	return TRUE;
    } else {
        return newline (argData, pArg, fMeta);
    }
}




flagType
newline (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    docursor (fMeta ? 0 : softcr (), YCUR(pInsCur)+1);
    return TRUE;

    argData; pArg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\mouse.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mouse.c

Abstract:

    Mouse support for MEP

Author:

    Ramon Juan San Andres (ramonsa) 07-Nov-1991


Revision History:


--*/

#include <string.h>
#include "mep.h"
#include "cmds.h"
#include "mouse.h"



void
DoMouseInWindow(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    );

flagType
SetCurrentWindow(
    int iWin
    );

void
DoMouse(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Handles Mouse events. Invoked by the MEP console interface

Arguments:

    Row         -   Supplies row position of the mouse
    Col         -   Supplies column position of the mouse
    MouseFlags  -   Supplies miscelaneous flags

Return Value:

    none

--*/


{
            int     i;
            KBDKEY  Key;
    static  BOOL    Clicked  = FALSE;
    static  BOOL    Dragging = FALSE;
    static  BOOL    InMouse  = FALSE;
    static  ROW     LastRow;
    static  COLUMN  LastCol;
    struct  windowType *winTmp;

    if ( fUseMouse ) {
        if ( !InMouse ) {
            InMouse = TRUE;
            if ( MouseFlags & MOUSE_CLICK_LEFT ) {
                //
                //  If dragging, start selection
                //
                if ( !fInSelection && Clicked && !Dragging && ( (LastRow != Row) || (LastCol != Col) ) ) {


    //#ifdef DEBUG
    //              char dbgb[256];
    //              sprintf( dbgb, "  MOUSE: Selecting at Row %d, Col %d\n", Row, Col );
    //              OutputDebugString( dbgb );
    //#endif
                    //
                    //  Start selection
                    //
                    Key.Unicode     = 'A';
                    Key.Scancode    = 'A';
                    Key.Flags       = CONS_RIGHT_ALT_PRESSED;

                    consolePutMouse( Row, Col, MouseFlags );
                    consolePutKey( &Key );
                    consolePutMouse( LastRow, LastCol, MouseFlags );

                    Dragging = TRUE;
                    InMouse  = FALSE;

                    return;

                } else {

                    Clicked  = TRUE;
                    LastRow  = Row;
                    LastCol  = Col;
                }

            } else {

                Clicked  = FALSE;
                Dragging = FALSE;
            }

            if ( cWin == 1 ) {

                DoMouseInWindow( Row, Col, MouseFlags );

            } else {

                //
                //  Determine what window we're in
                //
                for ( i=0; i<cWin; i++ ) {

                    winTmp = &(WinList[i]);

                    if ( ( (LINE)(Row-1) >= WINYPOS( winTmp ) )                         &&
                         ( (LINE)(Row-1) <= WINYPOS( winTmp ) + WINYSIZE( winTmp ) )    &&
                         ( (COL)(Col-1)  >= WINXPOS( winTmp ) )                         &&
                         ( (COL)(Col-1)  <  WINXPOS( winTmp ) + WINXSIZE( winTmp ) ) ) {

                        //
                        //  Found the window that we're in. Make that window
                        //  the current (i.e. "active" window ).
                        //
                        iCurWin = i;

                        if ( (winTmp == pWinCur) || SetCurrentWindow (iCurWin) ) {

                            DoMouseInWindow( Row - WINYPOS( winTmp ),
                                             Col - WINXPOS( winTmp ),
                                             MouseFlags );
                        }

                        break;
                    }
                }
            }

            InMouse = FALSE;
        }
    }
}


flagType
SetCurrentWindow(
    int iWin
    )
{
    flagType f;

    WaitForSingleObject(semIdle, INFINITE);

    f = SetWinCur( iWin );

    SetEvent( semIdle );

    return f;
}


void
DoMouseInWindow(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Handles Mouse events. Called by DoMouse after setting the active
    window.

Arguments:

    Row         -   Supplies row position of the mouse
    Col         -   Supplies column position of the mouse
    MouseFlags  -   Supplies miscelaneous flags

Return Value:

    none

--*/

{

    KBDKEY          Key;
    static BOOL     fFirstClick = FALSE;

    WaitForSingleObject(semIdle, INFINITE);

    //
    //  If the mouse is clicked, move the cursor to the mouse position.
    //
    if ( MouseFlags & MOUSE_CLICK_LEFT ) {

        //
        //  Toggle boxmode if necessary
        //
        if ( fInSelection && (MouseFlags & MOUSE_CLICK_RIGHT) ) {
            SendCmd( CMD_boxstream );
        }

        if ( (LINE)(Row-1) == WINYPOS( pWinCur ) + WINYSIZE( pWinCur ) ) {

            //
            //    scroll the window
            //
            Key.Unicode     = '\0';
            Key.Scancode    = VK_DOWN;
            Key.Flags       = 0;

            consolePutMouse( Row + WINYPOS( pWinCur )-1,
                             Col + WINXPOS( pWinCur ),
                             MouseFlags );
            consolePutKey( &Key );

        } else  if ( (LINE)(Row-1) <  WINYPOS( pWinCur ) + WINYSIZE( pWinCur ) ) {

            //
            //  Move the cursor to the new location
            //
            docursor( XWIN(pInsCur) + Col - 1, YWIN(pInsCur) + Row - 1  );

            //
            //  If we are making a selection, hilite it
            //
            if ( fInSelection ) {
                UpdateHighLight ( XCUR(pInsCur), YCUR(pInsCur), TRUE);
            }
        }

    } else if ( MouseFlags & MOUSE_CLICK_RIGHT ) {

        if ( !fInSelection ) {

            if ( !fFirstClick ) {

                fFirstClick = TRUE;

                if ( (LINE)(Row-1) <  WINYPOS( pWinCur ) + WINYSIZE( pWinCur ) ) {

                    //
                    //  Position the cursor and press the F1 key
                    //
                    docursor( XWIN(pInsCur) + Col - 1, YWIN(pInsCur) + Row - 1  );

                    Key.Unicode     = 0;
                    Key.Scancode    = VK_F1;
                    Key.Flags       = 0;
                    consolePutKey( &Key );
                }
            }
        }

    } else {

        fFirstClick = FALSE;
    }

    SetEvent( semIdle );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\mepstr.c ===
/************************************************************************
 *
 *              Microsoft Editor Messages and strings
 *
 *
 *  This file contains all the messages and strings used in MEP.
 *
 *
 * Revision History:
 *
 *          9/28/90     ramonsa     Adapted from original msg.txt file
 *
 ************************************************************************/



/************************************************************************
 *
 *  String constants
 *
 *  Strings that are used only in a few places and that are used only by
 *  MEP are declared here.
 *
 ************************************************************************/







/************************************************************************
 *
 *  Messages
 *
 *  Strings that might be shared are declared here for now. When the new
 *  message retriever is ready this might change.
 *
 *  String constants are also declared here (for eliminating duplications)
 *  if:
 *
 *  -   They are long
 *  -   They are used in different places but are not used extremely often
 *      (if they are used too often then they might be defined up here
 *      as constants to reduce the overhead at the expense of wasting
 *      memory.
 *
 *
 *  NOTE:
 *
 *      Messages must have a number assigned in msg.h
 *
 ************************************************************************/

#include "mep.h"


MSG_TXT MsgStr[] = {

//
//       8000 series: error messages
//                                                                  // 8001
    MSGERR_INV_ARG,     "Invalid Argument",                         // 8002
    MSGERR_ARG_REQ,     "Argument Required",                        // 8003
    MSGERR_NOEDIT,      "No-Edit file may not be modified",         // 8004
    MSGERR_NOREP,       "No command to repeat",                     // 8005
    MSGERR_NOCREAT,     "Cannot create %s - %s",                    // 8006
    MSGERR_OPEN,        "Cannot open %s - %s",                      // 8007
    MSGERR_RONLY,       "%s is read-only",                          // 8008
    MSGERR_SPACE,       "Out of space on %s",                       // 8009
    MSGERR_DEL,         "Can't delete %s - %s",                     // 8010
    MSGERR_REN,         "Can't rename %s to %s - %s",               // 8011
    MSGERR_OLDVER,      "Can't delete old version of %s",           // 8012
    MSGERR_SAVEDIR,     "Cannot save to directory: %s",             // 8013
    MSGERR_STFILE,      "Unsupported status file version",          // 8014
    MSGERR_UNDO,        "Nothing to UnDo",                          // 8015
    MSGERR_REDO,        "Nothing to ReDo",                          // 8016
    MSGERR_ITHREAD,     "Unable to start Idle thread",              // 8017
    MSGERR_CTHREAD,     "Unable to start compile thread",           // 8018
    MSGERR_PTHREAD,     "Unable to start printing thread",          // 8019
    MSGERR_TOOLS,       "Unable to read TOOLS.INI[%s]",             // 8020
    MSGERR_ZFORMAT,     "Unrecognized %% command in '%s'",          // 8021
    MSGERR_ZTELL,       "%s is not an editor function or macro",    // 8022
    MSGERR_CMPCMD,      "No compile command known",                 // 8023
    MSGERR_CMPCMD2,     "No compile command known for %s",          // 8024
    MSGERR_CMPFULL,     "Compile list full, try later",             // 8025
    MSGERR_CMPCANT,     "Cannot compile",                           // 8026
    MSGERR_CMPSRC,      "Source file not found: %s",                // 8027
    MSGERR_PRTFULL,     "Print list full, try later",               // 8025
    MSGERR_PRTCANT,     "Cannot print",
    MSGERR_NOMEM,       "Not enough memory",
    MSGERR_QUIT,        "Cannot recover from previous error, will quit",
//
//       9000 series: <assign> file text
//
    MSG_ASSIGN_HDR,     "; Assigning Editor Functions and Macros to Keystrokes", // 9001
            9002,       ";",
            9003,       ";   o To assign a function to a new key, find a line of the form",
            9004,       ";     \"func:keyname\" and replace \"keyname\" with the name of the new key.",
            9005,       ";",
            9006,       ";   o To remove a function from a given key, find the line that reads",
            9007,       ";     \"unassigned:\"  and append the key name.",
            9008,       ";",
            9009,       ";   o The assignment you make will not take effect until you move the",
            9010,       ";     cursor to a different line.  When you do, the line will be highlighted.",
            9011,       ";",
            9012,       ";   o To make the assignment permanent, save this file.",
            9013,       ";",
            9014,       ";   o A list of unused keys is shown after the assignment list.",
            9015,       ";",
            9016,       ";   o To return to editing, use the File menu to switch back to your",
            9017,       ";     file.",
            9018,       "?",

    MSG_SWITCH_HDR,     "; Setting Editor Switch Values", // 9025
            9026,       ";",
            9027,       ";   o To change the value of a switch, find the line that shows the",
            9028,       ";     current value and enter a new value.",
            9029,       ";",
            9030,       ";   o The change you make will not take effect until you move the cursor",
            9031,       ";     to a different line.",
            9032,       "?",


    MSG_KEYS_HDR1,      ";                                Available Keys", // 9050
            9051,       ";",
            9052,       ";------------------------------------------------------------------------------",
            9053,       "?",
    MSG_KEYS_HDR2,      ";    PLAIN      |     SHIFT     |     CTRL      |      ALT      |  SHIFT+CTRL", // 9054
            9055,       ";------------------------------------------------------------------------------",
            9056,       "?",

    MSG_ASG_FUNC,       ";   Instrinsic Editor Functions", // 9061
    MSG_ASG_MACROS,     ";   Macros",                      // 9062
    MSG_ASG_NUMER,      ";   Numeric Switches",            // 9063
    MSG_ASG_BOOL,       ";   Boolean Switches",            // 9064
    MSG_ASG_TEXT,       ";   Text Switches",               // 9065
    MSG_ASG_CLIP,       "The clipboard is empty",          // 9066
    MSG_ASG_LINES,      "%ld line%s in %s clipboard",      // 9067
    MSG_ASG_PAGES,      "%d virtual pages",                // 9068
//
//       10000 series: misc utility text
//
    MSG_PRESS_ANY,      "Press any key...",                          // 10000
    MSG_ARGCOUNT,       "Arg [%d]",                                  // 10001
    MSG_NEXTFILE,       "Next file is %s...",                        // 10002
    MSG_SAVING,         "Saving %s...",                              // 10003
    MSG_TELLPROMPT,     "Press key to tell about:",                  // 10004
    MSG_SAVEALL,        "Save all remaining changed files (Y/N)?",   // 10005
    MSG_SAVEONE,        "%s has changed!  Save changes (Y/N)?",      // 10006
    MSG_QUEUED,         "Queued: %s",                                // 10007
    MSG_CMPDONE,        "Compilation complete",                      // 10008
    MSG_PRINTING,       "Printing %s... Press Esc to abort",         // 10009
    MSG_SCANFILE,       "Scanning %s...",                            // 10010
//
//       10100: assign errors
//
    MSG_ASN_MISS,       "missing ':' in %s",                                        // 10100
    MSG_ASN_MISSK,      "Missing key assignment for '%s'",                          // 10101
    MSG_ASN_UNKKEY,     "'%s' is an unknown key",                                   // 10102
    MSG_ASN_INUSE,      "macro %s is in use",                                       // 10103
    MSG_ASN_MROOM,      "Not enough room for macro %s",                             // 10104
    MSG_ASN_NOTSWI,     "%s is not an editor switch",                               // 10105
    MSG_ASN_ILLSET,     "Illegal setting",                                          // 10106
    MSG_ASN_WINCHG,     "Cannot change screen parameters when windows present",     // 10107
    MSG_ASN_UNSUP,      "Not supported by video display",                           // 10108
    MSG_ASN_INVAL,      "%Fs: Invalid value '%s'",                                  // 10109
//
//  End of array
//
    0, ""
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\mep.c ===
/*** mep.c - top level for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/
#define INCL_DOS

#include "mep.h"
#include "version.h"


#define DEBFLAG Z

/*
 * use double macro level to force rup to be turned into string representation
 */
#define VER(x,y,z)  VER2(x,y,z)
#define VER2(x,y,z)  "Version "###x##"."###y"."###z" "szVerName

char Name[]      = "Microsoft (R) Editor";
char Version[]   = VER(rmj,rmm,rup);
char CopyRight[] = "Copyright (C) Microsoft Corp 1987-1990.  All rights reserved";


/*** main - program entry
*
* Input:
*  C standard command line parameters.  Recognizes:
*
*       /e string   - Execute string of commands on startup
*       /t          - Following file is "temporary", not kept in file history
*       /D          - Don't read tools.ini
*       /r          - Global no-edit mode (can't edit files)
*       /m markname - Start up at given mark
*       /pwb        - Start as PWB
*
*  When the editor is built with DEBUG defined, the following are also
*  recognized:
*
*       /d debflags - Specifies which debugging to turn on
*       /f filename - Specifies file for debug output
*
*  The following are present in the CW version of the editor only.  They are
*  for testing only and should NOT be documented:
*
*       /vt tapename- Set tape name
*       /vr         - Record messages to file "default.key"
*       /vp         - Play back messages from file "default.key"
*       /vd digit   - Set playback delay from 0 to 9
*
*
* Output:
*  Returns nothing. Exits via CleanExit()
*
* Exceptions:
*  Various and sundry, based on program operation
*
*************************************************************************/
void __cdecl
main (
    int c,
    char **v
    ) {

        char            *pExecute               = NULL;                 /* string to execute on start   */
        char            *szMark                 = NULL;                 /* mark to go to on start               */
        char            *szName                 = v[0];                 /* ptr to invokation name               */
        flagType        InLoop                  = TRUE;

        ConvertAppToOem( c, v );
        SHIFT(c,v);
#if DEBUG
    debug =  0;
    //debfh = stdout;
#endif

        while (c && fSwitChr (**v) && InLoop) {


        switch ((*v)[1]) {
#if DEBUG
        case 'f':
        case 'F':
            SHIFT(c,v);
            if ((debfh = MepFOpen(*v, ACCESSMODE_WRITE, SHAREMODE_RW, TRUE)) == NULL) {
                printf("Can't open %s for debug output - using stdout\n", *v);
                //debfh = stdout;
            }
            // setbuf(debfh, NULL);
            break;
#endif

        case 'e':
        case 'E':
            //
            //  /e command to execute
            //
            if ( c > 1 ) {
                            SHIFT (c, v);
                pExecute = *v;
            }
            break;

        case 't':
        case 'T':
            //
            //  /t next file is temporary .. don't keep in file history
                        //
                        InLoop = FALSE;
            break;


#if DEBUG
        case 'd':
            //
            // /d### debug level
            //
            SHIFT(c,v);
            debug = ntoi (*v, 16);
            break;
#else
        case 'd':
#endif
        case 'D':
            //
            //  /D don't read tools.ini
            //
            fDefaults = TRUE;
            break;

        case 'r':
        case 'R':
            //
            // /r Enter with noedit
            //
            fGlobalRO = TRUE;
            break;

        case 'm':
        case 'M':
            //
            //  /m markname - start at markname
            //
            SHIFT(c,v);
            szMark = *v;

        default:
                        printf ("%s %s\n", Name, Version);
                        printf ("%s\n", CopyRight);
                        printf("Usage: %s [/D] [/e cmd-string] [/m mark] [/r] [[/t] filename]*\n", szName);
                        fSaveScreen = FALSE;
            exit(1);
            break;
        }
                if (InLoop) {
                        SHIFT(c,v);
                }
    }

    InitNames (szName);

    cArgs = c;
    pArgs = v;
        // assert (_heapchk() == _HEAPOK);

    /*
     * At this point, command line arguments have been processed. Continue with
     * initialization.
     */
    if (!init ()) {
        CleanExit (1, CE_VM);
    }

    /*
     * based on the re-entry state, take appropriate initial action:
     *  - PWB_ENTRY:    process rest of command line
     *  - PWB_COMPILE:  read compile log, and go to first error in log
     *  - PWB_SHELL:    do nothing
     */

#if 0
    //
    // BUGBUG what is this supposed to do?
    // 
    if (szMark) {
        GoToMark;
    }
#endif
    domessage (CopyRight);

    Display ();

    /*
     * execute autostart macro if present
     */
    if (NameToFunc ("autostart")) {
        fExecute ("autostart");
        Display ();
    }

    /*
     * execute command line /e parameter if present
     */
    if (pExecute) {
        fExecute (pExecute);
    }

    TopLoop ();
    CleanExit (0, CE_VM | CE_SIGNALS | CE_STATE);
}





/*** TopLoop - read a command and execute it until termination
*
*  We read commands from the editor input and send them to the proper
*  recipients. We continue to do this until a termination flag is seen.
*
* Input:
*  None
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
TopLoop (
    void
    ) {
    PCMD pFuncPrev = &cmdUnassigned;

    while (!fBreak) {
        PCMD pFunc = zloop (ZL_CMD | ZL_BRK);

        if (pFunc != NULL) {
            /*  if prev wasn't graphic or this wasn't graphic then
             *      log a boundary
             */
            if (pFuncPrev->func != graphic || pFunc->func != graphic) {
                LogBoundary ();
            }
            fRetVal = SendCmd (pFunc);
            if (pFunc->func != cancel) {
                if (fCtrlc) {
                    DoCancel ();
                }
            }
            pFuncPrev = pFunc;
        }
    }
    fBreak = FALSE;
}





/*** zloop - read next command, potentially updating screen
*
*  zloop updates screen until a command is read that is not a macro
*  invocation. If a macro invocation is seen then just execute it and
*  continue. The reason for this is that the macro invocation will set up a
*  new input context that we'll retrieve in the next loop.
*
*  We call RecordCmd for each command, in case we have recording on.  If
*  the user has done <meta><record>, we record macro names, not their
*  values.  This is because a macro with flow control, especially a loop,
*  will behave badly (possibly hang) because none of the editing commands
*  return values.
*
* Input:
*  flags      - ZL_CMD      command key, should be an event
*             - ZL_BRK      take fBreak into account
*
* Output:
*  Returns a pointer to command structure that is next to be executed
*
*************************************************************************/
PCMD
zloop (
    flagType flags
    ) {

    REGISTER PCMD pFunc = NULL;
    EVTargs e;

    while (!fBreak || !TESTFLAG(flags, ZL_BRK)) {

        /*
         * Between every command, check heap and pfile list consistancy
         */
                // assert (_heapchk() == _HEAPOK);
                // assert (_pfilechk());

        /*  if macro in progress then
         */
        if (mtest ()) {
            pFunc = mGetCmd ();
        } else {
            DoDisplay ();

            do {
                pFunc = ReadCmd ();
                e.arg.key = keyCmd.KeyInfo;
                if (!TESTFLAG(flags, ZL_CMD)) {
                    break;
                }
            } while (DeclareEvent (EVT_KEY, (EVTargs *)&e));
        }

        if (pFunc != NULL) {
            RecordCmd (pFunc);
            if (pFunc->func == macro) {
                fRetVal = SendCmd (pFunc);
            } else {
                break;
            }
        }
    }
    return pFunc;
}





/*** Idle & IdleThread - Code executed at idle time
*
*  Idle loop. Structured so that only ONE idle-item does something each time
*  though the loop. Ensures minimum exit delay. When nothing has
*  happened we sleep a bit each time, to make sure we're not hogging the CPU.
*
*  Also causes the screen to be updated, if need be.
*
*  Idle is structure so that routines which it calls return either:
*       TRUE - idle processing done, perhaps more to be done
*       FALSE - no idle processing done, and no more anticipated.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
IdleThread (
    void
    ) {
    while (TRUE) {

        WaitForSingleObject( semIdle, INFINITE);
        Idle();
        SetEvent( semIdle );
        Sleep(100L);
    }
}



flagType
Idle (
    void
    ) {

    if (TESTFLAG (fDisplay, (RTEXT | RCURSOR | RSTATUS))) {
        DoDisplay ();
    }

    if (!DeclareEvent (EVT_IDLE, NULL)) {
        if (!fIdleUndo (FALSE)) {
                return FALSE;
        }
    }

    /*
     * got here, means someone processed idle, and may have more to do
     */
    return TRUE;
}



/*** IntError - Internal error Processor.
*
*  Allow user to abort, or attempt to continue.
*
* Input:
*  p            = pointer to error string
*
* Output:
*  Returns only if user says to.
*
*************************************************************************/
void
IntError (
    char *p
    ) {
    static char pszMsg [] = "MEP internal error - %s, continue? ";

        if ( OriginalScreen ) {
                consoleSetCurrentScreen( OriginalScreen );
        }
    printf ("\n");
    if (TESTFLAG (fInit, INIT_VIDEO)) {
        if (!confirm (pszMsg, p)) {
#if DEBUG
            fflush (debfh);
#endif
            CleanExit (1, CE_STATE);
        } else {
        ;
        }
    } else {
        printf (pszMsg, p);
        CleanExit (1, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\pick.c ===
/*** pick.c - pick a piece of text and put it into the put buffer
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"


#define DEBFLAG PICK



flagType
zpick (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    buffer pbuf;

    /*	LINEARG illegal 	    */
    /*	BOXARG illegal		    */

    switch (pArg->argType) {

    case NOARG:
	pick (0, pArg->arg.noarg.y, 0, pArg->arg.noarg.y, LINEARG);
        return TRUE;

    case TEXTARG:
        if (pFilePick != pFileHead) {
            DelFile (pFilePick, TRUE);
        }
	strcpy ((char *) pbuf, pArg->arg.textarg.pText);
	PutLine ((LINE)0, pbuf, pFilePick);
	kindpick = BOXARG;
        return TRUE;

    /*  NULLARG is converted into TEXTARG   */

    case LINEARG:
	pick (0, pArg->arg.linearg.yStart,
	      0, pArg->arg.linearg.yEnd, LINEARG);
        return TRUE;

    case BOXARG:
	pick (pArg->arg.boxarg.xLeft,  pArg->arg.boxarg.yTop,
	      pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom, BOXARG);
        return TRUE;

    case STREAMARG:
	pick (pArg->arg.streamarg.xStart,  pArg->arg.streamarg.yStart,
	      pArg->arg.streamarg.xEnd,    pArg->arg.streamarg.yEnd, STREAMARG);
	return TRUE;
    }

    return FALSE;
    argData; fMeta;
}




void
pick (
    COL  xstart,
    LINE ystart,
    COL  xend,
    LINE yend,
    int  kind
    )
{

    if (pFilePick != pFileHead) {
        DelFile (pFilePick, TRUE);
    }
    kindpick = kind;

    switch (kind) {

    case LINEARG:
	CopyLine (pFileHead, pFilePick, ystart, yend, (LINE)0);
        break;

    case BOXARG:
	CopyBox (pFileHead, pFilePick, xstart, ystart, xend, yend, (COL)0, (LINE)0);
        break;

    case STREAMARG:
	CopyStream (pFileHead, pFilePick, xstart, ystart, xend, yend, (COL)0, (LINE)0);
	break;
    }
}




flagType
put (
    CMDDATA argData,
    ARG  *pArg,
    flagType fMeta
    )
{

    flagType fTmp = FALSE;
    int      i;
    buffer   putbuf;
    pathbuf  filebuf;
    FILEHANDLE fh;
    PFILE    pFileTmp;
    char     *pBuf;


    switch (pArg->argType) {

	case BOXARG:
	case LINEARG:
	case STREAMARG:
	    delarg (pArg);
	    break;

	case TEXTARG:
	    strcpy ((char *) buf, pArg->arg.textarg.pText);
            DelFile (pFilePick, TRUE);
            if (pArg->arg.textarg.cArg > 1) {
                pBuf = whiteskip (buf);
                if (*pBuf == '!') {
		    findpath ("$TMP:z.$", filebuf, TRUE);
		    fTmp = TRUE;
		    sprintf (putbuf, "%s >%s", pBuf+1, filebuf);
		    zspawnp (putbuf, TRUE);
		    pBuf = filebuf;
                }
                if (*pBuf != '<') {
                    CanonFilename (pBuf, putbuf);
                } else {
                    strcpy (putbuf, pBuf);
                }
                //
                // If we find the file in the existing file history, read it in, if not already
                // in, and just to a copy operation on the desired text.
                //
                if ((pFileTmp = FileNameToHandle (putbuf, pBuf)) != NULL) {
                    if (!TESTFLAG (FLAGS (pFileTmp), REAL)) {
			if (!FileRead(pFileTmp->pName,pFileTmp, FALSE)) {
			    printerror ("Cannot read %s", pFileTmp->pName);
			    return FALSE;
                        }
                    }
		    CopyLine (pFileTmp, pFilePick, (LINE)0, pFileTmp->cLines-1, (LINE)0);
                } else {
                    if ((fh = MepFOpen(putbuf, ACCESSMODE_READ, SHAREMODE_RW, FALSE)) == NULL) {
			printerror ("%s does not exist", pBuf);
			return FALSE;
                    }
		    readlines (pFilePick, fh);
                    MepFClose (fh);
                }
                if (fTmp) {
                    _unlink (filebuf);
                }
                kindpick = LINEARG;
            } else {
                PutLine ((LINE)0, buf, pFilePick);
                kindpick = BOXARG;
            }
	    break;
    }

    switch (kindpick) {

	case LINEARG:
	    CopyLine (pFilePick, pFileHead, (LINE)0, pFilePick->cLines-1, YCUR (pInsCur));
            break;

	case BOXARG:
	    i = LineLength ((LINE)0, pFilePick);
	    CopyBox (pFilePick, pFileHead, 0, (LINE)0, i-1, pFilePick->cLines-1, XCUR (pInsCur), YCUR (pInsCur));
            break;

	case STREAMARG:
	    i = LineLength (pFilePick->cLines-1, pFilePick);
	    CopyStream (pFilePick, pFileHead, 0, (LINE)0, i, pFilePick->cLines-1, XCUR (pInsCur), YCUR (pInsCur));
	    break;
    }

    return TRUE;

    argData; fMeta;
}




/*** CopyLine - copy lines between files
*
*  If the source file is NULL, then we insert blank lines.
*
* Input:
*  pFileSrc	= source file handle
*  pFileDst	= destination file handle
*  yStart	= first line to be copied
*  yEnd 	= last line to be copied
*  yDst 	= location of destination of copy
*
*************************************************************************/
void
CopyLine (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    LINE    yStart,
    LINE    yEnd,
    LINE    yDst
    )
{
    linebuf L_buf;
    struct lineAttr * rgla = (struct lineAttr *)ZEROMALLOC (sizeof(linebuf)/sizeof(char) * sizeof(struct lineAttr));

    if (pFileSrc != pFileDst) {
        if (yStart <= yEnd) {
            InsLine (TRUE, yDst, yEnd - yStart + 1, pFileDst);
            if (pFileSrc != NULL) {
                MarkCopyLine (pFileSrc, pFileDst, yStart, yEnd, yDst);
                while (yStart <= yEnd) {
                    gettextline (TRUE, yStart++, L_buf, pFileSrc, ' ');
                    puttextline (TRUE, TRUE, yDst++, L_buf, pFileDst);
                    if (getcolorline (TRUE, yStart-1, rgla, pFileSrc)) {
                        putcolorline (TRUE, yDst-1, rgla, pFileDst);
                    }
                }
            }
        }
    }
    FREE (rgla);
}




/*** CopyBox - copy a box from one place to another
*
*  If the source file is NULL, then we insert blank space. We copy the box
*  defined by the LOGICAL box xLeft-xRight and yTop-yBottom inclusive.
*
* Input:
*  pFileSrc	= source file handle
*  pFileDst	= destination file handle
*  xLeft	= column location of beginning of copy
*  yTop 	= line location of beginning of copy
*  xRight	= column location of end of copy
*  yBottom	= line location of end of copy
*  xDst 	= column location of destination of copy
*  yDst 	= line location of destination of copy
*
*************************************************************************/
void
CopyBox (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    COL     xLeft,
    LINE    yTop,
    COL     xRight,
    LINE    yBottom,
    COL     xDst,
    LINE    yDst
    )
{
    int     cbDst;                          /* count of bytes in destination*/
    int     cbMove;                         /* count of bytes to move around*/
    linebuf dstbuf;                         /* buffer for result            */
    char    *pDst;                          /* physical pointer to dest     */
    char    *pSrcLeft;                      /* physical pointer to src left */
    char    *pSrcRight;                     /* physical pointer to src right+1*/
    linebuf L_srcbuf;                       /* buffer for source line       */
    struct lineAttr rgla[sizeof(linebuf)];
    flagType fColor;

    /*
     *  Do not allow overlapped copies.
     */
    if ((pFileSrc == pFileDst)
        && ((      fInRange ((LINE)xLeft, (LINE)xDst, (LINE)xRight)
                && fInRange (yTop, yDst, yBottom))
            || (   fInRange ((LINE)xLeft, (LINE)(xDst + xRight - xLeft), (LINE)xRight)
                && fInRange (yTop, yDst + yBottom - yTop, yBottom))
            )
        ) {
        return;
    }

    /*
     * If valid left and right coordinates for box, then for each line...
     */
    if (xLeft <= xRight) {
        /*
         *  Let the Marker update any affected marks.
         */
        MarkCopyBox (pFileSrc, pFileDst, xLeft, yTop, xRight, yBottom, xDst, yDst);
        while (yTop <= yBottom) {

            if (!pFileSrc) {
                //
                //  File is not a file, just insert spaces.
                //
                if (!fInsSpace (xDst, yDst, xRight - xLeft + 1, pFileDst, dstbuf)) {
                    LengthCheck (yDst, 0, NULL);
                }
                pDst  = pLog (dstbuf, xDst, TRUE);
            } else {
                //
                //  When source IS a file, we:
                //   - get both source and destination lines
                //   - ensure that the source line is detabbed (only way to ensure proper
                //     alignment in the copy.
                //   - get phsical pointers to right and left of source.
                //   - get phsical pointer to destination
                //   - get length of physical move and current destination
                //   - physical length check the potential destination result
                //   - open up a hole in the destination line for the source
                //   - copy the source range into the destination
                //   - perform logical length check.
                //
                fInsSpace (xRight+1, yTop, 0, pFileSrc, fRealTabs ? dstbuf : L_srcbuf);
                if (fRealTabs) {
                    Untab (fileTab, dstbuf, strlen(dstbuf), L_srcbuf, ' ');
                }
                fInsSpace (xDst,   yDst, 0, pFileDst, dstbuf);

                pSrcLeft  = pLog (L_srcbuf, xLeft, TRUE);
                pSrcRight = pLog (L_srcbuf, xRight, TRUE) + 1;

                pDst      = pLog (dstbuf, xDst, TRUE);

                cbMove  = (int)(pSrcRight - pSrcLeft);
                cbDst   = strlen (dstbuf);

                if (cbDst + cbMove > sizeof(linebuf)) {
                    LengthCheck (yDst, 0, NULL);
                } else {
                    memmove (pDst + cbMove, pDst, strlen(dstbuf) - (int)(pDst - dstbuf) + 1);

                    memmove (pDst, pSrcLeft, cbMove);

                    if (cbLog(dstbuf) > sizeof(linebuf)) {
                        LengthCheck (yDst, 0, NULL);
                        *pLog (dstbuf, sizeof(linebuf) - 1, TRUE) = 0;
                    }
                }
            }
            if (fColor = GetColor (yDst, rgla, pFileDst)) {
                if (pFileSrc) {
                    CopyColor (pFileSrc, pFileDst, yTop, xLeft, cbMove, yDst, xDst);
                } else {
                    ShiftColor (rgla, (int)(pDst - dstbuf), xRight - xLeft + 1);
                    ColorToLog (rgla, dstbuf);
                }
            }
            PutLine (yDst, dstbuf, pFileDst);
            if (fColor) {
                PutColor (yDst, rgla, pFileDst);
            }
            yDst++;
            yTop++;
        }
    }
}





/*** CopyStream - copy a stream of text (including end-of-lines)
*
*  If source file is NULL, then we insert blank space. We copy starting at
*  xStart/yStart and copy through to the character before xEnd/yEnd. This
*  means that to copy line Y INCLUDING the line separator, we specify
*  (xStart,yStart) = (0,Y) and (xEnd,yEnd) = (0, Y+1)
*
* Input:
*  pFileSrc	= source file handle
*  pFileDst	= destination file handle
*  xStart	= column location of beginning of copy
*  yStart	= line location of beginning of copy
*  xEnd 	= column location of end of copy
*  yEnd 	= line location of end of copy
*  xDst 	= column location of destination of copy
*  yDst 	= line location of destination of copy
*
*************************************************************************/
void
CopyStream (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    COL     xStart,
    LINE    yStart,
    COL     xEnd,
    LINE    yEnd,
    COL     xDst,
    LINE    yDst
    )
{
    linebuf dstbuf;                         /* buffer for result            */
    char    *pDst;
    linebuf L_srcbuf;                         /* buffer for source line       */
    LINE    yDstLast;

    /*
     * validate copy...must be different files, and coordinates must make sense.
     */
    if (!(pFileSrc != pFileDst &&
        (yStart < yEnd || (yStart == yEnd && xStart < xEnd)))) {
        return;
    }

    /*
     *  Special case a single-line stream as a box copy
     */
    if (yStart == yEnd) {
        CopyBox (pFileSrc, pFileDst, xStart, yStart, xEnd-1, yEnd, xDst, yDst);
        return;
    }

    /*
     * Valid stream copy. First, copy the intermediate lines.
     */
    CopyLine (pFileSrc, pFileDst, yStart+1, yEnd, yDst+1);

    /*
     * Form last line of destination stream. Copy last part of dest line onto
     * last part of last source line. Make sure that each copy of the
     * source/dest is correct length
     */
    fInsSpace (xDst, yDst, 0, pFileDst, dstbuf);    /*  dddddeeeeee   */
    if (pFileSrc != NULL) {
        fInsSpace (xEnd, yEnd, 0, pFileSrc, L_srcbuf);/*  AAAABBBBB     */
    } else {
	memset ((char *) L_srcbuf, ' ', xEnd);
    }
    pDst = pLog (dstbuf,xDst, TRUE);
    yDstLast = yDst + yEnd - yStart;
    LengthCheck (yDstLast, xEnd, pDst);
    strcpy ( pLog(L_srcbuf,xEnd,TRUE), pDst);         /*  AAAAeeeeee    */
    PutLine (yDstLast, L_srcbuf, pFileDst);

    /*
     * Form first line of destination stream. Copy last part of first source
     * line onto last part of dest line
     */
    if (pFileSrc != NULL) {
        fInsSpace (xStart, yStart, 0, pFileSrc, L_srcbuf);/*  CCCCCDDDDD*/
        LengthCheck (yDst, xDst, L_srcbuf + xStart);
        strcpy (pDst, pLog(L_srcbuf,xStart,TRUE));        /*  dddddDDDDD*/
    } else {
        *pDst = 0;
    }
    PutLine (yDst, dstbuf, pFileDst);

    /*
     * To update marks, we first adjust any marks at yDst, then add new
     * marks from the src.
     */
    MarkCopyBox (pFileDst, pFileDst, xDst, yDst, sizeof(linebuf), yDst, xEnd-1, yDstLast);
    MarkCopyBox (pFileSrc, pFileDst, 0, yEnd, xEnd, yEnd, 0, yDstLast);
    MarkCopyBox (pFileSrc, pFileDst, xStart, yStart, sizeof(linebuf), yStart, xDst, yDst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\record.c ===
/***  RECORD.C - Handle function-by-function recording
*
*       Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "cmds.h"


/* Use the pFile MODE1 flag for <record> quote mode */
#define INQUOTES    MODE1


static PFILE    pFileRecord;
static char     szRecordName[]  = "<record>";
static PCMD     pcmdRecord      = NULL;



/*** record - <record> edit command
*
* Purpose:
*
*   Toggles recording state.  When turning on, the file <record> is erased
*   (unless we are appending), the string "macroname:= " is inserted into
*   the file and quote mode is turned off.  When turning off, quote marks
*   are appended to the macro (if needed) and the macro is assigned.
*
*	       <record> - Starts/stops recording using the current macro
*			  name.
*		  <arg> - Start/stops recording using the default macro
*			  name.
*	  <arg> textarg - Starts recording a macro named 'textarg'.
*		 <meta> - Like <record>, but commands are not executed.
*	    <arg> <arg> - Like <record>, but append to current recording.
*   <arg> <arg> textarg - Start appending to macro named 'textarg'.
*
*   If recording is on, only <record> will work.
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
record (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    LINE        line;
    char        *pch;
    char        *szDefaultName  = "recordvalue";
    char    *lpch	    = NULL;
    flagType    fAppend         = FALSE;
    flagType    fNameGiven      = FALSE;

    // Check for the <record> file.  If we haven't done a <record>
    // yet, see if the user has created it.  If not, create it.
    // If this is the first time through, make sure it gets set to
    // READONLY.
    //
    if (pFileRecord == NULL) {
        if ((pFileRecord = FileNameToHandle(szRecordName,szRecordName)) == NULL) {
            pFileRecord = AddFile (szRecordName);
            FileRead (szRecordName, pFileRecord, FALSE);
        }
        SETFLAG (FLAGS(pFileRecord), REAL | FAKE | DOSFILE);
    }

    if (fMacroRecord) {
        // We need to turn off. Let's check for an open quote at the end
        // of the recording and close it.  Then we can DoAssign the whole
        // thing and we're done.
        //
        if (pArg->argType == NOARG) {
            if (TESTFLAG(FLAGS(pFileRecord), INQUOTES)) {
                GetLine (pFileRecord->cLines-1, buf, pFileRecord);
                strcat (buf, "\"");
                PutLine (pFileRecord->cLines-1, buf, pFileRecord);
                RSETFLAG (FLAGS(pFileRecord), INQUOTES);
            }
            fMacroRecord = FALSE;

            if (fMetaRecord) {
                domessage (NULL);
                fMetaRecord = FALSE;
            }

            // This may look like we're supporting multiple macro
            // definitions in the record file, but it is really a
            // cheap way to get GetTagLine to free up the heap space
            // it uses.
            //
            pch = NULL;
            line = 0;
            while ((pch = GetTagLine (&line, pch, pFileRecord))) {
                DoAssign (pch);
            }
        } else {
            ;
        }
    } else {
        // We are turning recording on.  First, decide on the name
        // of the macro to record to, and whether we are appending
        // or starting over.
        //
        switch (pArg->argType) {

            case NOARG:
		lpch = pcmdRecord ? pcmdRecord->name : (char *)szDefaultName;
                break;

            case TEXTARG:
                lpch = pArg->arg.textarg.pText;
                fNameGiven = TRUE;

            case NULLARG:
                fAppend = (flagType)(pArg->arg.textarg.cArg > 1);
                break;
        }

        assert (lpch);
        strcpy ((char far*)buf, lpch);

        while ((pcmdRecord = NameToFunc (buf)) == NULL) {
            if (!SetMacro (buf, RGCHEMPTY)) {
                return FALSE;
            }
        }

        // If we are not appending, we delete the file, insert a
        // new name and possibly a current value.
        //
        if (!fAppend || fNameGiven) {
            DelFile (pFileRecord, FALSE);
            strcat (buf, ":=");
            PutLine (0L, buf, pFileRecord);
            if (fAppend) {
                AppendMacroToRecord (pcmdRecord);
            }
        }


        RSETFLAG (FLAGS(pFileRecord), INQUOTES);
        fMacroRecord = TRUE;

        if (fMetaRecord = fMeta) {
            strcpy (buf, "<record>");
            FuncToKey (CMD_record, buf);
            domessage ("No-Execute Record Mode - Press %s to resume normal editing", buf);
        }
    }

    SETFLAG (fDisplay, RSTATUS);
    return fMacroRecord;

    argData;
}




/*** tell - Editor command - Tells us the names and values of things
*
* Purpose:
*
*   This allows the user to easily disover the name of a key, the name
*   of the function attached to a given key or the value of a macro.
*
*		<tell>	Prompts for a keystroke, then displays the key's
*			name and the function assigned to it in this
*			format: "function:KeyName"
*	   <arg><tell>	Like <tell>, but if the key has a macro attached,
*			displays "MacroName:= Macro Value"
* <arg> textarg <tell>	Like <arg><tell>, but gets the macro name from
*			the textarg instead of a keystroke.
*		<meta>	All of the above, except the output is inserted into
*			the current file.
*
*   Insertion takes place at the cursor.  The insertion will be
*   atomic; the user will see only the final product.
*
* Input:
*
*   The usual.
*
* Output:
*
*   Returns FALSE if the function is <unassigned>, TRUE otherwise.
*
*************************************************************************/
flagType
ztell (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer   L_buf;
    buffer   buf2;
    PCMD     pCmd;
    char     *pch;
    flagType fWrap      = fWordWrap;
    flagType fInQuotes  = FALSE;
    flagType fMacro     = FALSE;

    switch (pArg->argType) {

        case NOARG:
        case NULLARG:
            dispmsg (MSG_TELLPROMPT);
            pCmd = ReadCmdAndKey (buf2);
            if ((pArg->argType == NULLARG) &&
                (PVOID)pCmd->func == (PVOID)macro) {
                goto domacro;
            }
notmacro:
            sprintf (L_buf, "%Fs:%s",pCmd->name, buf2);
            break;

        case TEXTARG:
            strcpy (buf2, pArg->arg.textarg.pText);
            if (NULL == (pCmd = NameToFunc (buf2))) {
                disperr (MSGERR_ZTELL, buf2);
                return FALSE;
            }

            if ((PVOID)pCmd->func == (PVOID)macro) {
domacro:
                fMacro = TRUE;
                sprintf (L_buf, "%Fs:=", pCmd->name);
            } else {
                goto notmacro;
            }
    }

    // Now buf is filled with the string to display.
    // if fMacro is TRUE, we must also append the
    // value of pCmd->arg
    //
    if (fMeta) {
        fWordWrap = FALSE;
        pch = L_buf - 1;
doitagain:
        while (*++pch) {
            if (*pch == ' ' && XCUR(pInsCur) >= xMargin) {
                edit (' ');
                edit (' ');
                edit ('\\');
                docursor (softcr(), YCUR(pInsCur) + 1);
            } else {
                edit (*pch);
            }
        }
        if (fMacro) {
            pch = (char *)pCmd->arg - 1;
            fMacro = FALSE;
            goto doitagain;
        }
        fWordWrap = fWrap;
    } else {
        if (fMacro ) {
            strncat (L_buf, (char *)pCmd->arg, XSIZE);
        }
        domessage (L_buf);
    }
    return (flagType)((PVOID)pCmd->func != (PVOID)unassigned);

    argData;
}



/*** RecordCmd - Append a command name to the <record> file.
*
* Purpose:
*
*   Whenever a command is about to be performed, this function should
*   be called.
*
* Input:
*   pCmd -> The command to record
*
* Output: None
*
* Notes:
*
*   The basic operation is to append pCmd->name to the file.  This
*   means checking for:
*
*	o Line overflow.  If appending to the line would overflow the
*	  maximum line length (BUFLEN - 3), we must append a " \" and
*	  write to the next line.
*
*	o Graphic characters.  If the function is <graphic>, then we add
*	  the ASCII character, not "graphic".  If we are outside quotes, we
*	  must add quotes first and flag quote mode.  To flag quote mode
*	  we use the special 'MODE1' flag in pFile.
*
*	o <unassigned>.  This is considered user clumsiness and is not
*	  recorded.
*
*	o All other cases.  If the previous function was <graphic> and the
*	  current function is not, we must close quotes first.
*
*************************************************************************/
void
RecordCmd (
    PCMD pCmd
    )
{
    buffer szCmdName;
    buffer L_buf;
    REGISTER char * pchEndLine;
    REGISTER char * pchNew;
    char c;
    LINE line;
    int entab;

    if (!fMacroRecord) {   /* If we're not on, do nothing */
        return;
    }

    assert (pFileRecord);

    if ((PVOID)pCmd->func == (PVOID)unassigned ||
        (PVOID)pCmd->func == (PVOID)record ||
        (!fMetaRecord && (PVOID)pCmd->func == (PVOID)macro)) {
        return;
    }

    // First, we get the current (i.e. last) line to play with.
    // Let's also set a pointer to the end of it so we don't have
    // to keep strcat'ing and strlen'ing it.
    //
    GetLine ((line = pFileRecord->cLines-1), L_buf, pFileRecord);
    pchEndLine = strend (L_buf);
    pchNew = szCmdName;


    // Now we generate the new text.  Since we may be moving into and
    // out of quotes, we have four possible transitions from the
    // previous entry:
    //
    //      last cmd type   this cmd type   resulting pattern
    //
    //      graphic         graphic         >c<
    //      non-graphic     graphic         > "c<
    //      graphic         non-graphic     >" cmdname<
    //      non-graphic     non-graphic     > cmdname<
    //
    if ((PVOID)pCmd->func == (PVOID)graphic) {
        if (!TESTFLAG(FLAGS(pFileRecord), INQUOTES)) {
            *pchEndLine++ = ' ';
            *pchEndLine++ = '"';
            SETFLAG (FLAGS(pFileRecord), INQUOTES);
        }
        c = (char)pCmd->arg;
        if (c == '"' || c == '\\') {
            *pchNew++ = '\\';
        }

        *pchNew++ = c;
        *pchNew = '\0';
    } else {
        if (TESTFLAG (FLAGS(pFileRecord), INQUOTES)) {
            *pchEndLine++ = '"';
            RSETFLAG (FLAGS(pFileRecord), INQUOTES);
        }
        *pchEndLine++ = ' ';
	strcpy ((char *)pchNew, pCmd->name);
    }


    // Finally, let's add the new text to the file. We'll add
    // a continuation character if necessary.
    //
    entab = EnTab;
    EnTab = 0;
    if ((COL) ((pchEndLine - L_buf) + strlen (szCmdName)) > xMargin) {
        strcpy (pchEndLine, " \\");
        PutLine (line+1, szCmdName, pFileRecord);
        UpdateIf (pFileRecord, line+1, FALSE);
    } else {
        strcpy (pchEndLine, szCmdName);
        UpdateIf (pFileRecord, line, FALSE);
    }

    PutLine (line, L_buf, pFileRecord);
    EnTab = entab;

    return ;
}





/*** RecordString - Record an entire string
*
* Purpose:
*
*   To record a string that woule be missed by RecordCmd.
*
* Input:
*   psz - String to record.
*
* Output: None
*
* Notes:
*
*   Currently implemented by callinto RecordCmd.  Should be implemented
*   by having RecordCmd and RecordString call common "write to <record>"
*   code.
*
*************************************************************************/
void
RecordString (
    char * psz
    )
{

    if (!fMacroRecord) {  /* If we're not on, do nothing */
        return;
    }

    while (*psz) {
	(CMD_graphic)->arg = *psz++;
	RecordCmd (CMD_graphic);
    }
}




/*** AppendMacroToRecord - Append the current value of a macro to <record>
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
AppendMacroToRecord (
    PCMD pCmdMac
    )
{
    flagType fDone = FALSE;
    char     *pchValue, *pch;
    LINE     line;


    // First, get the raw macro value
    //
    pchValue = (char *)pCmdMac->arg;

    // Now, throw the vlaue into the file one line
    // at a time.  Start at the end of the file
    //
    line = pFileRecord->cLines - 1;

    do {
        GetLine (line, buf, pFileRecord);

        for (pch = pchValue + min ((ULONG)(xMargin + 5 - strlen(buf)), (ULONG)strlen (pchValue));
             pch > pchValue && *pch && *pch != ' ' && *pch != '\t';
             pch--) {
            ;
        }

        // Now pch points at either the last space, the end
        // of the value or the beginning.  If it points to the
        // beginning or end, we copy all of pchValue.  Otherwise,
        // we copy just up to pch
        //
        if (!*pch || pch == pchValue) {
            strcat (buf, pchValue);
            fDone = TRUE;
        } else {
            strncat (buf, pchValue, (int)(pch - pchValue));
            strcat (buf, "  \\");
            pchValue = pch + 1;
        }

        PutLine (line++, buf, pFileRecord);
    } while (!fDone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\pbal.c ===
/*** pbal.c - balance parenthesis
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "mep.h"


#define BALOPEN "([{"
#define BALCLOS ")]}"

static flagType fBalMeta;



flagType
pbal (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    flagType fFor;
    fl       flCur;

    fBalMeta = fMeta;

    switch (pArg->argType) {

    case NOARG: 		    /* balance a single character */
        balopen  = BALOPEN;
	balclose = BALCLOS;
	setAllScan (fFor = FALSE);
        break;


    /*  TEXTARG illegal             */


    case NULLARG:
        balopen  = BALCLOS;
	balclose = BALOPEN;
	setAllScan (fFor = TRUE);
        break;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }


    ballevel  = 0;
    flCur.col = XCUR(pInsCur);
    flCur.lin = YCUR(pInsCur);

    if (!fScan (flCur, FNADDR(fDoBal), fFor, FALSE)) {
	domessage ("No unbalanced characters found");
	return FALSE;
    }
    return TRUE;

    argData;
}





flagType
fDoBal (
    void
    ) {

    int k, x;

    if ((k=InSet(scanbuf[flScan.col], balclose)) != -1) {
	ballevel ++;
    } else if ((k=InSet(scanbuf[flScan.col], balopen)) != -1) {
	if (--ballevel < 0) {
	    HighLight (flScan.col, flScan.lin, flScan.col, flScan.lin);
	    if (!fInRange ((long)XWIN (pInsCur), (long)flScan.col, (long)(XWIN (pInsCur) + WINXSIZE(pWinCur))-1) ||
		!fInRange (YWIN (pInsCur), flScan.lin, (YWIN (pInsCur) + WINYSIZE(pWinCur))-1)) {
		/*  Balance point not on screen, put onto status line
		 */
		x = strlen (scanbuf);
                if (x >= XSIZE) {
		    if (x - flScan.col < XSIZE/2) {
			memmove ((char *) scanbuf, (char *) scanbuf + x - XSIZE, XSIZE);
			flScan.col -= x - XSIZE;
                    } else {
			memmove ((char *) scanbuf, (char *) scanbuf + flScan.col - XSIZE/2, XSIZE);
			flScan.col = XSIZE/2;
                    }
                }
		scanbuf[XSIZE] = 0;
		scanbuf[flScan.col] = 0;
                x = sout (0, YSIZE, scanbuf, infColor);
		x = vout (x, YSIZE, &balopen[k], 1, hgColor);
		soutb (x, YSIZE, &scanbuf[flScan.col+1], infColor);
            }
            if (!fBalMeta) {
                edit (balclose[k]);
            }
	    return TRUE;
        }
    }
    return FALSE;
}





int
InSet (
    char c,
    char *p
    )
{

    int i;

    for (i=0; *p; i++) {
        if (*p++ == c) {
            return i;
        }
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\replace.c ===
/*** replace.c - string replacement functions
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Repalces funnel through these routines as follows:
*
*	zreplace    mreplace	qreplace
*	     \         |	 /
*	      \        |	/
*	       \______ | ______/
*		      \|/
*		       v
*		   doreplace
*		       |
*		    (fScan)
*		       |
*		   fDoReplace
*		     /	 \
*		    /	  \
*		patRpl	simpleRpl (if a change is made)
*		    \ 	  /
*		     \   /
*		  ReplaceEdit
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/
#define NOVM
#include "mep.h"


static flagType       fQrpl   = FALSE;  /* TRUE => prompt for replacement     */
static struct patType *patBuf = NULL;	/* compiled pattern		      */
static int            srchlen;          /* length of textual search           */
static unsigned       MaxREStack;       /* Elements in RE stack               */
static RE_OPCODE      ** REStack;       /* Stack for REMatch                  */



/*** mreplace - multiple file search and replace
*
*  Perform a search and replace across multiple files. Acts like qreplace, in
*  that the first instance the user is always asked. he may then say "replace
*  all".
*
* Input:
*  Standard editting function.
*
* Output:
*  Returns TRUE on successfull replacement.
*
*************************************************************************/
flagType
mreplace (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return doreplace (TRUE, pArg, fMeta, TRUE);

    argData;
}



/*** zreplace & qreplace - perform search/replace
*
*  Editting functions which implement search & replace. qreplace prompts,
*  zreplace does not.
*
* Input:
*  Standard editting function parameters.
*
* Output:
*  Returns
*
*************************************************************************/
flagType
zreplace (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return doreplace (FALSE, pArg, fMeta, FALSE);

    argData;
}





flagType
qreplace (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return doreplace (TRUE, pArg, fMeta, FALSE);

    argData;
}




/*** doreplace - perform search-replace
*
*  Performs the actual search and replace argument verification, set up and
*  high level control.
*
* Input:
*  fQuery	= TRUE if a query replace
*  pArg 	= pArg of parent function
*  fMeta	= fMeta of parent function
*  fFiles	= TRUE is multiple file search and replace.
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
doreplace (
    flagType fQuery,
    ARG * pArg,
    flagType fMeta,
    flagType fFiles
    )
{
    buffer  bufFn;                          /* filename buffer              */
    fl      flStart;
    char    *p;
    PCMD    pCmd;
    PFILE   pFileSave;                      /* file to save as top of heap  */

    p = "Query Search string: ";
    if (!fQuery) {
        p += 6;
    }

    fQrpl = fQuery;
    fSrchCasePrev = fMeta ? (flagType)!fSrchCaseSwit : fSrchCaseSwit;
    Display ();
    cRepl = 0;

    /*
     * If not menu-driven, ask the user for a search string. If none is entered,
     * we're done.
     */
    if ((pCmd = getstring (srcbuf, p, NULL, GS_NEWLINE | GS_INITIAL)) == NULL || (PVOID)pCmd->func == (PVOID)cancel) {
        return FALSE;
    }

    if (srcbuf[0] == '\0') {
        return FALSE;
    }

    /*
     * If RE search to take place, the compile the expression.
     */
    if (pArg->arg.nullarg.cArg == 2) {
	if (patBuf != NULL) {
            FREE ((char *) patBuf);
	    patBuf = NULL;
        }
	patBuf = RECompile (srcbuf, fSrchCaseSwit, (flagType)!fUnixRE);
	if (patBuf == NULL) {
	    printerror ((RESize == -1) ?
			"Invalid pattern" :
			"Not enough memory for pattern");
	    return FALSE;
        }
	fRplRePrev = TRUE;
    } else {
        fRplRePrev = FALSE;
    }

    /*
     * If not menu driven, ask the user for a replacement string. Confirm the
     * entry of a null string. Error check the replacement if an RE search.
     */
    if ((pCmd = getstring (rplbuf, "Replace string: ", NULL, GS_NEWLINE | GS_INITIAL)) == NULL ||
        (PVOID)pCmd->func == (PVOID)cancel) {
        return FALSE;
    }

    if (rplbuf[0] == 0) {
        if (!confirm ("Empty replacement string, confirm: ", NULL)) {
            return FALSE;
        }
    }

    if (fRplRePrev && !RETranslate (patBuf, rplbuf, scanreal)) {
	printerror ("Invalid replacement pattern");
	return FALSE;
    }

    srchlen = strlen (srcbuf);

    switch (pArg->argType) {

    case NOARG:
    case NULLARG:
	setAllScan (TRUE);
        break;

    case LINEARG:
	rnScan.flFirst.col = 0;
        rnScan.flLast.col  = sizeof(linebuf)-1;
	rnScan.flFirst.lin = pArg->arg.linearg.yStart;
        rnScan.flLast.lin  = pArg->arg.linearg.yEnd;
        break;

    case BOXARG:
	rnScan.flFirst.col = pArg->arg.boxarg.xLeft;
        rnScan.flLast.col  = pArg->arg.boxarg.xRight;
	rnScan.flFirst.lin = pArg->arg.boxarg.yTop;
        rnScan.flLast.lin  = pArg->arg.boxarg.yBottom;
        break;

    case STREAMARG:
	if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
	    rnScan.flFirst.col = pArg->arg.streamarg.xStart;
            rnScan.flLast.col  = pArg->arg.streamarg.xEnd;
	    rnScan.flFirst.lin = pArg->arg.streamarg.yStart;
            rnScan.flLast.lin  = pArg->arg.streamarg.yEnd;
        } else {
	    rnScan.flFirst.col = 0;   /* Do all but last line first */
            rnScan.flLast.col  = sizeof(linebuf)-1;
	    rnScan.flFirst.lin = pArg->arg.streamarg.yStart;
            rnScan.flLast.lin  = pArg->arg.streamarg.yEnd - 1;
	    flStart.col = pArg->arg.streamarg.xStart - 1;
	    flStart.lin = rnScan.flFirst.lin;
	    fScan (flStart, fDoReplace , TRUE, fSrchWrapSwit);

            rnScan.flLast.col   = pArg->arg.streamarg.xEnd;
	    rnScan.flFirst.lin	= ++rnScan.flLast.lin;
        }
    }

    flStart.col = rnScan.flFirst.col-1;
    flStart.lin = rnScan.flFirst.lin;
    if (fRplRePrev) {
	MaxREStack = 512;
        REStack = (RE_OPCODE **)ZEROMALLOC (MaxREStack * sizeof(*REStack));
    }

    if (fFiles) {
        /*
         * Get the list handle, and initialize to start at the head of the list.
         * Attempt to read each file.
         */
	if (pCmd = GetListHandle ("mgreplist", TRUE)) {
	    pFileSave = pFileHead;
	    p = ScanList (pCmd, TRUE);
	    while (p) {
		CanonFilename (p, bufFn);
		forfile (bufFn, A_ALL, mrepl1file, &p);
		p = ScanList (NULL, TRUE);
                if (fCtrlc) {
                    return FALSE;
                }
            }
	    pFileToTop (pFileSave);
            dispmsg (0);
        }
    } else {
        fScan (flStart, fDoReplace , TRUE, fSrchWrapSwit);
    }

    if (fRplRePrev) {
        FREE (REStack);
    }
    domessage ("%d occurrences replaced", cRepl);
    return (flagType)(cRepl != 0);
}




/*** mrepl1file - search/replace the contents of 1 file.
*
*  Searches through one file for stuff.
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
mrepl1file (
    char   *szGrepFile,
    struct findType *pfbuf,
    void *dummy
    )
{
    flagType fDiscard;                      /* discard the file read?       */
    fl      flGrep;                         /* ptr to current grep loc      */
    int     cReplBefore;                    /* number of matches before     */
    PFILE   pFileGrep;                      /* file to be grepped           */

    assert (szGrepFile);
    assert (_pinschk(pInsCur));

    if (fCtrlc) {
        return;
    }

    /*
     * If we can get a handle to the file, then it's alread in the list, and we
     * should not discard it when done. If it is not in the list, we read it in,
     * but we'll discard it, unless something is found there.
     */
    if (!(pFileGrep = FileNameToHandle (szGrepFile, szGrepFile))) {
        pFileGrep = AddFile (szGrepFile);
        SETFLAG (FLAGS (pFileGrep), REFRESH);
        fDiscard = TRUE;
    } else {
        fDiscard = FALSE;
    }

    assert (_pinschk(pInsCur));

    /*
     * If the file needs to be physically read, do so.
     */
    if ((FLAGS (pFileGrep) & (REFRESH | REAL)) != REAL) {
        FileRead (pFileGrep->pName, pFileGrep, FALSE);
        RSETFLAG (FLAGS(pFileGrep), REFRESH);
    }

    dispmsg (MSG_SCANFILE, szGrepFile);
    pFileToTop (pFileGrep);

    /*
     * run through the file, searching and replacing as we go.
     */
    cReplBefore = cRepl;
    setAllScan (FALSE);
    flGrep.col = rnScan.flFirst.col-1;
    flGrep.lin = rnScan.flFirst.lin;
    fScan (flGrep, fDoReplace, TRUE, FALSE);
    /*
     * If the search was not successfull, discard the file, if needed, and move
     * to the next.
     */
    if (cReplBefore == cRepl) {
        if (fDiscard) {
            RemoveFile (pFileGrep);
        }
    } else {
        AutoSaveFile (pFileGrep);
    }

    assert (_pinschk(pInsCur));

    pfbuf; dummy;

}




/*** fDoReplace - called by fScan as file is scanned.
*
* Purpose:
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
fDoReplace (
    void
    )
{
    int  c;
    char *p = pLog (scanreal, flScan.col, TRUE);

    if (fRplRePrev) {
	int rem;
	flagType fAgain = TRUE;

        do {
	    switch (rem = REMatch (patBuf, scanreal, p, REStack, MaxREStack, TRUE)) {
		case REM_NOMATCH:
		    flScan.col = scanlen;
		    return FALSE;

		case REM_STKOVR:
		    MaxREStack += 128;
                    REStack = (RE_OPCODE **)ZEROREALLOC ((char *)REStack, MaxREStack * sizeof(*REStack));
		    break;

		default:
		    printerror ("Internal Error: RE error %d, line %ld", rem, flScan.lin);

		case REM_MATCH:
		    fAgain = FALSE;
		    break;
            }
        } while (fAgain);

	c = colPhys (scanreal, REStart (patBuf));
	srchlen = RELength (patBuf, 0);
        if (c + srchlen - 1 > scanlen) {
            return FALSE;
        }
	flScan.col = c;
    } else {
        if ( (*(fSrchCasePrev ? strncmp : _strnicmp)) (srcbuf, p, srchlen)) {
            return FALSE;
        }
        if (flScan.col + srchlen - 1 > scanlen) {
            return FALSE;
        }
    }

    if (fQrpl) {
    ClearHiLite (pFileHead, TRUE);
    Display();
	cursorfl (flScan);
	HighLight (flScan.col, flScan.lin, flScan.col+srchlen-1, flScan.lin);
	Display ();
        c = askuser ('n', 'a', "Replace this occurrence? (Yes/No/All/Quit): ",
			  NULL);
	ClearHiLite (pFileHead, TRUE);
	redraw (pFileHead, flScan.lin, flScan.lin);
        RSETFLAG (fDisplay, RHIGH);

        switch (c) {

	case -1:
	case 'q':
	    fCtrlc = TRUE;
            return TRUE;

	case 'n':
            return FALSE;

	case 'a':
	    dispmsg(0); 		/* clear dialog line		*/
	    fQrpl = FALSE;
	    break;
        }
    }

    if (fRplRePrev) {
	patRpl ();
    } else {
        simpleRpl (p);
    }
    return FALSE;
}





/*** simpleRpl & patRpl - perform textual replacement
*
* Purpose:
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
simpleRpl (
    char *p
    )
{
    ReplaceEdit (p, rplbuf);
}





void
patRpl (
    void
    )
{
    buffer txt;

    RETranslate (patBuf, rplbuf, txt);
    ReplaceEdit (REStart (patBuf), txt);
}





/*** ReplaceEdit - perform replacement in a line of text
*
* Purpose:
*
* Input:
*  p		= pointer to beginning of match within scanreal
*  rpl		= text of replacement
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
ReplaceEdit (
    char *p,
    char *rpl
    )
{
    int c;                      /*  length of replacement string              */

    /*	if the len of line - len of search + len of replacement string < BUFLEN
     *	then we can make the replacement.  Otherwise we flag an error and
     *	advance to the next line
     */
    c = strlen (rpl);
    if (cbLog (scanreal) + c - srchlen < sizeof(linebuf)) {
	/*  open up a space in the buffer at the spot where the string was
	 *  found.  Move the characters starting at the END of the match to
	 *  the point after where the END of the replacement is.
	 */
	memmove ((char*) &p[c], (char *) &p[srchlen], sizeof(linebuf) - flScan.col - c);
	memmove ((char *) p, (char *) rpl, c);
        PutLine (flScan.lin, scanreal, pFileHead);

	/*  if search length != 0 or replace length != 0, skip over replacement */
        if (srchlen != 0 || c != 0) {
            flScan.col += c - 1;
        }

        //
        // Adjust scan len to account for the fact that the end of the region being
        // scanned may have moved as a result of the replacement. Adjust by the
        // replacement difference, and bound by 0 and the length of the line.
        //
	scanlen = max (0, min (scanlen + c - srchlen, cbLog(scanreal)));
	cRepl++;
    } else {
	printerror ("line %ld too long; replacement skipped", flScan.lin+1);
	flScan.col = scanlen;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\setfile.c ===
/*  setfile.c - top-level file management commands
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"


static char *NoAlternate = "no alternate file";


/*** setfile - editor command to change and save files
*
*  <setfile>			- set to previous file on instance list
*  <arg> text <setfile> 	- set to specified file
*  <arg> <setfile>		- set to file spacified at current cursor pos
*  <arg><arg> text <setfile>	- write current file to specified filename
*  <arg><arg> <setfile>		- write current file to disk
*  <meta> ...			- do not autosave current file on change
*
*   The following is undocumented:
*
*   <arg><arg> "text" <meta> <setfile> - Like <arg><arg><setfile>, but
*					 doesn't prompt for confirmation
*					 and switches to new file even
*					 for pseudo-files.
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
setfile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    linebuf name; /* name to set to.  'linebuf', so fInsSpace can take it   */
    pathbuf path;
    char    *p = name;

    switch (pArg->argType) {

    case NOARG:
        if (pInsCur->pNext == NULL) {
            domessage( NoAlternate );
            return FALSE;
        }
        name[0] = 0;
        break;

    case TEXTARG:
        if (pArg->arg.textarg.cArg > 1) {
	    CanonFilename (pArg->arg.textarg.pText, path);
            /* The fMeta thing is a definite hack */
            if (fMeta || confirm("Do you want to save this file as %s ?", path)) {
                if (FileWrite (path, pFileHead)) {
                    if (!TESTFLAG (FLAGS(pFileHead), FAKE) || fMeta) {
                        FREE (pFileHead->pName);
                        pFileHead->pName = ZMakeStr (path);
                        RSETFLAG (FLAGS(pFileHead), (DIRTY | FAKE | TEMP));
			}
                    SETFLAG (fDisplay, RSTATUS);
                    SetModTime( pFileHead );
                    return TRUE;
		    }
		else
                    return FALSE;
		}
	    else {
                DoCancel();
                return FALSE;
		}
	    }
	else
	    findpath (pArg->arg.textarg.pText, name, TRUE);
        break;

    case NULLARG:
	if (pArg->arg.nullarg.cArg > 1)
            return (flagType)!FileWrite (NULL, pFileHead);

        fInsSpace (pArg->arg.nullarg.x, pArg->arg.nullarg.y, 0, pFileHead, name);
        p = pLog(name,pArg->arg.nullarg.x,TRUE);

	//
	//  Check to see if this a C file and it is an #include line
	//

	if ((FTYPE (pFileHead) == CFILE && strpre ("#include ", p)) ||
	    (FTYPE (pFileHead) == ASMFILE && strpre ("include", p))) {

	    //
	    //	skip the include directive
	    //

	    p = whitescan (p);
	    p = whiteskip (p);
	    }

        /*
         * Terminate filename at first whitespace
         */
        *whitescan (p) = 0;

        /*
         * If file is C, attempt to strip off #include delimiters if present
         */
        if (FTYPE (pFileHead) == CFILE) {
	    if (*p == '"')
                *strbscan (++p, "\"") = 0;
	    else
	    if (*p == '<') {
                *strbscan (++p, ">") = 0;
		sprintf (path, "$INCLUDE:%s", p);
		CanonFilename (path, p = name);
		}
	    else
                *strbscan (p, "\">") = 0;
	    }
	else {
            /*
             * If file is ASM, attempt to remove comment chars if present
             */
	    if (FTYPE (pFileHead) == ASMFILE)
                * strbscan (p, ";") = 0;
	    }

        break;
	}

    if (!fMeta)
        AutoSave ();

    if (name[0] == 0) {
        strcpy (name, pInsCur->pNext->pFile->pName);
    }

    return fChangeFile (TRUE, p);

    argData;
}




/*** refresh - re-read or discard file
*
*  <refresh>		- re-read current file
*  <arg> <refresh>	- remove current file from memory
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
refresh (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    EVTargs e;

    switch (pArg->argType) {
    case NOARG:
	if (confirm("Do you want to reread this file? ", NULL)) {
            /*
             * Offer to the extensions as an event
             */
	    e.pfile = pFileHead;
	    DeclareEvent (EVT_REFRESH,(EVTargs *)&e);

            /*
             * if assigns, force re-read
             */
            if (!strcmp (pFileHead->pName, rgchAssign)) {
                fNewassign = TRUE;
            }

	    FileRead (pFileHead->pName, pFileHead, TRUE);
	    RSETFLAG (FLAGS (pFileHead), DIRTY);
	    SETFLAG (fDisplay, RSTATUS);
	    return TRUE;
        }
	return FALSE;

    case NULLARG:
	if (pInsCur->pNext == NULL) {
	    domessage( NoAlternate );
	    return FALSE;
        }
        if (!confirm ("Do you want to delete this file from the current window? ", NULL)) {
            return FALSE;
        }

	RemoveTop ();

	newscreen ();

	while (pInsCur != NULL) {
            if (fChangeFile (FALSE, pFileHead->pName)) {
                return TRUE;
            }
        }
	return fChangeFile (FALSE, rgchUntitled);
    }

    return FALSE;
    argData; fMeta;
}




/*** noedit - Toggle no-edit flags
*
* Purpose:
*
*   To give the user control over the edit/no-edit state of the editor and
*   its files.	The editor has two flags controlling this:
*
*	Global no-edit	 => When flag is set, no file may be edited.
*	Per-file no-edit => When set, the given file cannot be edited
*
*   This function can be invoked as follows:
*
*	  <noedit>  Toggles global no-edit state.  When set, has same
*		    effect as /r switch.
*
*   <meta><noedit>  Toggles the per-file no-edit state for current file.
*
* Output:  Returns new state.  TRUE means no editing, FALSE means editing
*	   is allowed
*
* Notes:
*
*   This does not allow the user to change permissions on pseudo files.
*
*************************************************************************/
flagType
noedit (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    SETFLAG (fDisplay, RSTATUS);

    if (!fMeta) {
        return fGlobalRO = (flagType)!fGlobalRO;
    }

    if (TESTFLAG (FLAGS(pFileHead), FAKE)) {
        return (flagType)(TESTFLAG(FLAGS(pFileHead), READONLY));
    }

    if (TESTFLAG (FLAGS(pFileHead), READONLY)) {
	RSETFLAG (FLAGS(pFileHead), READONLY);
	return FALSE;
    } else {
	SETFLAG (FLAGS(pFileHead), READONLY);
	return TRUE;
    }
    argData; pArg;
}





/*** saveall - Editor <saveall> function
*
* Purpose:
*   Saves all dirty files.
*
* Input:   The usual. Accepts only NOARG.
*
* Output:
*	   Returns always true.
*
*************************************************************************/
flagType
saveall (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    SaveAllFiles ();
    return TRUE;

    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\statfile.c ===
/*** statefile.c - Code for status/state file processing
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"



/*** ReadTMPFile - Read the editor .STS/.TMP status file
*
*  Load up the information from the project status file.
*
* Input:
*
* Output:
*
*************************************************************************/
flagType
    ReadTMPFile (
    )
{
    FILE    *fhTmp;                         /* .TMP file file handle        */

    PWND    pWin = NULL;

    int     x;                              /* x corrdinate read from file  */
    int     y;                              /* y corrdinate read from file  */

    char    *pName;
    char    *pData;
    PINS    pInsNew  = NULL;
    PINS    pInsHead = NULL;
    PFILE   pFileTmp;                       /* pFile being created          */
    PFILE  *ppFileList;

    ppFileList = &pFileHead;
    while (pFileTmp = *ppFileList) {
        ppFileList = &pFileTmp->pFileNext;
        }

    if ((fhTmp = pathopen (pNameTmp, buf, "rt")) != NULL) {

        /*
         * Read the header lines in the file. We ignore the first line (editor
         * version), make sure that the second line contains the expected .TMP file
         * version string, and the third line has two integers, which are the screen
         * dimensions.
         */
        if ((fgetl (buf, sizeof(buf), fhTmp) == 0)
            || (fgetl (buf, sizeof(buf), fhTmp) == 0)
            || strcmp(buf,TMPVER)
            || (fgetl (buf, sizeof(buf), fhTmp) == 0)
            || (sscanf (buf, "%d %d", &x, &y) != 2)) {
        } else {
            /*
             * For each line in the rest of the .TMP file, process
             */
            while (fgetl (buf, sizeof(buf), fhTmp) != 0) {
                // assert (_heapchk() == _HEAPOK);
                assert (_pfilechk());
                /*
                 * Process previous search & replace strings
                 */
                if (!_strnicmp ("SRCH:", buf, 5)) {
                    strcpy (srchbuf, buf+5);
                } else if (!_strnicmp ("DST:", buf, 4)) {
                    strcpy (rplbuf, buf+4);
                } else if (!_strnicmp ("SRC:", buf, 4)) {
                    strcpy (srcbuf, buf+4);
                } else if (!_strnicmp ("INS:", buf, 4)) {
                    fInsert = (flagType)!_strnicmp ("ON", buf+4, 2);
                } else {
                    switch (buf[0]) {

                        /*
                         * lines begining with ">" indicate a new window. On the rest of
                         * the line, the first two digits are the window screen position,
                         * and the next are the window size.
                         */
                        case '>':
                            pWin = &WinList[cWin++];
                            if (sscanf (buf+1, " %d %d %d %d ",
                                    &WINXPOS(pWin), &WINYPOS(pWin),
                                    &WINXSIZE(pWin), &WINYSIZE(pWin)));
                            pWin->pInstance = NULL;
                            break;

                        /*
                         * Lines begining with a space are instance descriptors of the files
                         * in the most recent window's instance list.
                         */
                        case ' ':
                            /*
                             * allocate new instance, and place at tail of list (list now
                             * created in correct order).
                             */
                            if (pInsNew) {
                                pInsNew->pNext = (PINS) ZEROMALLOC (sizeof (*pInsNew));
                                pInsNew = pInsNew->pNext;
                            } else {
                                pInsHead = pInsNew = (PINS) ZEROMALLOC (sizeof (*pInsNew));
                            }
#ifdef DEBUG
                            pInsNew->id = ID_INSTANCE;
#endif
                            /*
                             * isolate filename and parse out instance information
                             */
                            if (buf[1] == '\"') {
                                pName = buf + 2;
                                pData = strrchr(buf, '\"');
                                *pData++ = '\0';
                            } else {
                                ParseCmd (buf, &pName,&pData);
                            }

                            if (sscanf (pData, " %d %ld %d %ld "
                                         , &XWIN(pInsNew), &YWIN(pInsNew)
										 , &XCUR(pInsNew), &YCUR(pInsNew)));
							//
							//	If the cursor position falls outside of the current
							//	window, we patch it
							//
							if( XCUR(pInsNew) - XWIN(pInsNew) > XSIZE ) {

								XCUR(pInsNew) = XWIN(pInsNew) + XSIZE - 1;
							}

							if ( YCUR(pInsNew) - YWIN(pInsNew) > YSIZE ) {

								YCUR(pInsNew) = YWIN(pInsNew) + YSIZE - 1;
							}

							/*
							//
							//	If the window and cursor dimensions conflict with
							//	the current dimensions, we patch them.
							//
							if ((XWIN(pInsNew) > XSIZE) || (YWIN(pInsNew) > YSIZE)) {
								XWIN(pInsNew) = XSIZE;
								YWIN(pInsNew) = YSIZE;
							}

							//if ((XCUR(pInsNew) > XSIZE) || (YCUR(pInsNew) > YSIZE)) {
							//	XCUR(pInsNew) = 0;
							//	YCUR(pInsNew) = 0;
							//}
							*/

                            /*
                             * create file structure
                             */
                            pFileTmp = (PFILE) ZEROMALLOC (sizeof (*pFileTmp));
#ifdef DEBUG
                            pFileTmp->id = ID_PFILE;
#endif
                            pFileTmp->pName = ZMakeStr (pName);

			    pFileTmp->plr      = NULL;
			    pFileTmp->pbFile   = NULL;
                            pFileTmp->vaColor  = (PVOID)(-1L);
                            pFileTmp->vaHiLite = (PVOID)(-1L);
                            pFileTmp->vaUndoCur  = (PVOID)(-1L);
                            pFileTmp->vaUndoHead = (PVOID)(-1L);
                            pFileTmp->vaUndoTail = (PVOID)(-1L);

                            CreateUndoList (pFileTmp);

                            /*
                             * Place the file at the end of the pFile list
                             */
                            *ppFileList = pFileTmp;
                            ppFileList = &pFileTmp->pFileNext;
                            SetFileType (pFileTmp);
                            IncFileRef (pFileTmp);
                            pInsNew->pFile = pFileTmp;
                            break;

                        /*
                         * A blank line occurrs at the end of the file list for a window.
                         * We use this to advance to next window. If we *just* found more
                         * than one window, fix the screen mode to match the last value
                         */
                        case '.':
                        case '\0':
							if (cWin >	1 && !fVideoAdjust (x, y)) {
                                goto initonewin;
                            }
                            assert (pWin && cWin);
                            pWin->pInstance = pInsHead;
                            pInsHead = pInsNew = NULL;
                            break;
                    }
                }
            }
        }

        fclose (fhTmp);

        /*
         * At startup, current window is always first window
         */
        pWinCur = WinList;
    }

	if (cWin == 1) {
		WINXSIZE(pWinCur) = XSIZE;
        WINYSIZE(pWinCur) = YSIZE;
	} else if (cWin == 0) {
initonewin:
        /*
         * if no status file was read, ensure that we have at least one valid window,
         * the size of the screen
         */
        cWin = 1;
        pWinCur = WinList;
        pWinCur->pInstance = NULL;
        WINXSIZE(pWinCur) = XSIZE;
        WINYSIZE(pWinCur) = YSIZE;
    }

    assert(pWinCur);

    pInsCur = pWinCur->pInstance;

    /*
     * Get the file to edit from the command line, if any.
     * This will eventually set pInsCur.
     */
    if (!fFileAdvance() && fCtrlc) {
        CleanExit (1, CE_VM | CE_SIGNALS);
    }

    /*
     * Find windows with no instance: set current file to <untitled>
     */
    for (pWin = WinList; pWin < &WinList[cWin]; pWin++) {
        if (pWin->pInstance == NULL) {
            pInsHead = (PINS) ZEROMALLOC (sizeof (*pInsHead));
#ifdef DEBUG
            pInsHead->id = ID_INSTANCE;
#endif
            if (!(pInsHead->pFile = FileNameToHandle (rgchUntitled, rgchEmpty))) {
                pInsHead->pFile = AddFile ((char *)rgchUntitled);
            }
            IncFileRef (pInsHead->pFile);
            pWin->pInstance = pInsHead;
        }
    }

    /*
     * Set current instance if not already done by fFileAdvance
     */
    if (pInsCur == NULL) {
        pInsCur = pWinCur->pInstance;
    }

    assert (pInsCur);

    /*
     * If we cannot change to the current file, we will walk the window instance
     * list until we get a valid file. If no one can be loaded then we switch to
     * the <untitled> pseudo-file.
     * NB: fChangeFile does a RemoveTop so we don't need to move pInsCur
     */
    while ((pInsCur != NULL) && (!fChangeFile (FALSE, pInsCur->pFile->pName))) {
        ;
    }

    if (pInsCur == NULL) {
        fChangeFile (FALSE, rgchUntitled);
    }

    return TRUE;
}




/*** WriteTMPFile
*
* Purpose:
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
WriteTMPFile (
    void
    )
{
    FILE    *fh;
    int     i, j;
    PFILE   pFileTmp;
    PINS    pInsTmp;

    if ((fh = pathopen (pNameTmp, buf, "wt")) == NULL) {
        return;
    }
    fprintf (fh, "%s %s\n", Name, Version);
    fprintf (fh, TMPVER"\n");
    fprintf (fh, "%d %d\n", XSIZE, YSIZE);

    /*
y	  * we truncate the search, src and rpl buffers back 10 characters each from the
     * maximum before writing them out. This avoids more major hacks in the code
     * which reads these lines back in, which limit the total line length to
     * BUFLEN.
     */
    srchbuf[sizeof(srcbuf)-10] = 0;
    srcbuf[sizeof(srcbuf)-10] = 0;
    rplbuf[sizeof(rplbuf)-10] = 0;
    fprintf (fh, "SRCH:");
    fprintf (fh, "%s", srchbuf);
    fprintf (fh, "\nSRC:");
    fprintf (fh, "%s", srcbuf);
    fprintf (fh, "\nDST:");
    fprintf (fh, "%s", rplbuf);

    fprintf (fh, "\nINS:%s\n", (fInsert)?"ON":"OFF");
    for (i = 0; i < cWin; i++) {
	if ((pInsTmp = WinList[i].pInstance) != NULL) {
	    fprintf (fh, "> %d %d %d %d\n", WinList[i].Pos.col, WinList[i].Pos.lin,
		     WinList[i].Size.col, WinList[i].Size.lin);
	    j = 0;
	    while (pInsTmp != NULL) {
		if (tmpsav && tmpsav == j)
		    break;
		pFileTmp = pInsTmp->pFile;
		if (!TESTFLAG (FLAGS (pFileTmp), FAKE | TEMP)) {
		    j++;
		    if (*whitescan(pFileTmp->pName) == '\0') {
			fprintf (fh, " %s %d %ld %d %ld\n", pFileTmp->pName,
				 XWIN(pInsTmp), YWIN(pInsTmp),
				 XCUR(pInsTmp), YCUR(pInsTmp));
		    } else {
			fprintf (fh, " \"%s\" %d %ld %d %ld\n", pFileTmp->pName,
				 XWIN(pInsTmp), YWIN(pInsTmp),
				 XCUR(pInsTmp), YCUR(pInsTmp));
		    }
                }
		pInsTmp = pInsTmp->pNext;
            }
	    /* empty window */
            if (j == 0) {
                fprintf (fh, " %s 0 0 0 0\n", rgchUntitled);
            }
            fprintf (fh, ".\n");
        }
    }
    fclose (fh);
}


flagType
savetmpfile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
	argData; pArg; fMeta;

	WriteTMPFile();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\search.c ===
/*** search.c - search routines for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Searches funnel through these routines as follows:
*
*         psearch     msearch     searchall   mgrep
*              \         |         /           /
*               \        |        /           /
*                \_______|_______/           /
*                        |                  /
*                        v                 /
*                     dosearch            /
*                      /___\_____________/
*                     /     \
*                    /       \
*                search    REsearch   REsearchS   <=== all exported to extensions
*
*   Global variables, and their meanings:
*
*   User set-able switches:
*     fUnixRE         unixre: switch. TRUE => Use UNIX Regular Expressions
*     fSrchCaseSwit   case: switch.   TRUE => case is significant
*     fSrchWrapSwit   wrap: switch.   TRUE => searches wrap
*
*   Previous Search Parameters:
*     fSrchAllPrev    TRUE => searched for all occurrances
*     fSrchCasePrev   TRUE => case was significant
*     fSrchDirPrev    TRUE => searched forward
*     fSrchRePrev     TRUE => used a regular expressions
*     fSrchWrapPrev   TRUE => wrapped around
*
*     srchbuf         search string
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/

#include <string.h>
#include <stdarg.h>
#include "mep.h"


static  int cAll;                       /* count of ocurrances for all  */
static  int cGrepped;                   /* count of ocurrances for mgrep*/
static  struct patType *patBuf  = NULL; /* compiled pattern             */


/***************************************************************************\

MEMBER:     lsearch

SYNOPSIS:   strstr based on supplied lengths rather than strlen()

ALGORITHM:

ARGUMENTS:

RETURNS:

NOTES:      Supplied strings may not be zero terminated or may have embedded
            NULs
            This is a brute force algorithm which should be updated to
            something reasonable if performance is a problem

HISTORY:    14-Aug-90 davegi
                Created

KEYWORDS:

SEEALSO:

\***************************************************************************/
char*
lsearch (
    char*   pchSrc,
    ULONG   cbSrc,
    char*   pchSub,
    ULONG   cbSub
    )
{

    REGISTER ULONG      i;
    REGISTER ULONG      j;

    assert( pchSrc );
    assert( pchSub );

    //  If the sub-string is longer than the source string or,
    //  cbSrc > strlen( pchSrc) (hack for backwards search), return NULL

    if(( cbSub > cbSrc ) || ( cbSrc > strlen( pchSrc ) + 1)) {
        return NULL;
    }

    //  Short Circuit...
    //  If first character in pchSub does not exist in pchSrc

    if( ! memchr( pchSrc, *pchSub, cbSrc )) {
        return NULL;
    }

    i = j = 0;
    do {
        if( pchSrc[ i ] == pchSub[ j ] ) {
            i++;
            j++;
        } else {
            i = i - j + 1;
            j = 0;
        }
    } while(( j < cbSub ) && ( i < cbSrc ));
    return ( j >= cbSub ) ? &( pchSrc[ i - cbSub ]) : NULL;
}



static char szNullStr[] = "";


/*** mgrep - multiple file search
*
*  Using the internal editor search code, and optimizing for those files
*  already in memory, search for a string or regular expression.
*
*  Searches the file list specified by the greplist macro.
*
*   no arg:         search for previous search string
*   Single arg:     search for string.
*   Double arg:     search for regular expression.
*   meta:           toggle case from current switch setting
*
*  Files to be searched which are already in the file history are simply
*  searched. Files which are NOT in the file history, are read in, and if
*  no occurance of the search string is found, they are then discarded as
*  well.
*
* Input:
*  Standard editting function
*
* Globals:
*                   - grep file list
*  fSrchCaseSwit    - users 'case' switch
*  fSrchRePrev      - previous RE search flag
*  fUnixRE          - users 'unixre' switch
*  pasBuf           - compiled RE pattern
*  srchbuf          - last searched for string.
*
* Output:
*  Returns TRUE on found.
*
*************************************************************************/
flagType
mgrep (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    int     l;                              /* length of matched string     */
    PCMD    pcmdGrepList;                   /* pointer to grep list         */
    char    *szGrepFile;                    /* pointer to current grep file */

    assert (pArg);
    fSrchCasePrev = fSrchCaseSwit;          /* assume case switch to begin  */

    switch (pArg->argType) {

    /*
     * TEXTARG: use text as search string. If RE search, also compile the regular
     * expression into patBuf. (Fall into NOARG code).
     */
    case TEXTARG:
        strcpy ((char *) buf, pArg->arg.textarg.pText);
        srchbuf[0] = 0;
        if (pArg->arg.textarg.cArg == 2) {
            if (patBuf != NULL) {
                FREE((char *) patBuf);
            }
            patBuf = RECompile (buf, fSrchCaseSwit, (flagType)!fUnixRE);
            if (patBuf == NULL) {
                printerror ((RESize == -1) ? "Invalid pattern" : "Not enough memory for pattern");
                return FALSE;
            }
            fSrchRePrev = TRUE;
        } else {
            fSrchRePrev = FALSE;
        }
        strcpy (srchbuf, buf);


    /*
     * NOARG: use previous search string & parameters
     */
    case NOARG:
        if (srchbuf[0] == 0) {
            printerror ("No search string specified");
            return FALSE;
        }
        break;
    }

    /*
     * Ee must ensure that no background compile is underway. Then get a pfile
     * there.
     */
    if (fBusy(pBTDComp)) {
        printerror ("Cannot mgrep to <compile> during background compile");
        return FALSE;
    }

    if ((PFILECOMP = FileNameToHandle (rgchComp, rgchComp)) == NULL) {
        PFILECOMP = AddFile ((char *)rgchComp);
        FileRead ((char *)rgchComp, PFILECOMP, FALSE);
        SETFLAG (FLAGS (PFILECOMP), READONLY);
    }

    /*
     * Under OS/2, if it is clear that we will destroy the log file contents
     * we ask the user and empty the file if he says so.
     */
    if (PFILECOMP->cLines
        && (confirm ("Delete current contents of compile log ? ", NULL))
       ) {
        DelFile (PFILECOMP, FALSE);
    }


    BuildFence ("mgrep", rgchEmpty, buf);
    AppFile (buf, PFILECOMP);
    /*
     * When not in a macro, indicate on the dialog line what it is we are
     * searching for
     */
    if (!mtest ()) {
        l = sout (0, YSIZE, "mgrep for '", infColor);
        l = sout (l, YSIZE, srchbuf, fgColor);
        soutb (l, YSIZE, "'", infColor);
    }

    if (fMeta) {
        fSrchCasePrev = (flagType)!fSrchCasePrev;
    }
    cGrepped = 0;

    /*
     * Get the list handle, and initialize to start at the head of the list.
     * Attempt to process each list element. If starts with "$", use forsemi to
     * process each file or pattern in each directory listed in the environment
     * variable, else process the filename directly.
     */
    if (pcmdGrepList = GetListHandle ("mgreplist", TRUE)) {
        szGrepFile = ScanList (pcmdGrepList, TRUE);
        while (szGrepFile) {
            char    *pathstr;
            char    *tmp = NULL;

            if (*szGrepFile == '$') {
                char    *p;

                if (*(p=strbscan (szGrepFile, ":"))) {
                    *p = 0;

                    if ((tmp = getenvOem (szGrepFile+1)) == NULL) {
                        pathstr = szNullStr;
                    } else {
                        pathstr = tmp;
                    }

                    *p++ = ':';
                    szGrepFile = p;
                }
            } else {
                pathstr = szNullStr;
            }

            forsemi (pathstr, mgrep1env, szGrepFile);

            if( tmp != NULL ) {
                free( tmp );
            }

            szGrepFile = ScanList (NULL, TRUE);
            if (fCtrlc) {
                return FALSE;
            }
        }
    }
    if (cGrepped) {
        nextmsg (0, &NoArg, FALSE);
    }
    domessage ("%d occurrences found",cGrepped);
    return (flagType)(cGrepped != 0);

    argData;
}





/*** mgrep1env - perform grep on environment variable when found
*
*  Called when an environment variable is found in the mgrep list to
*  process all the files in that path. Called once per directory entry
*  in the list.
*
* Input:
*  pszEnv       = pointer to directory name
*  pFileName    = pointer to filename
*
* Output:
*  Returns nothing.
*
*************************************************************************/
flagType
mgrep1env (
    char *  pszEnv,
    va_list pa
    )
{
    char   *pszFn = (char *)va_arg( pa, char* );
    pathbuf bufFn;                          /* filename buffer              */

    if (fCtrlc) {
        return TRUE;
    }

    /*
     * construct full pathname in buffer.
     */
    {
        pathbuf bufBuild = {0};

        strncat (bufBuild, pszEnv, sizeof(bufBuild)-1);
        if (*pszEnv && (*(strend(bufBuild)-1) != '\\')) {
            *(int *) strend (bufBuild) = '\\';
        }
        strcat (bufBuild, pszFn);
        CanonFilename (bufBuild, bufFn);
    }

    forfile (bufFn, A_ALL, mgrep1file, NULL);

    return FALSE;
}




/*** mgrep1file - grep the contents of 1 file.
*
*  Searches through one file for stuff.
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
mgrep1file (
    char   *szGrepFile,
    struct findType *pfbuf,
    void * dummy
    )
{

    flagType fDiscard;                      /* discard the file read?       */
    fl       flGrep;                         /* ptr to current grep loc      */
    int      l;                              /* length of matched string     */
    PFILE    pFileGrep;                      /* file to be grepped           */

    assert (szGrepFile);

    if (fCtrlc) {
        return;
    }

    flGrep.lin = 0;
    flGrep.col = 0;

    /*
     * If we can get a handle to the file, then it's alread in the list, and we
     * should not discard it when done. If it is not in the list, we read it in,
     * but we'll discard it, unless something is found there.
     */
    if (!(pFileGrep = FileNameToHandle (szGrepFile, szGrepFile))) {
        pFileGrep = AddFile (szGrepFile);
        SETFLAG (FLAGS (pFileGrep), REFRESH);
        fDiscard = TRUE;
    } else {
        fDiscard = FALSE;
    }

    /*
     * If the file needs to be physically read, do so.
     */
    if ((FLAGS (pFileGrep) & (REFRESH | REAL)) != REAL) {
        FileRead (pFileGrep->pName, pFileGrep, FALSE);
        RSETFLAG (FLAGS(pFileGrep), REFRESH);
    }

    /*
     * Use either the normal searcher, or the regular expression searcher, based
     * on the use of regular expressions.
     */
    do {
        if (fSrchRePrev) {
            l = REsearch (pFileGrep,        /* file to search               */
                          TRUE,             /* direction: forward           */
                          FALSE,            /* not a searchall              */
                          fSrchCasePrev,    /* case                         */
                          FALSE,            /* wrap                         */
                          patBuf,           /* pattern                      */
                          &flGrep);         /* start/end location           */
        } else {
            l = search (pFileGrep,
                          TRUE,             /* direction: forward           */
                          FALSE,            /* not a searchall              */
                          fSrchCasePrev,    /* case                         */
                          FALSE,            /* wrap                         */
                          srchbuf,          /* pattern                      */
                          &flGrep);         /* start/end location           */
        }

        if (l >= 0) {
            /*
             * if the search was successfull, if adding to <compile>, do so, else
             * highlight the found search string and exit.
             */
            buffer  linebuf;

            fDiscard = FALSE;
            cGrepped++;
            GetLine (flGrep.lin, linebuf, pFileGrep);
            zprintf (  PFILECOMP
                     , PFILECOMP->cLines
                     , "%s %ld %d: %s"
                     , pFileGrep->pName
                     , ++flGrep.lin
                     , ++flGrep.col
                     , linebuf);
        } else {
            /*
             * If the search was not successfull, discard the file, if needed, and move
             * to the next.
             */
            if (fDiscard) {
                RemoveFile (pFileGrep);
            }
            if (UpdateIf (PFILECOMP, PFILECOMP->cLines, FALSE)) {
                Display ();
            }
            return;
        }
    } while (TRUE);

    pfbuf; dummy;
}




/*** psearch - plus search function
*
*  Search the current file forward for a string.
*
* Input:
*  Standard Editor Editing Function
*
* Output:
*  Returns TRUE on success (at least one string found).
*
*************************************************************************/
flagType
psearch (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return dosearch (TRUE, pArg, fMeta, FALSE);

    argData;
}




/*** msearch - minus search function
*
*  Search the current file backward for a string.
*
* Input:
*  Standard Editor Editing Function
*
* Output:
*  Returns TRUE on success (at least one string found).
*
*************************************************************************/
flagType
msearch (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return dosearch (FALSE, pArg, fMeta, FALSE);

    argData;
}




/*** searchall
*
*  Searches the entire current file for a string, and highlights all ocurrances
*
* Input:
*  Standard Editor Editing Function
*
* Output:
*  Returns TRUE on success (at least one string found).
*
*************************************************************************/
flagType
searchall (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return dosearch (TRUE, pArg, fMeta, TRUE);

    argData;
}




/*** dosearch - perform search operation
*
*  Single funnel for all file search operations.
*
*  NULLARG is converted into TEXTARG
*  LINEARG, STREAMARG, BOXARG are illegal
*
* Input:
*  fForard      = TRUE => Indicates that search is forward
*  pArg         = pointer to user specified args
*  fMeta        = TRUE => if meta on
*  fAll         = TRUE => highlight all ocurrances
*
* Output:
*  Returns TRUE if found
*
*************************************************************************/
flagType
dosearch (
    flagType fForward,
    ARG * pArg,
    flagType fMeta,
    flagType fAll
    )
{
    int     l;                              /* length of matched string     */
    fl      flCur;                          /* file loc before/after search */
    rn      rnCur;                          /* range to be highlighted      */

    assert (pArg);
    fSrchCasePrev = fSrchCaseSwit;          /* assume case switch to begin  */

    switch (pArg->argType) {

    /*
     * TEXTARG: use text as search string. If RE search, also compile the regular
     * expression into patBuf. (Fall into NOARG code).
     */
    case TEXTARG:
        strcpy ((char *) buf, pArg->arg.textarg.pText);
        srchbuf[0] = 0;
        if (pArg->arg.textarg.cArg == 2) {
            if (patBuf != NULL) {
                FREE((char *) patBuf);
            }
            patBuf = RECompile (buf, fSrchCaseSwit, (flagType)!fUnixRE);
            if (patBuf == NULL) {
                printerror ((RESize == -1) ? "Invalid pattern" : "Not enough memory for pattern");
                return FALSE;
            }
            fSrchRePrev = TRUE;
        } else {
            fSrchRePrev = FALSE;
        }

        fSrchWrapPrev = fSrchWrapSwit;
        strcpy (srchbuf, buf);

    /*
     * NOARG: use previous search string & parameters
     */
    case NOARG:
        if (srchbuf[0] == 0) {
            printerror ("No search string specified");
            return FALSE;
        }
        break;

    }

    /*
     * The case to be used is the use's case switch, or the opposite of that if
     * meta was specified. Save rest of globals as well.
     */
    fSrchAllPrev = fAll;
    if (fMeta) {
        fSrchCasePrev = (flagType)!fSrchCasePrev;
    }

    fSrchDirPrev = fForward;

    /*
     * When not in a macro, indicate on the dialog line what it is we are
     * searching for
     */
    if (!mtest ()) {
        char c;
        l = sout (0, YSIZE, fSrchDirPrev ? "+Search for '" : "-Search for '", infColor);
        c = srchbuf[ XSIZE - 14];
        srchbuf[ XSIZE-14] = '\0';
        l = sout (l, YSIZE, srchbuf, fgColor);
        srchbuf[ XSIZE-14] = c;
        soutb (l, YSIZE, "'", infColor);
    }

    /*
     * If this is a search for all occurrances, we begin the search from the
     * file begining. Otherwise, set the start position of the search to the
     * current cursor position.
     */
    if (fSrchAllPrev) {
        flCur.col = 0;
        flCur.lin = 0;
    } else {
        flCur.col = XCUR (pInsCur) + (fSrchDirPrev ? 1 : -1);
        flCur.lin = YCUR (pInsCur);
    }

    /*
     * Use either the normal searcher, or the regular expression searcher, based
     * on the use of regular expressions.
     */
    if (fSrchRePrev) {
        l = REsearch (pFileHead,
                      fSrchDirPrev,
                      fSrchAllPrev,
                      fSrchCasePrev,
                      fSrchWrapPrev,
                      patBuf,
                      &flCur);
    } else  {
        l = search (pFileHead,
                    fSrchDirPrev,
                    fSrchAllPrev,
                    fSrchCasePrev,
                    fSrchWrapPrev,
                    srchbuf,
                    &flCur);
    }

    /*
     * if the search was successfull, output the count of items founf for search
     * all, or highlight the found search string for a single ocurrance search
     */
    if (l >= 0) {
        if (fSrchAllPrev) {
            newscreen ();
            domessage ("%d occurrences found",cAll);
        } else {
            rnCur.flFirst = flCur;
            rnCur.flLast.col = flCur.col+l-1;
            rnCur.flLast.lin = flCur.lin;
            ClearHiLite( pFileHead, TRUE);
            SetHiLite (pFileHead,rnCur,HGCOLOR);
            Display();
        }
        cursorfl (flCur);
        return TRUE;
    }

    /*
     * If the search was not successfull, indicate as such.
     */
    if (!mtest ()) {
        srchbuf[XSIZE-12] = 0;
        domessage (fSrchDirPrev ? "+'%s' not found" : "-'%s' not found", srchbuf);
    }
    return FALSE;
}





/*** search - look for a string in a file
*
*  search will begin a scan of the file looking for a particular string in the
*  specified file beginning at the specified location. We perform simple
*  character string matching. We return the length and location of the match.
*
* Input:
*  pFile        = pointer to file structure to be searched
*  fForward     = TRUE => search forward from the specified location
*  fAll         = TRUE => find and highlight all ocurrances
*  fCase        = TRUE => case is significant in comparisons
*  fWrap        = TRUE => search wraps around ends of file
*  pat          = character pointer to the search string
*  pflStart     = pointers to the location of the beginning of search. Updated
*                 to reflect the actually found location (or the first found
*                 for a searchall).
*
* Output:
*  Returns      length of match if found, -1 if not found
*
*************************************************************************/
int
search (
    PFILE   pFile,
    flagType fForward,
    flagType fAll,
    flagType fCase,
    flagType fWrap,
    char    *pat,
    fl      *pflStart
    )
{
    int     cbPhys;                         /* physical length of line      */
    fl      flCur;                          /* current location in file     */
    LINE    yMac;
    linebuf sbuf;
    linebuf pbuf;
    int     lpat            = strlen (pat);
    int     l;
    char    *pFound;
    char    *pSearch;                       /* point at which to search     */
    rn      rnCur;                          /* range to be highlighted      */

    assert (pat && pflStart && pFile);
    strcpy (pbuf, pat);
    if (!fCase) {
        _strlwr (pbuf);
    }
    cAll = 0;
    flCur = *pflStart;

    if (fForward) {
        /*
         * forward search. Search every line up until the end of the file. (or up
         * until the original start position, if wrap was set). Check for CTRL+C
         * break, and get each lines text.
         */
        yMac = pFile->cLines;

        while (flCur.lin < yMac) {
            if (fCtrlc) {
                break;
            }
            cbPhys = GetLine (flCur.lin, sbuf, pFile);
            l = cbLog (sbuf);

            /*
             * search the buffer for the string of interest. Convert string to lower case
             * first if case insensitive search.
             */
            if (!fCase) {
                _strlwr (sbuf);
            }

            pSearch = pLog (sbuf,flCur.col,TRUE);
            if (colPhys (sbuf, pSearch) != flCur.col) {
                pSearch++;
            }

            while ((l > flCur.col)
                && (pFound = lsearch (pSearch, cbPhys - (ULONG)(pSearch-sbuf), pbuf, lpat))) {

                /*
                 * string found. Compute starting column of match. If not already found,
                 * update the caller's copy. For search-all, add the highlight, else for
                 * search once, return the length.
                 */
                flCur.col = colPhys (sbuf, pFound);
                if (!cAll) {
                    *pflStart = flCur;
                }
                cAll++;
                if (!fAll) {
                    return colPhys(sbuf, pFound+lpat) - colPhys(sbuf, pFound);
                }
                rnCur.flFirst = flCur;
                rnCur.flLast.lin = flCur.lin;
                rnCur.flLast.col = flCur.col+lpat-1;
                SetHiLite (pFile,rnCur,HGCOLOR);
                pSearch = pLog (sbuf,flCur.col,TRUE) + 1;
                flCur.col = colPhys (sbuf, pSearch);
            }
            noise (flCur.lin++);

            /*
             * if wrap around supported, then if we're at the end of the file, wrap around
             * to the begining.
             */
            if (fWrap && (flCur.lin >= pFile->cLines)) {
                yMac = pflStart->lin;
                flCur.lin = 0;
            }
            flCur.col = 0;
        }
    } else {
        /*
         * backwards search. Doesn't have to be concerned about searchall, since those
         * always occur forward. Otherwise, the same as above, only backwards.
         */
        assert (!fAll);
        yMac = 0;
        while (flCur.lin >= yMac) {
            if (fCtrlc) {
                break;
            }
            GetLine (flCur.lin, sbuf, pFile);
            l = cbLog (sbuf);

            /*
             * search the buffer for the string of interest. Convert string to lower
             * case first if case insensitive search. Terminate the buffer at the
             * starting column (this is a backwards search)
             */
            if (!fCase) {
                _strlwr (sbuf);
            }
            pSearch  = pLog (sbuf, flCur.col, TRUE);
            *(pSearch+1) = 0;
            cbPhys   = (int)(pSearch - sbuf);
            pSearch  = sbuf;

            /*
             * search the line forward once for any occurrance. Then if FOUND, search
             * repeatedly for the LAST occurrance in the text, and return the info on
             * that.
             */
            if (pFound = lsearch (pSearch, cbPhys - (ULONG)(pSearch-sbuf), pbuf, lpat)) {
                do {
                    pSearch = pFound;
                } while (pFound = lsearch (pSearch+1, cbPhys - (ULONG)(pSearch-sbuf) , pbuf, lpat));
                flCur.col = colPhys (sbuf, pSearch);
                *pflStart = flCur;
                return colPhys(sbuf, pLog (sbuf,flCur.col,TRUE) + lpat) - flCur.col;
            }
            noise (flCur.lin--);
            if (fWrap && (flCur.lin < 0)) {
                yMac = pflStart->lin;
                flCur.lin = pFile->cLines-1;
            }
            flCur.col = sizeof(linebuf)-1;
        }
    }

    /*
     * end of search. if a search for all, and found at least one, then return the
     * pattern length. Else, return -1.
     */
    if (fAll && cAll) {
        return lpat;
    }
    return -1;
}




/*** REsearch - look for a pattern in a file
*
*  REsearch will begin a scan of the file looking for a particular pattern
*  in the specified file beginning at the specified location. We perform
*  regular expression matching. We return the length and location of the
*  match.
*
* Input:
*  pFile        = pointer to file structure to be searched
*  fForward     = TRUE => search forward from the specified location
*  fAll         = TRUE => find and highlight all ocurrances
*  fCase        = TRUE => case is significant in comparisons
*  fWrap        = TRUE => search wraps around ends of file
*  pat          = pointer to compiled pattern
*  pflStart     = pointers to the location of the beginning of search. Updated
*                 to reflect the actually found location (or the first found
*                 for a searchall).
*
* Output:
*  Returns length of (first) match if found, -1 if not found
*
*************************************************************************/
int
REsearch (
    PFILE    pFile,
    flagType fForward,
    flagType fAll,
    flagType fCase,
    flagType fWrap,
    struct patType *pat,
    fl       *pflStart
    )
{
    fl      flCur;
    int     l, rem;
    rn      rnCur;                          /* area to be highlighted       */
    linebuf sbuf;
    LINE    yMac;
    unsigned MaxREStack = 512;
    RE_OPCODE **REStack = (RE_OPCODE **)ZEROMALLOC (MaxREStack * sizeof(*REStack));
    flagType fAgain;

    assert (pat && pflStart && pFile);
    cAll = 0;
    flCur = *pflStart;

    if (fForward) {
        /*
         * forward search. Search every line up until the end of the file. (or up
         * until the original start position, if wrap was set). Check for CTRL+C
         * break, and get each lines text.
         */
        yMac = pFile->cLines;
        while (flCur.lin < yMac) {
            if (fCtrlc) {
                break;
            }
            if (GetLine (flCur.lin, sbuf, pFile) >= flCur.col) {
                fAgain = TRUE;
                do {
                    switch (rem = REMatch (pat, sbuf, pLog (sbuf, flCur.col, TRUE), REStack, MaxREStack, TRUE)) {

                        case REM_MATCH:
                            //
                            // update rnCur to reflect the logical coordinates of the string actually
                            // found.
                            // when real tabs are on, REStart returns the physical character position of
                            // the found string, which still needs to be mapped to the logical columns.
                            //
                            rnCur.flFirst.lin = rnCur.flLast.lin = flCur.lin;
                            rnCur.flFirst.col = colPhys (sbuf, REStart ((struct patType *) patBuf));
                            rnCur.flLast.col  = colPhys (sbuf, REStart ((struct patType *) patBuf) + RELength (pat, 0)) - 1;

                            //
                            // If not already found, update the caller's copy. For search-all, add the
                            // highlight, else for search once, return the length.
                            //
                            if (!cAll++) {
                                *pflStart = rnCur.flFirst;
                            }
                            if (fAll) {
                                SetHiLite (pFile,rnCur,HGCOLOR);
                            } else {
                                FREE (REStack);
                                return rnCur.flLast.col - rnCur.flFirst.col + 1;
                            }
                            flCur.col = rnCur.flFirst.col + 1;
                            break;

                        case REM_STKOVR:
                            //
                            //  The RE machine stack overflowed.  Increase and try again
                            //
                            MaxREStack += 128;
                            REStack = (RE_OPCODE **)ZEROREALLOC((PVOID)REStack, MaxREStack * sizeof (*REStack));
                            break;

                        //
                        //  Either REM_INVALID (we passed in bad parameters), or REM_UNDEF (undefined
                        //  opcode in pattern.  Either way, it's an internal error
                        //
                        default:
                            printerror ("Internal Error: RE error %d, line %ld", rem, flCur.lin);

                        case REM_NOMATCH:
                            fAgain = FALSE;
                            break;

                    }
                } while (fAgain);
            }
            noise (flCur.lin++);

            /*
             * if wrap around supported, then if we're at the end of the file, wrap around
             * to the begining.
             */
            if (fWrap && (flCur.lin >= pFile->cLines)) {
                yMac = pflStart->lin;
                flCur.lin = 0;
            }
            flCur.col = 0;
        }
    } else {
        /*
         * backwards search. Doesn't have to be concerned about searchall, since those
         * always occur forward. Otherwise, the same as above, only backwards.
         */
        assert (!fAll);
        if (flCur.col < 0) {
            flCur.lin--;
        }
        yMac = 0;
        while (flCur.lin >= yMac) {
            if (fCtrlc) {
                break;
            }
            l = GetLine (flCur.lin, sbuf, pFile);
            if (flCur.col < 0) {
                flCur.col = l;
            }
            fAgain = TRUE;
            do {
                switch (rem = REMatch (pat, sbuf, pLog (sbuf, flCur.col, TRUE), REStack, MaxREStack, FALSE)) {
                    case REM_MATCH:
                        pflStart->col = colPhys (sbuf, REStart ((struct patType *) patBuf));
                        pflStart->lin = flCur.lin;
                        FREE (REStack);
                        return   colPhys (sbuf, REStart ((struct patType *) patBuf) + RELength (pat, 0))
                               - colPhys (sbuf, REStart ((struct patType *) patBuf));

                    case REM_STKOVR:
                        MaxREStack += 128;
                        REStack = (RE_OPCODE **)ZEROREALLOC ((PVOID)REStack, MaxREStack * sizeof(*REStack));
                        break;

                    default:
                        printerror ("Internal Error: RE error %d, line %ld", rem, flCur.lin);

                    case REM_NOMATCH:
                        fAgain = FALSE;
                        break;
                }
            } while (fAgain);

            flCur.col = -1;
            noise (flCur.lin--);
            if (fWrap && (flCur.lin < 0)) {
                yMac = pflStart->lin;
                flCur.lin = pFile->cLines-1;
            }
        }
    }

    FREE (REStack);

    /*
     * end of search. if a search for all, and found at least one, then return the
     * pattern length. Else, return -1.
     */
    if (fAll && cAll) {
        return RELength (pat, 0);
    }
    return -1;

    fCase;
}




/*** REsearchS - look for a pattern in a file
*
*  REsearchS will begin a scan of the file looking for a particular pattern
*  in the specified file beginning at the specified location. We perform
*  regular expression matching. We return the length and location of the
*  match.
*
*  REsearchS is the same as REsearch, except that is takes an uncompiled
*  string.
*
* Input:
*  pFile        = pointer to file structure to be searched
*  fForward     = TRUE => search forward from the specified location
*  fAll         = TRUE => find and highlight all ocurrances
*  fCase        = TRUE => case is significant in comparisons
*  fWrap        = TRUE => search wraps around ends of file
*  pat          = pointer to RE character string
*  pflStart     = pointers to the location of the beginning of search. Updated
*                 to reflect the actually found location (or the first found
*                 for a searchall).
*
* Output:
*  Returns length of (first) match if found, -1 if not found
*
*************************************************************************/
int
REsearchS (
    PFILE   pFile,
    flagType fForward,
    flagType fAll,
    flagType fCase,
    flagType fWrap,
    char    *pat,
    fl      *pflStart
    )
{
    assert (pat && pflStart && pFile);
    if (patBuf != NULL) {
        FREE ((char *) patBuf);
    }
    patBuf = RECompile (pat, fCase, (flagType)!fUnixRE);
    if (patBuf == NULL) {
        printerror ( (RESize == -1) ? "Invalid pattern" : "Not enough memory for pattern");
        return -1;
    }
    return REsearch (pFile, fForward, fAll, fCase, fWrap, patBuf, pflStart);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\textline.c ===
/*** textline.c - basic line manipulators for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Edit-level to file-level interface.
*
*   The internal representation of a file is that of an array of line records
*   with each line record containing a pointer to the text of the line and a
*   length of that line. The line array is pointed to by the plr field of
*   the file descriptor. The lSize field is the MAXIMUM number of lines that
*   the line array can hold and the cLines is the number of lines actually
*   present. Here are some assumptions:
*
*    plr = NULL => no line array allocated
*    lineRec.vaLine = -1L => 0-length line
*
*   Tabs: functions and characters.
*
*   The tab function is a cursor movement command, and responds to the
*   "tabstops" editor switch. It has NO RELATIONSHIP to physical tab
*   characters, and how tab characters are treated or placed in the text file.
*
*   Tab characters, their interpretation and placement in editted text, is
*   controlled by three switchs:
*
*     Switch	  Editor Var	  Meaning
*     ----------- --------------- -------
*     filetab:
*     entab:
*     realtabs:   fRealTabs	  TRUE	=>  Tab  characters are NOT treated as
*				  runs	of  spaces for editting purposes. They
*				  are	defined   as   having  variable  (1-8)
*				  multi-column width.
*				  FALSE => Tabs characters in text are treated
*				  as runs of spaces.
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip near/far
*************************************************************************/
#include "mep.h"
#include <stdarg.h>

#define DELTA 400

//
//	BugBug Compiler asserts generating intrinsic code for memset
//
#pragma function( memset )

/*** LineLength - returns length of a specific line
*
* Input:
*  line 	= 0-based line number in file
*  pFile	= pointer to file
*
* Output:
*  Returns the logical number of characters, after tab expansion
*
*************************************************************************/
int
LineLength (
    LINE    line,
    PFILE   pFile
    )
{
    linebuf tmpbuf;

    return GetLineUntabed (line, tmpbuf, pFile);
}




/*** GetLine - gets a line into a particular buffer.
*
* If "fReal-Tabs" is NOT set, the line has all tabs expanded into spaces.
* No CR/LF is present.
*
* Input:
*  line 	= 0-based line number in file to return.  Lines beyond EOF
*		  are simply empty.
*  buf		= destination of line.
*  pFile	= pointer to the file structure from which the line is to be
*		  retrieved.
*
* Output:
*  Returns the number of characters in the line.
*
*************************************************************************/
int
GetLine (
    LINE    line,
    char    *buf,
    PFILE   pFile
    )
{
    return gettextline (fRealTabs, line, buf, pFile, ' ');
}





/*** GetLineUntabed - gets a line into a particular buffer, always untabed.
*
* The line has all tabs expanded into spaces.
* No CR/LF is present.
*
* Input:
*  line 	= 0-based line number in file to return.  Lines beyond EOF
*		  are simply empty.
*  buf		= destination of line.
*  pFile	= pointer to the file structure from which the line is to be
*		  retrieved.
*
* Output:
*  Returns the number of characters in the line.
*
*************************************************************************/
int
GetLineUntabed (
    LINE    line,
    char    *buf,
    PFILE   pFile
    )
{
    return gettextline (FALSE, line, buf, pFile, ' ');
}





/****************************************************************************
 *									    *
 *  GetColor (line, buf, pFile) 					    *
 *									    *
 *	line - 0-based line number in file to get color info for.	    *
 *	buf  - Place to put copy of line color info.			    *
 *	pFile- File to retrieve info from.				    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	TRUE if there is color attached to this line, FALSE otherwise.	    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Gets the color array associated with given line in the given file.  *
 *	The color array can be used by the cout routines to display the     *
 *	line in different colors.					    *
 *									    *
 ****************************************************************************/
flagType
GetColor (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    return (flagType)getcolorline (fRealTabs, line, buf, pFile);
}




/*** GetColorUntabbed - Get color with "untabbing"
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
GetColorUntabbed (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    return (flagType)getcolorline (FALSE, line, buf, pFile);
}



/*** getcolorline
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
int
getcolorline (
    flagType fRaw,
    LINE     line,
    struct   lineAttr * buf,
    PFILE    pFile
    )
{
    struct colorRecType *vColor;
    linebuf lbuf;

    //
    // Set default colors, in case there is no color for this line.
    //
    buf->len = 0xff;
    buf->attr = FGCOLOR;

    if ((pFile->vaColor == (PVOID)(-1L)) || (line >= pFile->cLines)) {
        return FALSE;
    }

    vColor = VACOLOR(line);

    if (vColor->vaColors == (PVOID)(-1L)) {
        return FALSE;
    }

    memmove((char *)buf, vColor->vaColors, vColor->cbColors);

    if (!fRaw) {
        if (gettextline (TRUE, line, lbuf, pFile, ' ')) {
            ColorToLog (buf, lbuf);
        }
    }

    return TRUE;
}






/****************************************************************************
 *									    *
 *  PutColor (line, buf, pFile) 					    *
 *									    *
 *	line - 0-based line number in file to attach color to.		    *
 *	buf  - Color array.						    *
 *	pFile- File to attach to.					    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Copies the contents of buf into VM space and attaches it to the     *
 *	given line.  If no colorRecType array exists, one is allocated.     *
 *	If color for the given line already exists, it is discarded.	    *
 *									    *
 ****************************************************************************/
void
PutColor (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    putcolorline (FALSE, line, buf, pFile);
}





/*** PutColorPhys
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
PutColorPhys (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    putcolorline (TRUE, line, buf, pFile);
}




/*** putcolorline
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
putcolorline (
    flagType fRaw,
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
	struct colorRecType vColor;
	struct colorRecType *Color;
    int     cbBuf;
    long    l;
    PBYTE    vaColor;

    //
    // Ignore color for lines which don't exist.
    //
    if (line >= pFile->cLines) {
        return;
    }

    //
    // Make sure we have a color array. If it doesn't exist, allocate one for the
    // number of lines we have so far. Initialize the entries therein to no color.
    //
    redraw (pFile, line, line);
    if (pFile->vaColor == (PVOID)(-1L)) {
        pFile->vaColor  = MALLOC (pFile->lSize * sizeof(vColor));
        if ( !pFile->vaColor ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
        vColor.vaColors = (PVOID)(-1L);
	vColor.cbColors = 0;
        vaColor = (PBYTE)pFile->vaColor;
	for (l=0; l<pFile->lSize; l++) {
            memmove(vaColor, (char *)&vColor, sizeof(vColor));
	    vaColor += sizeof (vColor);
        }
    }

    //
    // Now throw away the current color info for the line in question, allocate
    // new VM for the new information, then place the color info into VM, and
    // update the VA info in the color array.
	//
	Color = VACOLOR(line);
	if (Color->vaColors != (PVOID)(-1L)) {
		FREE (Color->vaColors);
    }
    if (!fRaw) {
        ColorToPhys (buf, line, pFile);
    }
    cbBuf = fcolcpy (NULL, (struct lineAttr *)buf) << 2;
    Color->vaColors = MALLOC ((long)cbBuf);
    if ( !Color->vaColors ) {
        disperr(MSGERR_NOMEM);
        disperr(MSGERR_QUIT);
        CleanExit(4,FALSE);
    }
	Color->cbColors = cbBuf;
	memmove(Color->vaColors,	(char *)buf, cbBuf);
}





/*** DelColor - Remove color from a line
*
* Purpose:
*
*   To free the color attached to a file line.
*
* Input:
*   line -  Line to free
*   pFile-  File with the color
*
* Output: None
*
*************************************************************************/
void
DelColor (
    LINE line,
    PFILE pFile
    )
{
    struct colorRecType *vColor;

    if (pFile->vaColor != (PVOID)-1L) {

        vColor = VACOLOR(line);
        if (vColor->vaColors != (PVOID)-1L) {
            FREE(vColor->vaColors);
            vColor->vaColors = (PVOID)-1L;
	}
    }
}





/*** gettextline - gets a line into a particular buffer.
*
* Input:
*  fRaw 	= TRUE => the line is returned unmodified, otherwise tabs are
*		  expanded according to fileTab.
*  line 	= 0-based line number in file to return.  Lines beyond EOF
*		  are simply empty.
*  buf		= destination of line.
*  pFile	= pointer to the file structure from which the line is to be
*		  retrieved.
*  bTab 	= character used for tab expansion
*
* Output:
*  Returns the number of characters in the line.
*
*************************************************************************/
int
gettextline (
    flagType fRaw,
    LINE    line,
    char    *buf,
    PFILE   pFile,
    char    bTab
    )
{
    LINEREC *vLine;
    linebuf getbuf;
    REGISTER char *p = fRaw ? buf : getbuf;
    int     cbLine;

    if (pFile->cLines <= line) {
        return buf[0] = 0;
    }

    /*
     * get line record
     */
    vLine = VALINE(line);

    if (vLine->vaLine == (PVOID)(-1L)) {
        return buf[0] = 0;
    }

    cbLine = min (sizeof(linebuf)-1, vLine->cbLine);

    /*
     * get line
	 */
	// BUGBUG remove
	// memmove(p, vLine->vaLine == (PVOID)-1 ? (PVOID)(-(ULONG)vLine->vaLine) : vLine->vaLine, cbLine);

	memmove(p, vLine->vaLine, cbLine );
	p[cbLine] = 0;

    if (!fRaw) {
		return Untab (fileTab, p, strlen(p), buf, bTab);
    } else {
        return cbLine;
    }
}



/*  PutLine - put a buffer into the  file.  No CR/LF is present in the input
 *  line.  Grow the file if need be.
 *
 *  line	0-based line number in file to replace.  Growth of the file
 *		inserts blank lines.
 *  buf 	source of line.
 *  pFile	pointer to the file structure into which the line is to be
 *		place.
 */
void
PutLine (
    LINE line,
    char *buf,
    REGISTER PFILE pFile
    )
{
    puttextline (FALSE, TRUE, line, buf, pFile);
}




/*** InsertLine - insert a buffer into the  file.
*
*  Like PutLine, except inserts the line immediately prior to the specified
*  line. Grows the file.
*
* Input:
*  line 	= 0-based line number in file to insert before.
*  buf		= source of line.
*  pFile	= pointer to the file structure into which the line is to be
*		  placed.
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
InsertLine (
    LINE    line,
    char    *buf,
    REGISTER PFILE pFile
    )
{
    InsLine (TRUE, line, 1L, pFile);
    puttextline (FALSE, TRUE, line, buf, pFile);
}




/*** zprintf - insert formatted text into file being editted
*
*  Like fprintf, except that it inserts it's output into a file being
*  editted. "\n"'s in the text cause a line break, and insert multiple
*  lines. Examples:
*
*	zprintf (pFile, line, "this is a number %d", num);
*
*  Inserts a new line in front of line number "line" with the new text.
*
*	zprintf (pFile, line, "this is \na number %d\n", num);
*
*  Inserts three lines: one containing "this is", the next containing "a
*  number", and the last blank.
*
* Input:
*  pFile	= target file
*  lFirst	= starting line number
*  fmt		= formatting string
*  ...		= args as per string
*
* Output:
*  Returns the line number of the last line written + 1.
*
*************************************************************************/
LINE
__cdecl
zprintf (
    PFILE   pFile,
    LINE    lFirst,
    char const *fmt,
    ...
    )
{
    linebuf  fbuf;                           /* buffer into which to format  */
    REGISTER char *pEnd;                    /* pointer into it              */
    REGISTER char *pStart;                  /* pointer to begining of line  */
    va_list  Arguments;

    /*
     * Start by getting the formatted text
     */
    va_start(Arguments, fmt);
    ZFormat (fbuf, fmt, Arguments);

    /*
     * for each substring in the file, insert the text
     */
    pStart = fbuf;
    do {
        if (pEnd = strchr(fbuf,'\n')) {
            *pEnd = 0;
        }
        InsertLine (lFirst++, pStart, pFile);
        pStart = pEnd+1;
    } while (pEnd);
    va_end(Arguments);
    return lFirst;
}





/*  puttextline - put a buffer into the  file.	No CR/LF is present in the input
 *  line.  Grow the file if need be.  Convert to tabbed representation based on
 *  flag
 *
 *  fRaw	TRUE => line is placed into memory unmodified, otherwise
 *		trailing spaces are eliminated (fTrailSpace) and spaces are
 *		converted to tabs.
 *  fLog	TRUE => make this action undo-able.
 *  line	0-based line number in file to replace.  Growth of the file
 *		inserts blank lines.
 *  buf 	source of line.
 *  pFile	pointer to the file structure into which the line is to be
 *		place.
 */
void
puttextline (
    flagType fRaw,
    flagType fLog,
    LINE line,
    char *buf,
    REGISTER PFILE pFile
    )
{
    static struct lineAttr rgla[sizeof(linebuf)];
    LINEREC *vLine;
    struct colorRecType vColor;
    int newLen;
    flagType fColor;
    linebuf putbuf;
    PVOID  va;

    redraw (pFile, line, line);
	makedirty (pFile);

    if (pFile->cLines <= line) {
		growline (line+1, pFile);
		pFile->cLines = line+1;
		SETFLAG (fDisplay, RSTATUS);
    } else {
        if (pFile == pInsCur->pFile) {
            AckReplace (line, FALSE);
        }
    }

    /* get line record */
    vLine = VALINE(line);

    newLen = strlen (buf);

    if (!fRaw) {
        if (!fTrailSpace && pFile == pFileHead) {
            newLen = RemoveTrailSpace (buf);
        }
        if (fRealTabs) {
            fColor = (flagType)getcolorline (FALSE, line, rgla, pFile);
        }

        switch (EnTab) {

		case 0:
            break;

		case 1:
			newLen = TabMin (fileTab, buf, putbuf);
			buf = putbuf;
            break;

		case 2:
			newLen = TabMax (fileTab, buf, putbuf);
			buf = putbuf;
            break;

		default:
			break;
        }
    }

    /*	We now have the real text that we'd like to replace in the file.
     *	If logging is requested then
     *	    we log this replacement action
     *	else
     *	    free the current line
     *	allocate a new line
     *	copy the line into the allocated line
     *	set the length
     *	replace line record
     */

    if (fLog) {
        if (pFile->vaColor != (PVOID)(-1)) {
            memmove((char *)&vColor, VACOLOR(line), sizeof(vColor));
            if (vColor.vaColors != (PVOID)(-1L)) {
                va = MALLOC ((long)vColor.cbColors);
                if ( !va ) {
                    disperr(MSGERR_NOMEM);
                    disperr(MSGERR_QUIT);
                    CleanExit(4,FALSE);
                }
                memmove(va, vColor.vaColors, (long)vColor.cbColors);
				vColor.vaColors = va;
            }
        } else {
            vColor.vaColors = (PVOID)(-1L);
			vColor.cbColors = 0;
        }

        LogReplace (pFile, line, vLine, &vColor);
	} else if (vLine->Malloced) {
		vLine->Malloced = FALSE;
        FREE (vLine->vaLine);
    }

    if (newLen == 0) {
        vLine->vaLine   = (PVOID)(-1L);
        vLine->Malloced = FALSE;
    } else {
        vLine->vaLine   = MALLOC((long) newLen);
        if ( !vLine->vaLine ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
        vLine->Malloced = TRUE;
	vLine->cbLine	= newLen;

	memmove(vLine->vaLine, buf, newLen);

    }
    if (fRealTabs && !fRaw && fColor) {
        PutColor (line, rgla, pFile);
    }
}





/*  FileLength - return the number of lines in a file
 *
 *  pFile	handle of file
 *
 *  returns	number of lines in file
 */
LINE
FileLength (
    PFILE pFile
    )
{
    return pFile->cLines;
}





/*  BlankLines - blank a series of line records in a file's line structure.
 *  We can be either gross (fill in one at a time) or be reasonable (fill in
 *  fixed size blocks at a time, or be smart (fill a block then copy
 *  exponentially large blocks).  We are smart.
 *
 *  n		number of line records to blank
 *  va		virtual address of first line to blank
 */
void
BlankLines (
    LINE    n,
    PVOID   va
    )
{

    LINEREC vLine;
    long    copylen = (long) sizeof (vLine);
    PBYTE   dst     = (PBYTE)va;
    long    amtleft = (long) sizeof (vLine) * n;
    long    amtdone = 0L;

    vLine.vaLine    = (PVOID)(-1L);
    vLine.Malloced  = FALSE;
    vLine.cbLine    = -1;

    while (amtleft != 0L) {
        if (amtdone == 0L) {
            // Copy first blank line
            memmove(dst, (char *)&vLine, (int) copylen);
        } else {
            // Copy bunch
	    copylen = amtleft < amtdone ? amtleft : amtdone;
            memmove(dst, va, copylen);
        }
        dst     += copylen;
	amtleft -= copylen;
	amtdone += copylen;
    }
}



/*  BlankColor - blank a series of color records in a file's line structure.
 *  We can be either gross (fill in one at a time) or be reasonable (fill in
 *  fixed size blocks at a time, or be smart (fill a block then copy
 *  exponentially large blocks).  We are smart.
 *
 *  n		number of color records to blank
 *  va		virtual address of first color to blank
 */
void
BlankColor (
    LINE    n,
    PVOID    va
    )
{
    struct colorRecType vColor;
    long    copylen = (long) sizeof (vColor);
    PBYTE   dst     = (PBYTE)va;
    long    amtleft = (long) sizeof (vColor) * n;
    long    amtdone = 0L;

    vColor.vaColors = (PVOID)(-1L);
    vColor.cbColors = -1;
    while (amtleft != 0L) {
        if (amtdone == 0L) {
            // Copy one
            memmove(dst, (char *)&vColor, (int) copylen);
        } else {
            copylen = amtleft < amtdone ? amtleft : amtdone;
            // Copy a bunch
            memmove(dst, va, copylen);
        }
        dst     += copylen;
	amtleft -= copylen;
	amtdone += copylen;
    }
}





/* growLine - make a structure n lines long */
void
growline (
    REGISTER LINE line,
    REGISTER PFILE pFile
    )
{
    long    tmp1;
    LINE    lSize;
    PBYTE   vaTmp;
    struct colorRecType vColor;

    //
    // IF the file has a color array, and if the requested growth is greater than
    // the number of lines in the file, copy over the existing color array to
    // larger VM, release the previous array, and initialize the "new" entries in
    // that array.
    //
    if ((pFile->vaColor != (PVOID)(-1L)) && (pFile->lSize < line)) {
	tmp1 = (lSize = line + DELTA) * (long) sizeof(vColor);
        vaTmp = (PBYTE)MALLOC (tmp1);
        if ( !vaTmp ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
        memmove(vaTmp, pFile->vaColor, pFile->cLines * sizeof(vColor));
        FREE (pFile->vaColor);
        pFile->vaColor  = (PVOID)vaTmp;
        vColor.vaColors = (PVOID)(-1L);
	vColor.cbColors = 0;
        vaTmp +=  pFile->cLines * sizeof(vColor);
	for (lSize = pFile->cLines; lSize < line+DELTA;  lSize++) {
            memmove(vaTmp, (char *)&vColor, sizeof(vColor));
	    vaTmp += sizeof(vColor);
        }
    }

    //
    // If there are no lines, or not enough lines allocated for, allocate a new
    // line buffer which is larger than the request by DELTA lines (allows us to
    // avoid this operation for every added line). If there were line records,
    // move them into this new buffer, and free the old one. Blank out the added
    // records.
    //
    if ((pFile->plr == NULL) || (pFile->lSize < line)) {
	tmp1 = (lSize = line + DELTA) * (long) sizeof (LINEREC);
        vaTmp = (PBYTE)MALLOC (tmp1);
        if ( !vaTmp ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
	if (pFile->plr != NULL) {
	    memmove(vaTmp, pFile->plr,
		    ((long)pFile->cLines) * sizeof (LINEREC));
	    FREE (pFile->plr);
        }
        pFile->lSize   = lSize;
	pFile->plr = (LINEREC *)vaTmp;
	BlankLines (lSize - pFile->cLines, VALINE(pFile->cLines));
        if (pFile->vaColor != (PVOID)(-1L)) {
            BlankColor (lSize - pFile->cLines, VACOLOR(pFile->cLines));
        }
    }
}




/*  DelLine - delete n lines from the file, starting at line n.  Shrink what-
 *  ever structures are necessary.
 *
 *  The line range yStart-yEnd is deleted inclusively.
 *
 *
 *  pFile	file structure from which lines are deleted
 *  yStart	beginning 0-based line number to be deleted
 *  yEnd	ending line to be deleted
 */
void
DelLine (
    flagType fLog,
    PFILE pFile,
    LINE yStart,
    LINE yEnd
    )
{
    if (yStart >= pFile->cLines || yStart > yEnd) {
        return;
    }

    redraw (pFile, yStart, pFile->cLines);
    makedirty (pFile);

    yEnd = lmin (yEnd, pFile->cLines-1);

    /*	if logging this delete operation is requested then
     *	    Log the delete range
     *	else
     *	    free up the data being deleted
     */
    if (fLog) {
        LogDelete (pFile, yStart, yEnd);
    }

    /*	block transfer the remainder of the file down
     */
    memmove(VALINE(yStart), VALINE(yEnd+1),
	    ((long)(pFile->cLines-yEnd-1))*sizeof(LINEREC));

    /* Do the same for the color.
    */
    if (pFile->vaColor != (PVOID)(-1L)) {
        memmove(VACOLOR(yStart), VACOLOR(yEnd+1),
                ((long)(pFile->cLines-yEnd-1))*sizeof(struct colorRecType));
    }

    /*	remove lines from count
     */
    pFile->cLines -= yEnd - yStart + 1;
    SETFLAG (fDisplay, RSTATUS);

    /*	Clear out line records
     */
    BlankLines (yEnd - yStart + 1, VALINE (pFile->cLines));
    if (pFile->vaColor != (PVOID)(-1L)) {
        BlankColor (yEnd - yStart + 1, VACOLOR (pFile->cLines));
    }

    if (fLog) {
        AdjustLines (pFile, yStart, yStart - yEnd - 1);
    }

    MarkDelStream (pFile, 0, yStart, sizeof(linebuf), yEnd);
}





/*  DelFile - delete contents of file
 *
 *  pFile	file structure that is to be cleared
 */
void
DelFile (
    REGISTER PFILE pFile,
    flagType fLog
    )
{
    DelLine (fLog, pFile, (LINE)0, pFile->cLines - 1);
    RSETFLAG (FLAGS(pFile), DIRTY);
}





/*  InsLine - insert a block of blank lines into the file.
 *
 *  line	0-based line before which the insertion will occur.
 *  n		number of blank lines to insert
 *  pFile	file structure for the operation
 */
void
InsLine (
    flagType fLog,
    LINE line,
    LINE n,
    REGISTER PFILE pFile
    )
{
    if (line >= pFile->cLines) {
	return;
    }
    redraw (pFile, line, n+pFile->cLines);
    makedirty (pFile);
    if (fLog) {
        LogInsert (pFile, line, n);
    }
    growline (pFile->cLines + n, pFile);
    memmove(VALINE(line+n), VALINE(line),
	    (long)sizeof(LINEREC)*(pFile->cLines - line));
    if (pFile->vaColor != (PVOID)(-1L)) {
        memmove(VACOLOR(line+n), VACOLOR(line),
	    (long)sizeof(struct colorRecType)*(pFile->cLines - line));
	BlankColor (n, VACOLOR(line));
    }
    BlankLines (n, VALINE(line));
    pFile->cLines += n;
    SETFLAG (fDisplay, RSTATUS);
    if (fLog) {
        AdjustLines (pFile, line, n);
    }
    MarkInsLine (line, n, pFile);
}





/*** fInsSpace - open up a space in a line.
*
*  The line is retrieved and copied into buf and the appropriate number of
*  spaces are inserted. The line is NOT replaced in the file.
*
* Input:
*  x		= 0-based logical column of insertion
*  y		= 0-based line insertion
*  n		= number of spaces to insert
*  pFile	= file structure for the operation
*  buf		= destination of line.
*
* Output:
*  Returns FALSE if line ended up too long (still copied, but truncated)
*
* Notes:
*
*   Often called with n==0 for the following side effects:
*
*	o Trailing spaces added up to column x.
*	o If column x is in a tab,
*	o Line truncated to sizeof linebuf.
*
*   Otherwise GetLine is used.
*
*************************************************************************/
flagType
fInsSpace (
    REGISTER COL  x,
    LINE    y,
    int     n,
    PFILE   pFile,
    linebuf buf
    )
{
    return fInsSpaceColor (x, y, n, pFile, buf, NULL);
}




flagType
fInsSpaceColor (
    REGISTER COL  x,
    LINE    y,
    int     n,
    PFILE   pFile,
    linebuf buf,
    struct lineAttr * pla
    )
{
    int     cbLine;                         /* logical length if line       */
    int     cbMove;                         /* physical length to move      */
    int     cbPhys;                         /* physical length of line      */
    int     colPhys;                        /* Physical column x            */
    int     i;                              /* temp                         */
    flagType fRaw = TRUE;                   /* return value: init ok        */

    /*
     * if the requested insertion is already too out, then truncate IT, and
     * set return flag to indicate truncation.
     */
    if (x >= sizeof(linebuf)) {
        x = sizeof(linebuf)-1;
        fRaw = FALSE;
    }

    /*
     * Read the line, get the logical length, and if needed, pad the line such
     * that the logical length is x.
     */
    cbPhys = GetLine (y, buf, pFile);
    cbLine = cbLog (buf);
	if (cbLine < x) {
		memset ((char *) buf+cbPhys, ' ', x-cbLine);
        cbPhys += (x - cbLine);
        buf[cbPhys] = 0;
        cbLine = x;
        assert (x == cbLog(buf));
    }

    /*
     * In the case that the requested position is over a tab, we add spaces in
     * front of the cursor position. We do this by adding the number of spaces
     * between the requested column and the "aligned" column, and then aligning
     * to that column.
     */
    i = AlignChar (x,buf);
    n += x - i;
    x = i;

    /*
     * open up a space of n chars at location x, moving the chars and NUL
     * For overflow, we have two cases to consider:
     *      x + n + 1 > BUFLEN
     *          set n to be BUFLEN - 1 - x and continue
     *      cbLine + n + 1 > BUFLEN
     *          set cbLine to be BUFLEN - 1 - n and move the bytes
     */
    if (x + n + 1 > sizeof(linebuf)) {
        n = sizeof(linebuf) - 1 - x;
        fRaw = FALSE;
    } else {
        if (cbLine + n >= sizeof(linebuf)) {
            cbLine = sizeof(linebuf) - 1 - n;
            *pLog(buf,cbLine,TRUE) = 0;
            cbPhys = strlen(buf);
            fRaw = FALSE;
        }
        colPhys = (int)(pLog(buf,x,TRUE) - buf);
        cbMove = cbPhys - colPhys + 1;
        memmove ((char *) pLog(buf,x,FALSE)+n, (char *) pLog(buf,x,TRUE), cbMove);
        if (pla) {
            ShiftColor (pla, colPhys, n);
        }
    }
    /*
     * fill the new space with blanks
     */
    n += (int)(pLog(buf,x, FALSE) - pLog(buf,x, TRUE));
    memset ((char *) pLog(buf,x, TRUE), ' ', n);
    buf[sizeof(linebuf)-1] = 0;
    return fRaw;
}




/*** delspace - delete text from a line
*
*  The line is retrieved and copied into buf and the appropriate number of
*  characters are deleted. The line is NOT replaced in the file.
*
* Input:
*  xDel 	= 0-based logical column of deletion
*  yDel 	= 0-based line of deletion
*  cDel 	= logical number of spaces to delete
*  pFile	= file structure for the operation
*  buf		= buffer into which to place the resulting line
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
delspace (
    COL     xDel,
    LINE    yDel,
    int     cDel,
    PFILE   pFile,
    linebuf buf
    )
{
    int     cDelPhys;                       /* count of bytes to remove from buff*/
    int     cLog;                           /* logical length of buffer     */
    REGISTER char *pDelPhys;                /* pointer to physical deletion point*/

    /*
     * Get and compute the logical length of the line. We have work only if the
     * logical length of the line is greater than (past) the logical deletion
     * point.
     */
    GetLine (yDel, buf, pFile);
    cLog = cbLog(buf);

    if (cLog > xDel) {
        /*
         * Compute the physical deletion point (we use it a lot). If the end of the
         * range to be deleted is beyond the actual end of the line, all we need do
         * is truncate at the physical deletion point.
         */
        pDelPhys = pLog(buf,xDel,TRUE);
        if (cLog <= xDel + cDel) {
            *pDelPhys = 0;
        } else if (cDel) {
            /*
             * Compute the physical length of bytes to be removed, and move the remaining
             * portion of the line over that deleted.
             */
            cDelPhys = (unsigned int)max ((pLog(buf,xDel+cDel,TRUE) - pDelPhys), 1);
            memmove ((char*) pDelPhys,
                     (char*) pDelPhys + cDelPhys
                  , (unsigned int)(pLog(buf,cLog,TRUE) - pDelPhys - cDelPhys + 1));
        }
    }
}





/*** DelBox - delete a box from a file
*
*  The box delimited by xLeft-xRight and yTop-yBottom is deleted inclusively.
*
* Input:
*  pFile	= file to be modified
*  xLeft	= column start of box
*  yTop 	= line start of box
*  xRight	= column end of box
*  yBottom	= line end of box
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
DelBox (
    PFILE   pFile,
    REGISTER COL  xLeft,
    REGISTER LINE yTop,
    COL     xRight,
    LINE    yBottom
    )
{
    linebuf  L_buf;
    struct lineAttr rgla[sizeof(linebuf)];
    flagType fColor;
    REGISTER int cCol = xRight - xLeft + 1;

    MarkDelBox (pFile, xLeft, yTop, xRight, yBottom);
    if (xLeft <= xRight) {
        while (yTop <= yBottom) {
            delspace (xLeft, yTop, cCol, pFile, L_buf);
            if (fColor = GetColor (yTop, rgla, pFile)) {
                ShiftColor (rgla, xRight, -cCol);
                ColorToLog (rgla, L_buf);
            }
            PutLine (yTop++, L_buf, pFile);
            if (fColor) {
                PutColor (yTop-1, rgla, pFile);
            }
        }
    }
}





/*** DelStream - delete a stream from a file
*
*  The stream specified starting at (xStart,yStart) is deleted up through
*  the character before (xEnd, yEnd).
*
* Input:
*  pFile	= file to be modified
*  xStart	= column start of stream
*  yStart	= line start of stream
*  xEnd 	= column end of stream
*  yEnd 	= line end of stream
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
DelStream (
    PFILE   pFile,
    REGISTER COL  xStart,
    REGISTER LINE yStart,
    COL     xEnd,
    LINE    yEnd
    )
{
    linebuf pbuf, sbuf;

    CopyColor (pFile, pFile, yEnd, xEnd, sizeof(linebuf), yStart, xStart);
    fInsSpace (xStart, yStart, 0, pFile, pbuf);
    *pLog (pbuf, xStart, TRUE) = 0;
    DelLine (TRUE, pFile, yStart, yEnd - 1);
    delspace (0, yStart, xEnd, pFile, sbuf);
    LengthCheck (yStart, xStart, sbuf);
    strcpy (pLog (pbuf, xStart, TRUE), sbuf);
    PutLine (yStart, pbuf, pFile);
    MarkCopyBox (pFile, pFile, xEnd, yStart, sizeof(linebuf), yStart, xStart, yStart);
}




/*  LengthCheck - verify/truncate a buffer prior to strcpy
 *
 *  Verify that the result of a strcpy will fit within a buffer.
 *  If the line is too long, display an error and truncate the string so
 *  that it will fit within a buffer.
 *
 *  line	line of interest (for display)
 *  offset	offset where strcpy begins
 *  pStr	pointer to copied string.  If NULL, the message is displayed.
 */
void
LengthCheck (
    LINE line,
    int  offset,
    REGISTER char *pStr
    )
{
    if (pStr == NULL || offset + strlen (pStr) + 1 > sizeof(linebuf)) {
	printerror ("Line %ld too long", line + 1);
        if (pStr != NULL) {
            pStr[BUFLEN - offset - 1] = 0;
        }
    }
}





/****************************************************************************
 *									    *
 *  fcolcpy (dst, src)							    *
 *									    *
 *	dst   - address of destination of copy				*
 *	src   - address of source of copy				*
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Number of struct lineAttr's copied                                  *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Copies the contents of src to dst.  The length of the array,	    *
 *	including the terminating 0xFFFF, is returned.	If the		    *
 *	destination is NULL, the number of items is still returned, but     *
 *	no copy takes place.						    *
 *									    *
 ****************************************************************************/
int
fcolcpy (
    struct lineAttr *  dst,
    struct lineAttr *  src
    )
{

	struct lineAttr *p = src;
	int size;

	while ((p->len != 0xFF) && ((p++)->attr != 0xFF)) {
	}

	size = (int)((PBYTE)p - (PBYTE)src);

	if ( dst ) {
		memmove((char *)dst, (char *)src, size);
	}

	return size / sizeof(struct lineAttr);
}




/*** FreeFile - Free all resources for LRU clean file or MRU dirty file
*
* Purpose:
*
*   When we are low on memory, we call this to get some back.  This frees
*   the text of the file from VM, as well as the pFile structure and name
*   from local memory.
*
*   The strategy is to find the least recently used clean file and throw it
*   out.  If there are no such files, we find the most recently used dirty
*   file, ask the user if he wants to save it, then flush it.  The user
*   can hit <cancel> to not flush the file.
*
* Input:
*
* Output:
*
*   Returns TRUE if successfull.
*
*
* Exceptions:
*
*   Pseudo files are not removed.
*   Dirty user files will be saved to disk first.
*
* Notes:
*
*************************************************************************/
flagType
ExpungeFile (
    void
    )
{
    flagType fRet   = FALSE;
    PFILE    pFile;

    /*
     * Ensure that we do NOT attempt to update any text screens (and possibly
     * attempt to allocate more memory).
     */
    RSETFLAG (fDisplay, RTEXT);

    if (!(pFile = pFileLRU (pFileHead))) {

        /*
         * No LRU clean files found. Ask if user wants to save them all, and let
         * him try. Then look for an LRU clean file again.
         */
        if (confirm ("Save all changed files?",NULL)) {
            SaveAllFiles ();
        }

        if (!(pFile = pFileLRU (pFileHead))) {
            /*
             * No LRU clean files, and he didn't want to save them all. So, we walk
             * the pFile list, and let him decide for each one. As soon as we find one
             * that we can flush, do so.
             */

            for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
                if (   ((FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY)
		    && (pFile != pFileIni)
                    && (pFile != pFileHead)
                    && (pFile != pFileMark)) {

                    if (confirm ("Save file %s before flushing?",pFile->pName)) {
                        FileWrite (NULL, pFile);
                    }
                    break;
                }
            }
        }
    }

    /*
     * We have some kind of pFile. Either it was clean, or it was dirty and the
     * user said save it, or it is dirty, and the user said flush it anyway. So
     * we do...
     */
    if (pFile) {
        domessage ("Flushing %s from memory", pFile->pName);
        RemoveFile (pFile);
        fRet = TRUE;
    }

    SETFLAG (fDisplay, RTEXT);
    return fRet;
}





/*** pFileLRU - Return last clean user file in file list
*
* Purpose:
*
*   Used by ExpungeFile to find LRU clean file.
*
* Input:
*
*   Head of list of files in MRU order
*
* Output:
*
*   Returns LRU pFile.
*
*
* Exceptions:
*
*   TOOLS.INI and the current mark file
*
* Notes:
*
*   The function recurses to the end of the list, then backtracks through
*   the unacceptable files to the one we want and returns that.  The
*   recursion take 4 bytes for each call.  The maximum number of calls
*   should be about 250.
*
*************************************************************************/
PFILE
pFileLRU (
    PFILE pFile
    )
{
    static PFILE pFileRet;

    if (pFile == NULL) {
        return NULL;
    }

    if (pFileRet = pFileLRU (pFile->pFileNext)) {
        return pFileRet;
    }

    if (TESTFLAG (FLAGS(pFile), FAKE) || TESTFLAG (FLAGS(pFile), DIRTY)) {
        return NULL;
    }

    if (pFile == pFileIni || pFile == pFileMark) {
        return NULL;
    }

    return pFile;
}






/*** FreeFileVM  - Free VM space associated with the given file
*
* Purpose:
*
*   To recover VM used by a file
*
* Input:
*
*   pFile - File in question.
*
* Output:
*
*   Returns nothing
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
FreeFileVM (
    PFILE pFile
    )
{
    LINE  i;
    LINEREC *vLine;


    for (i = 0; i < min( 1, pFile->cLines ); i++) {
        vLine = VALINE(i);
		if (vLine->Malloced) {
			vLine->Malloced = FALSE;
            FREE (vLine->vaLine);
        }
    }

    pFile->cLines = 0;
    pFile->lSize  = 0;

    if (pFile->plr != NULL) {
	FREE (pFile->plr);
	pFile->plr = NULL;
    }

    if (pFile->pbFile != NULL) {
	 FREE (pFile->pbFile);
	 pFile->pbFile = NULL;
     }

    RemoveUndoList (pFile);

    RSETFLAG (FLAGS (pFile), REAL);
}






/*** GetTagLine - Get a line, assuming a tools.ini-style format
*
* Purpose:
*
*   To get a clean, complete line in DoAssign form.  This means:
*
*	o Blank lines are skipped
*	o Lines beginning with ';' are skipped
*	o Text past a ';' not in quotes is eliminated
*	o Lines with continuation characters are concatenated
*	o When we reach another tag, we stop reading
*
*   The continuation character is a '\'; it must be preceded by
*   a space or tab and followed by nothing or whitespace and/or a comment.
*   Any leading whitespace on following lines is stripped.
*
* Input:
*   buf -   Place to put result.  This must be NULL initially and a
*	    GetTagLine returned pointer afterwords
*
* Output:
*
*   Returns pointer to next line, or NULL if we are done
*
* Notes:
*
*   When we return NULL, we also free the buffer.  If the caller stops
*   before NULL is returned, s/he must also free the buffer.
*
*   Because a line may be arbitrarily long, we may need to LMAlloc more
*   space for it.  Because of this, the routine itself will alloc all space
*   used.  When a non-NULL pointer is passed in, it is assumed that this
*   points to the heap.
*
*************************************************************************/

#define GTL_NORMAL  0
#define GTL_QUOTE   1
#define GTL_WS	    2
#define GTL_CONT    3

char *
GetTagLine (
    LINE * pCurLine,
    char * buf,
    PFILE  pFile
    )
{
    int     cch;
    int     ochScan;                        /* saved offset of pchScan      */
    int     state = GTL_NORMAL;
    int     statePrev;
    REGISTER char * pchScan;
    char    *pchSlash;
    char    *pch;
    flagType fEof = FALSE;
    flagType fWS;

    if (buf == NULL) {
        buf = ZEROMALLOC (sizeof(linebuf));
        if ( !buf ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
    }

    buf[0] = '\0';  /* Ya start with nothin' */
    pchScan = buf;

    //  We do this:
    //
    //      Get a line
    //      If it's a tag line or the last line, stop reading
    //      If it is blank or begins with a ';', start over
    //      Clean up the line
    //      If we are left looking at a \, reset pointers, allocate
    //      Enough more space to leave BUFLEN bytes of space, and
    //      Start over.
    //
    //  When we're done, 'buf' points to a complete line
    //
    while (TRUE) {
        GetLine ((*pCurLine)++, pchScan, pFile);

	if (IsTag (pchScan) || (*pCurLine) > pFile->cLines) {
            (*pCurLine)--;  /* Leave caller pointing at tag line    */
            fEof = TRUE;
            break;
        }

        /* Squeeze out all leading spaces. */
        pch = whiteskip (pchScan);
        memmove ((char *)pchScan, (char*)pch, strlen(pch) + 1);

        // Now look for a continuation sequence.  This is whitespace
        // followed by a \ followed by nothing but whitespace and/or
        // a comment.  We use a modified FSM with these states:
        //
        // GTL_NORMAL   Outside quotes
        // GTL_QUOTE    Inside quotes
        // GTL_WS       Reading whitespace
        // GTL_CONT     Possible continuation sequence found.
        //
        for (fWS = TRUE, statePrev = state = GTL_NORMAL;
            *pchScan;
            pchScan++) {
            if (*pchScan == ';' && fWS && statePrev != GTL_QUOTE) {
                *pchScan-- = '\0';
            } else {
                fWS = (flagType)(strchr (rgchWSpace, *pchScan) != NULL);
                switch (state) {

                    case GTL_NORMAL:
                        if (fWS) {
                            state = GTL_WS;
                            statePrev = GTL_NORMAL;
                        } else if (*pchScan == '"') {
                            state = GTL_QUOTE;
                        }
                        break;

                    case GTL_QUOTE:
                        if (fWS) {
                            state = GTL_WS;
                            statePrev = GTL_QUOTE;
                        } else if (*pchScan == '"') {
                            state = GTL_NORMAL;
                        }
                        break;

                    case GTL_WS:
                        if (*pchScan == '\\') {
                            pchSlash = pchScan;
                            state = GTL_CONT;
                            break;
                        }

                    case GTL_CONT:
                        if (!fWS) {
                            if (*pchScan == '"') {
                                state = statePrev == GTL_QUOTE ?
                                                    GTL_NORMAL :
                                                    GTL_QUOTE;
                            } else {
                                state = statePrev;
                            }
                        }
                        break;
                }
            }
        }

        if (state == GTL_CONT) {
            pchScan = pchSlash-1;   /* -1 to strip the space */
            /* Make sure there is enough space for getline! */
            cch = MEMSIZE (buf);
            ochScan = (int)(pchScan - buf);
            if ((cch - ochScan) < sizeof(linebuf)) {
                pch = buf = ZEROREALLOC (buf, cch + sizeof(linebuf));
                pchScan = pch + ochScan;
            }
        } else if (buf[0] == '\0') {
            continue;
        } else {
            break;
        }
    }


    // 'buf' holds whatever we got.  If 'fEof' is TRUE, this may be
    // nothing at all.  If 'fEof' is FALSE and we have nothing, then
    // we are confused.
    //
    if (fEof) {
        if (pchScan != buf) {
            // The user had a continuation character at the end
            // of the last line in the section or file. Erase the
            // trailing [garbage] and issue a warning message.
            //
            printerror ("Warning: continuation character on last line!");
            *pchScan = '\0';
            return buf;
        } else {
            FREE (buf);
            return NULL;
        }
    } else {
        assert (buf[0]);
    }

    return buf;
}





/*** cbLog - return logical length of entabbed line
*
*  Given a line possible entabbed, return the logical length of that line.
*
* Input:
*  pBuf 	= pointer to line in question
*
* Output:
*  Returns logical length of line
*
*************************************************************************/
int
cbLog (
    REGISTER char *pBuf
    )
{
    REGISTER int cbLine;

    if (!fRealTabs) {
        return strlen(pBuf);
    }

    cbLine = 0;
    while (*pBuf) {
        if (*pBuf++ == '\t') {
            cbLine = ((cbLine + fileTab) / fileTab) * fileTab;
        } else {
            cbLine++;
        }
    }
    return cbLine;
}





/*** colPhys - return logical column from physical pointer
*
*  Given a buffer and a pointer into it, determine the logical column
*  that that pointer represents. If a null is encountered before the
*  pointer into the buffer, the rest of the buffer contents are ignored
*  (that is, tab expansion calculation is not done), and the column is
*  returned as if the rest of the line up to the pointer were NOT tabs.
*
* Input:
*  pBuf 	= pointer to buffer
*  pCur 	= pointer into buffer
*
* Output:
*  Returns 0 based column represented
*
*************************************************************************/
COL
colPhys (
    char    *pBuf,
    char    *pCur
    )
{
    COL     colRet  = 0;

    /*
     * Special case the current pointer preceding the buffer, and return a
     * column of -1.
     */
    if (pBuf > pCur) {
        return -1;
    }

    while (*pBuf && (pBuf < pCur)) {
        if (*pBuf++ == '\t') {
            colRet = ((colRet + fileTab) / fileTab) * fileTab;
        } else {
            colRet++;
        }
    }

    if (pBuf < pCur) {
        colRet += (COL)(pCur - pBuf);
    }

    return colRet;
}





/*** IncCol, DecCol - Increment/Decrement a column w/ tabs
*
*  Increment or decrement a column position, taking into account tab
*  characters on the line and the fRealTabs flag. Ensure that the resulting
*  logical column position rests on a character, or the first column
*  position of an underlying tab, if fRealTabs is on.
*
* Input:
*  col		= column position to start
*  pText	= buffer containing the text of the line
*
* Output:
*  Returns new column position
*
*************************************************************************/
COL
DecCol (
    COL     col,
    char    *pText
    )
{
    return colPhys (pText, pLog (pText, col, FALSE) - 1);
}





COL
IncCol (
    COL     col,
    char    *pText
    )
{
    return colPhys (pText, pLog (pText, col, TRUE) + 1);
}





/*** AppFile - Append a line to the given file without logging the change
*
* Purpose:
*
*   Used to generate pseudo files that display information, such as
*   <information> and <assign>.
*
* Input:
*   p	  - Line to add.
*   pFile - File to add it to
*
* Output: None.
*
*************************************************************************/
void
AppFile (
    char *p,
    PFILE pFile
    )
{
    puttextline (FALSE, FALSE, pFile->cLines, p, pFile);
}




/*** PutTagLine - Put a line into file with continuation chars
*
* Purpose:
*
*   Used to generate TOOLS.INI type entries, in which a single logical
*   line can be broken into many physical lines separated by continuation
*   characters.
*
*   The current logical line is replaced.
*
* Input:
*   pFile   -	The file to put into
*   pszLine -	The line to put
*   line    -	The number of the line to replace
*
* Output: None
*
*************************************************************************/
void
PutTagLine (
    PFILE  pFile,
    char * pszLine,
    LINE   y,
    COL    x
    )
{
    PFILE    pFileCur   = pFileHead;
    fl       flWindow;
    fl       flCursor;
    flagType fWrap      = fWordWrap;
    LINE     yCur;
    linebuf  lbuf;

    // We remember which file we're in, then switch to the
    // given and use edit() to insert to string.  In between
    // in each character we check to see if we have been bumped
    // to thenext line.  If so, we retrieve the previous line
    // and append a continuation character.  When we're done, we
    // restore the previous state of pFile.
    //
    pFileToTop (pFile);
    flWindow = pInsCur->flWindow;
    flCursor = pInsCur->flCursorCur;

    pInsCur->flCursorCur.lin = y;

    if (x < 0) {
        x = LineLength (y, pFile);
    }

    pInsCur->flCursorCur.col = x;

    fWordWrap = TRUE;
    yCur      = y;

    while (*pszLine) {
        edit (*pszLine++);
        if (yCur != YCUR(pInsCur)) {
            GetLine (yCur, lbuf, pFile);
            strcat (lbuf, "  \\");
            PutLine (yCur, lbuf, pFile);
            yCur = YCUR(pInsCur);
        }
    }

    fWordWrap = fWrap;
    pInsCur->flWindow = flWindow;
    pInsCur->flCursorCur = flCursor;
    pFileToTop (pFileCur);
}





/*** ShiftColor - Shift color left or right within a line
*
* Purpose:
*
*   Shifts color to the left or right.	Shifting left deletes the
*   covered coilor.  Shifting right propogates the color at the
*   left edge of the shift.
*
* Input:
*   rgla    - Array of colors to work on.
*   xStart  - Column to start with
*   n	    - Number of columns to shift by.
*
* Output: None.
*
* Notes:
*
*   It is assumed that the color can properly be shifted by simply
*   adding or subtracting the given number of columns.	This means
*   that when fRealTabs is on, the color array should be presented
*   in physical form, as returned by GetColor().
*
*************************************************************************/
void
ShiftColor (
    struct lineAttr rgla[],
    COL x,
    int len
    )
{
    struct lineAttr * plaEnd;
    struct lineAttr * plaRight;
    struct lineAttr * plaLeft;

    int      dColRight;
    int      dColLeft;
    flagType fFoundRight = FALSE;
    flagType fFoundLeft  = FALSE;


    plaEnd    = plaLeft = plaRight = rgla;
    dColRight = dColLeft = x;

    fFoundRight  = fGetColorPos (&plaRight, &dColRight);
    fFoundLeft   = fGetColorPos (&plaLeft, &dColLeft);
    (void)fGetColorPos (&plaEnd, NULL);

    if (!fFoundLeft) {
        return;
    }

    if (len < 0) {
        // User is shifting left.  If the deletion
        // all lies within a single color, we simply shorten
        // that color.  If it does not, we delete the entries
        // for the colors we lose, then shorten the colors
        // on either side.
        //
        if (plaLeft == plaRight) {
            plaLeft->len = (unsigned char)((int)plaLeft->len + len);
        } else {
            memmove ((char *)(plaLeft + 1),
		    (char *)plaRight,
                    (unsigned int)(sizeof(*plaEnd) * (plaEnd - plaRight + 1)));
            plaLeft->len = (unsigned char)(dColLeft > 0 ? dColLeft : 0);
            if (fFoundRight) {
                (plaLeft+1)->len -= (unsigned char)dColRight;
            }
        }
    } else {
        plaLeft->len += (unsigned char)len;
    }
}




/*** CopyColor - Copy part of a line of color
*
* Purpose:
*
*   When text is copied, we make the color follow it with this.
*
* Input:
*   pFileSrc	- Source of color.  If NULL, the color is fgColor.
*   pFileDst	- Destination of color.
*   yStart	- Line to get color from.
*   xStart	- Column to start in
*   len		- length of color to copy
*   yDst	- Line to put color on
*   xDst	- Column to start in
*
* Output: None.
*
* Notes:
*
*   The color copied overwrites existing color.
*
*   This could be made faster by splicing in the color directly,
*   rather than calling UpdOneHiLite().
*
*************************************************************************/
void
CopyColor (
    PFILE pFileSrc,
    PFILE pFileDst,
    LINE  yStart,
    COL   xStart,
    COL   len,
    LINE  yDst,
    COL   xDst
    )
{
    struct lineAttr * rglaSrc = (struct lineAttr *)ZEROMALLOC (sizeof(linebuf)/sizeof(char) * sizeof(struct lineAttr));
    struct lineAttr * rglaDst = (struct lineAttr *)ZEROMALLOC (sizeof(linebuf)/sizeof(char) * sizeof(struct lineAttr));
    struct lineAttr * plaLeft;
    COL xLeft, cCol;
    flagType fLeft = TRUE, fColorDst, fColorSrc = FALSE;

    if ( !rglaSrc || !rglaDst ) {
        disperr(MSGERR_NOMEM);
        disperr(MSGERR_QUIT);
        CleanExit(4,FALSE);
    }


    xLeft = xStart;

    fColorDst = (flagType)getcolorline (TRUE, yDst, rglaDst, pFileDst);

    if (!pFileSrc ||
        !(fColorSrc = (flagType)GetColor (yStart, plaLeft = rglaSrc, pFileSrc)) ||
        !(fLeft = fGetColorPos(&plaLeft, &xLeft)) ) {

        if (fColorSrc || fColorDst) {
            UpdOneHiLite (rglaDst, xDst, len, TRUE, fLeft ? fgColor : plaLeft->attr);
        } else {
            goto freestuff;
        }
    } else {
        assert(plaLeft && plaLeft->len != 0xFF);

        plaLeft->len -= (unsigned char)xLeft;

        for (cCol = 0; cCol < len; cCol += plaLeft->len, plaLeft++) {
            if (plaLeft->len != 0xFF) {
                if ((int)plaLeft->len > (len - cCol)) {
                    plaLeft->len = (unsigned char)(len - cCol);
                }
                UpdOneHiLite (rglaDst, xDst + cCol, TRUE, plaLeft->len, plaLeft->attr);
            }
        }
    }

    putcolorline (TRUE, yDst, rglaDst, pFileDst);

freestuff:
    FREE (rglaSrc);
    FREE (rglaDst);
}





/*** SetColor - Assign a color to a stretch of text
*
* Purpose:
*
*   Add color to a file.
*
* Input:
*   pFile   - File to add color to.
*   y	    - Line to add color to.
*   x	    - Column to start in.
*   len	    - Length of color.
*   color   - color to attach.
*
* Output: None.
*
*************************************************************************/
void
SetColor (
    PFILE pFile,
    LINE  y,
    COL   x,
    COL   len,
    int   color
    )
{
    struct lineAttr * rgla = (struct lineAttr * )ZEROMALLOC (sizeof(linebuf)/sizeof(char) * sizeof(struct lineAttr));
    struct lineAttr * pla;

    if ( !rgla ) {
        disperr(MSGERR_NOMEM);
        disperr(MSGERR_QUIT);
        CleanExit(4,FALSE);
    }

    if (GetColorUntabbed (y, rgla, pFile)) {
        UpdOneHiLite (rgla, x, len, TRUE, color);
    } else {
        if (color == FGCOLOR) {
            goto freeit;
        }

        pla = rgla;

        if (x) {
            pla->len = (unsigned char)x;
            (pla++)->attr = (unsigned char)fgColor;
        }

        pla->len = (unsigned char)len;
        pla->attr = (unsigned char)color;
        (++pla)->len = 0xFF;
    }

    PutColor (y, rgla, pFile);

freeit:
    FREE (rgla);
}





/*** fGetColorPos - Get color array position of real column
*
* Purpose:
*
*   Given an array of lineAttr and a column number, find the
*   color array element and offset that corresponds to that
*   absolute column.
*
* Input:
*   ppla    - Color array to examine.
*   pOff    - Column in text line to find.  If NULL, this is a
*	      request to find the array terminator.
*
* Output:
*   ppla   - Element of input array that specifies the color field
*	     in which the input column will be found.  If the column
*	     lies beyond the defined color, this will be the terminator.
*   pOff   - The offset into the color field ppla which corresponds
*	     to the user's column.
*
*   Returns TRUE if the user's column lay within the color definition,
*   FALSE if not.
*
*************************************************************************/
flagType
fGetColorPos (
    struct lineAttr **ppla,
    COL * pOff
    )
{
    COL Off;
    COL x;

    if (pOff) {
        Off = *pOff;
    }

    for (x = 0; (*ppla)->len != 0xFF; x += (*ppla)->len, (*ppla)++) {
        if (pOff && (Off - x < (COL)((*ppla)->len))) {
            break;
        }
    }

    if (pOff) {
        *pOff = Off - x;
    }

    return (flagType)((*ppla)->len != 0xFF);
}






/*** ColorToPhys - Change a line's color info from logical to physical
*
* Purpose:
*
*   The logical color representation encodes one color column per screen
*   column.  The physical color representation encodes one color column
*   per file character.  The difference is that the file character may
*   be a tab, which represents 1-8 screen columns.
*
*   This function takes a logical color array and converts it to a
*   physical array, using the text the color is attached to.
*
* Input:
*   pla  -  Logical color array.
*   line -  Line number this is attached to to.
*   pFile-  File the line is in.
*
* Output: None
*
*************************************************************************/
void
ColorToPhys (
    struct lineAttr * pla,
    LINE  line,
    PFILE pFile
    )
{
    struct lineAttr * plaCur;
    linebuf  lBuf;
    COL      xLog, xPhys, xShrink;
    flagType fRealTabsOrig = fRealTabs;

    fRealTabs = TRUE;
    if (gettextline (TRUE, line, lBuf, pFile, ' ')) {
        // We read through the color array, keeping
        // track of the logical column represented
        // by the color fields.  At each field, we ask
        // what physical column the end of the field
        // represents.  If the two columns differ,
        // we shrink the current current field. The
        // amount to shrink is the difference between
        // the columns less the amount we have already
        // shrunk.
        //
        for (plaCur = pla, xShrink = 0, xLog = plaCur->len;
             plaCur->len != 0xFF;
             xLog += (++plaCur)->len) {

            xPhys = (COL)(pLog(lBuf, xLog, FALSE) - lBuf);

            plaCur->len -= (unsigned char)((xLog - xPhys) - xShrink);
            xShrink += (xLog - xPhys) - xShrink;
        }
    }
    fRealTabs = fRealTabsOrig;
}





/*** ColorToLog - Change a line's color info from physical to logical
*
* Purpose:
*
*   This is the opposite of ColorToPhys.
*
* Input:
*   pla   - Physical color array
*   pText - Text to for conversion
*
* Output: None.
*
*************************************************************************/
void
ColorToLog (
    struct lineAttr * pla,
    char * pText
    )
{
    struct lineAttr * plaCur;
    COL     xLog, xPhys, xGrow;

    // We read through the color array, keeping
    // track of the phsyical column represented
    // by the color fields.  At each field, we ask
    // what logical column the end of the field
    // represents.  If the two columns differ,
    // we grow the current current field. The
    // amount to grow is the difference between
    // the columns less the amount we have already
    // shrunk.
    //
    for (plaCur = pla, xGrow = 0, xPhys = plaCur->len;
         plaCur->len != 0xFF;
         xPhys += (++plaCur)->len) {

        xLog = colPhys (pText, pText + xPhys);

        plaCur->len += (unsigned char)((xLog - xPhys) - xGrow);
        xGrow += (xLog - xPhys) - xGrow;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\transkey.c ===
/*** transkey.c - keyboard translation
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*       03-Dec-1990 ramonsa     createdc
*
*************************************************************************/

//#define INCL_DOSSEMAPHORES
#include "mep.h"
#include "keyboard.h"
#include "keys.h"
#include "cmds.h"


WORD  GetNumlockIndex (WORD Scan);




#define NORMAL_KEY     0
#define ALT_KEY        1
#define CTRL_KEY       2
#define SHIFT_KEY      3


//      This table is indexed by a Scan code (as found in the KBDKEY
//  structure), and contains entries for the corresponding internal
//  MEP codes.
//
WORD   MapTable[][4] = {

    //  Normal  Alt     Ctrl    Shift               Scan code
    //
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  00
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  01     Left mouse
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  02     Right mouse
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  03
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  04
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  05
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  06
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  07
    {   0x012D, 0x01A1, 0x0215,  0x0255  },      //  08     bksp
	{	0x012E, 0x01A2, 0x0216,  0x0256	 },		 //	 09		tab-bktab
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0B
    {   0x0116, 0x018A, 0x01FE,  0x0000  },      //  0C     goto
    {   0x0131, 0x01A5, 0x0219,  0x0259  },      //  0D     enter
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  10     Shift
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  11     Ctrl
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  12
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  13     Pause
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  14     Caps Lock
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  15
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  16
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  17
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  18
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  19
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1A
    {   0x0130, 0x0000, 0x0218,  0x0258  },      //  1B     esc
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1F
    {   0x0000, 0x01A0, 0x0214,  0x0000  },      //  20     space
    {   0x0112, 0x0186, 0x01FA,  0x023A  },      //  21     pgup
    {   0x0113, 0x0187, 0x01FB,  0x023B  },      //  22     pgdown
    {   0x010D, 0x0181, 0x01F5,  0x0235  },      //  23     end
    {   0x010C, 0x0180, 0x01F4,  0x0234  },      //  24     home
    {   0x010E, 0x0182, 0x01F6,  0x0236  },      //  25     left
    {   0x0110, 0x0184, 0x01F8,  0x0238  },      //  26     up
    {   0x010F, 0x0183, 0x01F7,  0x0237  },      //  27     right
    {   0x0111, 0x0185, 0x01F9,  0x0239  },      //  28     down
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  29
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2C     Print Scrn
    {   0x0114, 0x0188, 0x01FC,  0x023C  },      //  2D     ins
    {   0x0115, 0x0189, 0x01FD,  0x023D  },      //  2E     del
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2F
    {   0x0000, 0x0140, 0x01B4,  0x0000  },      //  30     0
    {   0x0000, 0x0141, 0x01B5,  0x0000  },      //  31     1
    {   0x0000, 0x0142, 0x01B6,  0x0000  },      //  32     2
    {   0x0000, 0x0143, 0x01B7,  0x0000  },      //  33     3
    {   0x0000, 0x0144, 0x01B8,  0x0000  },      //  34     4
    {   0x0000, 0x0145, 0x01B9,  0x0000  },      //  35     5
    {   0x0000, 0x0146, 0x01BA,  0x0000  },      //  36     6
    {   0x0000, 0x0147, 0x01BB,  0x0000  },      //  37     7
    {   0x0000, 0x0148, 0x01BC,  0x0000  },      //  38     8
    {   0x0000, 0x0149, 0x01BD,  0x0000  },      //  39     9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  40
    {   0x0000, 0x014C, 0x01C0,  0x0000  },      //  41     a
    {   0x0000, 0x014D, 0x01C1,  0x0000  },      //  42     b
    {   0x0000, 0x014E, 0x01C2,  0x0000  },      //  43     c
    {   0x0000, 0x014F, 0x01C3,  0x0000  },      //  44     d
    {   0x0000, 0x0150, 0x01C4,  0x0000  },      //  45     e
    {   0x0000, 0x0151, 0x01C5,  0x0000  },      //  46     f
    {   0x0000, 0x0152, 0x01C6,  0x0000  },      //  47     g
    {   0x0000, 0x0153, 0x01C7,  0x0000  },      //  48     h
    {   0x0000, 0x0154, 0x01C8,  0x0000  },      //  49     i
    {   0x0000, 0x0155, 0x01C9,  0x0000  },      //  4A     j
    {   0x0000, 0x0156, 0x01CA,  0x0000  },      //  4B     k
    {   0x0000, 0x0157, 0x01CB,  0x0000  },      //  4C     l
    {   0x0000, 0x0158, 0x01CC,  0x0000  },      //  4D     m
    {   0x0000, 0x0159, 0x01CD,  0x0000  },      //  4E     n
    {   0x0000, 0x015A, 0x01CE,  0x0000  },      //  4F     o
    {   0x0000, 0x015B, 0x01CF,  0x0000  },      //  50     p
    {   0x0000, 0x015C, 0x01D0,  0x0000  },      //  51     q
    {   0x0000, 0x015D, 0x01D1,  0x0000  },      //  52     r
    {   0x0000, 0x015E, 0x01D2,  0x0000  },      //  53     s
    {   0x0000, 0x015F, 0x01D3,  0x0000  },      //  54     t
    {   0x0000, 0x0160, 0x01D4,  0x0000  },      //  55     u
    {   0x0000, 0x0161, 0x01D5,  0x0000  },      //  56     v
    {   0x0000, 0x0162, 0x01D6,  0x0000  },      //  57     w
    {   0x0000, 0x0163, 0x01D7,  0x0000  },      //  58     x
    {   0x0000, 0x0164, 0x01D8,  0x0000  },      //  59     y
    {   0x0000, 0x0165, 0x01D9,  0x0000  },      //  5A     z
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  60
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  61
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  62
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  63
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  64
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  65
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  66
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  67
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  68
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  69
    {   0x0126, 0x019A, 0x020E,  0x024E  },      //  6A     num*
    {   0x0125, 0x0199, 0x020D,  0x024D  },      //  6B     num+
    {   0x0128, 0x019C, 0x0210,  0x0250  },      //  6C     numenter
    {   0x0124, 0x0198, 0x020C,  0x024C  },      //  6D     num-
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  6E
    // {   0x0000, 0x017E, 0x01F2,  0x0000  },      //  ??     /
    {   0x0127, 0x019b, 0x020F,  0x024F  },      //  6F     num/
    {   0x0100, 0x0168, 0x01DC,  0x0228  },      //  70     f1
    {   0x0101, 0x0169, 0x01DD,  0x0229  },      //  71     f2
    {   0x0102, 0x016A, 0x01DE,  0x022A  },      //  72     f3
    {   0x0103, 0x016B, 0x01DF,  0x022B  },      //  73     f4
    {   0x0104, 0x016C, 0x01E0,  0x022C  },      //  74     f5
    {   0x0105, 0x016D, 0x01E1,  0x022D  },      //  75     f6
    {   0x0106, 0x016E, 0x01E2,  0x022E  },      //  76     f7
    {   0x0107, 0x016F, 0x01E3,  0x022F  },      //  77     f8
    {   0x0108, 0x0170, 0x01E4,  0x0230  },      //  78     f9
    {   0x0109, 0x0171, 0x01E5,  0x0231  },      //  79     f10
    {   0x010A, 0x0172, 0x01E6,  0x0232  },      //  7A     f11
    {   0x010B, 0x0173, 0x01E7,  0x0233  },      //  7B     f12
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  80
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  81
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  82
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  83
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  84
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  85
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  86
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  87
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  88
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  89
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  90     Num lock
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  91     Scroll Lock
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  92
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  93
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  94
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  95
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  96
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  97
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  98
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  99
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A0
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A1
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AA
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AB
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AC
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AD
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AE
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AF
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B0
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B1
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B9
    {   0x0000, 0x017A, 0x01EE,  0x0000  },      //  BA     ;
	{	0x0000, 0x0176, 0x01EA,	 0x0000	 },		 //	 BB		+
    {   0x0000, 0x017C, 0x01F0,  0x0000  },      //  BC     ,
    {   0x0000, 0x0175, 0x01E9,  0x0000  },      //  BD     -
    {   0x0000, 0x017D, 0x01F1,  0x0000  },      //  BE     .
    {   0x0000, 0x017E, 0x01F2,  0x0000  },      //  BF     /
    {   0x0000, 0x0174, 0x01E8,  0x0000  },      //  C0     `
    {   0x0000, 0x017B, 0x01EF,  0x0000  },      //  C1     '
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CA
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CB
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CC
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CD
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CE
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CF
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D0
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D1
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D9
	{	0x0000, 0x0000, 0x0000,  0x0000  },		 //	 DA
	{	0x0000, 0x0177, 0x01EB,  0x0000  },		 //	 DB		[
	{	0x0000, 0x0179, 0x01ED,  0x0000  },		 //	 DC	   backslash
    {   0x0000, 0x0178, 0x01EC,  0x0000  },      //  DD     ]
    {   0x0000, 0x017B, 0x01EF,  0x0000  },      //  DE     '
    {   0x0000, 0x0176, 0x01EA,  0x0000  },      //  DF     =
};

#define LAST_SCAN       0xDF


//      This table contains entries for codes when NUMLOCK is on,
//  it is not indexed by scan code, but by an index obtain thru the
//  function GetNumlockIndex function.
//
WORD   MapNumlockTable[][4] = {
    //  Special Alt     Ctrl    Shift               Index   Key
	//
    {   0x0118, 0x018C, 0x0200,  0x0240  },      //    0    num0
    {   0x0119, 0x018D, 0x0201,  0x0241  },      //    1    num1
    {   0x011A, 0x018E, 0x0202,  0x0242  },      //    2    num2
    {   0x011B, 0x018F, 0x0203,  0x0243  },      //    3    num3
    {   0x011C, 0x0190, 0x0204,  0x0244  },      //    4    num4
    {   0x011D, 0x0191, 0x0205,  0x0245  },      //    5    num5
    {   0x011E, 0x0192, 0x0206,  0x0246  },      //    6    num6
    {   0x011F, 0x0193, 0x0207,  0x0247  },      //    7    num7
    {   0x0120, 0x0194, 0x0208,  0x0248  },      //    8    num8
    {   0x0121, 0x0195, 0x0209,  0x0249  },      //    9    num9
    {   0x0124, 0x0198, 0x020C,  0x024C  },      //   10    num-
    {   0x0125, 0x0199, 0x020D,  0x024D  },      //   11    num+
    {   0x0126, 0x019A, 0x020E,  0x024E  },      //   12    num*
    {   0x0127, 0x019B, 0x020F,  0x024F  },      //   13    num/
	{	0x0128, 0x019C, 0x0210,  0x0250  }, 	 //   14	numenter

	{	0x0000, 0x0000, 0x0000,  0x0000  }		 //   15



};

#define NUMLOCK_NOMAP	((WORD)(-1))


/*** TranslateKey
*
* Purpose:
*
*       Translates a KBDKEY structure into a KEY_INFO structure.
*
*       This is the only function within the editor that knows about
*   the scan codes in the KBDKEY structure. All other editor functions
*   use our own codes (as found in the KEY_INFO structure).
*
* Input:
*       KBDKEY  structure
*
* Returns
*       KEY_INFO structure
*
*
*************************************************************************/

EDITOR_KEY
TranslateKey (
    KBDKEY  kbdi
    ) {

    BYTE            Ascii   =   (BYTE)kbdi.Unicode;
    BYTE            Scan    =   (BYTE)kbdi.Scancode;
    BYTE            Flags   =   0x00;

    DWORD           KbdiFlags   =   kbdi.Flags;

    EDITOR_KEY      k;
    WORD            MepCode     = 0;
	WORD			ControlKey  = 0;
	WORD			Index;


    if (Scan <= LAST_SCAN) {

        if (KbdiFlags & (CONS_LEFT_ALT_PRESSED | CONS_RIGHT_ALT_PRESSED)) {
            Flags       |= FLAG_ALT;
            ControlKey  = ALT_KEY;
        }

        if (KbdiFlags & (CONS_LEFT_CTRL_PRESSED | CONS_RIGHT_CTRL_PRESSED)) {
            Flags       |= FLAG_CTRL;
            //Ascii       &= 0x0F;
            if ( !ControlKey ) {
                ControlKey = CTRL_KEY;
            } else {
                //
                // Foreign keyboard stuff
                //
                if ( Ascii != 0x00 ) {
                    Flags   = 0;
                    ControlKey = 0;
                }
            }
        }

        if (KbdiFlags & CONS_SHIFT_PRESSED) {
            Flags     |= FLAG_SHIFT;
            if ( !ControlKey ) {
                ControlKey  = SHIFT_KEY;
            }
        }


		if (KbdiFlags & CONS_NUMLOCK_PRESSED) {

            Flags |= FLAG_NUMLOCK;

			//
			//	Numlock is set, determine which table to use
			//
			Index = GetNumlockIndex(Scan);

            if (Index == NUMLOCK_NOMAP) {
                //
                //  Key not affected by Numlock, use normal table
                //
                MepCode  = MapTable[Scan][ControlKey];
            } else {
                //
                //  Key is affected by Numlock, use special table
                //
                MepCode   = MapNumlockTable[Index][ControlKey];
            }
        } else {
            //
            //  Numlock not set, use normal table
            //
            MepCode  = MapTable[Scan][ControlKey];
        }
    }

    k.KeyInfo.KeyData.Ascii     =   Ascii;
    k.KeyInfo.KeyData.Scan      =   Scan;
    k.KeyInfo.KeyData.Flags     =   Flags;
    k.KeyInfo.KeyData.Unused    =   0x00;

    if (MepCode) {
        //
        //  Found an MEP code
        //
        k.KeyCode   =   MepCode;
    } else {
        //
        //  Our scan code is within the 256 ASCII characters, form the
        //  KEY_INFO structure and return.
        //
        k.KeyCode   =   Ascii;
    }

    return k;
}





WORD
GetNumlockIndex (
    WORD Scan
    )
{
    switch (Scan) {
        case 0x60:    return 0;      //  num0
        case 0x61:    return 1;      //  num1
        case 0x62:    return 2;      //  num2
        case 0x63:    return 3;      //  num3
        case 0x64:    return 4;      //  num4
        case 0x65:    return 5;      //  num5
        case 0x66:    return 6;      //  num6
        case 0x67:    return 7;      //  num7
        case 0x68:    return 8;      //  num8
        case 0x69:    return 9;      //  num9
        case 0x6D:    return 10;     //  num-
        case 0x6B:    return 11;     //  num+
        case 0x6A:    return 12;     //  num*
        case 0x6F:    return 13;     //  num/
        case 0x6C:    return 14;     //  numenter
        default:      return NUMLOCK_NOMAP;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\tab.c ===
/*** tab.c - perform tabification on output
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"



/*** TabMin - tabify buf, outside of strings
*
*  tabify buf in place and return length. Take into account " and ' chars
*  and remember escaping
*
* Input:
*  tab		= tab stops to entab to
*  src		= source buffer
*  dst		= destination buffer
*
* Output:
*  Returns physical length of buffer
*
*************************************************************************/
int
TabMin (
    int     tab,
    char    *src,
    char    *dst
    )
{
    int      column         = 0;            /* current column offset        */
    char     cQuote;                        /* character that began a quote */
    int      cSpaces;                       /* count of spaces in run       */
    flagType fEscape        = FALSE;        /* TRUE => processing escape    */
    flagType fQuote         = FALSE;        /* TRUE => processing quote     */
    REGISTER char *pDst     = dst;          /* moving ptr into dest         */
    REGISTER char *pSrc     = src;          /* moving ptr into source       */

    /*
     *  while there are characters to output
     */
    while (*pSrc) {

        /*
         *  if we are not quoting or escaping then we collect runs of spaces
         */
        if (!fQuote && !fEscape) {
            cSpaces = 0;

            /*
             * while there are spaces or tabs, collect runs thereof each time we have
             * advanced to a tab boundary output the tab and reset the count of spaces.
             */

            while ((*pSrc == ' ') || (*pSrc == '\t')) {
                if (*pSrc == '\t') {
                    cSpaces = 0;
                    column += tab - (column % tab);
                    *pDst++ = '\t';
                } else {
                    cSpaces++;
                    column++;
                    if ((column % tab) == 0) {
                        *pDst++ = (char)((cSpaces != 1) ? '\t' : ' ');
                        cSpaces = 0;
                    }
                }
                pSrc++;
            }

            /*
             * non-space found. Output remainder of spaces
             */
            while (cSpaces--) {
                *pDst++ = ' ';
            }
        }

        /*
         * determine what state we are in
         */
        if (!fQuote) {
            if (!fEscape) {

                /*
                 * if we are not quoting and we are not escaping, check for quoted strings and
                 * escaped characters.
                 */
                if (*pSrc == '"' || *pSrc == '\'') {
                    cQuote = *pSrc;
                    fQuote = TRUE;
                } else if (*pSrc == '\\') {
                    fEscape = TRUE;
                }
            } else {
                //
                //  We are not quoting. If we are escaping, reset escape.
                fEscape = FALSE;
            }
         } else if (!fEscape) {
            //
            //  In a quote, not escaping, check for end of quote, or
            //  beginning of escape
            //
            if (*pSrc == cQuote) {
                fQuote = FALSE;
            } else if (*pSrc == '\\') {
                fEscape = TRUE;
            }
         } else {
            //
            // Inside quote and inside escape, just reset escape mode
            //
            fEscape = FALSE;
        }

        /*
         * Finally, output the character
         */
        if (*pSrc) {
            *pDst++ = *pSrc++;
            column++;
        }
    }

    /*
     * terminate the destination string, and return
     */
    *pDst = 0;
    return (int)(pDst-dst);
}





/*** TabMax - tabify line regardless of content
*
* Input:
*  tab		= tab stops to entab to
*  src		= source buffer
*  dst		= destination buffer
*
* Output:
*  Returns physical length of buffer
*
*************************************************************************/
int
TabMax (
    int     tab,
    char    *src,
    char    *dst
    )
{

    int      column         = 0;            /* current column offset        */
    unsigned cSpaces;                       /* count of spaces in run       */
    REGISTER char *pDst     = dst;          /* moving ptr into dest         */
    REGISTER char *pSrc     = src;          /* moving ptr into source       */

    /*
     * while there are characters to output
     */
    while (*pSrc) {
        cSpaces = 0;

        /*
         * coallesce runs of spaces while there are spaces to coallesce
         */
        while ((*pSrc == ' ') || (*pSrc == '\t')) {
            if (*pSrc == '\t') {
                cSpaces = 0;
                column += tab - (column % tab);
                *pDst++ = '\t';
            } else {
                cSpaces++;
                column++;

                /*
                 * if we have advanced to a tab boundary output a tab & reset the count of
                 * spaces
                 */
                if ((column % tab) == 0) {
                    *pDst++ = (char)((cSpaces != 1) ? '\t' : ' ');
                    cSpaces = 0;
                }
            }
            pSrc++;
        }

        /*
         * output remainder of spaces
         */
        while (cSpaces--) {
            *pDst++ = ' ';
        }

        /*
         * Finally copy the character
         */
        if (*pSrc) {
            *pDst++ = *pSrc++;
            column++;
        }
    }

    *pDst = 0;
    return (int)(pDst-dst);
}




/*** SetTabDisp - tabdisp switch setting function
*
*  set character displayed for tabs to a new character
*
* Input:
*  Standard switch setting routine: ptr to string
*
* Output:
*  Returns TRUE
*
*************************************************************************/
flagType
SetTabDisp (
    char * val
    )
{
	char   NewVal;

	if ((NewVal = (char)atoi(val)) == 0) {
		NewVal = ' ';
	}

	tabDisp = NewVal;
	newscreen ();

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\show.c ===
/*** show.c - useful information displays
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/
#include "mep.h"
#include "cmds.h"


/*** showasg - construct the <assign> file
*
* Input:
*  pFile        = pFile to contruct it in
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
showasg (
    PFILE   pFile
    )
{
    int     i, j;
    PSWI    pSwi;
    linebuf tempbuf;
    extern unsigned char Int16CmdBase;

    /*
     * if now new assignments have been made (and file isn't empty), then don't
     * refresh the contents!
     */
    if (!fNewassign && pFile->cLines) {
        return;
    }

    fNewassign = FALSE;
    pFileAssign = pFile;
    DelFile (pFile, FALSE);

    /*
     * Write header to assign file
     */
    appmsgs (MSG_ASSIGN_HDR, pFile);
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * Start editor section on intrinsic functions with editor name, comment, and
     * dump the functions.
     */
    zprintf (pFile, pFile->cLines, "[%s]", pNameEditor);
    AppFile (GetMsg (MSG_ASG_FUNC, tempbuf), pFile);
    AppFile ((char *)rgchEmpty, pFile);
    for (i = 0; cmdSet[0][i].name; i++) {
        FuncOut (&cmdSet[0][i], pFile);
    }
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * The section on macros
     */
    AppFile (GetMsg (MSG_ASG_MACROS, tempbuf), pFile);
    AppFile ((char *)rgchEmpty, pFile);
    for (i = 0; i < cMac; i++) {
        FuncOut (rgMac[i], pFile);
    }
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * section specfic to each extension
     */
    for (i = 1; i < cCmdTab; i++) {
        zprintf (pFile, pFile->cLines, "[%s-%s]", pNameEditor, pExtName[i]);
        AppFile ((char *)rgchEmpty, pFile);
        for (j = 0; cmdSet[i][j].name; j++) {
            FuncOut (&cmdSet[i][j], pFile);
        }
        AppFile ((char *)rgchEmpty, pFile);
    }

    /*
     * Write available keys header
     */
    appmsgs (MSG_KEYS_HDR1, pFile);
    UnassignedOut (pFile);
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * Remember the start of the switches section, and dump that header
     */
    lSwitches = pFile->cLines - 1;
    appmsgs (MSG_SWITCH_HDR, pFile);

    for (i = 0; i < cCmdTab; i++) {

        if (i) {
                zprintf (pFile, pFile->cLines, "[%s-%s]", pNameEditor, pExtName[i]);
        } else {
            zprintf (pFile, pFile->cLines, "[%s]", pNameEditor);
        }

            AppFile (GetMsg(MSG_ASG_NUMER, tempbuf), pFile);
            AppFile ((char *)rgchEmpty, pFile);

        for (pSwi = swiSet[i]; pSwi->name != NULL; pSwi++) {

                if ((pSwi->type & 0xFF) == SWI_NUMERIC ||
                        (pSwi->type & 0xFF) == SWI_SCREEN) {

                if ((pSwi->type & 0xFF00) == RADIX16) {
                            zprintf (pFile, pFile->cLines, "%20Fs:%x", pSwi->name, *pSwi->act.ival);
                } else {
                    zprintf (pFile, pFile->cLines, "%20Fs:%d", pSwi->name, *pSwi->act.ival);
                }

            } else if ((i == 0) && (pSwi->type & 0xFF) >= SWI_SPECIAL) {

                if (pSwi->act.pFunc2 == SetFileTab) {
                    j = fileTab;
                } else if (pSwi->act.pFunc == SetTabDisp) {
                            j = (unsigned char)tabDisp;
                } else if (pSwi->act.pFunc == SetTrailDisp) {
                            j = (unsigned char)trailDisp;
                } else if (pSwi->act.pFunc == (PIF)SetCursorSizeSw ) {
                    j = CursorSize;
                } else {
                    continue;
                }

                        zprintf (pFile, pFile->cLines, "%20Fs:%ld", pSwi->name, (long)(unsigned)j);
            }
        }

            AppFile ((char *)rgchEmpty, pFile);

            AppFile (GetMsg(MSG_ASG_BOOL,tempbuf), pFile);
            AppFile ((char *)rgchEmpty, pFile);

        for (pSwi = swiSet[i]; pSwi->name != NULL; pSwi++) {
            if ((pSwi->type & 0xFF) == SWI_BOOLEAN) {
                zprintf (pFile, pFile->cLines, "%20Fs:%s", pSwi->name, *pSwi->act.fval ? "yes" : "no");
            }
        }

            AppFile ((char *)rgchEmpty, pFile);

            if (i == 0) {
                AppFile (GetMsg(MSG_ASG_TEXT,tempbuf), pFile);
                AppFile ((char *)rgchEmpty, pFile);

                zprintf (pFile, pFile->cLines, "%11s:%s", "backup",
                                backupType == B_BAK ? "bak" : backupType == B_UNDEL ? "undel" : "none");

                ShowMake (pFile);
            if (pFileMark) {
                zprintf (pFile, pFile->cLines, "%11s:%s", "markfile", pFileMark->pName);
            }
            zprintf (pFile, pFile->cLines, "%11s:%s", "printcmd", pPrintCmd ? pPrintCmd : "");
            zprintf (pFile, pFile->cLines, "%11s:%s", "readonly", ronlypgm ? ronlypgm : "");
                AppFile ((char *)rgchEmpty, pFile);

        }
    }

    FTYPE(pFile) = TEXTFILE;
    RSETFLAG (FLAGS(pFile), DIRTY);
}



/*** appmsgs - append series of text messages to pFile
*
*  Appends a series of text strings to the passed pFile
*
* Input:
*  iMsg         - Starting message number
*  pFile        - pFile to append to
*
* Output:
*  Returns
*
*************************************************************************/
void
appmsgs (
    int     iMsg,
    PFILE   pFile
    )
{
    linebuf tempbuf;

    while (TRUE) {
        GetMsg (iMsg++,tempbuf);
        if (tempbuf[0] == '?') {
            break;
        }
        AppFile (tempbuf, pFile);
    }
}


static char szEmptyClipboard[] = "The clipboard is empty";


/*** showinf - construct <information-file>
*
* Input:
*  pFile        - pFile to construct in
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
showinf (
    PFILE pFile
    )
{
    PFILE pFileTmp;

    DelFile (pFile, FALSE);
    SETFLAG (FLAGS(pFile), READONLY);
    AppFile (Name, pFile);
    AppFile (Version, pFile);
    AppFile ((char *)rgchEmpty, pFile);
    RSETFLAG (FLAGS(pFile), DIRTY);
    for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext) {
        infprint (pFileTmp, pFile);
    }
    AppFile ((char *)rgchEmpty, pFile);
    if (pFilePick->cLines == 0) {
        AppFile (szEmptyClipboard, pFile);
    } else {
        zprintf (pFile, pFile->cLines, "%ld line%s in %s clipboard", pFilePick->cLines,
                 pFilePick->cLines == 1 ? (char *)rgchEmpty : "s",
                 kindpick == STREAMARG ? "stream" : kindpick == LINEARG ? "line" :
                 kindpick == BOXARG ? "box" : "?");
    }
    AppFile ((char *)rgchEmpty, pFile);
    FTYPE(pFile) = TEXTFILE;
    RSETFLAG (FLAGS(pFile), DIRTY);
}




/*** infprint - print info about 1 file
*
*  Appends to the information file the info on 1 file
*
* Input:
*  pFile        - pFile of interest
*  pFileDisplay - pFile to display in
*
* Output:
*  Returns FALSE
*
*************************************************************************/
flagType
infprint (
    PFILE pFile,
    PFILE pFileDisplay
    )
{
    if (TESTFLAG(FLAGS(pFile),REAL)) {
        zprintf (pFileDisplay, pFileDisplay->cLines, "%-30s %c%ld lines", pFile->pName,
                       TESTFLAG(FLAGS(pFile),DIRTY) ? '*' : ' ',
                       pFile->cLines);
    } else {
        zprintf (pFileDisplay, pFileDisplay->cLines, "%-20s", pFile->pName);
    }
    return FALSE;
}




/*** information - show editting history
*
*  Display the information file
*
* Input:
*  standard editing function
*
* Output:
*  Returns TRUE on successfull display
*
*************************************************************************/
flagType
information (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    AutoSave ();
    return fChangeFile (FALSE, rgchInfFile);

    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\table.c ===
/***  table.c - function tables for editor
*
*   Modifications:
*
*	26-Nov-1991 mz	Strip off near/far
*
*  IMPORTANT:  cmdTable and swiTable MUST be sorted according to name of the
*  command/switch.  The table searching logic in ASSIGN.C will break otherwise.
*
*  IMPORTANT:  The names in cmdTable and SwiTable MUST be in lower case.
*************************************************************************/

#include "mep.h"


// #define toPIF(x)  (PIF)(long)(void *)&x

/*  short form to allow compact table description
 */
#define ANO     NOARG
#define ATXT    TEXTARG
#define ANUL    NULLARG
#define ALIN    LINEARG
#define ASTR    STREAMARG
#define ABOX    BOXARG
#define ANUM    NUMARG
#define AMRK    MARKARG

#define AEOL    NULLEOL
#define AEOW    NULLEOW
#define ABST    BOXSTR
#define FK	FASTKEY

#define MD      MODIFIES
#define KM      KEEPMETA
#define WFN     WINDOWFUNC
#define CFN     CURSORFUNC

/*  names of internal editor functions
 *
 *  Each function has a definition of how arguments are to be processed.
 *  This definition is comprised of a bitmap describing which arguments are
 *  legal and, if so, how they are to be interpreted.  The definitions are:
 *
 *
 *  MODIFIES    MD      The function will modify the contents of the file being
 *                      editted.
 *
 *  KEEPMETA    KM      The function being executed does not take the <meta>
 *                      prefix.  The state of the <meta> flag is preserved
 *                      across this editor function.
 *
 *  CURSORFUNC  CFN     The function being executed is a cursor movement
 *                      function.  It is allowed within the context of
 *                      an <arg> to select a file range on the screen; it
 *                      cannot take an <arg>.  It does not remove highlighting
 *                      that is present on the screen.
 *
 *  WINDOWFUNC  WFN     The function being executed is a window movement
 *                      function.  It does not remove highlighting that is
 *                      present on the screen.
 *
 *  NOARG       ANO     The function accepts the absence of an <arg> function.
 *                      When called the function receives a pointer to a
 *                      structure containing the location where the function
 *                      is expected to be applied.
 *
 *  TEXTARG     ATXT    The function accepts a textual argument that may
 *                      be typed in or selected on the screen.  The function is
 *			called with a pointer to the asciz text of the
 *                      argument.  See NULLEOL, NULLEOW, BOXSTR.
 *
 *  NULLARG     ANUL    The function accepts an <arg> with no discernable
 *                      cursor movement (cursor is on <arg> position).  The
 *                      function is called with a pointer to a structure
 *                      containing the location of the arg within the file.
 *
 *  NULLEOL     AEOL    The function accepts an <arg> with no discernable
 *                      cursor movement (cursor is on <arg> position).  The
 *                      function is called with a pointer to a structure
 *                      indicating TEXTARG and containing a pointer to the
 *                      asciz text of the line from the cursor to end-of-line.
 *
 *  NULLEOW     AEOW    The function accepts an <arg> with no discernable
 *                      cursor movement (cursor is on <arg> position).  The
 *                      function is called with a pointer to a structure
 *                      indicating TEXTARG and containing a pointer to the
 *                      asciz text of the line from the cursor to the next
 *                      whitespace.
 *
 *  LINEARG     ALIN    The function accepts an <arg> that is in the same
 *                      column as the cursor.  The function is expected to be
 *                      applied to all lines beginning in the range <arg> to
 *                      cursor inclusive.  The function is called with a
 *                      pointer to a structure containing the beginning
 *                      line of the range and the ending line of the range
 *
 *  STREAMARG   ASTR    The function accepts an <arg> that is considered to
 *                      apply beginning at a specific file location and
 *                      proceeding through all intervening lines and line-
 *                      breaks up until just to the left of the ending file
 *                      position.  The function is called with a pointer to
 *                      a structure containing the beginning point of the range
 *                      and the first point just beyond the end of the range.
 *
 *  BOXARG      ABOX    The function accepts an <arg> that is considered to
 *                      apply to a rectangle on the screen.  The function is
 *                      called with a pointer to a structure containing the
 *                      left and right column boundaries (inclusive) and the
 *                      top and bottom line numbers (inclusive) that describe
 *                      the region.
 *
 *  BOXSTR      ABST    If a BOXARG is presented to the function and the box
 *                      contains only a single line, the function is called
 *                      with a pointer to a structure marked TEXTARG and
 *			containing a pointer to the selection as an asciz
 *                      string.
 *
 *  NUMARG      ANUM    If text was specified and is numeric, it is considered
 *                      to represent a number of lines offset from the cursor
 *                      and represents the other end of an arg.  The
 *                      above tests are then applied, excluding TEXTARG.
 *
 *  MARKARG     AMRK    If text was specified and interpreted as a mark, it is
 *                      considered to be the other end of an arg.  The above
 *			tests are then applied, excluding TEXTARG.
 *
 *  FASTKEY	FK	The command will be repeated while the user holds down
 *			the invoking key.
 */

struct cmdDesc cmdTable[] = {
/*			     0|KM|CFN|WFN|ANO|ATXT|ANUL|AEOL|AEOW|ALIN|ASTR|ABOX|ABST|ANUM|AMRK|MD|FK*/
{"arg",        doarg,	   0,0|KM								     },
{"assign",     assign,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN	   |ABOX|ABST|ANUM|AMRK      },
{"backtab",    backtab,    0,0	 |CFN								     },
{"begfile",    begfile,    0,0	 |CFN								     },
{"begline",    begline,    0,0	 |CFN								     },
{"boxstream",  BoxStream,  0,0	 |CFN								     },
{"cancel",     cancel,	   0,0		 |ANO|ATXT|ANUL 	 |ALIN|ASTR|ABOX		     },
{"cdelete",    cdelete,    0,0	 |CFN							       |MD   },
{"compile",    compile,    0,0		 |ANO|ATXT|ANUL 			|ABST		     },
{"copy",       zpick,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN|ASTR|ABOX     |ANUM|AMRK      },
{"curdate",    curdate,    0,0		 |ANO						       |MD   },
{"curday",     curday,	   0,0		 |ANO						       |MD   },
{"curtime",    curtime,    0,0		 |ANO						       |MD   },
{"delete",     delete,     0,0           |ANO     |ANUL           |ALIN|ASTR|ABOX              |MD   },
{"down",       down,	   0,0	 |CFN								  |FK},
{"emacscdel",  emacscdel,  0,0		 |ANO						       |MD   },
{"emacsnewl",  emacsnewl,  0,0		 |ANO						       |MD   },
{"endfile",    endfile,    0,0	 |CFN								     },
{"endline",    endline,    0,0	 |CFN								     },
{"environment",environment,0,0		 |ANO|ATXT|ANUL 	 |ALIN	   |ABOX		     },
{"execute",    zexecute,   0,0		     |ATXT     |AEOL	 |ALIN		|ABST|ANUM	     },
{"exit",       zexit,	   0,0		 |ANO	  |ANUL 					     },
{"graphic",    graphic,    0,0		 |ANO			 |ALIN|ASTR|ABOX		    |MD   },
{"home",       home,	   0,0	 |CFN								     },
{"information",information,0,0		 |ANO							     },
{"initialize", zinit,	   0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"insert",     insert,	   0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX	       |MD   },
{"insertmode", insertmode, 0,0		 |ANO							     },
{"lastselect", lastselect, 0,0|KM	 |ANO							     },
{"lasttext",   lasttext,   0,0|KM	 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX		     },
{"ldelete",    ldelete,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"left",       left,	   0,0	 |CFN								  |FK},
{"linsert",    linsert,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"mark",       mark,	   0,0		 |ANO|ATXT|ANUL 			|ABST		     },
{"message",    zmessage,   0,0           |ANO|ATXT|ANUL          |ALIN|ASTR|ABOX                     },
{"meta",       meta,	   0,0|KM								     },
{"mgrep",      mgrep,	   0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"mlines",     mlines,	   0,0	     |WFN|ANO|ATXT|ANUL 					  |FK},
{"mpage",      mpage,	   0,0	 |CFN								  |FK},
{"mpara",      mpara,	   0,0	 |CFN								  |FK},
{"mreplace",   mreplace,   0,0		 |ANO	  |ANUL 				       |MD   },
{"msearch",    msearch,    0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"mword",      mword,	   0,0	 |CFN								  |FK},
{"newline",    newline,    0,0	 |CFN								     },
{"nextmsg",    nextmsg,    0,0		 |ANO|ATXT|ANUL 					     },
{"noedit",     noedit,	   0,0	 |CFN								     },
{"noop",		noop,	   0,0		 |ANO			 |ALIN|ASTR|ABOX			|MD   },
{"paste",      put,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN|ASTR|ABOX		|MD   },
{"pbal",       pbal,	   0,0		 |ANO	  |ANUL 				       |MD   },
{"plines",     plines,	   0,0	     |WFN|ANO|ATXT|ANUL 					  |FK},
{"ppage",      ppage,	   0,0	 |CFN								  |FK},
{"ppara",      ppara,	   0,0	 |CFN								  |FK},
{"print",      zPrint,	   0,0		 |ANO|ATXT		 |ALIN|ASTR|ABOX		     },
{"prompt",     promptarg,  0,0|KM	 |ANO|ATXT		 |ALIN|ASTR|ABOX		     },
{"psearch",    psearch,    0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"pword",      pword,	   0,0	 |CFN								  |FK},
{"qreplace",   qreplace,   0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"quote",      quote,	   0,0		 |ANO			 |ALIN|ASTR|ABOX	       |MD   },
{"record",     record,	   0,0		 |ANO|ATXT|ANUL 					     },
{"refresh",    refresh,    0,0		 |ANO	  |ANUL 					     },
{"repeat",     repeat,	   0,0		 |ANO							     },
{"replace",    zreplace,   0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"restcur",    restcur,    0,0           |ANO                                                        },
{"right",      right,	   0,0	 |CFN								  |FK},
{"saveall",    saveall,    0,0		 |ANO							     },
{"savecur",    savecur,    0,0		 |ANO							     },
{"savetmpfile",	savetmpfile,	0,0		 |ANO								 },
{"sdelete",    sdelete,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX	       |MD   },
{"searchall",  searchall,  0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"setfile",    setfile,    0,0           |ANO|ATXT|ANUL                         |ABST                },
{"setwindow",  setwindow,  0,0		 |ANO	  |ANUL 					     },
{"shell",      zspawn,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN	   |ABOX		     },
{"sinsert",    sinsert,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX	       |MD   },
{"tab",        tab,	   0,0	 |CFN								     },
{"tell",       ztell,	   0,0		 |ANO|ATXT|ANUL 					     },
{"unassigned", unassigned, 0,0		 |ANO|ATXT|ANUL 	 |ALIN|ASTR|ABOX		     },
{"undo",       zundo,	   0,0		 |ANO							     },
{"up",	       up,	   0,0	 |CFN								  |FK},
{"window",     window,     0,0           |ANO     |ANUL                                              },
{NULL,         NULL,       0,0                                                                       }
    };



/* names of switches */
struct swiDesc swiTable[] = {
    {   "askexit",          toPIF(fAskExit),            SWI_BOOLEAN },
    {   "askrtn",           toPIF(fAskRtn),             SWI_BOOLEAN },
    {   "autosave",         toPIF(fAutoSave),           SWI_BOOLEAN },
    {	"backup",	    (PIF)SetBackup,		SWI_SPECIAL2 },
	{	"case", 		toPIF(fSrchCaseSwit),	SWI_BOOLEAN },
	{	"cursorsize",		(PIF)SetCursorSizeSw,		SWI_SPECIAL2 },
#if DEBUG
    {   "debug",            toPIF(debug),               SWI_NUMERIC  | RADIX10},
#endif
    {   "displaycursor",    toPIF(fDisplayCursorLoc),   SWI_BOOLEAN },
    {	"editreadonly",     toPIF(fEditRO),		SWI_BOOLEAN },
    {   "entab",            toPIF(EnTab),               SWI_NUMERIC  | RADIX10},
    {	"enterboxmode",     toPIF(fBoxArg),		SWI_BOOLEAN },
    {   "enterinsmode",     toPIF(fInsert),             SWI_BOOLEAN },
    {   "errcolor",         toPIF(errColor),            SWI_NUMERIC  | RADIX16},
    {	"errprompt",	    toPIF(fErrPrompt),		SWI_BOOLEAN },
    {	"extmake",	    (PIF)SetExt,		SWI_SPECIAL2 },
    {   "fgcolor",          toPIF(fgColor),             SWI_NUMERIC  | RADIX16},
    {	"filetab",	    (PIF)SetFileTab,		SWI_SPECIAL2 },
    {	"height",	    toPIF(YSIZE),		SWI_SCREEN  },
    {   "hgcolor",          toPIF(hgColor),             SWI_NUMERIC  | RADIX16},
    {   "hike",             toPIF(hike),                SWI_NUMERIC  | RADIX10},
    {   "hscroll",          toPIF(hscroll),             SWI_NUMERIC  | RADIX10},
    {   "infcolor",         toPIF(infColor),            SWI_NUMERIC  | RADIX16},
    {	"keyboard",	    (PIF)SetKeyboard,		SWI_SPECIAL },
    {	"load", 	    (PIF)SetLoad,		SWI_SPECIAL2 },
    {	"markfile",	    (PIF)SetMarkFile,		SWI_SPECIAL2 },
    {	"msgflush",	    toPIF(fMsgflush),		SWI_BOOLEAN },
    {   "noise",            toPIF(cNoise),              SWI_NUMERIC  | RADIX10},
    {	"printcmd",	    SetPrintCmd,		SWI_SPECIAL },
    {   "readonly",         SetROnly,                   SWI_SPECIAL },
    {	"realtabs",	    toPIF(fRealTabs),		SWI_BOOLEAN },
    {   "rmargin",          toPIF(xMargin),             SWI_NUMERIC  | RADIX10},
    {   "savescreen",       toPIF(fSaveScreen),         SWI_BOOLEAN },
    {	"searchwrap",	    toPIF(fSrchWrapSwit),	SWI_BOOLEAN },
    {	"selcolor",	    toPIF(selColor),		SWI_NUMERIC  | RADIX16},
    {   "shortnames",       toPIF(fShortNames),         SWI_BOOLEAN },
    {   "snow",             toPIF(fCgaSnow),            SWI_BOOLEAN },
    {   "softcr",           toPIF(fSoftCR),             SWI_BOOLEAN },
    {   "stacolor",         toPIF(staColor),            SWI_NUMERIC  | RADIX16},
    {	"tabalign",	    toPIF(fTabAlign),		SWI_BOOLEAN },
    {	"tabdisp",	    SetTabDisp, 		SWI_SPECIAL },
    {   "tabstops",         toPIF(tabstops),            SWI_NUMERIC  | RADIX10},
    {   "tmpsav",           toPIF(tmpsav),              SWI_NUMERIC  | RADIX10},
    {   "traildisp",        SetTrailDisp,               SWI_SPECIAL },
    {   "trailspace",       toPIF(fTrailSpace),         SWI_BOOLEAN },
    {	"undelcount",	    toPIF(cUndelCount), 	SWI_NUMERIC  | RADIX10},
    {   "undocount",        toPIF(cUndo),               SWI_NUMERIC  | RADIX10},
    {   "unixre",           toPIF(fUnixRE),             SWI_BOOLEAN },
    {   "usemouse",         toPIF(fUseMouse),           SWI_BOOLEAN },
    {   "viewonly",         toPIF(fGlobalRO),           SWI_BOOLEAN },
    {   "vscroll",          toPIF(vscroll),             SWI_NUMERIC  | RADIX10},
    {	"wdcolor",	    toPIF(wdColor),		SWI_NUMERIC  | RADIX16},
    {	"width",	    toPIF(XSIZE),		SWI_SCREEN  },
    {   "wordwrap",         toPIF(fWordWrap),           SWI_BOOLEAN },
    {   NULL,               NULL,                       0 }
    };
/* c keyword table for softcr routine */
char * cftab[] = {
    "if"        ,
    "else"      ,
    "for"       ,
    "while"     ,
    "do"        ,
    "case"      ,
    "default"   ,
    NULL
    };

/* file type table.  Z identifies files by their extention.  Many extentions
 * can be a single type.  The soft tabbing algorithms and the compile commands
 * are driven by this mechanism.
 */
struct fTypeInfo ftypetbl[] = {
    {   "c",    CFILE       },
    {   "h",    CFILE       },
    {   "asm",  ASMFILE     },
    {   "inc",  ASMFILE     },
    {   "pas",  PASFILE     },
    {   "for",  FORFILE     },
    {   "lsp",  LSPFILE     },
    {   "bas",  BASFILE     },
    {   NULL,   TEXTFILE    }
    };

/*  mpTypepName - pointers to the textual names of each type
 */
char * mpTypepName[] =
    {   "text",                         /*  #define TEXTFILE    0             */
        "C",                            /*  #define CFILE       1             */
        "macro",                        /*  #define ASMFILE     2             */
        "pascal",                       /*  #define PASFILE     3             */
        "fortran",                      /*  #define FORFILE     4             */
        "lisp",                         /*  #define LSPFILE     5             */
        "BASIC"                         /*  #define BASFILE     6             */
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\untab.c ===
#include    <string.h>
#include	<stdlib.h>
#include    "mep.h"

extern int		fileTab;
extern flagType	fRealTabs;


/***************************************************************************\

MEMBER:     Untab

SYNOPSIS:   Expand tabs in line

ALGORITHM:  

ARGUMENTS:  int 	- number of characters per tab
	    const char* - pointer to source line
	    int 	- number of chars in source line
	    char*	- pointer to destination line
	    char	- replacement character for tab

RETURNS:    int     - length of untabbed line

NOTES:	    

HISTORY:    13-Jul-90 davegi
		Saved pDst and computed return value from it rather tha pDst
	    28-Jul-90 davegi
		Converted from 286 MASM
	    18-Mar-1992 markz
		Untab at most BUFLEN chars

KEYWORDS:   

SEEALSO:    

\***************************************************************************/

int
Untab (
    int 	cbTab,
    const char*	pSrc,
    int 	cbSrc,
    char*	pDst,
    char	cTab
    )
{
    
    const char*	pSrcStart;
    const char* pDstStart;
    int         i;
    int 	ccTab;
    char	buffer[128];
    
    assert( pSrc );
    assert( pDst );

    if (( size_t )strlen(pSrc) != ( size_t ) cbSrc ) {
        sprintf(buffer, "\nWARNING: strlen(pSrc) [%d] != cbSrc [%d]\n", strlen(pSrc), cbSrc);
        OutputDebugString(buffer);
        sprintf(buffer, "File %s, line %d\n", __FILE__, __LINE__ );
        OutputDebugString(buffer);
        cbSrc = (int)strlen(pSrc);
    }

    // assert( strlen( pSrc ) >= ( size_t ) cbSrc );
    
    //  Short circuit...
    //  If there are no tabs in the source, copy the source to the destination
    //  and return the supplied number of characters in the source (destination)
    
    if( ! strchr( pSrc, '\t' )) {
        strcpy( pDst, pSrc );
        return cbSrc;
    }
    
    //  Remember where we started
    
    pSrcStart = pSrc;
    pDstStart = pDst;

    //  While we are not at the end of the source copy a character from the
    //  source to the destination
    
    while (*pSrc  && pDst < pDstStart + BUFLEN - 1) {
        if (( *pDst++ = *pSrc++ ) == '\t' ) {

                //  If the character copied was a tab, replace it with the
                //  appropriate number of cTab characters

                pDst--;
                ccTab = (int)(cbTab - (( pDst - pDstStart ) % cbTab ));

            for( i = 0; i < ccTab && pDst < pDstStart + BUFLEN - 1; i++ ) {
                    *pDst++ = cTab;
            }
	    }
	}

    *pDst = '\0';	// Terminating NUL
    
    //return strlen( pDstStart );
    return (int)(pDst - pDstStart);
}





/***************************************************************************\

MEMBER:     AlignChar

SYNOPSIS:   Get logical starting column of character

ALGORITHM:  

ARGUMENTS:  COL 	-
	    const char*	-

RETURNS:    COL	    - starting column of character

NOTES:	    

HISTORY:
		03-Jul-91 ramonsa
		re-converted from 286 MASM
		20-Aug-90 davegi
		Return the supplied column when end of buffer is reached
	    14-Aug-90 davegi
		Return supplied column when it's passed the end of the buf
	    28-Jul-90 davegi
		Converted from 286 MASM\

KEYWORDS:   

SEEALSO:    

\***************************************************************************/

COL
AlignChar (
	COL			col,
    const char*	buf
    )
{
	register	int		CurCol;
	register	int		NextCol;
				int 	NewCurCol;
				char	Char;


	CurCol = col;

	//
	//	If we are not using real tabs, we just return supplied column,
	//	otherwise we figure out the column position.
	//
	if ( fRealTabs ) {

		NextCol = 0;

		while ( NextCol <= col ) {

			Char = *buf++;

			if ( Char == '\0' ) {
				//
				//	Reached end of file, return the supplied column
				//
				CurCol = col;
				break;
			}

			CurCol = NextCol;

			if ( Char == '\t' ) {

				NewCurCol = NextCol;

				CurCol += fileTab;

				NextCol = CurCol - ( CurCol % fileTab);

				CurCol = NewCurCol;

			} else {

				NextCol++;

			}
		}
	}

	return CurCol;

}




/***************************************************************************\

MEMBER:     pLog

SYNOPSIS:   Return a physical pointer given a logical offset

ALGORITHM:  

ARGUMENTS:  

RETURNS:    char*	- pointer into pBuf

NOTES:	    This is a many to one mapping due to tabs. That is, many logical
	    offsets may point to the same physical pointer if they point
	    to within a fileTab of a tab character.

HISTORY:    13-Aug-90 davegi
		Fixed return value when no tabs are present in line
		Fixed return value when first char is a tab
	    10-Aug-90 davegi
		Fixed return value when xOff is negative
	    28-Jul-90 davegi
		Converted from 286 MASM

KEYWORDS:   

SEEALSO:    

\***************************************************************************/

char*
pLog (
    char*       pBuf,
    int 	xOff,
    flagType	fBound
    )
{
    
    REGISTER char *pLast;
    REGISTER int   cbpBuf;
    int            cbpBufNext;
    
    assert( pBuf );
    
    //  If xOff is 0 return pBuf

    if( xOff == 0 ) {
        return pBuf;
    }

    //  If xOff is negative return pBuf - 1

    if( xOff < 0 ) {
	return pBuf - 1;
    }

    //  If we're not using real tabs, return the physical pointer which is
    //  at the (possibly bounded) logical offset
    
    if( ! fRealTabs ) {
        
        //  If required, bound the return value by the line length
   
        if( fBound ) {
            xOff = min(( size_t ) xOff, strlen( pBuf ));
        }
 
	return ( char* ) &( pBuf[ xOff ]);
    }

    if( ! strchr( pBuf, '\t' )) {

        //  If xOff is past the end of the line,
        //  return the physical pointer which is at the (possibly bounded)
        //  logical offset

        if( xOff > ( cbpBuf = strlen( pBuf ))) {
            if( fBound ) {
                xOff = cbpBuf;
            }
        }
        return ( char* ) &( pBuf[ xOff ]);
    }


    //  pLast:   last physical position in buffer;
    //  cbpBuf:  Last LOGICAL offset within buffer;
    //  cbpNext: Next LOGICAL offset within buffer
    //           (i.e. cbpBuf + tab)


    pLast  = pBuf;
    cbpBuf = 0;
    while (pBuf = strchr(pBuf, '\t')) {
        cbpBuf += (int)(pBuf - pLast);
        if (xOff < cbpBuf) {
            /*
             *  We're past the wanted column. Adjust and return
             *  pointer.
             */
            cbpBuf -= (int)(pBuf - pLast);
            return (char *)pLast + xOff - cbpBuf;
        }
        cbpBufNext = cbpBuf + fileTab -  (cbpBuf + fileTab)%fileTab;
        if ((cbpBuf <= xOff) && (xOff < cbpBufNext)) {
            /*
             *  Wanted column lies within this tab. return current
             *  position.
             */
            return (char *)pBuf;
        }
        pLast = ++pBuf;             // Skip this tab and continue
        cbpBuf  = cbpBufNext;
    }

    //  No more tabs in buffer. If wanted column is past the end of the
    //  buffer, return pointer based on fBound. Otherwise the
    //  physical column is (xOff - cbpBuf) positions from pLast.

    pBuf = pLast + strlen(pLast);
    cbpBufNext = (int)(cbpBuf + pBuf - pLast);
    if (xOff > cbpBufNext) {
        if (fBound) {
            return (char *)pBuf;
        }
    }
    return (char *)pLast + xOff - cbpBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\window.c ===
/**** window.c - window movement commands
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"

#define DEBFLAG WINDOW


void
saveflip (
    void
    )
{
    XOLDCUR(pInsCur) = XCUR(pInsCur);
    YOLDCUR(pInsCur) = YCUR(pInsCur);
    XOLDWIN(pInsCur) = XWIN(pInsCur);
    YOLDWIN(pInsCur) = YWIN(pInsCur);
}





void
restflip (
    void
    )
{
    doscreen( XOLDWIN(pInsCur), YOLDWIN(pInsCur),
	      XOLDCUR(pInsCur), YOLDCUR(pInsCur) );
}





void
movewin (
    COL  x,
    LINE y
    )
{
    doscreen( x, y, XCUR(pInsCur), YCUR(pInsCur) );
}





flagType
setwindow (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    switch (pArg->argType) {

    case NOARG:
	if (fMeta) {
            soutb (0, (int)(YCUR(pInsCur)-YWIN(pInsCur)), rgchEmpty, fgColor);
	    redraw (pFileHead, YCUR(pInsCur), YCUR(pInsCur));
	    SETFLAG( fDisplay, RCURSOR );
        } else {
	    newscreen ();
	    SETFLAG( fDisplay, RSTATUS | RCURSOR );
        }
        return TRUE;

    /*  TEXTARG illegal             */

    case NULLARG:
	movewin (XCUR(pInsCur), YCUR(pInsCur));
        return TRUE;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }

    return FALSE;

    argData;
}




flagType
plines (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer mbuf;

    switch (pArg->argType) {

    case NOARG:
	movewin (XWIN(pInsCur), YWIN(pInsCur) + YSCALE (vscroll));
        return TRUE;

    case TEXTARG:
	strcpy ((char *) mbuf, pArg->arg.textarg.pText);
	if (fIsNum (mbuf)) {
	    movewin ( XWIN(pInsCur), YWIN(pInsCur) + atol (mbuf));
	    return TRUE;
        } else {
            return BadArg ();
        }

    case NULLARG:
	movewin( XWIN(pInsCur), YCUR(pInsCur) );
        return TRUE;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }

    return FALSE;

    argData; fMeta;
}




flagType
mlines (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer mbuf;

    switch (pArg->argType) {

    case NOARG:
	movewin (XWIN(pInsCur), YWIN(pInsCur) - YSCALE (vscroll));
        return TRUE;

    case TEXTARG:
	strcpy ((char *) mbuf, pArg->arg.textarg.pText);
	if (fIsNum (mbuf)) {
	    movewin (XWIN(pInsCur), YWIN(pInsCur) - atol (mbuf));
	    return TRUE;
        } else {
            return BadArg ();
        }

    case NULLARG:
	movewin (XWIN(pInsCur), YCUR(pInsCur)-(WINYSIZE(pWinCur)-1));
        return TRUE;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }

    return FALSE;

    argData; fMeta;
}





/*
 * <window>		Move to next window
 * <arg><window>	split window horizontal
 * <arg><arg><window>	split window vertical
 * <meta><window>	close/merge current window
 *
 * CW: needs this hack
 * <arg><meta><window>	Move to previous window
 */
flagType
window (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    int i, v;
    flagType fVert = TRUE;

    v = TRUE;

    switch (pArg->argType) {

    case NOARG:
	/* change current window */
	if (cWin != 1) {
	    if (fMeta) {
		/*  <meta><window> - close current window.  Scan for window
		 *  that is adjacent to iCurWin
		 */
		if (!WinClose (iCurWin)) {
		    printerror ("Cannot close this window");
		    return FALSE;
                }
            } else {
		/* select next window */
                iCurWin = (iCurWin + 1) % cWin;
            }

	    v = SetWinCur (iCurWin);
        } else {
            v = FALSE;
        }
        break;

    case NULLARG:
	if (cWin == MAXWIN) {
	    printerror ("Too many windows");
	    return FALSE;
        }

	if (pArg->arg.nullarg.cArg == 1) {
	    i = pArg->arg.nullarg.y - YWIN (pInsCur);
	    fVert = FALSE;
        } else {
            i = pArg->arg.nullarg.x - XWIN(pInsCur);
        }

        if (!SplitWnd (pWinCur, fVert, i)) {
            return FALSE;
        }

        // docursor (XWIN(pInsCur), YWIN(pInsCur));
	break;
    }

    newscreen ();
    SETFLAG (fDisplay, RCURSOR|RSTATUS);
    DoDisplay();
    return (flagType)v;

    argData;
}





/*** SplitWnd - Creates a new window by splitting an existing window
*
* Purpose:
*
*   When the user asks to split a window, this is called.  It does
*   everything after the split location is known.
*
* Input:
*   Parameters:
*	pWnd	->  Window to split
*       fVert   ->  TRUE for vertical split, FALSE for horizontal
*	pos	->  Window relative offset to split at
*
*   Globals:
*	fZoomed -> To prevent splitting a zoomed window
*
* Output:
*
*   Returns TRUE if we split, FALSE otherwise.
*
*************************************************************************/
flagType
SplitWnd (
    PWND    pWnd,
    flagType fVert,
    int     pos
    )
{
    PINS    pInsTmp;
    PINS    pInsNext;
    struct windowType winTmp;
    LINE    Line, LineWin;
    LINE    NewLineWin;
    COL     Col;

    winTmp      = *pWnd;
    Line        = YCUR(pInsCur);
    Col         = XCUR(pInsCur);
    LineWin     = YWIN(pInsCur);
    NewLineWin  = (Line == 0) ? Line : Line - 1;

    if (!fVert) {
        if (pos < 5 || WINYSIZE(pWnd) - pos < 5) {
            printerror ("Window too small to split");
            return FALSE;
        }

        /*
         * new y size is remainder of window
         * old y size is reduced by the new window and separator
         * new y position is just below new separator
         */
        YWIN(pInsCur)   = NewLineWin;
        winTmp.Size.lin = WINYSIZE(pWnd) - pos - 2;
        WINYSIZE(pWnd) -= winTmp.Size.lin + 1;
        winTmp.Pos.lin  = WINYPOS(pWnd) + WINYSIZE(pWnd) + 1;

    } else {
        if (pos < 10 || WINXSIZE(pWnd) - pos < 10) {
            printerror ("Window too small to split");
            return FALSE;
        }

        YWIN(pInsCur) = NewLineWin;
        newwindow ();
        winTmp.Size.col = WINXSIZE(pWnd) - pos - 2;
        WINXSIZE(pWnd) -= winTmp.Size.col + 1;
        winTmp.Pos.col  = WINXPOS(pWnd) + WINXSIZE(pWnd) + 1;
    }

    //
    // Allocate and set up the new current instance for this window.
    // Set the new cursor position to home
    //
    pInsTmp = (PINS) ZEROMALLOC (sizeof (*pInsTmp));
    *pInsTmp = *pInsCur;

    winTmp.pInstance = pInsTmp;

    //
    // Walk the old instance list, and copy it to the new instance list
    //
    pInsNext = pInsCur;
    while (pInsNext = pInsNext->pNext) {
        pInsTmp->pNext = (PINS) ZEROMALLOC (sizeof (*pInsTmp));
        pInsTmp = pInsTmp->pNext;
        *pInsTmp = *pInsNext;
    }
    pInsTmp->pNext = NULL;
    WinList[cWin++] = winTmp;
    IncFileRef (pFileHead);
    SortWin ();
    YCUR(pInsCur) = Line;
    XCUR(pInsCur) = Col;
    YWIN(pInsCur) = LineWin;
    return TRUE;
}





/*  SortWin - sort window list based upon position on screen
 */
void
SortWin (
    void
    )
{
    struct windowType winTmp;
    int i, j;

    for (i = 0; i < cWin; i++) {
        for (j = i+1; j < cWin; j++) {
	    if (WinList[j].Pos.lin < WinList[i].Pos.lin ||
		(WinList[j].Pos.lin == WinList[i].Pos.lin &&
		 WinList[j].Pos.col < WinList[i].Pos.col)) {
                if (iCurWin == i) {
                    pWinCur = &WinList[iCurWin = j];
                }
		winTmp = WinList[i];
		WinList[i] = WinList[j];
		WinList[j] = winTmp;
            }
        }
    }
}






/* SetWinCur - Set current window
 *
 * Entry:
 *  iWin	= index to new current window.
 */
flagType
SetWinCur (
    int     iWin
    )
{
    iCurWin = iWin;
    pWinCur = &WinList[iWin];
    pInsCur = pWinCur->pInstance;

    /*
     * If we cannot change to the current file, we will walk the window instance
     * list until we get a valid file. If no one can be loaded then we switch to
     * the <untitled> pseudo-file.
     * NB: fChangeFile does a RemoveTop so we don't need to move pInsCur
     */
    while ((pInsCur != NULL) && (!fChangeFile (FALSE, pInsCur->pFile->pName))) {
        ;
    }

    if (pInsCur == NULL) {
        fChangeFile (FALSE, rgchUntitled);
    }
    return (flagType)(pInsCur != NULL);
}





/*  Adjacent - return true if two windows are adjacent to each other
 *
 *  Adjacent returns true if window i is to the left or above window j
 *  and exactly matches some size attributes
 */
flagType
Adjacent (
    int i,
    int j
    )
{
    REGISTER PWND pWini = &WinList[i];
    REGISTER PWND pWinj = &WinList[j];

    if (WINYSIZE(pWini) == WINYSIZE(pWinj) &&
	WINYPOS(pWini)	== WINYPOS(pWinj)  &&
	(WINXPOS(pWini) + WINXSIZE(pWini) + 1 == WINXPOS(pWinj) ||
         WINXPOS(pWinj) + WINXSIZE(pWinj) + 1 == WINXPOS(pWini))) {
	return TRUE;
    } else {
	return (flagType)
	   (WINXSIZE(pWini) == WINXSIZE(pWinj) &&
	    WINXPOS(pWini)  == WINXPOS(pWinj) &&
	    (WINYPOS(pWini) + WINYSIZE(pWini) + 1 == WINYPOS(pWinj) ||
             WINYPOS(pWinj) + WINYSIZE(pWinj) + 1 == WINYPOS(pWini)));
    }
}






/*  WinClose - close a window.
 *
 *  We walk the entire window list trying to find another window that
 *  is adjacent to the specified window.  When found, we free all data relevant
 *  to the specified window and expand the found window to encompass the
 *  new region.
 *
 *  j		window to be closed
 *
 *  returns	TRUE iff window was closed
 */
flagType
WinClose (
    int j
    )
{
    PINS pInsTmp;
    PINS pInsNext;
    REGISTER PWND pWini;
    REGISTER PWND pWinj = &WinList[j];
    int i;

    /*	Find adjacent window
     */
    for (i = 0; i < cWin; i++) {
        if (Adjacent (i, j)) {
            break;
        }
    }

    /*	No adjacent window found
     */
    if (i == cWin) {
        return FALSE;
    }

    pWini = &WinList[i];

    /*	Free up all those instances
     */
    pInsTmp = pWinj->pInstance;
    while (pInsTmp != NULL) {

        /*
         * we decrement the ref count here, without using DecFileRef, so that the file
         * will NOT be removed by having a zero reference count. This allows it to
         * live, unreferenced, in the file list, even if it is dirty. That allows us
         * to close any window that has dirty files associated with it.
         */
	pInsTmp->pFile->refCount--;
	pInsNext = pInsTmp;
	pInsTmp = pInsTmp->pNext;
        FREE ((char *) pInsNext);
    }

    /*	Expand pWini to encompass pWinj
     */
    if (WINYPOS(pWinj) == WINYPOS(pWini)) {
	WINXSIZE(pWini) += WINXSIZE(pWinj) + 1;
    } else {
        WINYSIZE(pWini) += WINYSIZE(pWinj) + 1;
    }
    WINXPOS(pWini) = min (WINXPOS(pWinj), WINXPOS(pWini));
    WINYPOS(pWini) = min (WINYPOS(pWinj), WINYPOS(pWini));
    memmove ((char *)&WinList[j], (char *)&WinList[j+1], (cWin-j-1) * sizeof (WinList[0]));
    if (i > j) {
        i--;
    }
    pWinCur = &WinList[iCurWin = i];
    cWin--;
    SortWin ();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\undo.c ===
/*** Undo.c - handle all undo operations for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   N-level undo/redo:
*
*   For each file, keep a d-linked list of edit records in VM, head / tail /
*   current pointers into this list, and a count of "boundaries" between
*   undo-able edit operations. When that count exceeds "cUndo", we move excess
*   records from the tail of the undo list to a dead-record list, for eventual
*   discard.
*
*   Freeing or rereading a file flushes its undo list.
*
*   There are 4 types of undo records:
*
*   Putline logs a "replace" record
*	line
*	va of old line
*   No optimization for recycling same space
*   Optimization for replacing same line
*
*   Insline logs an "insert" record
*	line
*	number of lines inserted
*
*   Delline logs a "delete" record
*	line
*	number deleted
*	VAs of deleted lines
*
*   Top loop logs "boundary" records
*	file flags
*	file modification time
*	window position
*	cursor position
*   Optimization of entering boundary on top of boundary
*   Top loop also contains an optimization to prevent boundaries between
*   graphic functions.
*
*   UNDO moves backwards in the undo list, reversing the effects of each record
*   logged until a boundary is encountered.
*
*   REDO moves forwards in the undo list, repeating the effects of each record
*   logged.
*
*   After an UNDO or REDO, the next record logging will cause the undo records
*   from the current position forward to be moved to the dead-record list for
*   eventual discard.
*
*   Discarding of dead records occurs durring the system idle loop, or when an
*   out-of-memory condition ocurrs.
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"



#define HEAD	    TRUE
#define TAIL	    FALSE

#define LINEREC(va,l)  ((PBYTE)(va)+sizeof(LINEREC)*((long)(l)))
#define COLORREC(va,l) ((PBYTE)(va)+sizeof(struct colorRecType)*((long)(l)))

#if defined (DEBUG)

	#define DUMPIT(x,y)   UNDODUMP(x,y)

	void
	UNDODUMP (
		PVOID	vaCur,
		char	*Stuff
		);

#else

	#define DUMPIT(x,y)

#endif


PVOID   vaDead = (PVOID)-1L;                   /* head of dead undo list       */



/*
 * UNDO record definitions.
 * NOTE: these records are duplicated in a less complete form in EXT.H for
 * extension users. BE SURE to change them there if you EVER change them
 */
struct replaceRec {
	int	op;			/* operation				*/
	PVOID	flink;			/* editor internal			*/
	PVOID	blink;			/* editor internal			*/
	LINE	length; 		/* length of replacement	*/
	LINE	line;			/* start of replacement 	*/
	LINEREC vLine;			/* text of line 			*/
	struct	colorRecType vColor;	/* color of line			*/
	PVOID	vaMarks;		/* marks attached to line	*/
    };

struct insertRec {
	int	op;			/* operation				*/
	PVOID	flink;			/* editor internal			*/
	PVOID	blink;			/* editor internal			*/
    LINE    length;
	LINE	line;			/* line number that was operated on */
	LINE	cLine;			/* number of lines inserted			*/
    };

struct deleteRec {
	int	op;			/* operation			*/
	PVOID	flink;			/* editor internal		*/
	PVOID	blink;			/* editor internal		*/
    LINE    length;
	LINE	line;			/* line number that was operated on */
	LINE	cLine;			/* Number of lines deleted			*/
	PVOID	vaLines;		/* editor internal					*/
	PVOID	vaColor;		/* Color of lines					*/
	PVOID	vaMarks;		/* marks attached to lines			*/
    };

struct boundRec {
	int	op;			/* operation (BOUND)			*/
	PVOID	flink;			/* editor interal				*/
	PVOID	blink;			/* editor interal				*/
	int	flags;			/* flags of file				*/
	time_t	modify; 		/* Date/Time of last modify		*/
	fl	flWindow;		/* position in file of window	*/
	fl	flCursor;		/* position in file of cursor	*/
    };

union Rec {
    struct replaceRec r;
    struct insertRec  i;
    struct deleteRec  d;
    struct boundRec   b;
    };



/*** CreateUndoList - initialize undo list for a file.
*
*  Allocate the doubly-linked undo list with a single boundary record. Also
*  clears any existing list.
*
* Input:
*  pFile	= file to operate on
*
*************************************************************************/
void
CreateUndoList (
    PFILE pFile
    )
{
	struct boundRec *boundary;

	RemoveUndoList (pFile);

	if (!(FLAGS(pFile) & READONLY)) {

        pFile->vaUndoCur = pFile->vaUndoHead = pFile->vaUndoTail
			= MALLOC ((long)sizeof (union Rec));

		boundary = (struct boundRec *)(pFile->vaUndoHead);

		boundary->op			= EVENT_BOUNDARY;
		boundary->blink			= boundary->flink		 = (PVOID)(-1L);
		boundary->flWindow.col	= boundary->flCursor.col = 0;
		boundary->flWindow.lin	= boundary->flCursor.lin = 0L;
		boundary->flags			= FLAGS (pFile);

	}
}





/*** LinkAtHead - link a record in at the head of the undo queue
*
*  This is the routine which also discards any re-doable operations. When
*  called, if the "current" position is not at the head of the list, that
*  means we are adding a new editting operation, and we discard everything
*  between the head of the list and the current position, which becomes the
*  new head.
*
* Input:
*  vaNewHead	= new head of linked list
*  precNewHead	= pointer to the record itself
*  pFile	= file whose list we are mucking with
*
*************************************************************************/
void
LinkAtHead (
    PVOID     vaNewHead,
    union Rec *precNewHead,
    PFILE   pFile
    )
{
	EVTargs e;		   /* event notification parameters*/

    /*
     * Declare the event
     */
    e.arg.pUndoRec = precNewHead;
    DeclareEvent (EVT_EDIT, &e);

    /*
     * discard any records between current position and head of list
     */
	while (pFile->vaUndoCur != pFile->vaUndoHead) {

		if (((union Rec *)(pFile->vaUndoHead ))->b.op == EVENT_BOUNDARY) {
			pFile->cUndo--;
		}

		FreeUndoRec ( HEAD, pFile );
    }

    /*
     * Modify the current head of the list to point at the new head.
     */
	((union Rec *)(pFile->vaUndoHead))->b.flink = vaNewHead;

    /*
     * Update the links in the new head, and send it out
     */
	memmove(vaNewHead, (char *)precNewHead, sizeof (union Rec));

	((union Rec *)vaNewHead)->b.flink = (PVOID)(-1L);
	((union Rec *)vaNewHead)->b.blink = pFile->vaUndoHead;

    pFile->vaUndoCur = pFile->vaUndoHead = vaNewHead;

}





/*** LogReplace - log replace action
*
* Allocate (or update) a replace record.
*
* Input:
*  pFile	= file being changed
*  line 	= line being replaced
*  vLine	= linerec being replaced
*
*************************************************************************/
void
LogReplace (
    PFILE   pFile,
    LINE    line,
    LINEREC * pvLine,
    struct colorRecType * pvColor
    )
{
    EVTargs e;				/* event notification parameters*/
	union Rec *rec;
	union Rec rec1;
	PVOID vaReplace;

	if ( pFile->vaUndoHead == (PVOID)-1L) {
		CreateUndoList( pFile );
	}

	vaReplace = pFile->vaUndoHead;

	if (!(FLAGS(pFile) & READONLY)) {

		rec = (union Rec *)vaReplace;

		if ((rec->r.op == EVENT_REPLACE) && (rec->r.line == line)) {

            /*
             * Optimization for immediately replacing the same line in a file with no
             * intervening boundary or other operation. Discard the passed in "old" line,
             * and update the other data in the existing replace record.
			 */
			rec->r.length = pFile->cLines;
			e.arg.pUndoRec = rec;
			DeclareEvent (EVT_EDIT, &e);

			if (pvLine->Malloced) {
				pvLine->Malloced = FALSE;
				FREE(pvLine->vaLine);
				pvLine->vaLine = (PVOID)-1L;
            }

		} else {

            /*
             * if not optimizable, create new replace record
             */
			vaReplace	= MALLOC( (long)sizeof(union Rec) );

			memcpy( &rec1, rec, sizeof(rec1) );

			rec1.r.op		= EVENT_REPLACE;
			rec1.r.vLine	= *pvLine;
			rec1.r.line		= line;
			rec1.r.vColor	= *pvColor;
			rec1.r.vaMarks	= GetMarkRange (pFile, line, line);
			rec1.r.length	= pFile->cLines;
			LinkAtHead( vaReplace, &rec1, pFile );
        }
    }
}




/*** LogInsert - log line insertion
*
*  Add one EVENT_INSERT record to head of list
*
* Input:
*  pFile	= file being changed
*  line 	= line being inserted at
*  cLines	= number of lines being inserted
*
*************************************************************************/
void
LogInsert (
    PFILE   pFile,
    LINE    line,
    LINE    cLines
    )
{
	union Rec rec;
    PVOID     vaInsert;

	if (!(FLAGS(pFile) & READONLY)) {

		vaInsert	= MALLOC( (long)sizeof(union Rec) );

        rec.i.op    = EVENT_INSERT;
		rec.i.length= pFile->cLines;
		rec.i.line	= line;
		rec.i.cLine = cLines;
		LinkAtHead (vaInsert,&rec,pFile);

    }
}



/*** LogDelete - Log delete action
*
*  Add one EVENT_DELETE record to head of list
*
* Input:
*  pFile	= file being changed
*  start	= 1st line being deleted
*  end		= last line being deleted
*
*************************************************************************/
void
LogDelete (
    PFILE   pFile,
    LINE    start,
    LINE    end
    )
{
    union Rec rec;
    long      cLine;
    PVOID     vaDelete;

    if (!(FLAGS(pFile) & READONLY)) {

        cLine    = end - start + 1;
        vaDelete = MALLOC ((long) sizeof (union Rec));

        rec.d.op      = EVENT_DELETE;
		rec.d.length  = pFile->cLines;
		rec.d.line	  = start;
		rec.d.cLine   = cLine;
	rec.d.vaLines = MALLOC (cLine * sizeof (LINEREC));
        rec.d.vaMarks = GetMarkRange (pFile, start, end);

        memmove(rec.d.vaLines,
		LINEREC (pFile->plr, start),
		cLine * sizeof (LINEREC));

        if (pFile->vaColor != (PVOID)-1L &&
            (rec.d.vaColor = MALLOC (cLine * sizeof (struct colorRecType))) != NULL) {
            memmove(rec.d.vaColor,
                    COLORREC (pFile->vaColor, start),
                    cLine * sizeof (struct colorRecType));
        } else {
            rec.d.vaColor = (PVOID)-1;
        }

		LinkAtHead( vaDelete, &rec, pFile );
    }
}





/*** LogBoundary - note end of editor function
*
*  Add one EVENT_BOUNDARY record to head of list.  A boundary record signals
*  the end of a Z edit function. If count of undo operations on this file
*  exceeds the max allowed, move the overflow to the dead-record list for
*  eventual discard.
*
*  If a EVENT_BOUNDARY record is already at the head, do not add another. This
*  allows LogBoundary() to be called at the top loop without generating bogus
*  EVENT_BOUNDARY records.
*
*************************************************************************/
void
LogBoundary (
    void
    )
{
    union Rec rec;
    PVOID     vaBound;
    EVTargs   e;

    if (!(FLAGS(pFileHead) & READONLY)) {

		vaBound = pFileHead->vaUndoCur;

        memmove((char *)&rec, vaBound, sizeof (rec));

		rec.b.flags 		= FLAGS (pFileHead);
		rec.b.modify		= pFileHead->modify;
		rec.b.flWindow.col	= XWIN (pInsCur);
		rec.b.flWindow.lin	= YWIN (pInsCur);
		rec.b.flCursor.col	= XCUR (pInsCur);
		rec.b.flCursor.lin	= YCUR (pInsCur);

		if (rec.b.op != EVENT_BOUNDARY) {

            vaBound = MALLOC ((long) sizeof (rec));

			rec.b.op = EVENT_BOUNDARY;
			LinkAtHead( vaBound, &rec, pFileHead );

            (pFileHead->cUndo)++;

			while ( pFileHead->cUndo > cUndo ) {
                if (FreeUndoRec(TAIL,pFileHead) == EVENT_BOUNDARY) {
                    pFileHead->cUndo--;
                }
			}

		} else {

			e.arg.pUndoRec = &rec;
			DeclareEvent (EVT_EDIT, &e);
            memmove(vaBound, (char *) &rec.b, sizeof (rec.b));
        }
    }
}





/*** FreeUndoRec - move record to dead-record list
*
*  Pick off one record from the Head of the list, or the tail of the list and
*  place it in the dead-record list. Return the .op of the next undo record.
*
* Input:
*  fHead	= TRUE -> place at head of list
*  pFile	= file to work on
*
*************************************************************************/
int
FreeUndoRec (
    flagType fHead,
    PFILE    pFile
    )
{
    PVOID     vaNext;
    PVOID     vaRem;

    /*
     * Get the dead record, and move up the list (if at head), or truncate the list
     * if at tail.
     */
    vaRem = fHead ? pFile->vaUndoHead : pFile->vaUndoTail;

    if (fHead) {
        vaNext = pFile->vaUndoHead = ((union Rec *)vaRem)->b.blink;
    } else {
        vaNext = pFile->vaUndoTail = ((union Rec *)vaRem)->b.flink;
    }

    /*
     * Update the links in the newly exposed (head or tail) record.
     */
    if (fHead) {
        ((union Rec *)vaNext)->b.flink = (PVOID)-1;
    } else {
        ((union Rec *)vaNext)->b.blink = (PVOID)-1;
    }

    EnterCriticalSection(&UndoCriticalSection);
    /*
     * Update the removed record to properly live in the dead list
     */
    ((union Rec *)vaRem)->b.blink  = vaDead;
    vaDead          = vaRem;


    LeaveCriticalSection(&UndoCriticalSection);

	return ((union Rec *)vaNext)->b.op;
}





/*** UnDoRec - undo an editting action
*
*  Reverse the action of the current undo record for the file. Do not log the
*  change. Return the type of the next record.
*
* Input:
*  pFile	= file being operated on
*
*************************************************************************/
int
UnDoRec (
    PFILE   pFile
    )
{
	union Rec *rec;
    LINEREC vlCur;
    struct colorRecType vcCur;
    EVTargs e;				/* event notification params	*/

	rec = (union Rec *)(pFile->vaUndoCur);

	e.arg.pUndoRec = rec;
    DeclareEvent (EVT_UNDO, &e);

	switch (rec->b.op) {

    case EVENT_REPLACE:
        /*
         * Swap the line in the file with the line in the replace record.
         */
		memmove((char *)&vlCur,
				LINEREC (pFile->plr, rec->r.line),
				sizeof (vlCur));

		memmove(LINEREC (pFile->plr, rec->r.line),
			   (char *)&rec->r.vLine,
			   sizeof (rec->r.vLine));

        /* Do the same for the color.
         *
         */
		if (pFile->vaColor != (PVOID)-1L) {

            memmove((char *)&vcCur,
					COLORREC (pFile->vaColor, rec->r.line),
                    sizeof (vcCur));

			memmove(COLORREC (pFile->vaColor, rec->r.line),
					(char *)&rec->r.vColor,
					sizeof (rec->r.vColor));
        }

		rec->r.vLine = vlCur;
		pFile->cLines = rec->r.length;
		AckReplace( rec->r.line, TRUE );
		PutMarks( pFile, rec->r.vaMarks, rec->r.line );
		break;

    case EVENT_INSERT:
		/*	delete the blank(!) lines that are present
		 */
		DelLine( FALSE, pFile, rec->i.line, rec->i.line + rec->i.cLine - 1);
		pFile->cLines = rec->i.length;
		break;

    case EVENT_DELETE:
		/*	insert a range of blank lines
		 *	copy the linerecs from the stored location to the blank area
		 */
		InsLine( FALSE, rec->d.line, rec->d.cLine, pFile );
		memmove(LINEREC (pFile->plr, rec->d.line),
				rec->d.vaLines,
				(long)rec->d.cLine * sizeof (LINEREC));

		if (pFile->vaColor != (PVOID)-1L) {

			memmove(COLORREC (pFile->vaColor, rec->d.line),
					rec->d.vaColor,
					(long)rec->d.cLine * sizeof (struct colorRecType));
		}

		pFile->cLines = rec->d.length;
		PutMarks (pFile, rec->d.vaMarks, rec->d.line);
		break;
    }

	pFile->vaUndoCur = rec->i.blink;
	return ((union Rec *)(pFile->vaUndoCur))->i.op;
}




/*** ReDoRec - redo editting action
*
*  Repeat the action of the current undo record for a file. Do not log the
*  change.
*
* Input:
*  pFile	= file to operate on
*
* Output:
*  Returns the type of record undone.
*
*************************************************************************/
int
ReDoRec (
    PFILE   pFile
    )
{
	EVTargs 	e;				/* event notification params	*/
	union Rec	*rec;
    LINEREC vlCur;

	rec = (union Rec *)(pFile->vaUndoCur);

	e.arg.pUndoRec = rec;
    DeclareEvent (EVT_UNDO, &e);

	switch (rec->b.op) {

    case EVENT_REPLACE:
        /*
         * Swap the line in the file with the line in the replace record.
         */
        memmove((char *)&vlCur,
				LINEREC (pFile->plr, rec->r.line),
                sizeof (vlCur));

		memmove(LINEREC (pFile->plr, rec->r.line),
				(char *)&rec->r.vLine,
				sizeof (rec->r.vLine));

		rec->r.vLine = vlCur;
		pFile->cLines = rec->r.length;
		AckReplace (rec->r.line, FALSE);
		break;

    case EVENT_INSERT:
		/*	Insert lines
		 */
		InsLine(FALSE, rec->i.line, rec->i.cLine, pFile);
		pFile->cLines = rec->d.length + rec->i.cLine;
        break;

    case EVENT_DELETE:
		/*	delete lines
		 */
		DelLine( FALSE, pFile, rec->d.line, rec->d.line + rec->d.cLine - 1 );
		pFile->cLines = rec->d.length - rec->d.cLine;
		break;
    }

	pFile->vaUndoCur = rec->i.flink;
	return ((union Rec *)(pFile->vaUndoCur))->i.op;
}





/*** zundo - Undo edit function
*
*  <undo>	- Reverse last edit function ( except undo )
*  <meta><undo> - Repeat previously undone action
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE if something done.
*
*************************************************************************/
flagType
zundo (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    int fTmp;
	union Rec rec;

    if (!fundoable(fMeta)) {
        if (!mtest ()) {
            disperr (fMeta ? MSGERR_REDO : MSGERR_UNDO);
        }
		return FALSE;
	}

    LogBoundary ();

    while ((fMeta ? ReDoRec (pFileHead) : UnDoRec (pFileHead)) != EVENT_BOUNDARY) {
        ;
    }

    /*
     * swap the flags so that traversals up and down the undo list work correctly.
     * If we now think that the file might not be dirty, check the modification
     * times as well. (This allows us to retain UNDO histories across file saves,
     * without erroneously reporting that a file is clean when it is not).
     * re-display the file.
     */
    memmove((char *)&rec, pFileHead->vaUndoCur, sizeof (rec));

    fTmp = FLAGS (pFileHead);
    rec.b.flags |= FLAGS(pFileHead) & VALMARKS;
    FLAGS(pFileHead) = rec.b.flags;
    rec.b.flags = fTmp;
    SETFLAG (fDisplay, RSTATUS);

    if (!TESTFLAG(FLAGS(pFileHead),DIRTY)
        && (rec.b.modify != pFileHead->modify)) {
        SETFLAG(FLAGS(pFileHead),DIRTY);
    }

    doscreen (rec.b.flWindow.col, rec.b.flWindow.lin, rec.b.flCursor.col, rec.b.flCursor.lin);
    newscreen ();

    return TRUE;

    argData; pArg;
}





/*** fundoable - return TRUE/FALSE if something is un/redoable
*
* Input:
*  fMeta	= TRUE -> redo check
*
* Output:
*  Returns TRUE is an undo or redo (as selected) can be performed
*
*************************************************************************/
flagType
fundoable (
    flagType fMeta
    )
{
	union Rec *rec;

    if (!pFileHead || pFileHead->vaUndoCur == (PVOID)-1L) {
        return FALSE;
    }

	rec = (union Rec *)(pFileHead->vaUndoCur);

	if (fMeta && (rec->i.flink == (PVOID)(-1))) {
        return FALSE;
	} else if (!fMeta && (rec->i.blink == (PVOID)(-1))) {
        return FALSE;
    }
    return TRUE;
}




/*  fIdleUndo - while MEP is in an idle loop waiting for keystrokes, free
 *  the extra stuff from the dead-record list.
 *
 *  returns	TRUE iff more to free
 */
flagType
fIdleUndo (
    flagType fAll
    )
{
    int         i;
	union Rec	*rec;
    LINEREC vLine;
	flagType	MoreToFree;
	PVOID		p;

    EnterCriticalSection(&UndoCriticalSection);

	// DUMPIT(vaDead, "\n\n***** In fIdleUndo\n");

    /*
     * if there is a dead list then
     */
    while (vaDead != (PVOID)(-1L)) {

		rec = (union Rec *)vaDead;

        /*
         *  Free stored lines(s)
         */
		switch (rec->b.op) {

        case EVENT_REPLACE:
			if (rec->r.vLine.Malloced) {
				rec->r.vLine.Malloced = FALSE;
				FREE(rec->r.vLine.vaLine);
				rec->r.vLine.vaLine = (PVOID)-1L;
            }
            break;

        case EVENT_DELETE:
			BlankLines (rec->d.cLine, rec->d.vaLines);
			for (i = 0; i < rec->d.cLine; i++) {
				memmove((char *)&vLine, LINEREC(rec->d.vaLines,i), sizeof(vLine));
				if (vLine.Malloced) {
					vLine.Malloced = FALSE;
					FREE (vLine.vaLine);
					vLine.vaLine = (PVOID)-1L;
                }
            }
			FREE (rec->d.vaLines);
            break;

        case EVENT_INSERT:
			break;
        }

        /*
         * free dead record.
		 */
		p = vaDead;
		vaDead = rec->b.blink;

		FREE (p);


        if (!fAll) {
            break;
        }
    }

    MoreToFree =  (flagType)(vaDead != (PVOID)(-1L));

    LeaveCriticalSection(&UndoCriticalSection);

    return MoreToFree;

}





/*  FlushUndo - Toss all unneeded undo records.
 */
void
FlushUndoBuffer (
    void
    )
{
    PFILE pFile = pFileHead;

    while (pFile) {
		RemoveUndoList (pFile);
		pFile = pFile->pFileNext;
    }
    fIdleUndo (TRUE);
}





/*  RemoveUndoList - transfer undolist to end of the dead list.
 */
void
RemoveUndoList (
    PFILE pFile
    )
{

    if (pFile->vaUndoTail != (PVOID)-1L) {

        EnterCriticalSection(&UndoCriticalSection);

        ((union Rec *)(pFile->vaUndoTail))->b.blink = vaDead;
        vaDead = pFile->vaUndoHead;

        LeaveCriticalSection(&UndoCriticalSection);

    }
    pFile->vaUndoHead = pFile->vaUndoTail = pFile->vaUndoCur = (PVOID)-1L;
    pFile->cUndo = 0;
}



#ifdef DEBUG
void
UNDODUMP (
    PVOID   vaCur,
    char    *Stuff
    )
{
    union Rec rec;

    char DbgBuffer[256];


    if (vaCur != (PVOID)-1) {
        OutputDebugString (Stuff);
        OutputDebugString("=============================================\n");
    }

    while (vaCur != (PVOID)-1L) {
        memmove((char *)&rec, vaCur, sizeof (rec));
        sprintf(DbgBuffer,  "\nUndo Record at va = %p\n",vaCur);
        OutputDebugString(DbgBuffer);
        sprintf(DbgBuffer,    "  flink           = %p\n",rec.b.flink);
        OutputDebugString(DbgBuffer);
        sprintf(DbgBuffer,    "  blink           = %p\n",rec.b.blink);
        OutputDebugString(DbgBuffer);

        switch (rec.b.op) {

        case EVENT_BOUNDARY:
            OutputDebugString("  Operation       = BOUNDARY\n");
            sprintf(DbgBuffer,"  yW, xW, yC, xC  = %ld, %d, %ld, %d\n",
                     rec.b.flWindow.lin, rec.b.flWindow.col, rec.b.flCursor.lin, rec.b.flCursor.col);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  flags           = %X\n",rec.b.flags);
            OutputDebugString(DbgBuffer);
            break;

        case EVENT_REPLACE:
            OutputDebugString("  Operation       = REPLACE\n");
            sprintf(DbgBuffer, "  line & length   = %ld & %ld\n", rec.r.line, rec.r.length);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  vLine           = va:%p cb:%d\n",rec.r.vLine.vaLine,
                     rec.r.vLine.cbLine);
            OutputDebugString(DbgBuffer);
            break;

        case EVENT_INSERT:
            OutputDebugString("  Operation       = INSERT\n");
            sprintf(DbgBuffer, "  line & length   = %ld & %ld\n", rec.i.line, rec.i.length);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  cLine           = %ld\n",rec.i.cLine);
            OutputDebugString(DbgBuffer);
            break;

        case EVENT_DELETE:
            OutputDebugString("  Operation       = DELETE\n");
            sprintf(DbgBuffer, "  line & length   = %ld & %ld\n", rec.d.line, rec.d.length);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  cLine           = %ld\n",rec.d.cLine);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  vaLines         = %p\n",rec.d.vaLines);
            OutputDebugString(DbgBuffer);
            break;
        }

        vaCur = rec.b.blink;
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\z19.c ===
/*  z19.c - Terminal dependent output routines.
*
*   Modifications:
*
*	26-Nov-1991 mz	Strip near/far
*
*************************************************************************/

#include "mep.h"


#define DEBFLAG  Z19



ULONG
MepWrite (
    ULONG   Row,
    ULONG   Col,
    PVOID   pBuffer,
    ULONG   BufferSize,
    DWORD   Attr,
    BOOL    BlankToEndOfLine,
    BOOL    ShowIt
    )
{
    ULONG   CharactersWritten = 0;

    // EnterCriticalSection( &ScreenCriticalSection );

    if (pBuffer) {

	CharactersWritten = consoleWriteLine( MepScreen,
					      pBuffer,
					      BufferSize,
					      Row,
					      Col,
					      Attr,
					      BlankToEndOfLine );

    }

    //
    //	If we want to update the screen, do it
    //
    if (ShowIt)
	consoleShowScreen( MepScreen );

    // LeaveCriticalSection( &ScreenCriticalSection );

    return CharactersWritten;
}




/*  coutb - output line with color, and blank extension
 *
 *  Purpose:
 *   outputs a string of characters, utilizing an array of color information and
 *   blank extending the line to the right hand side of the window.
 *
 *  Entry:
 *   pwnd    = pointer to CW window info (CW version only)
 *   x	     = starting column for output
 *   y	     = line number to be written
 *   p	     = pointer to text
 *   c	     = count of characters in text
 *   colors  = pointer to array of color info
 *
 * Returns:
 */
int
coutb (
    int 	 x,
    int 	 y,
    char	*p,
    int 	 c,
    struct lineAttr * colors
    )
{
    int   cnt;
    DWORD clr = 0;

    int   x1 = x;
    char *p1 = p;
    int   c1 = c;
    struct lineAttr *colors1 = colors;

    if (c1) {
	do {
	    cnt = min (c1, (int)colors1->len);
	    MepWrite( y,
		      x1,
		      p1,
		      cnt,
		      clr = (DWORD)ColorTab[colors1->attr - isaUserMin],
		      FALSE,
		      FALSE );

	    x1 += cnt;
	    p1 += cnt;
	    c1 -= cnt;
	} while (((colors1++)->len != 0xFF) && (c1 > 0));
    }

    if (x1 < XSIZE) {
	    MepWrite( y, x1, " ", 1, clr, TRUE, fReDraw );
    } else {
    	MepWrite( y, x1, NULL, 0, clr, FALSE, fReDraw );
    }

    return x1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\zaux.c ===
/*** zaux.c - helper routines for Z
*
*   Modifications
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#define INCL_SUB
#define INCL_DOSERRORS
#define INCL_DOSMISC

#include "mep.h"
#include <stdarg.h>
#include <errno.h>

/*** ParseCmd - Parse "command" line into two pieces
*
* Given a text string, returns a pointer to the first word (non-whitespace)
* in the text, which is null terminated by this routine, and a pointer to
* the second word.
*
* Input:
*  pText	= Pointer to text string
*  ppCmd	= Pointer to place to put pointer to first word
*  ppArg	= Pointer to place to put pointer to second word
*
* Output:
*  Returns nothing. Pointers update, and string possible modified to include
*  null terminator after first word.
*
*************************************************************************/
void
ParseCmd (
    char    *pText,
    char    **ppCmd,
    char    **ppArg
    )
{
    REGISTER char *pCmd;                    /* working pointer              */
    REGISTER char *pArg;                    /* working pointer              */

    pArg = whitescan (pCmd = whiteskip (pText));
    if (*pArg) {
        *pArg++ = '\0';
        pArg = whiteskip (pArg);
    }
    *ppCmd = pCmd;
    *ppArg = pArg;
}





char *
whiteskip (
    const char *p
    )
{
    return strbskip ((char *)p, (char *)rgchWSpace);
}





char *
whitescan (
    const char *p
    )
{
    return strbscan ((char *)p, (char *)rgchWSpace);
}





/*** RemoveTrailSpace - remove trailing white space characters from line
*
* Input:
*  p		= pointer to line to be stripped.
*
* Output:
*  Returns new length of line.
*
*************************************************************************/
int
RemoveTrailSpace (
    REGISTER char *p
    )
{
    REGISTER int len = strlen (p);

    while (len && strchr(rgchWSpace,p[len-1])) {
        len--;
    }

    p[len] = 0;
    return len;
}




/*** DoubleSlashes - given a character string, double all backslashes
*
* Input:
*  pbuf 	= pointer to character buffer
*
* Output:
*  Returns pbuf
*
*************************************************************************/
char *
DoubleSlashes (
    char * pbuf
    )
{
    REGISTER int l;
    REGISTER char *p;

    p = pbuf;
    l = strlen (p);
    while (l) {
        if (*p == '\\') {
            memmove ((char *) (p+1),(char *) p,     l+1);
            *p++ = '\\';
        }
        p++;
        l--;
    }
    return pbuf;
}





/*** UnDoubleSlashes - given a character string, un-double all backslashes
*
* Input:
*  pbuf 	= pointer to character buffer
*
* Output:
*  Returns pbuf
*
*************************************************************************/
char *
UnDoubleSlashes (
    char * pbuf
    )
{
    REGISTER char *p1;
    REGISTER char *p2;

    p1 = p2 = pbuf;
    while (*p1) {
        if ((*p2++ = *p1++) == '\\') {
            if (*p1 == '\\') {
                p1++;
            }
        }
    }
    return pbuf;
}




/*** fIsNum - see if a string is entirely digits
*
* Input:
*  p		= pointer to string
*
* Output:
*  Returns TRUE if valid number.
*
*************************************************************************/
flagType
fIsNum (
    char *p
    )
{
    if (*p == '-') {
        p++;
    }
    return (flagType)(*strbskip (p, "0123456789") == 0);
}





/*** OS2toErrTxt - Get Error Text for OS/2 error
*
* Get the error message text for an OS/2 returned error.
*
* Input:
*  erc		= OS/2 error number
*  buf		= location to place the error (BUFSIZE)
*
* Output:
*  Returns buf
*
*************************************************************************/
char *
OS2toErrText (
    int     erc,
    char *  buf
    )
{

    sprintf(buf, "Windows error No. %lu", GetLastError());
    return buf;

    erc;
}





/*** OS2toErrno - Convert OS/2 error code to C runtime error
*
* Purpose:
*  Maps errors returned by some OS/2 calls to equivalent C runtime errors,
*  such that routines which differ in OS/2 implementation can return equivalent
*  errors as their DOS counterparts.
*
* Input:
*  code 	= OS/2 returned error code
*
* Output:
*  returns a C runtime error constant
*
* Exceptions:
*  none
*
* Notes:
*  CONSIDER: It's been suggested that this routine, and error message
*  CONSIDER: presentation under OS/2 be changed to use DosGetMessage.
*
*************************************************************************/
int
OS2toErrno (
    int code
    )
{
    buffer L_buf;

    printerror (OS2toErrText (code,L_buf));

    return code;
}




union argPrintfType {
    long *pLong;
    int  *pInt;
    char **pStr;
    char **fpStr;
    };


/***  ZFormat - replace the C runtime formatting routines.
*
* Purpose:
*
*   ZFormat is a near-replacement for the *printf routines in the C runtime.
*
* Input:
*   pStr - destination string where formatted result is placed.
*   fmt  - formatting string.  Formats currently understood are:
*		    %c single character
*		    %[n][l]d %[n][l]x
*		    %[m.n]s
*		    %[m.n]|{dpfe}F - print drive, path, file, extension
*				     of current file.
*		      * may be used to copy in values for m and n from arg
*			list.
*		    %%
*   arg  - is a list of arguments
*
* Output:
*
*   Returns 0 on success, MSGERR_* on failure.	The MSGERR_* value may
*   be passed to disperr, as in:
*
*	if (err = ZFormat (pszUser))
*	    disperr (err, pszUser).
*
*   Note that the error message wants to display the offending string.
*
*   Currently, the only return value is:
*
*	MSGERR_ZFORMAT	8020	Unrecognized %% command in '%s'
*
*************************************************************************/

int
ZFormat (
    REGISTER char *pStr,
    const REGISTER char *fmt,
    va_list vl
    )
{
    char   c;
    char * pchar;
    int *  pint;



    *pStr = 0;
    while (c = *fmt++) {
        if (c != '%') {
	    *pStr++ = c;
        } else {
	    flagType fFar = FALSE;
	    flagType fLong = FALSE;
	    flagType fW = FALSE;
	    flagType fP = FALSE;
	    flagType fdF = FALSE;
	    flagType fpF = FALSE;
	    flagType ffF = FALSE;
	    flagType feF = FALSE;
	    char fill = ' ';
	    int base = 10;
	    int w = 0;
	    int p = 0;
	    int s = 1;
	    int l;

	    c = *fmt;
	    if (c == '-') {
		s = -1;
		c = *++fmt;
            }
	    if (isdigit (c) || c == '.' || c == '*') {
		/*  parse off w.p
		 */
		fW = TRUE;
		if (c == '*') {
		    pint = va_arg (vl, int *);
		    w = *pint;
		    fmt++;
                } else {
                    if (c == '0') {
                        fill = '0';
                    }
		    w = s * atoi (fmt);
		    fmt = strbskip (fmt, "0123456789");
                }
		if (*fmt == '.') {
		    fP = TRUE;
		    if (fmt[1] == '*') {
		   	p = va_arg (vl, int);
			fmt += 2;
                    } else {
			p = atoi (fmt+1);
			fmt = strbskip (fmt+1, "0123456789");
                    }
                }
            }
	    if (*fmt == 'l') {
		fLong = TRUE;
		fmt++;
            }
	    if (*fmt == 'F') {
		fFar = TRUE;
		fmt++;
            }
            if (*fmt == '|') {
                while (*fmt != 'F') {
		    switch (*++fmt) {
			case 'd': fdF = TRUE; break;
			case 'p': fpF = TRUE; break;
			case 'f': ffF = TRUE; break;
			case 'e': feF = TRUE; break;
			case 'F': if (fmt[-1] == '|') {
				    fdF = TRUE;
				    fpF = TRUE;
				    ffF = TRUE;
				    feF = TRUE;
				    }
				  break;
                        default :
                            // va_end(vl);
			    return MSGERR_ZFORMAT;
                    }
                }
            }

	    switch (*fmt++) {
	    case 'c':
		p = va_arg (vl, int);
		*pStr++ = (char)p;
		*pStr = 0;
		
                break;

	    case 'x':
		base = 16;
	    case 'd':
		if (fLong) {
		
		    _ltoa ( va_arg (vl, long), pStr, base);
		
                } else {
		    _ltoa ( (long)va_arg (vl, int), pStr, base);
		
                }
                break;

	    case 's':
		pchar = va_arg (vl, char *);
		if (fFar) {
                    if (!fP) {
                        p = strlen ( pchar );
                    }
		    memmove ((char *) pStr, pchar , p);
		
                } else {
                    if (!fP) {
                        p = strlen ( pchar );
                    }
		    memmove ((char *) pStr, pchar , p);
		
                }
		fill = ' ';
		pStr[p] = 0;
                break;

	    case 'F':
		pStr[0] = 0;
                if (fdF) {
                    drive (pFileHead->pName, pStr);
                }
                if (fpF) {
                    path (pFileHead->pName, strend(pStr));
                }
                if (ffF) {
                    filename (pFileHead->pName, strend(pStr));
                }
                if (feF) {
                    extention (pFileHead->pName, strend(pStr));
                }
                break;

	    case '%':
		*pStr++ = '%';
		*pStr = 0;
                break;

            default:
                // va_end(vl);
		return MSGERR_ZFORMAT;
            }

	    /*	text is immediately at pStr.  Check width to justification
	     */
	    l = strlen (pStr);
	    if (w < 0) {
		/*  left-justify
		 */
		w = -w;
		if (l < w) {
		    memset ((char *) &pStr[l], fill, w - l);
		    pStr[w] = 0;
                }
            } else if (l < w) {
		/*  right-justify
		 */
		memmove ((char *) &pStr[w-l], (char *) &pStr[0], l);
		memset ((char *) &pStr[0], fill, w - l);
		pStr[w] = 0;
            }
	    pStr += strlen (pStr);
        }
    }
    *pStr = 0;
    // va_end(vl);
    return 0;
}

/*  FmtAssign - formatted assign
 *
 *  FmtAssign is used to both format and perform an assignment
 *
 *  pFmt	character pointer to sprintf-style formatting
 *  arg 	set of unformatted arguments
 *
 *  returns	result of DoAssign upon formatted result
 */
flagType
__cdecl
FmtAssign (
    char *pFmt,
    ...
    )
{
    char L_buf[ 512 ];
    va_list L_pArgs;

    va_start (L_pArgs, pFmt);
    ZFormat (L_buf, pFmt, L_pArgs);
    va_end (L_pArgs);
    return DoAssign (L_buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\zdebug.c ===
/*** zdebug.c - perform debugging operations
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   NOTE:
*    The intent of this file is to contain primarily *non-release* code for
*    internal debugging. As such it exists in a seperate segment, and all
*    routines should be FAR.
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "mep.h"


#define DEBFLAG Z

#if defined DEBUG

static char DbgBuffer[128];


void *
DebugMalloc (
    int     Size,
    BOOL    ZeroIt,
    char *  FileName,
    int     LineNumber
    )
{
	void	*b;
	//int	HeapStatus;

	UNREFERENCED_PARAMETER( FileName );
	UNREFERENCED_PARAMETER( LineNumber );

    if (ZeroIt) {
		b = ZeroMalloc(Size);
    } else {
		b = malloc(Size);
    }

	//
	//	Heap check time
	//
	// HeapStatus = _heapchk();
	//
	//if ( HeapStatus != _HEAPOK ) {
	//	sprintf(DbgBuffer, "  Error: _heapchk status %d\n", HeapStatus );
	//	OutputDebugString(DbgBuffer);
	//	assert( HeapStatus == _HEAPOK );
	//}

	return b;

}


void *
DebugRealloc (
    void    *Mem,
    int     Size,
    BOOL    ZeroIt,
    char *  FileName,
    int     LineNumber
    )
{
	void *	b;
	//int	HeapStatus;

    if (ZeroIt) {
		b = ZeroRealloc(Mem, Size);
    } else {
		b = realloc(Mem, Size);
	}

	//
	//	Heap check time
	//
	//HeapStatus = _heapchk();
	//
	//if ( HeapStatus != _HEAPOK ) {
	//	sprintf(DbgBuffer, "  Error: _heapchk status %d\n", HeapStatus );
	//	OutputDebugString(DbgBuffer);
	//	assert( HeapStatus == _HEAPOK );
	//}

	return b;
}






void
DebugFree (
    void    *Mem,
    char    *FileName,
    int     LineNumber
    )
{
	//int HeapStatus;

	free( Mem );

	//
	//	Heap check time
	//
	//HeapStatus = _heapchk();
	//
	//if ( HeapStatus != _HEAPOK ) {
	//	sprintf(DbgBuffer, "  Error: _heapchk status %d File %s line %d\n", HeapStatus, FileName, LineNumber );
	//	OutputDebugString(DbgBuffer);
	//	assert( HeapStatus == _HEAPOK );
	//}
}




unsigned
DebugMemSize (
    void *  Mem,
    char *  FileName,
    int     LineNumber
    )
{
	return MemSize( Mem );
}


#endif


#ifdef DEBUG
/*** _assertexit - display assertion message and exit
*
* Input:
*  pszExp	- expression which failed
*  pszFn	- filename containing failure
*  line 	- line number failed at
*
* Output:
*  Doesn't return
*
*************************************************************************/
void
_assertexit (
    char    *pszExp,
    char    *pszFn,
    int     line
    )
{
	static char _assertstring[] = "Editor assertion failed: %s, file %s, line %d\n";
	static char AssertBuffer[256];

	sprintf( AssertBuffer, _assertstring, pszExp, pszFn, line );

	OutputDebugString( AssertBuffer );

	// fprintf(stderr, _assertstring, pszExp, pszFn, line);
	// fflush(stderr);
    //
    //  BugBug
    //      If we CleanExit, then we will never be able to read the
    //      assertion text!
    //
	// if (!fInCleanExit) {
    //    CleanExit (1, CE_STATE);
	// }
    abort();
}




/*** _nearCheck - check far pointer to be a valid near one.
*
*  asserts that the passed far pointer is indeed a valid near pointer
*
* Input:
*  fpCheck	- pointer to be checked
*  pName	- pointer to it's name
*  pFileName	- pointer to file name containing the check
*  LineNum	- the line number in the file containing the check
*
* Output:
*  Returns near pointer
*
* Exceptions:
*  asserts out on failure
*
*************************************************************************/
void *
_nearCheck (
    void *fpCheck,
    char    *pName,
    char    *pFileName,
    int     LineNum
    )
{
    return fpCheck;

    pName; pFileName; LineNum;
}




/*** _pfilechk - verify integrity of the pfile list
*
* Purpose:
*
* Input:
*  none
*
* Output:
*  Returns TRUE if pfile list looks okay, else FALSE.
*
*************************************************************************/
flagType
_pfilechk (
    void
    )
{
    PFILE   pFileTmp    = pFileHead;

	while ( pFileTmp != NULL ) {

#ifdef DEBUG
		if ( pFileTmp->id != ID_PFILE ) {
			return FALSE;
		}
#endif
		if ( pFileTmp->pName == NULL ) {
			return FALSE;
		}

		pFileTmp = pFileTmp->pFileNext;
	}

	return TRUE;
}





/*** _pinschk - verify integrity of an instance list
*
* Purpose:
*
* Input:
*  pIns		- Place to start the check
*
* Output:
*  Returns TRUE if instance list looks okay, else FALSE.
*
*************************************************************************/
flagType
_pinschk (
    PINS    pIns
    )
{
    int     cMax        = 64000/sizeof(*pIns);

    while (pIns && cMax--) {
        if (   (pIns->id != ID_INSTANCE)
            || (pIns->pFile == 0)
            || ((PVOID)pIns->pNext == (PVOID)0xffff)
            ) {
            return FALSE;
        }
        pIns = pIns->pNext;
    }
    return (flagType)(cMax != 0);
}





/*** _heapdump - dump the heap status to stdout
*
* Purpose:
*
* Input:
*   p		= pointer to title string
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
_heapdump (
    char    *p
    )
{
    p;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\word.c ===
/*** word.c - movement by words
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"

#define ISWORD(c) (flagType)((isalnum(c) || isxdigit(c) || c == '_' || c == '$'))

flagType fWordMeta;


/*** fDoWord  -  Checks for beginning or end of word during fScan.
*
*  Checks the character at flScan and the previous character for a change
*  between ISWORD and !ISWORD. This finds:
*
*	ISWORD -> !ISWORD ==> Just after end of a word
*	!ISWORD -> ISWORD ==> First character of word.
*
*  Normally returns TRUE for first character. If fWordMeta, returns TRUE for
*  end of word. fWordMeta holds <meta>, so <meta><xword> functions move to
*  end of word, while <xword> functions move to the beginning.
*
*  Exception: if current character is last on the line and fWordMeta is set,
*  we return TRUE and move the cursor one character to the right.
*
* Globals:
*  scanbuf	- Detabbed text of line being scanned.
*  scanlen	- Index of last character in scanbuf
*  fWordMeta	- Value of fMeta when editor function was invoked
*
* Outputs:
*  Returns if (fWordMeta)
*	TRUE	- character at (flScan.col, flScan.lin) begins a word
*	FALSE	- Otherwise
*   else
*	TRUE	- character at (flScan.col - 1, flScan.lin) ends a word
*	FALSE	- Otherwise
*
*  Moves cursor before returning TRUE
*
*************************************************************************/
flagType
fDoWord (
    void
    )
{
    if (!fWordMeta) {
	if (ISWORD (scanbuf[flScan.col]) && (flScan.col == 0 || !ISWORD (scanbuf[flScan.col-1]))) {
	    cursorfl (flScan);
	    return TRUE;
        }
    } else if (flScan.col > 0 && ISWORD (scanbuf[flScan.col-1])) {
	if (!ISWORD (scanbuf[flScan.col])) {
	    cursorfl (flScan);
	    return TRUE;
        } else if (flScan.col == scanlen) {
	    docursor (flScan.col+1, flScan.lin);
	    return TRUE;
        }
    }
    return FALSE;
}





/*** pword - move forward one word
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE on cursor moved
*
*************************************************************************/
flagType
pword (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    fl flCur;

    flCur = pInsCur->flCursorCur;
    fWordMeta = fMeta;
    setAllScan (TRUE);
    fScan (flCur, FNADDR(fDoWord), TRUE, FALSE);
    return (flagType)((flCur.col != XCUR(pInsCur)) || (flCur.lin != YCUR(pInsCur)));

    argData; pArg;
}





/*** mword - move backwards one word
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE on cursor moved
*
*************************************************************************/
flagType
mword (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    fl flCur;

    flCur = pInsCur->flCursorCur;
    fWordMeta = fMeta;
    setAllScan (FALSE);
    fScan (flCur, FNADDR(fDoWord), FALSE, FALSE);
    return (flagType)((flCur.col != XCUR(pInsCur)) || (flCur.lin != YCUR(pInsCur)));

    argData; pArg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\zexit.c ===
/*** zexit.c - perform exiting operations
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"


extern char *ConsoleTitle;

/*** zexit - exit the editor function
*
* Purpose:
*   <exit>	    save current file, state and advance to next file on
*		    command line
*   <arg><exit>     save current file, state and exit now
*   <meta><exit>    save state and exit
*
* Input:
*  Standard editor function parameters
*
* Output:
*  Returns .....
*
* Exceptions:
*
*************************************************************************/
flagType
zexit (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    flagType f  = FALSE;

    /*
     * auto-save current file if appropriate
     */
    if (!fMeta) {
        AutoSave ();
    }


    /*
     *  <exit> goes to the next file on the command line
     *  if we got an arg (<arg><exit> or <arg><meta><exit>) and some files remain
     *     from the command line, then we prompt the user for confirmation.
     */
    if (   (   (pArg->argType == NOARG)
            || (   (pArg->argType == NULLARG)
                && (pFileFileList)
                && (pFileFileList->cLines)
                && (!confirm ("You have more files to edit. Are you sure you want to exit? (y/n): ", NULL))
               )
           )
        && fFileAdvance ()
       ) {
        return FALSE;
    }

    /*
     * If there is background compile in progress that the user does not wish to
     * kill, abort.
     */
    if (!BTKillAll ()) {
        return FALSE;
    }


    /*
     * If we ask, and the user changes his mind, abort.
     */
    if (fAskExit && !confirm("Are you sure you want to exit? (y/n): ", NULL)) {
        return FALSE;
    }


    /* Prompt the user to save dirty files.  If the user chooses
     * not to exit at this time, fSaveDirtyFiles returns FALSE.
     */
    if (!fSaveDirtyFiles()) {
        return FALSE;
    }


    /*
     * At this point, it looks like we're going to exit. Give extensions a chance
     * to change things prior to writing the temp file.
     */
    DeclareEvent (EVT_EXIT, NULL);

    //
    //  Restore original console title
    //
    //SetConsoleTitle( &ConsoleTitle );

    /*
     * Finally, leave.
     */
    CleanExit (0, CE_VM | CE_SIGNALS | CE_STATE);

    argData;
}






/*** fFileAdvance - attempt to read in the next file on the command line
*
* Purpose:
*  We get the next file from the command line and try to read it in.
*
* Input:
*
* Output:
*  Returns TRUE iff the next file was successfully read in
*
*************************************************************************/
flagType
fFileAdvance (
    void
    )
{
    pathbuf    L_buf;           /* buffer to get filename       */
    int      cbLine;        /* length of line               */
    flagType fTmp;          /* TRUE=> temp file             */
    char     *pBufFn;       /* pointer to actual file name  */

    while (pFileFileList && (pFileFileList->cLines)) {

        pBufFn = L_buf;
        fTmp   = FALSE;

        /*
         * get and delete the top line in the list, containing the next filename
         */
        cbLine = GetLine (0L, L_buf, pFileFileList);
        DelLine (FALSE, pFileFileList, 0L, 0L);

        if (pFileFileList->cLines == 0) {
            RemoveFile (pFileFileList);
            pFileFileList = 0;
        }

        if (cbLine) {

            /*
             * if it starts with "/t " the user wants it to be a temp
             */
            if ((L_buf[0] == '/') && (L_buf[1] == 't')) {
                fTmp = TRUE;
                pBufFn += 3;
            }

            /*
             * if we can open it, and in fact it became the current file (not just
             * a directory or drive change), set flags as appropriate and return
             * success.
             */
            if (fChangeFile (FALSE, pBufFn)) {
                if (strcmp(pFileHead->pName,pBufFn) == 0) {
                    if (fTmp) {
                        SETFLAG (FLAGS (pFileHead), TEMP);
                    }
                    return TRUE;
                }
            }
        }
    }

    if (pFileFileList) {
        RemoveFile (pFileFileList);
        pFileFileList = 0;
    }
    return FALSE;
}





/*** SetFileList - Create list of fully qualified paths
*
*  Creates the <file-list> psuedo file, and scans the command line for all
*  non-switch parameters. For each of those it adds their fully qualified
*  path name to the psuedo file. This allows the user to change directories
*  at will, and not lose the ability to <exit> to get to the next file he
*  specified on the command line.
*
* Input:
*  none
*
* Output:
*  Returns number of files in <file-list>
*  <file-list> created
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
LINE
SetFileList (
    void
    )
{
    pathbuf L_buf;			    /* buffer to build path in	    */
    char    *pBufAdd;			    /* pointer to place path at     */

    pFileFileList = AddFile ("<file-list>");
    IncFileRef (pFileFileList);
    SETFLAG (FLAGS(pFileFileList), REAL | FAKE | DOSFILE | READONLY);

    pBufAdd = L_buf;

    while (cArgs && !fCtrlc) {

        if (fSwitChr (**pArgs)) {
            //
            //  if filename is preceded by -t, then prepend a -t to the
            //  file list
            //
            _strlwr (*pArgs);
            if (!strcmp ("t", *pArgs+1) && cArgs >= 2) {
                strcpy (L_buf, "/t ");
                pBufAdd = L_buf+3;
            }
        } else {
            //
            //  Form full pathname, and add each filename to the file
            //  list pseudo-file
            //
            if ( strlen(*pArgs) > sizeof(L_buf) ) {
                printerror( "File name too long." );
            } else {
                *pBufAdd = '\0';
                CanonFilename (*pArgs, pBufAdd);
                if ( *pBufAdd == '\0' || strlen(pBufAdd) > BUFLEN ) {
                    printerror( "File name too long." );
                } else {
                    PutLine (pFileFileList->cLines, pBufAdd = L_buf, pFileFileList);
                }
            }
        }

        SHIFT (cArgs, pArgs);
    }

    return pFileFileList->cLines;
}





/*** CleanExit - Clean up and return to DOS.
*
* Input:
*  retc 	- Return code to DOS
*  flags	= OR combination of one or more:
*		    CE_VM	Clean Up VM
*		    CE_SIGNALS	Clean up signals
*		    CE_STATE	Update state file
*
* Output:
*  Doesn't Return
*
*************************************************************************/
void
CleanExit (
    int      retc,
    flagType flags
    )
{
    fInCleanExit = TRUE;
    domessage (NULL);
    prespawn (flags);

    //if (!fSaveScreen) {
    //    voutb (0, YSIZE+1, NULL, 0, fgColor);
    //}

    exit(retc);
}





/*** prespawn - pre-spawn "termination" processing
*
*  A form of "termination" prior to spawning a process. Restore/save state as
*  required before shelling out a program
*
* Input:
*  flags	= OR combination of one or more:
*		    CE_VM	Clean Up VM
*		    CE_SIGNALS	Clean up signals
*		    CE_STATE	Update state file
*
* Output:
*  Returns .....
*
*************************************************************************/
flagType
prespawn (
    flagType flags
    )
{
    if (TESTFLAG (flags, CE_STATE)) {
        WriteTMPFile ();
    }

#if DEBUG
    fflush (debfh);
#endif

    /*
     * Unhook the keyboard and return it to cooked mode, reset hardware as
     * appropriate and restore the screen mode on entry, and it's contents if
     * so configured.
     */
	KbUnHook ();

    SetErrorMode( 0 );

    if (TESTFLAG(fInit, INIT_VIDEO)) {
		SetVideoState(1);
	}

    //if (fSaveScreen) {
    RestoreScreen();
    //}

    fSpawned = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\zthread.c ===
/*** zthread.c - Contains background processing threads code
*
*   Purpose - Description
*
*     This is a general purpose background threads manager, which allows to
*     create background threads of execution (BTCreate) to which "jobs" are
*     sent for being executed one at a time (BTAdd).
*
*     A "Job" can either be:
*
*     - An external command that will be executed by spawning a
*	command interpreter (the system shell) after standard i/o
*	redirection, so its output will be collected in a "log file"
*	accessible to the user as a Z pseudo-file.
*
*     - A procedure.
*
*     Jobs sent to a background thread are guaranteed to be executed
*     synchronously one at a time in the order they have been sent.
*
*     When killing a background thread, any queued procedure will be called
*     with the fKilled flag on. This allow to have "cleanup" procedures.
*
*   Warnings:
*
*     - Take care that the data any queued procedure will eventually need
*   will be available by the time it will be called.
*
*     - Procedures are called at idle-time (relatively to Z), that means
*   that they can use any Z functionality in them EXCEPT keyboard input.
*
*   How it works:
*
*   while (some work is left to be done) {
*	dequeue an action from the pending queue
*	if (it is an external command) {
*	enter a critical section------------+
*	create a pipe w/proper redirection  |
*	spawn (no-wait) the action	|
*	undo the redirection		|
*	leave the critical section----------+
*	while (fgetl (pipe input)) {
*	    Take semaphore for editing VM
*	    append line to file
*	    Release semaphore
*	    }
*	}
*	else
*	call the procedure
*	}
*
*     Basically, for each external command, we create a pipe, spawn the command
*     and let the child fill the pipe.	When the child exits, the pipe gets
*     broken (we already closed the _write handle on our side) and fgetl gets
*     back an EOF.
*
*
*   Revision History:
*   26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/

#define INCL_DOSQUEUES
#include "mep.h"

//
//  Duplicate a handle in the current process
//
#define DupHandle(a,b) DuplicateHandle(GetCurrentProcess(),    \
				       a,		       \
				       GetCurrentProcess(),    \
				       b,		       \
				       0,		       \
				       TRUE,		       \
				       DUPLICATE_SAME_ACCESS)




#define BTSTACKSIZE 2048

static BTD  *pBTList = NULL;	   /* Background Threads List	    */


#define READ_BUFFER_SIZE    1024

typedef struct _READ_BUFFER {

    PVOID   UserBuffer;
    DWORD   UserBufferSize;
    HANDLE  Handle;
    DWORD   BytesLeftInBuffer;
    PBYTE   NextByte;
    BYTE    Buffer[READ_BUFFER_SIZE];

} READ_BUFFER, *PREAD_BUFFER;

VOID
InitReadBuffer(
    PVOID	    UserBuffer,
    DWORD	    UserBufferSize,
    HANDLE	    Handle,
    PREAD_BUFFER    Buf
    );

BOOL
ReadOneLine (
    PREAD_BUFFER    Buf
    );



/*** BTCreate - Creates a background thread
*
* Purpose:
*  To create a background thread, all we need to do is set up its
*  associated data structure.
*
* Input:
*
*  pName  = A symbolic name for the log file, just as <compile> or <print>.
*	This is the name under wich the user will get acces to the log
*	file.
*
* Output:
*  Returns a pointer to the allocated Background Thread Data structure
*
*************************************************************************/
BTD *
BTCreate (
    char * pName
    )
{
    BTD     *pBTD;	/* pointer to the created background	*/
		/* thread's data structure              */

    /*
     * Allocate the thread's data structure and its log file name
     */
    pBTD = (BTD *) ZEROMALLOC (sizeof (BTD));

    /*
     * Initialize the thread's data structure fields
     */
    pBTD->pBTName   = ZMakeStr (pName);
    pBTD->pBTFile   = NULL;
    pBTD->flags     = BT_UPDATE;
    pBTD->cBTQ	    = pBTD->iBTQPut = pBTD->iBTQGet = 0;

    pBTD->ThreadHandle	= INVALID_HANDLE_VALUE;
    pBTD->ProcAlive	= FALSE;
    InitializeCriticalSection(&(pBTD->CriticalSection));

    /*
     * We maintain a list of background threads data structures. This is used
     * by BTKillAll, BTWorking and BTIdle.
     */
    pBTD->pBTNext = pBTList;
    pBTList = pBTD;

    return (pBTD);
}





/*** BTAdd - Send procedure to be called or external command to be extecuted
*	 by background thread
*
* Input:
*  pBTD  - pointer to thread data structure
*  pProc - pointer to the procedure to be called (NULL if external command)
*  pStr  - pointer to the procedure parameter (or external command to execute
*      if  pBTProc is NULL)
*
* Output:
*
*  Returns TRUE if procedure successfully queued
*
*************************************************************************/
flagType
BTAdd (
    BTD       *pBTD,
    PFUNCTION pProc,
    char      *pStr
    )
{

    HANDLE	Handle;     /*	Thread handle	*/
    DWORD	tid;	    /*	Thread id	*/

    /*
     * We will access the thread's critical data
     */
    EnterCriticalSection(&(pBTD->CriticalSection));


    /*
     * If the queue is full, we cannot insert the request
     */
    if (pBTD->cBTQ == MAXBTQ) {
	LeaveCriticalSection(&(pBTD->CriticalSection));
    return FALSE;
    }


    /*
     * If the queue is empty AND there is no thread running,
     * we have to start the thread...
     */
    if (pBTD->cBTQ == 0 && !fBusy(pBTD)) {
    /*
     * Create the log file if it doesn't exist yet
     */
    if (!(pBTD->pBTFile = FileNameToHandle (pBTD->pBTName, pBTD->pBTName))) {
	pBTD->pBTFile = AddFile (pBTD->pBTName);
	FileRead (pBTD->pBTName, pBTD->pBTFile, FALSE);
	SETFLAG (FLAGS (pBTD->pBTFile), READONLY);

	}

    /*
     * Start the thread
	 */
    if (!(Handle = CreateThread( NULL,
		     BTSTACKSIZE,
		     (LPTHREAD_START_ROUTINE)BThread,
		     (LPVOID)pBTD,
		     0,
		     &tid))) {
	    LeaveCriticalSection(&(pBTD->CriticalSection));
	    return FALSE;
	}
	pBTD->ThreadHandle = Handle;

    }


    /*
     * Since there IS room, we just put the job at the PUT pointer.
     */
    pBTD->BTQJob[pBTD->iBTQPut].pBTJProc = pProc;
    pBTD->BTQJob[pBTD->iBTQPut].pBTJStr  = pStr ? ZMakeStr (pStr) : NULL;

    pBTD->cBTQ++;
    pBTD->iBTQPut = (pBTD->iBTQPut >= (MAXBTQ - 1)) ?
		0 :
		pBTD->iBTQPut + 1;

    /*
     * We're finished with critical data
     */
    LeaveCriticalSection(&(pBTD->CriticalSection));

    return TRUE;
}





/*** BTKill - Kill background job, if in progress
*
* Purpose:
*  Kills the background job and flushes the thread's associated queue
*
* Input:
*  pBTD - pointer to thread data structure
*
* Output:
*  Returns TRUE if background thread ends up idling, else false.
*
* Notes:
*  We'll call the queued procedures with fKilled flag on, and we'll free
*  the allocated strings.
*  We won't free the thread's stack (the thread has to finish).
*
*************************************************************************/
flagType
BTKill (
    BTD     *pBTD
    )
{
    REGISTER ULONG iBTQ;	     /* just an index to the queue elements  */

    assert (pBTD);

    /*
     * We'll work if somthing's running and the user confirms
     */
    if ((fBusy(pBTD))
     && confirm ("Kill background %s ?", pBTD->pBTName)
       ) {


    /*
     * We will access critical data
	 */
	EnterCriticalSection(&(pBTD->CriticalSection));

    /*
     * Kill any child process
	 */

	if (pBTD->ProcAlive) {
	    TerminateProcess(pBTD->ProcessInfo.hProcess, 0);
	    pBTD->ProcAlive = FALSE;
	}

    /*
     * Flush the queue:
     *	 - Call the queued procedures with fKilled flag on
     *	 - Free the strings
     */
    for (iBTQ = pBTD->iBTQGet;
	 iBTQ != pBTD->iBTQPut;
	 iBTQ = (iBTQ >= MAXBTQ - 1) ? 0 : iBTQ + 1
	) {
	    if (pBTD->BTQJob[iBTQ].pBTJProc != NULL) {
		(*pBTD->BTQJob[iBTQ].pBTJProc) (pBTD->BTQJob[iBTQ].pBTJStr, TRUE);
	    }
	    if (pBTD->BTQJob[iBTQ].pBTJStr != NULL) {
		FREE (pBTD->BTQJob[iBTQ].pBTJStr);
	    }
	}

    pBTD->cBTQ = pBTD->iBTQPut = pBTD->iBTQGet = 0;

    /*
     * We're done with critical data
	 */
	LeaveCriticalSection(&(pBTD->CriticalSection));

    /*
     * We know the background thread didn't finish its job yet (It needs
     * at least to get the semaphore before exiting), but we pretend...
     */
    return TRUE;
    }

    return (flagType) (!fBusy(pBTD));
}




/*** BTKillAll - Kill all background jobs, for editor termination
*
* Purpose:
*  Kills all background jobs and flush all threads' associated queues
*
* Input:
*  none
*
* Output:
*  Returns TRUE if all background jobs have been killed, else false.
*
*************************************************************************/
flagType
BTKillAll (
    void
    )
{
    REGISTER BTD *pBTD;     /* pointer for scanning the threads list	*/

    for (pBTD = pBTList; pBTD != NULL; pBTD = pBTD->pBTNext) {
	if (!BTKill (pBTD)) {
	    return FALSE;
	}
    }
    return TRUE;
}



/*** BTWorking - Checks if any background processing is underway...
*
* Input:
*  None
*
* Output:
*  Returns TRUE if some background processing is active, FALSE otherwise
*
* Notes:
*  We are just scanning each thread queue status using the global list.
*
*************************************************************************/
flagType
BTWorking (
    void
    )
{
    REGISTER BTD *pBTD;     /* pointer for scanning the threads list	*/

    for (pBTD = pBTList; pBTD != NULL; pBTD = pBTD->pBTNext) {
	if (fBusy(pBTD)) {
	    break;
	}
    }
    return (flagType) (pBTD != NULL);
}





/*** BThread - Separate thread that starts up jobs as they are put in the queue
*
* Input:
*   Nothing
*
* Output:
*   Nothing
*
* Notes:
*   - We won't send any message nor have any user interaction neither
*     call any non-reentrant procedure, except at idle time.
*
*
*************************************************************************/

//  #pragma check_stack (off)
void
BThread (
    BTD *pBTD
    )
{
					    /* and for reading the pipe       */
    PFUNCTION	pProc;			    /* procedure to be called	      */
    char    *pStr;			    /* External command or parameter  */


    while (TRUE) {

	//
	//  We will access critical data
	//

	EnterCriticalSection(&(pBTD->CriticalSection));

	//
	//  If there's nothing in the queue, we end the thread.
	//

	if (pBTD->cBTQ == 0) {
	    pBTD->flags &= ~BT_BUSY;
	    SETFLAG (fDisplay, RSTATUS);
	    LeaveCriticalSection(&(pBTD->CriticalSection));
	    ExitThread( 0 );
	    }

	//
	//  Set the status as busy
	//

	pBTD->flags |= BT_BUSY;
	SETFLAG (fDisplay, RSTATUS);

	//
	//  Copy out the Job
	//

	pProc = pBTD->BTQJob[pBTD->iBTQGet].pBTJProc;
	pStr  = pBTD->BTQJob[pBTD->iBTQGet].pBTJStr;

	pBTD->cBTQ--;
	pBTD->iBTQGet = (pBTD->iBTQGet >= (MAXBTQ - 1)) ?
			0 :
			pBTD->iBTQGet + 1;

	//
	//  We're done with the critical data
	//

	LeaveCriticalSection(&(pBTD->CriticalSection));

	if (pProc != NULL) {

	    //
	    //	Procedure to call: we'll do it at idle time and we'll free any
	    //	stored parameter
	    //

        WaitForSingleObject( semIdle, INFINITE);
	    (*pProc) (pStr, FALSE);
	    if (pStr)
		FREE (pStr);
	    SetEvent( semIdle );
	    }
	else {

	    //
	    //	External command to spawn: First we build the command line
	    //

	    //
	    //	Here we spawn processes under the Win32 subsystem of
	    //	NT.
	    //

	    char    CommandLine[MAX_PATH];	//  Command line
	    BOOL    StatusOk;			//  status value
	    HANDLE  SavedStdIn; 		//  Original Standard Input
	    HANDLE  SavedStdOut;		//  Original Standard Output
	    HANDLE  SavedStdErr;		//  Original Standard Error
	    HANDLE  PipeRead;			//  Pipe - read end
            HANDLE  PipeWrite;                  //  Pipe - write end
            HANDLE  OutHandle, ErrHandle;
	    STARTUPINFO 	StartupInfo;	//  Startup information
	    linebuf LineBuf;			//  Buffer for 1 line
	    READ_BUFFER  ReadBuffer;
	    BOOL    MoreToRead = TRUE;		//  There is more to read
	    SECURITY_ATTRIBUTES PipeAttributes; //  Pipe Security attributes


	    strcpy(CommandLine, pComSpec);	//  Call command interpreter
	    strcat(CommandLine," /c "); 	//  and execute
	    strcat(CommandLine, pStr);		//  the specified command

	    //
	    //	First we save the standard handles
	    //

	    SavedStdIn	= GetStdHandle(STD_INPUT_HANDLE);
	    SavedStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	    SavedStdErr = GetStdHandle(STD_ERROR_HANDLE);

	    //
	    //	Create a pipe
	    //

	    PipeAttributes.nLength		=   sizeof(SECURITY_ATTRIBUTES);
	    PipeAttributes.lpSecurityDescriptor =   NULL,
	    PipeAttributes.bInheritHandle	=   TRUE;
	    StatusOk = CreatePipe( &PipeRead,
				   &PipeWrite,
				   &PipeAttributes,
				   0 );

	    if (!StatusOk) {
		domessage("Cannot create pipe - did not create process.");
		continue;
		}

	    //
	    //	We will mess with standard handles, so do it
	    //	in the IO critical section.
	    //

	    EnterCriticalSection(&IOCriticalSection);

	    //
	    //	Redirect standard handles
	    //

            SetStdHandle(STD_INPUT_HANDLE,  INVALID_HANDLE_VALUE);
	    SetStdHandle(STD_OUTPUT_HANDLE, PipeWrite);
	    SetStdHandle(STD_ERROR_HANDLE,  PipeWrite);

	    //
	    //	Start the process
	    //

	    memset(&StartupInfo, '\0', sizeof(STARTUPINFO));
	    StartupInfo.cb = sizeof(STARTUPINFO);

	    StatusOk = CreateProcess( NULL,
				      CommandLine,
				      NULL,
				      NULL,
				      TRUE,
				      0,
				      NULL,
				      NULL,
				      &StartupInfo,
				      &(pBTD->ProcessInfo) );

	    //
	    //	Now restore the original handles
	    //
            OutHandle = GetStdHandle(STD_OUTPUT_HANDLE);
            CloseHandle(OutHandle);

            ErrHandle = GetStdHandle(STD_ERROR_HANDLE);

            if (ErrHandle != OutHandle && ErrHandle != INVALID_HANDLE_VALUE)
                CloseHandle(ErrHandle);


	    SetStdHandle(STD_INPUT_HANDLE,  SavedStdIn);
	    SetStdHandle(STD_OUTPUT_HANDLE, SavedStdOut);
	    SetStdHandle(STD_ERROR_HANDLE,  SavedStdErr);

	    LeaveCriticalSection(&IOCriticalSection);


	    if (StatusOk) {

		//
		//  Copy all the output to the log file
		//

		InitReadBuffer( LineBuf, sizeof(linebuf), PipeRead, &ReadBuffer );

		while (MoreToRead) {

		    if (ReadOneLine( &ReadBuffer ) ) {

			//
			//  Append the new line
			//

                        WaitForSingleObject( semIdle, INFINITE);
                            AppFile (LineBuf, pBTD->pBTFile);

			//
			//  If the update flag is on, then we must update
			//  instances of the file so the last line we read
			//  will be displayed
			//
			if (pBTD->flags & BT_UPDATE)
			    UpdateIf (pBTD->pBTFile, pBTD->pBTFile->cLines - 1, FALSE);

			SetEvent( semIdle );

			}
		    else {
			//
			//  We only stop trying if the process has terminated
			//
			if (WaitForSingleObject((pBTD->ProcessInfo.hProcess), 0 ) == 0)
			    MoreToRead = FALSE;
			}
		    }

		//
                //  Close the pipe handles (Note that the PipeWrite handle
                //  was closed above)

                WaitForSingleObject( semIdle, INFINITE);
                CloseHandle(PipeRead);
                SetEvent( semIdle );

		//
		// Wait for the spawned process to terminate
		//
		}

        WaitForSingleObject( semIdle, INFINITE);
	    if (pStr)
		FREE (pStr);
	    bell ();
	    SetEvent( semIdle );

	    }

	}
}
// #pragma check_stack ()


VOID
InitReadBuffer(
    PVOID	    UserBuffer,
    DWORD	    UserBufferSize,
    HANDLE	    Handle,
    PREAD_BUFFER    Buf
    )
{
    Buf->UserBuffer	    = UserBuffer;
    Buf->UserBufferSize     = UserBufferSize;
    Buf->Handle 	    = Handle;
    Buf->BytesLeftInBuffer  = 0;
    Buf->NextByte	    = Buf->Buffer;
}


int
ReadOneChar (
    PREAD_BUFFER    pbuf
    )
{
    //
    //	Check to see if buffer is empty
    //

    if (pbuf->BytesLeftInBuffer == 0) {

	//
	//  Check to see if a fill of the buffer fails
	//

	if (!ReadFile (pbuf->Handle, pbuf->Buffer, READ_BUFFER_SIZE, &pbuf->BytesLeftInBuffer, NULL)) {

	    //
	    //	Fill failed, indicate buffer is empty and return EOF
	    //

	    pbuf->BytesLeftInBuffer = 0;
	    return -1;
	    }

	//
	//  Check to see if nothing read
	//
	if (pbuf->BytesLeftInBuffer == 0)
	    return -1;

	pbuf->NextByte = pbuf->Buffer;
	}

    //
    //	Buffer has pbuf->BytesLeftInBuffer chars left starting at
    //	pbuf->NextByte
    //

    pbuf->BytesLeftInBuffer--;
    return *pbuf->NextByte++;
}

//
//  Assumes tabs are 8 spaces wide on input
//


BOOL
ReadOneLine (
    PREAD_BUFFER    pbuf
    )
{
    PBYTE p;
    PBYTE pEnd;
    int c = 0;
    int cchTab;

    //
    //	Set pointer to beginning of output buffer
    //

    p = (PBYTE)pbuf->UserBuffer;
    pEnd = p + pbuf->UserBufferSize - 1;

    //
    //	read in chars, ignoring \r until buffer is full, \n, or \0
    //	expands tabs
    //

    while (p < pEnd) {
	c = ReadOneChar (pbuf);

	//
	//  CR is noise in line (we ignore it)
	//

	if (c == '\r')
	    continue;

	//
	//  EOF or NL is end-of-line indicator
	//

	if (c == -1 || c == '\n')
	    break;

	//
	//  tabs are expanded to 8 column boundaries, but not to
	//  overflow the line
	//

	if (c == '\t') {
	    cchTab = 8 - (ULONG)(p - (PBYTE)pbuf->UserBuffer) % 8;
	    cchTab = min (cchTab, (int)(pEnd - p));
	    while (cchTab--)
		*p++ = (BYTE) ' ';
	    }
	else
	    *p++ = (BYTE) c;
	}

    *p = 0;

    return c != -1 || strlen (pbuf->UserBuffer) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\zinit.c ===
/*** zinit.c - editor initialization
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/
#define INCL_DOSFILEMGR
#define INCL_SUB
#define INCL_DOSERRORS
#define INCL_DOSSEMAPHORES
#define INCL_DOSPROCESS

#include "mep.h"
#include "keyboard.h"
#include <conio.h>


#define DEBFLAG ZINIT

#define TSTACK          2048            /* Thread stack size            */

/*
 * Data initializations
 */
flagType    fAskExit    = FALSE;
flagType    fAskRtn     = TRUE;
flagType    fAutoSave   = TRUE;
flagType    fBoxArg     = FALSE;
flagType    fCgaSnow    = TRUE;
flagType    fEditRO     = TRUE;
flagType    fErrPrompt  = TRUE;
flagType    fGlobalRO   = FALSE;
flagType    fInsert     = TRUE;
flagType    fDisplayCursorLoc = FALSE;
flagType    fMacroRecord= FALSE;
flagType    fMsgflush   = TRUE;
flagType    fNewassign  = TRUE;
flagType    fRealTabs   = TRUE;
flagType    fSaveScreen = TRUE;
flagType    fShortNames = TRUE;
flagType    fSoftCR     = TRUE;
flagType    fTabAlign   = FALSE;
flagType    fTrailSpace = FALSE;
flagType    fWordWrap   = FALSE;
flagType    fBreak      = FALSE;
/*
 * Search/Replace globals
 */
flagType fUnixRE        = FALSE;
flagType fSrchAllPrev   = FALSE;
flagType fSrchCaseSwit  = FALSE;
flagType fSrchDirPrev   = TRUE;
flagType fSrchRePrev    = FALSE;
flagType fSrchWrapSwit  = FALSE;
flagType fSrchWrapPrev  = FALSE;
flagType fUseMouse      = FALSE;

flagType fCtrlc;
flagType fDebugMode;
flagType fMetaRecord;
flagType fDefaults;
flagType fMessUp;
flagType fMeta;
flagType fRetVal;
flagType fTextarg;
flagType fSrchCasePrev;
flagType fRplRePrev;
buffer   srchbuf;
buffer   srcbuf;
buffer   rplbuf;

unsigned kbdHandle;

int                backupType  = B_BAK;
int         cUndelCount = 32767;        /* essentially, infinite        */
int         cCmdTab     = 1;
LINE        cNoise      = 50;
int         cUndo       = 10;
int         EnTab       = 1;
char *      eolText     = "\r\n";       /* our definition of end of line*/
int             fileTab = 8;
int     CursorSize=0;
int         hike        = 4;
int         hscroll     = 10;
unsigned    kindpick    = LINEARG;
char        tabDisp     = ' ';
int         tabstops    = 4;
int         tmpsav      = 20;
char        trailDisp   = 0;
int         vscroll     = 1;
COL         xMargin     = 72;

PCMD *  rgMac       = NULL;         /* macro array                  */

int      cMac;

int      ballevel;
char     *balopen, *balclose;
unsigned getlsize         = 0xFE00;

char     Name[];
char     Version[];
char     CopyRight[];

EDITOR_KEY keyCmd;

int     ColorTab[16];

int      cArgs;
char     **pArgs;

char     * pNameEditor;
char     * pNameTmp;
char     * pNameInit;
char     * pNameHome;
char    *pComSpec;

int cMacUse;
struct macroInstanceType mi[MAXUSE];

PCMD     cmdSet[MAXEXT];
PSWI     swiSet[MAXEXT];
char    *pExtName[MAXEXT];




PSCREEN OriginalScreen;
PSCREEN MepScreen;
KBDMODE OriginalScreenMode;











/*
 * Compile and print threads
 */
BTD    *pBTDComp  = NULL;
BTD    *pBTDPrint = NULL;

unsigned    LVBlength   = 0;            /* We use this to know if we're detached */

/*
 * String values.
 */
char rgchPrint [] = "<print>";
char rgchComp  [] = "<compile>";
char rgchAssign[] = "<assign>";
char rgchEmpty[]  = "";
char rgchInfFile[]= "<information-file>";
char rgchUntitled[]="<untitled>";
char rgchWSpace[] = "\t ";        /* our definition of white space*/
char Shell[]      = SHELL;
char User[]       = "USER";
/*
 * autoload extension paterns.
 */
char rgchAutoLoad[]="m*.pxt";

sl                      slSize;
PFILE    pFilePick = NULL;
PFILE    pFileFileList = NULL;
PFILE    pFileAssign = NULL;
PFILE    pFileIni = NULL;
struct   windowType WinList[MAXWIN+1];
int      iCurWin = 0;
PINS        pInsCur     = NULL;
PWND        pWinCur     = NULL;
int                     cWin    = 0;
PFILE           pFileHead=NULL;
COMP     *pCompHead = NULL;
MARK     *pMarkHead = NULL;
char     *pMarkFile = NULL;
char     *pPrintCmd = NULL;
PFILE    pPrintFile = NULL;
buffer  scanbuf;
buffer  scanreal;
int     scanlen;
fl              flScan;
rn              rnScan;

#ifdef DEBUG
int      debug, indent;
FILEHANDLE debfh;
#endif

fl               flArg;
int      argcount;

flagType fInSelection = FALSE;

fl               flLow;
fl               flHigh;
LINE     lSwitches;
int      cRepl;
char     *ronlypgm = NULL;
buffer   buf;
buffer   textbuf;
int      Zvideo;
int      DOSvideo;

flagType *fChange = NULL;
unsigned fInit;
flagType fSpawned = FALSE;





flagType    fDisplay    = RCURSOR | RTEXT | RSTATUS;

flagType    fReDraw     = TRUE;
HANDLE      semIdle     = 0;

char        IdleStack[TSTACK*2];        /* Idle thread stack            */

int         argcount    =  0;
CRITICAL_SECTION    IOCriticalSection;
CRITICAL_SECTION    UndoCriticalSection;
CRITICAL_SECTION        ScreenCriticalSection;

/*
 * predefined args. Handy for invoking some set functions ourselves
 */
ARG     NoArg           = {NOARG, 0};


/*
 *  The format of these strings is identical to that of the assignments in
 *  TOOLS.INI
 */
char * initTab[] = {
/*  Default compilers */
             "extmake:c    cl /c /Zp %|F",
             "extmake:asm  masm -Mx %|F;",
             "extmake:pas  pl /c -Zz %|F",
             "extmake:for  fl /c %|F",
             "extmake:bas  bc /Z %|F;",
             "extmake:text nmake %s",

/*  Default macros */
//
// the F1 key is assigned to this message by default, so that in the case
// that on-line help is NOT loaded, we respond with this message. Once the
// help extension IS loaded, it automatically makes new assignments to these
// keystrokes, and all is well with the world.
//
             "helpnl:=cancel arg \"OnLine Help Not Loaded\" message",
             "helpnl:f1",
             "helpnl:shift+f1",
             "helpnl:ctrl+f1",
             "helpnl:alt+f1",
    NULL
    };

/*
 * exttab is a table used to keep track of cached extension-specific TOOLS.INI
 * sections.
 */
#define MAXEXTS 10                      /* max number of unique extensions*/

struct EXTINI {
    LINE    linSrc;                     /* TOOLS.INI line of the text   */
    char    ext[5];                     /* the file extension (w/ ".")  */
    } exttab[10]        = {0};


flagType         fInCleanExit = FALSE;

char    ConsoleTitle[256];



/*** InitNames - Initialize names used by editor
*
*  Initializes various names used by the editor which are based on the name it
*  was invoked with. Called immediately on entry.
*
* Input:
*  name         = Pointer to name editor invoked as
*
* Output:
*  Returns nothing
*
*  pNameHome    = environment variable to use as "home" directory
*  pNameEditor  = name editor invoked as
*  pNameTmp     = name of state preservation file (M.TMP)
*  pNameInit    = name of tools initialization file (TOOLS.INI)
*  pComSpec     = name of command processor
*
*************************************************************************/
void
InitNames (
    char * name
    )
{
    char *pname = name;
    char *tmp;

    //
    //  Just in case name has blanks after it, we will patch it
    //
    while ( *pname != '\0' &&
            *pname != ' ' ) {
        pname++;
    }
    *pname = '\0';


    if (!getenv(pNameHome = "INIT")) {
        pNameHome = User;
    }

    filename (name, buf);
    pNameEditor = ZMakeStr (buf);

    sprintf (buf, "$%s:%s.TMP", pNameHome, pNameEditor);
    pNameTmp = ZMakeStr (buf);

    sprintf (buf, "$%s:tools.ini", pNameHome);
    pNameInit = ZMakeStr (buf);

    pComSpec = NULL;
    if (!(tmp = (char *)getenvOem("COMSPEC"))) {
        pComSpec = Shell;
    } else {
        //
        //  We cannot keep a pointer to the environment table, so we
        //  point to a copy of the command interpreter path
        //
        char *p = MALLOC(strlen(tmp)+1);
        if (p) {
            strcpy(p,tmp);
            pComSpec = p;
        }
        free( tmp );
    }


#if 0
    if (!(pComSpec = getenv("COMSPEC"))) {
        pComSpec = Shell;
    } else {
        //
        //  We cannot keep a pointer to the environment table, so we
        //  point to a copy of the command interpreter path
        //
        char *p = MALLOC(strlen(pComSpec)+1);
        strcpy(p,pComSpec);
        pComSpec = p;
    }
#endif
}





/*** init - one-time editor start-up initialization
*
*  One-time editor initialzation code. This code is executed (only) at
*  start-up, after the command line switches have been parsed.
*
* Input:
*  none
*
* Output:
*  Returns TRUE if valid initialization
*
*************************************************************************/
int
init (
    void
    )
{

    DWORD   TPID;                      /* Thread Id                     */
    KBDMODE Mode;                      /* console mode                  */

    /*
     * Set up the base switch and command sets.
     */
    swiSet[0] = swiTable;
    cmdSet[0] = cmdTable;
    pExtName[0] = ZMakeStr (pNameEditor);

    /*
     * Initialize VM, and bomb off if that didn't work.
     */
        asserte( getlbuf = MALLOC( getlsize ));

    //    fSaveScreen = FALSE;
    //    CleanExit (1, FALSE);
    rgMac = (PCMD *)MALLOC ((long)(MAXMAC * sizeof(PCMD)));
    // assert (_heapchk() == _HEAPOK);


    /*
     * Attempt to get the *current* video state. If it's not one that we
     * understand, bomb off. Else, get the x and y sizes, for possible use later
     * as our editting mode, use postspawn to complete some initialization, and
     * set up our default colors.
         */

    //
    //  Create a new screen buffer and make it the active one.
    //
    InitializeCriticalSection(&ScreenCriticalSection);
    MepScreen          = consoleNewScreen();
    OriginalScreen = consoleGetCurrentScreen();
    if ( !MepScreen || !OriginalScreen ) {
        fprintf(stderr, "MEP Error: Could not allocate console buffer\n");
        exit(1);
    }
    consoleGetMode(&OriginalScreenMode);
        asserte(consoleSetCurrentScreen(MepScreen));
    //
    //  Put the console in raw mode
    //
    Mode = (OriginalScreenMode & ~(CONS_ENABLE_LINE_INPUT | CONS_ENABLE_PROCESSED_INPUT | CONS_ENABLE_ECHO_INPUT )) | CONS_ENABLE_MOUSE_INPUT ;
    consoleSetMode(Mode);
    SetConsoleCtrlHandler( CtrlC, TRUE );

    consoleFlushInput();

    postspawn (FALSE);

    hgColor     = GREEN;
    errColor    = RED;
    fgColor     = WHITE;
    infColor    = YELLOW;
    staColor    = CYAN;
    selColor    = WHITE << 4;
    wdColor     = WHITE;

    //
    //  Remember console title
    //
    ConsoleTitle[0] = '\0';
    GetConsoleTitle( ConsoleTitle, sizeof(ConsoleTitle) );

    /*
     * Create the clipboard
     */
    pFilePick = AddFile ("<clipboard>");
    pFilePick->refCount++;
    SETFLAG (FLAGS(pFilePick), REAL | FAKE | DOSFILE | VALMARKS);

    mepInitKeyboard( );          // Init the keyboard

    //
    //  Initialize the critical section that we use for thread
    //  synchronization
    //
    InitializeCriticalSection(&IOCriticalSection);
    InitializeCriticalSection(&UndoCriticalSection);

    //
    //  Create the semIdle event
    //

    asserte(semIdle = CreateEvent(NULL, FALSE, FALSE, NULL));



    /*
     * Create list of fully qualified paths for files on argument line, then
     * if files were specified, ensure that we are in initial state
     */
    SetFileList ();


    /*
     * Try to read the TMP file
     */
    ReadTMPFile ();


    /*
     * Update the screen data to reflect whatever resulted from reading the .TMP
     * file.
     */
    SetScreen ();


    /*
     * read tools.ini for 1st time
     */
    loadini (TRUE);

        SetScreen ();

        //
        //      Set the cursor size
        //
        SetCursorSize( CursorSize );

    //
    //  Make sure that hscroll is smaller than the window's width
    //
    if ( hscroll >= XSIZE ) {
        hscroll = XSIZE-1;
    }

    AutoLoadExt ();

    /*
     * Create the Idle time thread
     */

    if (!CreateThread(NULL, TSTACK * 2, (LPTHREAD_START_ROUTINE)IdleThread, NULL, 0, &TPID)) {
        disperr(MSGERR_ITHREAD);
    }


    /*
     * Create background threads for <compile> and <print>,
     */
    pBTDComp  = BTCreate (rgchComp);
    pBTDPrint = BTCreate (rgchPrint);

        assert(_pfilechk());
    return TRUE;
}





/*** DoInit - Load init file section
*
*  load from tools.ini, the tag name-tag into the editor configuration
*  table. set ffound to true if we find the appropriate file
*
* Input:
*  tag          = the name of the subsection to be read, or NULL for base
*                 section
*  pfFound      = Pointer to flag to be set TRUE if any assignment is actually
*                 made. May also be NULL.
*  linStart     = line number to start processing from if we already have
*                 a tools.ini. This make re-reading a previously read
*                 section faster.
*
* Output:
*  Returns TOOLS.INI line number of matching section. Assignments may be made,
*  and pfFound updated accordingly.
*
*************************************************************************/
LINE
DoInit (
    char *tag,
    flagType *pfFound,
    LINE    linStart
    )
{
    pathbuf  L_buf;                           /* full filename for TOOLS.INI  */
    buffer   bufTag;                        /* full tag to look for         */
    LINE     cLine;                         /* line in TOOLS.INI            */
    REGISTER char *pTag;                    /* pointer to tag, if found     */

    /*
     * if Tools.Ini hasn't already been found, attempt to locate it, and read in
     * it's contents.
     */
    if (pFileIni == NULL) {
        linStart = 0;
        pFileIni = (PFILE)-1;
        assert (pNameInit);
        if (findpath (pNameInit, L_buf, TRUE)) {
            pFileIni = FileNameToHandle (L_buf, NULL);
            if (pFileIni == NULL) {
                pFileIni = AddFile (L_buf);
                assert (pFileIni);
                pFileIni->refCount++;
                SETFLAG (FLAGS(pFileIni), DOSFILE);
            }
            if (!TESTFLAG (FLAGS(pFileIni), REAL)) {
                FileRead (L_buf, pFileIni, FALSE);
            }
        }
    }

    if (pFileIni != (PFILE)-1) {
        /*
         * If there is no starting line number, form the full tag name to be looked
         * for, and scan the file for it.
         */
        if (!(cLine = linStart)) {
            strcpy( bufTag, pNameEditor );
            // strcpy (bufTag, "mepnt"); //pNameEditor);
            if (tag != NULL && *tag != '\0') {
                strcat (strcat (bufTag, "-"), tag);
                }
            _strlwr (bufTag);
            linStart = cLine = LocateTag(pFileIni, bufTag);
        }

        /*
         * if the section was found, scan that section, until a new tag line
         * is found, and process the contents of that section
         */
        if (cLine) {
            pTag = NULL;
            while (pTag = GetTagLine (&cLine, pTag, pFileIni)) {
                DoAssign (pTag);
                if (pfFound) {
                    *pfFound = TRUE;
                }
                //assert (_heapchk() == _HEAPOK);
            }
        }
    }
    return linStart;
}





/*** IsTag - returns pointer to tag if line is marker; NULL otherwise
*
*  Identify tag lines in TOOLS.INI
*
* Input:
*  buf          = pointer to string to check
*
* Output:
*  Returns pointer to tag if line is marker; NULL otherwise
*
*************************************************************************/
char *
IsTag (
    REGISTER char *buf
    )
{
    REGISTER char *p;

    assert (buf);
    buf = whiteskip (buf);
    if (*buf++ == '[') {
        if (*(p = strbscan (buf, "]")) != '\0') {
            *p = 0;
            return buf;
        }
    }
    return NULL;
}





/*** LocateTag - Find TAG in TOOLS.INI formatted file
*
*  Locates a specific tag
*
* Input:
*  pFile        = pFile of file to be searched
*  pText        = text of the tag (no brackets)
*
* Output:
*  Returns line number +1 of tag line
*
*************************************************************************/
LINE
LocateTag (
    PFILE   pFile,
    char    *pText
    )
{
    buffer  L_buf;                            /* working buffer               */
    char    c;                              /* temp char                    */
    LINE    lCur;                           /* current line number          */
    char    *pTag;                          /* pointer to tag               */
    char    *pTagEnd;                       /* pointer to end of            */

    for (lCur = 0; lCur < pFile->cLines; lCur++) {
        GetLine (lCur, L_buf, pFile);
        if (pTagEnd = pTag = IsTag (L_buf)) {
            while (*pTagEnd) {
                pTagEnd = whitescan (pTag = whiteskip (pTagEnd));
                c = *pTagEnd;
                *pTagEnd = 0;
                if (!_stricmp (pText, pTag)) {
                    return lCur+1;
                }
                *pTagEnd = c;
            }
        }
    }
    return 0L;
}

/*** InitExt - execute extension-dependant TOOLS.INI assignments
*
*  Executes the assignments in the user's TOOLS.INI that are specific to a
*  particular file extension.
*
*  We cache the text of the tools.ini section in VM the first time it is read,
*  such that TOOLS.INI need not be read on every file change. This cache is
*  invalidated (and freed) on execution of the initialize command.
*
* Input:
*  szExt        = Pointer to string containing extension. MAX 4 CHARACTERS!
*
* Output:
*  Returns TRUE if section found & executed.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
InitExt (
    char    *szExt
    )
{
    flagType f;                             /* random flag                  */
    static int iDiscard         = 0;        /* roving discard index         */
    struct EXTINI *pIni;                    /* pointer to found entry       */
    struct EXTINI *pIniNew      = NULL;     /* pointer to new entry */

    /*
     * Only do this if we actually have a valid tools.ini. Before the initial
     * TOOLS.INI read, pFileIni will be zero, and we should not do this, because
     * we might cause it to be read (and then loadini will destroy some of what
     * happened, but not all). In cases where there simply is not TOOLS.INI
     * pFileIni may be -1, but that's caught later.
     */
    if (pFileIni == NULL) {
        return FALSE;
    }

    /*
     * Search init table for the line number of cached init section, and as soon
     * as found, re-read that section. ALSO, as we're walking, keep track of any
     * free table entries we find, so that we can create a cache if it's not.
     */
    for (pIni = &exttab[0]; pIni <= &exttab[9]; pIni++) {
        if (!strcmp (szExt, pIni->ext)) {
            pIni->linSrc = DoInit (szExt, &f, pIni->linSrc);
            return TRUE;
        }
        if (!(pIni->ext[0])) {
            pIniNew = pIni;
        }
    }

    /*
     * we did not find the table entry for the extension, then attempt to create
     * one. This means get rid of one, if there is no room.
     */
    if (!pIniNew) {
        pIni = &exttab[iDiscard];
        iDiscard = (iDiscard + 1) % 10;
    } else {
        pIni = pIniNew;
    }
    strcpy (pIni->ext, szExt);

    /*
     * read the section once to get the size. If the section does not exist, then
     * discard the table entry, and look for the default section "[M-..]"
     */
    if (pIni->linSrc = DoInit (szExt, &f, 0L)) {
        return TRUE;
    }
    pIni->ext[0] = 0;
    DoInit ("..", &f, 0L);
    return FALSE;
}




/*** loadini - load tools.ini data
*
*  Reads TOOLS.INI at startup, and when the initialize function is used.
*
* Input:
*  fFirst       = true if call at startup
*
* Output:
*  Returns
*
*************************************************************************/
int
loadini (
    flagType fFirst
    )
{
    buffer   L_buf;
    flagType fFound = FALSE;
    int i;

    /*
     * Clear current keyboard assignments
     */
    if (!fFirst) {
        FreeMacs ();
        for (i = 0; i < cMac; i++) {
            FREE ((char *)rgMac[i]->arg);
            FREE (rgMac[i]);
        }
        cMac = 0;
        // assert (_heapchk() == _HEAPOK);
    }
    FmtAssign ("curFileNam:=");
    FmtAssign ("curFile:=");
    FmtAssign ("curFileExt:=");

    /*
     * Load up the default settings for Z. These are stored as a simple
     * table of strings to be handed to DoAssign. Their format is identical
     * to that in the TOOLS.INI file.
     */
    for (i = 0; initTab[i]; i++) {
        DoAssign (strcpy((char *)L_buf, initTab[i]));
    }

    /*
     * if /D was not specified on startup, read tools.ini sections.
     */
    if (!fDefaults) {
        /*
         * Global editor section
         */
        DoInit (NULL, &fFound, 0L);

        /*
         * OS version dependent section
         */
        //sprintf (L_buf, "%d.%d", _osmajor, _osminor);
        //if (_osmajor >= 10 && !_osmode) {
        //    strcat (L_buf, "R");
        //}
        //DoInit (L_buf, &fFound, 0L);

        /*
         * screen mode dependant section
         */
        DoInit (VideoTag(), &fFound, 0L);
    }

    /*
     * if we have a current file, set filename macros, and read filename
     * extension specific TOOLS.INI section
     */
    if (pFileHead) {
        fInitFileMac (pFileHead);
    }

    newscreen ();

    /*
     * initialize variables whose initial values are dependant on tools.ini
     * values. These are generally "last setting" switches used in menu displays
     */
    fSrchCasePrev = fSrchCaseSwit;
    fSrchWrapPrev = fSrchWrapSwit;

    // assert (_heapchk() == _HEAPOK);
    assert (_pfilechk());

    return fFound;
}




/*** zinit - <initialize> editor function
*
* Input:
*  Standard Editor Function
*
* Output:
*  Returns TRUE if successful
*
*************************************************************************/
flagType
zinit (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    flagType    f;
    buffer      ibuf;

    /*
     * clear old version of tools.ini, and clear any cached extension-specific
     * tools.ini stuff
     */
    if (pFileIni != NULL && (pFileIni != (PFILE)-1)) {
        RemoveFile (pFileIni);
        pFileIni = NULL;
        memset ((char *)exttab, '\0', sizeof (exttab));
    }

    ibuf[0] = 0;

    switch (pArg->argType) {

    case NOARG:
        f = (flagType)loadini (FALSE);
        break;

    case TEXTARG:
        strcpy (ibuf, pArg->arg.textarg.pText);
        DoInit (ibuf, &f, 0L);
        break;
    }

    if (!f) {
        disperr (MSGERR_TOOLS, ibuf);
    }
    return f;

    argData;  fMeta;
}




/*** fVideoAdjust - set screen modes
*
*  understand what the screen capabilities are and adjust screen desires to
*  match up with screen capabilities.
*
*  The routine GetVideoState does the following:
*
*       Set up the fnMove/fnStore routine based upon screen capabilities
*       Return a handle encoding the possible and current display modes.
*
*  Once this is complete, the user will request a particular size. The
*  request comes from either tools.ini or from the Z.TMP file. Tools.ini
*  gives the first-approximation of what the screen really should be. Z.TMP
*  gives the final determination.
*
*  Given the type returned by GetVideoState, we will adjust xSize/ySize,
*  Zvideo and the window layout. If the screen can support a particular
*  xSize/ySize, then we set them up and return an indicator that
*  SetVideoState should be called.
*
*  If a particular xSize/ySize cannot be supported, the screen is left
*
*  Multiple windows present presents a problem. The best that we can do is
*  to toss all stored window information. We will return a failure
*  indication so that Z.TMP read-in can be suitably modified.
*
* Input:
*  xSizeNew     = new size for xSize
*  ySizeNew    = new size for ySize
*
* OutPut:
*  Returns TRUE if sizes are allowed
*
*************************************************************************/
flagType
fVideoAdjust (
    int xSizeNew,
    int ySizeNew
    )
{
    //int                 newState;
        SCREEN_INFORMATION      ScrInfo;

    if ( xSizeNew <= hscroll ) {
        return FALSE;
    }
        if ( !SetScreenSize ( ySizeNew+2, xSizeNew ) ) {
        return FALSE;
    }

        consoleGetScreenInformation( MepScreen, &ScrInfo );

    //Zvideo = newState;

        XSIZE = ScrInfo.NumberOfCols;
        YSIZE = ScrInfo.NumberOfRows-2;

    SetScreen ();
    return TRUE;
}



//
//  BUGBUG should be in console header
//
BOOL
consoleIsBusyReadingKeyboard (
    );

BOOL
consoleEnterCancelEvent (
    );


/*** CtrlC - Handler for Control-C signal.
*
*   Invalidate any type ahead and leave flag around.  If the user presses
*       Ctrl-C or Ctrl-Break five times without getting the tfCtrlc flag
*   cleared, assume that the editor is hung and exit.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*  Sets fCtrlc
*
*************************************************************************/
int
CtrlC (
        ULONG   CtrlType
    )
{

    if ( !fSpawned ) {
        CleanExit(4, FALSE );
    }
    return TRUE;

    //if ( (CtrlType == CTRL_BREAK_EVENT) ||
    //     (CtrlType == CTRL_C_EVENT) )  {
    //    if ( !fSpawned ) {
    //        CleanExit(4, FALSE);
    //    }
    //    return TRUE;
    //
    //} else {
    //    return FALSE;
    //}



#if 0
    static int cCtrlC;

    CtrlType;

    FlushInput ();

    if (fCtrlc) {

        /*
        //
        //  BUGBUG The original MEP would coung the number of cTrlC and
        //  ask the user if he/she wanted to exit. How do we do that?
        //

        if (++cCtrlC > 10 ) {
            COL     oldx;
            LINE    oldy;
            int     x;
            char    c = 'x';

            GetTextCursor( &oldx, &oldy );
            bell();
                consoleMoveTo( YSIZE, x = domessage ("**PANIC EXIT** Really exit and lose edits?", NULL));
            while ( c != 'Y' && c != 'N'  ) {
                c = toupper(getch());
            }
            domessage ("                                            ", NULL);
            consoleMoveTo( oldy, oldx );

            if ( c == 'Y' ) {
                CleanExit( 4, FALSE );
            } else {
                fCtrlc = FALSE;
                cCtrlC = 0;
            }
        }
        */
    } else {
                fCtrlc = TRUE;
                cCtrlC = 1;
        if ( consoleIsBusyReadingKeyboard() ) {
             consoleEnterCancelEvent();
        }
    }
    return TRUE;
#endif
}




/*** postspawn - Do state restore/re-init after to a spawn.
*
*  This routine is nominally intended to restore editor state after a spawn
*  operation. However, we also use this during initialization to set it as
*  well.
*
* Input:
*  None
*
* Output:
*  Returns .....
*
*************************************************************************/
void
postspawn (
    flagType fAsk
    )
{
        if (!TESTFLAG(fInit, INIT_VIDEO)) {
                GetScreenSize ( &YSIZE, &XSIZE);
                //
                //      We need at lesast 3 lines:
                //              -       Status Line
                //              -       Message Line
                //              -       Edit line
                //
                if ( YSIZE < 3 ) {
                        YSIZE = 3;
                        SetScreenSize( YSIZE, XSIZE );
                }
                YSIZE -= 2;
        }
        SETFLAG (fInit, INIT_VIDEO);


    if (fAsk) {
                printf ("Please strike any key to continue");
                _getch();
                FlushInput ();
                printf ("\n");
        }

    //if (fSaveScreen) {
    SaveScreen();
    //}

    SetScreen ();

    dispmsg (0);
        newscreen ();

    fSpawned = FALSE;

    SETFLAG (fDisplay, RTEXT | RSTATUS | RCURSOR);
}





/*** VideoTag - return video tag string
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/

char *
VideoTag (
    void
    )
{
        return "vga";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mkmsg\mkmsg.c ===
/*** MkMsg.c - Microsoft Make Messages Utility *******************************
*
*       Copyright (c) 1986-1992, Microsoft Corporation. All Rights Reserved.
*
* Purpose:
*  MkMsg.Exe is a utility that helps localize messages emitted by a utility by
*  padding them and placing them in message segments.
*      MkMsg also allows a programmer to associate symbols and Message Id to a
*  message text. It does this by producing a C style header file with #defines
*  or a Masm style include file with symbol definitions.
*
* Revision History:
*  02-Oct-1996 DS Remove special '\\' handling in RC output.
*  02-Feb-1994 HV Handle lines with only blansk.
*  25-Jan-1994 HV Add -err to generate external error file in the format:
*                 NUMBER\tMESSAGE
*  24-Jan-1994 HV Allow quoted message
*  21-Jan-1994 HV Nuke Lead Byte Table [[ ... ]], add !codepage directive
*  21-Jan-1994 HV Field separated by white spaces
*  19-Aug-1993 BW Add Lead Byte Table support
*  07-Apr-1993 BW Add -hex, -c options
*  13-Jul-1992 SB Add -msg option
*  16-Apr-1990 SB Add header
*  13-Apr-1990 SB Collated 6 different versions seperately SLM'ed on \\ODIN
*  19-Apr-1989 LN add "\xhh" recognition
*  ??-Apr-1986 RN Created by Randy Nevin
*
* Syntax:
*       MKMSG [-h cfile] [-x xcfile] [-inc afile] [-msg cfile] [-c cfile]
*               [-asm srcfile [-def str] [-min|-max]] [-386] [-hex] txtfile
*
* Notes:
*  The Utility takes as input a message file (a .txt file by convention) and
*  produces an assembler source file. The lines in the message file have one
*  of the formats which are instructions to MkMsg as follows -
*
*       1) "<<NMSG>>"  -- use near message segment
*       2) "<<FMSG>>"  -- use far message segment
* ----- Obsolete, see 8)
*       3) "[[XX, YY, ZZ]] - Use hex bytes XX, YY, ZZ as lead byte table.
*                            Lists are cumulative, empty list clears table.
* -----
*       4) "#Anything" -- comment line (ignored by mkmsg)
*       5) ""          -- blank line (ignored by mkmsg)
*       6) "Handle<White space>Number<White space>MessageText" -- associate MessageText with
*               message Id Number and the symbol Handle
*       7) "Number<White space>MessageText" -- associate MessageText with Id
*               Id Number
*   8) "!codepage xxx"  -- use this instead of [[ ... ]]
*
* Options:
*       The options can be specified in any order. When no options are specified
*       then the input is checked for syntactic validity.
*
*
*       -h cfile:          create a C style header file cfile with
*                                       #define Handle IdNumber
*                                       If -c is also defined, a declaration for __NMSG_TEXT
*                                       and a mcros defining GET_MSG as __NMSG_TEXT is added.
*  -msg cfile:          create a C style header file cfile with
*                                       array of struct having fields id and str
*       -c cfile:               create a file like -msg and add a definition
*                                       of a retrieval function
*       -x xcfile:              create a C style header file xcfile with
*                                       #define Handle MessageText
*       -inc afile:             create a MASM style include file afile with
*                                       Handle = IdNumber
*  -asm srcfile:        create a MASM source file srcfile with standard segment
*                                       definitions and messages in near segment (MSG) or far
*                                       segment (FAR_MSG) depending on whether <<NMSG>> or
*                                       <<FMSG>> is specified. The default is <<NMSG>>.
*
*                                       If -min(-max) is specified then the minimum(maximum)
*                                       0-padding is calculated and placed in srcfile. This
*                                       depends on the total length of the individual messages.
*
*                                       If -def is specified the public symbol str gets declared.
*                                       This is useful if the the object file produced from the
*                                       MASM source produced is part of a library. The linker
*                                       will link in that module from the library only if it
*                                       resolves some external references.
*
*                                       If -hex is specified and no Lead Byte Table is
*                                       present, all MessageText is rendered in printf-style
*                                       hexidecimal (e.g. "error" becomes
*                                       x65\x72\x72\x6f\x72").
*
*                                       if -hex is specified and a Lead Byte Table is present
*                                       even if it is empty), then all Double Byte characters
*                                       are rendering in hexidecimal.
*
* Future Directions:
*  1> Break up main() into smaller routines
*  2> Use mkmsg for handling messages
*  2> Allow use of spaces as separators, -- done. HV.
*  3> Allow specification of the separator
*  4> Provide -? and -help options.
*
*****************************************************************************/

// DEFINEs


// Standard INCLUDEs

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <locale.h>
#include <mbctype.h>

// Project INCLUDEs
// MACROs
// External PROTOTYPEs


// TYPEDEFs

typedef enum { FALSE = 0, TRUE = !0 } BOOL;

typedef struct status {
        char *txt;
        char *h;
        char *rc;
        char *x;
        char *inc;
        char *msg;
        char *c;
        char *asm;
        char *def;
        char *err;
        int min;
        int max;
        int use32;
        int hex;
} STATUS;


// Global PROTOTYPEs

void __cdecl Error(char *fmt, ...);
int __cdecl main(int argc, char **argv);
void parseCommandLine(unsigned argc, char **argv, STATUS *opt);
void msg_fputs (unsigned char * pch, int, FILE * fp);
int  ReadLine (FILE * fp);
BOOL ParseLine(char **ppSymbol, char **ppNumber, char **ppMessage);
BOOL HandleDirectives(void);
void SetCodePage (const char *pszCodePage);
BOOL IsLeadByte(unsigned by);

// WARNING:     the following CRT function is undocumented.  This call can only
//                      be used in our internal product (like this one) only.  Please
//                      contact CRT people for more information.
//void __cdecl __setmbctable(unsigned int);

//
//  Lead Byte support
//
unsigned char                           bUseLeadByteTable = FALSE;

typedef struct
{
        unsigned        uCodePage;              // Codepage number
        unsigned        byLead[12];             // Leadbyte ranges
} CPTABLE;

CPTABLE cpTable[] =
{
        {932, {0x81, 0x9f, 0xe0, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
        {0,   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}} // trailing to end
};

CPTABLE * pCP = NULL;

// Local PROTOTYPEs
// External VARIABLEs


// Initialized VARIABLEs

int cError = 0;

char didnear = 0;
char didfar = 0;

char dir32[] = ".386\n";

char ex[] = "expected escape sequence: %s\n";

char f1[] = "FAR_HDR segment byte public \'FAR_MSG\'\nFAR_HDR ends\n";
char f2[] = "FAR_MSG segment byte public \'FAR_MSG\'\nFAR_MSG ends\n";
char f3[] = "FAR_PAD segment byte public \'FAR_MSG\'\nFAR_PAD ends\n";
char f4[] = "FAR_EPAD segment byte common \'FAR_MSG\'\nFAR_EPAD ends\n";
char f5[] = "FMGROUP group FAR_HDR,FAR_MSG,FAR_PAD,FAR_EPAD\n\n";

char n1[] = "HDR segment byte public \'MSG\'\nHDR ends\n";
char n2[] = "MSG segment byte public \'MSG\'\nMSG ends\n";
char n3[] = "PAD segment byte public \'MSG\'\nPAD ends\n";
char n4[] = "EPAD segment byte common \'MSG\'\nEPAD ends\n";
char n5[] = "DGROUP group HDR,MSG,PAD,EPAD\n\n";
char usage[] = "\nMicrosoft (R) Message Creation Utility         Version %s"
        "\nCopyright (c) Microsoft Corp %s. All rights reserved.\n"
        "\nusage: MKMSG [-h cfile] [-rc rcfile] [-x xcfile] [-msg cfile]\n"
        "\t[-c cfile] [-err errfile] [-inc afile]\n"
        "\t[-asm srcfile [-def str] [-min|-max]] [-386] [-hex] txtfile\n";
char szVersionNo[] = "1.00.0011";
char szCopyRightYrs[] = "1986-1996";


// Local VARIABLEs

#define MSGSTYLE_COPY       0
#define MSGSTYLE_C_HEX      1
#define MSGSTYLE_ASM_BYTE   2
#define MSGSTYLE_ASM_TEXT   3

#define FALSE 0
#define TRUE  (!FALSE)

#define INBUFSIZE   1024

//static char buf[INBUFSIZE];   // line buffer
char *buf;                                      // The real buffer is in ReadLine()

//--------------------------------------------------------------------------

int  __cdecl
main(int argc, char **argv)
{
        FILE *f;                        // the input file
        FILE *fh = NULL;            // -h stream
        FILE *frc = NULL;              // -rc stream
        FILE *fx = NULL;            // -x stream
        FILE *fc = NULL;            // -c stream
        FILE *finc = NULL;          // -inc stream
        FILE *fmsg = NULL;          // -msg stream
        FILE *fasm = NULL;          // -asm stream
        FILE *ferr = NULL;              // -err stream
        int asmstate = 0;           // 0=nothing, 1=doing nmsg, 2=doing fmsg
        int instring;           // db "...
        unsigned int nLineCur = 0;      // Current line
        unsigned int cchLine;           // Chars in current line
        char *p;
        int npad = 0;           // cumulative amount of near padding
        int fpad = 0;           // cumulative amount of far padding
        int length;
        double factor;
        double result;

        static STATUS opt;              // Command line options

        parseCommandLine(argc, argv, &opt);

        if ((opt.def || opt.min || opt.max ) && !opt.asm) {
                Error( "-def/-min/-max ignored; no -asm file\n" );
                opt.min = opt.max = 0;
        }

        if (opt.min && opt.max) {
                Error( "-min and -max are mutually exclusive; -min chosen\n" );
                opt.max = 0;
        }

        if (!(f = fopen( opt.txt, "rb" ))) {
                Error( "can't open txtfile %s for binary reading\n", opt.txt );
                return( -1 );
        }

        if (opt.asm && !(fasm = fopen( opt.asm, "w" ))) {
                Error( "can't open -asm file %s for writing\n", opt.asm );
                return( -1 );
        }

        if (opt.h && !(fh = fopen( opt.h, "w" ))) {
                Error( "can't open -h file %s for writing\n", opt.h );
                return( -1 );
        }

        if (fh && opt.c) {
                fprintf (fh, "char * __NMSG_TEXT (unsigned);\n\n");
        }

        if (opt.rc && !(frc = fopen(opt.rc, "w")))
        {
                Error("Can't open -rc file %s for writing\n", opt.rc);
                return -1;
        }

        if (opt.rc) {
                fprintf(frc, "STRINGTABLE\nBEGIN\n");
        }

        if (opt.x && !(fx = fopen( opt.x, "w" ))) {
                Error( "can't open -x file %s for writing\n", opt.x );
                return( -1 );
        }

        if (opt.inc && !(finc = fopen( opt.inc, "w" ))) {
                Error( "can't open -inc file %s for writing\n", opt.inc );
                return( -1 );
        }

        if (opt.msg && !(fmsg = fopen( opt.msg, "w" ))) {
                Error( "can't open -msg file %s for writing\n", opt.msg );
                return( -1 );
        }

        if (opt.err && !(ferr = fopen(opt.err, "w")))
        {
                Error("Can't open -err file %s for writing\n", opt.err);
                return -1;
        }

        if (fmsg) {
                fprintf(fmsg, "typedef struct _message {\n"
                                  "\tunsigned\tid;\n"
                                  "\tchar *str;\n"
                                  "} MESSAGE;\n\n");
                fprintf(fmsg, "MESSAGE __MSGTAB[] = {\n");
        }

        if (opt.c && !(fc = fopen( opt.c, "w" ))) {
                Error( "can't open -c file %s for writing\n", opt.c );
                return( -1 );
        }

        if (fc) {
                fprintf(fc, "#include <stdio.h>\n\n");
                fprintf(fc, "typedef struct _message {\n"
                                "\tunsigned int\tid;\n"
                                "\tchar *str;\n"
                                "} MESSAGE;\n\n");
                fprintf(fc, "MESSAGE __MSGTAB[] = {\n");
        }

        while ((cchLine = ReadLine ( f )) != EOF)       // process lines
        {
                nLineCur++;
                if (buf[0] == '\0' || buf[0] == '#')
                {
                        continue;
                }
                else if (HandleDirectives())                    // Directive
                {
                        continue;
                }
                else if (buf[0] == '[' && buf[1] == '[')        // Old style leadbyte tbl
                {
                        fprintf(stderr,
                                "WARNING: Ignore leadbyte table, use !codepage instead: %s\n",
                                buf);
                        continue;
                }
                else if (buf[0] == '<')                                 // <<NMSG>> or <<FMSG>>
                {
                        if (!strcmp( "<<NMSG>>", buf ))         // near msgs follow
                        {
                                if (asmstate == 0)
                                {
                                        if (fasm)
                                        {
                                                if (!didnear) {
                                                        didnear++;
                                                        if (opt.use32)
                                                                fprintf( fasm, dir32);
                                                        fprintf( fasm, n1 );
                                                        fprintf( fasm, n2 );
                                                        fprintf( fasm, n3 );
                                                        fprintf( fasm, n4 );
                                                        fprintf( fasm, n5 );
                                                }
                                                fprintf( fasm,
                                                        "MSG segment\n" );
                                                if (opt.def)
                                                {
                                                        fprintf( fasm, "\tpublic\t%s\n", opt.def );
                                                        fprintf( fasm, "%s\tequ\t$\n", opt.def );
                                                }
                                                asmstate = 1;
                                        } // if (fasm)
                                } // if (asmstate == 0)
                                else if (asmstate == 1)
                                {
                                        Error( "already in nmsg\n" );
                                }
                                else if (asmstate == 2 && !opt.use32)
                                {
                                        if (fasm)
                                        {
                                                fprintf( fasm, "FAR_MSG ends\n\n" );
                                                if (!didnear)
                                                {
                                                        didnear++;
                                                        fprintf( fasm, n1 );
                                                        fprintf( fasm, n2 );
                                                        fprintf( fasm, n3 );
                                                        fprintf( fasm, n4 );
                                                        fprintf( fasm, n5 );
                                                }
                                                fprintf( fasm, "MSG segment\n" );
                                                asmstate = 1;
                                        } // if (fasm)
                                } // else if (asmstate == 2 ...)
                                else
                                {
                                        Error( "internal error\n" );
                                        return( -1 );
                                }
                        } // if near msg
                        else if (!strcmp( "<<FMSG>>", buf ))//far msgs follow
                        {
                                if (asmstate == 0)
                                {
                                        if (fasm)
                                        {
                                                if (!didfar)
                                                {
                                                        didfar++;
                                                        if (opt.use32)
                                                        {
                                                                fprintf( fasm, dir32);
                                                                fprintf( fasm, n1 );
                                                                fprintf( fasm, n2 );
                                                                fprintf( fasm, n3 );
                                                                fprintf( fasm, n4 );
                                                                fprintf( fasm, n5 );
                                                                fprintf( fasm, "MSG segment\n" );
                                                        }
                                                        else
                                                        {
                                                                fprintf( fasm, f1 );
                                                                fprintf( fasm, f2 );
                                                                fprintf( fasm, f3 );
                                                                fprintf( fasm, f4 );
                                                                fprintf( fasm, f5 );
                                                                fprintf( fasm, "FAR_MSG segment\n" );
                                                        }
                                                } // if (!didfar)
                                                if (opt.def)
                                                {
                                                        fprintf( fasm, "\tpublic\t%s\n", opt.def );
                                                        fprintf( fasm, "%s\tequ\t$\n", opt.def );
                                                }
                                                asmstate = 2;
                                        } // if (fasm)
                                } // if (asmstate == 0)
                                else if (asmstate == 1 && !opt.use32)
                                {
                                        if (fasm)
                                        {
                                                fprintf( fasm, "MSG ends\n\n" );
                                                if (!didfar)
                                                {
                                                        didfar++;
                                                        fprintf( fasm, f1 );
                                                        fprintf( fasm, f2 );
                                                        fprintf( fasm, f3 );
                                                        fprintf( fasm, f4 );
                                                        fprintf( fasm, f5 );
                                                }
                                                fprintf( fasm, "FAR_MSG segment\n" );
                                                asmstate = 2;
                                        }
                                } // else if (asmstate == 1 ...)
                                else if (asmstate == 2)
                                {
                                        Error( "already in far_msg\n" );
                                }
                                else
                                {
                                        Error( "internal error\n" );
                                        return( -1 );
                                }
                        } // far message
                        else    // Not near, not far
                        {
                                Error( "ignoring bad line: %s\n", buf );
                        }
                } // if (.. < ) near/far message
                else if (buf[0] != '\r' && buf[0] != '\n')              // something to do
                {
                        char *pSymbol;
                        char *pNumber;
                        char *pMessage;

                        if (!ParseLine(&pSymbol, &pNumber, &pMessage))
                        {
                                fprintf( stderr, "%s(%d): error in line: \"%s\"\n", opt.txt, nLineCur, buf);
                                continue;
                        }

                        if (pSymbol && opt.h)
                        {
                                fprintf( fh, "#define\t%s\t%s\n", pSymbol, pNumber );
                        }

                        if (opt.rc)
                        {
                                fprintf(frc, "\t%s, \"%s\"\n", pNumber, pMessage);
                        }

                        if (pSymbol && opt.x)
                        {
                                fprintf( fx, "#define\t%s\t\"", pSymbol );
                                msg_fputs( pMessage
                                , opt.hex ? MSGSTYLE_C_HEX : MSGSTYLE_COPY
                                , fx );
                                putc( '\"', fx );
                                putc( '\n', fx );
                        }

                        if (pSymbol && opt.inc)
                        {
                                fprintf( finc, "%s\t=\t%s\n", pSymbol, pNumber);
                        }

                        if (opt.msg)
                        {
                                fprintf( fmsg, "{%s, \"", pNumber );
                                msg_fputs( pMessage, opt.hex ? MSGSTYLE_C_HEX : MSGSTYLE_COPY, fmsg );
                                fprintf( fmsg, "\"}," );
                                if (opt.hex)
                                        fprintf( fmsg, " // \"%s\"", pMessage );
                                putc ( '\n', fmsg );
                        }

                        if (opt.c)
                        {
                                fprintf( fc, "{%s, \"", pNumber );
                                msg_fputs( pMessage, opt.hex ? MSGSTYLE_C_HEX : MSGSTYLE_COPY, fc );
                                fprintf( fc, "\"}," );
                                if (opt.hex)
                                        fprintf( fc, " // \"%s\"", pMessage );
                                putc ( '\n', fc );
                        }

                        if (opt.err)
                        {
                                fprintf(ferr, "%s\t\"%s\"\n", pNumber, pMessage);
                        } // opt.err

                        if (fasm)       // write asmfile
                        {
                                if (asmstate == 0)
                                {
                                        if (!didnear)
                                        {
                                                didnear++;
                                                if (opt.use32)
                                                        fprintf( fasm, dir32);
                                                fprintf( fasm, n1 );
                                                fprintf( fasm, n2 );
                                                fprintf( fasm, n3 );
                                                fprintf( fasm, n4 );
                                                fprintf( fasm, n5 );
                                        }
                                        fprintf( fasm, "MSG segment\n" );
                                        if (opt.def)
                                        {
                                                fprintf( fasm, "\tpublic\t%s\n", opt.def );
                                                fprintf( fasm, "%s\tequ\t$\n", opt.def );
                                        }
                                        asmstate = 1;
                                } // if (asmstate == 0)
                                fprintf( fasm, "\tdw\t%s\n\tdb\t", pNumber );
                                instring = 0;

                                for (p = pMessage, length = 0; *p; p++, length++)
                                {
                                        // allocate message
                                        if (*p == '\\')
                                        {
                                                // C escape sequence
                                                switch (*++p)
                                                {
                                                        case 'r':
                                                        case 'n':
                                                        case 't':
                                                        case 'f':
                                                        case 'v':
                                                        case 'b':
                                                        case '\'':
                                                        case '"':
                                                        case '\\':
                                                        case 'x':
                                                                if (instring) {
                                                                        putc( '"', fasm );
                                                                        putc( ',', fasm );
                                                                        instring = 0;
                                                                }
                                                                if (*p == 'x') {
                                                                        p++;
                                                                        if (*p && *(p+1))
                                                                                fprintf ( fasm, "0%c%ch", *p, *(p+1));
                                                                        else
                                                                                puts ("Error in Hex Constant");
                                                                        p++;
                                                                }
                                                                else if (*p == 'r')
                                                                        fprintf( fasm, "13" );
                                                                else if (*p == 'n')
                                                                        fprintf( fasm, "10" );
                                                                else if (*p == 't')
                                                                        fprintf( fasm, "9" );
                                                                else if (*p == 'f')
                                                                        fprintf( fasm, "12" );
                                                                else if (*p == 'v')
                                                                        fprintf( fasm, "11" );
                                                                else if (*p == 'b')
                                                                        fprintf( fasm, "8" );
                                                                else if (*p == '\'')
                                                                        fprintf( fasm, "39" );
                                                                else if (*p == '"')
                                                                        fprintf( fasm, "34" );
                                                                else if (*p == '\\')
                                                                        fprintf( fasm, "92" );

                                                                putc( ',', fasm );
                                                                break;

                                                        case '\0':
                                                                //not an error, warning ...
                                                                fprintf(stderr, ex, buf);
                                                                p--;
                                                                break;

                                                        default:
                                                                if (!instring) {
                                                                        putc( '"', fasm );
                                                                        instring = 1;
                                                                }

                                                                putc( *p, fasm );
                                                                break;
                                                } // switch
                                        } //if (*p == '\\')
                                        else if (instring)      // keep building string
                                        {
                                                putc( *p, fasm );
                                                if (IsLeadByte(*p))
                                                        putc( *++p, fasm );
                                        }
                                        else   // start building string
                                        {
                                                putc( '"', fasm );
                                                instring = 1;
                                                putc( *p, fasm );
                                                if (IsLeadByte(*p))
                                                        putc( *++p, fasm );
                                        }
                                } // for
                                if (instring)   // close string
                                {
                                        putc( '"', fasm );
                                        putc( ',', fasm );
                                }

                                putc( '0', fasm );
                                putc( '\n', fasm );

                                // calculate padding
                                // depends on msg length
                                if (opt.min || opt.max)
                                {
                                        if (opt.min)
                                                if (length <= 10)
                                                        factor = 1.01;
                                                else if (length <= 20)
                                                        factor = 0.81;
                                                else if (length <= 30)
                                                        factor = 0.61;
                                                else if (length <= 50)
                                                        factor = 0.41;
                                                else if (length <= 70)
                                                        factor = 0.31;
                                                else
                                                        factor = 0.30;
                                        else if (length <= 10)
                                                factor = 2.00;
                                        else if (length <= 20)
                                                factor = 1.00;
                                        else if (length <= 30)
                                                factor = 0.80;
                                        else if (length <= 50)
                                                factor = 0.60;
                                        else if (length <= 70)
                                                factor = 0.40;
                                        else
                                                factor = 0.30;

                                        result = (double)length * factor;

                                        if (asmstate == 1 || opt.use32)
                                        {
                                                npad += (int)result;
                                                if (result > (float)((int)result))
                                                        npad++;
                                        }
                                        else if (asmstate == 2)
                                        {
                                                fpad += (int)result;
                                                if (result > (float)((int)result))
                                                        fpad++;
                                        }
                                } // if (opt.min || opt.max)
                        } // if (fasm)...
                } // Something to do
        } // while read line

        if (fmsg) { // finish up -msg stuff
                fprintf(fmsg, "{0, NULL}\n};\n");
        }

        if (fc) // finish up -c stuff
        {
                fprintf(fc, "{0, NULL}\n};\n\n");

                fprintf(fc, "char * __NMSG_TEXT(\n" );
                fprintf(fc, "unsigned msgId\n" );
                fprintf(fc, ") {\n" );
                fprintf(fc, "        MESSAGE *pMsg = __MSGTAB;\n" );
                fprintf(fc, "\n" );
                fprintf(fc, "        for (;pMsg->id; pMsg++) {\n" );
                fprintf(fc, "                if (pMsg->id == msgId)\n" );
                fprintf(fc, "                        break;\n" );
                fprintf(fc, "        }\n" );
                fprintf(fc, "        return pMsg->str;\n" );
                fprintf(fc, "}\n" );
        } // if (fc)

        if (fasm)  // finish up asm file
        {
                if (asmstate == 1 || opt.use32)
                        fprintf( fasm, "MSG ends\n\n");
                else if (asmstate == 2)
                        fprintf( fasm, "FAR_MSG ends\n\n");

                if (npad) {  // add near padding
                        fprintf( fasm, "PAD segment\n\tdb\t%d dup(0)\n", npad );
                        fprintf( fasm, "PAD ends\n\n" );
                }

                if (fpad) {  // add far padding
                        fprintf( fasm, "FAR_PAD segment\n\tdb\t%d dup(0)\n", fpad );
                        fprintf( fasm, "FAR_PAD ends\n\n" );
                }

                fprintf( fasm, "\tend\n" );
                fclose( fasm );
        } // if (fasm)

        if (fh)
        {
                if (opt.c)
                        fprintf (fh, "\n#define GET_MSG(x) __NMSG_TEXT(x)\n");
                fclose( fh );
        }

        if (frc) {
                fprintf(frc, "END\n");
                fclose( frc );
        }

        if (fx)         fclose( fx );
        if (finc)       fclose( finc );
        if (fmsg)       fclose( fmsg );
        if (fc)         fclose( fc );
        if (ferr)       fclose( ferr );
        fclose( f );

        return(cError ? 1 : 0);
} // main()


void
parseCommandLine(
unsigned argc,
char **argv,
STATUS *opt
)
{
        // skip argv[0]
        argc--; argv++;

        while (argc && **argv == '-')  // process options
        {
                if  (!strcmp("-err", *argv))            // Create .err file
                {
                        argc--; argv++;
                        if (!argc)
                                Error("no -err file given\n");
                        else if (opt->err)
                                Error("extra -err for %s ignored\n", *argv);
                        else
                        {
                                opt->err = *argv;
                                argc--; argv++;
                        }
                } // -err
                else if (!strcmp( "-h", *argv )) {  // create .h file
                        argc--; argv++;
                        if (!argc)
                        Error( "no -h file given\n" );
                        else if (opt->h) {
                        Error( "extra -h file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -h file
                        opt->h = *argv;
                        argc--; argv++;
                        }
                }
                else if  (!strcmp("-rc", *argv)) { // Create .rc file
                        argc--; argv++;
                        if (!argc)
                            Error("no -rc file given\n");
                        else if (opt->rc)
                            Error("extra -rc for %s ignored\n", *argv);
                        else
                        {
                            opt->rc = *argv;
                            argc--; argv++;
                        }
                }
                else if (!strcmp( "-x", *argv )) {  // create .h file
                        argc--; argv++;
                        if (!argc)
                        Error( "no -x file given\n" );
                        else if (opt->x) {
                        Error( "extra -x file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -x file
                        opt->x = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-inc", *argv )) {  // create .inc file
                        argc--; argv++;
                        if (!argc)
                        Error( "no -inc file given\n" );
                        else if (opt->inc) {
                        Error( "extra -inc file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -inc file
                        opt->inc = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-msg", *argv )) {    // create .h file with struct
                        argc--; argv++;
                        if (!argc)
                        Error( "no -msg file given\n" );
                        else if (opt->msg) {
                        Error( "extra -msg file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -msg file
                        opt->msg = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-c", *argv )) {    // create .c file with struct and function
                        argc--; argv++;
                        if (!argc)
                        Error( "no -c file given\n" );
                        else if (opt->c) {
                        Error( "extra -c file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -c file
                        opt->c = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-asm", *argv )) {  // create .asm file
                        argc--; argv++;
                        if (!argc)
                        Error( "no -asm file given\n" );
                        else if (opt->asm) {
                        Error( "extra -asm file %s ignored\n", *argv );
                        argc--;
                        argv++;
                        }
                        else    {  // remember -asm file
                        opt->asm = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-def", *argv )) {
                        argc--; argv++;
                        if (!argc)
                        Error( "no -def string given\n" );
                        else {
                        opt->def = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-min", *argv )) {  // minimum padding
                        argc--; argv++;
                        if (opt->min)
                        Error( "redundant -min\n" );
                        opt->min = 1;
                }
                else if (!strcmp( "-max", *argv )) {  // maximum padding
                        argc--; argv++;
                        if (opt->max)
                        Error( "redundant -max\n" );
                        opt->max = 1;
                }
                else if (!strcmp( "-386", *argv))  {  // 32-bit segments
                        argc--; argv++;
                        if (opt->use32)
                        Error( "redundant -386\n" );
                        opt->use32 = 1;
                }
                else if (!strcmp( "-hex", *argv))  {  // hex rendering of text
                        argc--; argv++;
                        if (opt->hex)
                        Error( "redundant -hex\n" );
                        opt->hex = 1;
                }
                else {
                        Error( "unknown option %s ignored\n", *argv );
                        argc--;
                        argv++;
                }
        } // while
        if (!argc) {  // no arguments
                Error( usage, szVersionNo, szCopyRightYrs );
                exit( -1 );
        }

        if (argc != 1)  // extra arguments
                Error( "ignoring extra arguments\n" );

        opt->txt = *argv;
} // ParseCommandLine()


//
// Read One line into global buf
//
int
ReadLine (FILE * fp)
{
        int i = 0;
        int ch;
        static char szBuffer[INBUFSIZE];

        while ((ch = getc( fp )) != EOF && ch != '\r' && ch != '\n' && ch != '\x1A')
        if (i < INBUFSIZE-1)
                szBuffer[i++] = (char)ch;

        if (ch == EOF && i == 0)
        return EOF;

        if (ch == '\r')
        getc ( fp );    // Flush line feed

        szBuffer[i] = '\0';

        // Skip initial space
        for (buf = szBuffer; *buf && isspace(*buf); buf++)
                i--;

        return i;
}

void
__cdecl
Error(
char *fmt,
...
) {
        va_list args;

        va_start (args, fmt);

        vfprintf(stderr, fmt, args);
        ++cError;
}


///// msg_fputs
//
//  Purpose:
//
//      Send string to file in the given format.
//
//////////////////////////////////////////////////////////////////////////

void msg_fputs(
unsigned char * pch,
int  style,
FILE * fp
) {
char          chbuf[8];
unsigned char bInDBCS = FALSE;
static    int bPrevWasHex = FALSE;

        switch (style)
        {
        case MSGSTYLE_COPY:
                fputs (pch, fp);
                break;

        case MSGSTYLE_C_HEX:
                for (;*pch; pch++) {
                // If a lead byte table was specified, we use hex
                // only for double-byte characters, and for hex
                // digits after hex output.  This later is because
                // hex constants terminate only when a non-hex digit
                // (like a \) is encountered.
                //
                if (!bUseLeadByteTable
                        || bInDBCS || IsLeadByte(*pch)
                        || (bPrevWasHex && isxdigit(*pch))) {

                        sprintf (chbuf, "\\x%2.2x", *pch);
                        fputs (chbuf, fp);
                        bInDBCS = bInDBCS ? FALSE : IsLeadByte(*pch);
                        bPrevWasHex = TRUE;
                        }
                else {
                        fputc(*pch, fp);
                        bPrevWasHex = FALSE;
                        }
                }
                break;

        case MSGSTYLE_ASM_TEXT: // UNDONE
        case MSGSTYLE_ASM_BYTE: // UNDONE
                break;
        }
}


///// SetCodePage
//
//  Purpose:
//
//              Switch to the specified codepage so that we can recognize a lead
//              byte using IsLeadByte().
//
//      Parameters:
//              const char *pszCodePage:        Points to a buffer containing the codepage
//                                                      in the the format of ".xxx" where xxx is
//                                                      the codepage number.
//
//      Note:
//              This function replaces the old SetLeadByteTable(), which fills
//              the global lead byte table with values the user supplied in the
//              message file.
//
///////////////////////////////////////////////////////////////////////////

void
SetCodePage(const char *pszCodePage)
{
        unsigned i;
        unsigned uCodePage;

        if (!setlocale(LC_ALL, pszCodePage))                    // Switch to new locale
        {
                //__setmbctable(atoi(pszCodePage+1));           // Failed, use undoc'ed call
                // Failed, use internal codepage table
                uCodePage = atoi(pszCodePage+1);
                for (i = 0; cpTable[i].uCodePage; i++)
                {
                        if (cpTable[i].uCodePage == uCodePage)  // Found
                        {
                                pCP = &cpTable[i];
                                break;
                        }
                } // for
                if (0 == cpTable[i].uCodePage)
                        fprintf(stderr, "WARNING: unknown codepage: %s\n", pszCodePage+1);
        }
        bUseLeadByteTable = TRUE;
}

#ifdef VERBOSE
#define DB(x) x
#else
#define DB(x)
#endif
BOOL
IsLeadByte(unsigned by)
{
        unsigned byIndex;

        DB(printf("IsLeadByte(0x%02x) ==> ",by));

        if (!bUseLeadByteTable)
        {
                DB(printf("FALSE\n"));
                return FALSE;
        }

        if (!pCP)
#ifdef NT_BUILD
                puts("Codepage support not implemented");
#else
                return _ismbblead(by);
#endif

        for (byIndex = 0; pCP->byLead[byIndex]; byIndex += 2)
        {
                if (pCP->byLead[byIndex] <= by && by <= pCP->byLead[byIndex+1])
                {
                        DB(printf("TRUE\n"));
                        return TRUE;
                }
        }

        DB(printf("FALSE\n"));
        return FALSE;
}

///// ParseLine
//
//  Purpose:
//
//              Break the input line to 3 fields: symbol, number, and message.
//              The symbol field is optional: if the first non-blank char in
//              the line is a digit, then the symbol field is set to NULL.
//
//      Assumption:
//              We assume that the input line has the following formats:
//              [<White space> SYMBOL] <White space> NUMBER <White space> MESSAGE
//              where as the text between the square brackets ([]) is optional.
//
//      Parameters:
//              char **ppSymbol:        Points to the buffer containing the symbol.
//                                                      *ppSymbol == NULL if there is no symbol.
//              char **ppNumber:        Points to the buffer containing the number.
//              char **ppMessage:       Points to the buffer containing the message.
//
//      Use Global:
//              buf             Contains the line to examine.
//
//      Return Value:
//              TRUE:   The line is a valid line.
//              FALSE:  The line is not a valid line.
//
///////////////////////////////////////////////////////////////////////////

BOOL
ParseLine(char **ppSymbol, char **ppNumber, char **ppMessage)
{
        unsigned char *pBuf = buf;

        #define SKIP_BLANKS()   for ( ; *pBuf && isspace(*pBuf); pBuf++)
        #define SKIP_TO_BLANKS()        for ( ; *pBuf && !isspace(*pBuf); pBuf++)
        #define CHECK_NULL()    if (!*pBuf) return FALSE;

        SKIP_BLANKS();                  // Skip initial blanks
        CHECK_NULL();                   // Blank line?

        if (!isdigit(*pBuf))    // Symbol?
        {
                *ppSymbol = pBuf;
                SKIP_TO_BLANKS();
                CHECK_NULL();
                *pBuf++ = '\0';
                SKIP_BLANKS();
                CHECK_NULL();
        }
        else
                *ppSymbol = NULL;

        *ppNumber = pBuf;
        SKIP_TO_BLANKS();
        CHECK_NULL();
        *pBuf++ = '\0';

        SKIP_BLANKS();
        CHECK_NULL();
        *ppMessage = pBuf;

        // Handle quoted message:  if the message does not begin with quote, it is
        // extended to end of line.  If it begins with a double quote character,
        // then it is extended to the closing quote, or end of line, whichever
        // comes first.  While scanning for closing quote, we ignore the '\"',
        // which is the literal quote character.

        if ('\"' == *pBuf)                                      // quoted message
        {
                *ppMessage = ++pBuf;
                while (*pBuf && '\"' != *pBuf)
                {
                        if ('\\' == *pBuf || IsLeadByte(*pBuf))
                                pBuf++;
                        if (*pBuf)
                                pBuf++;
                } // while
                *pBuf = '\0';
        } // if ... quoted message

        return TRUE;
}

///// HandleDirectives
//
//  Purpose:
//
//              Determine if a line contains a directive, then carry out the
//              directive's command.
//
//      Use Global:
//              buf             Contains the line to examine.
//
//      Return Value:
//              TRUE:   The line is a directive.
//              FALSE:  The line is not a directive
//
///////////////////////////////////////////////////////////////////////////

BOOL
HandleDirectives(void)
{
        register unsigned char *pBuf = buf;
        unsigned char *pEnd;

        for ( ; *pBuf && isspace(*pBuf); pBuf++)        // Skip leading spaces
                ;

        if (!_strnicmp("!codepage", pBuf, 9))           // Change the codepage
        {
                for (pBuf += 9; *pBuf && isspace(*pBuf); pBuf++)        // Skip spaces
                        ;
                *--pBuf = '.';
                for (pEnd = pBuf + 1; *pEnd && isdigit(*pEnd); pEnd++)
                        ;
                *pEnd = '\0';
                SetCodePage(pBuf);
                return TRUE;
        }
        else if ('!' == *pBuf)
        {
                Error("Unrecognized directive: '%s'\n", pBuf);
                return TRUE;
        }

        return FALSE;
} // HandleDirectives
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\zprint.c ===
/*** zprint.c - print functions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#define INCL_DOSPROCESS
#include "mep.h"
#include "keyboard.h"
#include "keys.h"


/*** SetPrintCmd - sets the print command string ************************
*
*   Stores the given <printcmd> switch string to be used by the <print>
*   command and makes pPrintCmd global variable point to it.
*
*   Input:
*	pCmd = pointer to the new command string
*	       NULL means clear it up
*   Output:
*	Returns always TRUE
*
*   Note:
*	pPrintCmd is assigned NULL when no <printcmd> defined
*
*************************************************************************/

flagType
SetPrintCmd (
    char *pCmd
    )
{
    if (pPrintCmd != NULL)
	FREE (pPrintCmd);

    if (strlen (pCmd) != 0)
	pPrintCmd = ZMakeStr (pCmd);
    else
	pPrintCmd = NULL;

    return TRUE;
}






/*** zPrint - <print> editor function
*
*   Prints file(s) or designated area
*
*   Input:
*	NOARG	    Print current file
*	TEXTARG     List of files to print
*	STREAMARG   Print designated area
*	BOXARG	    Print designated area
*	LINEARG     Print designated area
*
*   Output:
*	Returns TRUE if the printing has been successful, FALSE otherwise
*
*************************************************************************/
flagType
zPrint (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    flagType	fOK;		    /* Holds the return value		*/
    PFILE       pFile;              /* general file pointer             */

    /*
     * The following is used only when we scan a list of files (TEXTARG)
     */
    flagType	fNewFile;	    /* Did we open a new file ? 	*/
    buffer	pNameList;	    /* Holds the list of file names	*/
    char	*pName, *pEndName;  /* Begining and end of file names	*/
    flagType	fDone = FALSE;	    /* Did we finish with the list ?	*/

    /*
     *	If we can flush the files, that's the moment
     */
    AutoSave ();

    switch (pArg->argType) {

	case NOARG:
	    return (DoPrint (pFileHead, FALSE));

	case TEXTARG:
	    /*
	     * Get the list in a buffer
	     */
	    strcpy ((char *) pNameList, pArg->arg.textarg.pText);

	    /*
	     * Empty list = no work
	     */
            if (!*(pName = whiteskip (pNameList))) {
                return FALSE;
            }

	    /*
	     * For each name:
	     *	     - pName points at the begining
	     *	     - Make pEndName pointing just past its ends
	     *	     - If it's already the end of the string
	     *		then we're done with the list
	     *		else put a zero terminator there
	     *	     - Do the job with the name we've found :
	     *		. Get the file handle (if it doen't exist yet,
	     *		  create one and switch fNewFile on
	     *		. Call DoPrint
	     *	     - Let pName point to the next name
	     */
	    fOK = TRUE;

	    do {
		pEndName = whitescan (pName);
                if (*pEndName) {
		    *pEndName = 0;
                } else {
                    fDone = TRUE;
                }

		if ((pFile = FileNameToHandle (pName, pName)) == NULL) {
		    pFile = AddFile (pName);
		    FileRead (pName, pFile, FALSE);
		    fNewFile = TRUE;
                } else  {
                    fNewFile = FALSE;
                }

		fOK &= DoPrint (pFile, FALSE);

                if (fNewFile) {
                    RemoveFile (pFile);
                }

		pName = whiteskip (++pEndName);

            } while (!fDone && *pName);

	    /*
	     * Just in case we would change the behaviour to stopping all
	     * things at the first error :
	     *
	     *	} while (fOK && !fDone && *pName);
	     */
            return (fOK);

	case STREAMARG:
	case BOXARG:
	case LINEARG:
	    /*
	     *	If we print an area, we'll put the text in a temporary file,
	     *	call DoPrint with this file and then destroy it.
	     */
	    pFile = GetTmpFile ();

	    switch (pArg->argType) {
		case STREAMARG:
		    CopyStream (pFileHead, pFile,
				pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
				pArg->arg.streamarg.xEnd, pArg->arg.streamarg.yEnd,
				0L,0L);
                    break;

		case BOXARG:
		    CopyBox (pFileHead, pFile,
			     pArg->arg.boxarg.xLeft, pArg->arg.boxarg.yTop,
			     pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom,
			     0L,0L);
                    break;

		case LINEARG:
		    CopyLine (pFileHead, pFile,
			      pArg->arg.linearg.yStart, pArg->arg.linearg.yEnd,
			      0L);
		    break;
            }

	    /*
	     * If we have to spawn a print command, then we need to make a real
	     * disk file
	     */
            if (pPrintCmd && (!FileWrite (pFile->pName, pFile))) {
		fOK = FALSE;
            } else {
                fOK = DoPrint (pFile, TRUE);
            }
	    RemoveFile (pFile);
	    return (fOK);
    }

    return FALSE;
    argData; fMeta;
}





/*** DoPrint - Does the printing
*
*   If a <printcmd> has been defined
*	queue up the job for the <print> thread (synchronous exec under DOS)
*   else
*	send the file to the printer, each line at a time
*
*   Input:
*	pFile = File to be printed.
*
*   Output:
*	Returns True if the printing has been succesful, False otherwise
*
*************************************************************************/
flagType
DoPrint (
    PFILE    pFile,
    flagType fDelete
    )
{
    assert (pFile);

    if (pPrintCmd) {
	buffer	 pCmdBuf;		// Buffer for command construction

	if (TESTFLAG (FLAGS (pFile), DIRTY) && confirm ("File %s is dirty, do you want to save it ?", pFile->pName))
            FileWrite (pFile->pName, pFile);

	sprintf (pCmdBuf, pPrintCmd, pFile->pName);


	if (pBTDPrint->cBTQ > MAXBTQ-2)
	    disperr (MSGERR_PRTFULL);
	else
	if (BTAdd (pBTDPrint, (PFUNCTION)NULL, pCmdBuf) &&
	    (!fDelete || BTAdd (pBTDPrint, (PFUNCTION)CleanPrint, pFile->pName)))
            return TRUE;
	else
            disperr (MSGERR_PRTCANT);

	if (fDelete)
            _unlink (pFile->pName);

	return FALSE;
    }
    else {
        static char   szPrn[] = "PRN";
	flagType      fOK = TRUE;	//  Holds the return value
	LINE	      lCur;		//  Number of line we're printing
	char	      pLineBuf[sizeof(linebuf)+1];
					//  Holds the line we're printing
	unsigned int  cLen;		//  Length of line we're printing
	EDITOR_KEY    Key;		//  User input (for abortion)
	int	      hPrn;		//  PRN file handle

	dispmsg (MSG_PRINTING,pFile->pName);

	if ((hPrn = _open (szPrn, O_WRONLY)) == -1) {
	    disperr (MSGERR_OPEN, szPrn, error());
	    fOK = FALSE;
	}
	else {
	    for (lCur = 0; lCur < pFile->cLines; lCur++) {
		if (TypeAhead () &&
		    (Key = TranslateKey(ReadChar()), (Key.KeyCode == 0x130)) &&
		    (!Key.KeyInfo.KeyData.Flags)) {

		    fOK = FALSE;
		    break;
                }
		cLen = GetLine (lCur, pLineBuf, pFile);
//		* (int UNALIGNED *) (pLineBuf + cLen++) = '\n';
		* (pLineBuf + cLen++) = '\n';
		if (_write (hPrn, pLineBuf, cLen) == -1) {
		    disperr (MSGERR_PRTCANT);
		    fOK = FALSE;
		    break;
                }
            }
	    _close (hPrn);
        }
	domessage (NULL);

        if (fDelete) {
            _unlink (pFile->pName);
        }
	return fOK;
    }
}





/*** GetTmpFile - Allocates temporary files
*
* Input:
*   nothing
*
* Output:
*   pointer to the allocated file
*
* Remark:
*   We do not use mktemp as it is creating files in the current directory.
*
* Notes:
*   - Each new call changes the content of the work buffer, so
*     the caller needs to save the string before doing a new call.
*   - There is a limit of 26 names to be generated
*
*************************************************************************/
PFILE
GetTmpFile (
    void
    )
{
    static pathbuf pPath = "";
    static char   *pVarLoc;

    if (!*pPath) {
	pathbuf pName;

	sprintf (pName, "$TMP:ME%06p.PRN", _getpid);
	findpath (pName, pPath, TRUE);
	pVarLoc  = strend (pPath) - 10;
	*pVarLoc = 'Z';
    }

    if (*pVarLoc == 'Z') {
	*pVarLoc = 'A';
    } else {
        ++*pVarLoc;
    }

    return (AddFile (pPath));

}





/*** Clean - cleans the printer intermediate file
*
* Input:
*   pName = Name of the file to get rid of
*
* Output:
*   None
*
* Remarks: - Under OS/2, since we're called by the background thread, we
*	     need to switch stack checking off
*	   - The background thread calls this routime at idle time
*
*************************************************************************/

// #pragma check_stack (off)

void
CleanPrint (
    char     *pName,
    flagType fKilled
    )
{
    _unlink (pName);
    fKilled;
}

// #pragma check_stack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\zutil.c ===
/*** zutil.c - misc utility functions not big enough to warrent their own file
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"


void *
ZeroMalloc (
    int Size
    )
{
    return calloc(Size, 1);
}




void *
ZeroRealloc (
    void   *pmem,
    int     Size
    )
{
    int     cbOrg  = 0;                   /* original size of block       */
    void    *p;				 /* pointer to returned block	 */

    if (pmem) {
        cbOrg = _msize (pmem);
    }

    p = realloc(pmem, Size);

    /*
     * if reallocated, and now larger, zero fill the new addition to the block.
     * if a new allocation, zero fill the whole thing.
     */
    if (cbOrg < Size) {
	memset ((char *)p+cbOrg, 0, Size-cbOrg);
    }
    return p;
}





unsigned
MemSize (
    void * p
    )
{
    return _msize (p);
}





/*** ZMakeStr - Make local heap copy of string
*
*  Allocate local memory for the passed string, and copy it into that memory.
*
* Input:
*  p		= Pointer to string
*
* Output:
*  Returns pointer to newly allocated memory
*
* Exceptions:
*  LMAlloc
*
*************************************************************************/
char *
ZMakeStr (
    char const *p
    )
{
    return strcpy (ZEROMALLOC (strlen (p)+1), p);
}





/*** ZReplStr - Modify local heap copy of string
*
*  Reallocate local memory for the passed string, and copy it into that memory.
*
* Input:
*  pDest	= pointer to heap entry (NULL means get one)
*  p		= Pointer to string
*
* Output:
*  Returns pointer to newly allocated memory
*
* Exceptions:
*  LMAlloc
*
*************************************************************************/
char *
ZReplStr (
    char    *pDest,
    char const *p
    )
{
    return pDest ? strcpy (ZEROREALLOC (pDest, strlen (p)+1), p) : ZMakeStr(p);
}





/*** DoCancel - clear input & force display update
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
flagType
DoCancel ()
{
    FlushInput ();
    SETFLAG (fDisplay, RTEXT | RSTATUS);
    return TRUE;
}





/*** cancel - <cancel> editting function
*
*
*
* Input:
*  Standard editing function
*
* Output:
*  Returns TRUE
*
*************************************************************************/
flagType
cancel (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    if (pArg->argType == NOARG) {
        fMeta = fMessUp;
	domessage (NULL);
        if (!fMeta) {
            DeclareEvent (EVT_CANCEL, NULL);
        }
    } else {
	domessage ("Argument cancelled");
	resetarg ();
    }
    return DoCancel ();

    argData;
}




/*** testmeta- return meta status & clear
*
*  Returns current status of meta indicator, and clears it.
*
* Input:
*  none
*
* Output:
*  Returns previous setting of meta
*
*************************************************************************/
flagType
testmeta (
    void
    )
{
    flagType f;

    f = fMeta;
    fMeta = FALSE;
    if (f) {
        SETFLAG( fDisplay, RSTATUS );
    }
    return f;
}





/*** meta - <meta> editor function
*
*  Toggle state of the meta flag, and cause screen status line to be updated.
*
* Input:
*  Standard editor function.
*
* Output:
*  Returns new META state
*
*************************************************************************/
flagType
meta (
    CMDDATA argData,
    ARG *pArg,
    flagType MetaFlag
    )
{
    SETFLAG( fDisplay, RSTATUS );
    return fMeta = (flagType)!fMeta;

    argData; pArg; MetaFlag;
}





/*** insertmode - <insertmode> editor function
*
*  Toggle setting of fInsert flag & cause status line to be updated.
*
* Input:
*  Standard editting function
*
* Output:
*  Returns new fInsert value.
*
*************************************************************************/
flagType
insertmode (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    SETFLAG( fDisplay, RSTATUS );
    return fInsert = (flagType)!fInsert;

    argData; pArg; fMeta;
}





/*** zmessage - <message> editor function
*
*   Macro allowing the user to display a message on the dialog line
*
*   Input:
*	User message (textarg) or no arg to clear the dialog line
*
*   Output:
*	Returns always TRUE
*
*
*************************************************************************/
flagType
zmessage (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    linebuf lbMsg;
    char    *pch = lbMsg;

    switch (pArg->argType) {

	case NOARG:
	    pch = NULL;
	    break;

	case TEXTARG:
	    strcpy ((char *) lbMsg, pArg->arg.textarg.pText);
	    break;

	case NULLARG:
	    GetLine (pArg->arg.nullarg.y, lbMsg, pFileHead);
	    goto MsgAdjust;

	case LINEARG:
	    GetLine (pArg->arg.linearg.yStart, lbMsg, pFileHead);
	    goto MsgAdjust;

	case STREAMARG:
	    fInsSpace (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart, 0, pFileHead, lbMsg);
            if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
                *pLog (lbMsg, pArg->arg.streamarg.xEnd+1, TRUE) = 0;
            }
	    pch = pLog (lbMsg, pArg->arg.streamarg.xStart, TRUE);
	    goto MsgAdjust;

	case BOXARG:
	    fInsSpace (pArg->arg.boxarg.xRight, pArg->arg.boxarg.yTop, 0, pFileHead, lbMsg);
	    *pLog (lbMsg, pArg->arg.boxarg.xRight+1, TRUE) = 0;
	    pch = pLog (lbMsg, pArg->arg.boxarg.xLeft, TRUE);
MsgAdjust:
	    if (pch > lbMsg) {
		strcpy (lbMsg, pch);
		pch = lbMsg;
            }
	    *pLog (lbMsg, XSIZE, TRUE) = 0;
	    break;
    }

    domessage (pch);
    return TRUE;

    argData; fMeta;
}





/*** GetCurPath gets the current drive and directory
*
*   Input:
*     szBuf: buffer to receive the current path
*
*   Output:
*     Nothing
*
*************************************************************************/
void
GetCurPath (
    char *szBuf
    )
{

    if (!GetCurrentDirectory(MAX_PATH, szBuf)) {
        *szBuf = '\00';
    }
    _strlwr (szBuf);
}





/*** SetCurPath - sets the current drive and directory
*
*   Input:
*     szPath: New path
*
*   Output:
*     TRUE if successful, FALSE otherwise.
*
*************************************************************************/
flagType
SetCurPath (
    char *szPath
    )
{

    if (_chdir (szPath) == -1) {
	return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\src\zspawn.c ===
/*** zspawn.c - shell command and support
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Contains the shell command, and associated support code.
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"




/*** zspawn - <shell> editor function
*
*   <shell>		runs command
*   <meta><shell>	runs command with no save of current file
*   <arg><shell>	uses text from line on screen as program to execute
*   <arg>text<shell>	does command /C text
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE on successfull spawn.
*
*************************************************************************/
flagType
zspawn (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer   sbuf;
    flagType f = FALSE;
    LINE     i;

    DeclareEvent (EVT_SHELL, NULL);
    if (!fMeta) {
        AutoSave ();
    }

    soutb (0, YSIZE+1, "***** PUSHED *****", fgColor);
    domessage (NULL);
    consoleMoveTo( YSIZE, 0 );

    switch (pArg->argType) {
    case NOARG:
	f = zspawnp (rgchEmpty, TRUE);
        break;

    case TEXTARG:
	strcpy ((char *) sbuf, pArg->arg.textarg.pText);
	f = zspawnp (sbuf, TRUE);
        break;

    /*  NULLARG converted to TEXTARG*/

    case LINEARG:
	for (i = pArg->arg.linearg.yStart; i <= pArg->arg.linearg.yEnd; i++) {
	    GetLine (i, sbuf, pFileHead);
            if (!(f = zspawnp (sbuf, (flagType)(i == pArg->arg.linearg.yEnd)))) {
		docursor (0, i);
		break;
            }
        }
        break;

    /*  STREAMARG illegal           */

    case BOXARG:
	for (i = pArg->arg.boxarg.yTop; i <= pArg->arg.boxarg.yBottom; i++) {
	    fInsSpace (pArg->arg.boxarg.xRight, i, 0, pFileHead, sbuf);
	    sbuf[pArg->arg.boxarg.xRight+1] = 0;
	    if (!(f = zspawnp (&sbuf[pArg->arg.boxarg.xLeft],
                               (flagType)(i == pArg->arg.boxarg.yBottom)))) {
		docursor (pArg->arg.boxarg.xLeft, i);
		break;
            }
        }
	break;
    }

    fSyncFile (pFileHead, TRUE);
    return f;

    argData;
}




/*** zspawnp - shell out a program
*
*  Execute the specified program, syncronously. Under DOS, if PWB and
*  minimize memory usage is on, we use the shell to execute the command,
*  else we just use system().
*
* Input:
*  p		= pointer to command string
*  fAsk 	= TRUE => ask to hit any key before returning
*
* Globals:
*  fIsPwb	= TRUE => we are executing as PWB
*  memuse	= memory usage options
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
zspawnp (
    REGISTER char const *p,
    flagType fAsk
    )
{
    intptr_t    i;
    flagType fCmd       = FALSE;            /* TRUE => null shell           */
    KBDMODE  KbdMode;

    /*
     * support suppression of the prompt by explicit character in front of
     * command, then skip any leading whitespace
     */
    if (*p == '!') {
        fAsk = FALSE;
        p++;
    }

    p = whiteskip (p);
    /*
     * if no command to execute, use command processor
     */
    if (!*p) {
        fCmd = TRUE;
        fAsk = FALSE;
        p = pComSpec;
    }

    KbdMode = KbGetMode();
	prespawn (CE_VM);
	i = fCmd ? _spawnlp (P_WAIT, (char *)p, (char *)p, NULL) : system (p);
    postspawn ((flagType)(!mtest () && fAskRtn && (i != -1) && fAsk));
    // Hook the keyboard
    KbHook();
    KbSetMode(KbdMode);

    if (i == -1) {
        printerror ("Spawn failed on %s - %s", p, error ());
    }
    return (flagType)(i != -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mkupdate\mkupdate.h ===
/*++

Copyright Microsoft Corporation, 1996-7, All Rights Reserved.      

Module Name:

    mkupdate.h

Abstract:

    Defines for application to create the update database from
    appropriately structured input update file and to maintain driver
    revisions

Author:

     Shivnandan Kaushik

Environment:

    User mode

Revision History:


--*/

#ifndef MKUPDATE_H
#define MKUPDATE_H

//
// Signature field returned by CPUID
//

#include "pshpack1.h"

typedef struct _CPU_SIGNATURE {
    union {
        ULONG LongPart;
        struct {
            ULONG   Stepping:4;
            ULONG   Model:4;
            ULONG   Family:4;
            ULONG   ProcessorType:2;
            ULONG   Reserved:18;
        } hw;
    } u;
} CPU_SIGNATURE, *PCPU_SIGNATURE;

typedef struct _PROCESSOR_FLAGS {
    union {
        ULONG LongPart;
        struct {
            ULONG   Slot1:1;
            ULONG   Mobile:1;
            ULONG   Slot2:1;
            ULONG   MobileModule:1;
            ULONG   Reserved1:1;
            ULONG   Reserved2:1;
            ULONG   Reserved3:1;
            ULONG   Reserved4:1;
            ULONG   Reserved:24;
        } hw;
    } u;
} PROCESSOR_FLAGS, *PPROCESSOR_FLAGS;

#define FLAG_SLOT1      0x1
#define FLAG_MOBILE     0x2
#define FLAG_SLOT2      0x4
#define FLAG_MODULE     0x8
#define FLAG_RESERVED1  0x10
#define FLAG_RESERVED2  0x20
#define FLAG_RESERVED3  0x40
#define FLAG_RESERVED4  0x80

#define MASK_SLOT1      ~(FLAG_SLOT1)
#define MASK_MOBILE     ~(FLAG_MOBILE)
#define MASK_SLOT2      ~(FLAG_SLOT2)
#define MASK_MODULE     ~(FLAG_MODULE)
#define MASK_RESERVED1  ~(FLAG_RESERVED1)
#define MASK_RESERVED2  ~(FLAG_RESERVED2)
#define MASK_RESERVED3  ~(FLAG_RESERVED3)
#define MASK_RESERVED4  ~(FLAG_RESERVED4)

// Structure defining a Pentium (R) Pro Processor Update
// This structure is also defined in nt\private\ntos\dd\update\update.h

#define UPDATE_VER_1_HEADER_SIZE 0x30
#define UPDATE_VER_1_DATA_SIZE   500

typedef struct _UPDATE {
    ULONG HeaderVersion;                    // Update Header Version
    ULONG UpdateRevision;                   // Revision number
    ULONG Date;                             // Date of update release
    CPU_SIGNATURE Processor;                // Target processor signature
    ULONG Checksum;                         // Checksum of entire update
                                            // including header
    ULONG LoaderRevision;                   // Loader revision for loading 
                                            // update to processor
    PROCESSOR_FLAGS ProcessorFlags;         // Processor Slot Information
    ULONG Reserved[5];                      // Reserved by Intel Corp. 
    ULONG Data[UPDATE_VER_1_DATA_SIZE];     // Update data
} UPDATE, *PUPDATE;

#include "poppack.h"

typedef struct _UPDATE_ENTRY{
    ULONG CpuSignature;
    ULONG UpdateRevision;
    ULONG ProcessorFlags;
    CHAR  CpuSigStr[32];
    CHAR  UpdateRevStr[32];
    CHAR  FlagsStr[32];
} UPDATE_ENTRY, *PUPDATE_ENTRY;

#define MAX_LINE                512
#define UPDATE_VER_SIZE          13         // Max. characters per patch version
#define UPDATE_DATA_FILE        "updtdata.c"

#define UPDATE_VERSION_FILE     "update.ver"

#endif //MKUPDATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mkupdate\mkupdate.c ===
/*++

Copyright Microsoft Corporation, 1996-7, All Rights Reserved.      

Module Name:

    mkupdate.c

Abstract:

    Application for creating the update database file from an
    appropriately structured input update file and maintaining
    the driver version in the resource file.

Author:

     Shivnandan Kaushik

Environment:

    User mode

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <winbase.h>
#include <winioctl.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include "mkupdate.h"

//
// Globals
//

PUPDATE_ENTRY UpdateTable;

VOID
GenMSHeader(
    FILE *file,
    CHAR *Filename,
    CHAR *Abstract
    )
/*++
Routine Description:

    Generates the Microsoft recommended header for code files.

Arguments:

  File: Output file pointer
  FileName: Output file name
  Abstract: Description of file

Return Value:
    
   None

--*/
{   
    fprintf(file,"/*++ \n\nCopyright (c) 1996-7  Microsoft Corporation, ");
    fprintf(file,"All Rights Reserved.\n\n");
    fprintf(file,"Copyright (c) 1995-2000 Intel Corporation. This update binary code\n");
    fprintf(file,"is distributed for the sole purpose of being loaded into Intel\n");
    fprintf(file,"Pentium(R) Pro Processor Family  and Pentium(R) 4 Family microprocessors.\n");
    fprintf(file,"All Rights on the binary code are reserved.\n\n");
    fprintf(file,"Module Name:\n\n    %s\n\n",Filename);
    fprintf(file,"Abstract:\n\n    %s\n\n",Abstract);
    fprintf(file,"Author:\n\n    !!!THIS IS A GENERATED FILE. DO NOT DIRECTLY EDIT!!!\n\n");
    fprintf(file,"Revision History:\n\n--*/\n\n");
}
    
BOOL
GetVerifyPutUpdate(
    FILE *OutputFile,
    ULONG UpdateNum,
    ULONG TotalUpdates
    )
/*++
Routine Description:

    Read in an update, verify it and write to data file.

Arguments:

    OutputFile: output file pointer
    UpdateNum: Update number in update list
    TotalUpdates: Total number of updates in update list.

Return Value:
    
    TRUE if writes succeeded else FALSE.

--*/
{
    FILE *UpdateFile;
    CHAR Line[MAX_LINE],UpdateString[MAX_LINE];
    CHAR Filename[MAX_PATH];
    BOOL BeginFound,EndFound;
    ULONG CurrentDword,i,Checksum;
    ULONG UpdateBuffer[sizeof(UPDATE)];
    PUPDATE CurrentUpdate;

    // create the string name of the file to open

    strcpy(Filename,UpdateTable[UpdateNum].CpuSigStr);
    strcat(Filename,"_");
    strcat(Filename,UpdateTable[UpdateNum].UpdateRevStr);
    strcat(Filename,".");
    strcat(Filename,UpdateTable[UpdateNum].FlagsStr);

    UpdateFile = fopen(Filename,"r");

    if (UpdateFile == NULL) {
        fprintf(stdout,"mkupdate:Unable to open update input file %s\n",Filename);
        return(FALSE);
    }

    //
    // Read in each update - scan till beginning of update
    // marked by keyword BEGIN_UPDATE
    //

    BeginFound = FALSE;
    while (fgets(Line,MAX_LINE,UpdateFile) != NULL) {
        if (sscanf(Line,"%s",&UpdateString)) {
            if (strcmp(UpdateString,"BEGIN_UPDATE") == 0) {
                BeginFound = TRUE;
                break;
            }
        }
    }

    if (!BeginFound) {
        fprintf(stdout,"mkupdate:BEGIN_UPDATE not found in update file %s\n",Filename);
        fclose(UpdateFile);
        return(FALSE);
    }

    //
    // scan "update size" forward.
    //

    EndFound = FALSE;
    for (i = 0; i < sizeof(UPDATE)/sizeof(ULONG); i++) {
        if (fgets(Line,MAX_LINE,UpdateFile) != NULL) {
            if (sscanf(Line,"%lx",&CurrentDword)) 
                UpdateBuffer[i] = CurrentDword;
        } else {
            EndFound = TRUE;
            break;
        }
    }

    if (EndFound) {
        fprintf(stdout,"mkupdate:Abnormal termination of update file %s\n",Filename);
        fclose(UpdateFile);
        return(FALSE);
    } else {
        if (fgets(Line,MAX_LINE,UpdateFile) != NULL) {
            if (sscanf(Line,"%s",&UpdateString)) {
                if (strcmp(UpdateString,"END_UPDATE") != 0) {
                    fprintf(stdout,"mkupdate:Update data size in %s incorrect\n",Filename);
                    fclose(UpdateFile);
                    return(FALSE);
                }
            }
        } else {
            fprintf(stdout,"mkupdate:Abnormal termination of update file %s\n",Filename);
            fclose(UpdateFile);
            return(FALSE);
        }
    }
    
    fclose (UpdateFile);

    // Verify Update - Checksum Buffer

    Checksum = 0;
    for (i = 0; i < sizeof(UPDATE)/sizeof(ULONG); i++) {
        Checksum += UpdateBuffer[i];
    }

    if (Checksum){
        fprintf(stdout,"mkupdate:Incorrect update checksum in %s\n",Filename);
        return(FALSE);
    } 

    //
    // Verify update - check if processor signature, update revision
    // and processor flags match that specified in listing file and 
    // update data file name
    //

    CurrentUpdate = (PUPDATE) UpdateBuffer;

    if ((CurrentUpdate->Processor.u.LongPart != 
            UpdateTable[UpdateNum].CpuSignature)){
        fprintf(stdout,"mkupdate:incorrect processor signature in %s: ",Filename); 
        fprintf(stdout,"expected 0x%lx got 0x%lx\n",
                        UpdateTable[UpdateNum].CpuSignature,
                        CurrentUpdate->Processor.u.LongPart); 
        return(FALSE);
    }

    if (CurrentUpdate->UpdateRevision != 
            UpdateTable[UpdateNum].UpdateRevision){
        fprintf(stdout,"mkupdate:incorrect update revision in %s: ",Filename); 
        fprintf(stdout,"expected 0x%lx got 0x%lx\n",
                        UpdateTable[UpdateNum].UpdateRevision,
                        CurrentUpdate->UpdateRevision); 
        return(FALSE);
    }

    if ((CurrentUpdate->ProcessorFlags.u.LongPart != 
            UpdateTable[UpdateNum].ProcessorFlags)){
        fprintf(stdout,"mkupdate:incorrect processor flags in %s: ",Filename); 
        fprintf(stdout,"expected 0x%lx got 0x%lx\n",
                        UpdateTable[UpdateNum].ProcessorFlags,
                        CurrentUpdate->ProcessorFlags.u.LongPart); 
        return(FALSE);
    }

    //
    // Input update validated. Write out validated update
    //

    fprintf(OutputFile,"    {\n");
    for (i = 0; i < sizeof(UPDATE)/sizeof(ULONG); i++) {
        fprintf(OutputFile,"        0x%.8x",UpdateBuffer[i]);
        if (i == sizeof(UPDATE)/sizeof(ULONG) - 1) {
            fprintf(OutputFile,"\n");
        } else {
            fprintf(OutputFile,",\n");
        }
    }
    fprintf(OutputFile,"    }");
    if (UpdateNum != TotalUpdates-1) {
        fprintf(OutputFile,",\n");
    }
    
    return(TRUE);
}

VOID
BuildUpdateInfoTable(
    FILE *OutputFile,
    ULONG TotalUpdates
    )
/*++
Routine Description:

    Write the CPU Signature and Processor Flags into the 
    Build Table and adds NULL for the MDL Item.

Arguments:

    OutputFile   :  output file pointer
    TotalUpdates :  Total number of updates in update list.

Return Value:
    
   None:

--*/
{   
    ULONG CpuSignature, ProcessorFlags, i;

    fprintf(OutputFile, "//\n// Update Info Table containing the CPU Signatures,\n");
    fprintf(OutputFile, "// Processor Flags, and MDL Pointers.  The MDL Pointers\n");
    fprintf(OutputFile, "// are initialized to NULL.  They get populated as pages\n");
    fprintf(OutputFile, "// corresponding to specific updates are locked in memory.\n");
    fprintf(OutputFile, "// This table contains the CPU Signatures and Processor Flags.\n");
    fprintf(OutputFile, "// in the same order as in the update database.  Therefore,\n");
    fprintf(OutputFile, "// the Update Info Table self-indexes to the right update.\n//\n\n");
    fprintf(OutputFile, "UPDATE_INFO UpdateInfo[] = {\n");

    //
    // Add each entry for the info
    //

    for (i = 0; i < TotalUpdates; i++) {
        CpuSignature = strtoul(UpdateTable[i].CpuSigStr, NULL, 16);
        ProcessorFlags = strtoul(UpdateTable[i].FlagsStr, NULL, 16);
        if (i < (TotalUpdates - 1)) {
            fprintf(OutputFile, "        {0x%x, 0x%x, NULL},\n", CpuSignature, ProcessorFlags);
        } else {
            fprintf(OutputFile, "        {0x%x, 0x%x, NULL}\n", CpuSignature, ProcessorFlags);
        }
    }
    
    //
    // generate closing code for the update info definition
    //

    fprintf(OutputFile, "};\n");

    return;
}

ULONG
PopulateUpdateList(
    CHAR *ListingFile
    )
/*++
Routine Description:

    Populates the update list with (processor signature, update revision)
    pairs included in the update listing file and returns the number of 
    updates found.

Arguments:

    ListingFile

Return Value:
    
   Number of updates in the update list. 0 if no updates found or any
   error encountered.

--*/
{
    CHAR Line[MAX_LINE],UpdateString[MAX_LINE];
    CHAR CpuSigStr[MAX_LINE],UpdateRevStr[MAX_LINE];
    CHAR FlagsStr[MAX_LINE];
    BOOL BeginFound,EndFound,Error;
    FILE *TmpFilePtr;
    ULONG NumUpdates,i;
    ULONG CpuSignature,UpdateRevision,ProcessorFlags;

#ifdef DEBUG
    fprintf(stderr,"listing file %s\n",ListingFile);
#endif
    // Open the update listing file

    TmpFilePtr = fopen(ListingFile,"r");

    if (TmpFilePtr == NULL) {
        fprintf(stdout,"mkupdate:Unable to open update listing file %s\n",ListingFile);
        return(0);
    };

    //
    // Scan for beginning of the update list marked by
    // BEGIN_UPDATE_LIST keyword
    //
    
    BeginFound = FALSE;
    while ((!BeginFound) && (fgets(Line,MAX_LINE,TmpFilePtr) != NULL)) {
        if (sscanf(Line,"%s",&UpdateString)) {
            if (strcmp(UpdateString,"BEGIN_UPDATE_LIST") == 0) {
                BeginFound = TRUE;
            }
        }
    }

    if (!BeginFound) {
        fprintf(stdout,"mkupdate:BEGIN_UPDATE_LIST not found in update listing file %s\n",ListingFile);
        fclose(TmpFilePtr);
        return(0);
    };

    //
    // Scan for end of the update list marked by
    // END_UPDATE_LIST keyword and count # updates.
    //
    
    NumUpdates = 0;
    EndFound = FALSE;   
    while ((!EndFound) && (fgets(Line,MAX_LINE,TmpFilePtr) != NULL)) {
        if (sscanf(Line,"%s",&UpdateString)) {
            if (strcmp(UpdateString,"END_UPDATE_LIST") == 0) {
                EndFound = TRUE;
            } else {
                NumUpdates++;
            }
        }
    }
    fclose(TmpFilePtr);
    if (!EndFound) {
        fprintf(stdout,"mkupdate:END_UPDATE_LIST not found in update listing file %s\n",ListingFile);
        return(0);
    }
    
    //
    // If legal file format and non-zero number of updates are found
    // then read the processor signatures and update revisions into
    // the update list.
    //
    
    if (NumUpdates) {

        // allocate memory for storing cpu signatures 

        UpdateTable = (UPDATE_ENTRY *) malloc(NumUpdates*sizeof(UPDATE_ENTRY));
        if (UpdateTable == NULL){
            fprintf(stdout,"mkupdate:Error: Memory Allocation Error\n");
            return(0);  
        }

        TmpFilePtr = fopen(ListingFile,"r");
        if (TmpFilePtr == NULL) {
            fprintf(stdout,"mkupdate:Unable to open update listing file %s\n",ListingFile);
            return(0);
        };

        while ((fgets(Line,MAX_LINE,TmpFilePtr) != NULL)) {
            if (sscanf(Line,"%s",&UpdateString)) {
                if (strcmp(UpdateString,"BEGIN_UPDATE_LIST") == 0) {
                    break;
                }
            }
        }

        // Scan the listing file and populate the update table

        Error = FALSE;
        for (i = 0; i < NumUpdates; i++) {
            if (fgets(Line,MAX_LINE,TmpFilePtr) == NULL) {
                fprintf(stdout,"mkupdate: Abnormal termination in update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }

            if (sscanf(Line,"%s %s %s",&CpuSigStr,&UpdateRevStr,&FlagsStr) != 3) {
                fprintf(stdout,"mkupdate: Incorrect format of update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }
#ifdef DEBUG
            fprintf(stderr,"CpuSig %s Update Rev %s Processor Flags %s,\n",CpuSigStr,
                    UpdateRevStr,FlagsStr);
#endif
            if (sscanf(CpuSigStr,"%lx",&CpuSignature) != 1) {
                fprintf(stdout,"mkupdate: Incorrect Processor Signature in update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }
            if (sscanf(UpdateRevStr,"%lx",&UpdateRevision)!= 1) {
                fprintf(stdout,"mkupdate: Incorrect Update Revision of update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }
            if (sscanf(FlagsStr,"%lx",&ProcessorFlags)!= 1) {
                fprintf(stdout,"mkupdate: Incorrect Processor Flags in update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }

#ifdef DEBUG
            fprintf(stderr,"CpuSig 0x%lx Update Rev 0x%lx Flags 0x%lx,\n",
                    CpuSignature,UpdateRevision,ProcessorFlags);
#endif
            strcpy(UpdateTable[i].CpuSigStr,CpuSigStr);
            UpdateTable[i].CpuSignature = CpuSignature;
            strcpy(UpdateTable[i].UpdateRevStr,UpdateRevStr);
            UpdateTable[i].UpdateRevision = UpdateRevision;
            strcpy(UpdateTable[i].FlagsStr,FlagsStr);
            UpdateTable[i].ProcessorFlags = ProcessorFlags;
        }

        fclose(TmpFilePtr);
        if (Error) {
            NumUpdates = 0;
            free(UpdateTable);
        }
    }

    return(NumUpdates);
}

VOID
CleanupDataFile(
    VOID
    )
/*++
Routine Description:

    If any operation during the creation of the new Data file fails, 
    then delete it so that the build for the driver will fail.

Arguments:

    None

Return Value:
    
    None

--*/
{
    DeleteFile(UPDATE_DATA_FILE);            
}

BOOL
SanitizeUpdateList(
    ULONG NumUpdates
    )
/*++
Routine Description:

    Sanitizes the update list. Checking for duplicate processor 
    signatures.

Arguments:

  NumUpdates: Number of updates in the update list.

Return Value:
    
    TRUE is list clean else FALSE.

--*/
{
    ULONG i,j;
    PROCESSOR_FLAGS ProcessorFlags;

    //
    // Check for garbage values in the update table
    //

    for (i = 0; i < NumUpdates-1; i++) {
        if (UpdateTable[i].CpuSignature == 0) {
            fprintf(stdout,"mkupdate: Error: incorrect processor signature in update list.\n");
            return(FALSE);    
        }
        if (UpdateTable[i].UpdateRevision == 0) {
            fprintf(stdout,"mkupdate: Error: incorrect update revision in update list.\n");
            return(FALSE);    
        }

        if (UpdateTable[i].ProcessorFlags != 0) {

            // Only a single bit must be set

            ProcessorFlags.u.LongPart = UpdateTable[i].ProcessorFlags;

            if (((ProcessorFlags.u.hw.Slot1) && 
                    (ProcessorFlags.u.LongPart & MASK_SLOT1)) ||
                ((ProcessorFlags.u.hw.Mobile) && 
                    (ProcessorFlags.u.LongPart & MASK_MOBILE)) ||
                ((ProcessorFlags.u.hw.Slot2) && 
                    (ProcessorFlags.u.LongPart & MASK_SLOT2)) ||
                ((ProcessorFlags.u.hw.MobileModule) && 
                    (ProcessorFlags.u.LongPart & MASK_MODULE)) ||
                ((ProcessorFlags.u.hw.Reserved1) && 
                    (ProcessorFlags.u.LongPart & MASK_RESERVED1)) ||
                ((ProcessorFlags.u.hw.Reserved2) && 
                    (ProcessorFlags.u.LongPart & MASK_RESERVED2)) ||
                ((ProcessorFlags.u.hw.Reserved3) && 
                    (ProcessorFlags.u.LongPart & MASK_RESERVED3)) ||
                ((ProcessorFlags.u.hw.Reserved4) && 
                    (ProcessorFlags.u.LongPart & MASK_RESERVED4))) {
                fprintf(stdout,"mkupdate: Error: incorrect processor flags in update list.\n");
                return(FALSE);    
            }
        }
    }
     
    for (i = 0; i < NumUpdates-1; i++) {
        for (j = i+1; j < NumUpdates; j++) {
            if ((UpdateTable[i].CpuSignature == UpdateTable[j].CpuSignature) 
                && (UpdateTable[i].ProcessorFlags == UpdateTable[j].ProcessorFlags)){
                fprintf(stdout,"mkupdate:Error: Duplicate processor entry 0x%lx:0x%lx in update list\n",
                        UpdateTable[i].CpuSignature,UpdateTable[i].ProcessorFlags);
                return(FALSE);
            }
        }
    }
    return(TRUE);
}

int
__cdecl main(
    int argc,
    LPSTR argv[]
    )
/*++
Routine Description:
    Scans the processor update listing file, pick up the specified 
    processor updates, verify the updates and generate the update 
    data file to be used by the update driver. Generates the 
    version numbers and strings to be included in the 
    resource definition file.

Arguments:
    
      listing file: list of the processor updates to be included in 
                    the driver.

Return Value:

--*/
{
    FILE    *DataOut, *RCFile,*VerFile;
    ULONG   NumUpdates,i;
    CHAR    Line[MAX_LINE];
    CHAR    *CurrentDataVersionString;
    BOOL    VerFileFound;
    CHAR    VersionFile[MAX_LINE];
    CHAR    *VersionDirectory;

    VersionFile[0] = 0;

    if (argc < 2) {
        fprintf(stdout,"%s: Usage: %s <patch listing file>\n",argv[0],argv[0]);
        exit(0);
    }
    
#ifdef DEBUG
    fprintf(stderr,"listing file %s\n",argv[1]);
#endif
    
    // Open generated file UPDATE_DATA_FILE. Delete previous file if any.

    DataOut=fopen(UPDATE_DATA_FILE,"w");

    if (DataOut == NULL) {
        fprintf(stdout,"mkupdate:Unable to open update data file %s\n",UPDATE_DATA_FILE);
        exit(0);
    }

    // Scan listing file and store all the CPU signatures in update table

    NumUpdates = PopulateUpdateList(argv[1]);
    if (NumUpdates == 0) {
        fprintf(stdout,"mkupdate:Listing file %s: Incorrect format or no updates specified.\n",
                argv[1]);
        fclose(DataOut);
        exit(0);
    }

    //
    // Dynamically allocate the size for CurrentDataVersionString
    //

    CurrentDataVersionString = (CHAR*)malloc(NumUpdates * UPDATE_VER_SIZE);

    if (CurrentDataVersionString == NULL) {
        fprintf(stdout,"mkupdate:Listing file %s: Failed to allocate memory.\n",
                argv[1]);
        fclose(DataOut);
        exit(0);
    }

    // Sanitize the update list

    if (!SanitizeUpdateList(NumUpdates)) {
        fclose(DataOut);
        DeleteFile(UPDATE_DATA_FILE);
        free(CurrentDataVersionString);
        exit(0);
    }

    // Generate the data file. First generate all headers

    GenMSHeader(DataOut,UPDATE_DATA_FILE,"Processor updates.");

    // generate the data segment alloc pragmas

    fprintf(DataOut,"\n#ifdef ALLOC_DATA_PRAGMA\n");
    fprintf(DataOut,"#pragma data_seg(\"PAGELK\")\n");
    fprintf(DataOut,"#endif\n\n");

    // generate the update table definition

    fprintf(DataOut,"//\n// Updates data\n//\n\n");
    fprintf(DataOut,"UPDATE UpdateData[] = {\n");
    
    // include each update

    for (i=0; i < NumUpdates; i++) {
        if (!GetVerifyPutUpdate(DataOut,i,NumUpdates)) {
            fprintf(stdout,"mkupdate:Error: processing update data file %s_%s.%s\n",
                UpdateTable[i].CpuSigStr,UpdateTable[i].UpdateRevStr,
                UpdateTable[i].FlagsStr);
            fclose(DataOut);
            CleanupDataFile();
            free(CurrentDataVersionString);
            exit(0);
        }
    }
    
    // generate closing code for the update table definition

    fprintf(DataOut,"\n};\n");

    // generate the closing data segment alloc pragmas

    fprintf(DataOut,"\n#ifdef ALLOC_DATA_PRAGMA\n");
    fprintf(DataOut,"#pragma data_seg()\n");
    fprintf(DataOut,"#endif\n\n");

    //
    // Generate the Update Info Table containing the
    // processor signatures, processor flags, and 
    // pointers to MDLs (initialized to NULL)
    //

    BuildUpdateInfoTable(DataOut, NumUpdates);
    
    fclose(DataOut);

    // Generate the version file. Delete previous file if any.

    RCFile = fopen(UPDATE_VERSION_FILE,"w");

    if (RCFile == NULL) {
        fprintf(stdout,"%s: Unable to open version file %s\n",
                argv[0],UPDATE_VERSION_FILE);
        free(CurrentDataVersionString);
        exit(0);
    }
    
    // Generate header

    GenMSHeader(RCFile,UPDATE_VERSION_FILE,"Version information for update device driver.");

    //
    // Open common.ver. If found generate the dataversion string and 
    // copy everything to our RC file and insert our
    // string definitions in the StringFileInfo resource section. We need
    // to do this because inclusion of common.ver prevents the addition 
    // of new string defines in the stringfileinfo block. If common.ver
    // is not found in the expected place we only include it expecting the 
    // appropriate settings in the build environment to locate the file.
    // 

    //
    // Generate the common.ver path name
    //
    
    //
    // Obtain the Drive Name
    //

    VersionDirectory = getenv( "_NTDRIVE" );

    if (VersionDirectory == NULL) {
        fprintf(stdout,"%s: Unable to obtain _NTDRIVE ENV variable\n",argv[0]);
        fclose(RCFile);
        free(CurrentDataVersionString);
        exit(0);
    }
 
    strcpy(VersionFile, VersionDirectory);

    //
    // Obtain the Base Directory
    //

    VersionDirectory = getenv( "_NTROOT" );

    if (VersionDirectory == NULL) {
        fprintf(stdout,"%s: Unable to obtain _NTROOT ENV variable\n",argv[0]);
        fclose(RCFile);
        free(CurrentDataVersionString);
        exit(0);
    }

    strcat(VersionFile, VersionDirectory);
    strcat(VersionFile, "\\public\\sdk\\inc\\common.ver");

    VerFile = fopen(VersionFile,"r");

    if (VerFile == NULL) {
        fprintf(stdout,"%s: Unable to open version file common.ver\n",argv[0]);
        VerFileFound = FALSE;
    } else {
        VerFileFound = TRUE;
    }

    if (VerFileFound) {

        // Construct data version string from update listing table

        strcpy(CurrentDataVersionString,"\"");
        for (i=0; i < NumUpdates; i++) {
            strcat(CurrentDataVersionString,UpdateTable[i].CpuSigStr);
            strcat(CurrentDataVersionString,"-");
            strcat(CurrentDataVersionString,UpdateTable[i].FlagsStr);
            strcat(CurrentDataVersionString,",");
            strcat(CurrentDataVersionString,UpdateTable[i].UpdateRevStr);
            if (i != NumUpdates-1)
                strcat(CurrentDataVersionString,",");
        }
        strcat(CurrentDataVersionString,"\"");

#ifdef DEBUG
        fprintf(stderr,"DataVersionString %s\n",CurrentDataVersionString);
#endif
        
        fprintf(RCFile,"#define VER_DATAVERSION_STR    %s\n",
                CurrentDataVersionString);

        // Scan till string info block into version file, add our 
        // definition and scan till end

        while (fgets(Line,MAX_LINE,VerFile) != NULL) {
            fputs(Line,RCFile);
            if (strstr(Line,"VALUE") && strstr(Line,"ProductVersion") 
                && strstr(Line,"VER_PRODUCTVERSION_STR")){
                fprintf(RCFile,"            VALUE \"DataVersion\",     VER_DATAVERSION_STR\n");
            }
        }
    } else {
        
        // version file not found. Cannot define the dataversion
        // and codeversion strings. Only include common.ver

        fprintf(RCFile,"\n\n#include \"common.ver\"\n");
    }
    
    fclose(RCFile);
    fclose(VerFile);
    free(CurrentDataVersionString);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtdir\mtdir.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <direct.h>

#define MALLOC(x,y) (x *)malloc(sizeof(x) * (y))

#define Empty     0
#define Not_Empty 1

BOOL    Verbose = FALSE;
BOOL    Execute = FALSE;
BOOL    Remove  = FALSE;
BOOL    SubDir  = FALSE;

void Usage(char *Message);
void VerboseUsage(char *Message);
BOOL CheckIfEmpty(char *Directory, BOOL PrintIt);

void Usage(char *Message)
{
    fprintf (stderr, "Usage: %s [/d] [/e] [/v] [directory ...]\n", Message);
    exit(1);
}

void VerboseUsage(char *Message)
{
    fprintf (stderr, "%s: Looking for empty SubDirectories\n\n", Message);
    fprintf (stderr, "%s%s%s%s%s%s%s",
             "A directory is treated as empty if it has no file or directory in it.  In any\n",
             "case, a directory is not empty if it has file.\n",
             "Available switches are:\n",
             "    /d:    directory is also listed empty if it only has SubDirectory in it\n",
             "    /e:    acutally perform deletions of empty directories\n",
             "    /v:    Verbose\n",
             "    /?:    prints this message\n");
    exit(1);
}

BOOL CheckIfEmpty(char *Directory, BOOL PrintIt)
{
    HANDLE DirHandle;
    WIN32_FIND_DATA FindData;
    WIN32_FIND_DATA *fp;
    BOOL IsEmpty;
    char Buffer[MAX_PATH];

    IsEmpty = TRUE;

    fp = &FindData;

    //
    //  Make one pass to find out if directory is empty
    //

    sprintf(Buffer, "%s\\*.*", Directory);

    DirHandle = FindFirstFile(Buffer, fp);

    do {

        // We want to skip "." and ".."  Once the control enters this scope,
        // the file found is not "." or ".."

        if (strcmp(fp->cFileName, ".") && strcmp(fp->cFileName, ".."))
        {
                        
            if (fp->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (!SubDir)    // If -d is not given on cmd line,
                {
                    IsEmpty = FALSE;  // We found a directory so we're not empty unless -d is specified
                }

            } else
            {
                IsEmpty = FALSE;  // We found a file so we're not empty.
            }
        }

    } while (FindNextFile(DirHandle, fp));

    FindClose(DirHandle);

    //
    //  Make another pass to call CheckIfEmpty recursively
    //

    sprintf(Buffer, "%s\\*.*", Directory);

    DirHandle = FindFirstFile(Buffer, fp);

    do {

        // We want to skip "." and ".."  Once the control enters this scope,
        // the file found is not "." or ".."

        if (strcmp(fp->cFileName, ".") && strcmp(fp->cFileName, ".."))
        {
            if (fp->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                //
                // Recursively call CheckIfEmpty on each subdirectory.
                //
                                
                sprintf(Buffer, "%s\\%s", Directory, fp->cFileName);

                if (SubDir)
                {
                    IsEmpty = (CheckIfEmpty( Buffer, !IsEmpty) && IsEmpty);

                } else
                {
                    Remove = CheckIfEmpty( Buffer, TRUE);
                }
                //
                // If in execute mode try to remove subdirectory, if it's empty it will be removed
                //
                if (Execute && Remove)
                {
                    _rmdir( Buffer);
                }
            }
        }

    } while (FindNextFile(DirHandle, fp));

    FindClose(DirHandle);

    if (IsEmpty && PrintIt)
    {
        if (Execute)
        {
            fprintf(stdout, "empty directory %s deleted\n", Directory);
        }
        else
        {
            fprintf(stdout, "%s empty\n", Directory);
        }

    }    else if (Verbose)
    {
        fprintf(stdout, "%s non-empty\n", Directory);
    }
    return (IsEmpty);
}


void _cdecl main(int argc, char *argv[])
{
    char c;
    char *prog = argv[0];
    char curdir[MAX_PATH];
        
    argc--;
    argv++;

    // Parse cmd line arguments for switches or flags.  Switches are not
    // case-sensitive
        
    while (argc > 0 && (**argv == '-' || **argv == '/'))
    {
        while (c = *++argv[0])
        {
            _tolower(c);

            switch (c)
            {
                case 'v':
                    Verbose = TRUE;
                    break;
                case 'd':
                    SubDir = TRUE;
                    //
                    // Always try to remove the directory if using /d
                    //
                    Remove = TRUE;
                    break;
                case 'e':
                    Execute = TRUE;
                    break;
                case '?':
                    VerboseUsage(prog);
                    break;
                default:
                    fprintf(stderr, "%s: Invalid switch \"%c\"\n", prog, c);
                    Usage(prog);
                    break;
            }
        }

        argc--;
        argv++;
    }

    if (argc < 1)             // No path given in cmd line.  Assume 'dot'
    {
        CheckIfEmpty(".", TRUE);
    }

    while (*argv)             // Check all the directories specified on
                              // the cmd line.
    {
        CheckIfEmpty(argv[0], TRUE);
        argv++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\exe\dialogs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       dialogs.cxx
//
//  Contents:   Implementation of dialog classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   ConfigDlgProc
//
//  Synopsis:   Handles the Config dialog
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK
ConfigDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CConfig * pConfig;

    pConfig = (CConfig *)GetWindowLong(hwnd, DWL_USER);

    switch (msg)
    {
    case WM_INITDIALOG:
        pConfig = (CConfig*)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);

        pConfig->InitializeConfigDialog(hwnd);

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            if (pConfig->CommitConfigChanges(hwnd))
                EndDialog(hwnd, 0);
            break;

        case IDCANCEL:
            EndDialog(hwnd, 1);
            break;
        }

        return TRUE;
    }

    return FALSE;
}

HRESULT
CConfig::QueryInterface(REFIID iid, void **ppvObj)
{
    VERIFY_THREAD();

    if (iid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

DWORD
CConfig::ThreadMain()
{
    AddRef();

    SetName("Config");

    ThreadStarted(S_OK);  // Must be after the AddRef() call!

    int ret = DialogBoxParam(g_hInstance,
                             MAKEINTRESOURCE(IDD_CONFIGPATHS),
                             NULL,
                             ConfigDlgProc,
                             (LPARAM)this);
    if (ret == -1)
    {
        ErrorPopup(L"Could not bring up config dialog");
    }

    Release();

    return 0;
}

void
CConfig::InitializeConfigDialog(HWND hwnd)
{
    CStr cstr;
    CStr cstrInit;

    _hwnd = hwnd;

    _pMT->_options.GetScriptPath(&cstr);
    _pMT->_options.GetInitScript(&cstrInit);

    SetDlgItemText(hwnd, IDD_SCRIPTPATH, cstr);
    SetDlgItemText(hwnd, IDD_INITSCRIPT, cstrInit);
}

BOOL
CConfig::CommitConfigChanges(HWND hwnd)
{
    LOCK_LOCALS(_pMT);

    CStr cstr;

    TCHAR achBufPath[MAX_PATH];
    TCHAR achBufScript[MAX_PATH];

    // Read in the options from the dialog and store them.  Need to have a
    // way to revert to defaults. Right now the user can revert to the
    // defaults by clearing the textbox(s) and clicking OK.

    GetDlgItemText(hwnd, IDD_SCRIPTPATH, achBufPath, sizeof(achBufPath));
    GetDlgItemText(hwnd, IDD_INITSCRIPT, achBufScript, sizeof(achBufScript));
    EnableWindow(_hwnd, FALSE);
    BOOL retval = _pMT->SetScriptPath(achBufPath, achBufScript);
    EnableWindow(_hwnd, TRUE);
    return retval;
}

//+---------------------------------------------------------------------------
//
//  Function:   MBTimeoutDlgProc
//
//  Synopsis:   Handles the MessageBoxTimeout dialog
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK
MBTimeoutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMessageBoxTimeout * pDialog;

    pDialog = (CMessageBoxTimeout *)GetWindowLong(hwnd, DWL_USER);

    switch (msg)
    {
    case WM_INITDIALOG:
        pDialog = (CMessageBoxTimeout*)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);

        pDialog->InitializeDialog(hwnd);

        return TRUE;

    case WM_COMMAND:
        pDialog->OnCommand(LOWORD(wParam), HIWORD(wParam));
        return TRUE;

    case WM_TIMER:
        pDialog->OnTimer();
        return TRUE;

    case WM_CLOSE:
        return TRUE;

    case WM_DESTROY:
        pDialog->_hwnd = NULL;
        break;
    }

    return FALSE;
}

HRESULT
CMessageBoxTimeout::QueryInterface(REFIID iid, void **ppvObj)
{
    VERIFY_THREAD();

    if (iid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

DWORD
CMessageBoxTimeout::ThreadMain()
{
    AddRef();

    Assert(_pmbt != NULL);

    SetName("MsgBoxTO");

    ThreadStarted(S_OK);  // Must be after the AddRef() call!

    int ret = DialogBoxParam(g_hInstance,
                             MAKEINTRESOURCE(IDD_MESSAGEBOX),
                             NULL,
                             MBTimeoutDlgProc,
                             (LPARAM)this);
    if (ret == -1)
    {
        _pmbt->mbts = MBTS_ERROR;
    }
    else
    {
        _pmbt->mbts = (MBT_SELECT)ret;
    }

    SetEvent(_pmbt->hEvent);

    Release();

    return 0;
}

void
CMessageBoxTimeout::InitializeDialog(HWND hwnd)
{
    CStr   cstrButtons;
    TCHAR *pch = NULL;
    int    i;

    _hwnd = hwnd;

    SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

    cstrButtons.Set(_pmbt->bstrButtonText);

    SetDlgItemText(hwnd, IDD_MESSAGE, _pmbt->bstrMessage);

    for (i = 5; i > 0; i--)
    {
        pch = (i == 1) ? cstrButtons : _tcsrchr(cstrButtons, L',');

        if (pch && i != 1)  // Skip the comma
            pch++;

        if (_pmbt->cButtons >= i && pch)
        {
            SetDlgItemText(hwnd, IDD_BUTTON1+i-1, pch);

            if (i > 1)
                *(pch-1) = L'\0';
        }
        else
        {
            ShowWindow(GetDlgItem(hwnd, IDD_BUTTON1+i-1), SW_HIDE);
        }
    }

    if (_pmbt->lTimeout == 0)
    {
        ShowWindow(GetDlgItem(hwnd, IDD_TIMEMSG), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDD_TIME), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDD_CANCELCOUNT), SW_HIDE);
    }
    else
    {
        TCHAR achBuf[30];

        if (!_pmbt->fCanCancel)
            EnableWindow(GetDlgItem(hwnd, IDD_CANCELCOUNT), FALSE);

        _lSecondsTilCancel    = _pmbt->lTimeout * 60;
        _lSecondsTilNextEvent = _pmbt->lEventInterval * 60;

        wsprintf(achBuf, L"%01d:%02d", _lSecondsTilCancel / 60,
                                       _lSecondsTilCancel % 60);

        SetDlgItemText(hwnd, IDD_TIME, achBuf);

        // Setup a 1 second timer
        SetTimer(hwnd, 1, 1000, NULL);
    }
}

void
CMessageBoxTimeout::OnCommand(USHORT id, USHORT wNotify)
{
    switch (id)
    {
    case IDD_BUTTON1:
    case IDD_BUTTON2:
    case IDD_BUTTON3:
    case IDD_BUTTON4:
    case IDD_BUTTON5:
        if (_pmbt->fConfirm)
        {
            TCHAR achBuf[100];
            TCHAR achText[100];

            GetDlgItemText(_hwnd, id, achText, 100);

            wsprintf(achBuf,
                     L"Click OK to confirm your choice of '%s'",
                     achText);

            if (MessageBox(_hwnd,
                           achBuf,
                           L"Gauntlet",
                           MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
            {
                break;
            }
        }
        KillTimer(_hwnd, 1);
        EndDialog(_hwnd, id-IDD_BUTTON1+MBTS_BUTTON1);
        break;

    case IDD_CANCELCOUNT:
        KillTimer(_hwnd, 1);
        SetDlgItemText(_hwnd, IDD_TIME, L"");
        SetDlgItemText(_hwnd, IDD_TIMEMSG, L"The countdown has been canceled.");
        EnableWindow(GetDlgItem(_hwnd, IDD_CANCELCOUNT), FALSE);
        break;
    }
}

void
CMessageBoxTimeout::OnTimer()
{
    TCHAR achBuf[30];

    _lSecondsTilCancel--;
    _lSecondsTilNextEvent--;

    wsprintf(achBuf, L"%01d:%02d", _lSecondsTilCancel / 60,
                                   _lSecondsTilCancel % 60);

    SetDlgItemText(_hwnd, IDD_TIME, achBuf);

    if (_lSecondsTilCancel <= 0)
    {
        KillTimer(_hwnd, 1);

        EndDialog(_hwnd, MBTS_TIMEOUT);

        return;
    }

    if (_lSecondsTilNextEvent <= 0 && _pmbt->lEventInterval != 0)
    {
        _pmbt->mbts = MBTS_INTERVAL;

        SetEvent(_pmbt->hEvent);

        _lSecondsTilNextEvent = _pmbt->lEventInterval * 60;

        // If we're minimized, unminimize to remind that we're still there.
        ShowWindow(_hwnd, SW_SHOWNORMAL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mrc\mrc.c ===
/*
 *		mrc.c
 *
 *		Makes RCDATA, #defines, and a table of keywords from a set of of tokens
 *		given as input.
 *
 *		Usage:
 *			mrc <tokens> <header> <resource> <C table>
 *
 *		<tokens> is the filename of the tokens file (.TOK) which lists out the
 *		tokens and optionally, lines to put in the other files. The internal
 *		format of the file is:
 *
 *		goal:		( <BOL> sections <EOL> )*
 *		sections:	comment | seed | token | imbed
 *		comment:	'#' <text>
 *		seed:		'TOKENS' short_int
 *		token:		C_string value <text>*
 *		value:		token_symbol | short_int | C_char_constant
 *		imbed:		'IMBED_IN' dest <EOL> imbed_text <BOL> 'END_IMBED'
 *		dest:		'.H' | '.RC' | '.C'
 *		imbed_text:	( <BOL> <text>* <EOL> )*
 *		<BOL>:		Beginning of line
 *		<EOL>:		End of line
 *
 *		The seed, lets you specify the seed value for the values to be assigned
 *		to each new token_symbol that is found. As a new token_symbol is found
 *		it is written out directly to the .H file as a #define line.
 *
 *		The imbedded text is written out the the corresponding .H, .RC, or .C
 *		file. This makes it possible to maintain just one source file for all
 *		the generated files. As each imbed is encountered, it is written out
 *		to the appropriate file.
 *
 *		When the end of the token file is reached, the set of tokens are sorted
 *		by their corresponding string and then written out to the C file and RC
 *		file.
 *
 *		<header> is the filename of the header file (.H) which will hold
 *		generated #defines which correspond to token_symbols and their assigned
 *		values.
 *
 *		<resource> is the filename of the resource file (.RC) which will hold
 *		a relocatable binary image of the the token lookup table in a RCDATA
 *		field. After any imbedded text, it will be written out as:
 *
 *		KEYWORDS RCDATA
 *		BEGIN
 *			<binary image of a C long>, <binary image of a C short>, // 1
 *				:
 *			<binary image of a C long>, <binary image of a C short>, // n
 *			<binary image of a long 0>, <binary image of a short 0>,
 *			<null terminated string>,								 // 1
 *				:
 *			<null terminated string>								 // n
 *		END
 *
 *		The C shorts hold the token values. The longs hold offsets from the
 *		beginning of the image, to the string for that token value. The long 0
 *		and short 0 denote the end of the look up table and allows the code
 *		that loads the image to find out how many entries there are in the
 *		table.
 *		
 *		<C table> is the filename of the C file (.C) which will hold the
 *		declaration a token lookup table. After any imbedded text, it will be
 *		written out as:
 *
 *		static KEYWORD rgKeyword[] =
 *		{
 *			{ <C_string>, <token_value> },							// 1
 *				:
 *			{ <C_string>, <token_value> },							// n
 *			{ NULL, 0 }
 *		};
 *
 *		Owner: Anthony Xavier V. Francisco
 *
 *		CAVEAT: If the KEYWORD structure in _rtfpars.h is changed, this program
 *				will be utterly useless and will have to updated accordingly.
 */
#include <windows.h>
// #include <ourtypes.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>

enum
{
	eTOK,
	eH,
	eRC,
	eC
};

typedef SHORT	TOKEN;

typedef	struct	_keyword
{
	CHAR	*szKeyword;
	TOKEN	token;
} KEYWORD;

FILE *	file[4];								// Streams for input and output
CHAR *	szOpenMode[] = { "r", "w", "w", "w" };	// Stream opening modes
TOKEN	sNextToken = 0;							// Value for next token

// Table of token strings and their values
KEYWORD	rgToken[256];
INT		cToken = 0;

// Table of strings and their token values
KEYWORD	rgKeyword[256];
INT		cKeyword = 0;

// Buffer and pointer used to support MyMalloc()
CHAR	rgchBuffer[4096];
CHAR *	pchAvail = rgchBuffer;

// A scratch pad string used to store temporary C constant string versions of
// a C string.
CHAR szScratch[128];

/*
 *		Error
 *
 *		Purpose:
 *			Print out error messages to stderr with free formatting capabilites
 *
 *		Arguments:
 *			szFmt				printf format string
 *			...					parameter corresponding to format string
 *
 *		Returns:
 *			None.
 */
void __cdecl Error( char * szFmt, ... )
{
	va_list	marker;

	va_start( marker, szFmt );
	vfprintf( stderr, szFmt, marker );
	va_end(marker);

	exit(-1);
}


/*
 *		TrimCRLF
 *
 *		Purpose:
 *			Take away the trailing '\n' and '\r' from a string
 *
 *		Arguments:
 *			sz					string to be trimmed
 *
 *		Returns:
 *			None.
 */
void TrimCRLF( CHAR * sz )
{
	INT		nLen = strlen(sz);
	CHAR *	pch = &sz[ nLen - 1 ];

	while ( nLen && *pch == '\n' || *pch == '\r' )
	{
		*pch-- = '\0';
		--nLen;
	}
}


/*
 *		NSzACmp
 *
 *		Purpose:
 *			Compares two ASCII strings based on ASCII values
 *
 *		Arguments:
 *			szA1	Strings to be compared
 *			szA2
 *
 *		Returns:
 *			< 0		szA1 < szA2
 *			0		szA1 = szA2
 *			> 0		szA1 > szA2
 */
INT NSzACmp( CHAR * szA1, CHAR * szA2 )
{
	while ( *szA1 && ( *szA1 == *szA2 ) )
	{
		++szA1;
		++szA2;
	}
	return *szA1 - *szA2;
}


/*
 *		PchGetNextWord
 *
 *		Purpose:
 *			Collects the group of characters delimitted by whitespace in a
 *			string.
 *
 *		Arguments:
 *			szLine			Pointer to the string where to look for a word
 *			szString		Where to put the word
 *
 *		Returns:
 *			Pointer to the character delimiting the end of the word found. If
 *			none is found, szString will have a length of zero.
 *
 */
CHAR * PchGetNextWord( CHAR * szLine, CHAR *szString )
{
	while ( *szLine && isspace(*szLine) )
		szLine++;

	while ( *szLine && !isspace(*szLine) )
		*szString++ = *szLine++;

	*szString = '\0';

	return szLine;
}


/*
 *		HandleImbed
 *
 *		Purpose:
 *			Takes care of copying lines to be imbedded into a generated file
 *
 *		Arguments:
 *			sz				String containing the destination for the imbedded
 *							lines.
 *
 *		Returns:
 *			None.
 */
void HandleImbed( CHAR * sz )
{
	CHAR	szLine[128];
	CHAR	szString[128];
	FILE *	fileDest;

	if ( !NSzACmp( sz, ".H" ) )
		fileDest = file[eH];
	else if ( !NSzACmp( sz, ".RC" ) )
		fileDest = file[eRC];
	else if ( !NSzACmp( sz, ".C" ) )
		fileDest = file[eC];
	else
		Error( "Can't imbed into %s\n", sz );

	while ( fgets( szLine, sizeof(szLine), file[eTOK] ) )
	{
		TrimCRLF(szLine);

		PchGetNextWord( szLine, szString );
		if ( !NSzACmp( szString, "END_IMBED" ) )
			break;
		fprintf( fileDest, "%s\n", szLine );
	}
}


/*
 *		TranslateQuoted
 *
 *		Purpose:
 *			Takes as C string constant declaration and makes it into a C string
 *			with out the escape characters.
 *
 *		Arguments:
 *			szDest				C string constant declaration to converted
 *
 *		Returns:
 *			None.
 */
void TranslateQuoted( CHAR * szDest )
{
	CHAR	szSrc[128];
	CHAR *	pch = &szSrc[1];

	// Go through the string until the end of string or matching quote
	strcpy( szSrc, szDest );
	while ( *pch && *pch != szSrc[0] )
	{
		switch (*pch)
		{
		case '\\':
			++pch;
			switch(*pch)
			{
			case '\\':
				*szDest++ = '\\';
				break;

			case 'n':
				*szDest++ = '\n';
				break;

			case 'r':
				*szDest++ = '\r';
				break;

			case 't':
				*szDest++ = '\t';
				break;

			default:
				*szDest++ = *pch;
				break;
			}
			break;

		default:
			*szDest++ = *pch;
			break;
		}
		pch++;
	}
	*szDest = '\0';
}


/*
 *		CompareKeywords
 *
 *		Purpose:
 *			Compares to KEYWORD structures to see if their keyword strings
 *			match.
 *
 *		Arguments:
 *			pv1					Pointer to a keyword structure
 *			pv2					Pointer to another keyword structure
 *
 *		Returns:
 *			0	strings are the same
 *			< 0	pv1's string is less than pv2's string
 *			> 0	pv1's string is greater than pv2's string
 */
int __cdecl CompareKeywords( void const * pv1, void const * pv2 )
{
	KEYWORD *	pk1 = ( KEYWORD * ) pv1;
	KEYWORD *	pk2 = ( KEYWORD * ) pv2;

	return NSzACmp( pk1->szKeyword, pk2->szKeyword );
}


/*
 *		MyMalloc
 *
 *		Purpose:
 *			Simulates malloc() by using a staticly allocated buffer.
 *
 *		Arguments:
 *			cb					Number of bytes to allocate
 *
 *		Returns:
 *			Pointer to a set of allocated bytes.
 */
CHAR * MyMalloc( INT cb )
{
	CHAR *	pch;

	pch = pchAvail;
	pchAvail += cb;
	if ( pchAvail - rgchBuffer > sizeof(rgchBuffer) )
		Error( "Not enough memory to satisfy %d byte request\n", cb );
	return pch;
}


/*
 *		AddKeyword
 *
 *		Purpose:
 *			Stores a keyword string and it's corresponding value into a
 *			KEYWORD structure. Space for the string is allocated.
 *
 *		Arguments:
 *			pkeyword			Pointer to a keyword structure
 *			szKeyword			The string to be stored.
 *			token				The token value for this string
 *
 *		Returns:
 *			None.
 */
void AddKeyword( KEYWORD * pk, CHAR * szKeyword, TOKEN token )
{
	pk->token = token;
	pk->szKeyword = ( CHAR * ) MyMalloc( strlen(szKeyword) + 1 );
	if ( pk->szKeyword == NULL )
		Error( "Not enough memory to store %s\n", szKeyword );
	strcpy( pk->szKeyword, szKeyword );
}


/*
 *		TokenLookup
 *
 *		Purpose:
 *			Lookup a token symbol in the rgToken table and return the value
 *			of the token for it. If the token symbol can't be found, add it
 *			to the table and assign the next available token value.
 *
 *		Arguments:
 *			sz				The symbol to lookup
 *
 *		Returns:
 *			The token value for the symbol.
 */
TOKEN TokenLookup( CHAR * sz )
{
	KEYWORD *	pk = rgToken;

	while ( pk->szKeyword && NSzACmp( pk->szKeyword, sz ) )
		pk++;

	if ( pk->szKeyword == NULL )
	{
		pk = &rgToken[cToken++];
		AddKeyword( pk, sz, sNextToken++ );
		fprintf( file[eH], "#define %s\t%d\n", sz, pk->token );
	}

	return pk->token;
}


/*
 *		MakeByte
 *
 *		Purpose:
 *			Write out the representation of a byte for an RCDATA statement into
 *			the RC file.
 *
 *		Arguments:
 *			b					The byte value to be written out.
 *
 *		Returns:
 *			None.
 */
void MakeByte( BYTE b )
{
	fprintf( file[eRC], "\"\\%03o\"", b );
}


/*
 *		MakeShort
 *
 *		Purpose:
 *			Write out the binary image of a short as a RCDATA statement into
 *			the RC file.
 *
 *		Arguments:
 *			s					The short value to be written out.
 *
 *		Returns:
 *			None.
 */
void MakeShort( SHORT s )
{
	BYTE *	pb = ( BYTE * ) &s;
	INT i;

	for ( i = 0; i < sizeof(SHORT); i++ )
	{
		MakeByte(*pb++);
		if ( i + 1 < sizeof(SHORT) )
			fprintf( file[eRC], ", " );
	}
}


/*
 *		MakeLong
 *
 *		Purpose:
 *			Write out the binary image of a long as a RCDATA statement into
 *			the RC file.
 *
 *		Arguments:
 *			l					The long value to be written out.
 *
 *		Returns:
 *			None.
 */
void MakeLong( LONG l )
{
	BYTE *	pb = ( BYTE * ) &l;
	INT i;

	for ( i = 0; i < sizeof(LONG); i++ )
	{
		MakeByte(*pb++);
		if ( i + 1 < sizeof(LONG) )
			fprintf( file[eRC], ", " );
	}
}


/*
 *		SzMakeQuoted
 *
 *		Purpose:
 *			Create the C constant string declaration version of a string and
 *			return a pointer to it.
 *			The created string is kept in a scratchpad which will be
 *			overwritten each time this function is called.
 *
 *		Arguments:
 *			sz				String to make a C constant string version of
 *
 *		Returns:
 *			Pointer to a scratchpad containing C constant string version of
 *			sz
 */
CHAR * SzMakeQuoted( CHAR * sz )
{
	CHAR *	pch = szScratch;

	*pch++ = '"';
	while (*sz)
	{
		switch (*sz)
		{
		case '\n':
			*pch++ = '\\';
			*pch++ = 'n';
			break;

		case '\r':
			*pch++ = '\\';
			*pch++ = 'r';
			break;

		case '\t':
			*pch++ = '\\';
			*pch++ = 't';
			break;

		case '\\':
			*pch++ = '\\';
			*pch++ = '\\';
			break;

		case '"':
			*pch++ = '\\';
			*pch++ = '"';
			break;

		default:
			if (isprint(*sz))
				*pch++ = *sz;
			else
				Error( "Don't know how to deal with ASCII %d\n", *sz );
			break;
		}
		sz++;
	}
	*pch++ = '"';
	*pch = '\0';
	return szScratch;
}

/*
 *		GenerateTable
 *
 *		Purpose:
 *			Generates the C table and RCDATA tables
 *
 *		Arguments:
 *			None.
 *
 *		Returns:
 *			None.
 */
void GenerateTable(void)
{
	KEYWORD *	pk;
	INT			nOffset;

	// Sort the keywords
	qsort( rgKeyword, cKeyword, sizeof(KEYWORD), CompareKeywords );

	// Put the header for the C table
	fprintf( file[eC], "static KEYWORD rgKeyword[] =\n{\n" );

	// Put the header for the RCDATA
	fprintf( file[eRC], "TOKENS RCDATA\nBEGIN\n" );

	// Output our keyword table
	pk = rgKeyword;
	nOffset = sizeof(rgKeyword);
	while ( pk->szKeyword != NULL )
	{
		// Add the string and token to the C file
		fprintf( file[eC], "\t{ %s, %d },\n", SzMakeQuoted(pk->szKeyword),
																pk->token );

		// Add the table entry into the RC file
		MakeLong(nOffset);
		fprintf( file[eRC], ", " );
		MakeShort(pk->token);
		fprintf( file[eRC], ", /* %d, %d */\n", nOffset, pk->token );
		nOffset += strlen(pk->szKeyword) + 1;

		pk++;
	}

	// Put the NULL entry for the RCDATA
	MakeLong(0);
	fprintf( file[eRC], ", " );
	MakeShort(pk->token);
	fprintf( file[eRC], ", /* %d, %d */\n", 0, pk->token );

	// Put the NULL entry for the C table and end the table
	fprintf( file[eC], "\t{ NULL, 0 }\n};\n" );

	// Output our keyword strings
	pk = rgKeyword;
	while ( pk->szKeyword != NULL )
	{
		if ( isprint(*pk->szKeyword) )
			fprintf( file[eRC], "\"%s\\0\"", pk->szKeyword );
		else
		{
			MakeByte( *pk->szKeyword );
			fprintf( file[eRC], ", " );
			MakeByte(0);
		}
		pk++;
		if ( pk->szKeyword != NULL )
			fprintf( file[eRC],",");
		fprintf( file[eRC],"\n");
	}
	fprintf( file[eRC], "END\n\n" );
}


int __cdecl main( int argc, char * argv[] )
{
	INT		i;
	CHAR	szLine[128];
	CHAR	szString[128];
	CHAR	szToken[128];
	CHAR	*pchCurr;
	TOKEN	token;

	// Verify we have enough parameters
	if ( argc != 5 )
		Error( "usage: %s tokens.TOK header.H resource.RC table.C\n", argv[0] );

	// Blank out our buffers
	memset( rgToken, 0, sizeof(rgToken) );
	memset( rgKeyword, 0, sizeof(rgKeyword) );
	memset( rgchBuffer, 0, sizeof(rgchBuffer) );

	// Open the files
	for ( i = eTOK; i <= eC; i++ )
		if ( ( file[i] = fopen( argv[ i + 1 ], szOpenMode[i] ) ) == NULL )
		{
			perror( argv[ i + 1 ] );
			return -1;
		}

	// Go through every line in the tokens file
	while ( fgets( szLine, sizeof(szLine), file[eTOK] ) )
	{
		TrimCRLF(szLine);

		// Skip blank lines
		if ( strlen(szLine) == 0 )
			continue;

		// Skip comments
		if ( szLine[0] == '#' )
			continue;

		// Get the first word
		pchCurr = PchGetNextWord( szLine, szString );

		// Do we want to imbed some text someplace ?
		if ( !NSzACmp( szString, "IMBED_IN" ) )
		{
			PchGetNextWord( pchCurr, szString );
			HandleImbed(szString);
			continue;
		}

		// Do we want to reset the lowest token value ?
		if ( !NSzACmp( szString, "TOKENS" ) )
		{
			PchGetNextWord( pchCurr, szString );
			sNextToken = (TOKEN)atoi(szString);
			continue;
		}

		// Are we specifying a string on this line ?
		if ( szString[0] == '"' )
		{
			// Remove the quotes from the string
			TranslateQuoted(szString);

			// Get the next word to find out what token value should go with
			// this string
			PchGetNextWord( pchCurr, szToken );

			if ( szToken[0] == '\'' )
			{
				// We have a single character equivalent for this token.
				TranslateQuoted(szToken);
				token = *szToken;
			}
			else if ( isdigit(szToken[0]) )
				token = (TOKEN)atoi(szToken);
			else
				token = TokenLookup(szToken);

			// Add the token and string pair to our table
			AddKeyword( &rgKeyword[cKeyword++], szString, token );
		}
	}

	// Generate the RC data for the RC file
	GenerateTable();

	// Close the files
	for ( i = eTOK; i <= eC; i++ )
		fclose(file[i]);
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\exe\factory.cxx ===
#include "headers.hxx"

DeclareTag(tagFactory, "MTScript", "Monitor Class Factories");

HRESULT CreateConnectedMachine(CMTScript *pMT, IUnknown **ppUnk);
HRESULT CreateScriptedProcess(CMTScript *pMT, IUnknown **ppUnk);

REGCLASSDATA g_regData[] =
{
    {
        &CLSID_RemoteMTScript,
        CreateConnectedMachine,
        CLSCTX_SERVER,
        0
    },
    {
        &CLSID_LocalScriptedProcess,
        CreateScriptedProcess,
        CLSCTX_LOCAL_SERVER,
        0
    }
};

// ***************************************************************
//
//

HRESULT
RegisterClassObjects(CMTScript *pMT)
{
    HRESULT       hr = S_OK;
    REGCLASSDATA *prcd;
    int           i;
    CStdFactory  *pFact;

    TraceTag((tagFactory, "Registering Class Factories..."));

    for (i = 0, prcd = g_regData;
         i < ARRAY_SIZE(g_regData);
         i++, prcd++)
    {
        pFact = new CStdFactory(pMT, prcd->pfnCreate);

        if (!pFact)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = CoRegisterClassObject(*prcd->pclsid,
                                       pFact,
                                       prcd->ctxCreate,
                                       REGCLS_MULTIPLEUSE,
                                       &prcd->dwCookie);

            pFact->Release();
        }

        if (hr)
        {
            // BUGBUG -- how do we handle errors here?
            WCHAR achBuf[100];

            wsprintf(achBuf, L"CoRegisterClassObject failed with (%x)", hr);

            MessageBox(NULL, achBuf, L"MTScript", MB_OK | MB_SETFOREGROUND);

            break;
        }
    }

    return hr;
}

void
UnregisterClassObjects()
{
    REGCLASSDATA *prcd;
    int           i;

    TraceTag((tagFactory, "Unregistering Class Factories..."));

    for (i = 0, prcd = g_regData;
         i < ARRAY_SIZE(g_regData);
         i++, prcd++)
    {
        if (prcd->dwCookie != 0)
        {
            CoRevokeClassObject(prcd->dwCookie);
        }
    }
}

// ***************************************************************

CStdFactory::CStdFactory(CMTScript *pMT, FNCREATE *pfnCreate)
{
    _ulRefs    = 1;
    _pMT       = pMT;
    _pfnCreate = pfnCreate;
}

STDMETHODIMP
CStdFactory::QueryInterface(REFIID iid, void ** ppvObject)
{
    if (iid == IID_IClassFactory || iid == IID_IUnknown)
    {
        *ppvObject = (IClassFactory*)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObject)->AddRef();
    return S_OK;
}

STDMETHODIMP
CStdFactory::CreateInstance(IUnknown * pUnkOuter,
                            REFIID     riid,
                            void **    ppvObject)
{
    IUnknown *pUnk;
    HRESULT   hr = E_FAIL;

    *ppvObject = NULL;

    TraceTag((tagFactory, "%p: CreateInstance called...", this));

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }

    hr = (*_pfnCreate)(_pMT, &pUnk);

    if (!hr)
    {
        hr = pUnk->QueryInterface(riid, ppvObject);
    }

    pUnk->Release();

    if (hr)
    {
        // BUGBUG -- Fix this

        WCHAR achBuf[100];

        wsprintf(achBuf, L"CreateInstance failed with (%x)", hr);

        MessageBox(NULL, achBuf, L"MTScript", MB_OK | MB_SETFOREGROUND);
    }

    return hr;
}

STDMETHODIMP
CStdFactory::LockServer(BOOL fLock)
{
    // BUGBUG -- Increment a count on the CMTScript object and don't go
    // away if it's not zero.

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateConnectedMachine
//
//  Synopsis:   Creates the object which implements IConnectedMachine
//
//  Arguments:  [pMT]   -- Pointer to CMTScript object
//              [ppUnk] -- Created object is returned here
//
//  Notes:      This function creates only one object and returns it for
//              all CreateInstance calls. There is no per-connection state
//              so it is unnecessary to create a separate object for each
//              connection.
//
//----------------------------------------------------------------------------

HRESULT
CreateConnectedMachine(CMTScript *pMT, IUnknown **ppUnk)
{
    HRESULT   hr = S_OK;
    CMachine *pMach;

    TraceTag((tagFactory, "Creating a CMachine object"));

    pMT->PostToThread(pMT, MD_MACHINECONNECT);

    LOCK_LOCALS(pMT);

    if (!pMT->_pMachine)
    {
        TraceTag((tagFactory, "Creating a CMachine object"));

        pMach = new CMachine(pMT, pMT->_pTIMachine);

        if (!pMach)
        {
            return E_OUTOFMEMORY;
        }

        hr = pMach->StartThread(NULL);
        if (FAILED(hr))
        {
            return hr;
        }

        pMT->_pMachine = pMach;
    }
    else
    {
        TraceTag((tagFactory, "Connecting to the existing CMachine object"));

        pMach = pMT->_pMachine;
    }

    // We are in the free-threaded apartment so we don't have to marshal this.
    return pMach->QueryInterface(IID_IUnknown, (LPVOID*)ppUnk);
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateScriptedProcess
//
//  Synopsis:   Creates the object which implement IScriptedProcess
//
//  Arguments:  [pMT]   -- Pointer to CMTScript object
//              [ppUnk] -- Created object is returned here
//
//  Notes:      Creates a new object for each connection.
//
//----------------------------------------------------------------------------

HRESULT
CreateScriptedProcess(CMTScript *pMT, IUnknown **ppUnk)
{
    HRESULT       hr = S_OK;
    CProcessComm *pPC;

    TraceTag((tagFactory, "Creating a CProcessComm object"));

    LOCK_LOCALS(pMT);

    pPC = new CProcessComm(pMT);

    if (!pPC)
    {
        return E_OUTOFMEMORY;
    }

    hr = pPC->QueryInterface(IID_IUnknown, (LPVOID*)ppUnk);

    pPC->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\common.inc ===
CHECKED_ALT_DIR=1

MSC_WARNING_LEVEL = /W4 /WX

C_DEFINES = $(C_DEFINES) \
    /D_WCTYPE_INLINE_DEFINED \
    /DSTRICT \
    /DUNICODE \
    /D_UNICODE \
    /DOLEDBVER=0x0200 \
    /DWIN32

!ifdef MTSCRIPT_DROP
C_DEFINES=$(C_DEFINES) /DMTSCRIPT_DROP /DMTSCRIPT_BUILDNUMBER=$(MTSCRIPT_BUILDNUMBER) /DMTSCRIPT_QFENUMBER=$(MTSCRIPT_QFENUMBER)
!endif

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
LINKER_NOICF=1      # ICF is s-l-o-w
USE_DEBUGLIB=1
!if $(386)
USE_STACK_SPEW=1
!endif
!else
MSC_OPTIMIZATION=/Oxs
!endif


USE_MSVCRT=1

# Use Win2000 functionality

WIN32_IE_VERSION=0x0500
WIN32_WINNT_VERSION=0x0500
WIN32_WIN95_VERSION=0x0500
SUBSYSTEM_VERSION=5.00

INCLUDES=

CONDITIONAL_INCLUDES= \
    winwlm.h \
    rpcerr.h \
    rpcmac.h \
    macname1.h \
    macpub.h \
    macapi.h \
    macname2.h \
    macocidl.h \
    mainwin.h \
    w16toff.hxx \
    print.h \
    regmsg16.h \
    urlmki.h \
    help.h \
    pgstup16.hxx \
    page.h \
    icapexp.h \
    stdole2.tlb \
    mshtml.tlb

!ifdef BOUNDSCHECKER
BOUNDSCHECKER=1
NO_PRECOMPILED_HEADERS=1
SUBSTITUTE_386_CC=nmcl
LINK_NAME=nmlink
BCHECK_LIBS=c:\progra~1\numega\boundschecker\bcinterf.lib
!else
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi
BCHECK_LIBS=
!endif

!ifdef PREFIX
NO_PRECOMPILED_HEADERS=1
SUBSTITUTE_386_CC=prefix.exe
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\exe\makefile.inc ===
$(O)\selfreg_mtscript.inf : selfreg.inx
    cleaninf.exe -w selfreg.inx $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\exe\machine.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       machine.cxx
//
//  Contents:   Implementation of the CMachine class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

DeclareTag(tagMachine, "MTScript", "Monitor IConnectedMachine");

// ***********************************************************************
//
// CMachConnectPoint
//
// ***********************************************************************

CMachConnectPoint::CMachConnectPoint(CMachine *pMach)
{
    _ulRefs = 1;
    _pMachine = pMach;
    _pMachine->AddRef();
}

CMachConnectPoint::~CMachConnectPoint()
{
    _pMachine->Release();
}

HRESULT
CMachConnectPoint::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CMachConnectPoint::GetConnectionInterface(IID * pIID)
{
    *pIID = DIID_DRemoteMTScriptEvents;
    return S_OK;
}

HRESULT
CMachConnectPoint::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    *ppCPC = _pMachine;
    (*ppCPC)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachConnectPoint::Advise, public
//
//  Synopsis:   Remembers interface pointers that we want to fire events
//              through.
//
//  Arguments:  [pUnkSink]  -- Pointer to remember
//              [pdwCookie] -- Place to put cookie for Unadvise
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMachConnectPoint::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    IDispatch *pDisp;
    HRESULT    hr;

    TraceTag((tagMachine, "Advising new machine sink: %p", pUnkSink));

    hr = pUnkSink->QueryInterface(IID_IDispatch, (LPVOID*)&pDisp);
    if (hr)
    {
        TraceTag((tagMachine, "Could not get IDispatch pointer on sink! (%x)", hr));
        return hr;
    }

    CMachine::LOCK_MACH_LOCALS(_pMachine);

    hr = _pMachine->_aryDispSink.Append(pDisp);
    if (hr)
    {
        TraceTag((tagMachine, "Error appending sink to array!"));
        RRETURN(hr);
    }

    *pdwCookie = (DWORD)pDisp;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachConnectPoint::Unadvise, public
//
//  Synopsis:   Forgets a pointer we remembered during Advise.
//
//  Arguments:  [dwCookie] -- Cookie returned from Advise
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMachConnectPoint::Unadvise(DWORD dwCookie)
{
    int i;

    TraceTag((tagMachine, "Unadvising machine sink: %p", dwCookie));

    CMachine::LOCK_MACH_LOCALS(_pMachine);

    i = _pMachine->_aryDispSink.Find((IDispatch*)dwCookie);

    if (i != -1)
    {
        _pMachine->_aryDispSink.ReleaseAndDelete(i);
    }
    else
        return E_INVALIDARG;

    return S_OK;
}

HRESULT
CMachConnectPoint::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    *ppEnum = NULL;
    RRETURN(E_NOTIMPL);
}

// ***********************************************************************
//
// CMachine
//
// ***********************************************************************

CMachine::CMachine(CMTScript *pMT, ITypeInfo *pTIMachine)
{
    _ulRefs = 1;
    _pMT    = pMT;

    TraceTag((tagMachine, "%p: CMachine object being constructed", this));

    Assert(pTIMachine);

    _pTypeInfoIMachine = pTIMachine;

    _pTypeInfoIMachine->AddRef();

    InitializeCriticalSection(&_cs);
}

CMachine::~CMachine()
{
    ReleaseInterface(_pTypeInfoIMachine);

    DeleteCriticalSection(&_cs);
}

HRESULT
CMachine::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IConnectedMachine || iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppvObj = (IConnectedMachine *)this;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *ppvObj = (IConnectionPointContainer *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachine::Init, public
//
//  Synopsis:   Used to do initialization that may fail
//
//----------------------------------------------------------------------------

BOOL
CMachine::Init()
{
    return CThreadComm::Init();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachine::ThreadMain, public
//
//  Synopsis:   Main loop for this thread. Handles messages coming from other
//              threads.
//
//----------------------------------------------------------------------------

DWORD
CMachine::ThreadMain()
{
    DWORD dwRet;
    BOOL  fExit = FALSE;

    SetName("CMachine");

    ThreadStarted(S_OK);

    TraceTag((tagMachine, "CMachine thread started"));

    while (!fExit)
    {
        dwRet = WaitForSingleObject(_hCommEvent, INFINITE);

        if (dwRet == WAIT_OBJECT_0)
        {
            fExit = HandleThreadMessage();
        }
        else
        {
            AssertSz(FALSE, "FATAL: WaitForSingleObject failed!");
            fExit = TRUE;
        }
    }

    TraceTag((tagMachine, "CMachine thread exiting"));

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachine::HandleThreadMessage, public
//
//  Synopsis:   Handles messages from other threads.
//
//----------------------------------------------------------------------------

BOOL
CMachine::HandleThreadMessage()
{
    VERIFY_THREAD();

    THREADMSG tm;
    BYTE      bData[MSGDATABUFSIZE];
    DWORD     cbData;
    BOOL      fRet = FALSE;

    while (GetNextMsg(&tm, (void *)bData, &cbData))
    {
        switch (tm)
        {
        case MD_NOTIFYSCRIPT:
            {
                VARIANT *pvar = *(VARIANT**)bData;

                Assert(V_VT(&pvar[0]) == VT_BSTR);

                FireScriptNotify(V_BSTR(&pvar[0]), pvar[1]);

                VariantClear(&pvar[0]);
                VariantClear(&pvar[1]);

                delete [] pvar;
            }
            break;

        case MD_PLEASEEXIT:
            fRet = TRUE;
            break;

        default:
            AssertSz(FALSE, "CMachine got a message it couldn't handle!");
            break;
        }
    }

    return fRet;
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::EnumConnectionPoints, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CMachine::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::FindConnectionPoint, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CMachine::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT* ppCpOut)
{
    HRESULT hr;

    if (iid == DIID_DRemoteMTScriptEvents || iid == IID_IDispatch)
    {
        *ppCpOut = new CMachConnectPoint(this);
        hr = *ppCpOut ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMachine::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    *pptinfo = _pTypeInfoIMachine;
    (*pptinfo)->AddRef();

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMachine::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMachine::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    return _pTypeInfoIMachine->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMachine::Invoke(DISPID dispidMember,
                 REFIID riid,
                 LCID lcid,
                 WORD wFlags,
                 DISPPARAMS * pdispparams,
                 VARIANT * pvarResult,
                 EXCEPINFO * pexcepinfo,
                 UINT * puArgErr)
{
    return _pTypeInfoIMachine->Invoke((IConnectedMachine *)this, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

// *************************************************************************

//+---------------------------------------------------------------------------
//
//  Member:     CMachine::FireScriptNotify, public
//
//  Synopsis:   Fires the script notify event on all objects connected to
//              our IConnectedMachine object that have requested to receive
//              events (through IConnectionPoint::Advise).
//
//  Arguments:  [bstrIdent] -- Parameter of event
//              [vInfo]     -- Parameter of event
//
//  Returns:    HRESULT
//
//  Notes:      This method is thread-safe and can be called from any thread.
//
//----------------------------------------------------------------------------

HRESULT
CMachine::FireScriptNotify(BSTR bstrIdent, VARIANT vInfo)
{
    HRESULT     hr;
    IDispatch **ppDisp;
    int         i;
    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr = 0;
    VARIANT     varg[2];

    CStackPtrAry<IDispatch*, 5> arySinks;

    // Since it may take some time to fire the events, and we don't want
    // to keep the array locked that whole time, we make a copy of the array.
    // This will also allow a sink to unadvise itself while handling the event
    // without deadlocking.

    {
        LOCK_MACH_LOCALS(this);

        // Check for no sinks. No use going to all this work if there's no one
        // listening.

        if (_aryDispSink.Size() == 0)
            return S_OK;

        hr = arySinks.Copy(_aryDispSink, TRUE);
        if (hr)
            RRETURN(hr);
    }

    // Set up the event parameters

    VariantInit(&varg[0]);
    VariantInit(&varg[1]);

    // Params are in order from last to first
    hr = VariantCopy(&varg[0], &vInfo);
    if (hr)
        return hr;

    V_VT(&varg[1]) = VT_BSTR;
    V_BSTR(&varg[1]) = bstrIdent;

    dp.rgvarg            = varg;
    dp.cArgs             = 2;
    dp.rgdispidNamedArgs = NULL;
    dp.cNamedArgs        = 0;

    // We don't use the same critical section here so _aryDispSink can be
    // manipulated while we're firing events. However, we still don't want
    // more than one thread firing events at the same time.

    TraceTag((tagMachine, "About to fire OnScriptNotify(%ls) on %d sinks...", bstrIdent, arySinks.Size()));

    for (i = arySinks.Size(), ppDisp = arySinks;
         i > 0;
         i--, ppDisp++)
    {
        hr = (*ppDisp)->Invoke(
                           DISPID_RemoteMTScript_OnScriptNotify,
                           IID_NULL,
                           0,
                           DISPATCH_METHOD,
                           &dp,
                           NULL,
                           &ei,
                           &uArgErr);
        if (hr)
        {
            // If the call failed, unadvise so we don't keep trying.

            TraceTag((tagError, "OnScriptNotify event call returned %x! Unadvising...", hr));

            // If the connection went down temporarily, don't unadvise.

            if (hr != HRESULT_FROM_WIN32(RPC_X_BAD_STUB_DATA) &&
                hr != HRESULT_FROM_WIN32(RPC_S_COMM_FAILURE))
            {
                LOCK_MACH_LOCALS(this);

                int index = _aryDispSink.Find(*ppDisp);

                Assert(index != -1);

                _aryDispSink.ReleaseAndDelete(index);
            }
        }
    }

    TraceTag((tagMachine, "Done firing OnScriptNotify(%ls).", bstrIdent));

    return S_OK;
}

// *************************************************************************

STDMETHODIMP
CMachine::Exec(BSTR bstrCmd, BSTR bstrParams, VARIANT *pvData)
{
    // We create an event object for each call on this method. While this
    // may have a cost, it makes this method thread-safe. If we cached an
    // event object then we would have to synchronize access to that event
    // object which could be even more expensive.
    MACHPROC_EVENT_DATA   med;
    MACHPROC_EVENT_DATA * pmed;
    HRESULT           hr = S_OK;

    if (!pvData)
    {
        return E_INVALIDARG;
    }

    TraceTag((tagMachine, "Exec call received: (%ls, %ls)", bstrCmd, bstrParams));

    VariantInit(pvData);

    med.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (med.hEvent == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    med.bstrCmd     = bstrCmd;
    med.bstrParams  = bstrParams;
    med.dwProcId    = 0;
    med.pvReturn    = pvData;
    med.dwGITCookie = 0;
    med.hrReturn    = S_OK;

    pmed = &med;

    HANDLE ahEvents[2];
    ahEvents[0] = med.hEvent;

    CScriptHost *pScript = _pMT->GetPrimaryScript();
    if (!pScript)
    {
        med.hrReturn = E_FAIL;
        goto Cleanup;
    }
    ahEvents[1] = pScript->hThread();
    _pMT->PostToThread(pScript,
                       MD_MACHEVENTCALL,
                       (LPVOID)&pmed,
                       sizeof(MACHPROC_EVENT_DATA*));

    // We can do WaitForSingleObject because we are in OLE's multi-threaded
    // apartment and don't need to handle messages from our event loop.
    DWORD dwWait;
    dwWait = WaitForMultipleObjects(2, ahEvents, FALSE, INFINITE);

    if (dwWait != WAIT_OBJECT_0) // Thread exit
    {
        med.hrReturn = E_FAIL;
        goto Cleanup;
    }
    if (med.hrReturn != S_OK)
    {
        hr = med.hrReturn;
        goto Cleanup;
    }

    // See if the return value was an IDispatch ptr. If so, grab the pointer
    // out of the GlobalInterfaceTable.
    if (V_VT(pvData) == VT_DISPATCH)
    {
        IDispatch *pDisp;

        AssertSz(med.dwGITCookie != 0, "FATAL: Itf pointer improperly marshalled");

        hr = _pMT->_pGIT->GetInterfaceFromGlobal(med.dwGITCookie,
                                                 IID_IDispatch,
                                                 (LPVOID*)&pDisp);
        if (!hr)
        {
            V_VT(pvData)       = VT_DISPATCH;
            V_DISPATCH(pvData) = pDisp;
        }

        _pMT->_pGIT->RevokeInterfaceFromGlobal(med.dwGITCookie);
    }

Cleanup:
    CloseHandle(med.hEvent);

    TraceTag((tagMachine, "Exec call returning %x", hr));

    return hr;
}


STDMETHODIMP
CMachine::get_PublicData(VARIANT *pvData)
{
    HRESULT hr = S_OK;

    VariantInit(pvData);

    TraceTag((tagMachine, "Remote machine asking for PublicData"));

    LOCK_LOCALS(_pMT);

    if (V_VT(&_pMT->_vPublicData) == VT_DISPATCH)
    {
        IDispatch *pDisp;

        Assert(_pMT->_dwPublicDataCookie != 0);

        hr = _pMT->_pGIT->GetInterfaceFromGlobal(_pMT->_dwPublicDataCookie,
                                                 IID_IDispatch,
                                                 (LPVOID*)&pDisp);
        if (!hr)
        {
            V_VT(pvData)       = VT_DISPATCH;
            V_DISPATCH(pvData) = pDisp;
        }
    }
    else
    {
        hr = VariantCopy(pvData, &_pMT->_vPublicData);
    }

    return hr;
}

STDMETHODIMP
CMachine::get_Name(BSTR *pbstrName)
{
    TCHAR achBuf[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwLength = ARRAY_SIZE(achBuf);

    GetComputerName(achBuf, &dwLength);

    *pbstrName = SysAllocString(achBuf);

    return (pbstrName) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP
CMachine::get_Platform(BSTR *pbstrPlatform)
{
    SYSTEM_INFO si;

    GetSystemInfo(&si);

    TCHAR *pchPlatform;

    if (!pbstrPlatform)
        return E_POINTER;

    switch (si.wProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        pchPlatform = L"x86";
        break;

    case PROCESSOR_ARCHITECTURE_AMD64:
        pchPlatform = L"amd64";
        break;

    case PROCESSOR_ARCHITECTURE_IA64:
        pchPlatform = L"ia64";
        break;

    case PROCESSOR_ARCHITECTURE_UNKNOWN:
    default:
        pchPlatform = L"unknown";
        break;
    }

    *pbstrPlatform = SysAllocString(pchPlatform);
    if (!*pbstrPlatform)
        return E_OUTOFMEMORY;

    return S_OK;
}

STDMETHODIMP
CMachine::get_OS(BSTR *pbstrOS)
{
    OSVERSIONINFO os;
    WCHAR *       pchOS = L"Unknown";

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!pbstrOS)
        return E_POINTER;

    GetVersionEx(&os);

    switch (os.dwPlatformId)
    {
    case VER_PLATFORM_WIN32_WINDOWS:
        if (   os.dwMajorVersion > 4
            || (   os.dwMajorVersion == 4
                && os.dwMinorVersion > 0))
        {
            pchOS = L"Win98";
        }
        else
        {
            pchOS = L"Win95";
        }
        break;

    case VER_PLATFORM_WIN32_NT:
        if (os.dwMajorVersion == 4)
        {
            pchOS = L"NT4";
        }
        else
        {
            pchOS = L"Win2000";
        }
        break;
    }

    *pbstrOS = SysAllocString(pchOS);
    if (!*pbstrOS)
        return E_OUTOFMEMORY;

    return S_OK;
}

STDMETHODIMP
CMachine::get_MajorVer(long *plMajorVer)
{
    if (!plMajorVer)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *plMajorVer = os.dwMajorVersion;

    return S_OK;
}

STDMETHODIMP
CMachine::get_MinorVer(long *plMinorVer)
{
    if (!plMinorVer)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *plMinorVer = os.dwMinorVersion;

    return S_OK;
}

STDMETHODIMP
CMachine::get_BuildNum(long *plBuildNum)
{
    if (!plBuildNum)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *plBuildNum = os.dwBuildNumber;

    return S_OK;
}

STDMETHODIMP
CMachine::get_PlatformIsNT(VARIANT_BOOL *pfIsNT)
{
    if (!pfIsNT)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *pfIsNT = (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
                    ? VB_TRUE
                    : VB_FALSE;

    return S_OK;
}

STDMETHODIMP
CMachine::get_ServicePack(BSTR *pbstrServicePack)
{
    if (!pbstrServicePack)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *pbstrServicePack = SysAllocString(os.szCSDVersion);

    return (pbstrServicePack) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP
CMachine::get_HostMajorVer(long *plMajorVer)
{
    if (!plMajorVer)
        return E_POINTER;

    *plMajorVer = IConnectedMachine_lVersionMajor;

    return S_OK;
}

STDMETHODIMP
CMachine::get_HostMinorVer(long *plMinorVer)
{
    if (!plMinorVer)
        return E_POINTER;

    *plMinorVer = IConnectedMachine_lVersionMinor;

    return S_OK;
}

STDMETHODIMP
CMachine::get_StatusValue(long nIndex, long *pnStatus)
{
    if (!pnStatus)
        return E_POINTER;

    return _pMT->get_StatusValue(nIndex, pnStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\exe\mtscript.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       mtscript.cxx
//
//  Contents:   Implementation of the MTScript class
//
//              Written by Lyle Corbin
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include <shellapi.h>
#include <advpub.h>     // for RegInstall

#include "StatusDialog.h"
#include "RegSettingsIO.h"

HINSTANCE   g_hInstDll;
HINSTANCE   g_hinstAdvPack = NULL;
REGINSTALL  g_pfnRegInstall = NULL;

const TCHAR *g_szWindowName = _T("MTScript");

LRESULT CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

//
// Global variables
//

HINSTANCE g_hInstance  = NULL;

EXTERN_C  HANDLE    g_hProcessHeap = NULL;
DWORD     g_dwFALSE   = 0;

DeclareTagOther(tagDebugger, "MTScript", "Register with script debugger (MUST RESTART)");
DeclareTagOther(tagIMSpy, "!Memory", "Register IMallocSpy (MUST RESTART)");

//+---------------------------------------------------------------------------
//
//  Function:   ErrorPopup
//
//  Synopsis:   Displays a message to the user.
//
//----------------------------------------------------------------------------

#define ERRPOPUP_BUFSIZE 300

void
ErrorPopup(LPWSTR szMessage)
{
    WCHAR achBuf[ERRPOPUP_BUFSIZE];

    _snwprintf(achBuf, ERRPOPUP_BUFSIZE, L"%s: (%d)", szMessage, GetLastError());

    achBuf[ERRPOPUP_BUFSIZE - 1] = L'\0';

    MessageBox(NULL, achBuf, L"MTScript", MB_OK | MB_SETFOREGROUND);
}

int PrintfMessageBox(HWND hwnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType, ...)
{
    TCHAR chBuffer[256];
    va_list args;
    va_start(args, uType);
    _vsnwprintf(chBuffer, 256, lpText, args);
    va_end(args);
    return MessageBox(hwnd, chBuffer, lpCaption, uType);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadAdvPack
//
//  Synopsis:   Loads AdvPack.dll for DLL registration.
//
//----------------------------------------------------------------------------

HRESULT
LoadAdvPack()
{
    HRESULT hr = S_OK;

    g_hinstAdvPack = LoadLibrary(_T("ADVPACK.DLL"));

    if (!g_hinstAdvPack)
        goto Error;

    g_pfnRegInstall = (REGINSTALL)GetProcAddress(g_hinstAdvPack, achREGINSTALL);

    if (!g_pfnRegInstall)
        goto Error;

Cleanup:
    return hr;

Error:
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (g_hinstAdvPack)
    {
        FreeLibrary(g_hinstAdvPack);
    }

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   Register
//
//  Synopsis:   Register the various important information needed by this
//              executable.
//
//  Notes:      Uses AdvPack.dll and an INF file to do the registration
//
//----------------------------------------------------------------------------

HRESULT
Register()
{
    HRESULT   hr;
    OLECHAR   strClsid[40];
    TCHAR     keyName [256];
    STRTABLE  stReg = { 0, NULL };

    if (!g_hinstAdvPack)
    {
        hr = LoadAdvPack();
        if (hr)
            goto Cleanup;
    }

    hr = g_pfnRegInstall(GetModuleHandle(NULL), "Register", &stReg);

    if (!hr)
    {
        DWORD dwRet;
        HKEY  hKey;
        BOOL  fSetACL = FALSE;

        // If the access key already exists, then don't modify it in case
        // someone changed it from the defaults.

        StringFromGUID2(CLSID_RemoteMTScript, strClsid, 40);

        wsprintf (keyName, TEXT("APPID\\%s"), strClsid);

        dwRet = RegOpenKeyEx (HKEY_CLASSES_ROOT,
                              keyName,
                              0,
                              KEY_ALL_ACCESS,
                              &hKey);

        if (dwRet == ERROR_SUCCESS)
        {
            dwRet = RegQueryValueEx (hKey,
                                     TEXT("AccessPermission"),
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);

            if (dwRet != ERROR_SUCCESS)
            {
                fSetACL = TRUE;
            }

            RegCloseKey (hKey);
        }
        else
        {
            fSetACL = TRUE;
        }

        if (fSetACL)
        {
            // Give everyone access rights
            hr = ChangeAppIDACL(CLSID_RemoteMTScript, _T("EVERYONE"), TRUE, TRUE, TRUE);

            if (!hr)
            {
                // Deny everyone launch rights
                hr = ChangeAppIDACL(CLSID_RemoteMTScript, _T("EVERYONE"), FALSE, TRUE, TRUE);
            }
        }
    }

Cleanup:
    RegFlushKey(HKEY_CLASSES_ROOT);

    return hr;
}

//+------------------------------------------------------------------------
//
// Function:    Unregister
//
// Synopsis:    Undo the actions of Register.
//
//-------------------------------------------------------------------------

HRESULT
Unregister()
{
    HRESULT  hr;
    HKEY     hKey;
    DWORD    dwRet;
    OLECHAR  strClsid[40];
    TCHAR    keyName [256];

    STRTABLE stReg = { 0, NULL };

    if (!g_hinstAdvPack)
    {
        hr = LoadAdvPack();
        if (hr)
            goto Cleanup;
    }

    //
    // Remove the security keys that we created while registering
    //

    StringFromGUID2(CLSID_RemoteMTScript, strClsid, 40);

    wsprintf (keyName, TEXT("APPID\\%s"), strClsid);

    dwRet = RegOpenKeyEx (HKEY_CLASSES_ROOT,
                          keyName,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey);

    if (dwRet == ERROR_SUCCESS)
    {
        RegDeleteValue (hKey, TEXT("AccessPermission"));
        RegDeleteValue (hKey, TEXT("LaunchPermission"));

        RegCloseKey (hKey);
    }

    hr = g_pfnRegInstall(GetModuleHandle(NULL), "Unregister", &stReg);

Cleanup:
    RegFlushKey(HKEY_CLASSES_ROOT);

    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   IAmTheOnlyMTScript, private
//
//  Synopsis:   Guarantees that only 1 MTScript gets to run
//
//  Arguments:
//
//  Returns:    True is there is not already a running MTScript.
//
//  Note:       This function "leaks" a Mutex handle intentionally.
//              The system frees this handle on exit - so we know
//              for sure that we have finished all other cleanup
//              before it OK for another instance of MTScript to run.
//
//-------------------------------------------------------------------------

static bool IAmTheOnlyMTScript()
{
    HANDLE hMutex = CreateMutex(0, FALSE, g_szWindowName);
    if (!hMutex)
    {
        ErrorPopup(_T("Cannot create MTScript mutex!"));
        return false;
    }
    if( GetLastError() == ERROR_ALREADY_EXISTS)
    {
        ErrorPopup(_T("Cannot run more than one mtscript.exe!"));
        return false;
    }
    return true;
}

//+------------------------------------------------------------------------
//
//  Function:   WinMain, public
//
//  Synopsis:   Entry routine called by Windows upon startup.
//
//  Arguments:  [hInstance]     -- handle to the program's instance
//              [hPrevInstance] -- Always NULL
//              [lpCmdLine]     -- Command line arguments
//              [nCmdShow]      -- Value to be passed to ShowWindow when the
//                                   main window is initialized.
//
//  Returns:    FALSE on error or the value passed from PostQuitMessage on exit
//
//-------------------------------------------------------------------------

EXTERN_C int PASCAL
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    OSVERSIONINFO  ovi;
    CMTScript *    pMT = NULL;
    int            iRet = 0;
#if DBG == 1
    IMallocSpy *   pSpy = NULL;
#endif

#ifdef USE_STACK_SPEW
    InitChkStk(0xCCCCCCCC);
#endif

    //
    // Initialize data structures.
    //
    g_hProcessHeap = GetProcessHeap();
    g_hInstance    = hInstance;

#if DBG == 1
    DbgExRestoreDefaultDebugState();
#endif

    //
    // Get system information
    //
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&ovi);

    if (ovi.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        // Win95 doesn't implement MessageBoxW
        MessageBoxA(NULL,
                    "MTScript",
                    "This program can only be run on Windows NT",
                    MB_OK | MB_SETFOREGROUND);

        goto Error;
    }

    if (lpCmdLine && _stricmp(&lpCmdLine[1], "register") == 0)
    {
        HRESULT hr;

        hr = Register();
        if (FAILED(hr))
            goto Error;

        return 0;
    }
    else if (lpCmdLine && _stricmp(&lpCmdLine[1], "unregister") == 0)
    {
        HRESULT hr;

        hr = Unregister();
        if (FAILED(hr))
            goto Error;

        return 0;
    }

    if (!IAmTheOnlyMTScript() )
    {
        return 1;
    }

#if DBG == 1
    if (DbgExIsTagEnabled(tagIMSpy))
    {
        pSpy = (IMallocSpy *)DbgExGetMallocSpy();

        if (pSpy)
        {
            CoRegisterMallocSpy(pSpy);
        }
    }
#endif

    //
    // Can't put it on the stack because it depends on having zero'd memory
    //
    pMT = new CMTScript();
    if (!pMT)
        goto Error;

    if (!pMT->Init())
        goto Error;

    //
    // Start doing real stuff
    //
    iRet = pMT->ThreadMain();

Cleanup:
    if (pMT)
        pMT->Release();

#if DBG == 1
    if (pSpy)
    {
        // Note, due to the fact that we do not have control over DLL unload
        // ordering, the IMallocSpy implementation may report false leaks.
        // (lylec) The only way to fix this is to explicitely load all
        // dependent DLLs and unload them in their proper order (mshtmdbg.dll
        // last).
        CoRevokeMallocSpy();
    }
#endif

    return iRet;

Error:
    iRet = 1;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  CMTScript::OPTIONSETTINGS class
//
//  Handles user-configurable options
//
//----------------------------------------------------------------------------

CMTScript::OPTIONSETTINGS::OPTIONSETTINGS()
    : cstrScriptPath(CSTR_NOINIT),
      cstrInitScript(CSTR_NOINIT)
{

}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::OPTIONSETTINGS::GetModulePath, public
//
//  Synopsis:   Returns the path of this executable. Used for finding other
//              related files.
//
//  Arguments:  [pstr] -- Place to put path.
//
//  Notes:      Any existing string in pstr will be cleared.
//
//----------------------------------------------------------------------------

void
CMTScript::OPTIONSETTINGS::GetModulePath(CStr *pstr)
{
    WCHAR *pch;
    WCHAR  achBuf[MAX_PATH];

    pstr->Free();

    if (!GetModuleFileName(NULL, achBuf, sizeof(achBuf)))
        return;

    pch = wcsrchr(achBuf, L'\\');
    if (!pch)
        return;

    *pch = L'\0';

    pstr->Set(achBuf);
}

void
CMTScript::OPTIONSETTINGS::GetScriptPath(CStr *cstrScript)
{
    LOCK_LOCALS(this);
    if (cstrScriptPath.Length() == 0)
    {
        // TCHAR  achBuf[MAX_PATH];
        // TCHAR *psz;

        GetModulePath(cstrScript);

/*
        cstrScript->Append(L"\\..\\..\\scripts");

        GetFullPathName(*cstrScript, MAX_PATH, achBuf, &psz);

        cstrScript->Set(achBuf);
*/
    }
    else
    {
        cstrScript->Set(cstrScriptPath);
    }
}

void
CMTScript::OPTIONSETTINGS::GetInitScript(CStr *cstr)
{
    static WCHAR * pszInitScript = L"mtscript.js";

    LOCK_LOCALS(this);
    if (cstrInitScript.Length() == 0)
    {
        cstr->Set(pszInitScript);
    }
    else
    {
        cstr->Set(cstrInitScript);
    }
}

//+---------------------------------------------------------------------------
//
//  CMTScript class
//
//  Handles the main UI thread
//
//----------------------------------------------------------------------------

CMTScript::CMTScript()
{
    Assert(_fInDestructor == FALSE);
    Assert(_pGIT == NULL);
    Assert(_dwPublicDataCookie == 0);
    Assert(_dwPrivateDataCookie == 0);
    Assert(_dwPublicSerialNum == 0);
    Assert(_dwPrivateSerialNum == 0);

    VariantInit(&_vPublicData);
    VariantInit(&_vPrivateData);

    _ulRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::~CMTScript, public
//
//  Synopsis:   destructor
//
//  Notes:      Anything done in the Init() call must be undone here. This
//              method must also be able to handle a partial initialization,
//              in case something inside Init() failed halfway through.
//
//----------------------------------------------------------------------------

CMTScript::~CMTScript()
{
    int       i;

    VERIFY_THREAD();

    // Anything done in the Init() call must be undone here

    UnregisterClassObjects();

    _fInDestructor = TRUE;

    //
    // Process any pending messages such as PROCESSTHREADTERMINATE now.
    //
    HandleThreadMessage();

    // Cleanup any running processes.

    for (i = 0; i < _aryProcesses.Size(); i++)
    {
        Shutdown(_aryProcesses[i]);
    }
    _aryProcesses.ReleaseAll();

    //
    // This must be done in reverse order because the primary script (element 0)
    // must be shutdown last.
    //
    for (i = _aryScripts.Size() - 1; i >= 0; i--)
    {
        Shutdown(_aryScripts[i]);
    }
    _aryScripts.ReleaseAll();

    if (_pMachine)
    {
        Shutdown(_pMachine);
        ReleaseInterface(_pMachine);
    }

    if (_dwPublicDataCookie != 0)
    {
        _pGIT->RevokeInterfaceFromGlobal(_dwPublicDataCookie);
    }

    if (_dwPrivateDataCookie != 0)
    {
        _pGIT->RevokeInterfaceFromGlobal(_dwPrivateDataCookie);
    }

    ReleaseInterface(_pTIMachine);
    ReleaseInterface(_pTypeLibEXE);
    ReleaseInterface(_pGIT);

    ReleaseInterface(_pJScriptFactory);

    VariantClear(&_vPublicData);
    VariantClear(&_vPrivateData);

    DeInitScriptDebugger();

    CoUninitialize();

    CleanupUI();

    // This delete call must be done after we've destroyed our window, which
    // in turn will destroy the status window.
    delete _pStatusDialog;
    _pStatusDialog = NULL;
}

HRESULT
CMTScript::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::Init, public
//
//  Synopsis:   Initialization method that can fail.
//
//----------------------------------------------------------------------------

BOOL
CMTScript::Init()
{
    HRESULT hr;

    _dwThreadId = GetCurrentThreadId();

    if (!CThreadComm::Init())
        return FALSE;

    //
    // Load our default configuration
    //
    UpdateOptionSettings(FALSE);

    if (FAILED(CoInitializeEx(NULL,
                              COINIT_MULTITHREADED |
                              COINIT_DISABLE_OLE1DDE   |
                              COINIT_SPEED_OVER_MEMORY)))
    {
        goto Error;
    }

    // This code may be needed if we want to do our own custom security.
    // However, it is easier to let DCOM do it for us.

    // The following code removes all security always. It cannot be overridden
    // using the registry.

    if (FAILED(CoInitializeSecurity(NULL,
                                    -1,
                                    NULL,
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_NONE,
                                    RPC_C_IMP_LEVEL_IMPERSONATE,
                                    NULL,
                                    EOAC_NONE,
                                    NULL)))
    {
        goto Error;
    }

    hr = LoadTypeLibraries();
    if (hr)
        goto Error;

    InitScriptDebugger();

    if (FAILED(CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IGlobalInterfaceTable,
                                (void **)&_pGIT)))
    {
        goto Error;
    }

     //
    // Create our hidden window and put an icon on the taskbar
    //
    if (!ConfigureUI())
        goto Error;

    //
    // Run the initial script
    //
    if (FAILED(RunScript(NULL, NULL)))
        goto Error;

    if (RegisterClassObjects(this) != S_OK)
        goto Error;

    #if DBG == 1
        OpenStatusDialog();
    #endif
    return TRUE;

Error:
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::ThreadMain, public
//
//  Synopsis:   Main UI message loop.
//
//  Arguments:  [hWnd] -- Modeless Dialog HWND
//
//----------------------------------------------------------------------------

DWORD
CMTScript::ThreadMain()
{
    DWORD            dwRet;
    HANDLE           ahEvents[3];
    int              cEvents = 2;
    DWORD            dwReturn = 0;

    VERIFY_THREAD();

    SetName("CMTScript");

    // Don't need to call ThreadStarted() because StartThread() was not used
    // to start the main thread!

    ahEvents[0] = _hCommEvent;
    ahEvents[1] = GetPrimaryScript()->hThread();

    while (TRUE)
    {
        MSG msg;

        //
        // Purge out all window messages.
        //
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                goto Cleanup;
            }

            if (_pStatusDialog)
            {
                if (_pStatusDialog->IsDialogMessage(&msg))
                    continue;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        //
        // Wait for anything we need to deal with.
        //
        dwRet = MsgWaitForMultipleObjects(cEvents,
                                          ahEvents,
                                          FALSE,
                                          INFINITE,
                                          QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
        {
            //
            // Another thread is sending us a message.
            //
            HandleThreadMessage();
        }
        else if (dwRet == WAIT_OBJECT_0 + 1)
        {
            // The Primary Script Thread terminated due to a problem loading
            // the initial script. Bring up the configuration dialog.

            {
                LOCK_LOCALS(this);
                _aryScripts.ReleaseAll();
            }

            if (!_fRestarting)
            {
                int iRet = MessageBox(_hwnd, _T("An error occurred loading the default script.\n\nDo you wish to edit the default configuration?"),
                                      _T("MTScript Error"),
                                      MB_YESNO | MB_SETFOREGROUND | MB_ICONERROR);

                if (iRet == IDNO)
                {
                    goto Cleanup;
                }

                _fRestarting = TRUE; // Preventthe config dialog from doing a restart in this case.
                CConfig * pConfig = new CConfig(this);

                if (pConfig)
                {
                    pConfig->StartThread(NULL);

                    WaitForSingleObject(pConfig->hThread(), INFINITE);

                    pConfig->Release();
                }
                _fRestarting = FALSE;
            }
            else
            {
                _fRestarting = FALSE;
            }

            //
            // Try re-loading the initial script
            //
            if (FAILED(RunScript(NULL, NULL)))
                goto Error;

            ahEvents[1] = GetPrimaryScript()->hThread();

            if (_pStatusDialog)
                _pStatusDialog->Restart();

        }
        else if (dwRet == WAIT_TIMEOUT)
        {
            // Make sure our message queue is empty first.
            HandleThreadMessage();

            // Right now we never fall in this loop.
        }
        else if (dwRet == WAIT_FAILED)
        {
            TraceTag((tagError, "MsgWaitForMultipleObjects failure (%d)", GetLastError()));

            AssertSz(FALSE, "MsgWaitForMultipleObjects failure");

            goto Cleanup;
        }
    }


Cleanup:
    return dwReturn;

Error:
    dwReturn = 1;
    goto Cleanup;
}

void
CMTScript::InitScriptDebugger()
{
    HRESULT hr;

    if (!IsTagEnabled(tagDebugger))
    {
        return;
    }

    hr = CoCreateInstance(CLSID_ProcessDebugManager,
                          NULL,
                          CLSCTX_INPROC_SERVER |
                            CLSCTX_INPROC_HANDLER |
                            CLSCTX_LOCAL_SERVER,
                          IID_IProcessDebugManager,
                          (LPVOID*)&_pPDM);
    if (hr)
    {
        TraceTag((tagError, "Could not create ProcessDebugManager: %x", hr));
        return;
    }

    hr = THR(_pPDM->CreateApplication(&_pDA));
    if (hr)
        goto Error;

    _pDA->SetName(L"MTScript");

    hr = THR(_pPDM->AddApplication(_pDA, &_dwAppCookie));
    if (hr)
        goto Error;

    return;

Error:
    ClearInterface(&_pDA);
    ClearInterface(&_pPDM);

    return;
}

void
CMTScript::DeInitScriptDebugger()
{
    _try
    {
        if (_pPDM)
        {
            _pPDM->RemoveApplication(_dwAppCookie);

            _pDA->Close();

            ReleaseInterface(_pPDM);
            ReleaseInterface(_pDA);
        }
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
        //$ BUGBUG -- Figure out what's wrong here!

        // Ignore the crash caused by the Script Debugger
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::HackCreateInstance, public
//
//  Synopsis:   Loads a private jscript.dll since the one that shipped with
//              Win2K is broken for what we need it for.
//
//  Arguments:  [clsid]  -- Same parameters as CoCreateInstance.
//              [pUnk]   --
//              [clsctx] --
//              [riid]   --
//              [ppv]    --
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMTScript::HackCreateInstance(REFCLSID clsid,
                              IUnknown *pUnk,
                              DWORD clsctx,
                              REFIID riid,
                              LPVOID *ppv)
{
    TCHAR              achDllPath[MAX_PATH];
    HINSTANCE          hInstDll;
    DWORD              iRet;
    TCHAR             *pch;
    LPFNGETCLASSOBJECT pfnGCO = NULL;
    HRESULT            hr;
    DWORD              dwJunk;
    BYTE              *pBuf = NULL;
    VS_FIXEDFILEINFO  *pFI = NULL;
    UINT               iLen;

    if (!_pJScriptFactory && _fHackVersionChecked)
    {
        return S_FALSE;
    }

    if (!_pJScriptFactory)
    {
        LOCK_LOCALS(this);

        // Make sure another thread didn't take care of this while we were
        // waiting for the lock.

        if (!_fHackVersionChecked)
        {
            // Remember we've done this check so we won't do it again.
            _fHackVersionChecked = TRUE;

            // First, check the version number on the system DLL

            iRet = GetSystemDirectory(achDllPath, MAX_PATH);
            if (iRet == 0)
                goto Win32Error;

            _tcscat(achDllPath, _T("\\jscript.dll"));

            iRet = GetFileVersionInfoSize(achDllPath, &dwJunk);
            if (iRet == 0)
                goto Win32Error;

            pBuf = new BYTE[iRet];

            iRet = GetFileVersionInfo(achDllPath, NULL, iRet, pBuf);
            if (iRet == 0)
                goto Win32Error;

            if (!VerQueryValue(pBuf, _T("\\"), (LPVOID*)&pFI, &iLen))
                goto Win32Error;

            //
            // Is the system DLL a version that has our needed fix?
            //
            // Version 5.1.0.4702 has the fix but isn't approved for Win2K.
            // The first official version that has the fix is 5.5.0.4703.
            //
            if (   (pFI->dwProductVersionMS == 0x00050001 && pFI->dwProductVersionLS >= 4702)
                || (pFI->dwProductVersionMS >= 0x00050005 && pFI->dwProductVersionLS >= 4703))
            {
                hr = S_FALSE;

                goto Cleanup;
            }

            iRet = GetModuleFileName(NULL, achDllPath, MAX_PATH);
            if (iRet == 0)
                goto Win32Error;

            pch = _tcsrchr(achDllPath, _T('\\'));
            if (pch)
            {
                *pch = _T('\0');
            }

            _tcscat(achDllPath, _T("\\jscript.dll"));

            hInstDll = CoLoadLibrary(achDllPath, TRUE);
            if (!hInstDll)
            {

                hr = HRESULT_FROM_WIN32(GetLastError());

                ErrorPopup(_T("Your copy of JSCRIPT.DLL contains a problem which may prevent you from using this tool.\n")
                           _T("Please update that DLL to version 5.1.0.4702 or later.\n")
                           _T("You may put the new DLL in the same directory as mtscript.exe to avoid upgrading the system DLL."));

                // ErrorPopup clears the GetLastError() status.
                goto Cleanup;
            }

            pfnGCO = (LPFNGETCLASSOBJECT)GetProcAddress(hInstDll, "DllGetClassObject");
            if (!pfnGCO)
                goto Win32Error;

            hr = (*pfnGCO)(clsid, IID_IClassFactory, (LPVOID*)&_pJScriptFactory);
            if (hr)
                goto Cleanup;
        }
    }

    if (_pJScriptFactory)
        hr = _pJScriptFactory->CreateInstance(pUnk, riid, ppv);
    else
        hr = S_FALSE;

Cleanup:
    delete [] pBuf;

    return hr;

Win32Error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::ConfigureUI, public
//
//  Synopsis:   Creates our hidden window and puts an icon on the taskbar
//
//----------------------------------------------------------------------------

BOOL
CMTScript::ConfigureUI()
{
    VERIFY_THREAD();

    WNDCLASS       wc = { 0 };
    NOTIFYICONDATA ni = { 0 };
    ATOM           aWin;
    BOOL           fRet;

    // The window will be a hidden window so we don't set many of the attributes

    wc.lpfnWndProc   = MainWndProc;
    wc.hInstance     = g_hInstance;
    wc.lpszClassName = SZ_WNDCLASS;

    aWin = RegisterClass(&wc);
    if (aWin == 0)
    {
        return FALSE;
    }

    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                           (LPTSTR)aWin,
                           g_szWindowName,
                           WS_OVERLAPPED,
                           10,  // Coordinates don't matter - it will never
                           10,  //   be visible.
                           10,
                           10,
                           NULL,
                           NULL,
                           g_hInstance,
                           (LPVOID)this);
    if (_hwnd == NULL)
    {
        return FALSE;
    }

    ni.cbSize = sizeof(NOTIFYICONDATA);
    ni.hWnd   = _hwnd;
    ni.uID    = 1;
    ni.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE;
    ni.uCallbackMessage = WM_USER;
    ni.hIcon  = LoadIcon(g_hInstance, L"myicon_small");
    wcscpy(ni.szTip, L"Remote Script Engine");

    fRet = Shell_NotifyIcon(NIM_ADD, &ni);

    DestroyIcon(ni.hIcon);

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::CleanupUI, public
//
//  Synopsis:   Cleans up UI related things.
//
//----------------------------------------------------------------------------

void
CMTScript::CleanupUI()
{
    VERIFY_THREAD();

    NOTIFYICONDATA ni = { 0 };

    if (_hwnd != NULL)
    {
        ni.cbSize = sizeof(NOTIFYICONDATA);
        ni.hWnd   = _hwnd;
        ni.uID    = 1;

        Shell_NotifyIcon(NIM_DELETE, &ni);

        DestroyWindow(_hwnd);
    }
}

HRESULT
CMTScript::LoadTypeLibraries()
{
    VERIFY_THREAD();
    HRESULT hr = S_OK;

    _pTIMachine = NULL;

    if (!_pTypeLibEXE)
    {
        hr = THR(LoadRegTypeLib(LIBID_MTScriptEngine, 1, 0, 0, &_pTypeLibEXE));

        if (hr)
            goto Cleanup;
    }

    if (!_pTIMachine)
    {
        TYPEATTR *pTypeAttr;
        UINT mb = IDYES;

        hr = THR(_pTypeLibEXE->GetTypeInfoOfGuid(IID_IConnectedMachine, &_pTIMachine));
        if (hr)
            goto Cleanup;

        hr = THR(_pTIMachine->GetTypeAttr(&pTypeAttr));
        if (hr)
            goto Cleanup;

        if (pTypeAttr->wMajorVerNum != IConnectedMachine_lVersionMajor || pTypeAttr->wMinorVerNum != IConnectedMachine_lVersionMinor)
        {
            mb = PrintfMessageBox(NULL,
                                       L"Mtscript.exe version (%d.%d) does not match mtlocal.dll (%d.%d).\n"
                                       L"You may experience undefined behavior if you continue.\n"
                                       L"Do you wish to ignore this error and continue?",
                                       L"Version mismatch error",
                                       MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND | MB_DEFBUTTON2,
                                       IConnectedMachine_lVersionMajor, IConnectedMachine_lVersionMinor,
                                       pTypeAttr->wMajorVerNum, pTypeAttr->wMinorVerNum);
        }
        _pTIMachine->ReleaseTypeAttr(pTypeAttr);
        if (mb != IDYES)
            return E_FAIL;
    }
Cleanup:

    if (hr)
    {
        PrintfMessageBox(NULL,
                         _T("FATAL: Could not load type library (%x).\nIs mtlocal.dll registered?"),
                         _T("MTScript"),
                         MB_OK | MB_ICONERROR | MB_SETFOREGROUND,
                         hr);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::ShowMenu, public
//
//  Synopsis:   Displays a menu when the user right-clicks on the tray icon.
//
//  Arguments:  [x] -- x location
//              [y] -- y location
//
//----------------------------------------------------------------------------

void
CMTScript::ShowMenu(int x, int y)
{
    VERIFY_THREAD();

    ULONG ulItem;

    HMENU hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU));

    if (x == -1 && y == -1)
    {
        POINT pt;

        GetCursorPos(&pt);

        x = pt.x;
        y = pt.y;
    }

    SetForegroundWindow(_hwnd);

    ulItem = TrackPopupMenuEx(GetSubMenu(hMenu, 0),
                              TPM_RETURNCMD |
                              TPM_NONOTIFY  |
                              TPM_RIGHTBUTTON |
                              TPM_LEFTALIGN,
                              x, y,
                              _hwnd,
                              NULL);
    switch (ulItem)
    {
    case IDM_EXIT:
        UpdateOptionSettings(true);
        PostQuitMessage(0);
        break;

    case IDM_CONFIGURE:
        {
            CConfig * pConfig = new CConfig(this);

            if (pConfig)
            {
                pConfig->StartThread(NULL);

                pConfig->Release();
            }
        }
        break;

    case IDM_RESTART:
        Restart();

        break;

    case IDM_STATUS:
        if (!_pStatusDialog)
            OpenStatusDialog();
        if (_pStatusDialog)
            _pStatusDialog->Show();
        break;

#if DBG == 1
    case IDM_TRACETAG:
        DbgExDoTracePointsDialog(FALSE);
        break;

    case IDM_MEMORYMON:
        DbgExOpenMemoryMonitor();
        break;
#endif
    }

    DestroyMenu(hMenu);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::HandleThreadMessage, public
//
//  Synopsis:   Another thread has sent us a cross-thread message that we need
//              to handle.
//
//----------------------------------------------------------------------------

void
CMTScript::HandleThreadMessage()
{
    VERIFY_THREAD();

    THREADMSG tm;
    BYTE      bData[MSGDATABUFSIZE];
    DWORD     cbData;

    while (GetNextMsg(&tm, (void *)bData, &cbData))
    {
        switch (tm)
        {
        case MD_SECONDARYSCRIPTTERMINATE:
            {
                //
                // A secondary script ended.  Find it in our list, remove it,
                // and delete it.
                //
                CScriptHost *pbs = *(CScriptHost**)bData;

                LOCK_LOCALS(this);
                Verify(_aryScripts.DeleteByValue(pbs));

                pbs->Release();
            }
            break;

        case MD_MACHINECONNECT:
            PostToThread(GetPrimaryScript(), MD_MACHINECONNECT);
            break;

        case MD_SENDTOPROCESS:
            {
                MACHPROC_EVENT_DATA *pmed = *(MACHPROC_EVENT_DATA**)bData;

                CProcessThread *pProc = FindProcess(pmed->dwProcId);

                if (pProc && pProc->GetProcComm())
                {
                    pProc->GetProcComm()->SendToProcess(pmed);
                }
                else
                {
                    V_VT(pmed->pvReturn) = VT_I4;
                    V_I4(pmed->pvReturn) = -1;
                    SetEvent(pmed->hEvent);
                }
            }
            break;

        case MD_REBOOT:
            Reboot();
            break;

        case MD_RESTART:
            Restart();
            break;

        case MD_PLEASEEXIT:
            PostQuitMessage(0);
            break;
        case MD_OUTPUTDEBUGSTRING:
            if (_pStatusDialog)
            {
                _pStatusDialog->OUTPUTDEBUGSTRING( (LPWSTR) bData);
            }
            break;
        default:
            AssertSz(FALSE, "CMTScript got a message it couldn't handle!");
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::RunScript, public
//
//  Synopsis:   Creates a scripting thread and runs a given script
//              Can be called from any thread.
//
//  Arguments:  [pszPath] -- If NULL, we're starting the primary thread.
//                           Otherwise, it's the name of a file in the
//                           scripts directory.
//
//----------------------------------------------------------------------------

HRESULT
CMTScript::RunScript(LPWSTR pszPath, VARIANT *pvarParam)
{
    HRESULT hr;
    CScriptHost * pScript = NULL;
    CStr             cstrScript;
    SCRIPT_PARAMS    scrParams;

    if (!pszPath)
        _options.GetInitScript(&cstrScript);
    else
        cstrScript.Set(pszPath);

    AssertSz(cstrScript.Length() > 0, "CRASH: Bogus script path");

    pScript = new CScriptHost(this,
                              (pszPath) ? FALSE : TRUE,
                              FALSE);
    if (!pScript)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    scrParams.pszPath    = cstrScript;
    scrParams.pvarParams = pvarParam;

    // Race: We can successfully start a thread.
    //       That thread can run to completion, and exit.
    //       CScriptHost would then post MD_SECONDARYSCRIPTTERMINATE
    //       in an attempt to remove the script from the list and free
    //       it.
    //       Thus, we must add it to the list first, then remove it
    //       if the script fails to start.
    {
        LOCK_LOCALS(this);
        _aryScripts.Append(pScript);
    }
    hr = pScript->StartThread(&scrParams);
    if (FAILED(hr) && pszPath) // DO NOT REMOVE THE PRIMARY SCRIPT! Instead, return SUCCESS.
    {                          // The main thread makes a special check for the primary script
        LOCK_LOCALS(this);
        Verify(_aryScripts.DeleteByValue(pScript));
        pScript->Release();
        goto Error;
    }
    Assert(pszPath || _aryScripts.Size() == 1);

    return S_OK;

Error:
    ReleaseInterface(pScript);
    if (pszPath == 0)
        ErrorPopup(L"An error occurred running the initial script");

    return hr;
}

HRESULT
CMTScript::UpdateOptionSettings(BOOL fSave)
{
    LOCK_LOCALS(&_options);   // Makes this method thread safe

    static REGKEYINFORMATION aKeyValuesOptions[] =
    {
        { _T("File Paths"),     RKI_KEY, 0 },
        { _T("Script Path"),    RKI_EXPANDSZ, offsetof(OPTIONSETTINGS, cstrScriptPath) },
        { _T("Initial Script"), RKI_STRING, offsetof(OPTIONSETTINGS, cstrInitScript) },
    };

    HRESULT hr;
    hr = RegSettingsIO(g_szRegistry, fSave, aKeyValuesOptions, ARRAY_SIZE(aKeyValuesOptions), (BYTE *)&_options);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::Restart, public
//
//  Synopsis:   Restarts like we were just starting
//
//  Notes:      All currently running scripts are stopped and destroyed.
//              Public information is freed and then everything is restarted.
//
//----------------------------------------------------------------------------

void
CMTScript::Restart()
{
    int i;

    // Make sure the status dialog doesn't try to do anything while we're
    // restarting.

    if (_pStatusDialog)
        _pStatusDialog->Pause();

    // Kill all running scripts and start over.
    for (i = _aryScripts.Size() - 1; i >= 0; i--)
    {
        Shutdown(_aryScripts[i]);

        // Scripts will be released when they notify us of their being
        // shutdown.
    }

    // Kill all running processes
    for (i = _aryProcesses.Size() - 1; i >= 0; i--)
    {
        Shutdown(_aryProcesses[i]);
    }
    _aryProcesses.ReleaseAll();

    if (_dwPublicDataCookie != 0)
    {
        _pGIT->RevokeInterfaceFromGlobal(_dwPublicDataCookie);
        _dwPublicDataCookie = 0;
    }

    if (_dwPrivateDataCookie != 0)
    {
        _pGIT->RevokeInterfaceFromGlobal(_dwPrivateDataCookie);
        _dwPrivateDataCookie = 0;
    }

    VariantClear(&_vPublicData);
    VariantClear(&_vPrivateData);

    // Reset the statusvalues to 0
    memset(_rgnStatusValues, 0, sizeof(_rgnStatusValues));

    // The above call to shutdown will terminate the primary script thread,
    // which will trigger the restart code in ThreadMain().

    _fRestarting = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::OpenStatusDialog, public
//
//  Synopsis:   Opens the status modeless dialog
//
//----------------------------------------------------------------------------
void
CMTScript::OpenStatusDialog()
{
    if (!_pStatusDialog)
        _pStatusDialog = new CStatusDialog(_hwnd, this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::Reboot, public
//
//  Synopsis:   Reboots the local machine. The user must have appropriate
//              rights to do so.
//
//----------------------------------------------------------------------------

void
CMTScript::Reboot()
{
    TOKEN_PRIVILEGES tp;
    LUID             luid;
    HANDLE           hToken;

    //
    // Try to make sure we get shutdown last
    //
    SetProcessShutdownParameters(0x101, 0);

    //
    // Setup shutdown priviledges
    //

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES,
                          &hToken))
    {
        goto Error;
    }

    if (!LookupPrivilegeValue(NULL,
                              SE_SHUTDOWN_NAME,
                              &luid))
    {
        goto Error;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(hToken,
                          FALSE,
                          &tp,
                          sizeof(TOKEN_PRIVILEGES),
                          (PTOKEN_PRIVILEGES) NULL,
                          (PDWORD) NULL);

    if (GetLastError() != ERROR_SUCCESS)
        goto Error;

    PostQuitMessage(0);

    // BUGBUG -- This call is Windows2000 specific.

    ExitWindowsEx(EWX_REBOOT | EWX_FORCEIFHUNG, 0xFFFF);

    return;

Error:
    TraceTag((tagError, "Failed to get security to reboot."));
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::AddProcess, public
//
//  Synopsis:   Adds a process to our process thread list. Any old ones
//              hanging around are cleaned up in the meantime.
//
//  Arguments:  [pProc] -- New process object to add.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMTScript::AddProcess(CProcessThread *pProc)
{
    LOCK_LOCALS(this);

    CleanupOldProcesses();

    return _aryProcesses.Append(pProc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::FindProcess, public
//
//  Synopsis:   Returns a process object for the given process ID.
//
//  Arguments:  [dwProcID] -- Process ID to find
//
//----------------------------------------------------------------------------

CProcessThread *
CMTScript::FindProcess(DWORD dwProcID)
{
    CProcessThread **ppProc;
    int              cProcs;

    LOCK_LOCALS(this);

    CleanupOldProcesses();

    for (ppProc = _aryProcesses, cProcs = _aryProcesses.Size();
         cProcs;
         ppProc++, cProcs--)
    {
        if ((*ppProc)->ProcId() == dwProcID)
        {
            break;
        }
    }

    if (cProcs == 0)
    {
        return NULL;
    }

    return *ppProc;
}

BOOL CMTScript::SetScriptPath(const TCHAR *pszScriptPath, const TCHAR *pszInitScript)
{
    LOCK_LOCALS(&_options);

    // If there is any change then prompt the user, then force a restart.
    //
    // NOTE: The CStr "class" does not protect itself, so we must test it
    //       first before using it!
    //
    if ( (_options.cstrScriptPath == 0 || _tcscmp(pszScriptPath, _options.cstrScriptPath) != 0) ||
        (_options.cstrInitScript == 0 || _tcscmp(pszInitScript, _options.cstrInitScript) != 0))
    {
        if (!_fRestarting)
        {
            UINT mb = MessageBox(NULL, L"This will require a restart. Continue?", L"Changing script path or starting script", MB_OKCANCEL | MB_ICONWARNING | MB_SETFOREGROUND);
            if (mb == IDCANCEL)
                return FALSE;
        }
        _options.cstrScriptPath.Set(pszScriptPath);
        _options.cstrInitScript.Set(pszInitScript);
        // Write it out to the registry.
        UpdateOptionSettings(TRUE);
        if (!_fRestarting)
            PostToThread(this, MD_RESTART);
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::CleanupOldProcesses, public
//
//  Synopsis:   Walks the array of process objects and looks for ones that
//              have been dead for more than a specified amount of time. For
//              those that are, the objects are freed.
//
//  Notes:      Assumes that the caller has already locked the process array.
//
//----------------------------------------------------------------------------

const ULONG MAX_PROCESS_DEADTIME = 5 * 60 * 1000; // Cleanup after 5 minutes

void
CMTScript::CleanupOldProcesses()
{
    int i;

    //$ CONSIDER: Adding a max number of dead processes as well.

    // We assume that the process array is already locked (via LOCK_LOCALS)!

    // Iterate in reverse order since we'll be removing elements as we go.

    for (i = _aryProcesses.Size() - 1; i >= 0; i--)
    {
        if (_aryProcesses[i]->GetDeadTime() > MAX_PROCESS_DEADTIME)
        {
            _aryProcesses.ReleaseAndDelete(i);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::GetScriptNames, public
//
//  Synopsis:   Walks the array of scripts, copying the script names
//              into the supplied buffer.
//              Each name is null terminated. The list is double null terminated.
//              If the buffer is not large enough, then *pcBuffer
//              is set the the required size and FALSE is returned.
//
//  Notes:      Returns 0 if index is past end of array of scripts.
//
//----------------------------------------------------------------------------
BOOL
CMTScript::GetScriptNames(TCHAR *pchBuffer, long *pcBuffer)
{
    VERIFY_THREAD();
    LOCK_LOCALS(this);
    long nChars = 0;
    int i;
    TCHAR *pch = pchBuffer;
    for(i = 0; i < _aryScripts.Size(); ++i)
    {
        TCHAR *ptr = _T("<invalid>");
        CScriptSite *site = _aryScripts[i]->GetSite();
        if (site)
        {
            ptr = _tcsrchr((LPTSTR)site->_cstrName, _T('\\'));
            if (!ptr)
                ptr = (LPTSTR)site->_cstrName;
        }
        int n = _tcslen(ptr) + 1;
        nChars += n;
        if ( nChars + 1 < *pcBuffer)
        {
            _tcscpy(pch, ptr);
            pch += n;
        }
        *pch = 0; // double null terminator.
    }
    BOOL retval = nChars + 1 < *pcBuffer;
    *pcBuffer = nChars + 1; // double null termination
    return retval;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::GetPrimaryScript, public
//
//  Synopsis:   Returns the first script in the array
//
//----------------------------------------------------------------------------
CScriptHost *CMTScript::GetPrimaryScript()
{
    LOCK_LOCALS(this);
    return _aryScripts[0];
}
//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::GetProcess, public
//
//  Synopsis:   Walks the array of processes
//
//  Notes:      Returns 0 if index is past end of array of processes.
//
//----------------------------------------------------------------------------
CProcessThread *
CMTScript::GetProcess(int index)
{
    VERIFY_THREAD();

    LOCK_LOCALS(this);

    if (index < 0 || index >= _aryProcesses.Size())
        return 0;

    return _aryProcesses[index];
}



//+---------------------------------------------------------------------------
//
//  Function:   MainWndProc
//
//  Synopsis:   Main window procedure for our hidden window. Used mainly to
//              handle context menu events on our tray icon.
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static CMTScript *s_pMT = NULL;

    switch (msg)
    {
    case WM_CREATE:
        {
            CREATESTRUCT UNALIGNED *pcs = (CREATESTRUCT *)lParam;

            s_pMT = (CMTScript *)pcs->lpCreateParams;
        }
        return 0;

    case WM_USER:
        switch (lParam)
        {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_CONTEXTMENU:
            if (s_pMT)
            {
                s_pMT->ShowMenu(-1, -1);
            }
            return 0;
        }
        return 0;

    case WM_COMMAND:
        return 0;
        break;

    case WM_LBUTTONDOWN:
        return 0;
        break;

    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Function:   get_StatusValue
//
//  Synopsis:   Return the value at [nIndex] in the StatusValues array
//              Currently the implementation of this property has a small
//              limit to the range of "nIndex".
//              This allows us to avoid any dynamic memory allocation
//              and also allows us to dispense with the usual thread locking.
//
//----------------------------------------------------------------------------
HRESULT
CMTScript::get_StatusValue(long nIndex, long *pnStatus)
{
    if (!pnStatus)
        return E_POINTER;

    if (nIndex < 0 || nIndex >= ARRAY_SIZE(_rgnStatusValues))
        return E_INVALIDARG;

    *pnStatus = _rgnStatusValues[nIndex];

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   put_StatusValue
//
//  Synopsis:   Set the value at [nIndex] in the StatusValues array
//
//----------------------------------------------------------------------------
HRESULT
CMTScript::put_StatusValue(long nIndex, long nStatus)
{
    if (nIndex < 0 || nIndex >= ARRAY_SIZE(_rgnStatusValues))
        return E_INVALIDARG;

    _rgnStatusValues[nIndex] = nStatus;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\config.h ===
#define IDD_CONFIGPATHS             100
#define IDD_SCRIPTPATH              103
#define IDD_INITSCRIPT              107
#define IDD_STATUSDIALOG            108
#define IDC_SCRIPTLIST              109
#define IDC_STATUSOUTPUT            112
#define IDC_DEBUGOUTPUT             114
#define IDC_PROCESSLIST             111
#define IDC_CLEAR                   117
#define IDC_SIGNALLIST              118
#define IDC_OUTPUTTEXT              113
#define IDC_PROCESSTEXT             115
#define IDC_SIGNALTEXT              116
#define IDC_LOGGING                 119
#define IDC_EXIT                    120
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\exe\resizer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       Resizer.cxx
//
//  Contents:   Implementation of the CResizer class
//
//              Written by Joe Porkka
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "Resizer.h"


CResizer::CResizer()
:    _hWnd(0), _pResizeInfo(0)
{
    memset(&_winRect, 0, sizeof(_winRect));
}

void CResizer::Init(HWND win, CResizeInfo *pResizeInfo)
{
    _hWnd = win;
    _pResizeInfo = pResizeInfo;
    GetClientRect(_hWnd, &_winRect);
    for(CResizeInfo *p = _pResizeInfo; p->_id; ++p)
    {
        InitCtrl(p);
    }
}

CResizer::~CResizer()
{
}

void CResizer::NewSize() const
{
    RECT newDlgSize;
    GetClientRect(_hWnd, &newDlgSize);
    for(CResizeInfo *p = _pResizeInfo; p->_id; ++p)
    {
        RECT newpos = p->_Rect;
        if (p->_Flags & sf_Width)
        { // Adjust the width
            int w = (p->_Rect.right - p->_Rect.left) + (newDlgSize.right - _winRect.right);
            newpos.right = newpos.left + w;
        }
        if (p->_Flags & sf_Height)
        { // Adjust the height
            int h = (p->_Rect.bottom - p->_Rect.top) + (newDlgSize.bottom - _winRect.bottom);
            newpos.bottom = newpos.top + h;
        }
        if (p->_Flags & sf_Left)
        { // adjust left edge
            int w = p->_Rect.right - p->_Rect.left;
            newpos.left = newDlgSize.right - (_winRect.right - p->_Rect.left);
            newpos.right = newpos.left + w;
        }
        if (p->_Flags & sf_Top)
        { // adjust top edge
            int h = p->_Rect.bottom - p->_Rect.top;
            newpos.top = newDlgSize.bottom - (_winRect.bottom - p->_Rect.top);
            newpos.bottom = newpos.top + h;
        }

        if (p->_Flags & sf_HalfLeftWidth)
        { // adjust left edge & width by half width delta
//            int w = p->_Rect.right - p->_Rect.left;
            int widthdelta = newDlgSize.right - _winRect.right;
            newpos.left = p->_Rect.left + widthdelta / 2;
            newpos.right = p->_Rect.right + widthdelta;
        }
        if (p->_Flags & sf_HalfTopHeight)
        { // adjust left edge & width by half width delta
            int heightdelta = newDlgSize.bottom - _winRect.bottom;
            newpos.top = p->_Rect.top + heightdelta / 2;
            newpos.bottom = p->_Rect.bottom + heightdelta;
        }

        if (p->_Flags & sf_HalfWidth)
        { // adjust left edge & width by half width delta
            int widthdelta = newDlgSize.right - _winRect.right;
            newpos.right = p->_Rect.right + widthdelta  - widthdelta / 2;
        }
        if (p->_Flags & sf_HalfHeight)
        { // adjust left edge & width by half width delta
            int heightdelta = newDlgSize.bottom - _winRect.bottom;
            newpos.bottom = p->_Rect.bottom + heightdelta - heightdelta / 2;
        }

        SetWindowPos(GetDlgItem(_hWnd, p->_id), 0, newpos.left, newpos.top, newpos.right - newpos.left, newpos.bottom - newpos.top, SWP_NOZORDER);
    }
}

void CResizer::InitCtrl(CResizeInfo *p)
{
    GetWindowRect(GetDlgItem(_hWnd, p->_id), &p->_Rect);
    MapWindowPoints(0, _hWnd, (POINT *)&p->_Rect, 2); // Map abs coordinates of control to dialog relative.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\dialogs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       hostobj.h
//
//  Contents:   Contains the main application object
//
//----------------------------------------------------------------------------


//****************************************************************************
//
// Classes
//
//****************************************************************************

//+---------------------------------------------------------------------------
//
//  Class:      CConfig (cdd)
//
//  Purpose:    Class which runs the configuration dialog. We run it in a
//              separate thread because we cannot afford to block the main
//              thread on UI stuff.
//
//----------------------------------------------------------------------------

class CConfig : public CThreadComm
{

    friend BOOL CALLBACK
           ConfigDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

public:
    DECLARE_STANDARD_IUNKNOWN(CConfig);

    CConfig(CMTScript *pMT) : _pMT(pMT) { _ulRefs = 1; }

    CMTScript * _pMT;

protected:
    virtual DWORD ThreadMain();

    void InitializeConfigDialog(HWND hwnd);
    BOOL CommitConfigChanges(HWND hwnd);

private:
    HWND   _hwnd;
};


//+---------------------------------------------------------------------------
//
//  Class:      CMessageBoxTimeout (cdd)
//
//  Purpose:    Class which runs the configuration dialog. We run it in a
//              separate thread because we cannot afford to block the main
//              thread on UI stuff.
//
//----------------------------------------------------------------------------

class CMessageBoxTimeout : public CThreadComm
{

    friend BOOL CALLBACK
           MBTimeoutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

public:
    DECLARE_STANDARD_IUNKNOWN(CMessageBoxTimeout);

    CMessageBoxTimeout(MBTIMEOUT *pmbt) : _pmbt(pmbt) { _ulRefs = 1; }

    MBTIMEOUT *_pmbt;
    long       _lSecondsTilCancel;
    long       _lSecondsTilNextEvent;
    HWND       _hwnd;

protected:
    virtual DWORD ThreadMain();

    void InitializeDialog(HWND hwnd);
    void OnCommand(USHORT id, USHORT wNotify);
    void OnTimer();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\dispid.h ===
#define DISPID_MTScript_ScriptMain           100
#define DISPID_MTScript_OnMachineConnect     101
#define DISPID_MTScript_OnMachineDisconnect  102
#define DISPID_MTScript_OnRemoteExec         103
#define DISPID_MTScript_OnScriptError        104

#define DISPID_MTScript_OnProcessEvent       200
#define DISPID_MTScript_OnEventSourceEvent   201

#define DISPID_MTScript_OnMessageBoxInterval 300

#define DISPID_RemoteMTScript_OnScriptNotify 400
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\exe\statusdialog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       StatusDialog.cxx
//
//  Contents:   Implementation of the StatusDialog class
//
//              Written by Joe Porkka
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#include "StatusDialog.h"
#include "RegSettingsIO.h"
#include <stdio.h>
#include <time.h>
#define REFRESH_DELAY 500
#define MAX_DBMSG_LENGTH 256
#define MAX_SCRIPT_NAME_LENGTH 512
DeclareTag(tagStat, "Stat", "status events");

CCustomListBox::CCustomListBox()
{
    _hwnd = 0;
}

CCustomListBox::~CCustomListBox()
{
    _hwnd = 0;
    ResetContent();
}

void CCustomListBox::Init(HWND dlg, UINT idCtrl)
{
    _nExtent = 0;
    _hwnd = GetDlgItem(dlg, idCtrl);
    SetWindowLong(_hwnd, GWL_USERDATA, (LONG) this);
    SendMessage(LB_SETCOUNT, _Messages.Size(), 0);
}

const TCHAR *CCustomListBox::GetString(int index)
{
    if (index >= 0 && index < _Messages.Size())
    {
        return _Messages[index];
    }
    return 0;
}

void CCustomListBox::ResetContent()
{
    SetEnd(0);
}

void CCustomListBox::SetEnd(int nItems)
{
    if (nItems < _Messages.Size())
    {
        for(int i = nItems; i < _Messages.Size(); ++i)
        {
            delete [] _Messages[i];
            _Messages[i] = 0;
        }

        _Messages.SetSize(nItems);
    }
    if (_hwnd)
    {
        int cTopIndex = SendMessage(LB_GETTOPINDEX, 0, 0);
        int nSelCount = SendMessage(LB_GETSELCOUNT, 0, 0);
        if (nItems != SendMessage(LB_GETCOUNT, 0, 0) )
        {
            SendMessage(WM_SETREDRAW, FALSE, 0);

            long *pSelItems = 0;
            if (nSelCount > 0)
            {
                pSelItems = new long[nSelCount];
                if (pSelItems)
                    SendMessage(LB_GETSELITEMS, nSelCount, (LPARAM) pSelItems);

                MemSetName(pSelItems, "StatusDialog selcount: %d", nSelCount);
            }

            SendMessage(LB_SETCOUNT, _Messages.Size(), 0);
            if (nSelCount != 0)
            {
                // If there is a selection  (or LB_ERR in the single select listbox case), maintain current scroll position
                SendMessage(LB_SETTOPINDEX, cTopIndex, 0);
            }
            else if (nItems > 0)
                SendMessage(LB_SETTOPINDEX, nItems - 1, 0);

            if (pSelItems)
            {
                for(int i = 0; i < nSelCount; ++i)
                {
                    SendMessage( LB_SELITEMRANGE,
                        TRUE,
                        MAKELONG(pSelItems[i], pSelItems[i]));
                }
                delete [] pSelItems;
            }

            SendMessage( WM_SETREDRAW, TRUE, 0);
        }
    }
}

void CCustomListBox::AppendString(const TCHAR *sz)
{
    SetString(_Messages.Size(), sz);
    SetEnd(_Messages.Size());
}

void CCustomListBox::SetString(int nItem, const TCHAR *sz)
{
    if (nItem >= _Messages.Size())
    { // CImplAry oughta do this for us!
        if (nItem >= _nAllocatedMessageLength)
        { // Grow allocation by power of 2
            int newsize = _Messages.Size() * 2;
            if (newsize == 0)
                newsize = 1;
            while (newsize < nItem + 1)
                newsize *= 2;

            if (_Messages.EnsureSize(newsize) == S_OK)
            {
                _nAllocatedMessageLength = newsize;
                for(int i = _Messages.Size(); i < newsize; ++i)
                    _Messages[i] = NULL;

                _Messages.SetSize(nItem + 1);
            }
        }
        else
        {
            _Messages.SetSize(nItem + 1);
            _Messages[nItem] = NULL;
        }
    }

    if (nItem < _Messages.Size())
    {
        delete [] _Messages[nItem];
        int len = _tcslen(sz);
        _Messages[nItem] = new TCHAR[len + 1];
        if (_Messages[nItem])
        {
            MemSetName(_Messages[nItem], "StatusDialog line #%d", nItem);
            _tcscpy(_Messages[nItem], sz);
        }
    }

    // Limit the maximum number of messages so we don't eat up memory.  We
    // let it grow to 10 messages over our limit, then we delete down to 10
    // under.

    if (_Messages.Size() > MAX_STATUS_MESSAGES + 10)
    {
        int cPurge = _Messages.Size() - (MAX_STATUS_MESSAGES - 10);
        int i;

        for (i = 0; i < cPurge; i++)
        {
            delete [] _Messages[i];
        }

        // if cPurge is 1, then we will delete only the first element. Using
        // DeleteMultiple is dramatically more efficient than deleting
        // one element at a time.

        _Messages.DeleteMultiple(0, cPurge - 1);

        Refresh();
    }
}

void CCustomListBox::MeasureItem(MEASUREITEMSTRUCT *pmis)
{
    if (_hwnd)
    {
        HDC hdc = GetDC(_hwnd);
        TEXTMETRIC tm;
        GetTextMetrics(hdc, &tm);
        ReleaseDC(_hwnd, hdc);
        pmis->itemHeight = tm.tmHeight;
    }
    else
        pmis->itemHeight = 20;
}

void CCustomListBox::DrawItem(DRAWITEMSTRUCT *pdis)
{
    TCHAR *szText = 0;
    if (pdis->itemID < unsigned(_Messages.Size()))
        szText = _Messages[pdis->itemID];

    if (!szText)
        szText = L"";

    switch (pdis->itemAction)
    {
        case ODA_SELECT:
        case ODA_DRAWENTIRE:
            // Display the text associated with the item.
            {
                COLORREF savetext = 0;
                COLORREF savebk = 0;
                if (pdis->itemState & ODS_SELECTED)
                {
                    savetext = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    savebk = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
                }
                DrawTextEx(pdis->hDC,
                    szText,
                    -1,
                    &pdis->rcItem,
                    DT_EXPANDTABS | DT_NOPREFIX | DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_EXTERNALLEADING,
                    0);

                RECT extRect = pdis->rcItem;
                DrawTextEx(pdis->hDC,
                    szText,
                    -1,
                    &extRect,
                    DT_CALCRECT | DT_EXPANDTABS | DT_NOPREFIX | DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_EXTERNALLEADING,
                    0);

                if (pdis->itemState & ODS_SELECTED)
                {
                    SetTextColor(pdis->hDC, savetext );
                    SetBkColor(pdis->hDC, savebk);
                }
                if (extRect.right > _nExtent)
                {
                    _nExtent = extRect.right ;
                    SendMessage( LB_SETHORIZONTALEXTENT, _nExtent, 0);
                }
            }
            break;

        case ODA_FOCUS:

            // Do not process focus changes. The focus caret
            // (outline rectangle) indicates the selection.
            // The IDOK button indicates the final
            // selection.

            break;
    }
}

CStatusDialog::CStatusDialog(HWND parent, CMTScript *pMTScript)
: _parent(parent), _pMTScript(pMTScript), _fLogToFile(FALSE)
{
    _hwnd = 0;
    Assert(pMTScript);

//    _cstrLogFileName.Set(L"\\\\jporkka10\\log\\MT%COMPUTERNAME%.log");
    _cstrLogFileName.Set(L"%TEMP%\\%COMPUTERNAME%_MTDbg.log");
    UpdateOptionSettings(false);
    if (_fStatusOpen)
        Show();
}

CStatusDialog::~CStatusDialog()
{
    if (_hwnd)
        DestroyWindow(_hwnd);
    ClearOutput();
}

CCustomListBox *CStatusDialog::CtrlIDToListBox(UINT CtrlID)
{
    switch(CtrlID)
    {
        case IDC_SCRIPTLIST:
            return &_CScriptListBox;
        case IDC_PROCESSLIST:
            return &_CProcessListBox;
        case IDC_SIGNALLIST:
            return &_CSignalListBox;
        case IDC_DEBUGOUTPUT:
            return &_COutputListBox;
        default:
            Assert(0);
            break;
    }
    return 0;
}

bool CStatusDialog::Show()
{
    if (!_hwnd)
    {
        _hwnd = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(IDD_STATUSDIALOG), _parent, DlgProc, (LONG)this);
        if (!_hwnd)
            return false;
        _fStatusOpen = true;

        WINDOWPLACEMENT wp = { sizeof(WINDOWPLACEMENT) };
        GetWindowPlacement(_hwnd, &wp);
        if (!IsRectEmpty(&_WindowPlacement.rcNormalPosition))
            wp.rcNormalPosition = _WindowPlacement.rcNormalPosition;
        wp.ptMaxPosition = _WindowPlacement.ptMaxPosition;
        wp.flags = 0;
        if (_fMaximized)
            wp.showCmd = SW_SHOWMAXIMIZED;

        SetWindowPlacement(_hwnd, &wp);
        UpdateOptionSettings(true);
    }

    return true;
}

void CStatusDialog::InitDialog()
{
    _CScriptListBox.Init(_hwnd, IDC_SCRIPTLIST);
    _CProcessListBox.Init(_hwnd, IDC_PROCESSLIST);
    _CSignalListBox.Init(_hwnd, IDC_SIGNALLIST);
    _COutputListBox.Init(_hwnd, IDC_DEBUGOUTPUT);
    SendDlgItemMessage(_hwnd, IDC_LOGGING, BM_SETCHECK, _fLogToFile ? BST_CHECKED : BST_UNCHECKED, 0);

    Refresh();

    RECT rect;
    GetWindowRect(_hwnd, &rect);
    _InitialSize.x = rect.right - rect.left;
    _InitialSize.y = rect.bottom - rect.top;

    static struct CResizeInfo rgResizeInfo[] =
    {
        { IDC_OUTPUTTEXT,  CResizer::sf_HalfLeftWidth },
        { IDC_DEBUGOUTPUT, CResizer::sf_HalfLeftWidth |  CResizer::sf_Height    },
        { IDOK,            CResizer::sf_Top           |  CResizer::sf_Left      },
        { IDC_CLEAR,       CResizer::sf_Top           |  CResizer::sf_Left      },
        { IDC_EXIT,        CResizer::sf_Top           |  CResizer::sf_Left      },
        { IDC_SCRIPTLIST,  CResizer::sf_HalfWidth     },
        { IDC_PROCESSLIST, CResizer::sf_HalfWidth     |  CResizer::sf_Height    },
        { IDC_SIGNALLIST,  CResizer::sf_Top           |  CResizer::sf_HalfWidth },
        { IDC_SIGNALTEXT,  CResizer::sf_Top           },
        { IDC_LOGGING,     CResizer::sf_Top           },
        {0}
    };
    _Resizer.Init(_hwnd, rgResizeInfo);
}

void CStatusDialog::Destroy()
{
    UpdateOptionSettings(true);
    _hwnd = 0;
    _CScriptListBox.Destroy();
    _CProcessListBox.Destroy();
    _CSignalListBox.Destroy();
    _COutputListBox.Destroy();
#if DBG != 1
        _COutputListBox.ResetContent();
#endif
}

BOOL CALLBACK CStatusDialog::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CStatusDialog *stats = (CStatusDialog *)GetWindowLong(hwnd, GWL_USERDATA);
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            SetWindowLong(hwnd, GWL_USERDATA, lParam);
            stats = (CStatusDialog *)lParam;
            stats->_hwnd = hwnd;
            stats->InitDialog();
            if (!stats->_fPaused)
                SetTimer(hwnd, 1, REFRESH_DELAY, 0);
            break;
        }
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    if (stats)
                        stats->_fStatusOpen = false;
                    DestroyWindow(hwnd);
                    break;

                case IDC_EXIT:
                    DestroyWindow(hwnd);
                    PostQuitMessage(0);
                    break;
                case IDC_CLEAR:
                    if (stats)
                        stats->ClearOutput();
                    break;
                case IDC_SIGNALLIST:
                    if (stats && HIWORD(wParam) == LBN_DBLCLK)
                    {
                        CCustomListBox *pListBox = stats->CtrlIDToListBox(LOWORD(wParam));
                        if (pListBox == &stats->_CSignalListBox)
                        {
                            stats->ToggleSignal();
                        }
                    }
                    break;
                case IDC_LOGGING:
                    if (stats)
                        stats->UpdateLogging();
                    break;
            }
            break;
        }
        case WM_TIMER:
            if (stats)
                stats->Refresh();
            break;
        case WM_DESTROY:
            KillTimer(hwnd, 1);
            SetWindowLong(hwnd, GWL_USERDATA, 0);
            if (stats)
                stats->Destroy();
            break;
        case WM_GETMINMAXINFO:
            if (stats)
                stats->GetMinMaxInfo((MINMAXINFO *)lParam);
            break;
        case WM_MOVE:
            break;
        case WM_SIZE:
            if (stats)
                stats->Resize(LOWORD(lParam), HIWORD(lParam));
            break;
        case WM_EXITSIZEMOVE:
            if (stats)
            {
                stats->UpdateOptionSettings(true);
            }
            break;
        case WM_MEASUREITEM:
            if (stats)
            {
                CCustomListBox *pListBox = stats->CtrlIDToListBox(wParam);
                if (pListBox )
                    pListBox->MeasureItem( (LPMEASUREITEMSTRUCT) lParam);
            }
            break;
        case WM_DRAWITEM:
            if (stats)
            {
                CCustomListBox *pListBox = stats->CtrlIDToListBox(wParam);
                if (pListBox )
                    pListBox->DrawItem((DRAWITEMSTRUCT *) lParam);
            }
            break;
        default:
            return 0; // did not process the message;
    }
    return true;
}

BOOL CStatusDialog::IsDialogMessage(MSG *msg)
{
    if (_hwnd)
    {
        return ::IsDialogMessage(_hwnd, msg);
    }

    return 0;
}

void CStatusDialog::PopulateScripts()
{
    int i = 0;

    if (_hwnd)
    {
        TCHAR szBuffer[MAX_SCRIPT_NAME_LENGTH];
        long cBuffer = MAX_SCRIPT_NAME_LENGTH;
        _pMTScript->GetScriptNames(szBuffer, &cBuffer); // We don't really care if we do not get all of them..,
        TCHAR *ptr = szBuffer;
        while (*ptr && ptr < szBuffer + MAX_SCRIPT_NAME_LENGTH)
        {
            _CScriptListBox.SetString(i, ptr);
            ptr += _tcslen(ptr) + 1;
            ++i;
        }
        _CScriptListBox.SetEnd(i);
        _CScriptListBox.Refresh();
    }
}

void CStatusDialog::PopulateSignals()
{
    int i = 0;
    HANDLE hEvent;
    CStr cstr;

    if (_hwnd)
    {
        for(i = 0; CScriptHost::GetSyncEventName(i, &cstr, &hEvent) == S_OK; ++i)
        {
            wchar_t szSignalText[256];
            bool signalled = (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0);
            wsprintf(szSignalText, L"%s:\t%.32s", signalled ? L"Set" : L"Clr", (LPTSTR)cstr);
            szSignalText[ARRAY_SIZE(szSignalText) - 1] = 0;

            _CSignalListBox.SetString(i, szSignalText);
        }
        _CSignalListBox.SetEnd(i);
        _CSignalListBox.Refresh();
    }
}

wchar_t *FormatFileTime(_int64 t, wchar_t szBuf[16])
{
    wchar_t *szPrefix = L"";
    if (t < 0)
    {
        t = -t;
        szPrefix = L"-";
    }
    t /= 1000;
    long Sec   = t % 60;
    long Min   = (t / 60) % 60;
    long Hours = t / 3600;
    wsprintf(szBuf, L"%s%02.2d:%02.2d:%02.2d", szPrefix, Hours, Min, Sec);
    return szBuf;
}

void CStatusDialog::PopulateProcesses()
{
    if (!_hwnd)
        return;
    int cProcesses = 0;
    for(int pass = 0; pass < 2; ++pass)
    {
        CProcessThread *pProcess;
        for(int i = 0; (pProcess = _pMTScript->GetProcess(i)) != 0; ++i)
        {
            const PROCESS_PARAMS *params = pProcess->GetParams();
            const TCHAR *ptr = _T("<invalid>");
            if (params->pszCommand)
                ptr = (LPTSTR)params->pszCommand;

            wchar_t szText[256];
            wchar_t szTimeBuf[16];
            DWORD dwExitCode = pProcess->GetExitCode();
            if (pass == 0 && dwExitCode == STILL_ACTIVE)
            {
                HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION,
                    false,
                    pProcess->ProcId());

                if (hProc)
                {
                    _int64 i64CreationTime;
                    _int64 i64ExitTime;
                    _int64 i64KernelTime;
                    _int64 i64UserTime;
                    GetProcessTimes(hProc,
                        (FILETIME*) &i64CreationTime,
                        (FILETIME*) &i64ExitTime,
                        (FILETIME*) &i64KernelTime,
                        (FILETIME*) &i64UserTime);

                    GetSystemTimeAsFileTime((FILETIME*)&i64ExitTime);
                    CloseHandle(hProc);
                    wsprintf(szText, L"%04d (R):\t%.128s (%s)",
                        pProcess->ProcId(),
                        ptr,
                        FormatFileTime((i64ExitTime - i64CreationTime) / 10000, szTimeBuf));
                }
                else
                    wsprintf(szText, L"%04d (R):\t%.128s", pProcess->ProcId(), ptr);
                szText[ARRAY_SIZE(szText) - 1] = 0;
                _CProcessListBox.SetString(cProcesses, szText);
                ++cProcesses;
            }
            else if (pass == 1 && dwExitCode != STILL_ACTIVE)
            {
                wsprintf(szText, L"%04d (%u):\t%.128s\t (-%s)",
                    pProcess->ProcId(),
                    dwExitCode,
                    ptr, FormatFileTime(pProcess->GetDeadTime() , szTimeBuf));

                szText[ARRAY_SIZE(szText) - 1] = 0;
                _CProcessListBox.SetString(cProcesses, szText);
                ++cProcesses;
            }
        }
    }
    _CProcessListBox.SetEnd(cProcesses);
    _CProcessListBox.Refresh();
}

void CStatusDialog::Refresh()
{
    PopulateScripts();
    PopulateProcesses();
    PopulateSignals();
}

bool Exists(const TCHAR *pszLogFileName)
{
    WIN32_FIND_DATA fd;

    HANDLE hFind = FindFirstFile(pszLogFileName, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        return true;
    }
    return false;
}

void RenumberFile(const TCHAR *pszLogFileName)
{
    if (Exists(pszLogFileName))
    {
        TCHAR achFileName[MAX_PATH + 32];
        const TCHAR *dot   = wcsrchr(pszLogFileName, L'.');
        const TCHAR *slash = wcsrchr(pszLogFileName, L'\\');
        const TCHAR *colon = wcsrchr(pszLogFileName, L':');

        if (dot && dot > pszLogFileName && dot > slash && dot > colon)
        {
            for(int i = 1; i < 999; ++i)
            {
                swprintf(achFileName, L"%.*s_%.03d.%s", dot - pszLogFileName, pszLogFileName, i, dot + 1);
                if (!Exists(achFileName))
                {
                    MoveFile(pszLogFileName, achFileName);
                    break;
                }
            }
        }
    }
}

void CStatusDialog::OUTPUTDEBUGSTRING(LPWSTR pszMsg)
{
#if DBG != 1
    if (_hwnd)
#endif
    {
        _COutputListBox.AppendString(pszMsg);
        _COutputListBox.Refresh();
    }

    if (_fLogToFile )
    {
        if (!_fCreatedLogFileName)
        {
            if (ExpandEnvironmentStrings(_cstrLogFileName, _achLogFileName, ARRAY_SIZE(_achLogFileName)))
                _fCreatedLogFileName = true;

            RenumberFile(_achLogFileName);
            _fAddedHeaderToFile = false;
        }
        FILE *f = _wfopen(_achLogFileName, L"a+");
        if (f)
        {
            if (!_fAddedHeaderToFile)
            {
                _fAddedHeaderToFile = true;
                time_t t = time(0);
                fprintf(f, "============================\nMTScript started %s", ctime(&t));
            }
            fputws(pszMsg, f);
            fputws(L"\n", f);
            fclose(f);
        }
    }
}

void CStatusDialog::ClearOutput()
{
    _COutputListBox.ResetContent();
    _COutputListBox.Refresh();
}

void CStatusDialog::Resize(int width, int height)
{
    _Resizer.NewSize();
}

void CStatusDialog::GetMinMaxInfo(MINMAXINFO *mmi)
{
    mmi->ptMinTrackSize = _InitialSize;
}

void CStatusDialog::Pause()
{
    if (_hwnd)
    {
        KillTimer(_hwnd, 1);
    }
    _fPaused = TRUE;
}

void CStatusDialog::Restart()
{
    if (_hwnd && _fPaused)
    {
        SetTimer(_hwnd, 1, REFRESH_DELAY, 0);
    }
    _fPaused = FALSE;

    _fAddedHeaderToFile = false;
}

HRESULT CStatusDialog::UpdateOptionSettings(BOOL fSave)
{
    static REGKEYINFORMATION aKeyValuesOptions[] =
    {
        { _T("Options"),          RKI_KEY, 0 },
        { _T("StatusDialogOpen"), RKI_BOOL,   offsetof(CStatusDialog, _fStatusOpen) },
        { _T("LogToFile"),        RKI_BOOL,   offsetof(CStatusDialog, _fLogToFile) } ,
        { _T("LogFileName"),      RKI_STRING, offsetof(CStatusDialog, _cstrLogFileName) } ,
        { _T("StatusLeft"),       RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.rcNormalPosition.left) },
        { _T("StatusTop"),        RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.rcNormalPosition.top) },
        { _T("StatusRight"),      RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.rcNormalPosition.right) },
        { _T("StatusBottom"),     RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.rcNormalPosition.bottom) },
        { _T("StatusMaxLeft"),    RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.ptMaxPosition.x) },
        { _T("StatusMaxTop"),     RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.ptMaxPosition.y) },
        { _T("StatusMax"),        RKI_BOOL,   offsetof(CStatusDialog, _fMaximized) } ,
    };

    HRESULT hr;
    if (fSave)
    {
        if (_hwnd)
        {
            _WindowPlacement.length = sizeof(WINDOWPLACEMENT);
            GetWindowPlacement(_hwnd, &_WindowPlacement);
            if (_WindowPlacement.showCmd == SW_MAXIMIZE)
                _fMaximized = TRUE;
            else
                _fMaximized = FALSE;
        }
    }
    hr = RegSettingsIO(g_szRegistry, fSave, aKeyValuesOptions, ARRAY_SIZE(aKeyValuesOptions), (BYTE *)this);

    return hr;
}

void CStatusDialog::ToggleSignal()
{
    int index = _CSignalListBox.SendMessage(LB_GETCARETINDEX, 0, 0);
    LPCTSTR pszName = _CSignalListBox.GetString(index);
    if (pszName)
        pszName = wcschr(pszName, L'\t');
    HANDLE hEvent;
    if (pszName && CScriptHost::GetSyncEvent(pszName + 1, &hEvent) == S_OK)
    {
        bool signalled = (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0);
        if (signalled)
            ResetEvent(hEvent);
        else
            SetEvent(hEvent);
    }
}

void CStatusDialog::UpdateLogging()
{
    _fLogToFile = (SendDlgItemMessage(_hwnd, IDC_LOGGING, BM_GETCHECK, 0, 0) == BST_CHECKED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\exe\proccomm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       proccomm.cxx
//
//  Contents:   Implementation of the CProcessComm class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

DeclareTag(tagProcComm, "MTScript", "IScriptedProcess communication");

CProcessComm::CProcessComm(CMTScript *pMT)
{
    _ulRefs = 1;

    _pMT = pMT;

    Assert(_pSink == NULL);
    Assert(_pSH == NULL);
    Assert(_pProc == NULL);
    TraceTag((tagProcComm, "CProcessComm this(%x)", this));
}

CProcessComm::~CProcessComm()
{
    TraceTag((tagProcComm, "%p: Destroyed this(%x)", _pProc, this));

    if (_pProc)
    {
        _pProc->SetProcComm(NULL);
    }

    ReleaseInterface(_pSink);
    ReleaseInterface(_pSH);
    ReleaseInterface(_pProc);
}

HRESULT
CProcessComm::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IScriptedProcess)
    {
        *ppv = (IScriptedProcess *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SetProcessID, public
//
//  Synopsis:   Called by the remote process to tell us who it is.  We use
//              the information to match it with the CProcessThread and
//              CScriptHost object that created it.
//
//  Arguments:  [lProcessID] -- Process ID of the calling process
//              [pszEnvID]   -- Value of the __MTSCRIPT_ENV_ID environment
//                              variable.
//
//  Returns:    S_OK, E_INVALIDARG if a match could not be made.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProcessComm::SetProcessID(long lProcessID, wchar_t *pszEnvID)
{
    CProcessThread **ppProc;
    int              cProcs;
    long             lEnvID;
    wchar_t         *pch;

    if (!pszEnvID)
    {
        return E_INVALIDARG;
    }

    if (_pProc)
    {
        TraceTag((tagProcComm, "%p: Got duplicate call to SetProcessID! (id=%d)", _pProc, lProcessID));
        return E_UNEXPECTED;
    }

    lEnvID = wcstol(pszEnvID, &pch, 10);

    LOCK_LOCALS(_pMT);

    for (ppProc = _pMT->_aryProcesses, cProcs = _pMT->_aryProcesses.Size();
         cProcs;
         ppProc++, cProcs--)
    {
        if ((*ppProc)->IsOwner(lProcessID, lEnvID))
        {
            break;
        }
    }

    if (cProcs == 0)
    {
        return E_INVALIDARG;
    }

    // We don't allow more than one process to connect to a single
    // CProcessThread. This could happen if more than one child process of
    // the one we launched with RunLocalCommand tries to connect. All but the
    // first one will get an error back.

    if ((*ppProc)->GetProcComm())
    {
        TraceTag((tagProcComm, "%p: Got duplicate call to SetProcessID! (id=%d)", *ppProc, lProcessID));
        return E_UNEXPECTED;
    }

    _pProc = *ppProc;
    _pProc->AddRef();

    _pSH = _pProc->ScriptHost();
    _pSH->AddRef();

    _pProc->SetProcComm(this);

    TraceTag((tagProcComm, "Proc:%p, this:%p: Received SetProcessID call: %d, %ls", _pProc, this, lProcessID, pszEnvID));

    _pMT->PostToThread(_pSH, MD_PROCESSCONNECTED, &_pProc, sizeof(CProcessComm*));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SendData, public
//
//  Synopsis:   Called by the remote process when it wants to fire an event
//              into the script.
//
//  Arguments:  [pszType]  -- String giving name of data
//              [pszData]  -- String giving data
//              [plReturn] -- Return value from event handler
//
//  Returns:    HRESULT
//
//  Notes:      This uses the same data structures as CMachine::Exec and is
//              basically the same code.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProcessComm::SendData(wchar_t * pszType,
                       wchar_t * pszData,
                       long    * plReturn)
{
    // We create an event object for each call on this method. While this
    // may have a cost, it makes this method thread-safe. If we cached an
    // event object then we would have to synchronize access to that event
    // object which could be even more expensive.
    MACHPROC_EVENT_DATA   med;
    MACHPROC_EVENT_DATA * pmed;
    VARIANT           vRet;
    VARIANT           vLong;
    HRESULT           hr = S_OK;

    TraceTag((tagProcComm, "%p: SendData call received: (%ls, %ls)", _pProc, pszType, pszData));

    VariantInit(&vRet);
    VariantInit(&vLong);

    if (!_pSH)
    {
        return E_UNEXPECTED;
    }

    if (!plReturn)
    {
        return E_INVALIDARG;
    }

    med.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (med.hEvent == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    med.bstrCmd     = SysAllocString(pszType);
    med.bstrParams  = SysAllocString(pszData);
    med.dwProcId    = _pProc->ProcId();
    med.pvReturn    = &vRet;
    med.dwGITCookie = 0;
    med.hrReturn    = S_OK;

    pmed = &med;

    _pMT->PostToThread(_pSH,
                       MD_PROCESSDATA,
                       (LPVOID)&pmed,
                       sizeof(MACHPROC_EVENT_DATA*));

    // We can do WaitForSingleObject because we are in OLE's multi-threaded
    // apartment and don't need to handle messages from our event loop.
    WaitForSingleObject(med.hEvent, INFINITE);

    if (med.hrReturn != S_OK)
    {
        hr = med.hrReturn;
        goto Cleanup;
    }

    if (VariantChangeType(&vLong, &vRet, 0, VT_I4) != S_OK)
    {
        *plReturn = -1;
    }
    else
    {
        *plReturn = V_I4(&vLong);
    }

Cleanup:
    VariantClear(&vRet);
    VariantClear(&vLong);

    SysFreeString(med.bstrCmd);
    SysFreeString(med.bstrParams);

    CloseHandle(med.hEvent);

    TraceTag((tagProcComm, "%p: SendData is returning %x", _pProc, hr));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SetExitCode, public
//
//  Synopsis:   Sets the exit code which will be given to the script for
//              this process. This will override the actual exit code of
//              the process.
//
//  Arguments:  [lExitCode] -- New exit code.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProcessComm::SetExitCode(long lExitCode)
{
    if (!_pProc)
    {
        return E_UNEXPECTED;
    }

    TraceTag((tagProcComm, "%p: Process set exit code of %d", _pProc, lExitCode));

    _pProc->SetExitCode((DWORD)lExitCode);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SetProcessSink, public
//
//  Synopsis:   Sets the sink interface so the script can call back into
//              the remote process.
//
//  Arguments:  [pSink] -- Sink interface
//
//  Returns:    HRESULT
//
//  Notes:      Clear the sink by calling SetProcessSink with NULL before
//              shutting down.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProcessComm::SetProcessSink(IScriptedProcessSink *pSink)
{
    ReleaseInterface(_pSink);

    _pSink = pSink;

    TraceTag((tagProcComm, "%p: Received new process sink (%p)", _pProc, pSink));

    if (pSink)
    {
        pSink->AddRef();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SendToProcess, public
//
//  Synopsis:   Sends a command to the remote process as requested by the
//              script engine.
//
//  Arguments:  [pmed] -- Pointer to cross-thread data structure.
//
//----------------------------------------------------------------------------

void
CProcessComm::SendToProcess(MACHPROC_EVENT_DATA *pmed)
{
    long    lReturn     = 0;
    HRESULT hr          = S_OK;

    TraceTag((tagProcComm, "%p: Making call to ReceiveData. Params=(%ls, %ls)",
              _pProc, pmed->bstrCmd, pmed->bstrParams));

    if (_pSink)
    {
        hr = _pSink->ReceiveData(pmed->bstrCmd, pmed->bstrParams, &lReturn);
    }

    V_VT(pmed->pvReturn) = VT_I4;
    V_I4(pmed->pvReturn) = lReturn;

    TraceTag((tagProcComm, "%p: Call to ReceiveData returned %x", _pProc, hr));

    pmed->hrReturn = hr;

    SetEvent(pmed->hEvent);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\cstr.h ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         CSTR.HXX
//
// Contents     Class definition for length prefix string class
//
// Classes      CStr
//
// Stolen from Trident
//
//-----------------------------------------------------------------------------

class ANSIString
{
public:
    ANSIString(WCHAR *pchWide);
   ~ANSIString() { delete _pch; }

    void Set(WCHAR *pchWide);

    operator LPSTR () const { return _pch; }

private:
    char *_pch;
};

/*
    Use this macro to avoid initialization of embedded
    objects when parent object zeros out the memory
*/

#define CSTR_NOINIT ((float)0.0)

/*
    This class defines a length prefix 0 terminated string object. It points
    to the beginning of the characters so the pointer returned can be used in
    normal string operations taking into account that of course that it can
    contain any binary value.
*/

class CStr
{
public:

    DECLARE_MEMALLOC_NEW_DELETE()

    /*
        Default constructor
    */
    CStr()
    {
        _pch = 0;
    }

    /*
        Special constructor to AVOID construction for embedded
        objects...
    */
    CStr(float num)
    {
        Assert(_pch == 0);
    }
    /*
        Destructor will free data
    */
    ~CStr()
    {
        _Free();
    }

    operator LPTSTR () const { return _pch; }
    HRESULT Set(LPCTSTR pch);
    HRESULT Set(LPCTSTR pch, UINT uc);

    HRESULT SetMultiByte(LPCSTR pch);
    HRESULT GetMultiByte(LPSTR pch, UINT cch);

    HRESULT SetBSTR(const BSTR bstr);

    HRESULT Set(const CStr &cstr);

    void    TakeOwnership(CStr &cstr);
    UINT    Length() const;

    // Update the internal length indication without changing any allocation.

    HRESULT SetLengthNoAlloc( UINT uc );

    // Reallocate the string to a larger size, length unchanged.

    HRESULT ReAlloc( UINT uc );

    HRESULT Append(LPCTSTR pch);
    HRESULT Append(LPCTSTR pch, UINT uc);
    HRESULT AppendMultiByte(LPCSTR pch);

    void Free()
    {
        _Free();
        _pch = 0;
    }

    TCHAR * TakePch() { TCHAR * pch = _pch; _pch = NULL; return(pch); }

    HRESULT AllocBSTR(BSTR *pBSTR) const;

    HRESULT TrimTrailingWhitespace();

private:
    void    _Free();
    LPTSTR  _pch;
    NO_COPY(CStr);

public:
    HRESULT Clone(CStr **ppCStr) const;
    BOOL    Compare (const CStr *pCStr) const;
    WORD    ComputeCrc() const;
    BOOL    IsNull(void) const { return _pch == NULL ? TRUE : FALSE; }
    HRESULT Save(IStream * pstm) const;
    HRESULT Load(IStream * pstm);
    ULONG   GetSaveSize() const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\empty.cxx ===
#include "comhdr.hxx"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\factory.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       factory.h
//
//  Contents:   Definition of the standard class factory class
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CStdFactory (csf)
//
//  Purpose:    Standard implementation of a class factory.
//
//----------------------------------------------------------------------------

class CStdFactory : public IClassFactory
{
public:
    typedef HRESULT (FNCREATE)(CMTScript *pMT, IUnknown **ppUnkObj);

    CStdFactory(CMTScript *pMT, FNCREATE *pfnCreate);
   ~CStdFactory() {};

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN(CStdFactory);

    // IClassFactory methods

    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

private:
    CMTScript * _pMT;
    FNCREATE  * _pfnCreate;
};

//+---------------------------------------------------------------------------
//
//  Struct:     REGCLASSDATA
//
//  Purpose:    Used to declare the classes we want to register with OLE.
//              A class factory that will create the class will be registered
//              for each entry.
//
//----------------------------------------------------------------------------

struct REGCLASSDATA
{
    const CLSID           *pclsid;    // CLSID to register
    CStdFactory::FNCREATE *pfnCreate; // Pointer to creation function
    DWORD                  ctxCreate; // CLSCTX to register this class with
    DWORD                  dwCookie;  // Cookie returned from CoRegister...
};


HRESULT RegisterClassObjects(CMTScript *pMT);
void    UnregisterClassObjects();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\localobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       localobj.h
//
//  Contents:   Contains class definitions of objects used in the remoteable
//              object proxy object.
//
//----------------------------------------------------------------------------

class CLocalMTProxy;

//+---------------------------------------------------------------------------
//
//  Class:      CMTLocalFactory
//
//  Purpose:    Standard implementation of a class factory.  This is meant
//              to be created as a global object and therefore does not
//              destroy itself when its refcount goes to zero.
//
//----------------------------------------------------------------------------

class CMTLocalFactory : public IClassFactory
{
public:
    CMTLocalFactory();
   ~CMTLocalFactory() {};

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void)
        {
            return InterlockedIncrement((long*)&_ulRefs);
        }
    STDMETHOD_(ULONG, Release) (void)
        {
            if (InterlockedDecrement((long*)&_ulRefs) == 0)
            {
                return 0;
            }
            return _ulRefs;
        }

    // IClassFactory methods

    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

private:
    ULONG  _ulRefs;
};

//+---------------------------------------------------------------------------
//
//  Class:      CMTEventSink (ces)
//
//  Purpose:    Class which sinks events from the remote object
//
//----------------------------------------------------------------------------

class CMTEventSink : public IDispatch
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CMTEventSink() { }
   ~CMTEventSink() { }

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

private:
    CLocalMTProxy* Proxy();
};

//+---------------------------------------------------------------------------
//
//  Class:      CLocalMTProxy (cm)
//
//  Purpose:    Contains all useful info about a machine and what it's
//              doing.
//
//  Notes:      This class is manipulated from multiple threads. All
//              member functions must be thread safe!
//
//              This is the class that is created by the class factory and
//              handed out as a remote object to other machines. It has no
//              real code in itself but merely provides a way to talk to the
//              already running script engines.
//
//----------------------------------------------------------------------------

class CLocalMTProxy : public IRemoteMTScriptProxy,
                      public IConnectionPointContainer,
                      public IProvideClassInfo
{
    friend class CLocalProxyCP;
    friend class CMTEventSink;

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CLocalMTProxy();
   ~CLocalMTProxy();

    // IUnknown methods. Because we have a refcounted sub-object (our event
    // sink) we must do more complicated object lifetime stuff here.

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);
    ULONG SubAddRef (void);
    ULONG SubRelease (void);

    void Passivate(void);

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

    // IConnectionPointContainer methods

    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS*);
    STDMETHOD(FindConnectionPoint)(REFIID, LPCONNECTIONPOINT*);

    // IProvideClassInfo methods

    STDMETHOD(GetClassInfo)(ITypeInfo **pTI);

    // IRemoteMTScriptProxy interface

    STDMETHOD(Connect)(BSTR bstrMachine);
    STDMETHOD(Disconnect)();
    STDMETHOD(DownloadFile)(BSTR bstrURL, BSTR *bstrFile);

    HRESULT LoadTypeLibs();

private:
    DWORD _ulAllRefs;
    DWORD _ulRefs;

    ITypeLib *   _pTypeLibDLL;
    ITypeInfo *  _pTypeInfoInterface;
    ITypeInfo *  _pTypeInfoCM;

    IDispatch *  _pDispRemote;
    DWORD        _dwSinkCookie;
    CMTEventSink _cesSink;

    IDispatch*   _pDispSink;
};

inline CLocalMTProxy * CMTEventSink::Proxy()
{
    return CONTAINING_RECORD(this, CLocalMTProxy, _cesSink);
}

inline STDMETHODIMP_(ULONG)
CMTEventSink::AddRef(void)
{
    return Proxy()->SubAddRef();
}

inline STDMETHODIMP_(ULONG)
CMTEventSink::Release(void)
{
    return Proxy()->SubRelease();
}

//+---------------------------------------------------------------------------
//
//  Class:      CLocalProxyCP (mcp)
//
//  Purpose:    Implements IConnectionPoint for CLocalMTProxy
//
//----------------------------------------------------------------------------

class CLocalProxyCP : public IConnectionPoint
{
public:

    CLocalProxyCP(CLocalMTProxy *pMTP);
   ~CLocalProxyCP();

    DECLARE_STANDARD_IUNKNOWN(CLocalProxyCP);

    STDMETHOD(GetConnectionInterface)(IID * pIID);
    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer ** ppCPC);
    STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);
    STDMETHOD(EnumConnections)(LPENUMCONNECTIONS * ppEnum);

    CLocalMTProxy *_pMTProxy;
};

extern HINSTANCE g_hInstDll;
extern long g_lObjectCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\machine.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       machine.h
//
//  Contents:   IConnectedMachine class definition
//
//----------------------------------------------------------------------------


//****************************************************************************
//
// Forward declarations
//
//****************************************************************************

class CMTScript;
class CScriptHost;

//****************************************************************************
//
// Classes
//
//****************************************************************************

//+---------------------------------------------------------------------------
//
//  Class:      CMachine (cm)
//
//  Purpose:    Contains all useful info about a machine and what it's
//              doing.
//
//  Notes:      This class is manipulated from multiple threads. All
//              member functions must be thread safe!
//
//              This is the class that is created by the class factory and
//              handed out as a remote object to other machines. It has no
//              real code in itself but merely provides a way to talk to the
//              already running script engines.
//
//----------------------------------------------------------------------------

class CMachine : public CThreadComm,
                 public IConnectedMachine,
                 public IConnectionPointContainer
{
    friend class CMachConnectPoint;

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CMachine(CMTScript *pMT, ITypeInfo *pTIMachine);
   ~CMachine();

    DECLARE_STANDARD_IUNKNOWN(CMachine);

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

    // IConnectionPointContainer methods

    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS*);
    STDMETHOD(FindConnectionPoint)(REFIID, LPCONNECTIONPOINT*);

    // IConnectedMachine interface

    STDMETHOD(Exec)(BSTR bstrCmd, BSTR bstrParams, VARIANT *pvData);

    STDMETHOD(get_PublicData)(VARIANT *pvData);
    STDMETHOD(get_Name)(BSTR *pbstrName);
    STDMETHOD(get_Platform)(BSTR *pbstrPlat);
    STDMETHOD(get_OS)(BSTR *pbstrOS);
    STDMETHOD(get_MajorVer)(long *plMajorVer);
    STDMETHOD(get_MinorVer)(long *plMinorVer);
    STDMETHOD(get_BuildNum)(long *plBuildNum);
    STDMETHOD(get_PlatformIsNT)(VARIANT_BOOL *pfIsNT);
    STDMETHOD(get_ServicePack)(BSTR *pbstrSP);
    STDMETHOD(get_HostMajorVer)(long *plMajorVer);
    STDMETHOD(get_HostMinorVer)(long *plMajorVer);
    STDMETHOD(get_StatusValue)(long nIndex, long *pnStatus);

    HRESULT FireScriptNotify(BSTR bstrIdent, VARIANT vInfoF);

    #define LOCK_MACH_LOCALS(pObj)  CMachLock local_lock(pObj);

protected:
    virtual BOOL  Init();
    virtual DWORD ThreadMain();

    BOOL HandleThreadMessage();

private:
    class CMachLock
    {
    public:
        CMachLock(CMachine *pThis);
       ~CMachLock();

    private:
        CMachine *_pThis;
    };
    friend class CMachLock;

    CMTScript *                 _pMT;
    ITypeInfo *                 _pTypeInfoIMachine;

    CRITICAL_SECTION            _cs;
    CStackPtrAry<IDispatch*, 5> _aryDispSink;
};

inline
CMachine::CMachLock::CMachLock(CMachine *pThis)
    : _pThis(pThis)
{
    EnterCriticalSection(&_pThis->_cs);
}

inline
CMachine::CMachLock::~CMachLock()
{
    LeaveCriticalSection(&_pThis->_cs);
}


//+---------------------------------------------------------------------------
//
//  Class:      CMachConnectPoint (mcp)
//
//  Purpose:    Implements IConnectionPoint for CMachine
//
//----------------------------------------------------------------------------

class CMachConnectPoint : public IConnectionPoint
{
public:

    CMachConnectPoint(CMachine *pMach);
   ~CMachConnectPoint();

    DECLARE_STANDARD_IUNKNOWN(CMachConnectPoint);

    STDMETHOD(GetConnectionInterface)(IID * pIID);
    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer ** ppCPC);
    STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);
    STDMETHOD(EnumConnections)(LPENUMCONNECTIONS * ppEnum);

    CMachine *_pMachine;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\hostobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       hostobj.h
//
//  Contents:   Contains the main application object
//
//----------------------------------------------------------------------------


//****************************************************************************
//
// Forward declarations
//
//****************************************************************************

class CScriptHost;
class CMachine;
class CProcessThread;
class CStatusDialog;

//****************************************************************************
//
// Classes
//
//****************************************************************************

//+---------------------------------------------------------------------------
//
//  Class:      CMTScript (cmt)
//
//  Purpose:    Class which runs the main thread for the process.
//
//----------------------------------------------------------------------------

#define MAX_STATUS_VALUES 16 // Maximum allowed StatusValue values.
class CMTScript : public CThreadComm
{
    friend int PASCAL WinMain(HINSTANCE hInstance,
                              HINSTANCE hPrevInstance,
                              LPSTR     lpCmdLine,
                              int       nCmdShow);

    friend LRESULT CALLBACK
           MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    friend class CConfig;

public:
    CMTScript();
   ~CMTScript();

    DECLARE_STANDARD_IUNKNOWN(CMTScript);

    // Script Debugging helpers
    IProcessDebugManager * _pPDM;
    IDebugApplication    * _pDA;
    DWORD                  _dwAppCookie;

    CScriptHost *GetPrimaryScript();
    CProcessThread *GetProcess(int index);
    BOOL GetScriptNames(TCHAR *pchBuffer, long *pcBuffer);

    // These methods are thread safe.

    HRESULT          AddProcess(CProcessThread *pProc);
    CProcessThread * FindProcess(DWORD dwProcId);
    HRESULT          get_StatusValue(long nIndex, long *pnStatus);
    HRESULT          put_StatusValue(long nIndex, long nStatus);

    // Hack function to work around JSCRIPT.DLL bug
    HRESULT          HackCreateInstance(REFCLSID, IUnknown *, DWORD, REFIID, LPVOID*);

    BOOL SetScriptPath(const TCHAR *pszScriptPath, const TCHAR *pszInitScript);

    BOOL            _fHackVersionChecked;
    IClassFactory * _pJScriptFactory;

    HRESULT RunScript(LPWSTR bstrPath, VARIANT *pvarParams);
protected:
    virtual BOOL  Init();
    virtual DWORD ThreadMain();

    void    InitScriptDebugger();
    void    DeInitScriptDebugger();
    BOOL    ConfigureUI();
    void    CleanupUI();
    HRESULT LoadTypeLibraries();

    void ShowMenu(int x, int y);
    void Reboot();
    void Restart();
    void OpenStatusDialog();
    void HandleThreadMessage();

    HRESULT UpdateOptionSettings(BOOL fSave);

    void CleanupOldProcesses();

private:
    BOOL _fInDestructor;
    BOOL _fRestarting;
    HWND _hwnd;
    CStatusDialog *_pStatusDialog;

public:
    struct OPTIONSETTINGS : public CThreadLock
    {
        OPTIONSETTINGS();

        static void GetModulePath(CStr *pstr);

        void GetScriptPath(CStr *cstrPage); // internally does a LOCK_LOCALS

        void GetInitScript(CStr *cstr); // internally does a LOCK_LOCALS

        CStr  cstrScriptPath;
        CStr  cstrInitScript;
    };

    ITypeLib              * _pTypeLibEXE;
    ITypeInfo             * _pTIMachine;
    IGlobalInterfaceTable * _pGIT;

    // _rgnStatusValues: Simple array of status values -- Multithreaded access, but no locking necessary
    long                    _rgnStatusValues[MAX_STATUS_VALUES];

    // ***************************
    //   THREAD-SAFE MEMBER DATA
    //   All access to the following members must be protected by LOCK_LOCALS()
    //   or InterlockedXXX.
    //
    OPTIONSETTINGS  _options;
    CMachine*       _pMachine;

    VARIANT         _vPublicData;
    VARIANT         _vPrivateData;

    DWORD           _dwPublicDataCookie;
    DWORD           _dwPrivateDataCookie;

    DWORD           _dwPublicSerialNum;
    DWORD           _dwPrivateSerialNum;

    CStackPtrAry<CScriptHost*, 10> _aryScripts;

    CStackPtrAry<CProcessThread*, 10> _aryProcesses;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\mem.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       mem.h
//
//  Contents:   Memory utility functions (has leak tracking in debug)
//
//----------------------------------------------------------------------------


EXTERN_C void *  _MemAlloc(ULONG cb);
EXTERN_C void *  _MemAllocClear(ULONG cb);
EXTERN_C HRESULT _MemRealloc(void ** ppv, ULONG cb);
EXTERN_C ULONG   _MemGetSize(void * pv);
EXTERN_C void    _MemFree(void * pv);
HRESULT          _MemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MemAllocString(ULONG cch, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MemReplaceString(LPCTSTR pchSrc, LPTSTR * ppchDest);
void __cdecl     _MemSetName(void * pv, char * szFmt, ...);
#define          _MemFreeString(pch) _MemFree(pch)

#if defined(MEMGUARD)

#define MemAlloc(cb)                            _MgMemAlloc(cb)
#define MemAllocClear(cb)                       _MgMemAllocClear(cb)
#define MemRealloc(ppv, cb)                     _MgMemRealloc(ppv, cb)
#define MemGetSize(pv)                          _MgMemGetSize(pv)
#define MemFree(pv)                             _MgMemFree(pv)
#define MemAllocString(pch, ppch)               _MgMemAllocString(pch, ppch)
#define MemAllocStringBuffer(cch, pch, ppch)    _MgMemAllocString(cch, pch, ppch)
#define MemReplaceString(pch, ppch)             _MgMemReplaceString(pch, ppch)
#define MemFreeString(pch)                      _MgMemFreeString(pch)

#else

#define MemAlloc(cb)                            _MemAlloc(cb)
#define MemAllocClear(cb)                       _MemAllocClear(cb)
#define MemRealloc(ppv, cb)                     _MemRealloc(ppv, cb)
#define MemGetSize(pv)                          _MemGetSize(pv)
#define MemFree(pv)                             _MemFree(pv)
#define MemAllocString(pch, ppch)               _MemAllocString(pch, ppch)
#define MemAllocStringBuffer(cch, pch, ppch)    _MemAllocString(cch, pch, ppch)
#define MemReplaceString(pch, ppch)             _MemReplaceString(pch, ppch)
#define MemFreeString(pch)                      _MemFreeString(pch)

#endif

#if DBG == 1
#define MemSetName                              DbgExMemSetName
#else
#define MemSetName                              0&&
#endif

inline void * __cdecl operator new(size_t cb)           { return MemAlloc(cb); }
inline void * __cdecl operator new[](size_t cb)         { return MemAlloc(cb); }
inline void * __cdecl operator new(size_t cb, int mt)   { return MemAlloc(cb); }
inline void * __cdecl operator new[](size_t cb, int mt) { return MemAlloc(cb); }
inline void * __cdecl operator new(size_t cb, void * pv){ return pv; }
inline void   __cdecl operator delete(void *pv)         { MemFree(pv); }
inline void   __cdecl operator delete[](void *pv)       { MemFree(pv); }

#define DECLARE_MEMALLOC_NEW_DELETE() \
    inline void * __cdecl operator new(size_t cb) { return(MemAlloc(cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAlloc(cb)); } \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMCLEAR_NEW_DELETE() \
    inline void * __cdecl operator new(size_t cb) { return(MemAllocClear(cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAllocClear(cb)); } \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\f3debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
// File:      F3DEBUG.H
//
// Contains:  Debugging stuff -- uses MSHTML's mshtmdbg.dll for debugging
//            utilities.
//
//            Stolen from Trident
//
//--------------------------------------------------------------------------

#include <mshtmdbg.h>

//--------------------------------------------------------------------------
// Assert, Verify && WHEN_DBG
//--------------------------------------------------------------------------

#if defined(_M_IX86)
    #define F3DebugBreak() _asm { int 3 }
#else
    #define F3DebugBreak() DebugBreak()
#endif

#if DBG != 1

#define Verify(x)   x
#define Assert(x)
#define AssertSz(x, sz)
#define IF_DBG(x)
#define WHEN_DBG(x)
#define IF_NOT_DBG(x) x
#define WHEN_NOT_DBG(x) x
#define StartupAssert(x)
#define AssertThreadDisable(fb)


#else // #if DBG != 1

#define AssertThreadDisable(fDisable)   DbgExAssertThreadDisable(fDisable)

extern DWORD g_dwFALSE;

#define Verify(x)       Assert(x)
#define Assert(x)       do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, #x))\
                               F3DebugBreak(); } while (g_dwFALSE)

#define AssertSz(x, sz) do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, sz))\
                               F3DebugBreak(); } while (g_dwFALSE)

#define AssertLocSz(x, File, Line, sz)   do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(File, Line, sz))\
                               F3DebugBreak(); } while (g_dwFALSE)
#define IF_DBG(x) x
#define WHEN_DBG(x) x
#define IF_NOT_DBG(x)
#define WHEN_NOT_DBG(x)


#define concat_name(x, y) x##y
#define concat_line_impl(x, y) concat_name(x, y)
#define concat_LINE(x) concat_line_impl(x, __LINE__)

//
// Startup assertion:
// The assertion is called by initializing a global variable with
// a function that performs the assertion and returns 1. The name
// of the global variable and function name are suffixed with the
// line number to make them unique. Unfortunatly, one cannot just
// write StartupAssert_##__LINE__, because __LINE__ is not an
// argument to the macro and so the expansion is, e.g. StartupAssert__##53.
// So we indirect through another macro which concatenates its
// two arguments.
//

#define StartupAssert(x)                                                    \
static int                                                                  \
concat_LINE(StartupAssert_) ()                                              \
{                                                                           \
    Assert(x);                                                              \
    return 1;                                                               \
}                                                                           \
                                                                            \
static int concat_LINE(g_StartupAssert_) = concat_LINE(StartupAssert_)()    \

#endif // #if DBG != 1

//--------------------------------------------------------------------------
// Trace Tags
//--------------------------------------------------------------------------

#if DBG != 1
    #define TraceTag(x)
    #define TraceTagEx(x)
    #define TaggedTraceListEx(tag, usFlags, szFmt, valMarker)
    #define TraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescription)
    #define DeclareTagOther(tag, szOwner, szDescription)
    #define ExternTag(tag)
    #define IsTagEnabled(tag) FALSE
    #define EnableTag(tag, fEnable)
    #define SetDiskFlag(tag, fSendToDisk)
    #define SetBreakFlag(tag, fBreak)
    #define FindTag(szTagDesc) NULL
    #define PerfDbgTag(tag, szOwner, szDescrip) \
            PerfTag(tag, szOwner, szDescrip)
    #define PerfDbgExtern(tag) \
            PerfExtern(tag)
    #define PerfDbgLog(tag,pv,f) PerfLog(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) PerfLog1(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) PerfLog2(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) PerfLog3(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) PerfLog4(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfLogFn x
    #define IsPerfDbgEnabled(tag) IsPerfEnabled(tag)

#else
    #define TraceTag(x)                         \
        do                                      \
        {                                       \
            if (TaggedTrace x)                  \
                F3DebugBreak();                 \
        } while  (g_dwFALSE)

    #define TraceTagEx(x)                       \
        do                                      \
        {                                       \
            if (TaggedTraceEx x)                \
                F3DebugBreak();                 \
        } while  (g_dwFALSE)

    #define TraceCallers(tag, iStart, cTotal)   \
        TaggedTraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescrip) \
        TRACETAG tag(DbgExTagRegisterTrace(szOwner, szDescrip, FALSE));
    #define DeclareTagOther(tag, szOwner, szDescrip) \
        TRACETAG tag(DbgExTagRegisterOther(szOwner, szDescrip, FALSE));
    #define ExternTag(tag) extern TRACETAG tag;
    #define PerfDbgTag(tag, szOwner, szDescrip) DeclareTag(tag, szOwner, szDescrip)
    #define PerfDbgExtern(tag) ExternTag(tag)
    #define PerfDbgLog(tag,pv,f) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfDbgLogFn x
    #define IsPerfDbgEnabled(tag) IsTagEnabled(tag)

    int __cdecl PerfDbgLogFn(int tag, void * pvObj, char * pchFmt, ...);

    // Tag trace functions

    #define TaggedTrace         DbgExTaggedTrace
    #define TaggedTraceEx       DbgExTaggedTraceEx
    #define TaggedTraceListEx   DbgExTaggedTraceListEx
    #define TaggedTraceCallers  DbgExTaggedTraceCallers

    // TaggedTraceEx usFlags parameter defines

    #define TAG_NONAME      0x01
    #define TAG_NONEWLINE   0x02
    #define TAG_USECONSOLE  0x04
    #define TAG_INDENT      0x08
    #define TAG_OUTDENT     0x10

    // Register a new tag.

    // Standard tags
    #define tagError                DbgExTagError()
    #define tagWarning              DbgExTagWarning()
    #define tagThread               DbgExTagThread()
    #define tagAssertExit           DbgExTagAssertExit()
    #define tagAssertStacks         DbgExTagAssertStacks()
    #define tagMemoryStrict         DbgExTagMemoryStrict()
    #define tagCoMemoryStrict       DbgExTagCoMemoryStrict()
    #define tagMemoryStrictTail     DbgExTagMemoryStrictTail()
    #define tagMemoryStrictAlign    DbgExTagMemoryStrictAlign()
    #define tagOLEWatch             DbgExTagOLEWatch()
    #define tagPerf                 DbgExTagPerf()

    // Get/Set tag enabled status.

    #define IsTagEnabled            DbgExIsTagEnabled
    #define EnableTag               DbgExEnableTag
    #define SetDiskFlag             DbgExSetDiskFlag
    #define SetBreakFlag            DbgExSetBreakFlag
    #define FindTag                 DbgExFindTag

#endif

//--------------------------------------------------------------------------
// Memory Allocation
//--------------------------------------------------------------------------

#if DBG != 1

    #define DbgPreAlloc(cb)             cb
    #define DbgPostAlloc(pv)            pv
    #define DbgPreFree(pv)              pv
    #define DbgPostFree()
    #define DbgPreRealloc(pv, cb, ppv)  cb
    #define DbgPostRealloc(pv)          pv
    #define DbgPreGetSize(pv)           pv
    #define DbgPostGetSize(cb)          cb
    #define DbgPreDidAlloc(pv)          pv
    #define DbgPostDidAlloc(pv, fAct)   fAct

    #define DbgMemoryTrackDisable(fb)
    #define DbgCoMemoryTrackDisable(fb)
    #define DbgMemoryBlockTrackDisable(pv)

    #define CHECK_HEAP()

#else

    #define DbgPreAlloc                 DbgExPreAlloc
    #define DbgPostAlloc                DbgExPostAlloc
    #define DbgPreFree                  DbgExPreFree
    #define DbgPostFree                 DbgExPostFree
    #define DbgPreRealloc               DbgExPreRealloc
    #define DbgPostRealloc              DbgExPostRealloc
    #define DbgPreGetSize               DbgExPreGetSize
    #define DbgPostGetSize              DbgExPostGetSize
    #define DbgPreDidAlloc              DbgExPreDidAlloc
    #define DbgPostDidAlloc             DbgExPostDidAlloc

    #define DbgMemoryTrackDisable       DbgExMemoryTrackDisable
    #define DbgCoMemoryTrackDisable     DbgExCoMemoryTrackDisable
    #define DbgMemoryBlockTrackDisable  DbgExMemoryBlockTrackDisable

    //
    // Use the CHECK_HEAP macro to do thorough heap validation.
    //
    BOOL CheckSmallBlockHeap();
    #define CHECK_HEAP()    Assert(DbgExValidateInternalHeap() && CheckSmallBlockHeap() && "Corrupted heap!")

#endif


//+---------------------------------------------------------------------
//  Interface tracing.
//----------------------------------------------------------------------

#if DBG == 1 && !defined(WIN16)
    #define DbgTrackItf     DbgExTrackItf
#else
    #define DbgTrackItf(iid, pch, fTrackOnQi, ppv)
#endif

//--------------------------------------------------------------------------
// Failure testing
//--------------------------------------------------------------------------

#if DBG == 1 && defined(__cplusplus)

#define SetSimFailCounts    DbgExSetSimFailCounts
#define GetFailCount        DbgExGetFailCount
#define TraceFailL          DbgExTraceFailL
#define TraceWin32L         DbgExTraceWin32L
#define TraceHR             DbgExTraceHR
#define TraceOLE            DbgExTraceOLE
#define TraceEnter          DbgExTraceEnter
#define TraceExit           DbgExTraceExit

template <class t> inline t
TraceFail(t errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) DbgExTraceFailL((LONG_PTR) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

template <class t> inline t
TraceWin32(t errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) DbgExTraceWin32L((LONG_PTR) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

// disabled TraceEnter, we don't need it at this time
#undef TraceEnter
#define TraceEnter(x, y, z) NULL

#define TFAIL(e, x)             (TraceEnter(#x, __FILE__, __LINE__), TraceFail( (x), (e), FALSE, #x, __FILE__, __LINE__))
#define TW32(e, x)              (TraceEnter(#x, __FILE__, __LINE__), TraceWin32((x), (e), FALSE, #x, __FILE__, __LINE__))
#define THR(x)                  (TraceEnter(#x, __FILE__, __LINE__), TraceHR((x), FALSE, #x, __FILE__, __LINE__))

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (TraceEnter(#x, __FILE__, __LINE__), (void) TraceFail((x), (e), TRUE, #x, __FILE__, __LINE__))
#define IGNORE_W32(e,x)         (TraceEnter(#x, __FILE__, __LINE__), (void) TraceWin32((x), (e), TRUE, #x, __FILE__, __LINE__))
#define IGNORE_HR(x)            (TraceEnter(#x, __FILE__, __LINE__), (void) TraceHR((x), TRUE, #x, __FILE__, __LINE__))

#else // #if DBG == 1

#define SetSimFailCounts(firstFailure, cInterval)

#define TFAIL(e, x)             (x)
#define TW32(e, x)              (x)
#define THR(x)                  (x)

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (x)
#define IGNORE_W32(e,x)         (x)
#define IGNORE_HR(x)            (x)

#endif // #if DBG == 1

//+-------------------------------------------------------------------------
//  Return tracing
//--------------------------------------------------------------------------

#if DBG == 1

    #define SRETURN(hr) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, -1)
    #define RRETURN(hr) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 0)
    #define RRETURN1(hr, s1) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2(hr, s1, s2) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3(hr, s1, s2, s3) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 3, (s1), (s2), (s3))
    #define RRETURN4(hr, s1, s2, s3, s4) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 4, (s1), (s2), (s3), (s4))

    #define SRETURN_NOTRACE(hr) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, -1)
    #define RRETURN_NOTRACE(hr) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 0)
    #define RRETURN1_NOTRACE(hr, s1) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2_NOTRACE(hr, s1, s2) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3_NOTRACE(hr, s1, s2, s3) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 3, (s1), (s2), (s3))
    #define RRETURN4_NOTRACE(hr, s1, s2, s3, s4) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 4, (s1), (s2), (s3), (s4))

#else   // DBG == 0

    #define SRETURN(hr)                 return (hr)
    #define RRETURN(hr)                 return (hr)
    #define RRETURN1(hr, s1)            return (hr)
    #define RRETURN2(hr, s1, s2)        return (hr)
    #define RRETURN3(hr, s1, s2, s3)    return (hr)
    #define RRETURN4(hr, s1, s2, s3, s4)return (hr)

    #define SRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN1_NOTRACE(hr, s1)            return (hr)
    #define RRETURN2_NOTRACE(hr, s1, s2)        return (hr)
    #define RRETURN3_NOTRACE(hr, s1, s2, s3)    return (hr)
    #define RRETURN4_NOTRACE(hr, s1, s2, s3, s4)return (hr)

#endif  // DBG

//+-------------------------------------------------------------------------
//  Stack Spew
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
EXTERN_C void InitChkStk(DWORD);
#pragma check_stack(on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\dynary.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       formsary.hxx
//
//  Contents:   CImplAry* classes
//
//              Stolen from Trident
//
//----------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
// This is the implementation of the generic resizeable array classes. There
// are four array classes:
//
// CPtrAry<ELEM> --
//
//       Dynamic array class which is optimized for sizeof(ELEM) equal
//       to 4. The array is initially empty with no space or memory allocated
//       for data.
//
// CDataAry<ELEM> --
//
//       Same as CPtrAry but where sizeof(ELEM) is != 4 and less than 128.
//
// CStackPtrAry<ELEM, N> --
//
//       Dynamic array class optimized for sizeof(ELEM) equal to 4.
//       Space for N elements is allocated as member data of the class. If
//       this class is created on the stack, then space for N elements will
//       be created on the stack. The class can grow beyond N elements, at
//       which point memory will be allocated for the array data.
//
// CStackDataAry<ELEM, N> --
//
//       Same as CStackPtrAry, but where sizeof(ELEM) is != 4 and less than 128.
//
//
// All four classes have virtually the same methods, and are used the same.
// The only difference is that the DataAry classes have AppendIndirect and
// InsertIndirect, while the PtrAry classes use Append and Insert. The reason
// for the difference is that the Indirect methods take a pointer to the data,
// while the non-indirect methods take the actual data as an argument.
//
// The Stack arrays (CStackPtrAry and CStackDataAry) are used to pre-allocate
// space for elements in the array. This is useful if you create the array on
// the stack and you know that most of the time the array will be less than
// a certain number of elements. Creating one of these arrays on the stack
// allocates the array on the stack as well, preventing a separate memory
// allocation. Only if the array grows beyond the initial size will any
// additional memory be allocated.
//
// The fastest and most efficient way of looping through all elements in
// the array is as follows:
//
//            ELEM * pElem;
//            int    i;
//
//            for (i = aryElems.Size(), pElem = aryElems;
//                 i > 0;
//                 i--, pElem++)
//            {
//                (*pElem)->DoSomething();
//            }
//
// This loop syntax has been shown to be the fastest and produce the smallest
// code. Here's an example using a real data type:
//
//            CStackPtrAry<CSite*, 16> arySites;
//            CSite **ppSite;
//            int     i;
//
//            // Populate the array.
//            ...
//
//            // Now loop through every element in the array.
//            for (i = arySites.Size(), ppSite = arySites;
//                 i > 0;
//                 i--, ppSite++)
//            {
//                (*ppSite)->DoSomething();
//            }
//
// METHOD DESCRIPTIONS:
//
// Commonly used methods:
//
//        Size()             Returns the number of elements currently stored
//                           in the array.
//
//        operator []        Returns the given element in the array.
//
//        Item(int i)        Returns the given element in the array.
//
//        operator ELEM*     Allows the array class to be cast to a pointer
//                           to ELEM. Returns a pointer to the first element
//                           in the array. (Same as a Base() method).
//
//        Append(ELEM e)     Adds a new pointer to the end of the array,
//                           growing the array if necessary.  Only valid
//                           for arrays of pointers (CPtrAry, CStackPtrAry).
//
//        AppendIndirect(ELEM *pe, ELEM** ppePlaced)
//                           As Append, for non-pointer arrays
//                           (CDataAry, CStackDataAry).
//                           pe [in] - Pointer to element to add to array. The
//                                     data is copied into the array. Can be
//                                     NULL, in which case the new element is
//                                     initialized to all zeroes.
//                           ppePlaced [out] - Returns pointer to the new
//                                     element. Can be NULL.
//
//        Insert(int i, ELEM e)
//                           Inserts a new element (e) at the given index (i)
//                           in the array, growing the array if necessary. Any
//                           elements at or following the index are moved
//                           out of the way.
//
//        InsertIndirect(int i, ELEM *pe)
//                           As Insert, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        Find(ELEM e)       Returns the index at which a given element (e)
//                           is found (CPtrAry, CStackPtrAry).
//
//        FindIndirect(ELEM *pe)
//                           As Find, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        DeleteAll()        Empties the array and de-allocates associated
//                           memory.
//
//        Delete(int i)      Deletes an element of the array, moving any
//                           elements that follow it to fill
//
//        DeleteMultiple(int start, int end)
//                           Deletes a range of elements from the array,
//                           moving to fill. [start] and [end] are the indices
//                           of the start and end elements (inclusive).
//
//        DeleteByValue(ELEM e)
//                           Delete the element matching the given value.
//
//        DeleteByValueIndirect(ELEM *pe)
//                           As DeleteByValue, for non-pointer arrays.
//                                    (CDataAry, CStackDataAry).
//
//
// Less commonly used methods:
//
//        EnsureSize(long c) If you know how many elements you are going to put
//                          in the array before you actually do it, you can use
//                          EnsureSize to allocate the memory all at once instead
//                          of relying on Append(Indirect) to grow the array. This
//                          can be much more efficient (by causing only a single
//                          memory allocation instead of many) than just using
//                          Append(Indirect). You pass in the number of elements
//                          that memory should be allocated for. Note that this
//                          does not affect the "Size" of the array, which is
//                          the number of elements currently stored in it.
//
//        SetSize(int c)    Sets the "Size" of the array, which is the number
//                          of elements currently stored in it. SetSize will not
//                          allocate memory if you're growing the array.
//                          EnsureSize must be called first to reserve space if
//                          the array is growing. Setting the size smaller does
//                          not de-allocate memory, it just chops off the
//                          elements at the end of the array.
//
//        Grow(int c)       Equivalent to calling EnsureSize(c) followed by
//                          SetSize(c).
//
//        ReleaseAll()      (CPtrAry and CStackPtrAry only) Calls Release()
//                          on each element in the array and empties the array.
//
//        ReleaseAndDelete(int idx)
//                          (CPtrAry and CStackPtrAry only) Calls Release() on
//                          the given element and removes it from the array.
//
//           (See the class definitions below for signatures of the following
//            methods and src\core\cdutil\formsary.cxx for argument
//            descriptions)
//
//        CopyAppend        Appends data from another array (of the same type)
//                          to the end.
//
//        Copy              Copies data from another array (of the same type)
//                          into this array, replacing any existing data.
//
//        CopyAppendIndirect  Appends data from a C-style array of element data
//                          to the end of this array.
//
//        CopyIndirect      Copies elements from a C-style array into this array
//                          replacing any existing data.
//
//        EnumElements      Create an enumerator which supports the given
//                          interface ID for the contents of the array
//
//        EnumVARIANT       Create an IEnumVARIANT enumerator.
//
//        operator void *   Allow the CImplAry class to be cast
//                          to a (void *). Avoid using if possible - use
//                          the type-safe operator ELEM * instead.
//
//        ClearAndReset     Obsolete. Do not use.
//
//
//----------------------------------------------------------------------------





//----------------------------------------------------------------------------
//
// Class:     CImplAry
//
// Purpose:   Base implementation of all the dynamic array classes.
//
// Interface:
//
//        Deref       Returns a pointer to an element of the array;
//                    should only be used by derived classes. Use the
//                    type-safe methods operator[] or Item() instead.
//
//        GetAlloced  Get number of elements allocated
//
//  Members:    _c          Current size of the array
//              _pv         Buffer storing the elements
//
//  Note:       The CImplAry class only supports arrays of elements
//              whose size is less than 128.
//
//-------------------------------------------------------------------------


class CImplAry
{
    friend class CImplPtrAry;

private:
                DECLARE_MEMALLOC_NEW_DELETE();
public:
                ~CImplAry();
    inline int         Size() const    { return _c; } // UNIX: long->int for min() macro
    inline void        SetSize(int c)  { _c = c; }
    inline operator void *()           { return PData(); }
    void        DeleteAll();

    // BUGBUG -- This method should be protected, but I don't want to convert
    // existing code that uses it. (lylec)
    void *      Deref(size_t cb, int i);

#if DBG == 1
    BOOL _fCheckLock ; // If set with TraceTag CImplAryLock then any change
                       // (addition or deletion to the DataAry will generate an assert.

    void        LockCheck(BOOL fState)
      { _fCheckLock = fState; }
#else
    void        LockCheck(BOOL)
      {  }
#endif

    NO_COPY(CImplAry);

protected:

    //  Methods which are wrapped by inline subclass methods

                CImplAry();

    HRESULT     EnsureSize(size_t cb, long c);
    HRESULT     Grow(size_t cb, int c);
    HRESULT     AppendIndirect(size_t cb, void * pv, void ** ppvPlaced=NULL);
    HRESULT     InsertIndirect(size_t cb, int i, void * pv);
    int         FindIndirect(size_t cb, void *);

    void        Delete(size_t cb, int i);
    BOOL        DeleteByValueIndirect(size_t cb, void *pv);
    void        DeleteMultiple(size_t cb, int start, int end);

    HRESULT     CopyAppend(size_t cb, const CImplAry& ary, BOOL fAddRef);
    HRESULT     Copy(size_t cb, const CImplAry& ary, BOOL fAddRef);
    HRESULT     CopyIndirect(size_t cb, int c, void * pv, BOOL fAddRef);

    ULONG       GetAlloced(size_t cb);

    HRESULT     EnumElements(
                        size_t  cb,
                        REFIID  iid,
                        void ** ppv,
                        BOOL    fAddRef,
                        BOOL    fCopy = TRUE,
                        BOOL    fDelete = TRUE);

    HRESULT     EnumVARIANT(
                        size_t  cb,
                        VARTYPE         vt,
                        IEnumVARIANT ** ppenum,
                        BOOL            fCopy = TRUE,
                        BOOL            fDelete = TRUE);

    inline BOOL        UsingStackArray()
                    { return _fDontFree; }

    UINT        GetStackSize()
                    { Assert(_fStack);
                      return *(UINT*)((BYTE*)this + sizeof(CImplAry)); }
    void *      GetStackPtr()
                    { Assert(_fStack);
                      return (void*)((BYTE*)this + sizeof(CImplAry) + sizeof(int)); }

    unsigned long   _fStack     :1  ;  // Set if we're a stack-based array.
    unsigned long   _fDontFree  :1  ;  // Cleared if _pv points to alloced memory.
    unsigned long   _c          :30 ; // Count of elements

    void *      _pv;

    inline void * & PData()    { return _pv; }
};

//+------------------------------------------------------------------------
//
//  Member:     CImplAry::CImplAry
//
//+------------------------------------------------------------------------
inline
CImplAry::CImplAry()
{
    memset(this, 0, sizeof(CImplAry));
}

//+------------------------------------------------------------------------
//
//  Member:     CImplAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  i
//
//  Returns:    void *
//
//-------------------------------------------------------------------------

inline void *
CImplAry::Deref(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(ULONG( i ) < GetAlloced(cb));
    return ((BYTE *) PData()) + i * cb;
}

//+------------------------------------------------------------------------
//
//  Class:      CImplPtrAry (ary)
//
//  Purpose:    Subclass used for arrays of pointers.  In this case, the
//              element size is known to be sizeof(void *).  Normally, the
//              CPtrAry template is used to define a specific concrete
//              implementation of this class, to hold a specific type of
//              pointer.
//
//              See documentation above for use.
//
//-------------------------------------------------------------------------

class CImplPtrAry : public CImplAry
{
protected:
    DECLARE_MEMALLOC_NEW_DELETE();

    CImplPtrAry() : CImplAry() {};

    HRESULT     Append(void * pv);
    HRESULT     Insert(int i, void * pv);
    int         Find(void * pv);
    BOOL        DeleteByValue(void *pv);

    HRESULT     CopyAppend(const CImplAry& ary, BOOL fAddRef);
    HRESULT     Copy(const CImplAry& ary, BOOL fAddRef);
    HRESULT     CopyIndirect(int c, void * pv, BOOL fAddRef);


public:

    HRESULT     ClearAndReset();

    HRESULT     EnsureSize(long c);

    HRESULT     Grow(int c);

    void        Delete(int i);
    void        DeleteMultiple(int start, int end);

    void        ReleaseAll();
    void        ReleaseAndDelete(int idx);
};


//+---------------------------------------------------------------------------
//
//  Class:      CDataAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplAry.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM>
class CDataAry : public CImplAry
{
public:
    DECLARE_MEMALLOC_NEW_DELETE();

    CDataAry() : CImplAry() { }
    operator ELEM *() { return (ELEM *)PData(); }
    CDataAry(const CDataAry &);

    ELEM & Item(int i) { return *(ELEM*)Deref(sizeof(ELEM), i); }

    HRESULT     EnsureSize(long c)
                    { return CImplAry::EnsureSize(sizeof(ELEM), c); }
    HRESULT     Grow(int c)
                    { return CImplAry::Grow(sizeof(ELEM), c); }
    HRESULT     AppendIndirect(ELEM * pe, ELEM ** ppePlaced=NULL)
                    { return CImplAry::AppendIndirect(sizeof(ELEM), (void*)pe, (void**)ppePlaced); }
    ELEM *      Append()
                    { ELEM * pElem; return AppendIndirect( NULL, & pElem ) ? NULL : pElem; }
    HRESULT     InsertIndirect(int i, ELEM * pe)
                    { return CImplAry::InsertIndirect(sizeof(ELEM), i, (void*)pe); }
    int         FindIndirect(ELEM * pe)
                    { return CImplAry::FindIndirect(sizeof(ELEM), (void*)pe); }

    void        Delete(int i)
                    { CImplAry::Delete(sizeof(ELEM), i); }
    BOOL        DeleteByValueIndirect(ELEM *pe)
                    { return CImplAry::DeleteByValueIndirect(sizeof(ELEM), (void*)pe); }
    void        DeleteMultiple(int start, int end)
                    { CImplAry::DeleteMultiple(sizeof(ELEM), start, end); }

    HRESULT     CopyAppend(const CDataAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplAry::Copy(sizeof(ELEM), ary, fAddRef); }
    HRESULT     Copy(const CDataAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplAry::Copy(sizeof(ELEM), ary, fAddRef); }
    HRESULT     CopyIndirect(int c, ELEM * pv, BOOL fAddRef)
                    { return CImplAry::CopyIndirect(sizeof(ELEM), c, (void*)pv, fAddRef); }
};

//+---------------------------------------------------------------------------
//
//  Class:      CPtrAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplPtrAry.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM>
class CPtrAry : public CImplPtrAry
{
public:
    DECLARE_MEMALLOC_NEW_DELETE();

    CPtrAry() : CImplPtrAry() { Assert(sizeof(ELEM) == sizeof(void*)); }
    operator ELEM *() { return (ELEM *)PData(); }
    CPtrAry(const CPtrAry &);

    ELEM & Item(int i) { return *(ELEM*)Deref(sizeof(ELEM), i); }

    HRESULT     Append(ELEM e)
                    { return CImplPtrAry::Append((void*)e); }
    HRESULT     Insert(int i, ELEM e)
                    { return CImplPtrAry::Insert(i, (void*)e); }
    BOOL        DeleteByValue(ELEM e)
                    { return CImplPtrAry::DeleteByValue((void*)e); }
    int         Find(ELEM e)
                    { return CImplPtrAry::Find((void*)e); }

    HRESULT     CopyAppend(const CPtrAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplPtrAry::Copy(ary, fAddRef); }
    HRESULT     Copy(const CPtrAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplPtrAry::Copy(ary, fAddRef); }
    HRESULT     CopyIndirect(int c, ELEM *pe, BOOL fAddRef)
                    { return CImplPtrAry::CopyIndirect(c, (void*)pe, fAddRef); }

};

//+---------------------------------------------------------------------------
//
//  Class:      CStackDataAry
//
//  Purpose:    Declares a CDataAry that has initial storage on the stack.
//              N elements are declared on the stack, and the array will
//              grow dynamically beyond that if necessary.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM, int N>
class CStackDataAry : public CDataAry<ELEM>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE();

    CStackDataAry() : CDataAry<ELEM>()
    {
        _cStack     = N;
        _fStack     = TRUE;
        _fDontFree  = TRUE;
        PData()     = (void *) & _achTInit;
    }

protected:
    int   _cStack;                     // Must be first data member.
    char  _achTInit[N*sizeof(ELEM)];
};

//+---------------------------------------------------------------------------
//
//  Class:      CStackPtrAry
//
//  Purpose:    Same as CStackDataAry except for pointer types.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM, int N>
class CStackPtrAry : public CPtrAry<ELEM>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE();

    CStackPtrAry() : CPtrAry<ELEM>()
    {
        _cStack     = N;
        _fStack     = TRUE;
        _fDontFree  = TRUE;
        PData()     = (void *) & _achTInit;
    }

protected:
    int   _cStack;                     // Must be first data member.
    char  _achTInit[N*sizeof(ELEM)];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\regsettingsio.h ===
#ifndef REGSETTINGSIO_H
#define REGSETTINGSIO_H

#define MAX_REG_VALUE_LENGTH   50
extern const WCHAR *g_szRegistry;

enum RKI_TYPE
{
    RKI_KEY,
    RKI_BOOL,
    RKI_DWORD,
    RKI_STRING,
    RKI_EXPANDSZ
};

struct REGKEYINFORMATION
{
    TCHAR *   pszName;            // Name of the value or key
    BYTE      rkiType;            // Type of entry
    size_t    cbOffset;           // Offset of member to store data in
};

HRESULT RegSettingsIO(const WCHAR *szRegistry, BOOL fSave, const REGKEYINFORMATION *aKeyValues, int cKeyValues, BYTE *pBase);

HRESULT ChangeAppIDACL(REFGUID AppID, LPTSTR Principal, BOOL fAccess, BOOL SetPrincipal, BOOL Permit);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\msgbox.h ===
#define IDD_MESSAGEBOX              200
#define IDD_BUTTON1                 101
#define IDD_BUTTON2                 102
#define IDD_BUTTON3                 103
#define IDD_BUTTON4                 104
#define IDD_BUTTON5                 105
#define IDD_TIMEMSG                 107
#define IDD_TIME                    108
#define IDD_CANCELCOUNT             109
#define IDD_MESSAGE                 111
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\mshtmdbg.h ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       mshtmdbg.h
//
//  Contents:   External include file for mshtmdbg.dll
//
// ----------------------------------------------------------------------------

#ifndef _MSHTMDBG_H_
#define _MSHTMDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

#define MSHTMDBG_API_VERSION    (4)     // Increment whenever API changes

typedef INT     TRACETAG;
typedef INT_PTR PERFTAG;
typedef INT_PTR PERFMETERTAG;

DWORD       WINAPI  DbgExGetVersion();
BOOL        WINAPI  DbgExIsFullDebug();
void        WINAPI  DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));

void        WINAPI  DbgExDoTracePointsDialog(BOOL fWait);
void        WINAPI  DbgExRestoreDefaultDebugState();

BOOL        WINAPI  DbgExEnableTag(TRACETAG tag, BOOL fEnable);
BOOL        WINAPI  DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk);
BOOL        WINAPI  DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak);
BOOL        WINAPI  DbgExIsTagEnabled(TRACETAG tag);
TRACETAG    WINAPI  DbgExFindTag(char * szTagDesc);

TRACETAG    WINAPI  DbgExTagError();
TRACETAG    WINAPI  DbgExTagWarning();
TRACETAG    WINAPI  DbgExTagThread();
TRACETAG    WINAPI  DbgExTagAssertExit();
TRACETAG    WINAPI  DbgExTagAssertStacks();
TRACETAG    WINAPI  DbgExTagMemoryStrict();
TRACETAG    WINAPI  DbgExTagCoMemoryStrict();
TRACETAG    WINAPI  DbgExTagMemoryStrictTail();
TRACETAG    WINAPI  DbgExTagMemoryStrictAlign();
TRACETAG    WINAPI  DbgExTagOLEWatch();
TRACETAG    WINAPI  DbgExTagRegisterTrace(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagRegisterOther(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagPerf();

BOOL        __cdecl DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...);
BOOL        __cdecl DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...);
BOOL        WINAPI  DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker);
void        WINAPI  DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal);

BOOL        WINAPI  DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage);
void        WINAPI  DbgExAssertThreadDisable(BOOL fDisable);
HRESULT     __cdecl DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...);
HRESULT     WINAPI  DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker);

size_t      WINAPI  DbgExPreAlloc(size_t cbRequest);
void *      WINAPI  DbgExPostAlloc(void *pv);
void *      WINAPI  DbgExPreFree(void *pv);
void        WINAPI  DbgExPostFree();
size_t      WINAPI  DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv);
void *      WINAPI  DbgExPostRealloc(void *pv);
void *      WINAPI  DbgExPreGetSize(void *pvRequest);
size_t      WINAPI  DbgExPostGetSize(size_t cb);
void *      WINAPI  DbgExPreDidAlloc(void *pvRequest);
BOOL        WINAPI  DbgExPostDidAlloc(void *pvRequest, BOOL fActual);

void        WINAPI  DbgExMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExCoMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExMemoryBlockTrackDisable(void * pv);
void        WINAPI  DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt);
void *      WINAPI  DbgExGetMallocSpy();
void        WINAPI  DbgExTraceMemoryLeaks();
BOOL        WINAPI  DbgExValidateInternalHeap();

LONG_PTR    WINAPI  DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
LONG_PTR    WINAPI  DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite);
void        WINAPI  DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExSetSimFailCounts(int firstFailure, int cInterval);
void        WINAPI  DbgExShowSimFailDlg();
BOOL        WINAPI  DbgExFFail();
int         WINAPI  DbgExGetFailCount();
void        WINAPI  DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv);

void        WINAPI  DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize);
void        WINAPI  DbgExOpenMemoryMonitor();
void        WINAPI  DbgExOpenLogFile(LPCSTR szFName);

void *      __cdecl DbgExMemSetName(void *pvRequest, char * szFmt, ...);
void *      WINAPI  DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list valMarker);
char *      WINAPI  DbgExMemGetName(void *pvRequest);

HRESULT     WINAPI  DbgExWsClear(HANDLE hProcess);
HRESULT     WINAPI  DbgExWsTakeSnapshot(HANDLE hProcess);
BSTR        WINAPI  DbgExWsGetModule(long row);
BSTR        WINAPI  DbgExWsGetSection(long row);
long        WINAPI  DbgExWsSize(long row);
long        WINAPI  DbgExWsCount();
long        WINAPI  DbgExWsTotal();
HRESULT     WINAPI  DbgExWsStartDelta(HANDLE hProcess);
long        WINAPI  DbgExWsEndDelta(HANDLE hProcess);

void        WINAPI  DbgExDumpProcessHeaps();

PERFTAG     WINAPI  DbgExPerfRegister(char * szTag, char * szOwner, char * szDescrip);
void        __cdecl DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...);
void        WINAPI  DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker);
void        WINAPI  DbgExPerfDump();
void        WINAPI  DbgExPerfClear();
void        WINAPI  DbgExPerfTags();

char *      WINAPI  DbgExDecodeMessage(UINT msg);

PERFMETERTAG WINAPI  DbgExMtRegister(char * szTag, char * szOwner, char * szDescrip);
void        WINAPI  DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG lVal);
void        WINAPI  DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG lVal);
char *      WINAPI  DbgExMtGetName(PERFMETERTAG mt);
char *      WINAPI  DbgExMtGetDesc(PERFMETERTAG mt);
BOOL        WINAPI  DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG lNewValue);
void        WINAPI  DbgExMtOpenMonitor();
void        WINAPI  DbgExMtLogDump(LPSTR pchFile);

void        WINAPI  DbgExSetTopUrl(LPWSTR pstrUrl);
void        WINAPI  DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf);

BOOL        WINAPI  DbgExGetChkStkFill(DWORD * pdwFill);

#ifdef __cplusplus
}
#endif

// Performance Logging --------------------------------------------------------

#ifdef PERFTAGS

#define     IsPerfEnabled(tag) (*(BOOL *)tag)
#define     PerfTag(tag, szOwner, szDescrip) PERFTAG tag(DbgExPerfRegister(#tag, szOwner, szDescrip));
#define     PerfExtern(tag) extern PERFTAG tag;
#define     PerfLog(tag,pv,f) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f) : 0
#define     PerfLog1(tag,pv,f,a1) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1) : 0
#define     PerfLog2(tag,pv,f,a1,a2) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2) : 0
#define     PerfLog3(tag,pv,f,a1,a2,a3) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3) : 0
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4) : 0
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5) : 0
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6) : 0
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) : 0
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) : 0
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) : 0
#define     PerfDump()  DbgExPerfDump()
#define     PerfClear() DbgExPerfClear()
#define     PerfTags()  DbgExPerfTags()

#else

#define     IsPerfEnabled(tag) (FALSE)
#define     PerfTag(tag, szOwner, szDescrip)
#define     PerfExtern(tag)
#define     PerfLog(tag,pv,f)
#define     PerfLog1(tag,pv,f,a1)
#define     PerfLog2(tag,pv,f,a1,a2)
#define     PerfLog3(tag,pv,f,a1,a2,a3)
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4)
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define     PerfDump()
#define     PerfClear()
#define     PerfTags()

#endif

// Performance Metering -------------------------------------------------------

#ifdef PERFMETER

#define     Mt(x)                               g_mt##x
#define     MtExtern(tag)                       extern PERFMETERTAG g_mt##tag;
#define     MtDefine(tag, tagOwner, szDescrip)  PERFMETERTAG g_mt##tag(DbgExMtRegister("mt" #tag, "mt" #tagOwner, szDescrip));
#define     MtAdd(mt, lCnt, lVal)               DbgExMtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)               DbgExMtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewVal)  DbgExMtSimulateOutOfMemory(mt, lNewVal)
#define     MtOpenMonitor()                     DbgExMtOpenMonitor()

#else

#define     Mt(x)                               0
#define     MtExtern(tag)
#define     MtDefine(tag, szOwner, szDescrip)
#define     MtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewValue)
#define     MtOpenMonitor()

#endif

// MSHTML perf control --------------------------------------------------------

#define HTMPERFCTL_NAME     "#MSHTML#PERF#"

enum
{
    HTMPF_CALLBACK_ONLOAD   = 0x00000001,   // callback when topdoc loaded
    HTMPF_ENABLE_PROFILE    = 0x00000002,   // enable profiling
    HTMPF_ENABLE_MEMWATCH   = 0x00000004,   // enable memwatch sampling
    HTMPF_DISABLE_PADEVENTS = 0x00000008,   // disable firing of events from mshtmpad.exe
    HTMPF_DISABLE_IMGCACHE  = 0x00000010,   // disable image cache in mshtml
    HTMPF_DISABLE_OFFSCREEN = 0x00000020,   // disable offscreen buffering
};

typedef void (WINAPI *HTMPFCBFN)(DWORD dwArg1, void * pvArg2);

typedef struct HTMPERFCTL
{
    DWORD       dwSize;     // set to sizeof(MSHTMLPERF)
    DWORD       dwFlags;    // see HTMPF_*
    HTMPFCBFN   pfnCall;    // Callback function
    void *      pvHost;     // Private data for host
} HTMPERFCTL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\process.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       process.h
//
//  Contents:   CProcessThread class definition
//
//----------------------------------------------------------------------------

#define PIPE_BUFFER_SIZE 1024

class CProcessComm;

//+---------------------------------------------------------------------------
//
//  Class:      CProcessParams
//
//  Purpose:    Provide simple free store management for PROCESS_PARAMS
//
//----------------------------------------------------------------------------
class CProcessParams : public PROCESS_PARAMS
{
public:
        CProcessParams();
        ~CProcessParams();

//      CProcessParams &operator =(const PROCESS_PARAMS &params);
        bool Copy(const PROCESS_PARAMS *params);

private:
        void Free();
        bool Assign(const PROCESS_PARAMS &params);
};

//+---------------------------------------------------------------------------
//
//  Class:      CProcessThread (cpt)
//
//  Purpose:    Class which spawns a process, monitors its success, talks to
//              it during execution if necessary, and returns its completion
//              status. (each CProcessThread is in its own thread)
//
//----------------------------------------------------------------------------

class CProcessThread  : public CThreadComm
{
public:
    CProcessThread(CScriptHost *pSH);
   ~CProcessThread();

    DECLARE_STANDARD_IUNKNOWN(CProcessThread);

    DWORD  ProcId()    { return _piProc.dwProcessId; }

    // Thread-Safe member functions. These can be called by any thread to
    // get the appropriate information without having to go through
    // PostToThread. These are only safe AFTER the process has been started.

    HRESULT GetProcessOutput(BSTR *pbstrOutput);
    DWORD   GetExitCode();
    void    SetExitCode(DWORD dwExitCode)
               {
                   _dwExitCode = dwExitCode;
                   _fUseExitCode = TRUE;
               }
    void    Terminate();

    ULONG   GetDeadTime();
    BOOL    IsOwner(DWORD dwProcID, long lID)
                 { return (lID == _lEnvID); }

    CScriptHost * ScriptHost()
                 { return _pSH; }

    void SetProcComm(CProcessComm *pPC)
                 { Assert(!_pPC || !pPC); _pPC = pPC; }
    CProcessComm * GetProcComm()
                 { return _pPC; }

        const PROCESS_PARAMS *GetParams() const { return &_ProcParams; }
protected:

    virtual DWORD ThreadMain();
    virtual BOOL  Init();

    void HandleThreadMessage();
    void HandleProcessExit();
    BOOL IsDataInPipe();
    void ReadPipeData();
    void CheckIoPort();

    HRESULT LaunchProcess(const PROCESS_PARAMS *pProcParams);
    void    GetProcessEnvironment(CStr *pcstr, BOOL fNoEnviron);

private:
    CScriptHost        *_pSH;
    CProcessComm       *_pPC;          // Not AddRef'd

    PROCESS_INFORMATION _piProc;
    long                _lEnvID;

    DWORD               _dwExitCode;   // Value set explicitely by the process
    BOOL                _fUseExitCode; // TRUE if _dwExitCode is the code we want

    HANDLE              _hPipe;
    BYTE                _abBuffer[PIPE_BUFFER_SIZE];

    HANDLE              _hJob;
    HANDLE              _hIoPort;

    CStackPtrAry<DWORD, 10> _aryProcIds;

    CProcessParams      _ProcParams;

    _int64              _i64ExitTime;

    // Access to the following members must be thread-safe (by calling
    // LOCK_LOCALS).
    CStr                _cstrOutput;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\mtverp.h ===
// DO NOT Edit this file w/o consulting with the PTT Build tools team!

// Change VER_PRODUCTBUILD and VER_PRODUCTBUILD_QFE as appropriate.
#ifndef MTSCRIPT_BUILDNUMBER
#error MTSCRIPT_BUILDNUMBER must be defined for official builds!
#endif

#ifndef MTSCRIPT_QFENUMBER
#error MTSCRIPT_QFENUMBER must be defined for official builds!
#endif

#define VER_MAJOR_PRODUCTVER            1
#define VER_MINOR_PRODUCTVER            00
#define VER_PRODUCTBUILD                MTSCRIPT_BUILDNUMBER
#define VER_PRODUCTBUILD_QFE            MTSCRIPT_QFENUMBER

#define VER_PRODUCTVERSION              VER_MAJOR_PRODUCTVER,VER_MINOR_PRODUCTVER,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W            (0x0100)
#define VER_PRODUCTVERSION_DW           (0x01000000 | VER_PRODUCTBUILD)

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft(R) MultiThreaded Script Engine"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows (R) is a registered trademark of Microsoft Corporation."

// READ THIS

// Do not change VER_PRODUCTVERSION_STRING.
//
// The code below will take VER_PRODUCTVERSION_STRING and create a version
// string that includes the QFE number & etc.
//

#define VER_PRODUCTBETA_STR             ""
#define VER_PRODUCTVERSION_STRING       "1.00"

#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\proccomm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       proccomm.h
//
//  Contents:   Contains the definition of CProcessComm
//
//----------------------------------------------------------------------------

class CProcessComm : public IScriptedProcess
{
public:

    CProcessComm(CMTScript *pMT);
   ~CProcessComm();

    DECLARE_MEMCLEAR_NEW_DELETE();

    DECLARE_STANDARD_IUNKNOWN(CProcessComm);

    // IScriptedProcess methods

    STDMETHOD(SetProcessID)(long lProcessID, wchar_t *pszEnvID);
    STDMETHOD(SendData)(wchar_t * pszType,
                        wchar_t * pszData,
                        long *plReturn);
    STDMETHOD(SetExitCode)(long lExitCode);
    STDMETHOD(SetProcessSink)(IScriptedProcessSink * pSPS);


    void SendToProcess(MACHPROC_EVENT_DATA *pmed);

private:

    CMTScript            *_pMT;
    IScriptedProcessSink *_pSink;
    CScriptHost          *_pSH;
    CProcessThread       *_pProc;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\resizer.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       resizer.h
//
//  Contents:   Dialog resizer class
//
//----------------------------------------------------------------------------

#ifndef RESIZER_H
#define RESIZER_H
struct CResizeInfo
{
    UINT _id;
    int  _Flags;
    RECT _Rect;
};

class CResizer
{
public:
    enum sizeflags
    {
        sf_Width         = 0x01,
        sf_Height        = 0x02,
        sf_Left          = 0x04,
        sf_Top           = 0x08,
        sf_HalfLeftWidth = 0x10,
        sf_HalfTopHeight = 0x20,
        sf_HalfWidth     = 0x40,
        sf_HalfHeight    = 0x80
    };
    CResizer();
    ~CResizer();

    void Init(HWND win, CResizeInfo *pResizeInfo);
    void NewSize() const;
private:
    HWND _hWnd;
    RECT _winRect;
    CResizeInfo *_pResizeInfo;

    void InitCtrl(CResizeInfo *p);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\script.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       bsscript.h
//
//  Contents:   Script engine classes
//
//----------------------------------------------------------------------------

class CScriptHost;
class CProcessThread;

// Helper class to make initialization
// and freeing of VARIANTARGs foolproof.
// Can be used anywhere a VARIANTARG
// would be used.
class AutoVariant : public VARIANTARG
{
public:
    AutoVariant()
    {
        VariantInit( (VARIANTARG *) this);
    }
    BOOL Set(long value)
    {
        V_VT(this) = VT_I4;
        V_I4(this) = value;
        return TRUE;
    }
    BOOL Set(TCHAR *value)
    {
        V_VT(this) = VT_BSTR;
        V_BSTR(this) = SysAllocString(value); // NULL is a valid value for BSTR
        if (value && !V_BSTR(this))
            return FALSE;
        return TRUE;
    }
    ~AutoVariant()
    {
        VariantClear( (VARIANTARG *) this);
    }
};

//+------------------------------------------------------------------------
//
//  Class:      CScriptSite
//
//  Purpose:    Active scripting site
//
//-------------------------------------------------------------------------

class CScriptSite :
    public IActiveScriptSite,
    public IActiveScriptSiteWindow,
    public IActiveScriptSiteDebug,
    public IProvideMultipleClassInfo,
    public IConnectionPointContainer,
    public IGlobalMTScript
{
public:

    DECLARE_MEMCLEAR_NEW_DELETE();

    CScriptSite(CScriptHost * pSH);
   ~CScriptSite();

    HRESULT Init(LPWSTR pszName);
    void    Close();
    void    Abort();

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IActiveScriptSite methods

    STDMETHOD(GetLCID)(LCID *plcid);
    STDMETHOD(GetItemInfo)(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppiunkItem, ITypeInfo **ppti);
    STDMETHOD(GetDocVersionString)(BSTR *pszVersion);
    STDMETHOD(RequestItems)(void);
    STDMETHOD(RequestTypeLibs)(void);
    STDMETHOD(OnScriptTerminate)(const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo);
    STDMETHOD(OnStateChange)(SCRIPTSTATE ssScriptState);
    STDMETHOD(OnScriptError)(IActiveScriptError *pscripterror);
    STDMETHOD(OnEnterScript)(void);
    STDMETHOD(OnLeaveScript)(void);

    // IActiveScriptSiteWindow methods

    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(EnableModeless)(BOOL fEnable);

    // IActiveScriptSiteDebug methods

    STDMETHOD(GetDocumentContextFromPosition)(DWORD dwSourceContext,
                                              ULONG uCharacterOffset,
                                              ULONG uNumChars,
                                              IDebugDocumentContext **ppsc);

    STDMETHOD(GetApplication)(IDebugApplication **ppda);
    STDMETHOD(GetRootApplicationNode)(IDebugApplicationNode **ppdanRoot);
    STDMETHOD(OnScriptErrorDebug)(IActiveScriptErrorDebug *pErrorDebug,
                                  BOOL *pfEnterDebugger,
                                  BOOL *pfCallOnScriptErrorWhenContinuing);

    // IProvideClassInfo methods

    STDMETHOD(GetClassInfo)(ITypeInfo **);
    STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID * pGUID);

    // IProvideMultipleClassInfo methods

    STDMETHOD(GetMultiTypeInfoCount)(ULONG *pcti);
    STDMETHOD(GetInfoOfIndex)(ULONG iti, DWORD dwFlags, ITypeInfo** pptiCoClass, DWORD* pdwTIFlags, ULONG* pcdispidReserved, IID* piidPrimary, IID* piidSource);

    // IConnectionPointContainer methods

    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS*);
    STDMETHOD(FindConnectionPoint)(REFIID, LPCONNECTIONPOINT*);

    // IBServer methods
    // We need to implement these on a separate identity from
    // the main pad object in order to prevent ref count loops
    // with the script engine.

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

    STDMETHOD(get_PublicData)(VARIANT *);
    STDMETHOD(put_PublicData)(VARIANT);
    STDMETHOD(get_PrivateData)(VARIANT *);
    STDMETHOD(put_PrivateData)(VARIANT);
    STDMETHOD(ExitProcess)();
    STDMETHOD(Restart)();
    STDMETHOD(get_LocalMachine)(BSTR *);
    STDMETHOD(Include)(BSTR);
    STDMETHOD(CallScript)(BSTR, VARIANT *);
    STDMETHOD(SpawnScript)(BSTR, VARIANT *);
    STDMETHOD(get_ScriptParam)(VARIANT *);
    STDMETHOD(get_ScriptPath)(BSTR *);
    STDMETHOD(CallExternal)(BSTR, BSTR, VARIANT *, long *);
    STDMETHOD(ResetSync)(const BSTR);
    STDMETHOD(WaitForSync)(BSTR, long, VARIANT_BOOL *);
    STDMETHOD(WaitForMultipleSyncs)(const BSTR, VARIANT_BOOL, long, long *);
    STDMETHOD(SignalThreadSync)(BSTR);
    STDMETHOD(TakeThreadLock)(BSTR);
    STDMETHOD(ReleaseThreadLock)(BSTR);
    STDMETHOD(DoEvents)();
    STDMETHOD(MessageBoxTimeout)(BSTR, long, BSTR, long, long, VARIANT_BOOL, VARIANT_BOOL, long *);
    STDMETHOD(RunLocalCommand)(BSTR, BSTR, BSTR, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, long *);
    STDMETHOD(GetLastRunLocalError)(long *);
    STDMETHOD(GetProcessOutput)(long, BSTR *);
    STDMETHOD(GetProcessExitCode)(long, long *);
    STDMETHOD(TerminateProcess)(long);
    STDMETHOD(SendToProcess)(long, BSTR, BSTR, long *);
    STDMETHOD(SendMail)(BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, long *);
    STDMETHOD(SendSMTPMail)(BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, long *);
    STDMETHOD(ASSERT)(VARIANT_BOOL, BSTR);
    STDMETHOD(OUTPUTDEBUGSTRING)(BSTR);
    STDMETHOD(UnevalString)(BSTR, BSTR*);
    STDMETHOD(CopyOrAppendFile)(BSTR bstrSrc,BSTR bstrDst,long nSrcOffset,long nSrcLength,VARIANT_BOOL  fAppend,long *nSrcFilePosition);
    STDMETHOD(Sleep)(int);
    STDMETHOD(Reboot)();
    STDMETHOD(NotifyScript)(BSTR, VARIANT);
    STDMETHOD(RegisterEventSource)(IDispatch *pDisp, BSTR bstrProgID);
    STDMETHOD(UnregisterEventSource)(IDispatch *pDisp);
    STDMETHOD(get_HostMajorVer)(long *pVer);
    STDMETHOD(get_HostMinorVer)(long *pVer);
    STDMETHOD(get_StatusValue)(long nIndex, long *pnStatus);
    STDMETHOD(put_StatusValue)(long nIndex, long nStatus);

    // Other methods

    HRESULT ExecuteScriptStr(TCHAR * pchScript);
    HRESULT ExecuteScriptFile(TCHAR *pchPath);
    HRESULT SetScriptState(SCRIPTSTATE ss);

    CScriptHost * ScriptHost() { return _pSH; }

    // Member variables
    CStr                        _cstrName;
    ULONG                       _ulRefs;
    CScriptSite *               _pScriptSitePrev;
    IActiveScript *             _pScript;
    CScriptHost*                _pSH;
    TCHAR                       _achPath[MAX_PATH];
    VARIANT                     _varParam;
    IDispatch *                 _pDispSink;
    IDebugDocumentHelper      * _pDDH;  // Script Debugging helper
    DWORD                       _dwSourceContext;
    BOOL                        _fInDebugError;

private:
    BOOL                        _fInScriptError;
};

class AutoCriticalSection : public CRITICAL_SECTION
{
public:
    AutoCriticalSection()
    {
        InitializeCriticalSection(this);
    }
    ~AutoCriticalSection()
    {
        DeleteCriticalSection(this);
    }
};

class CScriptHost :
        public CThreadComm,
        public IGlobalMTScript
{
    friend class CScriptEventSink;

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CScriptHost(CMTScript *  pBS,
                BOOL         fPrimary,
                BOOL         fDispatchOnly);

   ~CScriptHost();

    DECLARE_STANDARD_IUNKNOWN(CScriptHost);

    // Script management

    HRESULT LoadTypeLibrary();
    HRESULT PushScript(TCHAR *pchType);
    HRESULT PopScript();
    HRESULT CloseScripts();
    HRESULT AbortScripts();
    HRESULT ExecuteTopLevelScript(TCHAR *pchPath, VARIANT *pvarParams);
    HRESULT ExecuteTopLevelScriptlet(TCHAR *pchScript);

    long    FireScriptErrorEvent(
                                TCHAR *bstrFile,
                                long nLine,
                                long nChar,
                                TCHAR *bstrText,
                                long sCode,
                                TCHAR *bstrSource,
                                TCHAR *bstrDescription);
    long    FireScriptErrorEvent(TCHAR *szMsg);
    void    FireProcessEvent(THREADMSG mt, CProcessThread *pProc);
    void    FireMachineEvent(MACHPROC_EVENT_DATA *pmed, BOOL fExec);
    void    FireEvent(DISPID, UINT cArg, VARIANTARG *pvararg, VARIANTARG *pvarResult);
    void    FireEvent(DISPID, UINT cArg, VARIANTARG *pvararg);
    void    FireEvent(DISPID, LPCTSTR);
    void    FireEvent(DISPID, BOOL);
    void    FireEvent(DISPID, IDispatch *pDisp);

    BOOL    GetMachineDispatch(LPSTR achName,
                               IConnectedMachine **ppMach);

    static HRESULT GetSyncEventName(int nEvent, CStr *pCStr, HANDLE *phEvent);
    static HRESULT GetSyncEvent(LPCTSTR pszName, HANDLE *phEvent);
    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

    // IGlobalMTScript interface

    STDMETHOD(get_PublicData)(VARIANT *);
    STDMETHOD(put_PublicData)(VARIANT);
    STDMETHOD(get_PrivateData)(VARIANT *);
    STDMETHOD(put_PrivateData)(VARIANT);
    STDMETHOD(ExitProcess)();
    STDMETHOD(Restart)();
    STDMETHOD(get_LocalMachine)(BSTR *);
    STDMETHOD(Include)(BSTR);
    STDMETHOD(CallScript)(BSTR, VARIANT *);
    STDMETHOD(SpawnScript)(BSTR, VARIANT *);
    STDMETHOD(get_ScriptParam)(VARIANT *);
    STDMETHOD(get_ScriptPath)(BSTR *);
    STDMETHOD(CallExternal)(BSTR, BSTR, VARIANT *, long *);
    STDMETHOD(ResetSync)(const BSTR);
    STDMETHOD(WaitForSync)(BSTR, long, VARIANT_BOOL *);
    STDMETHOD(WaitForMultipleSyncs)(const BSTR, VARIANT_BOOL, long, long *);
    STDMETHOD(SignalThreadSync)(BSTR);
    STDMETHOD(TakeThreadLock)(BSTR);
    STDMETHOD(ReleaseThreadLock)(BSTR);
    STDMETHOD(DoEvents)();
    STDMETHOD(MessageBoxTimeout)(BSTR, long, BSTR, long, long, VARIANT_BOOL, VARIANT_BOOL, long *);
    STDMETHOD(RunLocalCommand)(BSTR, BSTR, BSTR, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, long *);
    STDMETHOD(GetLastRunLocalError)(long *);
    STDMETHOD(GetProcessOutput)(long, BSTR *);
    STDMETHOD(GetProcessExitCode)(long, long *);
    STDMETHOD(TerminateProcess)(long);
    STDMETHOD(SendToProcess)(long, BSTR, BSTR, long *);
    STDMETHOD(SendMail)(BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, long *);
    STDMETHOD(SendSMTPMail)(BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, long *);
    STDMETHOD(ASSERT)(VARIANT_BOOL, BSTR);
    STDMETHOD(OUTPUTDEBUGSTRING)(BSTR);
    STDMETHOD(UnevalString)(BSTR, BSTR*);
    STDMETHOD(CopyOrAppendFile)(BSTR bstrSrc,BSTR bstrDst,long nSrcOffset,long nSrcLength,VARIANT_BOOL  fAppend,long *nSrcFilePosition);
    STDMETHOD(Sleep)(int);
    STDMETHOD(Reboot)();
    STDMETHOD(NotifyScript)(BSTR, VARIANT);
    STDMETHOD(RegisterEventSource)(IDispatch *pDisp, BSTR bstrProgID);
    STDMETHOD(UnregisterEventSource)(IDispatch *pDisp);
    STDMETHOD(get_HostMajorVer)(long *pVer);
    STDMETHOD(get_HostMinorVer)(long *pVer);
    STDMETHOD(get_StatusValue)(long nIndex, long *pnStatus);
    STDMETHOD(put_StatusValue)(long nIndex, long nStatus);

    CScriptSite *  GetSite() { return _pScriptSite; }
    void GetScriptPath(CStr *pcstrPath);

    CMTScript *                 _pMT;
    CScriptSite *               _pScriptSite;

    BOOL                        _fIsPrimaryScript;
    BOOL                        _fMustExitThread;
    BOOL                        _fDontHandleEvents;
    ITypeInfo *                 _pTypeInfoIGlobalMTScript;
    ITypeInfo *                 _pTypeInfoCMTScript;
    ITypeLib *                  _pTypeLibEXE;

    VARIANT                     _vPubCache;
    VARIANT                     _vPrivCache;
    DWORD                       _dwPublicSN;
    DWORD                       _dwPrivateSN;

    long                        _lTimerInterval;

    HRESULT                     _hrLastRunLocalError;

    CStackPtrAry<CScriptEventSink*, 5> _aryEvtSinks;

protected:
    virtual DWORD ThreadMain();
    void HandleThreadMessage();

    enum MEP_RETURN
    {
        MEP_TIMEOUT,       // Timeout period expired
        MEP_EXIT,          // Thread is terminating
        MEP_FALLTHROUGH,   // No event occurred (fWait==FALSE only)
        MEP_EVENT_0,       // The given event(s) are signaled
    };

    DWORD MessageEventPump(BOOL     fWait,
                           UINT     cEvents   = 0,
                           HANDLE * pEvents   = NULL,
                           BOOL     fAll      = FALSE,
                           DWORD    dwTimeout = INFINITE,
                           BOOL     fNoEvents = FALSE);


    HRESULT StringToEventArray(const wchar_t *pszNameList, CStackPtrAry<HANDLE, 5> *aryEvents);
    HRESULT GetLockCritSec(LPTSTR             pszName,
                           CRITICAL_SECTION **ppcs,
                           DWORD            **ppdwOwner);

    struct SYNCEVENT
    {
        CStr   _cstrName;
        HANDLE _hEvent;
    };

    struct THREADLOCK
    {
        CStr             _cstrName;
        CRITICAL_SECTION _csLock;
        DWORD            _dwOwner;
    };

    // MAX_LOCKS is used because you can't move critical section objects
    // in memory once you've initialized them, thus making it impossible to
    // use the dynamic array class.
    #define MAX_LOCKS 10

    // The primary thread owns initialization and cleanup of these objects.
    static CStackDataAry<SYNCEVENT, 5> s_arySyncEvents;
    static THREADLOCK                  s_aThreadLocks[MAX_LOCKS];
    static UINT                        s_cThreadLocks;
    static AutoCriticalSection         s_csSync;
};

//+---------------------------------------------------------------------------
//
//  Class:      CConnectionPoint (ccp)
//
//  Purpose:    Implements IConnectionPoint for the script site
//
//----------------------------------------------------------------------------

class CConnectionPoint : public IConnectionPoint
{
public:

    CConnectionPoint(CScriptSite *pSite);
   ~CConnectionPoint();

    DECLARE_STANDARD_IUNKNOWN(CConnectionPoint);

    STDMETHOD(GetConnectionInterface)(IID * pIID);
    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer ** ppCPC);
    STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);
    STDMETHOD(EnumConnections)(LPENUMCONNECTIONS * ppEnum);

    CScriptSite *_pSite;
};


//+---------------------------------------------------------------------------
//
//  Class:      CMTEventSink (ces)
//
//  Purpose:    Class which sinks events from objects registered with
//              RegisterEventSource().
//
//----------------------------------------------------------------------------

class CScriptEventSink : public IDispatch
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CScriptEventSink(CScriptHost *pSH);
   ~CScriptEventSink();

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN(CScriptEventSink);

    HRESULT Connect(IDispatch *pSource, BSTR bstrProgID);
    void    Disconnect();

    BOOL    IsThisYourSource(IDispatch * pSource)
                { return pSource == _pDispSource; }

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

private:

    CScriptHost * _pSH;
    IDispatch   * _pDispSource;
    DWORD         _dwSinkCookie;
    IID           _clsidEvents;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\threadlock.h ===
#ifndef THREADLOCK_H
#define THREADLOCK_H
class CThreadLock
{
public:
    CThreadLock()
    {
        InitializeCriticalSection(&_csAccess);
    }
    ~CThreadLock()
    {
        DeleteCriticalSection(&_csAccess);
    }
    void ThreadLock()
    {
        EnterCriticalSection(&_csAccess);
    }
    void ThreadUnLock()
    {
        LeaveCriticalSection(&_csAccess);
    }
private:
    CRITICAL_SECTION _csAccess;   // Used to control access to member data

    // Do not allow this object to be copied.
    CThreadLock(const CThreadLock &that);
    operator=(const CThreadLock &that);
};
class CAutoLock
{
public:
    CAutoLock(CThreadLock *pThis) : _pThis(pThis)
    {
        _pThis->ThreadLock();
    }
   ~CAutoLock()
   {
       _pThis->ThreadUnLock();
   }

private:
    CThreadLock *_pThis;
};

//
//
// LOCK_LOCALS() should be used whenever access to thread-safe member data
// is needed.
//
#define LOCK_LOCALS(pObj)  CAutoLock local_lock(pObj);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\thrdcomm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       thrdcomm.h
//
//  Contents:   Contains the inter-thread communication class
//
//----------------------------------------------------------------------------


//****************************************************************************
//
// Forward declarations
//
//****************************************************************************

class CThreadComm;


//****************************************************************************
//
// Classes
//
//****************************************************************************

//+---------------------------------------------------------------------------
//
//  Class:      CThreadComm (ctc)
//
//  Purpose:    Base class which handles cross-thread communication. This
//              is the only class with methods that can safely be called
//              by any thread. All other classes must have their methods
//              called by their owning thread (except the ctor/dtor and Init
//              which are called by the creating thread).
//
//----------------------------------------------------------------------------

class CThreadComm : public IUnknown, public CThreadLock
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    // Thread-unsafe member functions - can only be called by owning (or
    // creating) thread.

    CThreadComm();
   ~CThreadComm();

    HRESULT      StartThread(void * pvParams);
    BOOL         Shutdown(CThreadComm * pTarget);

    static DWORD  TempThreadRoutine(LPVOID pvParam);
    virtual DWORD ThreadMain() = 0;
    // Used to tell StartThread that the new thread is going and has picked
    // up all of its parameters.
    // If fSuccess is false, then the thread will be terminating
    // immediatly, and StartThread() will wait for it to do so.
    void         ThreadStarted(HRESULT hrThread) {
                                   _hrThread = hrThread;
                                   SetEvent(_hThreadReady); // Signal the other thread
                                   ::Sleep(100);          // Yield to the other thread
                                 }

    BOOL GetNextMsg(THREADMSG *tm, void * pData, DWORD *cbData);
    void Reply(DWORD dwReply);

    void SetName(LPCSTR szName);

    // -----------------------------------------------------------------
    //
    // Thread-safe member functions - can be called by any thread.

    HANDLE hThread() { return _hThread; }

    void  PostToThread(CThreadComm *pTarget, THREADMSG tm, void * pData = NULL, DWORD cbData = 0);
    DWORD SendToThread(CThreadComm *pTarget, THREADMSG tm, void * pData = NULL, DWORD cbData = 0);

    // End of thread-safe member list
    //
    // -----------------------------------------------------------------

protected:
    virtual BOOL Init();

    //
    // Every method on objects that derive from CThreadComm should have
    // VERIFY_THREAD at the beginning. VERIFY_THREAD ensures that the proper
    // thread is calling the method (i.e. it ensure that proper apartment rules
    // are being followed.)
    //
    inline void VERIFY_THREAD() { Assert(GetCurrentThreadId() == _dwThreadId); }

    HANDLE           _hThreadReady; // Event signaled when the new thread has set its return value
    HANDLE           _hCommEvent; // Event signaled when there is a message
    DWORD            _dwThreadId;
    HANDLE           _hThread;
    void *           _pvParams;
    HRESULT          _hrThread;   // The new thread sets this for initial success/failure.
private:

    //
    // MSGDATABUFSIZE: Max size of a thread message. The -40 is to keep the
    // MESSAGEDATA struct below 1K.
    //
    #define MSGDATABUFSIZE  (1024 - 40)

    //
    // MESSAGEDATA: All the data associated with a thread message.
    //
    struct MESSAGEDATA
    {
        MESSAGEDATA *pNext;
        THREADMSG    tmMessage;
        DWORD        dwResult;
        HANDLE       hResultEvt;
        DWORD        cbData;
        BYTE         bData[MSGDATABUFSIZE];
    };

#if DBG == 1
    typedef struct tagTHREADNAME_INFO
    {
            DWORD    dwType; // == 0x1000
            LPCSTR   szName;
            DWORD    dwThreadID;
            DWORD    dwFlags;
    } THREADNAME_INFO;
#endif

    DWORD SendHelper(THREADMSG tm,
                     void *    pData,
                     DWORD     cbData,
                     BOOL      fSend,
                     HANDLE    hResultEvt);

    // ***************************
    //   THREAD-SAFE MEMBER DATA
    //   All access to the following members must be protected by LOCK_LOCALS()
    //
    MESSAGEDATA     *_pMsgData;   // Linked list of messages
    BOOL             _fInSend;    // True if we're inside SendToThread -
                                  //   needed to catch deadlock situations.
    MESSAGEDATA    * _pMsgReply;  // Place where we need to put our reply
    HANDLE           _hResultEvt; // Event used to indicate that the result
                                  //   is ready.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\types.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       types.h
//
//  Contents:   Various type definitions
//
//----------------------------------------------------------------------------

#include "config.h"
#include "msgbox.h"
#include "dispid.h"

//****************************************************************************
//
// Defines
//
//****************************************************************************

#define IDR_MAINMENU   100

#define IDM_EXIT       300
#define IDM_CONFIGURE  301
#define IDM_ABOUT      302
#define IDM_TRACETAG   303
#define IDM_MEMORYMON  304
#define IDM_RESTART    305
#define IDM_STATUS     306

#define VB_TRUE     ((VARIANT_BOOL)-1)           // TRUE for VARIANT_BOOL
#define VB_FALSE    ((VARIANT_BOOL)0)            // FALSE for VARIANT_BOOL

#define SZ_APPLICATION_NAME TEXT("MTScript")
#define SZ_WNDCLASS SZ_APPLICATION_NAME TEXT("_HiddenWindow")

#ifndef RC_INVOKED

//****************************************************************************
//
// Globals
//
//****************************************************************************

extern HANDLE    g_hProcHeap;  // Handle to process heap.
extern HINSTANCE g_hInstance;  // Instance handle of this EXE


//****************************************************************************
//
// Function prototypes
//
//****************************************************************************

void ErrorPopup(LPWSTR pszMsg);

#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

void ClearInterfaceFn(IUnknown **ppUnk);

template <class PI>
inline void
ClearInterface(PI * ppI)
{
    ClearInterfaceFn((IUnknown **) ppI);
}

#define ReleaseInterface(x) if (x) { (x)->Release(); }

#define ULREF_IN_DESTRUCTOR 256

#define DECLARE_STANDARD_IUNKNOWN(cls)                              \
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);          \
    ULONG _ulRefs;                                                  \
    STDMETHOD_(ULONG, AddRef) (void)                                \
        {                                                           \
            return InterlockedIncrement((long*)&_ulRefs);           \
        }                                                           \
    STDMETHOD_(ULONG, Release) (void)                               \
        {                                                           \
            if (InterlockedDecrement((long*)&_ulRefs) == 0)         \
            {                                                       \
                _ulRefs = ULREF_IN_DESTRUCTOR;                      \
                delete this;                                        \
                return 0;                                           \
            }                                                       \
            return _ulRefs;                                         \
        }                                                           \
    ULONG GetRefs(void)                                             \
        { return _ulRefs; }

//****************************************************************************
//
// Enums and Structs
//
//****************************************************************************

//
// THREADMSG -- messages that can be sent between threads.
//
enum THREADMSG
{
    MD_SECONDARYSCRIPTTERMINATE,
    MD_MACHINECONNECT,
    MD_MACHEVENTCALL,
    MD_NOTIFYSCRIPT,
    MD_REBOOT,
    MD_RESTART,
    MD_PROCESSEXITED,
    MD_PROCESSTERMINATED,
    MD_PROCESSCRASHED,
    MD_PROCESSCONNECTED,
    MD_PROCESSDATA,
    MD_SENDTOPROCESS,
    MD_OUTPUTDEBUGSTRING,
    MD_PLEASEEXIT
};

enum MBT_SELECT
{
    MBTS_TIMEOUT = 0,
    MBTS_BUTTON1 = 1,
    MBTS_BUTTON2 = 2,
    MBTS_BUTTON3 = 3,
    MBTS_BUTTON4 = 4,
    MBTS_BUTTON5 = 5,
    MBTS_INTERVAL,
    MBTS_ERROR
};

struct MBTIMEOUT
{
    BSTR   bstrMessage;
    long   cButtons;
    BSTR   bstrButtonText;
    long   lTimeout;
    long   lEventInterval;
    BOOL   fCanCancel;
    BOOL   fConfirm;

    HANDLE     hEvent;
    MBT_SELECT mbts;
};

struct SCRIPT_PARAMS
{
    LPTSTR   pszPath;
    VARIANT *pvarParams;
};

struct PROCESS_PARAMS
{
    LPTSTR   pszCommand;
    LPTSTR   pszDir;
    LPTSTR   pszTitle;
    BOOL     fMinimize;
    BOOL     fGetOutput;
    BOOL     fNoEnviron;
    BOOL     fNoCrashPopup;
};

struct MACHPROC_EVENT_DATA
{
    HANDLE    hEvent;
    DWORD     dwProcId;
    BSTR      bstrCmd;
    BSTR      bstrParams;
    VARIANT * pvReturn;
    DWORD     dwGITCookie;
    HRESULT   hrReturn;
};

#endif // RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\localobj\makefile.inc ===
$(O)\selfreg_mtlocal.inf : selfreg.inx
    cleaninf.exe -w selfreg.inx $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\statusdialog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       statusdialog.h
//
//  Contents:   Contains the CStatusDialog class
//
//----------------------------------------------------------------------------
#ifndef STATUSDIALOG_H
#define STATUSDIALOG_H

#include "Resizer.h"

#define MAX_STATUS_MESSAGES 300

class CMTScript;

class CCustomListBox
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();
    CCustomListBox();
    ~CCustomListBox();

    void Refresh() const
    {
        if (_hwnd)
            InvalidateRect(_hwnd, 0, 0);
    }
    // Add another string
    void AppendString(const TCHAR *sz);

    // Change or add a string at a given position.
    void SetString(int nItem, const TCHAR *sz);

    // Shorten the list of strings.
    void SetEnd(int nItems);

    // Clear the contents of the listbox
    void ResetContent();

    // Handle windows messages for this control.
    void Init(HWND dlg, UINT idCtrl);
    void Destroy()
    {
        _hwnd = 0;
    }
    void DrawItem(DRAWITEMSTRUCT *pdis) ;
    void MeasureItem(MEASUREITEMSTRUCT *pmis);
    const TCHAR *GetString(int nItem);
    LRESULT SendMessage(UINT Msg, WPARAM wParam, LPARAM lParam)
    {
        return ::SendMessage(_hwnd, Msg, wParam, lParam);
    }
private:
    HWND _hwnd;                  // The handle to this list

    CPtrAry<TCHAR *> _Messages;
    int _nAllocatedMessageLength;
    int _nExtent;                 // the width of the listbox
};

class CStatusDialog
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CStatusDialog(HWND parent, CMTScript *pMTScript);
    ~CStatusDialog();
    bool Show();

    BOOL IsDialogMessage(MSG *msg);
    void OUTPUTDEBUGSTRING(LPWSTR pszMsg);
    void Refresh();
    void Pause();
    void Restart();

private:

    HWND _parent;                 // Parent window
    HWND _hwnd;                   // me
    WINDOWPLACEMENT _WindowPlacement; // my current size & position
    BOOL _fMaximized;
    RECT _rect;                   // my current size & position
    BOOL _fStatusOpen;            // Used for registry IO
    BOOL _fLogToFile;             // if logging to a file is enabled
    CStr _cstrLogFileName;        // The name of the log file
    BOOL _fPaused;                // Used by Pause/Restart
    CMTScript *_pMTScript;        // Used to retrieve status info
    TCHAR _achLogFileName[MAX_PATH];
    bool _fCreatedLogFileName;    // Have we created the filename for the logfile yet?
    bool _fAddedHeaderToFile;     // Have we put a timestamp line into the logfile yet?

    CCustomListBox _CScriptListBox;
    CCustomListBox _CProcessListBox;
    CCustomListBox _CSignalListBox;
    CCustomListBox _COutputListBox;

    POINT _InitialSize;
    CResizer _Resizer;

    // message handlers
    void InitDialog();
    void Destroy();
    void Resize(int width, int height);
    void GetMinMaxInfo(MINMAXINFO *mmi);
    CCustomListBox *CtrlIDToListBox(UINT CtrlID);
    HRESULT UpdateOptionSettings(BOOL fSave);

    static BOOL CALLBACK DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void PopulateScripts();
    void PopulateSignals();
    void PopulateProcesses();
    void ClearOutput();

    void ToggleSignal();
    void UpdateLogging();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\localobj\factory.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       factory.cxx
//
//  Contents:   Contains the class factory implementation and other DLL
//              functions for the mtlocal DLL.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "mtscript.h"    // MIDL generated file
#include "localobj.h"

#include <advpub.h>     // for RegInstall

HINSTANCE   g_hInstDll;
HINSTANCE   g_hinstAdvPack = NULL;
REGINSTALL  g_pfnRegInstall = NULL;

// Globals used by our utilities.

DWORD           g_dwFALSE      = 0;
EXTERN_C HANDLE g_hProcessHeap = NULL;

// Global class factory

CMTLocalFactory g_LocalFactory;

// ***************************************************************

CMTLocalFactory::CMTLocalFactory()
{
    _ulRefs = 0;
}

STDMETHODIMP
CMTLocalFactory::QueryInterface(REFIID iid, void ** ppvObject)
{
    if (iid == IID_IClassFactory || iid == IID_IUnknown)
    {
        *ppvObject = (IClassFactory*)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObject)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTLocalFactory::CreateInstance, public
//
//  Synopsis:   Creates the CLocalMTProxy object
//
//----------------------------------------------------------------------------

STDMETHODIMP
CMTLocalFactory::CreateInstance(IUnknown * pUnkOuter,
                                REFIID     riid,
                                void **    ppvObject)
{
    HRESULT        hr = E_FAIL;
    CLocalMTProxy *pMTP;

    *ppvObject = NULL;

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }

    pMTP = new CLocalMTProxy();
    if (!pMTP)
    {
        return E_OUTOFMEMORY;
    }

    hr = pMTP->QueryInterface(riid, ppvObject);

    pMTP->Release();

#if DBG == 1
    if (hr)
        TraceTag((tagError, "CreateInstance failed with %x", hr));
#endif

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTLocalFactory::LockServer, public
//
//  Synopsis:   Keeps the DLL from being unloaded
//
//----------------------------------------------------------------------------

STDMETHODIMP
CMTLocalFactory::LockServer(BOOL fLock)
{
    // Because we implement our class factory as a global object, we don't
    // need to worry about keeping it in memory if LockServer is called.

    if (fLock)
    {
        InterlockedIncrement(&g_lObjectCount);
    }
    else
    {
        InterlockedDecrement(&g_lObjectCount);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Main DLL entrypoint.
//
//  Returns:    Doesn't do much except unload advpack.dll if we loaded it.
//
//----------------------------------------------------------------------------

BOOL
WINAPI
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fOk = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstDll = (HINSTANCE)hDll;

        Assert(g_hInstDll != NULL);

        DisableThreadLibraryCalls(g_hInstDll);

        // Set the variable used by our memory allocator.
        g_hProcessHeap = GetProcessHeap();
        break;

    case DLL_PROCESS_DETACH:
        if (g_hinstAdvPack)
        {
            FreeLibrary(g_hinstAdvPack);
        }
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadAdvPack
//
//  Synopsis:   Loads AdvPack.dll for DLL registration.
//
//----------------------------------------------------------------------------

HRESULT
LoadAdvPack()
{
    HRESULT hr = S_OK;

    g_hinstAdvPack = LoadLibrary(_T("ADVPACK.DLL"));

    if (!g_hinstAdvPack)
        goto Error;

    g_pfnRegInstall = (REGINSTALL)GetProcAddress(g_hinstAdvPack, achREGINSTALL);

    if (!g_pfnRegInstall)
        goto Error;

Cleanup:
    return hr;

Error:
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (g_hinstAdvPack)
    {
        FreeLibrary(g_hinstAdvPack);
    }

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Register the various important information needed by our
//              class.
//
//  Notes:      Uses AdvPack.dll and an INF file to do the registration
//
//----------------------------------------------------------------------------

STDAPI
DllRegisterServer()
{
    HRESULT   hr;
    STRTABLE  stReg = { 0, NULL };
    ITypeLib *pTypeLibDLL = NULL;
    TCHAR     achDll[MAX_PATH];

    Assert(g_hInstDll != NULL);

    // Make sure the type library is registered

    GetModuleFileName(g_hInstDll, achDll, MAX_PATH);

    hr = THR(LoadTypeLib(achDll, &pTypeLibDLL));

    if (hr)
        goto Cleanup;

    // This may fail if the user is not an administrator on this machine.
    // It's not a big deal unless they try to run mtscript.exe, but the UI
    // will still work.
    (void) RegisterTypeLib(pTypeLibDLL, achDll, NULL);

    if (!g_hinstAdvPack)
    {
        hr = LoadAdvPack();
        if (hr)
            goto Cleanup;
    }

    hr = g_pfnRegInstall(g_hInstDll, "Register", &stReg);

Cleanup:
    if (pTypeLibDLL)
    {
        pTypeLibDLL->Release();
    }

    RegFlushKey(HKEY_CLASSES_ROOT);

    return hr;
}

//+------------------------------------------------------------------------
//
// Function:    DllUnregisterServer
//
// Synopsis:    Undo the actions of DllRegisterServer.
//
//-------------------------------------------------------------------------

STDAPI
DllUnregisterServer()
{
    HRESULT hr;

    STRTABLE stReg = { 0, NULL };

    Assert(g_hInstDll != NULL);

    if (!g_hinstAdvPack)
    {
        hr = LoadAdvPack();
        if (hr)
            goto Cleanup;
    }

    hr = g_pfnRegInstall(g_hInstDll, "Unregister", &stReg);

    // Unregister the type library

    if (!hr)
    {
        (void) UnRegisterTypeLib(LIBID_MTScriptEngine, 1, 0, 0, SYS_WIN32);
    }

Cleanup:
    RegFlushKey(HKEY_CLASSES_ROOT);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Returns the class factory for a particular object
//
//----------------------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppv)
{
    HRESULT hr;

    if (clsid == CLSID_RemoteMTScriptProxy)
    {
        hr = g_LocalFactory.QueryInterface(iid, ppv);
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Indicates if we can be unloaded.
//
//  Notes:      Returns OK if we currently have no objects running.
//
//----------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    if (g_lObjectCount == 0)
    {
        return S_OK;
    }

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\inc\w4warn.h ===
/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 1994.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#pragma warning(disable:4001) /* nonstandard extension 'extension' was used                            */
#pragma warning(disable:4097) /* typedef name 'type' used as synonym for class 'class'                 */
#pragma warning(disable:4100) /* unreferenced formal parameter                                         */
#pragma warning(disable:4115) /* named type definition in parentheses                                  */
#pragma warning(disable:4127) /* conditional expression is constant                                    */
#pragma warning(disable:4134) /* conversion between pointers to members of same class                  */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union         */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union                    */
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer       */
#pragma warning(disable:4209) /* nonstandard extension used : benign typedef redefinition              */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int           */
#pragma warning(disable:4505) /* unreferenced local function has been removed                          */
#pragma warning(disable:4511) /* 'class' : copy constructor could not be generated                     */
#pragma warning(disable:4512) /* 'class': assignment operator could not be generated                   */
#pragma warning(disable:4514) /* 'function' : unreferenced inline function has been removed            */
#pragma warning(disable:4552) /* operator has no effect; expected operator with side-effect            */
#pragma warning(disable:4553) /* operator has no effect; did you intend '='?                           */
#pragma warning(disable:4705) /* statement has no effect                                               */
#pragma warning(disable:4710) /* function call not expanded                                            */
#pragma warning(disable:4711) /* function 'function' selected for inline expansion                     */
#pragma warning(disable:4068) /* unknown pragma */
/*
 * Warning 4244 is benign more often than not, so if you don't want it then
 * uncomment this to filter out those errors.
 *
 */
#pragma warning(disable:4244) /* conversion from 'type' to 'type', possible loss of data               */

/*
 * This helps to track down "Illegal attempt to instantiate abstract class" messages
 */
#pragma warning(error:4259) /* pure virtual function not defined                                       */

#pragma warning(error:4102) /* 'label' : unreferenced label                                            */

/*
 *   Level 4 warnings that we want treated as level 3 warnings.
 */

// #pragma warning(3:4127) /* conditional expression is constant                                          */
#pragma warning(3:4702) /* unreachable code                                                            */
#pragma warning(3:4706) /* assignment within conditional expression                                    */

#pragma warning(disable:4041) /* compiler limit reached: terminating browser output                    */

#ifdef _MAC
#pragma warning(disable:4229) /* anachronism used : modifiers on data are ignored                      */
#pragma warning(disable:4798) /* pcode: constructors and destructors have native code generated        */
#endif

#ifdef _M_PPC
#pragma warning(disable:4701) /* local variable  may be used without having been initialized           */
#endif

#ifdef _M_IA64
#pragma warning(disable:4268) /* 'variable' : 'const' static/global data initialized with compiler generated default constructor fills the object with zeros */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\localobj\object.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       object.cxx
//
//  Contents:   Implementation of the CLocalMTProxy class and
//              associated objects.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "mtscript.h"    // MIDL generated file
#include "localobj.h"

long g_lObjectCount = 0;

// ***********************************************************************
//
// CLocalProxyCP
//
// ConnectionPoint for CLocalMTProxy
//
// ***********************************************************************

CLocalProxyCP::CLocalProxyCP(CLocalMTProxy *pMach)
{
    _ulRefs = 1;
    _pMTProxy = pMach;
    _pMTProxy->AddRef();
}

CLocalProxyCP::~CLocalProxyCP()
{
    _pMTProxy->Release();
}

HRESULT
CLocalProxyCP::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CLocalProxyCP::GetConnectionInterface(IID * pIID)
{
    *pIID = DIID_DRemoteMTScriptEvents;
    return S_OK;
}

HRESULT
CLocalProxyCP::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    *ppCPC = _pMTProxy;
    (*ppCPC)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalProxyCP::Advise, public
//
//  Synopsis:   Remembers interface pointers that we want to fire events
//              through.
//
//  Arguments:  [pUnkSink]  -- Pointer to remember
//              [pdwCookie] -- Place to put cookie for Unadvise
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CLocalProxyCP::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    IDispatch *pDisp;
    HRESULT    hr;

    TraceTag((tagError, "CLocalProxyCP::Advise: Advising %p", pUnkSink));

    hr = pUnkSink->QueryInterface(IID_IDispatch, (LPVOID*)&pDisp);
    if (hr)
    {
        return hr;
    }

    // We can only keep one sink at a time.

    ReleaseInterface(_pMTProxy->_pDispSink);

    _pMTProxy->_pDispSink = pDisp;

    *pdwCookie = (DWORD)pDisp;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalProxyCP::Unadvise, public
//
//  Synopsis:   Forgets a pointer we remembered during Advise.
//
//  Arguments:  [dwCookie] -- Cookie returned from Advise
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CLocalProxyCP::Unadvise(DWORD dwCookie)
{
    TraceTag((tagError, "CLocalProxyCP::Unadvise: Unadvising %p", dwCookie));

    if (dwCookie == (DWORD)_pMTProxy->_pDispSink)
    {
        ClearInterface(&_pMTProxy->_pDispSink);
    }
    else
        return E_INVALIDARG;

    return S_OK;
}

HRESULT
CLocalProxyCP::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    *ppEnum = NULL;
    RRETURN(E_NOTIMPL);
}

// ***********************************************************************
//
// CLocalMTProxy
//
// ***********************************************************************

CLocalMTProxy::CLocalMTProxy()
{
    _ulRefs = 1;
    _ulAllRefs = 1;

    InterlockedIncrement(&g_lObjectCount);

    Assert(_pTypeInfoInterface == NULL);
    Assert(_pTypeLibDLL == NULL);
}

CLocalMTProxy::~CLocalMTProxy()
{
    ReleaseInterface(_pTypeInfoInterface);
    ReleaseInterface(_pTypeInfoCM);
    ReleaseInterface(_pTypeLibDLL);

    InterlockedDecrement(&g_lObjectCount);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::Passivate, public
//
//  Synopsis:   Called when the refcount for CLocalMTProxy goes to zero. This
//              will cause us to let go of all the objects we hold onto, which
//              in turn should cause everyone else to let go of our subobjects.
//              When that happens we can finally delete ourselves.
//
//----------------------------------------------------------------------------

void
CLocalMTProxy::Passivate()
{
    Disconnect();

    ClearInterface(&_pDispSink);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::QueryInterface, public
//
//  Synopsis:   Standard IUnknown::QueryInterface
//
//----------------------------------------------------------------------------

HRESULT
CLocalMTProxy::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IRemoteMTScriptProxy || iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppvObj = (IRemoteMTScriptProxy *)this;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *ppvObj = (IConnectionPointContainer *)this;
    }
    else if (iid == IID_IProvideClassInfo)
    {
        *ppvObj = (IProvideClassInfo *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::AddRef, public
//
//  Synopsis:   Standard IUnknown::AddRef. Increments the refcount on the
//              CLocalMTProxy object.
//
//----------------------------------------------------------------------------

ULONG
CLocalMTProxy::AddRef()
{
    return ++_ulRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::Release, public
//
//  Synopsis:   IUnknown::Release.
//
//  Notes:      If the refcount on CLocalMTProxy goes to zero, we know our
//              owner is done with us and we can clean up. So, we release
//              all our interface pointers and etc. However, someone may still
//              be holding on to our event sink subobject, so we can't
//              delete ourselves yet.
//
//----------------------------------------------------------------------------

ULONG
CLocalMTProxy::Release()
{
    ULONG ulRefs = --_ulRefs;

    if (ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;

        Passivate();

        AssertSz(_ulRefs == ULREF_IN_DESTRUCTOR,
                 "NONFATAL: Invalid refcount during passivate!");

        _ulRefs = 0;

        SubRelease();
    }

    return ulRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::SubAddRef, public
//
//  Synopsis:   Called when the event sink gets addref'd. Increments an overall
//              refcount.
//
//----------------------------------------------------------------------------

ULONG
CLocalMTProxy::SubAddRef()
{
    return ++_ulAllRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::SubRelease, public
//
//  Synopsis:   Called when the event sink gets released and when
//              CLocalMTProxy passivates.  If the overall refcount is zero,
//              we know no-one is using us and we can go away.
//
//----------------------------------------------------------------------------

ULONG
CLocalMTProxy::SubRelease()
{
    if (--_ulAllRefs == 0)
    {
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }

    return 0;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::EnumConnectionPoints, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::FindConnectionPoint, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT* ppCpOut)
{
    HRESULT hr;

    TraceTag((tagError, "CLocalMTProxy::FindConnectionPoint called."));

    if (iid == DIID_DRemoteMTScriptEvents || iid == IID_IDispatch)
    {
        TraceTag((tagError, "CLocalMTProxy::FindConnectionPoint: Returning event source."));

        *ppCpOut = new CLocalProxyCP(this);
        hr = *ppCpOut ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::GetClassInfo, public
//
//  Synopsis:   Implementation of IProvideClassInfo
//
//  Arguments:  [pTI] -- Return type info interface here
//
//  Notes:      This returns the typeinfo for the RemoteMTScriptProxy coclass
//
//----------------------------------------------------------------------------

HRESULT
CLocalMTProxy::GetClassInfo(ITypeInfo **pTI)
{
    HRESULT hr;

    TraceTag((tagError, "CLocalMTProxy::GetClassInfo called"));

    hr = LoadTypeLibs();
    if (hr)
        return hr;

    hr = _pTypeLibDLL->GetTypeInfoOfGuid(CLSID_RemoteMTScriptProxy, pTI);

    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::GetTypeInfo, IDispatch
//
//  Notes:  This returns the typeinfo for the IRemoteMTScriptProxy dual
//          interface.
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    HRESULT hr;

    TraceTag((tagError, "CLocalMTProxy::GetTypeInfo called"));

    hr = LoadTypeLibs();
    if (hr)
        return hr;

    *pptinfo = _pTypeInfoInterface;
    (*pptinfo)->AddRef();

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    HRESULT hr;

    hr = LoadTypeLibs();
    if (hr)
        return hr;

    hr = _pTypeInfoInterface->GetIDsOfNames(rgszNames, cNames, rgdispid);

    if (hr && _pDispRemote)
    {
        hr = _pTypeInfoCM->GetIDsOfNames(rgszNames, cNames, rgdispid);
    }

    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::Invoke(DISPID dispidMember,
                      REFIID riid,
                      LCID lcid,
                      WORD wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT * pvarResult,
                      EXCEPINFO * pexcepinfo,
                      UINT * puArgErr)
{
    HRESULT hr;

    hr = LoadTypeLibs();
    if (hr)
        return hr;

    hr = _pTypeInfoInterface->Invoke((IRemoteMTScriptProxy *)this,
                                     dispidMember,
                                     wFlags,
                                     pdispparams,
                                     pvarResult,
                                     pexcepinfo,
                                     puArgErr);
    //
    // If we're connected to the remote object, then we forward any calls
    // we don't know how to handle on to that object. This is not aggregation,
    // since we have not set up object identity in this relationship.
    //
    if (hr && _pDispRemote)
    {
        hr = _pDispRemote->Invoke(dispidMember,
                                  riid,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  puArgErr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::LoadTypeLibs, public
//
//  Synopsis:   Ensures that we have loaded our typelibrary
//
//----------------------------------------------------------------------------

HRESULT
CLocalMTProxy::LoadTypeLibs()
{
    HRESULT hr = S_OK;
    TCHAR   achDll[MAX_PATH];

    if (!_pTypeLibDLL)
    {
        GetModuleFileName(g_hInstDll, achDll, MAX_PATH);

        hr = THR(LoadTypeLib(achDll, &_pTypeLibDLL));

        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoInterface)
    {
        hr = THR(_pTypeLibDLL->GetTypeInfoOfGuid(IID_IRemoteMTScriptProxy,
                                                 &_pTypeInfoInterface));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoCM)
    {
        hr = THR(_pTypeLibDLL->GetTypeInfoOfGuid(IID_IConnectedMachine,
                                                 &_pTypeInfoCM));
        if (hr)
            goto Cleanup;
    }

Cleanup:

    if (hr)
    {
        TraceTag((tagError, "CLocalMTProxy::LoadTypeLibs returning %x", hr));
    }

    return hr;
}

// *************************************************************************

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::Connect, public
//
//  Synopsis:   Connects to the RemoteMTScript object on the given remote
//              (or local) machine.
//
//  Arguments:  [bstrMachine] -- Machine to connect to. If NULL or empty,
//                               use the local machine.
//
//  Returns:    HRESULT
//
//  Notes:      This also sets up the event sink for handling events.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CLocalMTProxy::Connect(BSTR bstrMachine)
{
    HRESULT      hr = S_OK;
    COSERVERINFO csi = { 0 };
    MULTI_QI     mqi[2] = { 0 };
    BOOL         fRemote = TRUE;

    // IConnectionPointContainer *pCPC;
    // IConnectionPoint          *pCP;

    if (!bstrMachine || SysStringLen(bstrMachine) == 0)
    {
        fRemote = FALSE;
    }

    TraceTag((tagError, "CLocalMTProxy::Connect called. Machine=%ls", (fRemote) ? bstrMachine : L"<local>"));

    // The following code will remove all security from the connection. This
    // will need to be enabled if the corresponding call to CoInitializeSecurity
    // is turned on in mtscript.exe.

    // Remove security for the connection.

    csi.pAuthInfo = NULL;

    csi.pwszName = bstrMachine;

    mqi[0].pIID = &IID_IDispatch;
    // mqi[1].pIID = &IID_IConnectionPointContainer;

    hr = CoCreateInstanceEx(CLSID_RemoteMTScript,
                            NULL,
                            CLSCTX_SERVER,
                            (fRemote) ? &csi : NULL,
                            1,
                            mqi);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CLocalMTProxy::Connect: CoCreateInstanceEx returned=%x", hr));
        return hr;
    }

    if (mqi[0].hr)
        return mqi[0].hr;

    _pDispRemote = (IDispatch *)mqi[0].pItf;

/*
    // Security problems make it difficult to impossible to make a
    // reverse COM event interface connect successfully.

    if (!mqi[1].hr)
    {
        pCPC = (IConnectionPointContainer *)mqi[1].pItf;


        hr = pCPC->FindConnectionPoint(DIID_DRemoteMTScriptEvents, &pCP);
        if (!hr)
        {
            hr = pCP->Advise(&_cesSink, &_dwSinkCookie);

            ReleaseInterface(pCP);
        }

        ReleaseInterface(pCPC);

#if DBG == 1
        if (hr)
            TraceTag((tagError, "Hookup to event sink returned %x", hr));
#endif

        // If the advise failed for some reason, just don't sink events.
    }
    else
    {
        TraceTag((tagError, "CLocalMTProxy::Connect: ICPC QI returned=%x", mqi[1].hr));
    }
*/

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::Disconnect, public
//
//  Synopsis:   Disconnects from a machine we connected to via Connect().
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

STDMETHODIMP
CLocalMTProxy::Disconnect()
{
    HRESULT hr = S_OK;

    TraceTag((tagError, "CLocalMTProxy::Disconnect called"));

    if (_dwSinkCookie)
    {
        IConnectionPointContainer *pCPC;
        IConnectionPoint          *pCP;

        hr = _pDispRemote->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pCPC);
        if (!hr)
        {
            hr = pCPC->FindConnectionPoint(DIID_DRemoteMTScriptEvents,
                                           &pCP);
            if (!hr)
            {
                pCP->Unadvise(_dwSinkCookie);

                ReleaseInterface(pCP);
            }

            ReleaseInterface(pCPC);

#if DBG == 1
            if (hr)
                TraceTag((tagError, "Unadvise from event sink returned %x", hr));
#endif
        }

        _dwSinkCookie = 0;
    }

    ClearInterface(&_pDispRemote);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::DownloadFile, public
//
//  Synopsis:   Downloads a file from the given URL and stores it locally.
//
//  Arguments:  [bstrURL]  -- URL to download
//              [bstrFile] -- Path of where the file was saved by urlmon
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CLocalMTProxy::DownloadFile(BSTR bstrURL, BSTR *bstrFile)
{
    HRESULT hr;
    TCHAR   achBuf[MAX_PATH * 2];


    hr = URLDownloadToCacheFile((IRemoteMTScriptProxy*)this,
                                bstrURL,
                                achBuf,
                                MAX_PATH * 2,
                                0,
                                NULL);
    if (hr)
    {
        int       cChar;
        HINSTANCE hModURLMON = LoadLibraryA("urlmon.dll");

        cChar = wsprintf(achBuf, L"Error: (%x) ", hr);

        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_FROM_HMODULE |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      hModURLMON,
                      hr,
                      0,
                      achBuf + cChar,
                      MAX_PATH * 2 - cChar,
                      NULL);

        FreeLibrary(hModURLMON);
    }

    *bstrFile = SysAllocString(achBuf);

    return S_OK;
}

// *************************************************************************
//
// CMTEventSink
//
// Class which implements the event sink for the remote object. This just
// forwards all calls to the event sink registered with us by the web page,
// if any.
//
// *************************************************************************

HRESULT
CMTEventSink::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppv = (IDispatch *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMTEventSink::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMTEventSink::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    if (Proxy()->_pDispSink)
    {
        return Proxy()->_pDispSink->GetTypeInfo(itinfo, lcid, pptinfo);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMTEventSink::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMTEventSink::GetTypeInfoCount(UINT * pctinfo)
{
    if (Proxy()->_pDispSink)
    {
        return Proxy()->_pDispSink->GetTypeInfoCount(pctinfo);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMTEventSink::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMTEventSink::GetIDsOfNames(REFIID riid,
                            LPOLESTR * rgszNames,
                            UINT cNames,
                            LCID lcid,
                            DISPID * rgdispid)
{
    if (Proxy()->_pDispSink)
    {
        return Proxy()->_pDispSink->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMTEventSink::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMTEventSink::Invoke(DISPID dispidMember,
                      REFIID riid,
                      LCID lcid,
                      WORD wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT * pvarResult,
                      EXCEPINFO * pexcepinfo,
                      UINT * puArgErr)
{
    TraceTag((tagError, "CMTEventSink::Invoke called"));

    if (Proxy()->_pDispSink)
    {
        HRESULT hr;

        hr = Proxy()->_pDispSink->Invoke(dispidMember,
                                  riid,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  puArgErr);
        if (hr)
        {
            TraceTag((tagError, "CMTEventSink::Invoke: Sink call returned %x!", hr));
        }
    }

    TraceTag((tagError, "CMTEventSink::Invoke returning"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\scrhost\automation.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       bsauto.cxx
//
//-------------------------------------------------------------------------

#include "headers.hxx"
#include <mapi.h>

#undef ASSERT

DeclareTag(tagSync, "MTScript", "Trace Thread Sync events");
DeclareTag(tagLock, "MTScript", "Trace Thread Lock events");
ExternTag(tagProcess);

AutoCriticalSection CScriptHost::s_csSync;
CStackDataAry<CScriptHost::SYNCEVENT, 5> CScriptHost::s_arySyncEvents;

CScriptHost::THREADLOCK CScriptHost::s_aThreadLocks[MAX_LOCKS];
UINT CScriptHost::s_cThreadLocks = 0;

static const wchar_t *g_pszListDeliminator = L";,";
static wchar_t *g_pszAtomicSyncLock = L"g_pszAtomicSyncLock";
//---------------------------------------------------------------------------
//
//  Member: CScriptHost::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    VERIFY_THREAD();

    HRESULT hr;

    hr = LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    *pptinfo = _pTypeInfoIGlobalMTScript;
    (*pptinfo)->AddRef();

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::GetTypeInfoCount(UINT * pctinfo)
{
    VERIFY_THREAD();

    *pctinfo = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    VERIFY_THREAD();

    HRESULT hr;

    hr = THR(LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    hr = _pTypeInfoIGlobalMTScript->GetIDsOfNames(rgszNames, cNames, rgdispid);

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,DISPPARAMS * pdispparams, VARIANT * pvarResult,EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    VERIFY_THREAD();

    HRESULT hr;

    hr = LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    hr = _pTypeInfoIGlobalMTScript->Invoke((IGlobalMTScript *)this, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

Cleanup:
    return hr;
}

//***************************************************************************
//
//  IGlobalMTScript implementation
//
//***************************************************************************

HRESULT
CScriptHost::get_PublicData(VARIANT * pvData)
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    // NOTE: We assume that the output parameter pvData is an empty or
    // uninitialized VARIANT. This should be safe because it is defined as
    // the return value for this method to the scripting engines and is
    // a pure [out] parameter.

    VariantInit(pvData);

    // Check to see if the data has changed since we last got it.
    // _dwPublicSerialNum is a DWORD so we are guaranteed an atomic read.

    if (_pMT->_dwPublicSerialNum != _dwPublicSN)
    {
        LOCK_LOCALS(_pMT);

        VariantClear(&_vPubCache);

        // If the data is an IDispatch pointer (how the scripting engines
        // implement most objects) we must get a marshalled copy to this thread.
        // Otherwise we can just copy the data into the return value.

        if (V_VT(&_pMT->_vPublicData) == VT_DISPATCH)
        {
            IDispatch *pDisp;

            Assert(_pMT->_dwPublicDataCookie != 0);

            hr = _pMT->_pGIT->GetInterfaceFromGlobal(_pMT->_dwPublicDataCookie,
                                                     IID_IDispatch,
                                                     (LPVOID*)&pDisp);
            if (!hr)
            {
                V_VT(&_vPubCache)       = VT_DISPATCH;
                V_DISPATCH(&_vPubCache) = pDisp;
            }
        }
        else
        {
            hr = VariantCopy(&_vPubCache, &_pMT->_vPublicData);
        }

        _dwPublicSN = _pMT->_dwPublicSerialNum;
    }

    if (!hr)
    {
        hr = VariantCopy(pvData, &_vPubCache);
    }

    return hr;
}

HRESULT
CScriptHost::put_PublicData(VARIANT vData)
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    // Check for data types which we don't support.
    if (   V_ISBYREF(&vData)
        || V_ISARRAY(&vData)
        || V_ISVECTOR(&vData)
        || V_VT(&vData) == VT_UNKNOWN)
    {
        return E_INVALIDARG;
    }

    LOCK_LOCALS(_pMT);

    // If the previous data is an IDispatch pointer revoke it from the
    // GlobalInterfaceTable.

    if (V_VT(&_pMT->_vPublicData) == VT_DISPATCH)
    {
        Assert(_pMT->_dwPublicDataCookie != 0);

        hr = _pMT->_pGIT->RevokeInterfaceFromGlobal(_pMT->_dwPublicDataCookie);

        AssertSz(!hr, "Unexpected failure revoking itf from GIT");

        _pMT->_dwPublicDataCookie = 0;
    }

    // If the new data is an IDispatch pointer then we must register it.

    if (V_VT(&vData) == VT_DISPATCH)
    {
        Assert(_pMT->_dwPublicDataCookie == 0);

        hr = _pMT->_pGIT->RegisterInterfaceInGlobal(V_DISPATCH(&vData),
                                                    IID_IDispatch,
                                                    &_pMT->_dwPublicDataCookie);

        AssertSz(!hr, "Unexpected failure registering itf in GIT");
    }

    //  Update the global copy of the data.

    //$ FUTURE: This can be optimized to reduce memory usage (by not making
    //  a copy of a string in every thread, for example).

    _pMT->_dwPublicSerialNum++;
    hr = VariantCopy(&_pMT->_vPublicData, &vData);

    if (!hr)
    {
        // Even if it's an IDispatch, we don't need to marshal it for
        // ourselves because we're running in the same thread as the script
        // engine that gave it to us.
        hr = VariantCopy(&_vPubCache, &vData);

        _dwPublicSN = _pMT->_dwPublicSerialNum;
    }

    return S_OK;
}

HRESULT
CScriptHost::get_PrivateData(VARIANT * pvData)
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    // NOTE: We assume that the output parameter pvData is an empty or
    // uninitialized VARIANT. This should be safe because it is defined as
    // the return value for this method to the scripting engines and is
    // a pure [out] parameter.

    VariantInit(pvData);

    // Check to see if the data has changed since we last got it.
    // _dwPrivateSerialNum is a DWORD so we are guaranteed an atomic read.

    if (_pMT->_dwPrivateSerialNum != _dwPrivateSN)
    {
        LOCK_LOCALS(_pMT);

        VariantClear(&_vPrivCache);

        // If the data is an IDispatch pointer (how the scripting engines
        // implement most objects) we must get a marshalled copy to this thread.
        // Otherwise we can just copy the data into the return value.

        if (V_VT(&_pMT->_vPrivateData) == VT_DISPATCH)
        {
            IDispatch *pDisp;

            Assert(_pMT->_dwPrivateDataCookie != 0);

            hr = _pMT->_pGIT->GetInterfaceFromGlobal(_pMT->_dwPrivateDataCookie,
                                                     IID_IDispatch,
                                                     (LPVOID*)&pDisp);
            if (!hr)
            {
                V_VT(&_vPrivCache)       = VT_DISPATCH;
                V_DISPATCH(&_vPrivCache) = pDisp;
            }
        }
        else
        {
            hr = VariantCopy(&_vPrivCache, &_pMT->_vPrivateData);
        }

        _dwPrivateSN = _pMT->_dwPrivateSerialNum;
    }

    if (!hr)
    {
        hr = VariantCopy(pvData, &_vPrivCache);
    }

    return hr;
}

HRESULT
CScriptHost::put_PrivateData(VARIANT vData)
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    // Check for data types which we don't support.
    if (   V_ISBYREF(&vData)
        || V_ISARRAY(&vData)
        || V_ISVECTOR(&vData)
        || V_VT(&vData) == VT_UNKNOWN)
    {
        return E_INVALIDARG;
    }

    LOCK_LOCALS(_pMT);

    // If the previous data is an IDispatch pointer revoke it from the
    // GlobalInterfaceTable.

    if (V_VT(&_pMT->_vPrivateData) == VT_DISPATCH)
    {
        Assert(_pMT->_dwPrivateDataCookie != 0);

        hr = _pMT->_pGIT->RevokeInterfaceFromGlobal(_pMT->_dwPrivateDataCookie);

        AssertSz(!hr, "Unexpected failure revoking itf from GIT");

        _pMT->_dwPrivateDataCookie = 0;
    }

    // If the new data is an IDispatch pointer then we must register it.

    if (V_VT(&vData) == VT_DISPATCH)
    {
        Assert(_pMT->_dwPrivateDataCookie == 0);

        hr = _pMT->_pGIT->RegisterInterfaceInGlobal(V_DISPATCH(&vData),
                                                    IID_IDispatch,
                                                    &_pMT->_dwPrivateDataCookie);

        AssertSz(!hr, "Unexpected failure registering itf in GIT");
    }

    //  Update the global copy of the data.

    //$ FUTURE: This can be optimized to reduce memory usage (by not making
    //  a copy of a string in every thread, for example).

    _pMT->_dwPrivateSerialNum++;
    hr = VariantCopy(&_pMT->_vPrivateData, &vData);

    if (!hr)
    {
        // Even if it's an IDispatch, we don't need to marshal it for
        // ourselves because we're running in the same thread as the script
        // engine that gave it to us.
        hr = VariantCopy(&_vPrivCache, &vData);

        _dwPrivateSN = _pMT->_dwPrivateSerialNum;
    }

    return S_OK;
}

HRESULT
CScriptHost::ExitProcess()
{
    VERIFY_THREAD();

    PostToThread(_pMT, MD_PLEASEEXIT);

    return S_OK;
}

HRESULT
CScriptHost::Restart()
{
    VERIFY_THREAD();

    PostToThread(_pMT, MD_RESTART);

    return S_OK;
}

HRESULT
CScriptHost::get_LocalMachine(BSTR *pbstrName)
{
    TCHAR achCompName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwLen = MAX_COMPUTERNAME_LENGTH+1;

    VERIFY_THREAD();

    if (!pbstrName)
        return E_POINTER;

    GetComputerName(achCompName, &dwLen);

    achCompName[dwLen] = '\0';

    *pbstrName = SysAllocString(achCompName);
    if (!*pbstrName)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CScriptHost::Include(BSTR bstrPath)
{
    VERIFY_THREAD();

    HRESULT hr;

    if(!bstrPath)
        return E_INVALIDARG;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    //$ TODO: Define a new named item context for the included file for better
    // debugging.
    hr = THR(GetSite()->ExecuteScriptFile(bstrPath));

    return hr;
}

HRESULT
CScriptHost::CallScript(BSTR bstrPath, VARIANT *pvarScriptParam)
{
    VERIFY_THREAD();

    HRESULT hr;

    if(!bstrPath)
        return E_INVALIDARG;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    hr = THR(PushScript(_tcsrchr(bstrPath, _T('.'))));
    if(hr)
        goto Cleanup;

     if (pvarScriptParam && pvarScriptParam->vt != VT_ERROR)
    {
        hr = THR(VariantCopy(&GetSite()->_varParam, pvarScriptParam));
        if (hr)
            goto Cleanup;
    }

    hr = THR(GetSite()->ExecuteScriptFile(bstrPath));

    hr = THR(GetSite()->SetScriptState(SCRIPTSTATE_CONNECTED));
    if (hr)
        goto Cleanup;

    FireEvent(DISPID_MTScript_ScriptMain, 0, NULL);

    PopScript();

Cleanup:
    return hr;
}

HRESULT
CScriptHost::SpawnScript(BSTR bstrPath, VARIANT *pvarScriptParam)
{
    VERIFY_THREAD();

    HRESULT  hr = S_OK;
    VARIANT *pvarParam = NULL;
    DWORD dwCookie = 0;
    BOOL  fRegistered = false;

    // Check for data types which we don't support.
    if (   !bstrPath
        || SysStringLen(bstrPath) == 0
        || V_ISBYREF(pvarScriptParam)
        || V_ISARRAY(pvarScriptParam)
        || V_ISVECTOR(pvarScriptParam)
        || V_VT(pvarScriptParam) == VT_UNKNOWN)
    {
        return E_INVALIDARG;
    }

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (pvarScriptParam && pvarScriptParam->vt != VT_ERROR)
    {
        pvarParam = new VARIANT;

        if (!pvarParam)
            return E_OUTOFMEMORY;

        VariantInit(pvarParam);

        if (V_VT(pvarScriptParam) == VT_DISPATCH)
        {
            // Stick the pointer in the GlobalInterfaceTable, so the other
            // thread can pull it out safely.

            hr = _pMT->_pGIT->RegisterInterfaceInGlobal(V_DISPATCH(pvarScriptParam),
                                                        IID_IDispatch,
                                                        &dwCookie);
            if (hr)
                goto Cleanup;

            // Stick the cookie in the variant we hand to the other thread.

            V_VT(pvarParam) = VT_DISPATCH;
            V_I4(pvarParam) = dwCookie;
            fRegistered = true;
        }
        else
        {
            hr = THR(VariantCopy(pvarParam, pvarScriptParam));
            if (hr)
                goto Cleanup;
        }
    }
    hr = _pMT->RunScript(bstrPath, pvarParam);

Cleanup:
    if (pvarParam)
    {
        if (fRegistered)
        {
            Verify(_pMT->_pGIT->RevokeInterfaceFromGlobal(dwCookie) == S_OK);
        }
        if (V_VT(pvarParam) != VT_DISPATCH)
            VariantClear(pvarParam);
        delete pvarParam;
    }
    return hr;
}

HRESULT
CScriptHost::get_ScriptParam(VARIANT *pvarScriptParam)
{
    VERIFY_THREAD();

    HRESULT hr;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (GetSite())
    {
        hr = THR(VariantCopy(pvarScriptParam, &GetSite()->_varParam));
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CScriptHost::get_ScriptPath(BSTR *pbstrPath)
{
    CStr cstrPath;

    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    _pMT->_options.GetScriptPath(&cstrPath);

    return cstrPath.AllocBSTR(pbstrPath);
}

typedef HRESULT (TestExternal_Func)(VARIANT *pParam, long *plRetVal);

HRESULT
CScriptHost::CallExternal(BSTR     bstrDLLName,
                             BSTR     bstrFunctionName,
                             VARIANT *pParam,
                             long *   plRetVal)
{
    VERIFY_THREAD();

    HRESULT            hr       = S_OK;
    HINSTANCE          hInstDLL = NULL;
    TestExternal_Func *pfn      = NULL;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (!plRetVal || !bstrDLLName || !bstrFunctionName)
        return E_POINTER;

    *plRetVal = -1;

    hInstDLL = LoadLibrary(bstrDLLName);

    if (NULL == hInstDLL)
    {
        return S_FALSE;     // Can't return error codes or the script will abort
    }

    int   cchLen = SysStringLen(bstrFunctionName);
    char *pchBuf = new char[cchLen+1];

    if (pchBuf)
    {
        WideCharToMultiByte(CP_ACP, 0, bstrFunctionName, cchLen, pchBuf, cchLen+1, NULL, NULL);
        pchBuf[cchLen] = '\0';

        pfn = (TestExternal_Func *)GetProcAddress(hInstDLL, pchBuf);

        delete pchBuf;
    }

    if (NULL == pfn)
    {
        hr = S_FALSE;
    }
    else
    {
        *plRetVal = 0;
        hr = (*pfn)(pParam, plRetVal);
    }

    FreeLibrary(hInstDLL);

    return hr;
}

HRESULT
CScriptHost::GetSyncEventName(int nEvent, CStr *pCStr, HANDLE *phEvent)
{
    HRESULT    hr = S_OK;

    *phEvent = NULL;

    if (nEvent < 0)
        return E_INVALIDARG;

    EnterCriticalSection(&s_csSync);

    if (nEvent >= s_arySyncEvents.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pCStr->Set(s_arySyncEvents[nEvent]._cstrName);
    *phEvent = s_arySyncEvents[nEvent]._hEvent;

Cleanup:
    LeaveCriticalSection(&s_csSync);

    RRETURN(hr);
}

HRESULT
CScriptHost::GetSyncEvent(LPCTSTR pszName, HANDLE *phEvent)
{
    int        i;
    SYNCEVENT *pse;
    HRESULT    hr = S_OK;

    *phEvent = NULL;

    if (_tcslen(pszName) < 1)
        return E_INVALIDARG;

    EnterCriticalSection(&s_csSync);

    for (i = s_arySyncEvents.Size(), pse = s_arySyncEvents;
         i > 0;
         i--, pse++)
    {
        if (_tcsicmp(pszName, pse->_cstrName) == 0)
        {
            *phEvent = pse->_hEvent;
            break;
        }
    }

    if (i == 0)
    {
        //
        // The event doesn't exist yet. Create one. The primary script thread
        // owns cleaning all this stuff up.
        //
        SYNCEVENT se;

        se._hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!se._hEvent)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
        else
        {
            se._cstrName.Set(pszName);

            s_arySyncEvents.AppendIndirect(&se);

            //
            // The cstr in 'se' will destroy its memory unless we take it away.
            // It's now owned by the cstrName member of the array.
            //
            (void)se._cstrName.TakePch();

            *phEvent = se._hEvent;
        }
    }

Cleanup:
    LeaveCriticalSection(&s_csSync);

    RRETURN(hr);
}

HRESULT
CScriptHost::StringToEventArray(const wchar_t *pszNameList, CStackPtrAry<HANDLE, 5> *pAryEvents)
{
    HRESULT hr = S_OK;
    if (wcspbrk(pszNameList, g_pszListDeliminator))
    {
        CStr cstrNameList;
        HRESULT hr = cstrNameList.Set(pszNameList);
        wchar_t *pch = NULL;

        if (hr == S_OK)
            pch = wcstok(cstrNameList, g_pszListDeliminator);

        while (hr == S_OK && pch)
        {
            HANDLE  hEvent;
            hr = THR(GetSyncEvent(pch, &hEvent));
            if (hr != S_OK)
                break;

            // Don't allow duplicates. MsgWaitForMultipleObjects will barf.
            if (pAryEvents->Find(hEvent) != -1)
            {
                hr = E_INVALIDARG;
                break;
            }

            hr = pAryEvents->Append(hEvent);

            pch = wcstok(NULL, g_pszListDeliminator);
        }
    }
    else
    {
        HANDLE  hEvent;
        hr = THR(GetSyncEvent(pszNameList, &hEvent));
        if (hr == S_OK)
            hr = pAryEvents->Append(hEvent);
    }
    RRETURN(hr);
}

HRESULT
CScriptHost::ResetSync(const BSTR bstrName)
{
    VERIFY_THREAD();

    HRESULT hr;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    CStackPtrAry<HANDLE, 5> aryEvents;
    hr = StringToEventArray(bstrName, &aryEvents);
    if (hr == S_OK)
    {
        for(int i = aryEvents.Size() - 1; i>= 0; --i)
            ResetEvent(aryEvents[i]);
    }
    return hr;
}

HRESULT
CScriptHost::WaitForSync(BSTR bstrName, long nTimeout, VARIANT_BOOL *pfSignaled)
{
    VERIFY_THREAD();

    HANDLE  hEvent;
    HRESULT hr;

    if (!pfSignaled)
        return E_POINTER;

    *pfSignaled = VB_TRUE;

    hr = THR(GetSyncEvent(bstrName, &hEvent));
    if (hr)
        RRETURN(hr);

    TraceTag((tagSync, "Thread 0x%x is starting a wait for sync %ls",
              _dwThreadId, bstrName));

    if (MessageEventPump(TRUE,
                         1,
                         &hEvent,
                         FALSE,
                         (nTimeout > 0) ? nTimeout : INFINITE) != MEP_EVENT_0)
    {
        *pfSignaled = VB_FALSE;
    }

    // Now make sure that SignalThreadSync() and ResetSync()
    // are atomic when manipulating multiple syncs.
    TakeThreadLock(g_pszAtomicSyncLock);
    ReleaseThreadLock(g_pszAtomicSyncLock);
    TraceTag((tagSync, "Thread 0x%x has returned from a wait for sync %ls (signaled=%s)",
              _dwThreadId,
              bstrName,
              (*pfSignaled==VB_FALSE) ? "false" : "true"));

    return S_OK;
}

HRESULT
CScriptHost::WaitForMultipleSyncs(const BSTR         bstrNameList,
                                  VARIANT_BOOL fWaitForAll,
                                  long         nTimeout,
                                  long        *plSignal)
{
    VERIFY_THREAD();

    HRESULT hr;
    DWORD   dwRet;

    *plSignal = 0;

    CStackPtrAry<HANDLE, 5> aryEvents;
    hr = StringToEventArray(bstrNameList, &aryEvents);

    if (hr == S_OK)
    {
        TraceTag((tagSync, "Thread 0x%x is starting a multiwait for sync %ls",
                  _dwThreadId, bstrNameList));
        dwRet = MessageEventPump(TRUE,
                                 aryEvents.Size(),
                                 aryEvents,
                                 (fWaitForAll == VB_TRUE) ? TRUE : FALSE,
                                 (nTimeout > 0) ? nTimeout : INFINITE);
        if (dwRet >= MEP_EVENT_0)
        {
            *plSignal = dwRet - MEP_EVENT_0 + 1; // result is 1-based, not zero-based
            // Now make sure that SignalThreadSync() and ResetSync()
            // are atomic when manipulating multiple syncs.
            TakeThreadLock(g_pszAtomicSyncLock);
            ReleaseThreadLock(g_pszAtomicSyncLock);
        }
        TraceTag((tagSync, "Thread 0x%x has returned from a multiwait for sync %ls (signaled=%d)",
                  _dwThreadId,
                  bstrNameList,
                  *plSignal));
    }
    return hr;
}

HRESULT
CScriptHost::SignalThreadSync(BSTR bstrName)
{
    HRESULT hr;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    TraceTag((tagSync, "Thread 0x%x is signalling sync %ls",
              _dwThreadId, bstrName));

    CStackPtrAry<HANDLE, 5> aryEvents;
    hr = StringToEventArray(bstrName, &aryEvents);
    if (hr == S_OK)
    {
        if (aryEvents.Size() > 1)
            TakeThreadLock(g_pszAtomicSyncLock);

        for(int i = aryEvents.Size() - 1; i>= 0; --i)
            SetEvent(aryEvents[i]);

        if (aryEvents.Size() > 1)
            ReleaseThreadLock(g_pszAtomicSyncLock);
    }

    return S_OK;
}

HRESULT
CScriptHost::GetLockCritSec(LPTSTR             pszName,
                            CRITICAL_SECTION **ppcs,
                            DWORD            **ppdwOwner)
{
    int         i;
    THREADLOCK *ptl;
    HRESULT     hr = S_OK;

    if (_tcslen(pszName) < 1)
        return E_INVALIDARG;

    *ppcs = NULL;

    EnterCriticalSection(&s_csSync);

    for (i = s_cThreadLocks, ptl = s_aThreadLocks;
         i > 0;
         i--, ptl++)
    {
        if (_tcsicmp(pszName, ptl->_cstrName) == 0)
        {
            *ppcs      = &ptl->_csLock;
            *ppdwOwner = &ptl->_dwOwner;

            break;
        }
    }

    if (i == 0)
    {
        //
        // The critical section doesn't exist yet.  Create one.  The primary
        // script thread owns cleaning all this stuff up.
        //

        if (s_cThreadLocks == MAX_LOCKS)
        {
            // BUGBUG -- SetErrorInfo
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        ptl = &s_aThreadLocks[s_cThreadLocks++];

        InitializeCriticalSection(&ptl->_csLock);

        ptl->_cstrName.Set(pszName);
        ptl->_dwOwner = 0;

        *ppcs      = &ptl->_csLock;
        *ppdwOwner = &ptl->_dwOwner;
    }

Cleanup:
    LeaveCriticalSection(&s_csSync);

    RRETURN(hr);
}

HRESULT
CScriptHost::TakeThreadLock(BSTR bstrName)
{
    HRESULT           hr;
    CRITICAL_SECTION *pcs;
    DWORD            *pdwOwner;

    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    hr = THR(GetLockCritSec(bstrName, &pcs, &pdwOwner));
    if (hr)
        RRETURN(hr);

    TraceTag((tagLock, "Thread 0x%x is trying to obtain lock %ls",
              _dwThreadId, bstrName));

    while (!TryEnterCriticalSection(pcs))
    {
        // Make sure we don't get hung here if the thread's trying to exit

        if (MessageEventPump(TRUE, 0, NULL, FALSE, 100, TRUE) == MEP_EXIT)
            return E_FAIL;
    }

    TraceTag((tagLock, "Thread 0x%x has obtained lock %ls",
              _dwThreadId, bstrName));

    *pdwOwner = GetCurrentThreadId();

    return S_OK;
}

HRESULT
CScriptHost::ReleaseThreadLock(BSTR bstrName)
{
    HRESULT            hr;
    CRITICAL_SECTION  *pcs;
    DWORD             *pdwOwner;

    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    hr = THR(GetLockCritSec(bstrName, &pcs, &pdwOwner));
    if (hr)
        RRETURN(hr);

    // LeaveCriticalSection can cause other threads to lock indefinitely on
    // the critical section if we don't actually own it.

    if (*pdwOwner != GetCurrentThreadId())
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
    }

    LeaveCriticalSection(pcs);

    TraceTag((tagLock, "Thread 0x%x has released lock %ls",
              _dwThreadId, bstrName));

    return S_OK;
}

HRESULT
CScriptHost::DoEvents()
{
    VERIFY_THREAD();

    MessageEventPump(FALSE);

    return S_OK;
}

HRESULT
CScriptHost::MessageBoxTimeout(BSTR bstrMessage,        // Message Text
                                  long cButtons,           // Number of buttons (max 5)
                                  BSTR bstrButtonText,     // Comma separated list of button text. Number must match cButtons
                                  long lTimeout,           // Timeout in minutes. If zero then no timeout.
                                  long lEventInterval,     // Fire a OnMessageBoxInterval event every lEventInterval minutes
                                  VARIANT_BOOL fCanCancel, // If TRUE then timeout can be canceled.
                                  VARIANT_BOOL fConfirm,   // If TRUE then confirm the button pushed before returning.
                                  long *plSelected)        // Returns button pushed. 0=timeout, 1=Button1, 2=Button2, etc.
{
    VERIFY_THREAD();

    HANDLE     hEvent;
    MBTIMEOUT  mbt = { 0 };
    BOOL       fExit = FALSE;
    HRESULT    hr = S_OK;


    if (!plSelected)
        return E_POINTER;

    *plSelected = -1;

    if (cButtons < 1 || cButtons > 5)
        return E_INVALIDARG;

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!hEvent)
        return HRESULT_FROM_WIN32(GetLastError());

    mbt.bstrMessage    = bstrMessage;
    mbt.cButtons       = cButtons;
    mbt.bstrButtonText = bstrButtonText;
    mbt.lTimeout       = lTimeout;
    mbt.lEventInterval = lEventInterval;
    mbt.fCanCancel     = (fCanCancel == VB_TRUE) ? TRUE : FALSE;
    mbt.fConfirm       = (fConfirm == VB_TRUE) ? TRUE : FALSE;
    mbt.hEvent         = hEvent;

    CMessageBoxTimeout *pmbt = new CMessageBoxTimeout(&mbt);
    if (!pmbt)
        return E_OUTOFMEMORY;

    pmbt->StartThread(NULL);

    while (!fExit)
    {
        // Make sure it was our event being signaled that caused the loop to end
        if (MessageEventPump(TRUE, 1, &hEvent) != MEP_EVENT_0)
        {
            hr = S_FALSE;
            fExit = TRUE;
            break;
        }

        switch (mbt.mbts)
        {
        case MBTS_BUTTON1:
        case MBTS_BUTTON2:
        case MBTS_BUTTON3:
        case MBTS_BUTTON4:
        case MBTS_BUTTON5:
        case MBTS_TIMEOUT:
            *plSelected = (long)mbt.mbts;
            fExit = TRUE;
            break;

        case MBTS_INTERVAL:
            FireEvent(DISPID_MTScript_OnMessageBoxInterval, 0, NULL);
            ResetEvent(hEvent);
            break;

        case MBTS_ERROR:
            hr = E_FAIL;
            fExit = TRUE;
            break;

        default:
            AssertSz(FALSE, "FATAL: Invalid value for mbts!");
            fExit = TRUE;
            break;
        }
    }

    if (pmbt->_hwnd != NULL)
    {
        EndDialog(pmbt->_hwnd, 0);
    }

    pmbt->Release();

    CloseHandle(hEvent);

    return hr;
}

HRESULT
CScriptHost::RunLocalCommand(BSTR         bstrCommand,
                             BSTR         bstrDir,
                             BSTR         bstrTitle,
                             VARIANT_BOOL fMinimize,
                             VARIANT_BOOL fGetOutput,
                             VARIANT_BOOL fWait,
                             VARIANT_BOOL fNoCrashPopup,
                             VARIANT_BOOL fNoEnviron,
                             long *       plErrorCode)
{
    VERIFY_THREAD();

    CProcessThread *pProc;
    PROCESS_PARAMS  pp;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (!plErrorCode)
        return E_POINTER;

    pp.pszCommand    = bstrCommand;
    pp.pszDir        = bstrDir;
    pp.pszTitle      = bstrTitle;
    pp.fMinimize     = (fMinimize     == VB_TRUE) ? TRUE : FALSE;
    pp.fGetOutput    = (fGetOutput    == VB_TRUE) ? TRUE : FALSE;
    pp.fNoCrashPopup = (fNoCrashPopup == VB_TRUE) ? TRUE : FALSE;
    pp.fNoEnviron    = (fNoEnviron    == VB_TRUE) ? TRUE : FALSE;

    _hrLastRunLocalError = S_OK;

    pProc = new CProcessThread(this);
    if (!pProc)
    {
        _hrLastRunLocalError = E_OUTOFMEMORY;

        *plErrorCode = 0;

        return S_FALSE;
    }
    _hrLastRunLocalError = pProc->StartThread(&pp);
    if (FAILED(_hrLastRunLocalError))
    {
        *plErrorCode = 0;

        pProc->Release();

        // Don't cause a script error by returning a failure code.
        return S_FALSE;
    }

    _pMT->AddProcess(pProc);

    if (fWait == VB_TRUE)
    {
        HANDLE hEvent = pProc->hThread();

        // The actual return code here doesn't matter. We'll do the same thing
        // no matter what causes MessageEventPump to exit.
        MessageEventPump(TRUE, 1, &hEvent);
    }


    TraceTag((tagProcess, "RunLocalCommand PID=%d, %s", pProc->ProcId(), bstrCommand));
    *plErrorCode = pProc->ProcId();

    return S_OK;
}

HRESULT
CScriptHost::GetLastRunLocalError(long *plErrorCode)
{
    VERIFY_THREAD();

    *plErrorCode = _hrLastRunLocalError;

    return S_OK;
}

HRESULT
CScriptHost::GetProcessOutput(long lProcessID, BSTR *pbstrData)
{
    VERIFY_THREAD();

    CProcessThread *pProc;

    pProc = _pMT->FindProcess((DWORD)lProcessID);

    if (!pProc)
    {
        return E_INVALIDARG;
    }

    return pProc->GetProcessOutput(pbstrData);
}

HRESULT
CScriptHost::GetProcessExitCode(long lProcessID, long *plExitCode)
{
    VERIFY_THREAD();

    CProcessThread *pProc;

    pProc = _pMT->FindProcess((DWORD)lProcessID);

    if (!pProc)
    {
        return E_INVALIDARG;
    }

    *plExitCode = pProc->GetExitCode();

    return S_OK;
}

HRESULT
CScriptHost::TerminateProcess(long lProcessID)
{
    VERIFY_THREAD();

    CProcessThread *pProc;

    pProc = _pMT->FindProcess((DWORD)lProcessID);

    if (!pProc)
    {
        return E_INVALIDARG;
    }

    PostToThread(pProc, MD_PLEASEEXIT);

    return S_OK;
}

HRESULT
CScriptHost::SendToProcess(long  lProcessID,
                           BSTR  bstrType,
                           BSTR  bstrData,
                           long *plReturn)
{
    VERIFY_THREAD();
    MACHPROC_EVENT_DATA  med;
    MACHPROC_EVENT_DATA *pmed;
    VARIANT              vRet;
    HRESULT              hr = S_OK;

    CProcessThread *pProc;

    pProc = _pMT->FindProcess((DWORD)lProcessID);

    //$ TODO -- Fix these error return codes to not cause script errors.
    if (!pProc || !plReturn)
    {
        return E_INVALIDARG;
    }
    else if (pProc->GetExitCode() != STILL_ACTIVE)
    {
        *plReturn = -1;
        return S_FALSE;
    }

    VariantInit(&vRet);

    med.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (med.hEvent == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    med.bstrCmd     = bstrType;
    med.bstrParams  = bstrData;
    med.dwProcId    = (DWORD)lProcessID;
    med.pvReturn    = &vRet;
    med.dwGITCookie = 0;
    med.hrReturn    = S_OK;

    pmed = &med;

    PostToThread(_pMT, MD_SENDTOPROCESS, &pmed, sizeof(MACHPROC_EVENT_DATA*));

    // BUGBUG - we could get a crash if something causes us to exit before
    // the CMTScript thread handles the MD_SENDTOPROCESS message.
    MessageEventPump(TRUE, 1, &med.hEvent);

    hr = med.hrReturn;

    *plReturn = V_I4(&vRet);

    VariantClear(&vRet);

    CloseHandle(med.hEvent);

    return hr;
}


#define USERPROFILESTRING_SZ (256 * sizeof(TCHAR))
TCHAR   UserProfileString[USERPROFILESTRING_SZ];

HRESULT
CScriptHost::SendMail(BSTR   bstrTo,
                         BSTR   bstrCC,
                         BSTR   bstrBCC,
                         BSTR   bstrSubject,
                         BSTR   bstrMessage,
                         BSTR   bstrAttachmentPath,
                         BSTR   bstrUsername,
                         BSTR   bstrPassword,
                         long * plErrorCode)
{
    // This implementation was stolen from the execmail.exe source code.

    // Handles to MAPI32.DLL library, host name registry key, email session.
    //$ FUTURE -- Cache this stuff instead of reloading the library every
    // time.
    HINSTANCE       hLibrary;
    LHANDLE         hSession;

    // Function pointers for MAPI calls we use.
    LPMAPILOGON     fnMAPILogon;
    LPMAPISENDMAIL  fnMAPISendMail;
    LPMAPILOGOFF    fnMAPILogoff;

    // MAPI structures and counters.
    MapiRecipDesc   rgRecipDescStruct[30];
    MapiMessage     MessageStruct = {0, NULL, NULL, NULL, NULL, NULL, 0, NULL, 0, NULL, 0, NULL};
    MapiFileDesc    MAPIFileDesc = {0, 0, 0, NULL, NULL, NULL};
    FLAGS           MAPIFlags = MAPI_NEW_SESSION;

    // Pointers to email parameter strings.
    char            *pszToList      = NULL;
    char            *pszCCList      = NULL;
    char            *pszBCCList     = NULL;

    ULONG            ulErrorCode;

    if (!plErrorCode)
        return E_POINTER;

    ///////////////////////////////////////////////////////////////////////////
    // No point going any farther if MAPI32.DLL isn't available.
    hLibrary = LoadLibrary(L"MAPI32.DLL");
    if (hLibrary == NULL)
    {
        DWORD dwError = GetLastError();

        TraceTag((tagError, "Error: MAPI32.DLL not found on this machine!"));

        *plErrorCode = HRESULT_FROM_WIN32(dwError);

        return S_FALSE;
    }

    // Must convert all parameters to ANSI
    ANSIString szTo(bstrTo);
    ANSIString szCC(bstrCC);
    ANSIString szBCC(bstrBCC);
    ANSIString szSubject(bstrSubject);
    ANSIString szMessage(bstrMessage);
    ANSIString szAttachment(bstrAttachmentPath);
    ANSIString szUsername(bstrUsername);
    ANSIString szPassword(bstrPassword);


    // Set up MAPI function pointers.
    fnMAPILogon    = (LPMAPILOGON)GetProcAddress(hLibrary, "MAPILogon");
    fnMAPISendMail = (LPMAPISENDMAIL)GetProcAddress(hLibrary, "MAPISendMail");
    fnMAPILogoff   = (LPMAPILOGOFF)GetProcAddress(hLibrary, "MAPILogoff");

    // Hook the recipient structure array into the message structure.
    MessageStruct.lpRecips = rgRecipDescStruct;

    // Get the default user parameters if none were specified.
    if (SysStringLen(bstrUsername) == 0)
    {
        HKEY    hkey;
        WCHAR   KeyPath[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles";
        WCHAR   Value[] = L"DefaultProfile";
        DWORD   buf_sz = USERPROFILESTRING_SZ;
        DWORD   val_type;

        if( RegOpenKeyEx( HKEY_CURRENT_USER, KeyPath, 0, KEY_READ, &hkey ) == ERROR_SUCCESS )
        {
            if ( RegQueryValueEx( hkey, Value, NULL, &val_type, (BYTE*)UserProfileString, &buf_sz ) == ERROR_SUCCESS )
            {
                if ( val_type == REG_SZ )
                {
                    szUsername.Set(UserProfileString);
                }
            }

            RegCloseKey( hkey );
        }
    }

    pszToList = szTo;

    // Parse ToList into rgRecipDescStruct.
    while (*pszToList && (MessageStruct.nRecipCount < 30))
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pszToList))
        {
            *pszToList=0;
            pszToList++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            rgRecipDescStruct[MessageStruct.nRecipCount].ulReserved = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulRecipClass = MAPI_TO;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszName = pszToList;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszAddress = NULL;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulEIDSize = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpEntryID = NULL;
            MessageStruct.nRecipCount++;
            // Move beginning of string to next name in ToList.
            do
            {
                pszToList++;
            } while (isgraph(*pszToList));
        }
    }

    pszCCList = szCC;

    // Parse CCList into rgRecipDescStruct.
    while (*pszCCList && (MessageStruct.nRecipCount < 30))
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pszCCList))
        {
            *pszCCList=0;
            pszCCList++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            rgRecipDescStruct[MessageStruct.nRecipCount].ulReserved = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulRecipClass = MAPI_CC;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszName = pszCCList;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszAddress = NULL;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulEIDSize = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpEntryID = NULL;
            MessageStruct.nRecipCount++;
            // Move beginning of string to next name in CCList.
            do
            {
                pszCCList++;
            } while (isgraph(*pszCCList));
        }
    }

    pszBCCList = szBCC;

    // Parse BCCList into rgRecipDescStruct.
    while (*pszBCCList && (MessageStruct.nRecipCount < 30))
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pszBCCList))
        {
            *pszBCCList=0;
            pszBCCList++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            rgRecipDescStruct[MessageStruct.nRecipCount].ulReserved = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulRecipClass = MAPI_BCC;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszName = pszBCCList;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszAddress = NULL;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulEIDSize = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpEntryID = NULL;
            MessageStruct.nRecipCount++;
            // Move beginning of string to next name in BCCList.
            do
            {
                pszBCCList++;
            } while (isgraph(*pszBCCList));
        }
    }

    if (strlen(szAttachment) > 0)
    {
        MAPIFileDesc.ulReserved = 0;
        MAPIFileDesc.flFlags = 0;
        MAPIFileDesc.nPosition = 0;
        MAPIFileDesc.lpszPathName = szAttachment;
        MAPIFileDesc.lpszFileName = NULL;
        MAPIFileDesc.lpFileType = NULL;

        MessageStruct.nFileCount = 1;
        MessageStruct.lpFiles = &MAPIFileDesc;

        // muck around with the message text (The attachment
        // will be attached at the beginning of the mail message
        // but it replaces the character at that position)

        // BUGBUG -- Do we need to do this? (lylec)
        //strcpy(szMessageText," \n");
    }

    MessageStruct.lpszSubject = szSubject;
    MessageStruct.lpszNoteText = szMessage;

    *plErrorCode = 0;

    // Send the message!

    ulErrorCode = fnMAPILogon(0L, szUsername, szPassword, MAPIFlags, 0L, &hSession);

    if (ulErrorCode != SUCCESS_SUCCESS)
    {
        *plErrorCode = (long)ulErrorCode;
    }
    else
    {
        ulErrorCode = fnMAPISendMail(hSession, 0L, &MessageStruct, 0L, 0L);

        if (ulErrorCode != SUCCESS_SUCCESS)
        {
            *plErrorCode = (long)ulErrorCode;
        }

        fnMAPILogoff(hSession, 0L, 0L, 0L);
    }

    FreeLibrary(hLibrary);

    return S_OK;
}

HRESULT
CScriptHost::OUTPUTDEBUGSTRING(BSTR bstrMessage)
{
    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    TCHAR szText[ (MSGDATABUFSIZE-1) / sizeof(TCHAR) ];

    CScriptSite *site = GetSite();
    const TCHAR *pszScriptName = L"";
    if (site)
    {
        pszScriptName = _tcsrchr((LPTSTR)site->_cstrName, _T('\\'));
        if (!pszScriptName)
            pszScriptName = (LPTSTR)site->_cstrName;
    }
    int cChars = _snwprintf(szText, ARRAY_SIZE(szText), L"%.12s \t%s", pszScriptName, bstrMessage);

    szText[ARRAY_SIZE(szText) - 1] = 0;

    if (cChars < 0)
        cChars = ARRAY_SIZE(szText);
    else
        cChars++;

    PostToThread(_pMT,
                             MD_OUTPUTDEBUGSTRING,
                             szText,
                             cChars * sizeof(TCHAR));
    return S_OK;
}

HRESULT
CScriptHost::UnevalString(BSTR bstrInput, BSTR *pbstrOutput)
{
    int nInputLength = SysStringLen(bstrInput);
    OLECHAR tmpBuf[512];
    OLECHAR *pTmp = 0;
    OLECHAR *pOutputBuffer;

    *pbstrOutput = 0;
    if (sizeof(OLECHAR) * (nInputLength * 2 + 2) > sizeof(tmpBuf))
    {
        pTmp = (OLECHAR *)MemAlloc(sizeof(OLECHAR) * (nInputLength * 2 + 2));
        if (!pTmp)
            return E_OUTOFMEMORY;
        pOutputBuffer = pTmp;
    }
    else
    {
        pOutputBuffer = tmpBuf;
    }
    int j = 0;
    pOutputBuffer[j++] = L'"';
    for(OLECHAR *pInputEnd = bstrInput + nInputLength; bstrInput < pInputEnd; ++bstrInput)
    {
        switch(*bstrInput)
        {
        case L'\\':
        case L'"':
        case L'\'':
            pOutputBuffer[j] = L'\\';
            pOutputBuffer[j+1] = *bstrInput;
            j += 2;
            break;
        case L'\n':
            pOutputBuffer[j] = L'\\';
            pOutputBuffer[j+1] = L'n';
            j += 2;
            break;
        case L'\r':
            pOutputBuffer[j] = L'\\';
            pOutputBuffer[j+1] = L'r';
            j += 2;
            break;
        case L'\t':
            pOutputBuffer[j] = L'\\';
            pOutputBuffer[j+1] = L't';
            j += 2;
            break;
        default:
            pOutputBuffer[j++] = *bstrInput;
            break;
        }
    }
    pOutputBuffer[j++] = L'"';
    *pbstrOutput = SysAllocStringLen(pOutputBuffer, j);

    if (pTmp)
        MemFree(pTmp);

    if (!*pbstrOutput)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CScriptHost::CopyOrAppendFile(BSTR bstrSrc,
                 BSTR bstrDst,
                 long nSrcOffset,
                 long nSrcLength,
                 VARIANT_BOOL fAppend,
                 long *pnSrcFilePosition)
{
    HRESULT hr   = S_OK;
    HANDLE hDst  = INVALID_HANDLE_VALUE;
    HANDLE hSrcFile = INVALID_HANDLE_VALUE;
    BY_HANDLE_FILE_INFORMATION  fi = {0};
    long nEndPos;
    long nLen;
    DWORD nBytesRead;
    DWORD nBytesWritten;
    char rgBuffer[4096];

    hDst = CreateFile(
                bstrDst,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                0,
                (fAppend ? OPEN_ALWAYS : CREATE_ALWAYS),
                FILE_ATTRIBUTE_NORMAL,
                0);

    if (hDst == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    hSrcFile = CreateFile(bstrSrc,
                GENERIC_READ,
                FILE_SHARE_WRITE,
                0,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                0);

    if (hSrcFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    GetFileInformationByHandle(hSrcFile, &fi);
    if (fi.nFileSizeHigh != 0 || (fi.nFileSizeLow & 0x80000000) != 0)
    {
        hr = E_FAIL;//HRESULT_FROM_WIN32(?????);
        goto Cleanup;
    }
    if (nSrcLength == -1)
        nEndPos = (long)fi.nFileSizeLow;
    else
    {
        if ( ((_int64)nSrcOffset + nSrcLength) > 0x7f000000)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        nEndPos = nSrcOffset + nSrcLength;
    }
    if (nEndPos > (long)fi.nFileSizeLow)
        nEndPos = (long)fi.nFileSizeLow;

    if (SetFilePointer(hSrcFile, nSrcOffset, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    if (SetFilePointer(hDst, 0, 0, FILE_END) == INVALID_SET_FILE_POINTER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    while (nSrcOffset < nEndPos)
    {
        nLen = nEndPos - nSrcOffset;
        if (nLen > sizeof(rgBuffer))
            nLen = sizeof(rgBuffer);

        if (!ReadFile(hSrcFile, rgBuffer, nLen, &nBytesRead, 0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
        if (!WriteFile(hDst, rgBuffer, nBytesRead, &nBytesWritten, 0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
        nSrcOffset += nBytesRead;
    }
    if (pnSrcFilePosition)
        *pnSrcFilePosition = nSrcOffset;
Cleanup:
    if (hDst != INVALID_HANDLE_VALUE)
        CloseHandle(hDst);
    if (hSrcFile != INVALID_HANDLE_VALUE)
        CloseHandle(hSrcFile);
    return hr;
}

HRESULT
CScriptHost::ASSERT(VARIANT_BOOL fAssert, BSTR bstrMessage)
{
    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (!fAssert)
    {
        CHAR ach[1024];

        // Add name of currently executing script to the assert message.

        if (!GetSite() || !GetSite()->_achPath[0])
        {
            ach[0] = 0;
        }
        else
        {
            // Try to chop off directory name.

            TCHAR * pchName = wcsrchr(GetSite()->_achPath, _T('\\'));
            if (pchName)
                pchName += 1;
            else
                pchName = GetSite()->_achPath;

            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pchName,
                    -1,
                    ach,
                    MAX_PATH,
                    NULL,
                    NULL);

            strcat(ach, ": ");
        }

        // Add message to the assert.

        if (!bstrMessage || !*bstrMessage)
        {
            strcat(ach, "MTScript Script Assert");
        }
        else
        {
            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    bstrMessage,
                    -1,
                    &ach[strlen(ach)],
                    ARRAY_SIZE(ach) - MAX_PATH - 3,
                    NULL,
                    NULL);
        }

#if DBG == 1
        AssertSz(FALSE, ach);
#else
        if (MessageBoxA(NULL, ach, "MTScript Script Assert", MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
            return E_FAIL;
#endif
    }

    return S_OK;
}

HRESULT
CScriptHost::Sleep (int nTimeout)
{
    VERIFY_THREAD();

    MessageEventPump(TRUE, 0, NULL, FALSE, (DWORD)nTimeout);

    return S_OK;
}

HRESULT
CScriptHost::Reboot()
{
    VERIFY_THREAD();

    PostToThread(_pMT, MD_REBOOT);

    return S_OK;
}

HRESULT
CScriptHost::NotifyScript(BSTR bstrEvent, VARIANT vData)
{
    HRESULT hr = S_OK;
    VARIANT *pvar;

    VERIFY_THREAD();

    // Check for data types which we don't support.
    if (   V_ISBYREF(&vData)
        || V_ISARRAY(&vData)
        || V_ISVECTOR(&vData)
        || V_VT(&vData) == VT_DISPATCH  //$ FUTURE: Support this later
        || V_VT(&vData) == VT_UNKNOWN)
    {
        return E_INVALIDARG;
    }

    if (!_pMT->_pMachine)
    {
        return S_OK;
    }

    pvar = new VARIANT[2];

    VariantInit(&pvar[0]);
    VariantInit(&pvar[1]);

    V_VT(&pvar[0]) = VT_BSTR;
    V_BSTR(&pvar[0]) = SysAllocString(bstrEvent);

    VariantCopy(&pvar[1], &vData);

    PostToThread(_pMT->_pMachine, MD_NOTIFYSCRIPT, &pvar, sizeof(VARIANT*));

    return hr;
}

HRESULT
CScriptHost::RegisterEventSource(IDispatch *pDisp, BSTR bstrProgID)
{
    HRESULT           hr;
    CScriptEventSink *pSink = NULL;

    pSink = new CScriptEventSink(this);
    if (!pSink)
        return E_OUTOFMEMORY;

    hr = pSink->Connect(pDisp, bstrProgID);
    if (!hr)
    {
        _aryEvtSinks.Append(pSink);
    }
    else
        pSink->Release();

    return hr;
}

HRESULT
CScriptHost::UnregisterEventSource(IDispatch *pDisp)
{
    int  i;
    BOOL fFound = FALSE;

    for (i = 0; i < _aryEvtSinks.Size(); i++)
    {
        if (_aryEvtSinks[i]->IsThisYourSource(pDisp))
        {
            _aryEvtSinks[i]->Disconnect();

            _aryEvtSinks.ReleaseAndDelete(i);

            fFound = TRUE;
            break;
        }
    }

    return (fFound) ? S_OK : E_INVALIDARG;
}

HRESULT
CScriptHost::get_HostMajorVer(long *plMajorVer)
{
    if (!plMajorVer)
        return E_POINTER;

    *plMajorVer = IConnectedMachine_lVersionMajor;

    return S_OK;
}

HRESULT
CScriptHost::get_HostMinorVer(long *plMinorVer)
{
    if (!plMinorVer)
        return E_POINTER;

    *plMinorVer = IConnectedMachine_lVersionMinor;

    return S_OK;
}

HRESULT CScriptHost::get_StatusValue(long nIndex, long *pnStatus)
{
    return _pMT->get_StatusValue(nIndex, pnStatus);
}

HRESULT CScriptHost::put_StatusValue(long nIndex, long nStatus)
{
    return _pMT->put_StatusValue(nIndex, nStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\scrhost\script.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       bscript.cxx
//
//  Contents:   Implementation of CBServerScript
//
//----------------------------------------------------------------------------

#include "headers.hxx"
CScriptHost::CScriptHost(CMTScript *   pMT,
                         BOOL         fPrimary,
                         BOOL         fDispatchOnly)
      : _pMT(pMT),
        _fIsPrimaryScript(fPrimary)
{
    _ulRefs     = 1;

    VariantInit(&_vPubCache);
    VariantInit(&_vPrivCache);

    Assert(_dwPublicSN == 0);
    Assert(_dwPrivateSN == 0);
}

CScriptHost::~CScriptHost()
{
    int i;

    // Any thread can call the dtor.
    WHEN_DBG(_dwThreadId = GetCurrentThreadId());
    AssertSz(PopScript() == S_FALSE,
             "Script object not closed properly!");

    VariantClear(&_vPubCache);
    VariantClear(&_vPrivCache);

    for (i = 0; i < _aryEvtSinks.Size(); i++)
    {
        _aryEvtSinks[i]->Disconnect();
    }

    _aryEvtSinks.ReleaseAll();

    ReleaseInterface(_pTypeInfoIGlobalMTScript);
    ReleaseInterface(_pTypeInfoCMTScript);
}

HRESULT
CScriptHost::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IGlobalMTScript || iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppvObj = (IGlobalMTScript *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

DWORD
CScriptHost::ThreadMain()
{
    HRESULT        hr;
    CStr           cstrScript;
    VARIANT        varParam;
    SCRIPT_PARAMS *pscrParams;

    VariantInit(&varParam);

    VERIFY_THREAD();

    pscrParams = (SCRIPT_PARAMS*)_pvParams;


    cstrScript.Set(pscrParams->pszPath);

#if DBG == 1
    char achBuf[10];
    cstrScript.GetMultiByte(achBuf, 10);
    SetName(achBuf);
#endif

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED |
                              COINIT_DISABLE_OLE1DDE   |
                              COINIT_SPEED_OVER_MEMORY);
    if (!SUCCEEDED(hr))
    {
        ThreadStarted(hr);  // Free our creating thread
        goto Cleanup;
    }

    if (pscrParams->pvarParams)
    {
        if (V_VT(pscrParams->pvarParams) == VT_DISPATCH)
        {
            // Unmarshal the IDispatch pointer being handed to us from the
            // other thread.

            IDispatch *pDisp;
            DWORD      dwCookie = V_I4(pscrParams->pvarParams);

            hr = _pMT->_pGIT->GetInterfaceFromGlobal(dwCookie,
                                                     IID_IDispatch,
                                                     (LPVOID*)&pDisp);
            if (!hr)
            {
                V_VT(&varParam) = VT_DISPATCH;
                V_DISPATCH(&varParam) = pDisp;
            }
        }
        else
        {
            VariantCopy(&varParam, pscrParams->pvarParams);
        }
    }

    // Hold a reference on ourself while the script is running
    AddRef();

    if (_fIsPrimaryScript)
    {

        hr = THR(LoadTypeLibrary());

        // Ensure that ScriptMain() completes before we fire any other events.
        _fDontHandleEvents = TRUE;
    }

    if (hr)
    {
        ThreadStarted(hr);
        goto Cleanup;
    }
    hr = ExecuteTopLevelScript(cstrScript, &varParam);
    if (hr)
    {
        ThreadStarted(hr);
        TraceTag((tagError, "Failed to execute script: %x", hr));
        AssertSz(!_fIsPrimaryScript, "Failed to execute script");

        PostQuitMessage(0);
        goto Cleanup;
    }
    ThreadStarted(hr);
    FireEvent(DISPID_MTScript_ScriptMain, 0, NULL);
    //
    // Secondary scripts go away as soon as they're done.
    //
    if (_fIsPrimaryScript)
    {
        DWORD dwRet;

        _fDontHandleEvents = FALSE;

        dwRet = MessageEventPump(TRUE);

        AssertSz(dwRet == MEP_EXIT, "NONFATAL: Invalid return value from MessageEventPump!");
    }
    else
    {
        CScriptHost *pThis = this;

        PostToThread(_pMT,
                     MD_SECONDARYSCRIPTTERMINATE,
                     (LPVOID)&pThis,
                     sizeof(CScriptHost*));
    }

Cleanup:
    CloseScripts();

    VariantClear(&varParam);

    if (_fIsPrimaryScript)
    {
        int i;

        for (i = 0; i < s_arySyncEvents.Size(); i++)
        {
            CloseHandle(s_arySyncEvents[i]._hEvent);
            s_arySyncEvents[i]._cstrName.Free();
        }

        s_arySyncEvents.DeleteAll();

        for (i = 0; i < (int)s_cThreadLocks; i++)
        {
            DeleteCriticalSection(&s_aThreadLocks[i]._csLock);
            s_aThreadLocks[i]._cstrName.Free();
        }

        memset(&s_aThreadLocks, 0, sizeof(s_aThreadLocks));
        s_cThreadLocks = 0;
    }

    Release();
    CoUninitialize();
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptHost::MessageEventPump, public
//
//  Synopsis:   Empties our message queues (both windows' and our private
//              threadcomm queue)
//
//  Arguments:  [fWait]     -- If TRUE, will not return until an event occurs
//              [cEvents]   -- Count of events to monitor
//              [pEvents]   -- Pointer to list of event handles
//              [fAll]      -- If TRUE, don't return until all handles in
//                               pEvents are signaled.
//              [dwTimeout] -- Timeout after this many ms if nothing signals
//              [fNoEvents] -- If TRUE, don't fire events while waiting
//
//  Returns:    MEP_TIMEOUT: The given timeout period expired without any
//                           event objects becoming signaled. Returned only
//                           if dwTimeout != INFINITE
//              MEP_EXIT: An event occurred which is causing this thread to
//                        terminate. The caller should clean up and finish
//                        what it's doing.
//              MEP_FALLTHROUGH: Indicates that no objects signaled.
//                               Returned only if fWait==FALSE.
//              MEP_EVENT_0: If one (or all if fAll==TRUE) of the passed-in
//                           event handles became signaled. The index of the
//                           signaled handle is added to MEP_EVENT_0. Returned
//                           only if one or more event handles were passed in.
//
//----------------------------------------------------------------------------

DWORD
CScriptHost::MessageEventPump(BOOL    fWait,
                              UINT    cEvents   /* = 0        */,
                              HANDLE *pEvents   /* = NULL     */,
                              BOOL    fAll      /* = FALSE    */,
                              DWORD   dwTimeout /* = INFINITE */,
                              BOOL    fNoEvents /* = FALSE    */)
{
    CStackPtrAry<HANDLE, 5> aryHandles;

    MSG   msg;
    DWORD dwRet;
    DWORD mepReturn = MEP_FALLTHROUGH;

    _int64 i64Freq = 0;
    _int64 i64Time;
    _int64 i64Goal  = 0;
    long   lTimeout = dwTimeout;
    BOOL   fTimeout = dwTimeout != INFINITE;

    if (cEvents)
    {
        aryHandles.CopyIndirect(cEvents, pEvents, FALSE);
    }

    if (_fMustExitThread)
    {
        return MEP_EXIT;
    }

    // WARNING! aryHandles will get rebuilt under certain conditions below.
    // If you add code which adds handles to the array, you must update the
    // code below as well!

    if (!fNoEvents && !_fDontHandleEvents)
    {
        aryHandles.Insert(0, _hCommEvent);
    }
    else if (fNoEvents)
    {
        _fDontHandleEvents = TRUE;
    }

    if (fTimeout)
    {
        QueryPerformanceFrequency((LARGE_INTEGER*)&i64Freq);
        QueryPerformanceCounter((LARGE_INTEGER*)&i64Time);

        // Resolution must be at least milliseconds
        Assert(i64Freq >= 1000);

        // Compute the time when the timer will be complete, converted to ms
        i64Goal = ((i64Time * 1000) / i64Freq) + lTimeout;
    }

    do
    {
        //
        // Purge out all window messages (primarily for OLE's benefit).
        //
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                _fMustExitThread = TRUE;
                return MEP_EXIT;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if (_fMustExitThread)
        {
            AbortScripts();
            return MEP_EXIT;
        }

        dwRet = MsgWaitForMultipleObjects(aryHandles.Size(),
                                          aryHandles,
                                          FALSE,
                                          (fWait) ? (DWORD)lTimeout : 0,
                                          QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0 && !_fDontHandleEvents)
        {
            //
            // Another thread is sending us a message.
            //
            HandleThreadMessage();
        }
        else if (dwRet < WAIT_OBJECT_0 + aryHandles.Size())
        {
            Assert(cEvents);

            int iEvent = dwRet - WAIT_OBJECT_0;

            //
            // One of the events the script is waiting for has been signaled.
            //
            if (fAll)
            {
                // They want to wait for all the events. Remove the signaled
                // event from the array and if it's the last one then we're
                // there!

                aryHandles.Delete(iEvent);

                if (aryHandles.Size() == ((_fDontHandleEvents) ? 0 : 1))
                {
                    // All the events have come back signaled. Check that none
                    // have become unsignaled.
                    if (WaitForMultipleObjects(cEvents, pEvents, TRUE, 0) == WAIT_TIMEOUT)
                    {
                        // Something became unsignaled. Start over! Rebuild
                        // the array of handles.

                        aryHandles.CopyIndirect(cEvents, pEvents, FALSE);

                        if (!_fDontHandleEvents)
                        {
                            aryHandles.Insert(0, _hCommEvent);
                        }
                    }
                    else
                    {
                        mepReturn = MEP_EVENT_0;

                        break;
                    }
                }
            }
            else
            {
                mepReturn = MEP_EVENT_0 + iEvent;

                if (!_fDontHandleEvents)
                {
                    mepReturn--;
                }

                break;
            }
        }
        else if (dwRet == WAIT_OBJECT_0 + aryHandles.Size())
        {
            //
            // A windows message came through. It will be handled at the
            // top of the loop.
            //
        }
        else if (dwRet == WAIT_FAILED)
        {
            TraceTag((tagError, "WaitForMultipleObjects failure (%d)", GetLastError()));

            AssertSz(FALSE, "WaitForMultipleObjects failure");

            _fMustExitThread = TRUE;

            mepReturn = MEP_EXIT;

            break;
        }
        else
        {
            Assert(dwRet == WAIT_TIMEOUT);

            mepReturn = MEP_TIMEOUT;

            break;
        }

        // Since any number of things could have brought us out of MWFMO,
        // we need to compute the remaining timeout for the next time around.

        if (fTimeout)
        {
            QueryPerformanceCounter((LARGE_INTEGER*)&i64Time);

            // Convert current time to milliseconds.
            i64Time = ((i64Time * 1000) / i64Freq);

            // Compute the delta between the current time and our goal
            lTimeout = (DWORD)(i64Goal - i64Time);

            // Are we timed out?
            if (lTimeout <= 0)
            {
                mepReturn = MEP_TIMEOUT;

                break;
            }
        }
    }
    while (fWait);  // Only do the loop once if fWait == FALSE

    if (fNoEvents)
    {
        _fDontHandleEvents = FALSE;
    }

    // MEP_FALLTHROUGH is not a valid return if fWait == TRUE
    Assert(!fWait || mepReturn != MEP_FALLTHROUGH);

    return mepReturn;
}

void
CScriptHost::HandleThreadMessage()
{
    VERIFY_THREAD();

    THREADMSG tm;
    BYTE      bData[MSGDATABUFSIZE];
    DWORD     cbData;

    if (_fDontHandleEvents)
        return;

    //
    //$ FUTURE: Add a way to filter messages so we can check for MD_PLEASEEXIT
    // without pulling off the event messages
    //
    while (GetNextMsg(&tm, (void **)bData, &cbData))
    {
        switch (tm)
        {
        case MD_PLEASEEXIT:
            //
            // We're being asked to terminate.
            //
            AbortScripts();
            PostQuitMessage(0);
            break;

        case MD_MACHINECONNECT:
            AssertSz(_fIsPrimaryScript, "Non-primary script got machine event!");

            _fDontHandleEvents = TRUE;

            FireEvent(DISPID_MTScript_OnMachineConnect, 0, NULL);

            _fDontHandleEvents = FALSE;
            break;

        case MD_MACHEVENTCALL:
            AssertSz(_fIsPrimaryScript, "Non-primary script got machine event!");
            Assert(cbData == sizeof(MACHPROC_EVENT_DATA*));

            _fDontHandleEvents = TRUE;

            // This call will set the event object in the
            // MACHPROC_EVENT_DATA struct when everything completes.
            FireMachineEvent(*(MACHPROC_EVENT_DATA**)bData, TRUE);

            _fDontHandleEvents = FALSE;
            break;

        case MD_PROCESSDATA:
            Assert(cbData == sizeof(MACHPROC_EVENT_DATA*));

            _fDontHandleEvents = TRUE;

            // This call will set the event object in the
            // MACHPROC_EVENT_DATA struct when everything completes.
            FireMachineEvent(*(MACHPROC_EVENT_DATA**)bData, FALSE);

            _fDontHandleEvents = FALSE;
            break;

        case MD_PROCESSEXITED:
        case MD_PROCESSTERMINATED:
        case MD_PROCESSCONNECTED:
        case MD_PROCESSCRASHED:
            Assert(cbData == sizeof(CProcessThread*));

            _fDontHandleEvents = TRUE;

            FireProcessEvent(tm, *(CProcessThread**)bData);

            _fDontHandleEvents = FALSE;

            break;

        default:
            AssertSz(FALSE, "CScriptHost got a message it couldn't handle!");
            break;
        }
    }
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::PushScript
//
//  Create a new script site/engine and push it on the script stack
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::PushScript(TCHAR *pchName)
{
    VERIFY_THREAD();

    HRESULT hr;
    CScriptSite * pScriptSite;
    TCHAR       * pchFile;

    hr = LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    pScriptSite = new CScriptSite(this);
    if(!pScriptSite)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pchFile = _tcsrchr(pchName, _T('\\'));
    if (!pchFile)
    {
        pchFile = pchName;
    }
    else
        pchFile++;

    hr = pScriptSite->Init(pchFile);
    if (hr)
    {
        delete pScriptSite;
        pScriptSite = NULL;
        goto Cleanup;
    }

    pScriptSite->_pScriptSitePrev = _pScriptSite;
    _pScriptSite = pScriptSite;

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::PopScript
//
//  Pop last script site/engine off the script stack
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::PopScript()
{
    VERIFY_THREAD();

    CScriptSite * pScriptSite = _pScriptSite;

    if(!_pScriptSite)
        return S_FALSE;

    _pScriptSite = _pScriptSite->_pScriptSitePrev;

    pScriptSite->Close();
    pScriptSite->Release();

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member: CScriptHost::CloseScripts
//
//  Clear the stack of script engines
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::CloseScripts()
{
    VERIFY_THREAD();

    while(PopScript() == S_OK)
        ;

    AssertSz(_pScriptSite == NULL, "Should have released script site");

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::AbortScripts
//
//  Clear the stack of script engines
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::AbortScripts()
{
    VERIFY_THREAD();

    // Make sure we're not stuck on MsgWaitForMultipleObjects and that we
    //   never will be again.

    _fMustExitThread = TRUE;
    SetEvent(_hCommEvent);

    CScriptSite * pScriptSite;

    pScriptSite = _pScriptSite;

    while (pScriptSite)
    {
        pScriptSite->Abort();

        pScriptSite = pScriptSite->_pScriptSitePrev;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::ExecuteTopLevelScript
//
//  Close previous top level script engine then load and execute script
//  in a new top level script engine
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::ExecuteTopLevelScript(TCHAR * pchPath, VARIANT *pvarParams)
{
    VERIFY_THREAD();

    HRESULT hr;

    // Stablize reference count during script execution.
    // Script can hide window which decrements reference count.

    AddRef();

    // Getting read to close the scripts fire unload event.
    CloseScripts();

    hr = THR(PushScript(pchPath));
    if(hr)
        goto Cleanup;

    hr = THR(VariantCopy(&_pScriptSite->_varParam, pvarParams));
    if (hr)
        goto Cleanup;

    hr = THR(_pScriptSite->ExecuteScriptFile(pchPath));
    if(hr)
        goto Cleanup;

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));
    if (hr)
        goto Cleanup;

Cleanup:
    Release();
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::ExecuteScriptlet
//
//  Add a scriptlet to the current top level script engine and execute it
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::ExecuteTopLevelScriptlet(TCHAR * pchScript)
{
    VERIFY_THREAD();

    HRESULT hr;

    // Stablize reference count during script execution.
    // Script can hide window which decrements reference count.

    AddRef();

    if(!_pScriptSite)
    {
        hr = THR(PushScript(_T("Scriptlet")));
        if(hr)
            goto Cleanup;
    }
    else
    {
        Assert(_pScriptSite->_pScriptSitePrev == NULL);
    }

    hr = THR(_pScriptSite->ExecuteScriptStr(pchScript));
    if (hr)
        goto Cleanup;

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));

Cleanup:
    Release();
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptHost::FireProcessEvent, public
//
//  Synopsis:   Fires an OnProcessEvent event into the script
//
//----------------------------------------------------------------------------

void
CScriptHost::FireProcessEvent(THREADMSG tm, CProcessThread *pProc)
{
    VARIANTARG  varg[3];
    TCHAR      *pszMsg;
    DISPID      dispid = DISPID_MTScript_OnProcessEvent;

    VERIFY_THREAD();

    VariantInit(&varg[0]);
    VariantInit(&varg[1]);
    VariantInit(&varg[2]);

    // Parameters are in order from last to first

    V_VT(&varg[2]) = VT_I4;
    V_I4(&varg[2]) = pProc->ProcId();

    switch (tm)
    {
    case MD_PROCESSEXITED:
        pszMsg = _T("exited");

        V_VT(&varg[0]) = VT_I4;
        V_I4(&varg[0]) = pProc->GetExitCode();
        break;

    case MD_PROCESSCRASHED:
        pszMsg = _T("crashed");

        // 3rd parameter is empty
        break;

    case MD_PROCESSTERMINATED:
        pszMsg = _T("terminated");

        // 3rd parameter is empty
        break;

    case MD_PROCESSCONNECTED:
        pszMsg = _T("connected");

        // 3rd parameter is empty
        break;

    default:
        AssertSz(FALSE, "NONFATAL: Invalid THREADMSG value");
        return;
        break;
    }

    V_VT(&varg[1])   = VT_BSTR;
    V_BSTR(&varg[1]) = SysAllocString(pszMsg); // NULL is a valid value for BSTR

    FireEvent(dispid, 3, varg);

    VariantClear(&varg[0]);
    VariantClear(&varg[1]);
    VariantClear(&varg[2]);

    return;
}

long CScriptHost::FireScriptErrorEvent(
                                        TCHAR *bstrFile,
                                        long nLine,
                                        long nChar,
                                        TCHAR *bstrText,
                                        long sCode,
                                        TCHAR *bstrSource,
                                        TCHAR *bstrDescription)
{
    long      cSucceeded = 0;

    VERIFY_THREAD();

    // Parameters are in order from last to first
    AutoVariant varg[7];
    cSucceeded += varg[6].Set(bstrFile);
    cSucceeded += varg[5].Set(nLine);
    cSucceeded += varg[4].Set(nChar);
    cSucceeded += varg[3].Set(bstrText);
    cSucceeded += varg[2].Set(sCode);
    cSucceeded += varg[1].Set(bstrSource);
    cSucceeded += varg[0].Set(bstrDescription);

    if (cSucceeded != ARRAY_SIZE(varg))
        return 0; // Default return value

    AutoVariant varResult;
    FireEvent(DISPID_MTScript_OnScriptError, ARRAY_SIZE(varg), varg, &varResult);
    AutoVariant varResultInt;
    if (VariantChangeType(&varResultInt, &varResult, 0, VT_I4) == S_OK)
        return  V_I4(&varResultInt);

    return 0;
}
//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireMachineEvent
//
//  Notes:  Fires the OnRemoteExec event when a machine connected to us
//          remotely calls the Exec() method.
//
//---------------------------------------------------------------------------

void
CScriptHost::FireMachineEvent(MACHPROC_EVENT_DATA *pmed, BOOL fExec)
{

    VERIFY_THREAD();

    DISPID      dispid = (fExec)
                           ? DISPID_MTScript_OnRemoteExec
                           : DISPID_MTScript_OnProcessEvent;
    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr = 0;
    VARIANTARG  vararg[3];
    VARIANTARG  varResult;
    HRESULT     hr = S_OK;

    pmed->hrReturn = S_OK;

    if (GetSite() && GetSite()->_pDispSink)
    {
        VariantInit(&vararg[0]);
        VariantInit(&vararg[1]);
        VariantInit(&vararg[2]);
        VariantInit(&varResult);

        // Params are in order from last to first in the array
        V_VT(&vararg[0]) = VT_BSTR;
        V_BSTR(&vararg[0]) = pmed->bstrParams;

        V_VT(&vararg[1]) = VT_BSTR;
        V_BSTR(&vararg[1]) = pmed->bstrCmd;

        if (!fExec)
        {
            V_VT(&vararg[2]) = VT_I4;
            V_I4(&vararg[2]) = pmed->dwProcId;
        }

        dp.rgvarg            = vararg;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs             = (fExec) ? 2 : 3;
        dp.cNamedArgs        = 0;

        hr = GetSite()->_pDispSink->Invoke(dispid,
                                           IID_NULL,
                                           0,
                                           DISPATCH_METHOD,
                                           &dp,
                                           &varResult,
                                           &ei,
                                           &uArgErr);
        pmed->hrReturn = hr;

        if (hr)
        {
            // If an error occurred, do nothing except return the error code.
        }
        // Check for data types which we don't support.
        else if (   V_ISBYREF(&varResult)
                 || V_ISARRAY(&varResult)
                 || V_ISVECTOR(&varResult)
                 || V_VT(&varResult) == VT_UNKNOWN)
        {
            // Do nothing. Return an empty result
            AssertSz(FALSE, "NONFATAL: Unsupported data type returned from OnRemoteExec event");
        }
        else if (V_VT(&varResult) == VT_DISPATCH)
        {
            if (fExec)
            {
                // Note that the return value is an IDispatch, but don't set the
                // pointer because it will need to be retrieved out of the GIT
                V_VT(pmed->pvReturn)       = VT_DISPATCH;
                V_DISPATCH(pmed->pvReturn) = NULL;

                hr =_pMT->_pGIT->RegisterInterfaceInGlobal(V_DISPATCH(&varResult),
                                                           IID_IDispatch,
                                                           &pmed->dwGITCookie);
                if (hr)
                {
                    pmed->hrReturn = hr;
                }
            }

            // Leave the result empty if they returned an IDispatch from an
            //   OnProcessEvent call.
        }
        else
        {
            VariantCopy(pmed->pvReturn, &varResult);
        }

        VariantClear(&varResult);
    }

    // Tell the calling thread we're done with the call and it can continue.
    SetEvent(pmed->hEvent);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireEvent
//
//---------------------------------------------------------------------------

void
CScriptHost::FireEvent(DISPID dispid, UINT cArg, VARIANTARG *pvararg, VARIANTARG *pvarResult)
{
    VERIFY_THREAD();

    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr = 0;

    if (GetSite() && GetSite()->_pDispSink)
    {
        dp.rgvarg            = pvararg;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs             = cArg;
        dp.cNamedArgs        = 0;

        GetSite()->_pDispSink->Invoke(
                dispid,
                IID_NULL,
                0,
                DISPATCH_METHOD,
                &dp,
                pvarResult,
                &ei,
                &uArgErr);
    }
}

void
CScriptHost::FireEvent(DISPID dispid, UINT carg, VARIANTARG *pvararg)
{
    FireEvent(dispid, carg, pvararg, NULL);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireEvent
//
//---------------------------------------------------------------------------

void
CScriptHost::FireEvent(DISPID dispid, LPCTSTR pch)
{
    VERIFY_THREAD();

    VARIANT var;

    V_BSTR(&var) = SysAllocString(pch);
    V_VT(&var) = VT_BSTR;
    FireEvent(dispid, 1, &var);
    SysFreeString(V_BSTR(&var));
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireEvent
//
//---------------------------------------------------------------------------

void
CScriptHost::FireEvent(DISPID dispid, BOOL fArg)
{
    VERIFY_THREAD();

    VARIANT var;

    V_BOOL(&var) = fArg ? VARIANT_TRUE : VARIANT_FALSE;
    V_VT(&var) = VT_BOOL;
    FireEvent(dispid, 1, &var);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireEvent
//
//---------------------------------------------------------------------------

void
CScriptHost::FireEvent(DISPID dispid, IDispatch *pDisp)
{
    VERIFY_THREAD();

    VARIANT var;

    V_DISPATCH(&var) = pDisp;
    V_VT(&var) = VT_DISPATCH;
    FireEvent(dispid, 1, &var);
}

HRESULT
CScriptHost::LoadTypeLibrary()
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    if (!_pTypeLibEXE)
    {
        // BUGBUG -- Is this valid, or does this need to be marshalled?

        _pTypeLibEXE = _pMT->_pTypeLibEXE;
    }

    if (!_pTypeInfoCMTScript)
    {
        hr = THR(_pTypeLibEXE->GetTypeInfoOfGuid(CLSID_LocalMTScript, &_pTypeInfoCMTScript));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoIGlobalMTScript)
    {
        hr = THR(_pTypeLibEXE->GetTypeInfoOfGuid(IID_IGlobalMTScript, &_pTypeInfoIGlobalMTScript));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

void
CScriptHost::GetScriptPath(CStr *pcstrPath)
{
    _pMT->_options.GetScriptPath(pcstrPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\scrhost\ssite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       bsssite.hxx
//
//  Contents:   CBServerScriptSite
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#undef ASSERT

// ************************************************************************
//
// CConnectionPoint
//
// ************************************************************************

CConnectionPoint::CConnectionPoint(CScriptSite *pSite)
{
    _ulRefs = 1;
    _pSite = pSite;
    _pSite->AddRef();
}

CConnectionPoint::~CConnectionPoint()
{
    _pSite->Release();
}

HRESULT
CConnectionPoint::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CConnectionPoint::GetConnectionInterface(IID * pIID)
{
    *pIID = DIID_DLocalMTScriptEvents;
    return S_OK;
}

HRESULT
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    *ppCPC = _pSite;
    (*ppCPC)->AddRef();
    return S_OK;
}

HRESULT
CConnectionPoint::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    *pdwCookie = 0;

    ClearInterface(&_pSite->_pDispSink);
    RRETURN(THR(pUnkSink->QueryInterface(IID_IDispatch, (void **)&_pSite->_pDispSink)));
}

HRESULT
CConnectionPoint::Unadvise(DWORD dwCookie)
{
    ClearInterface(&_pSite->_pDispSink);
    return S_OK;
}

HRESULT
CConnectionPoint::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    *ppEnum = NULL;
    RRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// CScriptSite
//
// ************************************************************************

STDMETHODIMP
CScriptSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IActiveScriptSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IActiveScriptSite *) this;
    }
    else if (iid == IID_IGlobalMTScript || iid == IID_IDispatch)
    {
        *ppv = (IGlobalMTScript *)this;
    }
    else if (iid == IID_IActiveScriptSiteDebug)
    {
        *ppv = (IActiveScriptSiteDebug *)this;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *ppv = (IConnectionPointContainer *)this;
    }
    else if (iid == IID_IProvideClassInfo ||
            iid == IID_IProvideClassInfo2 ||
            iid == IID_IProvideMultipleClassInfo)
    {
        *ppv = (IProvideMultipleClassInfo *)this;
    }
    else if (iid == IID_IActiveScriptSiteWindow)
    {
        *ppv = (IActiveScriptSiteWindow *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite constructor
//
//---------------------------------------------------------------------------

CScriptSite::CScriptSite(CScriptHost *pScriptHost)
    : _cstrName(CSTR_NOINIT)
{
    _pSH    = pScriptHost;
    _ulRefs = 1;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite destructor
//
//---------------------------------------------------------------------------

CScriptSite::~CScriptSite()
{
    VariantClear(&_varParam);
    ClearInterface(&_pDispSink);
    AssertSz(_ulRefs <= 1, "Object not properly released on destruction!");

    if (_pDDH)
    {
        _pDDH->Detach();
        ClearInterface(&_pDDH);
    }
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::AddRef, Release
//
//---------------------------------------------------------------------------

ULONG
CScriptSite::AddRef()
{
    _ulRefs += 1;
    return _ulRefs;
}

ULONG
CScriptSite::Release()
{
    if (--_ulRefs == 0)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::Init
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::Init(LPWSTR pszName)
{
    HRESULT hr;
    IActiveScriptParse *pParse = NULL;
    static const CLSID CLSID_JSCRIPT = { 0xf414c260, 0x6ac0, 0x11cf, 0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58};
    WCHAR  *pch;

    _cstrName.Set(pszName);

    hr = THR(ScriptHost()->_pMT->HackCreateInstance(CLSID_JSCRIPT,
                                                    NULL,
                                                    CLSCTX_INPROC_SERVER,
                                                    IID_IActiveScript,
                                                    (void **)&_pScript));
    if (hr)
    {
        hr = THR(CoCreateInstance(CLSID_JSCRIPT,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IActiveScript,
                                  (void **)&_pScript));
    }

    if (hr)
        goto Cleanup;

    if (ScriptHost()->_pMT->_pPDM)
    {
        Assert(_pDDH == NULL);

        hr = ScriptHost()->_pMT->_pPDM->CreateDebugDocumentHelper(NULL, &_pDDH);
        if (SUCCEEDED(hr))
        {
            hr = THR(_pDDH->Init(ScriptHost()->_pMT->_pDA,
                                 _cstrName,
                                 _cstrName,
                                 0));
            if (hr)
                goto Cleanup;

            hr = THR(_pDDH->Attach((_pScriptSitePrev)
                                       ? _pScriptSitePrev->_pDDH
                                       : NULL));
            if (hr)
                goto Cleanup;
        }
    }

    for (pch = _cstrName; *pch; pch++)
    {
        if (*pch == L'.')
        {
            *pch = L'_';
        }
    }

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pParse));
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->SetScriptSite(this));
    if (hr)
        goto Cleanup;

    hr = THR(pParse->InitNew());
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->AddNamedItem(_cstrName, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE | SCRIPTITEM_GLOBALMEMBERS));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParse);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
// Method:  CScriptSite::Close
//
//---------------------------------------------------------------------------

void
CScriptSite::Close()
{
    if (_pScript)
    {
        _pScript->Close();
        ClearInterface(&_pScript);
    }
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::Abort
//
//---------------------------------------------------------------------------

void
CScriptSite::Abort()
{
    if (_pScript)
    {
        HRESULT hr;

        hr = THR(_pScript->InterruptScriptThread(SCRIPTTHREADID_CURRENT,
                                                 NULL,
                                                 0));
    }
}


//---------------------------------------------------------------------------
//
//  Member:     CScriptSite::GetClassInfo, IProvideClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetClassInfo(ITypeInfo **ppTypeInfo)
{
    HRESULT hr;

    hr = ScriptHost()->LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    *ppTypeInfo = ScriptHost()->_pTypeInfoCMTScript;
    (*ppTypeInfo)->AddRef();

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptSite::GetGUID, IProvideClassInfo2
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetGUID(DWORD dwGuidKind, GUID * pGUID)
{
    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
    {
        *pGUID = DIID_DLocalMTScriptEvents;
    }
    else
    {
        return E_NOTIMPL;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptSite::GetMultiTypeInfoCount, IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------


HRESULT
CScriptSite::GetMultiTypeInfoCount(ULONG *pc)
{
    *pc = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptSite::GetInfoOfIndex, IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetInfoOfIndex(
    ULONG       itinfo,
    DWORD       dwFlags,
    ITypeInfo** pptinfoCoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    AssertSz(itinfo == 0, "itinfo == 0");

    if (dwFlags & MULTICLASSINFO_GETTYPEINFO)
    {
        *pptinfoCoClass = ScriptHost()->_pTypeInfoCMTScript;
        (*pptinfoCoClass)->AddRef();
        if (pdwTIFlags)
            *pdwTIFlags = 0;
    }

    if (dwFlags & MULTICLASSINFO_GETNUMRESERVEDDISPIDS)
    {
        *pcdispidReserved = 100;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDPRIMARY)
    {
        *piidPrimary = IID_IGlobalMTScript;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDSOURCE)
    {
        *piidSource = DIID_DLocalMTScriptEvents;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptSite::EnumConnectionPoints, IConnectionPointContainer
//
//---------------------------------------------------------------------------
HRESULT
CScriptSite::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptSite::FindConnectionPoint, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT* ppCpOut)
{
    HRESULT hr;

    if (iid == DIID_DLocalMTScriptEvents || iid == IID_IDispatch)
    {
        *ppCpOut = new CConnectionPoint(this);
        hr = *ppCpOut ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::GetLCID, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetLCID(LCID *plcid)
{
    return E_NOTIMPL;     // Use system settings
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::GetItemInfo, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetItemInfo(
      LPCOLESTR   pstrName,
      DWORD       dwReturnMask,
      IUnknown**  ppunkItemOut,
      ITypeInfo** pptinfoOut)
{
    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        if (!pptinfoOut)
            return E_INVALIDARG;
        *pptinfoOut = NULL;
    }

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if (!ppunkItemOut)
            return E_INVALIDARG;
        *ppunkItemOut = NULL;
    }

    if (!_wcsicmp(_cstrName, pstrName))
    {
        if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
        {
            *pptinfoOut = ScriptHost()->_pTypeInfoCMTScript;
            (*pptinfoOut)->AddRef();
        }
        if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
        {
            *ppunkItemOut = (IGlobalMTScript *)this;
            (*ppunkItemOut)->AddRef();
        }
        return S_OK;
    }


    return TYPE_E_ELEMENTNOTFOUND;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::GetDocVersionString, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetDocVersionString(BSTR *pbstrVersion)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::RequestItems()
{
    return _pScript->AddNamedItem(_cstrName, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::RequestTypeLibs, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::RequestTypeLibs()
{
    return _pScript->AddTypeLib(LIBID_MTScriptEngine, 1, 0, 0);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnScriptTerminate, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::OnScriptTerminate(const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo)
{
    // UNDONE: Put up error dlg here
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnStateChange, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
    // Don't care about notification
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnScriptError, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::OnScriptError(IActiveScriptError *pse)
{
    long        nScriptErrorResult = 0;
    BSTR        bstrLine = NULL;
    TCHAR *     pchDescription;
    TCHAR       achDescription[256];
    TCHAR       achMessage[1024];
    EXCEPINFO   ei;
    DWORD       dwSrcContext;
    ULONG       ulLine;
    LONG        ichError;
    HRESULT     hr;
    LONG        iRet = IDYES;

    TraceTag((tagError, "OnScriptError!"));

    if (ScriptHost()->_fMustExitThread)
    {
        return S_OK;
    }

    hr = THR(pse->GetExceptionInfo(&ei));
    if (hr)
        goto Cleanup;

    hr = THR(pse->GetSourcePosition(&dwSrcContext, &ulLine, &ichError));
    if (hr)
        goto Cleanup;

    hr = THR(pse->GetSourceLineText(&bstrLine));
    if (hr)
        hr = S_OK;  // Ignore this error, there may not be source available

    if (ei.bstrDescription)
    {
        pchDescription = ei.bstrDescription;
    }
    else
    {
        achDescription[0] = 0;
        FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                ei.scode,
                LANG_SYSTEM_DEFAULT,
                achDescription,
                ARRAY_SIZE(achDescription),
                NULL);
        pchDescription = achDescription;
    }

// First, lets format a message nice for OUTPUTDEBUGSTRING
    _snwprintf(achMessage, ARRAY_SIZE(achMessage),
        _T("Thread: %s")
        _T("File: %s ")
        _T("Line: %d ")
        _T("Char: %d ")
        _T("Text: %s ")
        _T("Scode: %x ")
        _T("Source: %s ")
        _T("Description: %s"),
        (LPTSTR)_cstrName,
        _achPath,
        (long)(ulLine + 1),
        (long)(ichError),
        bstrLine ? bstrLine : _T(""),
        ei.scode,
        ei.bstrSource ? ei.bstrSource : _T(""),
        pchDescription
        );
    achMessage[ARRAY_SIZE(achMessage) - 1] = 0;
    OUTPUTDEBUGSTRING(achMessage);
    //Assert(!_fInScriptError);
    if (!_fInScriptError)
    {
        _fInScriptError = true;
        nScriptErrorResult = _pSH->FireScriptErrorEvent(
                _achPath,
                ulLine + 1,
                ichError,
                bstrLine ? bstrLine : _T(""),
                ei.scode,
                ei.bstrSource ? ei.bstrSource : _T(""),
                pchDescription);
        _fInScriptError = false;
    }

    if (nScriptErrorResult == 0)
    {
        _snwprintf(achMessage, ARRAY_SIZE(achMessage),
            _T("Thread: %s\r\n")
            _T("File: %s\r\n")
            _T("Line: %d\r\n")
            _T("Char: %d\r\n")
            _T("Text: %s\r\n")
            _T("Scode: %x\r\n")
            _T("Source: %s\r\n")
            _T("Description: %s\r\n")
            _T("%s"),
            (LPTSTR)_cstrName,
            _achPath,
            (long)(ulLine + 1),
            (long)(ichError),
            bstrLine ? bstrLine : _T(""),
            ei.scode,
            ei.bstrSource ? ei.bstrSource : _T(""),
            pchDescription,
            ((_fInDebugError) ? _T("\r\nDo you wish to debug?\r\n") : _T(""))
            );
        achMessage[ARRAY_SIZE(achMessage) - 1] = 0;

        MSGBOXPARAMS mbp;
        memset(&mbp, 0, sizeof(mbp));
        mbp.cbSize = sizeof(mbp);
        //mbp.hwndOwner = ScriptHost()->_pDoc->_hwnd;
        mbp.hwndOwner = NULL;
        mbp.lpszText = achMessage;
        mbp.lpszCaption = _T("Script Error");
        mbp.dwStyle = MB_APPLMODAL | MB_ICONERROR | ((_fInDebugError) ? MB_YESNO : MB_OK);

        iRet = MessageBoxIndirect(&mbp);
    }
    if (nScriptErrorResult == 1)
        hr = S_FALSE;
Cleanup:
    if(ei.bstrSource)
        SysFreeString(ei.bstrSource);
    if(ei.bstrDescription)
        SysFreeString(ei.bstrDescription);
    if(ei.bstrHelpFile)
        SysFreeString(ei.bstrHelpFile);

    if (bstrLine)
        SysFreeString(bstrLine);

    RRETURN1((_fInDebugError && !hr && iRet == IDYES) ? S_FALSE : hr, S_FALSE);
}


//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnEnterScript, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::OnEnterScript()
{
    // No need to do anything
    return S_OK;
}


//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnLeaveScript, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::OnLeaveScript()
{
    // No need to do anything
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::, IActiveScriptSiteWindow
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::GetWindow(HWND *phwndOut)
{
    //*phwndOut = ScriptHost()->_pDoc->_hwnd;
    *phwndOut = NULL;
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::EnableModeless, IActiveScriptSiteWindow
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::EnableModeless(BOOL fEnable)
{
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptSite::ExecuteScriptFile
//
//  Load and execute script file
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::ExecuteScriptFile(TCHAR *pchPath)
{
    HRESULT     hr;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       cchFile;
    DWORD       cbRead;
    char *      pchBuf = 0;
    TCHAR *     pchBufWide = 0;
    TCHAR *     pchFile;

    // Attempt to find the file. First, we try to use the path as given. If
    // that doesn't work, then we prefix the script path and try to find it.

    GetFullPathName(pchPath, ARRAY_SIZE(_achPath), _achPath, &pchFile);

    if (GetFileAttributes(_achPath) == 0xFFFFFFFF)
    {
        // The file apparently doesn't exist. Try pre-pending the ScriptPath
        // onto it.

        CStr cstrPath;

        ScriptHost()->GetScriptPath(&cstrPath);

        cstrPath.Append(L"\\");

        cstrPath.Append(pchPath);

        GetFullPathName(cstrPath, ARRAY_SIZE(_achPath), _achPath, &pchFile);
    }

    // Load script file

    hFile = CreateFile(_achPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    cchFile = GetFileSize(hFile, NULL);
    if (cchFile == 0xFFFFFFFF)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pchBuf = new char[cchFile + 1];
    pchBufWide = new TCHAR[cchFile + 1];
    if (!pchBuf || !pchBufWide)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!ReadFile(hFile, pchBuf, cchFile, &cbRead, 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    pchBuf[cbRead] = 0;

    MultiByteToWideChar(CP_ACP, 0, pchBuf, -1, pchBufWide, cchFile + 1);

    if (_pDDH)
    {
        pchFile = wcsrchr(pchPath, L'\\');
        if (!pchFile)
        {
            pchFile = pchPath;
        }
        else
            pchFile++;

        hr = THR(_pDDH->SetLongName(_achPath));
        if (hr)
            goto Cleanup;

        hr = THR(_pDDH->AddUnicodeText(pchBufWide));
        if (hr)
            goto Cleanup;

        hr = THR(_pDDH->DefineScriptBlock(0,
                                          cchFile,
                                          _pScript,
                                          TRUE,
                                          &_dwSourceContext));
        //if (hr)
        //    goto Cleanup;
    }

    // Execute script

    hr = ExecuteScriptStr(pchBufWide);
    if(hr)
        goto Cleanup;


Cleanup:
    delete pchBuf;
    delete pchBufWide;
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::ExecuteScriptStr
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::ExecuteScriptStr(TCHAR * pchScript)
{
    HRESULT hr;
    IActiveScriptParse * pParse = NULL;

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pParse));
    if (hr)
        goto Cleanup;

    hr = THR(pParse->ParseScriptText(pchScript, _cstrName, NULL, NULL, 0, 0, 0L, NULL, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParse);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::SetScriptState
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::SetScriptState(SCRIPTSTATE ss)
{
    return _pScript->SetScriptState(ss);
}

HRESULT
CScriptSite::GetDocumentContextFromPosition(DWORD dwSourceContext,
                                            ULONG uCharacterOffset,
                                            ULONG uNumChars,
                                            IDebugDocumentContext **ppsc)
{
    HRESULT hr;

    if (_pDDH)
    {
        ULONG ulStartPos;

        hr = _pDDH->GetScriptBlockInfo(dwSourceContext, NULL, &ulStartPos, NULL);
        if (hr)
            goto Cleanup;

        hr = _pDDH->CreateDebugDocumentContext(ulStartPos+uCharacterOffset,
                                               uNumChars,
                                               ppsc);
    }
    else
        hr = E_UNEXPECTED;

Cleanup:
    RRETURN(hr);
}

HRESULT
CScriptSite::GetApplication(IDebugApplication **ppda)
{
    *ppda = ScriptHost()->_pMT->_pDA;

    return (*ppda) ? S_OK : E_UNEXPECTED;
}

HRESULT
CScriptSite::GetRootApplicationNode(IDebugApplicationNode **ppdanRoot)
{
    if (!ScriptHost()->_pMT->_pDA || !_pDDH)
    {
        return E_UNEXPECTED;
    }

    return _pDDH->GetDebugApplicationNode(ppdanRoot);
}

HRESULT
CScriptSite::OnScriptErrorDebug(IActiveScriptErrorDebug *pErrorDebug,
                                BOOL *pfEnterDebugger,
                                BOOL *pfCallOnScriptErrorWhenContinuing)
{
    HRESULT hr;
    IActiveScriptError * pError;

    TraceTag((tagError, "OnScriptErrorDebug!"));

    *pfEnterDebugger = FALSE;
    *pfCallOnScriptErrorWhenContinuing = TRUE;

    if (ScriptHost()->_fMustExitThread)
    {
        return S_OK;
    }

    hr = pErrorDebug->QueryInterface(IID_IActiveScriptError, (LPVOID*)&pError);
    if (SUCCEEDED(hr))
    {
        _fInDebugError = TRUE;

        hr = OnScriptError(pError);

        _fInDebugError = FALSE;

        if (hr == S_FALSE)
        {
            *pfEnterDebugger = TRUE;
        }

        *pfCallOnScriptErrorWhenContinuing = TRUE;

        pError->Release();
    }

    return S_OK;
}


//---------------------------------------------------------------------------
//
// Method:  CScriptSite::xxx, IBServer
//
//          The implementation of IBServer passed to the script engine
//          cannot be the same as that of the CBServerDoc because this
//          causes a reference count loop with the script engine.
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::GetTypeInfoCount(UINT FAR* pctinfo)
            { return ScriptHost()->GetTypeInfoCount(pctinfo); }
HRESULT CScriptSite::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo FAR* FAR* pptinfo)
            { return ScriptHost()->GetTypeInfo(itinfo, lcid, pptinfo); }
HRESULT CScriptSite::GetIDsOfNames(
  REFIID riid,
  OLECHAR FAR* FAR* rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID FAR* rgdispid)
            { return ScriptHost()->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
HRESULT CScriptSite::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS FAR* pdispparams,
  VARIANT FAR* pvarResult,
  EXCEPINFO FAR* pexcepinfo,
  UINT FAR* puArgErr)
            { return ScriptHost()->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }


HRESULT CScriptSite::get_PublicData(VARIANT *pvData)
            { return ScriptHost()->get_PublicData(pvData); }
HRESULT CScriptSite::put_PublicData(VARIANT vData)
            { return ScriptHost()->put_PublicData(vData); }
HRESULT CScriptSite::get_PrivateData(VARIANT *pvData)
            { return ScriptHost()->get_PrivateData(pvData); }
HRESULT CScriptSite::put_PrivateData(VARIANT vData)
            { return ScriptHost()->put_PrivateData(vData); }
HRESULT CScriptSite::ExitProcess()
            { return ScriptHost()->ExitProcess(); }
HRESULT CScriptSite::Restart()
            { return ScriptHost()->Restart(); }
HRESULT CScriptSite::get_LocalMachine(BSTR *pbstrName)
            { return ScriptHost()->get_LocalMachine(pbstrName); }
HRESULT CScriptSite::Include(BSTR bstrPath)
            { return ScriptHost()->Include(bstrPath); }
HRESULT CScriptSite::CallScript(BSTR Path, VARIANT *ScriptParam)
            { return ScriptHost()->CallScript(Path, ScriptParam); }
HRESULT CScriptSite::SpawnScript(BSTR Path, VARIANT *ScriptParam)
            { return ScriptHost()->SpawnScript(Path, ScriptParam); }
HRESULT CScriptSite::get_ScriptParam(VARIANT *ScriptParam)
            { return ScriptHost()->get_ScriptParam(ScriptParam); }
HRESULT CScriptSite::get_ScriptPath(BSTR *bstrPath)
            { return ScriptHost()->get_ScriptPath(bstrPath); }
HRESULT CScriptSite::CallExternal(BSTR bstrDLLName, BSTR bstrFunctionName, VARIANT *pParam, long *plRetVal)
            { return ScriptHost()->CallExternal(bstrDLLName, bstrFunctionName, pParam, plRetVal); }
HRESULT CScriptSite::ResetSync(const BSTR bstrName)
            { return ScriptHost()->ResetSync(bstrName); }
HRESULT CScriptSite::WaitForSync(BSTR bstrName, long nTimeout, VARIANT_BOOL *pfTimedout)
            { return ScriptHost()->WaitForSync(bstrName, nTimeout, pfTimedout); }
HRESULT CScriptSite::WaitForMultipleSyncs(const BSTR bstrNameList, VARIANT_BOOL fWaitForAll, long nTimeout, long *plSignal)
            { return ScriptHost()->WaitForMultipleSyncs(bstrNameList, fWaitForAll, nTimeout, plSignal); }
HRESULT CScriptSite::SignalThreadSync(BSTR bstrName)
            { return ScriptHost()->SignalThreadSync(bstrName); }
HRESULT CScriptSite::TakeThreadLock(BSTR bstrName)
            { return ScriptHost()->TakeThreadLock(bstrName); }
HRESULT CScriptSite::ReleaseThreadLock(BSTR bstrName)
            { return ScriptHost()->ReleaseThreadLock(bstrName); }
HRESULT CScriptSite::DoEvents()
            { return ScriptHost()->DoEvents(); }
HRESULT CScriptSite::MessageBoxTimeout(BSTR msg, long cBtn, BSTR btnText, long time, long intrvl, VARIANT_BOOL cancel, VARIANT_BOOL confirm, long *plSel)
            { return ScriptHost()->MessageBoxTimeout(msg, cBtn, btnText, time, intrvl, cancel, confirm, plSel); }
HRESULT CScriptSite::RunLocalCommand(BSTR bstrCmd, BSTR bstrDir, BSTR bstrTitle, VARIANT_BOOL fMin, VARIANT_BOOL fGetOut, VARIANT_BOOL fWait, VARIANT_BOOL fNoPopup, VARIANT_BOOL fNoEnviron, long *plError)
            { return ScriptHost()->RunLocalCommand(bstrCmd, bstrDir, bstrTitle, fMin, fGetOut, fWait, fNoPopup, fNoEnviron, plError); }
HRESULT CScriptSite::CopyOrAppendFile(BSTR bstrSrc, BSTR bstrDst, long nSrcOffset, long nSrcLength, VARIANT_BOOL  fAppend, long *nSrcFilePosition)
            { return ScriptHost()->CopyOrAppendFile(bstrSrc, bstrDst, nSrcOffset, nSrcLength, fAppend, nSrcFilePosition); }
HRESULT CScriptSite::GetLastRunLocalError(long *plErrorCode)
            { return ScriptHost()->GetLastRunLocalError(plErrorCode); }
HRESULT CScriptSite::GetProcessOutput(long lProcessID, BSTR *pbstrData)
            { return ScriptHost()->GetProcessOutput(lProcessID, pbstrData); }
HRESULT CScriptSite::GetProcessExitCode(long lProcessID, long *plExitCode)
            { return ScriptHost()->GetProcessExitCode(lProcessID, plExitCode); }
HRESULT CScriptSite::TerminateProcess(long lProcessID)
            { return ScriptHost()->TerminateProcess(lProcessID); }
HRESULT CScriptSite::SendToProcess(long lProcessID, BSTR bstrType, BSTR bstrData, long *plReturn)
            { return ScriptHost()->SendToProcess(lProcessID, bstrType, bstrData, plReturn); }
HRESULT CScriptSite::SendMail(BSTR to, BSTR cc, BSTR bcc, BSTR subject, BSTR msg, BSTR attach, BSTR user, BSTR pass, long *plError)
            { return ScriptHost()->SendMail(to, cc, bcc, subject, msg, attach, user, pass, plError); }
HRESULT CScriptSite::SendSMTPMail(BSTR from, BSTR to, BSTR cc, BSTR subject, BSTR msg, BSTR host, long *plError)
            { return ScriptHost()->SendSMTPMail(from, to, cc, subject, msg, host, plError); }
HRESULT CScriptSite::OUTPUTDEBUGSTRING(BSTR LogMsg)
            { return ScriptHost()->OUTPUTDEBUGSTRING(LogMsg); }
HRESULT CScriptSite::UnevalString(BSTR in, BSTR *out)
            { return ScriptHost()->UnevalString(in, out); }
HRESULT CScriptSite::ASSERT(VARIANT_BOOL Assertion, BSTR LogMsg)
            { return ScriptHost()->ASSERT(Assertion, LogMsg); }
HRESULT CScriptSite::Sleep (int nTimeout)
            { return ScriptHost()->Sleep (nTimeout); }
HRESULT CScriptSite::Reboot ()
            { return ScriptHost()->Reboot (); }
HRESULT CScriptSite::NotifyScript (BSTR bstrEvent, VARIANT vData)
            { return ScriptHost()->NotifyScript (bstrEvent, vData); }
HRESULT CScriptSite::RegisterEventSource (IDispatch *pDisp, BSTR bstrProgID)
            { return ScriptHost()->RegisterEventSource (pDisp, bstrProgID); }
HRESULT CScriptSite::UnregisterEventSource (IDispatch *pDisp)
            { return ScriptHost()->UnregisterEventSource (pDisp); }
HRESULT CScriptSite::get_HostMajorVer(long *plMajorVer)
            { return ScriptHost()->get_HostMajorVer (plMajorVer); }
HRESULT CScriptSite::get_HostMinorVer(long *plMinorVer)
            { return ScriptHost()->get_HostMinorVer (plMinorVer); }
HRESULT CScriptSite::get_StatusValue(long nIndex, long *pnStatus)
            { return ScriptHost()->get_StatusValue(nIndex, pnStatus); }
HRESULT CScriptSite::put_StatusValue(long nIndex, long nStatus)
            { return ScriptHost()->put_StatusValue(nIndex, nStatus); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\scrhost\evtsink.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       evtsink.cxx
//
//  Contents:   Implementation of the CScriptEventSink class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

CScriptEventSink::CScriptEventSink(CScriptHost *pSH)
{
    _pSH = pSH;
    _ulRefs = 1;

    Assert(_dwSinkCookie == 0);
}

CScriptEventSink::~CScriptEventSink()
{
    Disconnect();
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptEventSink::Connect, public
//
//  Synopsis:   Connects to event interface on the source object
//
//  Arguments:  [pSource] -- Object to sink events from
//
//  Returns:    HRESULT
//
//              TODO: This method should be more generic and walk through
//              the object's typeinfo looking for the default source
//              interface.
//
//----------------------------------------------------------------------------

HRESULT
CScriptEventSink::Connect(IDispatch *pSource, BSTR bstrProgID)
{
    HRESULT      hr = S_OK;

    IConnectionPointContainer *pCPC;
    IConnectionPoint          *pCP = 0;

    _pDispSource = pSource;

    pSource->AddRef();

    hr = _pDispSource->QueryInterface(IID_IConnectionPointContainer,
                                      (LPVOID*)&pCPC);
    if (!hr)
    {
        if (bstrProgID && SysStringLen(bstrProgID) > 0)
            hr = CLSIDFromProgID(bstrProgID, &_clsidEvents);
        else
            _clsidEvents = DIID_DRemoteMTScriptEvents;

        if (hr == S_OK)
            hr = pCPC->FindConnectionPoint(_clsidEvents, &pCP);

        if (!hr)
        {
            hr = pCP->Advise(this, &_dwSinkCookie);

            ReleaseInterface(pCP);
        }

        ReleaseInterface(pCPC);

#if DBG == 1
        if (hr)
            TraceTag((tagError, "Hookup to event sink returned %x", hr));
#endif
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptEventSink::Disconnect, public
//
//  Synopsis:   Disconnects from a machine we connected to via Connect().
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

void
CScriptEventSink::Disconnect()
{
    HRESULT hr = S_OK;

    if (_dwSinkCookie && _pDispSource)
    {
        IConnectionPointContainer *pCPC;
        IConnectionPoint          *pCP;

        hr = _pDispSource->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pCPC);
        if (!hr)
        {
            hr = pCPC->FindConnectionPoint(DIID_DRemoteMTScriptEvents,
                                           &pCP);
            if (!hr)
            {
                pCP->Unadvise(_dwSinkCookie);

                ReleaseInterface(pCP);
            }

            ReleaseInterface(pCPC);

#if DBG == 1
            if (hr)
                TraceTag((tagError, "Unadvise from event sink returned %x", hr));
#endif
        }

        _dwSinkCookie = 0;
    }

    ClearInterface(&_pDispSource);

    _pSH = NULL;
}

// *************************************************************************
//
// CScriptEventSink
//
// Class which implements the event sink for the remote object. We only pay
// attention to Invoke calls.
//
// *************************************************************************

HRESULT
CScriptEventSink::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || 
        iid == IID_IDispatch || 
        iid == _clsidEvents)
    {
        *ppv = (IDispatch *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptEventSink::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptEventSink::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptEventSink::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptEventSink::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 0;

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptEventSink::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptEventSink::GetIDsOfNames(REFIID riid,
                            LPOLESTR * rgszNames,
                            UINT cNames,
                            LCID lcid,
                            DISPID * rgdispid)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptEventSink::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptEventSink::Invoke(DISPID dispidMember,
                         REFIID riid,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS * pdispparams,
                         VARIANT * pvarResult,
                         EXCEPINFO * pexcepinfo,
                         UINT * puArgErr)
{
    if (_pSH && _pSH->GetSite() && _pSH->GetSite()->_pDispSink)
    {
        DISPPARAMS dp;
        VARIANTARG varg[20];

        // We need to tack on 2 parameters to the call. First is the object
        // that is firing the event. Second is the dispatch ID.
        // We put them on the end of the list, which means they become
        // the first and second parameters to the event.

        if (pdispparams->cArgs > ARRAY_SIZE(varg) - 2)
        {
            AssertSz(FALSE, "NONFATAL: Too many parameters to event (max==18)!");
            return E_FAIL;
        }

        dp.cArgs = pdispparams->cArgs + 2;
        dp.cNamedArgs = pdispparams->cNamedArgs;
        dp.rgdispidNamedArgs = pdispparams->rgdispidNamedArgs;

        memcpy(varg, pdispparams->rgvarg, pdispparams->cArgs * sizeof(VARIANTARG));

        V_VT(&varg[dp.cArgs-1]) = VT_DISPATCH;
        V_DISPATCH(&varg[dp.cArgs-1]) = _pDispSource;

        V_VT(&varg[dp.cArgs-2]) = VT_I4;
        V_I4(&varg[dp.cArgs-2]) = dispidMember;

        dp.rgvarg = varg;

        return _pSH->GetSite()->_pDispSink->Invoke(
                                  DISPID_MTScript_OnEventSourceEvent,
                                  IID_NULL,
                                  lcid,
                                  DISPATCH_METHOD,
                                  &dp,
                                  pvarResult,
                                  pexcepinfo,
                                  puArgErr);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\scrhost\process.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       process.cxx
//
//  Contents:   Implementation of the CProcessThread class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "stdlib.h"

DeclareTag(tagProcess, "MTScript", "Monitor Process Creation");

char *g_pszExitCodeStr = "PROCESS_EXIT_CODE=";

#define PIPEREAD_TIMEOUT 2

CProcessParams::CProcessParams()
{
        pszCommand = 0;
        pszDir = 0;
        pszTitle = 0;
}

CProcessParams::~CProcessParams()
{
        Free();
}

bool CProcessParams::Copy(const PROCESS_PARAMS *params)
{
        return Assign(*params);
}

void CProcessParams::Free()
{
        SysFreeString(pszCommand);
        SysFreeString(pszDir);
        SysFreeString(pszTitle);

        pszCommand = 0;
        pszDir     = 0;
        pszTitle   = 0;
}

bool CProcessParams::Assign(const PROCESS_PARAMS &params)
{
        pszCommand    = SysAllocString(params.pszCommand);
        pszDir        = SysAllocString(params.pszDir);
        pszTitle      = SysAllocString(params.pszTitle);
        fMinimize     = params.fMinimize;
        fGetOutput    = params.fGetOutput;
        fNoEnviron    = params.fNoEnviron;
        fNoCrashPopup = params.fNoCrashPopup;

        if (params.pszCommand && !pszCommand ||
                        params.pszDir && !pszDir ||
                        params.pszTitle && !pszTitle)
        {
                return false;
        }
        return true;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::CProcessThread, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CProcessThread::CProcessThread(CScriptHost *pSH)
    : _cstrOutput(CSTR_NOINIT)
{
    _ulRefs = 1;

    _pSH = pSH;
    _pSH->AddRef();

    // This object should be initialized to all zero.

    Assert(_hPipe == NULL);
    Assert(_hJob == NULL);
    Assert(_hIoPort == NULL);
    Assert(_dwExitCode == 0);
    Assert(_piProc.hProcess == NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::~CProcessThread, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CProcessThread::~CProcessThread()
{
    AssertSz(!_hJob, "NONFATAL: Job handle should be NULL!");
    AssertSz(!_hIoPort, "NONFATAL: Port handle should be NULL!");

    TraceTag((tagProcess, "Closing process PID=%d", ProcId()));
    if (_hPipe)
        CloseHandle(_hPipe);

    if (_piProc.hProcess)
        CloseHandle(_piProc.hProcess);

    ReleaseInterface(_pSH);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::QueryInterface, public
//
//  Synopsis:   Standard implementation. This class implements no meaningful
//              interfaces.
//
//----------------------------------------------------------------------------

HRESULT
CProcessThread::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::Init, public
//
//  Synopsis:   Initializes the class
//
//----------------------------------------------------------------------------

BOOL
CProcessThread::Init()
{
    //$ FUTURE: For NT4 and Win9x support we will need to dynamically use the
    // job APIs since those platforms do not support them.

    _hJob = CreateJobObject(NULL, NULL);
    if (!_hJob)
    {
        TraceTag((tagError, "CreateJobObject failed with %d", GetLastError()));
        return FALSE;
    }

    return CThreadComm::Init();
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::GetProcessOutput, public
//
//  Synopsis:   Returns the collected STDOUT/STDERR data from the process
//              up to this point.
//
//  Arguments:  [pbstrOutput] -- Pointer to BSTR where the string should be
//                               copied. The BSTR will be allocated.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CProcessThread::GetProcessOutput(BSTR *pbstrOutput)
{
    LOCK_LOCALS(this);

    return _cstrOutput.AllocBSTR(pbstrOutput);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::GetExitCode, public
//
//  Synopsis:   Returns the exit code of the process. If the process is still
//              running, it returns STILL_ACTIVE (0x103, dec 259)
//
//----------------------------------------------------------------------------

DWORD
CProcessThread::GetExitCode()
{
    DWORD dwExit;

    AssertSz(_piProc.hProcess, "FATAL: Bad process handle");

    GetExitCodeProcess(_piProc.hProcess, &dwExit);

    if (dwExit == STILL_ACTIVE || !_fUseExitCode)
    {
        return STILL_ACTIVE;
    }

    return _dwExitCode;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::GetDeadTime, public
//
//  Synopsis:   Returns the number of ms since the process exited. If it
//              hasn't exited yet, it returns 0.
//
//----------------------------------------------------------------------------

ULONG
CProcessThread::GetDeadTime()
{
    _int64 i64CurrentTime;
    DWORD  dwExit;

    AssertSz(_piProc.hProcess, "FATAL: Bad process handle");

    GetExitCodeProcess(_piProc.hProcess, &dwExit);

    // If the process is still running return 0.
    if (dwExit == STILL_ACTIVE || !_i64ExitTime)
    {
        return 0;
    }

    GetSystemTimeAsFileTime((FILETIME*)&i64CurrentTime);

    // Calculate the difference in milli-seconds.  There are 10,000
    // FILETIME intervals in one second (each increment of 1 represents 100
    // nano-seconds)

    return (i64CurrentTime - _i64ExitTime) / 10000;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::Terminate, public
//
//  Synopsis:   Exits this thread. The process we own is terminated if it's
//              still running.
//
//----------------------------------------------------------------------------

void
CProcessThread::Terminate()
{
    DWORD            dwCode;
    CProcessThread * pThis = this;
    BOOL             fTerminated = FALSE;
    BOOL             fFireEvent = FALSE;

    VERIFY_THREAD();

    TraceTag((tagProcess, "Entering Terminate"));

    //
    // Flush out any data the process may have written to the pipe.
    //
    ReadPipeData();

    //
    // Make sure we've received all messages from our completion port
    //
    CheckIoPort();

    if (_piProc.hProcess)
    {
        //
        // Terminate the process(es) if still running.
        //

        fFireEvent = TRUE;

        GetExitCodeProcess(_piProc.hProcess, &dwCode);

        if (dwCode == STILL_ACTIVE)
        {
            TraceTag((tagProcess, "Root process still active!"));

            if (_hJob)
            {
                TerminateJobObject(_hJob, ERROR_PROCESS_ABORTED);
            }
            else
            {
                TraceTag((tagProcess, "Terminating process, not job!"));

                TerminateProcess(_piProc.hProcess, ERROR_PROCESS_ABORTED);
            }

            dwCode = ERROR_PROCESS_ABORTED;

            //
            // Flush out any data the process may have written to the pipe.
            //
            ReadPipeData();

            //
            // Make sure we've received all messages from our completion port
            //
            CheckIoPort();

            fTerminated = TRUE;
        }

        if (!_fUseExitCode)
        {
            _dwExitCode = dwCode;
            _fUseExitCode = TRUE;
        }
    }

    if (_hIoPort)
        CloseHandle(_hIoPort);

    if (_hJob)
        CloseHandle(_hJob);

    _hIoPort = NULL;
    _hJob    = NULL;

    // We need to hold onto _piProc.hProcess so the system doesn't reuse the
    // process ID.

    if (fFireEvent)
    {
        if (fTerminated)
        {
            PostToThread(_pSH, MD_PROCESSTERMINATED, &pThis, sizeof(CProcessThread*));
        }
        else
        {
            PostToThread(_pSH, MD_PROCESSEXITED, &pThis, sizeof(CProcessThread*));
        }
    }

    GetSystemTimeAsFileTime((FILETIME*)&_i64ExitTime);

    TraceTag((tagProcess, "Exiting process thread!"));

    Release();

    ExitThread(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::RealThreadRoutine, public
//
//  Synopsis:   Main loop which runs this thread while it is active. The thread
//              will terminate if this method returns. Termination normally
//              happens when the client disconnects by calling Terminate().
//
//----------------------------------------------------------------------------

DWORD
CProcessThread::ThreadMain()
{
    DWORD   dwRet;
    HANDLE  ahEvents[3];
    int     cEvents = 2;
    HRESULT hr;

    PROCESS_PARAMS *pParams = (PROCESS_PARAMS *)_pvParams;

    _ProcParams.Copy(pParams);

#if DBG == 1
    {
        char achBuf[10];
        CStr cstrCmd;

        cstrCmd.Set(pParams->pszCommand);
        cstrCmd.GetMultiByte(achBuf, 10);
        SetName(achBuf);
    }
#endif

    AddRef();

    hr = LaunchProcess(pParams);

    ThreadStarted(hr);   // Release our calling thread

    if (hr)
    {
        Terminate();
        return 1;       // Just in case
    }

    ahEvents[0] = _hCommEvent;
    ahEvents[1] = _piProc.hProcess;

    while (TRUE)
    {
        //
        // Anonymous pipes don't support asynchronous I/O, and we can't wait
        // on a handle to see if there's data on the completion port.  So,
        // what we do is poll for those every 2 seconds instead.
        //
        dwRet = WaitForMultipleObjects(cEvents,
                                       ahEvents,
                                       FALSE,
                                       (_hPipe || _hIoPort)
                                          ? PIPEREAD_TIMEOUT * 1000
                                          : INFINITE);
        if (dwRet == WAIT_OBJECT_0)
        {
            //
            // Another thread is sending us a message.
            //
            HandleThreadMessage();
        }
        else if (dwRet == WAIT_OBJECT_0 + 1)
        {
            //
            // The process terminated.
            //
            HandleProcessExit();
        }
        else if (dwRet == WAIT_TIMEOUT)
        {
            ReadPipeData();

            CheckIoPort();
        }
        else if (dwRet == WAIT_FAILED)
        {
            AssertSz(FALSE, "NONFATAL: WaitForMultipleObjectsFailure");

            break;
        }
    }

    // Make sure we clean everything up OK
    Terminate();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::HandleThreadMessage, public
//
//  Synopsis:   Handles any messages other threads send us.
//
//----------------------------------------------------------------------------

void
CProcessThread::HandleThreadMessage()
{
    THREADMSG tm;
    BYTE      bData[MSGDATABUFSIZE];
    DWORD     cbData;

    while (GetNextMsg(&tm, (void **)bData, &cbData))
    {
        switch (tm)
        {
        case MD_PLEASEEXIT:
            //
            // We're being asked to terminate.
            //
            Terminate();
            break;

        default:
            AssertSz(FALSE, "FATAL: CProcessThread got a message it couldn't handle!");
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::HandleProcessExit, public
//
//  Synopsis:   The process we started has exited. Send out the status and
//              exit.
//
//----------------------------------------------------------------------------

void
CProcessThread::HandleProcessExit()
{
    //
    // Flush out any data the process may have written to the pipe.
    //
    ReadPipeData();

    // Save the exit code
    if (!_fUseExitCode)
    {
        GetExitCodeProcess(_piProc.hProcess, &_dwExitCode);

        _fUseExitCode = TRUE;

        AssertSz(_dwExitCode != STILL_ACTIVE, "LEAK: Exited process still active!");
    }

    Terminate();
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::IsDataInPipe, public
//
//  Synopsis:   Is there any data waiting to be read from the anonymous pipe?
//
//----------------------------------------------------------------------------

BOOL
CProcessThread::IsDataInPipe()
{
    DWORD dwBytesAvail = 0;
    BOOL  fSuccess;

    if (!_hPipe)
        return FALSE;

    fSuccess = PeekNamedPipe(_hPipe,
                             NULL,
                             NULL,
                             NULL,
                             &dwBytesAvail,
                             NULL);

    if (!fSuccess)
    {
        //
        // Stop trying to read from the pipe
        //
        CloseHandle(_hPipe);
        _hPipe = NULL;
    }

    return (dwBytesAvail != 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::ReadPipeData, public
//
//  Synopsis:   Read any and all data which is waiting on the pipe. This will
//              be anything that the process writes to STDOUT.
//
//----------------------------------------------------------------------------

void
CProcessThread::ReadPipeData()
{
    BOOL         fSuccess = TRUE;
    DWORD        cbRead;
    char        *pch;

    while (IsDataInPipe())
    {
        CStr cstrTemp;

        fSuccess = ReadFile(_hPipe,
                            _abBuffer,
                            PIPE_BUFFER_SIZE - 1,
                            &cbRead,
                            NULL);

        if (!fSuccess || cbRead == 0)
        {
            Terminate();

            return; // just in case
        }

        _abBuffer[cbRead] = '\0';

        //
        // Is the process letting us know that we should pretend the exit code
        // is some value other than the actual exit code?
        // (using PROCESS_EXIT_CODE=x in its STDOUT stream)
        //
        pch = strstr((const char*)_abBuffer, g_pszExitCodeStr);
        if (pch)
        {
            _dwExitCode = atol(pch + strlen(g_pszExitCodeStr));
            _fUseExitCode = TRUE;
        }

        // The string is now in _abBuffer. Add it to our buffer.
        //
        // Assume the data coming across is MultiByte string data.
        //
        LOCK_LOCALS(this);

        _cstrOutput.AppendMultiByte((const char *)_abBuffer);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::CheckIoPort, public
//
//  Synopsis:   Check the CompletionPort that we are using to receive messages
//              from the job object. This will tell us if any process we
//              created or that is a child of the one we created crashed.
//
//----------------------------------------------------------------------------

void
CProcessThread::CheckIoPort()
{
    DWORD dwCode  = 0;
    DWORD dwKey   = 0;
    DWORD dwParam = 0;;

    if (!_hIoPort)
    {
        return;
    }

    while (GetQueuedCompletionStatus(_hIoPort,
                                     &dwCode,
                                     &dwKey,
                                     (LPOVERLAPPED*)&dwParam,
                                     0))
    {
        AssertSz(dwKey == (DWORD)this, "NONFATAL: Bogus port value from GetQueuedCompletionStatus");

        switch (dwCode)
        {
        case JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS:

            {
                CProcessThread *pThis = this;

                // There is no reliable way to get the actual exit code, since
                // the process is already gone and we don't have a handle to it.

                TraceTag((tagProcess, "Process %d crashed!", dwParam));

                PostToThread(_pSH, MD_PROCESSCRASHED, &pThis, sizeof(CProcessThread*));
            }

            break;

        case JOB_OBJECT_MSG_EXIT_PROCESS:
            TraceTag((tagProcess, "Process %d exited.", dwParam));
            break;

        case JOB_OBJECT_MSG_NEW_PROCESS:

            TraceTag((tagProcess, "Process %d started.", dwParam));
            // Remember the process id so we can use it later
            _aryProcIds.Append(dwParam);
            break;

        default:
            break;
        }
    }

    DWORD dwError = GetLastError();

    if (dwError != WAIT_TIMEOUT)
    {
        TraceTag((tagProcess, "GetQueuedCompletionStatus returned %d", dwError));
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::LaunchProcess, public
//
//  Synopsis:   Start the child process for the given command.
//
//----------------------------------------------------------------------------

HRESULT
CProcessThread::LaunchProcess(const PROCESS_PARAMS *pProcParams)
{
    BOOL        fSuccess;
    TCHAR       achCommand[MAX_PATH * 2];
    TCHAR       achDir[MAX_PATH];
    BOOL        fUseDir;
    HRESULT     hr = S_OK;
    CStr        cstrEnvironment;

    STARTUPINFO si         = { 0 };
    HANDLE      hPipeStdout = NULL;
    HANDLE      hPipeStderr = NULL;

    if (pProcParams->fGetOutput)
    {
        //
        // Setup the anonymous pipe which we will use to get status from the
        // process.  Anytime it writes to STDOUT or STDERR it will come across
        // this pipe to us.
        //
        SECURITY_ATTRIBUTES sa;

        sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle       = TRUE;

        fSuccess = CreatePipe(&_hPipe, &hPipeStdout, &sa, 0);
        if (!fSuccess)
        {
            AssertSz(FALSE, "FATAL: Could not create anonymous pipe");

            goto Win32Error;
        }

        //
        // Change our end of the pipe to non-inheritable so the new process
        // doesn't pick it up.
        //
        fSuccess = DuplicateHandle(GetCurrentProcess(),
                                   _hPipe,
                                   GetCurrentProcess(),
                                   NULL,
                                   0,
                                   FALSE,
                                   DUPLICATE_SAME_ACCESS);
        if (!fSuccess)
        {
            AssertSz(FALSE, "FATAL: Error removing inheritance from handle!");

            goto Win32Error;
        }

        //
        // Now duplicate the stdout handle for stderr
        //
        fSuccess = DuplicateHandle(GetCurrentProcess(),
                                   hPipeStdout,
                                   GetCurrentProcess(),
                                   &hPipeStderr,
                                   0,
                                   TRUE,
                                   DUPLICATE_SAME_ACCESS);
        if (!fSuccess)
        {
            AssertSz(FALSE, "Error duplicating stdout handle!");

            goto Win32Error;
        }
    }
    else
    {
        hPipeStdout = GetStdHandle(STD_OUTPUT_HANDLE);
        hPipeStderr = GetStdHandle(STD_ERROR_HANDLE);
    }

    if (_hJob)
    {
        JOBOBJECT_EXTENDED_LIMIT_INFORMATION joLimit = { 0 };
        JOBOBJECT_ASSOCIATE_COMPLETION_PORT  joPort = { 0 };

        if (pProcParams->fNoCrashPopup)
        {
            // Force crashes to terminate the job (and all processes in it).

            joLimit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;

            fSuccess = SetInformationJobObject(_hJob,
                                       JobObjectExtendedLimitInformation,
                                       &joLimit,
                                       sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION));
            if (!fSuccess)  // Ignore failures except to report them.
            {
                TraceTag((tagError,
                          "SetInformationJobObject failed with %d",
                          GetLastError()));
            }
        }

        // Now we need to setup a completion port so we can find out if one
        // of the processes crashed.

        _hIoPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, (DWORD)this, 0);

        if (_hIoPort)
        {
            joPort.CompletionKey  = this;
            joPort.CompletionPort = _hIoPort;

            fSuccess = SetInformationJobObject(_hJob,
                                       JobObjectAssociateCompletionPortInformation,
                                       &joPort,
                                       sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT));

            if (!fSuccess)  // Ignore failures except to report them.
            {
                TraceTag((tagError,
                          "Failed to set completion port on job: %d",
                          GetLastError()));
            }
        }
        else
        {
            TraceTag((tagError,
                      "CreateIoCompletionPort failed with %d!",
                      GetLastError()));
        }
    }

    si.cb = sizeof(STARTUPINFO);

    if (pProcParams->fMinimize)
    {
        si.wShowWindow =  SW_SHOWMINNOACTIVE;
    }
    else
    {
        si.wShowWindow =  SW_SHOWNORMAL;
    }

    if (pProcParams->pszTitle != NULL && _tcslen(pProcParams->pszTitle) > 0)
    {
        si.lpTitle = pProcParams->pszTitle;
    }

    //
    // Setup our inherited standard handles.
    //
    si.hStdInput   = GetStdHandle(STD_INPUT_HANDLE);
    si.hStdOutput  = hPipeStdout;
    si.hStdError   = hPipeStderr;

    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;

    if (!pProcParams->fGetOutput)
    {
        si.dwFlags &= ~STARTF_USESTDHANDLES;
    }

    //
    // Expand environment strings in the command name as well as the working
    // dir.
    //

    ExpandEnvironmentStrings(pProcParams->pszCommand,
                             achCommand,
                             MAX_PATH * 2);

    fUseDir = pProcParams->pszDir && _tcslen(pProcParams->pszDir) > 0;

    if (fUseDir)
    {
        WCHAR *psz;
        WCHAR achDir2[MAX_PATH];

        ExpandEnvironmentStrings(pProcParams->pszDir, achDir2, MAX_PATH);
        GetFullPathName(achDir2, MAX_PATH, achDir, &psz);
    }

    GetProcessEnvironment(&cstrEnvironment, pProcParams->fNoEnviron);

    TraceTag((tagProcess, "Launching Process: %ls in %ls", achCommand, achDir));

    //
    // Let's do it!
    //
    fSuccess = CreateProcess(NULL,
                             achCommand,
                             NULL,
                             NULL,
                             TRUE,
                             BELOW_NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT,
                             cstrEnvironment,
                             (fUseDir) ? achDir : NULL,
                             &si,
                             &_piProc);
    if (!fSuccess)
        goto Win32Error;

    if (_hJob)
    {
        if (!AssignProcessToJobObject(_hJob, _piProc.hProcess))
        {
            TraceTag((tagError, "AssignProcessToJobObject failed with %d", GetLastError()));
            CloseHandle(_hJob);
            _hJob = NULL;
        }
    }

    TraceTag((tagProcess, "Created process PID=%d %ls", _piProc.dwProcessId, achCommand));
    CloseHandle(_piProc.hThread);

Cleanup:
    if (pProcParams->fGetOutput)
    {
        //
        // The write handles have been inherited by the child process, so we
        // let go of them.
        //
        CloseHandle(hPipeStdout);
        CloseHandle(hPipeStderr);
    }

    return hr;

Win32Error:

    hr = HRESULT_FROM_WIN32(GetLastError());

    TraceTag((tagProcess, "Error creating process: %x", hr));

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::GetProcessEnvironment, public
//
//  Synopsis:   Builds an environment block for the new process that has
//              our custom id so we can identify them.
//
//  Arguments:  [pcstr]      -- Place to put environment block
//              [fNoEnviron] -- If TRUE, don't inherit the environment block
//
//----------------------------------------------------------------------------

void
CProcessThread::GetProcessEnvironment(CStr *pcstr, BOOL fNoEnviron)
{
    TCHAR *pszEnviron;
    TCHAR  achNewVar[50];
    int    cch = 1;
    TCHAR *pch;

    static long s_lProcID = 0;

    _lEnvID = InterlockedIncrement(&s_lProcID);

    wsprintf(achNewVar, _T("__MTSCRIPT_ENV_ID=%d\0"), _lEnvID);

    if (!fNoEnviron)
    {
        pszEnviron = GetEnvironmentStrings();

        pch = pszEnviron;
        cch = 2;          // Always have two terminating nulls at least

        while (*pch || *(pch+1))
        {
            pch++;
            cch++;
        }

        pcstr->Set(NULL, cch + _tcslen(achNewVar));

        memcpy((LPTSTR)*pcstr, pszEnviron, cch * sizeof(TCHAR));

        FreeEnvironmentStrings(pszEnviron);
    }
    else
    {
        pcstr->Set(NULL, _tcslen(achNewVar) + 1);
    }

    memcpy((LPTSTR)*pcstr + cch - 1,
           achNewVar,
           (_tcslen(achNewVar)+1) * sizeof(TCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\scrhost\smtp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       smtp.cxx
//
//  Contents:   Contains the command to send SMTP mail
//
//              Stolen from KrisK's mail.exe tool.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include <iostream.h>
#include <winsock2.h>

HRESULT
CScriptHost::SendSMTPMail(BSTR  bstrFrom,
                          BSTR  bstrTo,
                          BSTR  bstrCC,
                          BSTR  bstrSubject,
                          BSTR  bstrMessage,
                          BSTR  bstrSMTPHost,
                          long *plError)
{
    char                  achRecvBuf[2048];
    unsigned short        port = 25;
    struct sockaddr_in    Ser;
    struct hostent *      hp;
    WSADATA               wsaData;
    SOCKET                conn_socket = INVALID_SOCKET;
    int                   iRet;
    int                   iLen;
    char                  achSendBuf[1024];
    char *                pch;
    char *                aszToList[30];
    int                   cToList = 0;
    char *                aszCCList[30];
    int                   cCCList = 0;
    SYSTEMTIME            stUT;
    int                   i;

    ANSIString szFrom(bstrFrom);
    ANSIString szTo(bstrTo);
    ANSIString szCC(bstrCC);
    ANSIString szSubject(bstrSubject);
    ANSIString szMessage(bstrMessage);
    ANSIString szSMTPHost(bstrSMTPHost);

    // ************** Parse the ToList into individual recipients
    pch = szTo;

    while (*pch && cToList < 30)
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pch))
        {
            *pch=0;
            pch++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            aszToList[cToList++] = pch;

            // Move beginning of string to next name in ToList.
            do
            {
                pch++;
            } while (isgraph(*pch));
        }
    }

    // Parse the CCList into individual recipients
    pch = szCC;

    // Parse CCList into rgRecipDescStruct.
    while (*pch && cCCList < 30)
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pch))
        {
            *pch=0;
            pch++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            aszCCList[cCCList++] = pch;

            // Move beginning of string to next name in CCList.
            do
            {
                pch++;
            } while (isgraph(*pch));
        }
    }

    // ************** Initialize Windows Sockets

    // BUGBUG -- Make error return code meaningful

    iRet = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iRet != 0)
    {
        *plError = iRet;
        return S_OK;
    }

    hp = gethostbyname(szSMTPHost);
    if (hp == NULL)
        goto WSAError;

    memset(&Ser,0,sizeof(Ser));
    memcpy(&(Ser.sin_addr),hp->h_addr,hp->h_length);

    Ser.sin_family = hp->h_addrtype;
    Ser.sin_port = htons(port);

    // Open a socket
    conn_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (conn_socket == INVALID_SOCKET)
        goto WSAError;

    // ************** Connect to the SMTP host

    iRet = connect(conn_socket, (struct sockaddr*)&Ser, sizeof(Ser));
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // Get the server's initial response
    iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // We expect code 220: "Service Ready"
    if (strncmp(achRecvBuf, "220", 3) != 0)
        goto ACKError;

    // ************** Send the mail command

    iLen = wsprintfA(achSendBuf, "MAIL FROM: <%s>\r\n", szFrom);
    iRet = send(conn_socket, achSendBuf, iLen, 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // We expect code 250: "Requested mail action OK, completed"
    if (strncmp(achRecvBuf, "250", 3) != 0)
        goto ACKError;

    // ************** Send the recipient list (combination of TO and CC)

    for (i = 0; i < cToList; i++)
    {
        iLen = wsprintfA(achSendBuf, "RCPT TO: <%s>\r\n", aszToList[i]);

        iRet = send(conn_socket, achSendBuf, iLen, 0);
        if (iRet == SOCKET_ERROR)
            goto WSAError;

        iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
        if (iRet == SOCKET_ERROR)
            goto WSAError;

        // We expect code 250: "Requested mail action OK, completed"
        if (strncmp(achRecvBuf, "250", 3) != 0)
            goto ACKError;
    }

    for (i = 0; i < cCCList; i++)
    {
        iLen = wsprintfA(achSendBuf, "RCPT TO: <%s>\r\n", aszCCList[i]);

        iRet = send(conn_socket, achSendBuf, iLen, 0);
        if (iRet == SOCKET_ERROR)
            goto WSAError;

        iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
        if (iRet == SOCKET_ERROR)
            goto WSAError;

        // We expect code 250: "Requested mail action OK, completed"
        if (strncmp(achRecvBuf, "250", 3) != 0)
            goto ACKError;
    }

    // ************** Send the mail headers

    iLen = wsprintfA(achSendBuf, "DATA\r\n");
    iRet = send(conn_socket, achSendBuf, iLen, 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // We expect code 354: "Start mail input; End with ."
    if (strncmp(achRecvBuf, "354", 3) != 0)
        goto ACKError;

    GetSystemTime(&stUT);

    GetDateFormatA(LOCALE_NEUTRAL,
                   0,
                   &stUT,
                   "dd MMM yy",
                   achRecvBuf,
                   sizeof(achRecvBuf));

    wsprintfA(achSendBuf,
             "Date: %s %02d:%02d UT\r\n",
             achRecvBuf,
             stUT.wHour,
             stUT.wMinute);

    iRet = send(conn_socket, achSendBuf, strlen(achSendBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    wsprintfA(achSendBuf, "From: <%s>\r\n", szFrom);

    wsprintfA(&achSendBuf[strlen(achSendBuf)], "Subject: %s\r\n", szSubject);

    wsprintfA(&achSendBuf[strlen(achSendBuf)], "To: ");

    for (i = 0; i < cToList; i++)
    {
        wsprintfA(&achSendBuf[strlen(achSendBuf)],
                 "<%s>%s",
                 aszToList[i],
                 (i == cToList-1) ? "\r\n" : ",\r\n ");
    }

    if (cCCList > 0)
    {
        wsprintfA(&achSendBuf[strlen(achSendBuf)], "cc: ", szFrom);

        for (i = 0; i < cCCList; i++)
        {
            wsprintfA(&achSendBuf[strlen(achSendBuf)],
                     "<%s>%s",
                     aszCCList[i],
                     (i == cCCList-1) ? "\r\n" : ",\r\n ");
        }
    }

    wsprintfA(&achSendBuf[strlen(achSendBuf)], "Reply-To: <%s>\r\n\r\n", szFrom);

/*
    BUGBUG -- Perhaps support HTML formatted mail in the future?
    if ( html )
            str += "MIME-Version: 1.0\r\nContent-Type: text/html;\r\n       charset=\"iso-8859-1\"\r\nSUBJECT: "+ title + "\r\n\r\n"+ message +"\r\n.\r\n";
*/


    iRet = send(conn_socket, achSendBuf, strlen(achSendBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // ************** Send the message body

    iRet = send(conn_socket, szMessage, strlen(szMessage), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // ************** Close the connection

    strcpy(achSendBuf, "\r\n.\r\n");

    iRet = send(conn_socket, achSendBuf, strlen(achSendBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // We expect code 250: "Requested mail action OK, completed"
    if (strncmp(achRecvBuf, "250", 3) != 0)
        goto ACKError;


    strcpy(achSendBuf, "QUIT\r\n");

    send(conn_socket, achSendBuf, strlen(achSendBuf), 0);

Cleanup:
    if (conn_socket != INVALID_SOCKET)
    {
        closesocket(conn_socket);
    }

    WSACleanup();

    return S_OK;

ACKError:
    // BUGBUG -- Preserve entire string that was returned
    achRecvBuf[3] = '\0';
    *plError = atoi(achRecvBuf);
    goto Cleanup;

WSAError:
    *plError = WSAGetLastError();

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\scripts\makefile.inc ===
types.js: types.xml xmltypes.js
    cscript xmltypes.js //nologo > types.js
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\util\regdcom.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       regdcom.cxx
//
//  Contents:   Utility functions used to manipulated the DCOM registry
//              settings.
//
//              This code was stolen from the DCOMPERM sample code written
//              by Michael Nelson.
//
//              The only function that should be called outside this file is
//              ChangeAppIDACL. All others are utility functions used by it.
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#include "ntsecapi.h"

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle,
                             TokenUser,
                             tokenUser,
                             0,
                             &tokenSize);

        tokenUser = (TOKEN_USER *) MemAlloc (tokenSize);

        if (GetTokenInformation (tokenHandle,
                                 TokenUser,
                                 tokenUser,
                                 tokenSize,
                                 &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) MemAlloc (sidLength);

            memcpy (*Sid, tokenUser->User.Sid, sidLength);
            CloseHandle (tokenHandle);
        } else
        {
            MemFree (tokenUser);
            return GetLastError();
        }
    } else
    {
        MemFree (tokenUser);
        return GetLastError();
    }

    MemFree (tokenUser);
    return ERROR_SUCCESS;
}

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid
    )
{
    DWORD        sidSize;
    TCHAR        refDomain [256];
    DWORD        refDomainSize;
    DWORD        returnValue;
    SID_NAME_USE snu;

    sidSize = 0;
    refDomainSize = 255;

    LookupAccountName (NULL,
                       Principal,
                       *Sid,
                       &sidSize,
                       refDomain,
                       &refDomainSize,
                       &snu);

    returnValue = GetLastError();
    if (returnValue != ERROR_INSUFFICIENT_BUFFER)
        return returnValue;

    *Sid = (PSID) MemAlloc (sidSize);
    refDomainSize = 255;

    if (!LookupAccountName (NULL,
                            Principal,
                            *Sid,
                            &sidSize,
                            refDomain,
                            &refDomainSize,
                            &snu))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl;
    DWORD   sidLength;
    PSID    sid;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) MemAlloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    MemFree(sid);

    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl;
    PACL                  sacl;
    PSID                  ownerSID;
    PSID                  groupSID;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, TEXT(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS)
                return returnValue;

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS)
            return returnValue;

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) MemAlloc (valueSize);

        returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, (LPBYTE) *SD, &valueSize);
        if (returnValue)
        {
            MemFree (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS)
                return returnValue;

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    BOOL *pfNewAcl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue;
    PSID                  principalSID;
    PACL                  oldACL, newACL;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        MemFree (principalSID);
        return GetLastError();
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        MemFree (principalSID);
        return GetLastError();
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        MemFree (principalSID);
        return returnValue;
    }

    *Acl = newACL;

    if (*pfNewAcl)
        delete [] oldACL;

    *pfNewAcl = TRUE;

    MemFree (principalSID);
    return ERROR_SUCCESS;
}

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    BOOL *pfNewAcl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
        goto Cleanup;

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
        goto Cleanup;

    *Acl = newACL;

    if (*pfNewAcl)
        delete [] oldACL;

    *pfNewAcl = TRUE;

Cleanup:

    MemFree (principalSID);
    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID;
    DWORD                   returnValue;
    ACE_HEADER              *aceHeader;

    returnValue = GetPrincipalSID (Principal, &principalSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            MemFree (principalSID);
            return GetLastError();
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                MemFree (principalSID);
                return ERROR_SUCCESS;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                MemFree (principalSID);
                return ERROR_SUCCESS;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                MemFree (principalSID);
                return ERROR_SUCCESS;
            }
        }
    }

    MemFree (principalSID);
    return ERROR_SUCCESS;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue;
    SECURITY_DESCRIPTOR *sd;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newACL = FALSE;
    BOOL                newSD = FALSE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL))
        return GetLastError();

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
    {
        returnValue = AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, Principal);
    }
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, &newACL, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
    {
        MemFree (sd);
        return returnValue;
    }

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD)
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
    else
        sdAbsolute = sd;

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE))
        return GetLastError();

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) MemAlloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize))
        return GetLastError();

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

    MemFree (sd);
    MemFree (sdSelfRelative);

    if (newACL)
        delete [] dacl;

    if (!newSD)
        MemFree (sdAbsolute);

    return ERROR_SUCCESS;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue;
    SECURITY_DESCRIPTOR *sd;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newACL = FALSE;
    BOOL                newSD = FALSE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL))
        return GetLastError();

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
    {
        MemFree (sd);
        return returnValue;
    }

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD)
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
    else
        sdAbsolute = sd;

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE))
        return GetLastError();

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) MemAlloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize))
        return GetLastError();

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

    MemFree (sd);
    MemFree (sdSelfRelative);

    if (newACL)
        delete [] dacl;

    if (!newSD)
        MemFree (sdAbsolute);

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChangeAppIDACL
//
//  Synopsis:   Given an AppID and a username ("EVERYONE",
//              "REDMOND\johndoe") add or remove them from the DCOM Access
//              or launch permissions for that app.
//
//  Arguments:  [AppID]        -- GUID of application to set permissions for.
//              [Principal]    -- Name of user
//              [fAccess]      -- If TRUE, set the access permissions. If
//                                   FALSE, set the launch permissions.
//              [SetPrincipal] -- If TRUE, add the user, otherwise remove
//              [Permit]       -- If TRUE, give them access, otherwise deny
//                                 them access (ignored if [SetPrincipal] is
//                                 false.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
ChangeAppIDACL (
    REFGUID AppID,
    LPTSTR  Principal,
    BOOL    fAccess,
    BOOL    SetPrincipal,
    BOOL    Permit)
{
    TCHAR   keyName [256];
    DWORD   dwRet;
    LPTSTR  pstrValue;
    OLECHAR strClsid[40];

    StringFromGUID2(AppID, strClsid, 40);

    wsprintf (keyName, TEXT("APPID\\%s"), strClsid);

    if (fAccess)
        pstrValue = TEXT("AccessPermission");
    else
        pstrValue = TEXT("LaunchPermission");

    if (SetPrincipal)
    {
        RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, pstrValue, Principal);
        dwRet = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, pstrValue, Principal, Permit);
    }
    else
    {
        dwRet = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, pstrValue, Principal);
    }

    return HRESULT_FROM_WIN32(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\util\dbgstk.cxx ===
/***
*dbgstk.c - debug check stack routine
*
*       Copyright (c) 1986-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This module contains a debug impelmentation of the standard _chkstk
*   for i386.  It will do the standard stack probe (code copied from
*   VC5 CRT) and then call a debug routine which will have the oportunity
*   top spew the stack before it gets initialized (or not).
*
*******************************************************************************/
#include "headers.hxx"

#if defined(USE_STACK_SPEW) && defined(_X86_)

#pragma check_stack(off)

static BOOL    g_fStackSpewEnabled = FALSE;
static DWORD   g_dwSpew = 0x0;

extern "C" void __declspec(naked) __cdecl _chkstk()
{
    _asm
    {
        ;  First probe the stack.  We do this because
        ;  we don't want to write past the stack guard page
        ;  Note that this code came from the original
        ;  c run time source.

        push    ecx                     ; save ecx
        push    eax                     ; save eax (size of stack needed)
        cmp     eax,1000h               ; more than one page requested?
        lea     ecx,[esp] + 12          ;   compute new stack pointer in ecx
                                        ;   correct for return address and
                                        ;   saved ecx, eax
        jb      short lastpage          ; no

probepages:
        sub     ecx,1000h               ; yes, move down a page
        sub     eax,1000h               ; adjust request and...

        test    dword ptr [ecx],eax     ; ...probe it

        cmp     eax,1000h               ; more than one page requested?
        jae     short probepages        ; no

lastpage:
        sub     ecx,eax                 ; move stack down by eax
        mov     eax,esp                 ; save current tos and do a...

        test    dword ptr [ecx],eax     ; ...probe in case a page was crossed

        ;  Now set up and write our data into the area of the stack
        ;  that was opened up

        lea     esp,[ecx] - 12          ; set the stack pointer to the bottom
                                        ; leave room 12 in padding so we don't
                                        ; clobber ourselves

        mov     ecx,dword ptr [eax+8]   ; recover return address
        push    ecx

        cmp     g_fStackSpewEnabled,0   ; see if we are enabled

        mov     ecx,dword ptr [eax+4]   ; recover original ecx

        je      done                    ; not enabled

        push    ecx                     ; save original ecx

        pushfd                          ; save flags
        std                             ; set DI: decr edi after stosd

        mov     ecx,dword ptr [eax]     ; recover original eax (stack size)

        push    edi                     ; save edi on stack also
        lea     edi,[eax]+8             ; load up iterator start address

        shr     ecx,2                   ; get count of dwords

        mov     eax,g_dwSpew            ; load up value

        rep stosd                       ; let 'er rip

        pop     edi                     ; pop saved edi
        popfd                           ; pop flags
        pop     ecx                     ; pop saved ecx

done:
        ret     12                      ; return, popping off 12 padding
    }
}

// NOTE: _alloca_probe is impelemented exactly the same as _chkstk
// I'd like to find some way to merge these two pieces of code but I
// don't know how with inline assembly...
extern "C" void __declspec(naked) __cdecl _alloca_probe()
{
    _asm
    {
        ;  First probe the stack.  We do this because
        ;  we don't want to write past the stack guard page
        ;  Note that this code came from the original
        ;  c run time source.

        push    ecx                     ; save ecx
        push    eax                     ; save eax (size of stack needed)
        cmp     eax,1000h               ; more than one page requested?
        lea     ecx,[esp] + 12          ;   compute new stack pointer in ecx
                                        ;   correct for return address and
                                        ;   saved ecx, eax
        jb      short lastpage          ; no

probepages:
        sub     ecx,1000h               ; yes, move down a page
        sub     eax,1000h               ; adjust request and...

        test    dword ptr [ecx],eax     ; ...probe it

        cmp     eax,1000h               ; more than one page requested?
        jae     short probepages        ; no

lastpage:
        sub     ecx,eax                 ; move stack down by eax
        mov     eax,esp                 ; save current tos and do a...

        test    dword ptr [ecx],eax     ; ...probe in case a page was crossed

        ;  Now set up and write our data into the area of the stack
        ;  that was opened up

        lea     esp,[ecx] - 12          ; set the stack pointer to the bottom
                                        ; leave room 12 in padding so we don't
                                        ; clobber ourselves

        mov     ecx,dword ptr [eax+8]   ; recover return address
        push    ecx

        cmp     g_fStackSpewEnabled,0   ; see if we are enabled

        mov     ecx,dword ptr [eax+4]   ; recover original ecx

        je      done                    ; not enabled

        push    ecx                     ; save original ecx

        pushfd                          ; save flags
        std                             ; set DI: decr edi after stosd

        mov     ecx,dword ptr [eax]     ; recover original eax (stack size)

        push    edi                     ; save edi on stack also
        lea     edi,[eax]+8             ; load up iterator start address

        shr     ecx,2                   ; get count of dwords

        mov     eax,g_dwSpew            ; load up value

        rep stosd                       ; let 'er rip

        pop     edi                     ; pop saved edi
        popfd                           ; pop flags
        pop     ecx                     ; pop saved ecx

done:
        ret     12                      ; return, popping off 12 padding
    }
}

//
// Initialize the debug stack system
//

extern "C" void
InitChkStk(BOOL dwFill)
{
    g_dwSpew = dwFill;
    g_fStackSpewEnabled = TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\util\cstr.cxx ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         CSTR.CXX
//
// Contents     Class implementation for length prefix string class
//
// Classes      CStr
//
// Maintained by Istvanc
//
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//-----------------------------------------------------------------------------

#include "headers.hxx"

ANSIString::ANSIString(WCHAR *pchWide)
{
    _pch = NULL;

    Set(pchWide);
}

void
ANSIString::Set(WCHAR *pchWide)
{
    int cch = wcslen(pchWide) + 1;

    if (_pch)
        delete _pch;

    if (cch > 0)
    {
        _pch = new char[cch];

        MemSetName(_pch, "ANSIString");

        if (_pch)
        {
            WideCharToMultiByte(CP_ACP,
                                0,
                                pchWide,
                                -1,
                                _pch,
                                cch,
                                NULL,
                                NULL);
        }
    }
    else
        _pch = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates memory for a string and initializes it from a given
//              string.
//
//  Arguments:  [pch] -- String to initialize with. Can be NULL
//              [uc]  -- Number of characters to allocate.
//
//  Returns:    HRESULT
//
//  Notes:      The total number of characters allocated is uc+1, to allow
//              for a NULL terminator. If [pch] is NULL, then the string is
//              uninitialized except for the NULL terminator, which is at
//              character position [uc].
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(LPCTSTR pch, UINT uc)
{
    if (pch == _pch)
    {
        if (uc == Length())
            return S_OK;
        // when the ptrs are the same the length can only be
        // different if the ptrs are NULL.  this is a hack used
        // internally to implement realloc type expansion
        Assert(pch == NULL && _pch == NULL);
    }

    Free();

    BYTE * p = new BYTE [sizeof(TCHAR) + sizeof(TCHAR) * uc + sizeof(UINT)];
    if (p)
    {
        MemSetName(p, "CStr String");

        *(UINT *)(p)  = uc * sizeof(TCHAR);
        _pch = (TCHAR *)(p + sizeof(UINT));
        if (pch)
        {
            _tcsncpy(_pch, pch, uc);
        }

        ((TCHAR *)_pch) [uc] = 0;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates a string and initializes it
//
//  Arguments:  [pch] -- String to initialize from
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(LPCTSTR pch)
{
    RRETURN(Set(pch, pch ? _tcsclen(pch) : 0));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates a string and initializes it
//
//  Arguments:  [cstr] -- String to initialize from
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(const CStr &cstr)
{
    RRETURN(Set(cstr, cstr.Length()));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::TakeOwnership, public
//
//  Synopsis:   Takes the ownership of a string from another CStr class.
//
//  Arguments:  [cstr] -- Class to take string from
//
//  Notes:      This method just transfers a string from one CStr class to
//              another. The class which is the source of the transfer has
//              a NULL value at the end of the operation.
//
//----------------------------------------------------------------------------

void
CStr::TakeOwnership(CStr &cstr)
{
    _Free();
    _pch = cstr._pch;
    cstr._pch = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetBSTR, public
//
//  Synopsis:   Allocates a string and initializes it from a BSTR
//
//  Arguments:  [bstr] -- Initialization string
//
//  Notes:      This method is more efficient than Set(LPCWSTR pch) because
//              of the length-prefix on BSTRs.
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetBSTR(const BSTR bstr)
{
    RRETURN(Set(bstr, bstr ? SysStringLen(bstr) : 0));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetMultiByte, public
//
//  Synopsis:   Sets the string value from an MultiByte string
//
//  Arguments:  [pch] -- MultiByte string to convert to UNICODE
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetMultiByte(LPCSTR pch)
{
    HRESULT hr;
    DWORD   dwLen;

    dwLen = strlen(pch);

    hr = Set(NULL, dwLen);
    if (hr)
        RRETURN(hr);

    dwLen = MultiByteToWideChar(CP_ACP,
                                0,
                                pch,
                                dwLen,
                                _pch,
                                dwLen + 1);

    if (dwLen == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::GetMultiByte, public
//
//  Synopsis:   Gets the string value in MultiByte format
//
//  Arguments:  [pch] -- Place to put MultiByte string
//              [cch] -- Size of buffer pch points to
//
//----------------------------------------------------------------------------

HRESULT
CStr::GetMultiByte(LPSTR pch, UINT cch)
{
    HRESULT hr = S_OK;

    DWORD dwLen = WideCharToMultiByte(CP_ACP,
                                      0,
                                      _pch,
                                      -1,
                                      pch,
                                      cch,
                                      NULL,
                                      NULL);
    if (dwLen == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Length, public
//
//  Synopsis:   Returns the length of the string associated with this class
//
//----------------------------------------------------------------------------

UINT
CStr::Length() const
{
    if (_pch)
        return (((UINT *)_pch) [-1]) / sizeof(TCHAR);
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::ReAlloc, public
//
//  Synopsis:   Reallocate the string to a different size buffer.
//              The length of the string is not affected, but it is allocated
//              within a larger (or maybe smaller) memory allocation.
//
//----------------------------------------------------------------------------

HRESULT
CStr::ReAlloc( UINT uc )
{
    HRESULT hr;
    TCHAR * pchOld;
    UINT    ubOld;

    Assert(uc >= Length());  // Disallowed to allocate a too-short buffer.

    if (uc)
    {
        pchOld = _pch;      // Save pointer to old string.
        _pch = 0;           // Prevent Set from Freeing the string.
        ubOld = pchOld ?    // Save old length
                    *(UINT *) (((BYTE *)pchOld) - sizeof(UINT))
                  : 0;

        hr = Set(pchOld, uc);                   // Alloc new; Copy old string.
        if (hr)
        {
            _pch = pchOld;
            RRETURN(hr);
        }
        *(UINT *)(((BYTE *)_pch) - sizeof(UINT)) = ubOld; // Restore length.

        if (pchOld )
        {
            delete [] (((BYTE *)pchOld) - sizeof(UINT));
        }
    }

    // else if uc == 0, then, since we have already checked that uc >= Length,
    // length must == 0.

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Append
//
//  Synopsis:   Append chars to the end of the string, reallocating & updating
//              its length.
//
//----------------------------------------------------------------------------

HRESULT
CStr::Append(LPCTSTR pch, UINT uc)
{
    HRESULT hr = S_OK;
    UINT ucOld, ucNew;
    BYTE *p;

    if (uc)
    {
        ucOld = Length();
        ucNew = ucOld + uc;
        hr = ReAlloc(ucNew);
        if (hr)
            goto Cleanup;
        _tcsncpy(_pch + ucOld, pch, uc);
        ((TCHAR *)_pch) [ucNew] = 0;
        p = ((BYTE*)_pch - sizeof(UINT));
        *(UINT *)p = ucNew * sizeof(TCHAR);
    }
Cleanup:
    RRETURN(hr);
}


HRESULT
CStr::Append(LPCTSTR pch)
{
    RRETURN(Append(pch, pch ? _tcsclen(pch) : 0));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::AppendMultiByte, public
//
//  Synopsis:   Append a multibyte string to the end,
//
//----------------------------------------------------------------------------

HRESULT
CStr::AppendMultiByte(LPCSTR pch)
{
    HRESULT hr = S_OK;
    UINT ucOld, ucNew, uc;
    BYTE *p;

    uc = strlen(pch);

    if (uc)
    {
        ucOld = Length();
        ucNew = ucOld + uc;
        hr = ReAlloc(ucNew);
        if (hr)
            goto Cleanup;

        uc = MultiByteToWideChar(CP_ACP,
                                 0,
                                 pch,
                                 uc,
                                 _pch + ucOld,
                                 uc + 1);
        if (uc == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            TraceTag((tagError, "CSTR: Fatal string conversion error %x", hr));

            goto Cleanup;
        }

        ((TCHAR *)_pch) [ucNew] = 0;
        p = ((BYTE*)_pch - sizeof(UINT));
        *(UINT *)p = ucNew * sizeof(TCHAR);
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetLengthNoAlloc, public
//
//  Synopsis:   Sets the internal length of the string. Note.  There is no
//              verification that the length that is set is within the allocated
//              range of the string. If the caller sets the length too large,
//              this blasts a null byte into memory.
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetLengthNoAlloc( UINT uc )
{
    if (_pch)
    {
        BYTE * p = ( (BYTE *)_pch - sizeof(UINT));
        *(UINT *)p = uc * sizeof(TCHAR);    // Set the length prefix.
        ((TCHAR *)_pch) [uc] = 0;           // Set null terminator
        return S_OK;
    }
    else
        return E_POINTER;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::AllocBSTR, public
//
//  Synopsis:   Allocates a BSTR and initializes it with the string that is
//              associated with this class.
//
//  Arguments:  [pBSTR] -- Place to put new BSTR. This pointer should not
//                         be pointing to an existing BSTR.
//
//----------------------------------------------------------------------------

HRESULT
CStr::AllocBSTR(BSTR *pBSTR) const
{
    if (!_pch)
    {
        *pBSTR = 0;
        return S_OK;
    }

    *pBSTR = SysAllocStringLen(*this, Length());
    RRETURN(*pBSTR ? S_OK: E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::TrimTrailingWhitespace, public
//
//  Synopsis:   Removes any trailing whitespace in the string that is
//              associated with this class.
//
//  Arguments:  None.
//
//----------------------------------------------------------------------------

HRESULT CStr::TrimTrailingWhitespace()
{
    if (!_pch)
        return S_OK;

    UINT ucNewLength = Length();

    for ( ; ucNewLength > 0; ucNewLength-- )
    {
        if ( !_istspace( ((TCHAR *)_pch)[ ucNewLength - 1 ] ) )
            break;
        ((TCHAR *)_pch)[ ucNewLength - 1 ] = (TCHAR) 0;
    }

    BYTE *p = ((BYTE*)_pch - sizeof(UINT));
    *(UINT *)p = ucNewLength * sizeof(TCHAR);
        return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::_Free, private
//
//  Synopsis:   Frees any memory held onto by this class.
//
//----------------------------------------------------------------------------

void
CStr::_Free()
{
    if (_pch )
    {
        delete [] (((BYTE *)_pch) - sizeof(UINT));
    }
    _pch=0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Clone
//
//  Synopsis:   Make copy of current string
//
//----------------------------------------------------------------------------
HRESULT
CStr::Clone(CStr **ppCStr) const
{
    HRESULT hr;
    Assert(ppCStr);
    *ppCStr = new CStr;
    hr = *ppCStr?S_OK:E_OUTOFMEMORY;
    if (hr)
        goto Cleanup;

    hr = THR( (*ppCStr)->Set(*this) );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Compare
//
//  Synopsis:   Case insensitive comparison of 2 strings
//
//----------------------------------------------------------------------------
BOOL
CStr::Compare (const CStr *pCStr) const
{
    return (!_tcsicmp(*pCStr, *this));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::ComputeCrc
//
//  Synopsis:   Computes a hash of the string.
//
//----------------------------------------------------------------------------
#pragma warning(disable:4305)
WORD
CStr::ComputeCrc() const
{
    WORD wHash=0;
    const TCHAR* pch;
    int i;

    pch=*this;
    for(i = Length();i > 0;i--, pch++)
    {
        wHash = wHash << 7 ^ wHash >> (16-7) ^ (TCHAR)CharUpper((LPTSTR)((DWORD)(*pch)));
    }

    return wHash;
}
#pragma warning(default:4305)

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Load
//
//  Synopsis:   Initializes the CStr from a stream
//
//----------------------------------------------------------------------------
HRESULT
CStr::Load(IStream * pstm)
{
    DWORD cch;
    HRESULT hr;

    hr = THR(pstm->Read(&cch, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    if (cch == 0xFFFFFFFF)
    {
        Free();
    }
    else
    {
        hr = THR(Set(NULL, cch));
        if (hr)
            goto Cleanup;

        if (cch)
        {
            hr = THR(pstm->Read(_pch, cch * sizeof(TCHAR), NULL));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Save
//
//  Synopsis:   Writes the contents of the CStr to a stream
//
//----------------------------------------------------------------------------
HRESULT
CStr::Save(IStream * pstm) const
{
    DWORD   cch = _pch ? Length() : 0xFFFFFFFF;
    HRESULT hr;

    hr = THR(pstm->Write(&cch, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    if (cch && cch != 0xFFFFFFFF)
    {
        hr = THR(pstm->Write(_pch, cch * sizeof(TCHAR), NULL));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::GetSaveSize
//
//  Synopsis:   Returns the number of bytes which will be written by
//              CStr::Save
//
//----------------------------------------------------------------------------
ULONG
CStr::GetSaveSize() const
{
    return(sizeof(DWORD) + (_pch ? (Length() * sizeof(TCHAR)) : 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\util\dynary.cxx ===
//+------------------------------------------------------------------------
//
//  File:   formsary.cxx
//
//  Contents:   Generic dynamic array class
//
//  Classes:    CImplAry
//
//-------------------------------------------------------------------------

#include <headers.hxx>

//  CImplAry class

//+------------------------------------------------------------------------
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//-------------------------------------------------------------------------
CImplAry::~CImplAry( )
{
    if (!UsingStackArray())
    {
        MemFree(PData());
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is _cStack*cb if
//              we're still using the stack-allocated array.
//
//----------------------------------------------------------------------------

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }
    else
    {
        return MemGetSize(PData());
    }
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CImplAry::EnsureSize ( size_t cb, long c )
{
    HRESULT  hr = S_OK;
    unsigned long cbAlloc;

    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        goto Cleanup;

    Assert( c >= 0 );

    cbAlloc = ((c < 8) ? c : ((c + 7) & ~7)) * cb;

    if (UsingStackArray() ||
        (((unsigned long) c > ((_c < 8) ? _c : ((_c + 7) & ~7))) && cbAlloc > MemGetSize(PData())))
    {
        Assert(!_fCheckLock && "CDataAry changing while CImplAryLock is on");

        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //

            void * pbDataOld = PData();
            int    cbOld     = GetAlloced( cb );

            PData() = MemAlloc( cbAlloc );

            if (!PData())
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            memcpy( PData(), pbDataOld, cbOld );
        }
        else
        {
            hr = MemRealloc( (void **) & PData(), cbAlloc );

            if (hr)
                goto Cleanup;
        }

        _fDontFree = FALSE;
    }

Cleanup:

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (!hr)
    {
        SetSize(c);
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//-------------------------------------------------------------------------
HRESULT
CImplAry::AppendIndirect(size_t cb, void * pv, void ** ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, _c);
    }

    if (!pv)
    {
        memset(Deref(cb, _c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, _c), pv, cb);
    }

    _c++;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Member: CImplAry::Delete
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//-------------------------------------------------------------------------
void
CImplAry::Delete(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)_c);

    Assert(!_fCheckLock && "CDataAry changing while CImplAryLock is on");

    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    _c--;
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//-------------------------------------------------------------------------
BOOL
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        Delete(cb, i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//-------------------------------------------------------------------------
void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)_c) && (end < (int)_c));
    Assert(end >= start);

    if ((unsigned)end < (_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (_c - end - 1) * cb);
    }

    _c -= (end - start) + 1;
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//-------------------------------------------------------------------------
void
CImplAry::DeleteAll(void)
{
    Assert(!_fCheckLock && "CDataAry changing while CImplAryLock is on");

    if (!UsingStackArray())
    {
        MemFree(PData());

        if (_fStack)
        {
            PData() = GetStackPtr();
            _fDontFree = TRUE;
        }
        else
        {
            PData() = NULL;
        }
    }

    _c = 0;
}


//+------------------------------------------------------------------------
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//-------------------------------------------------------------------------
HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (_c - i ) * cb);

    if (!pv)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }
    _c++;
    return NOERROR;

}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//----------------------------------------------------------------------------

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = _c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return _c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, BOOL fAddRef)
{
    RRETURN(CopyIndirect(cb, ary._c, ((CImplAry *)&ary)->PData(), fAddRef));
}



//+------------------------------------------------------------------------
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    IUnknown **     ppUnk;

    if (pv == PData())
        return S_OK;

    DeleteAll();
    if (pv)
    {
        if (EnsureSize(cb, c))
            RRETURN(E_OUTOFMEMORY);

        memcpy(PData(), pv, c * cb);
    }

    _c = c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}


HRESULT
CImplPtrAry::ClearAndReset()
{
    //  BUGBUG why does this function reallocate memory, rather than
    //    just memset'ing to 0? (chrisz)

    // BUGBUG -- Do not use this method! Use DeleteAll to clear the array.
    Assert(!PData());

    PData() = NULL;
    HRESULT hr = EnsureSize(_c);
    _c = 0;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//-------------------------------------------------------------------------

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
}

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
}

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
}

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
}

int
CImplPtrAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}


void
CImplPtrAry::Delete(int i)
{
    CImplAry::Delete(sizeof(void *), i);
}

BOOL
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::Delete(sizeof(void *), i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
}

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown * pUnk;

    Assert(idx < (int)_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];

    Delete(idx);

    if (pUnk)
        (pUnk)->Release();
}


void
CImplPtrAry::ReleaseAll(void)
{
    int         i;
    IUnknown ** ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < _c; i++, ppUnk++)
    {
        if (*ppUnk)
            (*ppUnk)->Release();
    }

    DeleteAll();
}

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, BOOL fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, BOOL fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\util\memutils.cxx ===
//+------------------------------------------------------------------------
//
//  File:       memutil.cxx
//
//  Contents:   Memory utilities
//
//  History:    Stolen from Trident
//
//-------------------------------------------------------------------------

#include "headers.hxx"

EXTERN_C HANDLE g_hProcessHeap;

#define SMALLBLOCKHEAP 0

void
ClearInterfaceFn(IUnknown **ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}


//+------------------------------------------------------------------------
// Allocation functions not implemented in this file:
//
//      CDUTIL.HXX
//          operator new
//          operator delete
//
//      OLE's OBJBASE.H
//          CoTaskMemAlloc, CoTaskMemFree
//
//-------------------------------------------------------------------------

#if SMALLBLOCKHEAP

DeclareTag(tagSmallBlockHeap, "!Memory", "Check small block heap every time")
DeclareTag(tagSmallBlockHeapDisable, "!Memory", "Disable small block heap");

#define _CRTBLD 1
#include "winheap.h"
EXTERN_C CRITICAL_SECTION g_csHeap;

#if DBG == 1
#define CHECKSBH if (IsTagEnabled(tagSmallBlockHeap)) {Assert(CheckSmallBlockHeap() && "Small block heap corrupt");};
BOOL IsSmallBlockHeapEnabled()
{
    static int g_fSmallBlockHeap = -1;
    if (g_fSmallBlockHeap == -1)
        g_fSmallBlockHeap = IsTagEnabled(tagSmallBlockHeapDisable) ? 0 : 1;
    return(g_fSmallBlockHeap == 1);
}
BOOL CheckSmallBlockHeap()
{
    if (IsSmallBlockHeapEnabled())
    {
        EnterCriticalSection(&g_csHeap);
        BOOL f = __sbh_heap_check() >= 0;
        LeaveCriticalSection(&g_csHeap);
        return f;
    }
    return TRUE;
}
#else
#define CHECKSBH
#endif

#else

#if DBG == 1
BOOL CheckSmallBlockHeap()
{
    return TRUE;
}
#endif

#endif SMALLBLOCKHEAP

//+------------------------------------------------------------------------
//
//  Function:   _MemGetSize
//
//  Synopsis:   Get size of block allocated with MemAlloc/MemRealloc.
//
//              Note that MemAlloc/MemRealloc can allocate more than
//              the requested number of bytes. Therefore the size returned
//              from this function is possibly greater than the size
//              passed to MemAlloc/Realloc.
//
//  Arguments:  [pv] - Return size of this block.
//
//  Returns:    The size of the block, or zero of pv == NULL.
//
//-------------------------------------------------------------------------
ULONG
_MemGetSize(void *pv)
{
    if (pv == NULL)
        return 0;

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        __sbh_region_t *    preg;
        __sbh_page_t *      ppage;
        __map_t *           pmap;

        EnterCriticalSection(&g_csHeap);
        if ((pmap = __sbh_find_block(DbgPreGetSize(pv), &preg, &ppage)) != NULL )
        {
            size_t s = DbgPostGetSize(((size_t)(*pmap)) << _PARASHIFT);
            LeaveCriticalSection(&g_csHeap);
            return s;
        }
        LeaveCriticalSection(&g_csHeap);
    }
#endif

    return DbgPostGetSize(HeapSize(g_hProcessHeap, 0, DbgPreGetSize(pv)));
}

//+------------------------------------------------------------------------
//
//  Function:   _MemAlloc
//
//  Synopsis:   Allocate block of memory.
//
//              The contents of the block are undefined.  If the requested size
//              is zero, this function returns a valid pointer.  The returned
//              pointer is guaranteed to be suitably aligned for storage of any
//              object type.
//
//  Arguments:  [cb] - Number of bytes to allocate.
//
//  Returns:    Pointer to the allocated block, or NULL on error.
//
//-------------------------------------------------------------------------
void *
_MemAlloc(ULONG cb)
{
    AssertSz (cb, "Requesting zero sized block.");

    // The small-block heap will lose its mind if this ever happens, so we
    // protect against the possibility.

    if (cb == 0)
        cb = 1;

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        /* round up to the nearest paragraph */
        size_t cbr = (DbgPreAlloc(cb) + _PARASIZE - 1) & ~(_PARASIZE - 1);

        if (cbr < __sbh_threshold)
        {
            CHECKSBH;
            EnterCriticalSection(&g_csHeap);
            void * pv = DbgPostAlloc(__sbh_alloc_block(cbr >> _PARASHIFT));
            LeaveCriticalSection(&g_csHeap);
            if (pv)
                return pv;
        }
    }
#endif

    return DbgPostAlloc(HeapAlloc(g_hProcessHeap, 0, DbgPreAlloc(cb)));
}


//+------------------------------------------------------------------------
//  Function:   _MemAllocClear
//
//  Synopsis:   Allocate a zero filled block of memory.
//
//              If the requested size is zero, this function returns a valid
//              pointer. The returned pointer is guaranteed to be suitably
//              aligned for storage of any object type.
//
//  Arguments:  [cb] - Number of bytes to allocate.
//
//  Returns:    Pointer to the allocated block, or NULL on error.
//
//-------------------------------------------------------------------------
void *
_MemAllocClear(ULONG cb)
{
    AssertSz (cb, "Allocating zero sized block.");

    // The small-block heap will lose its mind if this ever happens, so we
    // protect against the possibility.

    if (cb == 0)
        cb = 1;

    void * pv;

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        /* round up to the nearest paragraph */
        size_t cbr = (DbgPreAlloc(cb) + _PARASIZE - 1) & ~(_PARASIZE - 1);

        if (cbr < __sbh_threshold)
        {
            CHECKSBH;
            EnterCriticalSection(&g_csHeap);
            pv = DbgPostAlloc(__sbh_alloc_block(cbr >> _PARASHIFT));
            LeaveCriticalSection(&g_csHeap);
            if (pv)
            {
                memset(pv, 0, cb);
                return pv;
            }
        }
    }
#endif

    pv = DbgPostAlloc(HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY,
                    DbgPreAlloc(cb)));

    // In debug, DbgPostAlloc set the memory so we need to clear it again.

#if DBG==1
    if (pv)
    {
        memset(pv, 0, cb);
    }
#endif

    return pv;
}

//+------------------------------------------------------------------------
//
//  Function:   _MemFree
//
//  Synopsis:   Free a block of memory allocated with MemAlloc,
//              MemAllocFree or MemRealloc.
//
//  Arguments:  [pv] - Pointer to block to free.  A value of zero is
//              is ignored.
//
//-------------------------------------------------------------------------

void
_MemFree(void *pv)
{
    // The null check is required for HeapFree.
    if (pv == NULL)
        return;

    Assert(g_hProcessHeap);

#if DBG == 1
    pv = DbgPreFree(pv);
#endif

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        __sbh_region_t *preg;
        __sbh_page_t *  ppage;
        __map_t *       pmap;

        CHECKSBH;
        EnterCriticalSection(&g_csHeap);
        if ( (pmap = __sbh_find_block(pv, &preg, &ppage)) != NULL ) {
            __sbh_free_block(preg, ppage, pmap);
            LeaveCriticalSection(&g_csHeap);
            DbgPostFree();
            return;
        }
        LeaveCriticalSection(&g_csHeap);
    }
#endif

    HeapFree(g_hProcessHeap, 0, pv);
    DbgPostFree();
}

//+------------------------------------------------------------------------
//  Function:   _MemRealloc
//
//  Synopsis:   Change the size of an existing block of memory, allocate a
//              block of memory, or free a block of memory depending on the
//              arguments.
//
//              If cb is zero, this function always frees the block of memory
//              and *ppv is set to zero.
//
//              If cb is not zero and *ppv is zero, then this function allocates
//              cb bytes.
//
//              If cb is not zero and *ppv is non-zero, then this function
//              changes the size of the block, possibly by moving it.
//
//              On error, *ppv is left unchanged.  The block contents remains
//              unchanged up to the smaller of the new and old sizes.  The
//              contents of the block beyond the old size is undefined.
//              The returned pointer is guaranteed to be suitably aligned for
//              storage of any object type.
//
//              The signature of this function is different than thy typical
//              realloc-like function to avoid the following common error:
//                  pv = realloc(pv, cb);
//              If realloc fails, then null is returned and the pointer to the
//              original block of memory is leaked.
//
//  Arguments:  [cb] - Requested size in bytes. A value of zero always frees
//                  the block.
//              [ppv] - On input, pointer to existing block pointer or null.
//                  On output, pointer to new block pointer.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemRealloc(void **ppv, ULONG cb)
{
    void *pv;

    Assert(g_hProcessHeap);

    if (cb == 0)
    {
        _MemFree(*ppv);
        *ppv = 0;
    }
    else if (*ppv == NULL)
    {
        *ppv = _MemAlloc(cb);
        if (*ppv == NULL)
            return E_OUTOFMEMORY;
    }
    else
    {
    #if DBG == 1
        cb = DbgPreRealloc(*ppv, cb, &pv);
    #else
        pv = *ppv;
    #endif

    #if SMALLBLOCKHEAP
    #if DBG==1
        if (IsSmallBlockHeapEnabled())
    #endif
        {
            __sbh_region_t *preg;
            __sbh_page_t *  ppage;
            __map_t *       pmap;
            ULONG           cbr;
            void *          pvNew;

            cbr = (cb + _PARASIZE - 1) & ~(_PARASIZE - 1);

            CHECKSBH;
            EnterCriticalSection(&g_csHeap);
            if ( (pmap = __sbh_find_block(pv, &preg, &ppage)) != NULL )
            {
                pvNew = NULL;
                /*
                 * If the new size falls below __sbh_threshold, try to
                 * carry out the reallocation within the small-block
                 * heap.
                 */
                if ( cbr < __sbh_threshold ) {
                    if ( __sbh_resize_block(preg, ppage, pmap, cbr >> _PARASHIFT))
                    {
                        pvNew = pv;
                    }
                    else if ((pvNew = __sbh_alloc_block(cbr >> _PARASHIFT)) != NULL)
                    {
                        ULONG cbOld = ((size_t)(*pmap)) << _PARASHIFT;
                        memcpy(pvNew, pv, min(cbOld, cb));
                        __sbh_free_block(preg, ppage, pmap);
                    }
                }

                /*
                 * If the reallocation has not been (successfully)
                 * performed in the small-block heap, try to allocate a
                 * new block with HeapAlloc.
                 */
                if ((pvNew == NULL) && ((pvNew = HeapAlloc(g_hProcessHeap, 0, cb)) != NULL))
                {
                    ULONG cbOld = ((size_t)(*pmap)) << _PARASHIFT;
                    memcpy(pvNew, pv, min(cbOld, cb));
                    __sbh_free_block(preg, ppage, pmap);
                }
                LeaveCriticalSection(&g_csHeap);
                *ppv = DbgPostRealloc(pvNew);
                if (*ppv)
                {
                    return S_OK;
                }
                else
                {
                    return E_OUTOFMEMORY;
                }
            }
            else
            {
                LeaveCriticalSection(&g_csHeap);
            }
        }
    #endif

        pv = DbgPostRealloc(HeapReAlloc(g_hProcessHeap, 0, pv, cb));

        if (pv == NULL)
            return E_OUTOFMEMORY;
        *ppv = pv;
    }

    return S_OK;
}

// MEMGUARD -------------------------------------------------------------------

#if defined(MEMGUARD)

#define MGGUARDDATA 0xF0F0BAAD

struct MGGUARD
{
    MGGUARD *pNext;
    DWORD    dw;
};

MGGUARD * g_pMemList = NULL;

void
_MgMemValidate()
{
    EnterCriticalSection(&g_csHeap);

    MGGUARD *pg = g_pMemList;

    while (pg)
    {
        if (pg->dw != MGGUARDDATA)
        {
            DebugBreak();
        }

        pg = pg->pNext;
    }

    LeaveCriticalSection(&g_csHeap);
}

void
_MgRemove(MGGUARD *pmg)
{
    if (!pmg)
        return;

    EnterCriticalSection(&g_csHeap);

    MGGUARD *pg = g_pMemList;

    if (pmg == pg)
    {
        g_pMemList = pg->pNext;
        goto Cleanup;
    }

    while (pg)
    {
        if (pg->pNext == pmg)
        {
            pg->pNext = pg->pNext->pNext;
            break;
        }

        pg = pg->pNext;
    }

Cleanup:
    LeaveCriticalSection(&g_csHeap);

}

void
_MgAdd(MGGUARD *pmg)
{
    EnterCriticalSection(&g_csHeap);

    pmg->pNext = g_pMemList;
    g_pMemList = pmg;

    LeaveCriticalSection(&g_csHeap);
}

void *
_MgMemAlloc(ULONG cb)
{
    _MgMemValidate();

    MGGUARD * pmg = (MGGUARD *)_MemAlloc(sizeof(MGGUARD) + cb);

    if (pmg)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        return(pmg + 1);
    }
    else
    {
        return(NULL);
    }

}

void *
_MgMemAllocClear(ULONG cb)
{
    _MgMemValidate();

    MGGUARD * pmg = (MGGUARD *)_MemAllocClear(sizeof(MGGUARD) + cb);

    if (pmg)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        return(pmg + 1);
    }
    else
    {
        return(NULL);
    }
}

HRESULT
_MgMemRealloc(void ** ppv, ULONG cb)
{
    _MgMemValidate();

    if (cb == 0)
    {
        _MgMemFree(*ppv);
        *ppv = 0;
        return(S_OK);
    }

    if (*ppv == NULL)
    {
        *ppv = _MgMemAlloc(cb);
        return(*ppv ? S_OK : E_OUTOFMEMORY);
    }

    MGGUARD *  pmg = (MGGUARD *)*ppv - 1;

    _MgRemove(pmg);

    HRESULT    hr = _MemRealloc((void **)&pmg, sizeof(MGGUARD) + cb);

    if (hr == S_OK)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        *ppv = pmg + 1;
    }

    return(hr);
}

ULONG
_MgMemGetSize(void * pv)
{
    _MgMemValidate();

    if (pv == NULL)
        return(0);
    else
        return(_MemGetSize((MGGUARD *)pv - 1) - sizeof(MGGUARD));
}

void
_MgMemFree(void * pv)
{
    _MgMemValidate();

    if (pv)
    {
        MGGUARD * pmg = (MGGUARD *)pv - 1;
        if (pmg->dw != MGGUARDDATA)
        {
            // The memory guard DWORD was overwritten! Bogus!
#ifdef _M_IX86
            _asm int 3  // To get a proper stacktrace.
#else
            DebugBreak();
#endif
        }
        _MgRemove(pmg);

        _MemFree(pmg);
    }
}

HRESULT
_MgMemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst)
{
    TCHAR *pch;
    size_t cb;

    cb = (_tcsclen(pchSrc) + 1) * sizeof(TCHAR);
    *ppchDst = pch = (TCHAR *)_MgMemAlloc(cb);
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        return S_OK;
    }
}

HRESULT
_MgMemAllocString(ULONG cch, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb = cch * sizeof(TCHAR);

    *ppchDest = pch = (TCHAR *)_MgMemAlloc(cb + sizeof(TCHAR));
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        pch[cch] = 0;
        return S_OK;
    }
}

HRESULT
_MgMemReplaceString(const TCHAR *pchSrc, TCHAR **ppchDest)
{
    HRESULT hr;
    TCHAR *pch;

    if (pchSrc)
    {
        hr = THR(_MgMemAllocString(pchSrc, &pch));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pch = NULL;
    }

    _MgMemFreeString(*ppchDest);
    *ppchDest = pch;

    return S_OK;
}

#endif // MEMGUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\util\regsettingsio.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       RegSettingsIO.cxx
//
//  Contents:   Register Settings IO functions
//
//              Written by Lyle Corbin
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "RegSettingsIO.h"

const WCHAR *g_szRegistry = L"Software\\Microsoft\\MTScript";

HRESULT
RegSettingsIO(const WCHAR *szRegistry, BOOL fSave, const REGKEYINFORMATION *aKeyValues, int cKeyValues, BYTE *pBase)
{
    LONG                lRet;
    HKEY                hKeyRoot = NULL;
    HKEY                hKeySub  = NULL;
    int                 i;
    DWORD               dwType;
    DWORD               dwSize;
    DWORD               dwDisposition;

    DWORD               dwDataBuf[MAX_REG_VALUE_LENGTH];
    BYTE              * bDataBuf = (BYTE*) dwDataBuf;

    BYTE              * pbData;
    BOOL                fWriteReg = fSave;
    WCHAR             * pch;

    const REGKEYINFORMATION * prki;
    lRet = RegCreateKeyEx(HKEY_CURRENT_USER,
                          g_szRegistry,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hKeyRoot,
                          &dwDisposition);

    if( lRet != ERROR_SUCCESS )
        return S_FALSE;

    if (dwDisposition == REG_CREATED_NEW_KEY)
    {
        //
        // The key didn't exist. Write out the default values.
        //
        fWriteReg = TRUE;
    }

    for (i = 0; i < cKeyValues; i++)
    {
        prki = &aKeyValues[i];

        switch (prki->rkiType)
        {
        case RKI_KEY:
            if (!prki->pszName)
            {
                hKeySub = hKeyRoot;
            }
            else
            {
                if (hKeySub && (hKeySub != hKeyRoot))
                {
                    RegCloseKey(hKeySub);
                    hKeySub = NULL;

                    fWriteReg = fSave;
                }

                pch = prki->pszName;

                lRet = RegCreateKeyEx(hKeyRoot,
                                      pch,
                                      0,
                                      NULL,
                                      0,
                                      KEY_ALL_ACCESS,
                                      NULL,
                                      &hKeySub,
                                      &dwDisposition);

                if (lRet != ERROR_SUCCESS)
                {
                    // We couldn't get this key, skip it.
                    i++;
                    while (i < cKeyValues &&
                           aKeyValues[i].rkiType != RKI_KEY)
                    {
                        i++;
                    }

                    i--; // Account for the fact that continue will increment i again.
                    hKeySub = NULL;
                    continue;
                }
                else if (dwDisposition == REG_CREATED_NEW_KEY)
                {
                    //
                    // The key didn't exist. Write out the default values.
                    //
                    fWriteReg = TRUE;
                }
            }
            break;

        case RKI_BOOL:
            Assert(hKeySub);

            if (fWriteReg)
            {
                RegSetValueEx(hKeySub,
                              prki->pszName,
                              0,
                              REG_DWORD,
                              (BYTE*)((BYTE *)pBase + prki->cbOffset),
                              sizeof(BOOL));
            }
            else
            {
                dwSize = MAX_REG_VALUE_LENGTH;

                lRet = RegQueryValueEx(hKeySub,
                                       prki->pszName,
                                       0,
                                       &dwType,
                                       bDataBuf,
                                       &dwSize);

                if (lRet == ERROR_SUCCESS)
                {
                    pbData = (BYTE*)((BYTE *)pBase + prki->cbOffset);

                    if (dwType == REG_DWORD)
                    {
                        *pbData = (*(DWORD*)bDataBuf != 0);
                    }
                    else if (dwType == REG_SZ)
                    {
                        TCHAR ch = *(TCHAR *)bDataBuf;

                        if (ch == _T('1') ||
                            ch == _T('y') ||
                            ch == _T('Y'))
                        {
                            *pbData = TRUE;
                        }
                        else
                        {
                            *pbData = FALSE;
                        }
                    } else if (dwType == REG_BINARY)
                    {
                        *pbData = (*(BYTE*)bDataBuf != 0);
                    }

                    // Can't convert other types. Just leave it the default.
                }
            }
            break;

        case RKI_DWORD:
            Assert(hKeySub);

            if (fWriteReg)
            {
                RegSetValueEx(hKeySub,
                              prki->pszName,
                              0,
                              REG_DWORD,
                              (BYTE*)((BYTE *)pBase + prki->cbOffset),
                              sizeof(DWORD));
            }
            else
            {
                dwSize = sizeof(DWORD);

                lRet = RegQueryValueEx(hKeySub,
                                       prki->pszName,
                                       0,
                                       &dwType,
                                       bDataBuf,
                                       &dwSize);

                if (lRet == ERROR_SUCCESS && (dwType == REG_BINARY || dwType == REG_DWORD))
                {
                    *(DWORD*)((BYTE *)pBase + prki->cbOffset) = *(DWORD*)bDataBuf;
                }
            }
            break;

        case RKI_STRING:
        case RKI_EXPANDSZ:
            Assert(hKeySub);

            {
                CStr *pstr = ((CStr *)((BYTE *)pBase + prki->cbOffset));

                if (fWriteReg)
                {
                    //
                    // Only write it out if there is a value there.  That way
                    // we get the default next time we load even if it may
                    // evaluate differently (e.g.  location of this exe
                    // changes).
                    //
                    RegSetValueEx(hKeySub,
                                  prki->pszName,
                                  0,
                                  (prki->rkiType == RKI_STRING) ? REG_SZ : REG_EXPAND_SZ,
                                  (BYTE*)((pstr->Length() > 0) ? (LPTSTR)*pstr : L""),
                                  (pstr->Length()+1) * sizeof(TCHAR));
                }
                else
                {
                    dwSize = 0;

                    // get the size of string
                    lRet = RegQueryValueEx(hKeySub,
                                           prki->pszName,
                                           0,
                                           &dwType,
                                           NULL,
                                           &dwSize);

                    if (lRet == ERROR_SUCCESS && dwSize - sizeof(TCHAR) > 0)
                    {
                        // Set already adds 1 for a terminating NULL, and
                        // dwSize is including it as well.
                        pstr->Set(NULL, (dwSize / sizeof(TCHAR)) - 1);

                        lRet = RegQueryValueEx(hKeySub,
                                               prki->pszName,
                                               0,
                                               &dwType,
                                               (BYTE*)(LPTSTR)*pstr,
                                               &dwSize);

                        if (lRet != ERROR_SUCCESS ||
                            (dwType != REG_SZ && dwType != REG_EXPAND_SZ))
                        {
                            pstr->Free();
                        }

                        if (dwType == REG_EXPAND_SZ)
                        {
                            CStr cstrExpand;

                            dwSize = ExpandEnvironmentStrings(*pstr, NULL, 0);

                            // Set already adds 1 for a terminating NULL, and
                            // dwSize is including it as well.
                            cstrExpand.Set(NULL, dwSize - 1);

                            dwSize = ExpandEnvironmentStrings(*pstr, cstrExpand, dwSize + 1);

                            pstr->TakeOwnership(cstrExpand);
                        }

                        pstr->TrimTrailingWhitespace();
                    }
                }
            }

            break;

        default:
            AssertSz(FALSE, "Unrecognized RKI Type");
            break;
        }
    }

    if (hKeySub && (hKeySub != hKeyRoot))
        RegCloseKey(hKeySub);

    RegCloseKey( hKeyRoot );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mtscript\util\thrdcomm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       thrdcomm.cxx
//
//  Contents:   Implementation of the CThreadComm class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

DeclareTagOther(tagDontKillThread, "MTScript", "Dont Terminate Threads on Shutdown");

//+---------------------------------------------------------------------------
//
//  CThreadComm class
//
//  Handles communication between threads.
//
//----------------------------------------------------------------------------

CThreadComm::CThreadComm()
{
    Assert(_hCommEvent == NULL);
    Assert(_hThreadReady == NULL);
    Assert(_hThread    == NULL);
    Assert(_pMsgData   == NULL);
}

CThreadComm::~CThreadComm()
{
    MESSAGEDATA *pMsg;

    if (_hThread)
        CloseHandle(_hThread);

    if (_hCommEvent)
        CloseHandle(_hCommEvent);

    if (_hThreadReady)
        CloseHandle(_hThreadReady);

    if (_hResultEvt)
        CloseHandle(_hResultEvt);

    while (_pMsgData)
    {
        pMsg = _pMsgData->pNext;

        delete _pMsgData;

        _pMsgData = pMsg;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::Init, public
//
//  Synopsis:   Initializes the class. Must be called on all instances before
//              using.
//
//----------------------------------------------------------------------------

BOOL
CThreadComm::Init()
{
    _hCommEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!_hCommEvent)
        goto Error;

    _hThreadReady = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!_hThreadReady)
        goto Error;

    _hResultEvt = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!_hResultEvt)
        goto Error;

    return TRUE;

Error:
    ErrorPopup(L"CThreadComm::Init");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::SendHelper, public
//
//  Synopsis:   Send or post the given message to the thread which owns
//              this class.
//
//  Arguments:  [md]     -- Message to send
//              [pvData] -- Associated data with message.
//              [cbData] -- Size of info that [pvData] points to.
//              [fSend]  -- TRUE if we're doing a send, FALSE if it's a post
//              [hResultEvt] -- Event handle to signal when the result is ready
//
//----------------------------------------------------------------------------

DWORD
CThreadComm::SendHelper(THREADMSG mt,
                        void *    pvData,
                        DWORD     cbData,
                        BOOL      fSend,
                        HANDLE    hResultEvt)
{
    DWORD        dwRet = 0;
    MESSAGEDATA *pMsg = NULL, *pMsgLoop;

    AssertSz(!pvData || cbData != 0, "Invalid params to PostToThread");

    pMsg = new MESSAGEDATA;
    if (!pMsg)
        goto Error;

    pMsg->pNext      = NULL;
    pMsg->tmMessage  = mt;
    pMsg->dwResult   = 0;
    pMsg->hResultEvt = hResultEvt;

    if (pvData)
    {
        AssertSz(cbData <= MSGDATABUFSIZE, "Data is too big!");

        pMsg->cbData = cbData;
        memcpy(pMsg->bData, pvData, cbData);
    }
    else
    {
        pMsg->cbData = 0;
    }

    {
        LOCK_LOCALS(this);

        if (!fSend)
        {
            //
            // Stick the new message at the end so we get messages FIFO
            //

            pMsgLoop = _pMsgData;

            while (pMsgLoop && pMsgLoop->pNext)
            {
                pMsgLoop = pMsgLoop->pNext;
            }

            if (!pMsgLoop)
            {
                _pMsgData = pMsg;
            }
            else
            {
                pMsgLoop->pNext = pMsg;
            }
        }
        else
        {
            // Set dwResult to indicate we're expecting a result
            pMsg->dwResult = 1;

            //
            // Put sent messages at the front to minimize potential deadlocks
            //
            pMsg->pNext = _pMsgData;
            _pMsgData = pMsg;

            Assert(hResultEvt);

            ResetEvent(hResultEvt);
        }
    }

    SetEvent(_hCommEvent);

    if (fSend)
    {
        HANDLE ahEvents[2];
        ahEvents[0] = hResultEvt;
        ahEvents[1] = _hThread ;
        DWORD dwWait = WaitForMultipleObjects(2, ahEvents, FALSE, 50000);
        switch(dwWait)
        {
            case WAIT_OBJECT_0: // OK, this is good
                break;

            default:
            case WAIT_OBJECT_0 + 1:
            case WAIT_TIMEOUT:
                AssertSz(FALSE, "SendToThread never responded!");

                //
                // This causes a memory leak, but it's better than a crash. What
                // we really need to do is remove the message from the queue.
                //
                return 0;
        }

        dwRet = pMsg->dwResult;

        delete pMsg;
    }

    return dwRet;

Error:
    ErrorPopup(L"CThreadComm::PostToThread - out of memory");

    return dwRet;
}
//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::PostToThread, public
//
//  Synopsis:   Post the given message to the thread which owns pTarget.
//
//  Arguments:  [md]     -- Message to send
//              [pvData] -- Associated data with message.
//              [cbData] -- Size of info that [pvData] points to.
//
//----------------------------------------------------------------------------

void
CThreadComm::PostToThread(CThreadComm *pTarget,
                          THREADMSG    mt,
                          void *       pvData,
                          DWORD        cbData)
{
    (void)pTarget->SendHelper(mt, pvData, cbData, FALSE, NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::SendToThread, public
//
//  Synopsis:   Send the given message to the thread which owns this class.
//
//  Arguments:  [md]     -- Message to send
//              [pvData] -- Associated data with message.
//              [cbData] -- Size of info that [pvData] points to.
//
//----------------------------------------------------------------------------

DWORD
CThreadComm::SendToThread(CThreadComm *pTarget,
                          THREADMSG    mt,
                          void *       pvData,
                          DWORD        cbData)
{
    DWORD  dwRet;

    VERIFY_THREAD();

    Assert(sizeof(_fInSend) == 4);  // We are relying on atomic read/writes
                                    //   because multiple threads are accessing
                                    //   this variable.
    Assert(!_fInSend);

    _fInSend = TRUE;

    if (pTarget->_fInSend)
    {
        //
        // Somebody is trying to send to us while we're sending to someone else.
        // This is potentially a deadlock situation! First, wait and see if it
        // resolves, then if it doesn't, assert and bail out!
        //
        TraceTag((tagError, "Perf Hit! Avoiding deadlock situation!"));

        Sleep(100); // Arbitrary 100 ms

        if (pTarget->_fInSend)
        {
            AssertSz(FALSE, "Deadlock - SendToThread called on object doing a send!");

            _fInSend = FALSE;

            return 0;
        }
    }

    dwRet = pTarget->SendHelper(mt, pvData, cbData, TRUE, _hResultEvt);

    _fInSend = FALSE;

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::GetNextMsg, public
//
//  Synopsis:   Retrieves the next message waiting for this thread.
//
//  Arguments:  [md]      -- Place to put message type.
//              [pData]   -- Associated data for message. Must be allocated
//                            memory of size MSGDATABUFSIZE
//              [pcbData] -- Size of info in *pData is returned here.
//
//  Returns:    TRUE if a valid message was returned. FALSE if there are no
//              more messages.
//
//----------------------------------------------------------------------------

BOOL
CThreadComm::GetNextMsg(THREADMSG *mt, void * pData, DWORD *pcbData)
{
    MESSAGEDATA *pMsg;
    BOOL         fRet = TRUE;

    VERIFY_THREAD();

    LOCK_LOCALS(this);

    AssertSz(!_pMsgReply, "Sent message not replied to!");

    pMsg = _pMsgData;

    if (pMsg)
    {
        _pMsgData = pMsg->pNext;

        *mt       = pMsg->tmMessage;
        *pcbData  = pMsg->cbData;
        memcpy(pData, pMsg->bData, pMsg->cbData);

        //
        // If the caller is not expecting a reply, delete the message. If he is,
        // then the caller will free the memory.
        //
        if (pMsg->dwResult == 0)
        {
            delete pMsg;
        }
        else
        {
            _pMsgReply = pMsg;
        }
    }
    else if (!_pMsgData)
    {
        ResetEvent(_hCommEvent);
        fRet = FALSE;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::Reply, public
//
//  Synopsis:   Call this to send the result of a SendToThread call back to
//              the calling thread.
//
//  Arguments:  [dwReply] -- Result to send back.
//
//----------------------------------------------------------------------------

void
CThreadComm::Reply(DWORD dwReply)
{
    VERIFY_THREAD();

    Assert(_pMsgReply);

    _pMsgReply->dwResult = dwReply;

    SetEvent(_pMsgReply->hResultEvt);

    _pMsgReply = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     MessageEventPump, public
//
//  Synopsis:   Empties our message queues (both windows' and our private
//              threadcomm queue)
//
//  Arguments:
//              [hEvent]    -- event handle to wait for
//
//  Returns:
//              WAIT_ABANDONED: An event occurred which is causing this thread to
//                        terminate. The caller should clean up and finish
//                        what it's doing.
//              WAIT_OBJECT_0: If one (or all if fAll==TRUE) of the passed-in
//                           event handles became signaled. The index of the
//                           signaled handle is added to MEP_EVENT_0. Returned
//                           only if one or more event handles were passed in.
//
//----------------------------------------------------------------------------

DWORD
MessageEventPump(HANDLE hEvent)
{
    MSG   msg;
    DWORD dwRet;
    DWORD mepReturn = 0;

    do
    {
        //
        // Purge out all window messages (primarily for OLE's benefit).
        //
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                return WAIT_ABANDONED;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        dwRet = MsgWaitForMultipleObjects(1,
                                          &hEvent,
                                          FALSE,
                                          INFINITE,
                                          QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
        {
            mepReturn = dwRet;
            break;
        }
        else if (dwRet == WAIT_OBJECT_0 + 1)
        {
            //
            // A windows message came through. It will be handled at the
            // top of the loop.
            //
        }
        else if (dwRet == WAIT_FAILED || dwRet == WAIT_ABANDONED)
        {
            TraceTag((tagError, "WaitForMultipleObjects failure (%d)", GetLastError()));

            AssertSz(FALSE, "WaitForMultipleObjects failure");

            mepReturn = dwRet;

            break;
        }
    }
    while (true);
    return mepReturn;
}
//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::StartThread, public
//
//  Synopsis:   Starts a new thread that owns this CThreadComm instance.
//
//----------------------------------------------------------------------------

HRESULT
CThreadComm::StartThread(void * pvParams)
{
    if (!Init())
    {
        AssertSz(FALSE, "Failed to initialize new class.");
        return E_FAIL; // TODO: need to change Init() to return HRESULT
    }
    ResetEvent(_hThreadReady);

    //
    // Create suspended because we need to set member variables before it
    // gets going.
    //
    _hThread = CreateThread(NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)CThreadComm::TempThreadRoutine,
                            (LPVOID)this,
                            CREATE_SUSPENDED,
                            &_dwThreadId);

    if (_hThread == NULL)
    {
        long e = GetLastError();
        return HRESULT_FROM_WIN32(e);
    }

    _pvParams = pvParams;
    _hrThread = S_OK;
    //
    // Everything's set up - get it going!
    //
    ResumeThread(_hThread);
    //
    // Wait for the new thread to say it's ready...
    //
    MessageEventPump(_hThreadReady); // This is neccessary to allow the new thread to retrieve the script parameter with GetInterfaceFromGlobal().
    // On failure, wait for the thread to exit before returning.
    if (FAILED(_hrThread))
    {
        WaitForSingleObject(_hThread, INFINITE);
        return _hrThread;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::TempThreadRoutine, public
//
//  Synopsis:   Static member given to CreateThread. Just a stub that calls
//              the real thread routine.
//
//----------------------------------------------------------------------------

DWORD
CThreadComm::TempThreadRoutine(LPVOID pvParam)
{
    CThreadComm *pThis = (CThreadComm*)pvParam;

    AssertSz(pThis, "Bad arg passed to CThreadComm::TempThreadRoutine");

    return pThis->ThreadMain();
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::SetName, public
//
//  Synopsis:   On a debug build, sets the thread name so the debugger
//              lists the threads in an understandable manner.
//
//  Arguments:  [pszName] -- Name to set thread to.
//
//----------------------------------------------------------------------------

void
CThreadComm::SetName(LPCSTR pszName)
{
#if DBG == 1
    THREADNAME_INFO info =
    {
        0x1000,
        pszName,
        _dwThreadId
    };

    __try
    {
        RaiseException(0x406d1388, 0, sizeof(info) / sizeof(DWORD), (DWORD *)&info);
    }
    __except(EXCEPTION_CONTINUE_EXECUTION)
    {
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::Shutdown, public
//
//  Synopsis:   Forces the thread containing the given instance of the
//              ThreadComm object to shutdown.
//
//  Arguments:  [pTarget] -- Object to shutdown
//
//  Returns:    TRUE if it shutdown normally, FALSE if it had to be killed.
//
//----------------------------------------------------------------------------

BOOL
CThreadComm::Shutdown(CThreadComm *pTarget)
{
    BOOL fReturn    = TRUE;
    DWORD dwTimeout = (IsTagEnabled(tagDontKillThread)) ? INFINITE : 5000;
    DWORD dwCode;

    GetExitCodeThread(pTarget->hThread(), &dwCode);

    // Is client already dead?

    if (dwCode != STILL_ACTIVE)
        return TRUE;

    //
    // Sending the PLEASEEXIT message will flush all other messages out,
    // causing any unsent data to be sent before closing the pipe.
    //
    PostToThread(pTarget, MD_PLEASEEXIT);

    // Wait 5 seconds for our thread to terminate and then kill it.
    if (WaitForSingleObject(pTarget->hThread(), dwTimeout) == WAIT_TIMEOUT)
    {
        TraceTag((tagError, "Terminating thread for object %x...", this));

        AssertSz(FALSE, "I'm being forced to terminate a thread!");

        TerminateThread(pTarget->hThread(), 1);

        fReturn = FALSE;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\comstf.h ===
/************************************************/
/* Common Library Component public include file */
/************************************************/


#if !defined (COMSTF_INCLUDED )

#define COMSTF_INCLUDED

#include <windows.h>

// avoid warnings on every file from including stdlib.h
#if defined(min)
#undef min
#undef max
#endif /* min */

#include <port1632.h>

#define _dt_begin_ignore
#define _dt_end_ignore
_dt_begin_ignore
#define _dt_public
#define _dt_private
#define _dt_hidden
#define _dt_system(s)
#define _dt_subsystem(s)
_dt_end_ignore

#include <ids.h>


_dt_system(Common Library)


/*
**	Global variable macro for DLL portability
*/
_dt_public
#define GLOBAL(x)  (x)


/*	standard datatypes
*/
_dt_public typedef  BYTE *          PB;

_dt_public typedef  unsigned        CB;

_dt_public typedef  LONG *          PLONG_STF;


/*	BOOLean datatype
*/
#define  fFalse  ((BOOL)0)

#define  fTrue   ((BOOL)1)


/*	To avoid compiler warnings for unused parameters
*/
#define  Unused(x)      (x)=(x)


/*  If new GRCs are added, they should as well be handled
	in EercErrorHandler() in ERROR1.C */
/*
**	General Return Code datatype
*/
typedef  USHORT  GRC;

#define  grcFirst                   ((GRC)0)

#define  grcLast                    ((GRC)57)

#define  grcOkay                    ((GRC)0)
#define  grcNotOkay                 ((GRC)1)
#define  grcOutOfMemory             ((GRC)2)
#define  grcInvalidStruct           ((GRC)3)
#define  grcOpenFileErr             ((GRC)4)
#define  grcCreateFileErr           ((GRC)5)
#define  grcReadFileErr             ((GRC)6)
#define  grcWriteFileErr            ((GRC)7)
#define  grcRemoveFileErr           ((GRC)8)
#define  grcRenameFileErr           ((GRC)9)
#define  grcReadDiskErr             ((GRC)10)
#define  grcCreateDirErr            ((GRC)11)
#define  grcRemoveDirErr            ((GRC)12)
#define  grcBadINF                  ((GRC)13)
#define  grcINFStartNonSection      ((GRC)14)
#define  grcINFBadSectionLabel      ((GRC)15)
#define  grcINFBadLine              ((GRC)16)
#define  grcINFBadKey               ((GRC)17)
#define  grcINFContainsZeros        ((GRC)18)
#define  grcTooManyINFSections      ((GRC)19)
#define  grcCloseFileErr            ((GRC)20)
#define  grcChangeDirErr            ((GRC)21)
#define  grcINFSrcDescrSect         ((GRC)22)
#define  grcTooManyINFKeys          ((GRC)23)
#define  grcWriteInf                ((GRC)24)
#define  grcInvalidPoer             ((GRC)25)
#define  grcINFMissingLine          ((GRC)26)
#define  grcINFBadFDLine            ((GRC)27)
#define  grcINFBadRSLine            ((GRC)28)
#define  grcBadInstallLine          ((GRC)29)
#define  grcMissingDidErr           ((GRC)30)
#define  grcInvalidPathErr          ((GRC)31)
#define  grcWriteIniValueErr        ((GRC)32)
#define  grcReplaceIniValueErr      ((GRC)33)
#define  grcIniValueTooLongErr      ((GRC)34)
#define  grcDDEInitErr              ((GRC)35)
#define  grcDDEExecErr              ((GRC)36)
#define  grcBadWinExeFileFormatErr  ((GRC)37)
#define  grcResourceTooLongErr      ((GRC)38)
#define  grcMissingSysIniSectionErr ((GRC)39)
#define  grcDecompGenericErr        ((GRC)40)
#define  grcDecompUnknownAlgErr     ((GRC)41)
#define  grcDecompBadHeaderErr      ((GRC)42)
#define  grcReadFile2Err            ((GRC)43)
#define  grcWriteFile2Err           ((GRC)44)
#define  grcWriteInf2Err            ((GRC)45)
#define  grcMissingResourceErr      ((GRC)46)
#define  grcLibraryLoadErr          ((GRC)47)
#define  grcBadLibEntry             ((GRC)48)
#define  grcApplet                  ((GRC)49)
#define  grcExternal                ((GRC)50)
#define  grcSpawn                   ((GRC)51)
#define  grcDiskFull                ((GRC)52)
#define  grcDDEAddItem              ((GRC)53)
#define  grcDDERemoveItem           ((GRC)54)
#define  grcINFMissingSection       ((GRC)55)
#define  grcRunTimeParseErr         ((GRC)56)
#define  grcOpenSameFileErr         ((GRC)57)

/**************************************/
/* common library function prototypes */
/**************************************/


_dt_subsystem(String Handling)


/*	CHaracter Physical representation datatype
*/
_dt_public typedef  BYTE            CHP;
_dt_public typedef  CHP *           PCHP;
_dt_public typedef  CB              CCHP;

_dt_public
#define  CbFromCchp(cchp)  ((CB)(cchp))


/*	CHaracter Logical representation datatype
*/
_dt_public typedef  CHP             CHL;
_dt_public typedef  CHL *           PCHL;
_dt_public typedef  PCHL *          PPCHL;
_dt_public typedef  CB              CCHL;
_dt_public typedef  CB              ICHL;


_dt_hidden
#define  cbFullPathMax    ((CB)(MAX_PATH-1))
_dt_hidden
#define  cchlFullPathMax  ((CCHL)(MAX_PATH-1))
_dt_hidden
#define  cchlFullDirMax   cchlFullPathMax
_dt_hidden
#define  cchpFullPathMax  ((CCHP)(MAX_PATH-1))


_dt_public
#define  cbFullPathBuf    ((CB)(cbFullPathMax + 1))
_dt_public
#define  cchlFullPathBuf  ((CCHL)(cchlFullPathMax + 1))
_dt_public
#define  cchpFullPathBuf  ((CCHP)(cchpFullPathMax + 1))


/*	String Zero terminated datatype
*/
_dt_public typedef  PCHL   SZ;
_dt_hidden
#define PSZ PPSZ
_dt_public typedef  PPCHL  PSZ;
_dt_public typedef  PPCHL  RGSZ;


/*	Comparison Return Code datatype
*/
_dt_public typedef INT CRC;

_dt_public
#define  crcError         ((CRC)(-2))

_dt_public
#define  crcEqual         ((CRC)0)

_dt_public
#define  crcFirstHigher   ((CRC)1)

_dt_public
#define  crcSecondHigher  ((CRC)(-1))


  /* String manipulation routines */
extern  SZ      APIENTRY SzDupl(SZ);
extern  CRC     APIENTRY CrcStringCompare(SZ, SZ);
extern  CRC     APIENTRY CrcStringCompareI(SZ, SZ);
extern  SZ      APIENTRY SzLastChar(SZ);


/*
**	Purpose:
**		Advances a string pointer to the beginning of the next valid
**		character.  This may include skipping a double-byte character.
**	Arguments:
**		sz: the string pointer to advance.  It can be NULL or empty, or else
**			it must point at the beginning of a valid character.
**	Returns:
**		NULL if sz was NULL.
**		sz unchanged if it was an empty string (*sz == '\0').
**		sz advanced past the current character and to the beginning of the
**			next valid character.
*/
_dt_public
#define  SzNextChar(sz)            ((SZ)AnsiNext(sz))


/*
**	Purpose:
**		Retreats a string pointer to the beginning of the previous valid
**		character.  This may include skipping a double-byte character.
**	Arguments:
**		szStart: string pointer to the beginning of a valid character that
**			equals or preceeds the character szCur.
**		szCur:   string pointer to retreat.  It can be NULL or empty, or
**			can point to any byte in a valid character.
**	Returns:
**		NULL if szCur was NULL.
**		sz unchanged if szStart was NULL or if szCur equaled szStart.
**		sz retreated past the current character and to the beginning of the
**			previous valid character.
*/
_dt_public
#define  SzPrevChar(szStart, szCur) ((SZ)AnsiPrev(szStart,szCur))


/*
**	Purpose:
**		Copies a string from one buffer to another.
**	Arguments:
**		szDst: string pointer to destination buffer.  This can be NULL or
**			else it must contain enough storage to copy szSrc with its
**			terminating zero character.
**		szSrc: string pointer to source buffer.  This can be NULL or else
**			must point to a zero terminated string (can be empty).
**	Returns:
**		NULL if either szDst or szSrc is NULL.
**		szDst signifying the operation succeeded.
*/
_dt_public
#define  SzStrCopy(szDst, szSrc)    ((SZ)lstrcpy((LPSTR)szDst,(LPSTR)szSrc))


/*
**	Purpose:
**		Appends a string from one buffer to another.
**	Arguments:
**		szDst: string pointer to destination buffer.  This can be NULL or
**			else it must contain a zero terminated string (can be empty)
**			and enough storage to append szSrc with its terminating zero
**			character.
**		szSrc: string pointer to source buffer.  This can be NULL or else
**			must point to a zero terminated string (can be empty).
**	Returns:
**		NULL if either szDst or szSrc is NULL.
**		szDst signifying the operation succeeded.
*/
_dt_public
#define  SzStrCat(szDst, szSrc)     ((SZ)lstrcat((LPSTR)szDst,(LPSTR)szSrc))


/*
**	Purpose:
**		Calculates the number of Physical Characters that a string occupies
**		(not including the terminating zero character).
**	Arguments:
**		sz: string whose length is to be calculated.
**	Returns:
**		0 if sz was NULL.
**		The number of Physical Characters from the beginning of the string
**			to its terminating zero character.
*/
_dt_public
#define  CchpStrLen(sz)            ((CCHP)CbStrLen(sz))


/*
**	Purpose:
**		Calculates the number of Logical Characters that a string occupies
**		(not including the terminating zero character).
**	Arguments:
**		sz: string whose length is to be calculated.
**	Returns:
**		0 if sz was NULL.
**		The number of Logical Characters from the beginning of the string
**			to its terminating zero character.
*/
_dt_public
#define  CchlStrLen(sz)            ((CCHL)CbStrLen(sz))


/*
**	Purpose:
**		Calculates the number of bytes that a string occupies (not including
**		the terminating zero character).
**	Arguments:
**		sz: string whose length is to be calculated.
**	Returns:
**		0 if sz was NULL.
**		The number of bytes from the beginning of the string to its
**			terminating zero character.
*/
_dt_public
#define  CbStrLen(sz)              ((CB)lstrlen((LPSTR)sz))


/*
**	Purpose:
**		Determines whether the current character is a single Physical
**		Character.
**	Arguments:
**		sz: string pointer which can be NULL, empty, or pointing to the
**			beginning of a valid character.
**	Returns:
**		fFalse if sz is NULL or points to the beginning of a multiple
**			Physical Character character.
**		fTrue if sz is empty or points to the beginning of a single
**			Physical Character character.
*/
_dt_public
#define  FSingleByteCharSz(sz)     ((BOOL)((sz)!=(SZ)NULL))


/*
**	Purpose:
**		Determines whether a character is an End-Of-Line character.
**	Arguments:
**		chp: Physical Character (eg a single byte Logical Character).
**	Returns:
**		fFalse if chp is not either a '\n' or a '\r' character.
**		fTrue if chp is either a '\n' or a '\r' character.
*/
_dt_public
#define FEolChp(chp)         ((BOOL)((chp) == '\n' || (chp) == '\r'))


/*
**	Purpose:
**		Determines whether a character is whitespace.
**	Arguments:
**		chp: Physical Character (eg a single byte Logical Character).
**	Returns:
**		fFalse if chp is not either a space or a tab character.
**		fTrue if chp is either a space or a tab character.
*/
_dt_public
#define FWhiteSpaceChp(chp)  ((BOOL)((chp) == ' '  || (chp) == '\t'))


/*
**	Purpose:
**		Converts a zero-terminated string to upper case.
**	Arguments:
**		sz: the string to convert to upper case.  sz must be non-NULL though
**			it can be empty.
**	Returns:
**		A pointer to the converted string.
*/
_dt_public
#define SzStrUpper(sz)  (SZ)(AnsiUpper((LPSTR)(sz)))

/*
**	Purpose:
**		Converts a zero-terminated string to lower case.
**	Arguments:
**		sz: the string to convert to lower case.  sz must be non-NULL though
**			it can be empty.
**	Returns:
**		A pointer to the converted string.
*/
_dt_public
#define SzStrLower(sz)  (SZ)(AnsiLower((LPSTR)(sz)))


_dt_subsystem(Memory Handling)

#define cbSymbolMax (64*1024)
#define cbAllocMax (65520*5)
#define cbIntStrMax 16


  /* Memory Handling routines */
#if defined(DBG) && defined(MEMORY_CHECK)

        PVOID MyMalloc(unsigned, char *, int) malloc
        PVOID MyRealloc(PVOID,unsigned, char *, int);
        VOID  MyFree(PVOID, char *, int);
        VOID  MemCheck(VOID);
        VOID  MemDump(VOID);

        #define PbAlloc(cb)             ((PB)MyMalloc((unsigned)(cb), __FILE__, __LINE__ ))
        #define PbRealloc(pb,cbn,cbo)   ((PB)MyRealloc(pb,(unsigned)(cbn), __FILE__, __LINE__))
        #define FFree(pb,cb)            (MyFree(pb, __FILE__, __LINE__),TRUE)
        #define MemChk()                MemCheck()

#else  // ! (DBG && MEMORY_CHECK)

        PVOID MyMalloc(unsigned);
        PVOID MyRealloc(PVOID,unsigned);
        VOID  MyFree(PVOID);

        #define PbAlloc(cb)             ((PB)MyMalloc((unsigned)(cb)))
        #define PbRealloc(pb,cbn,cbo)   ((PB)MyRealloc(pb,(unsigned)(cbn)))
        #define FFree(pb,cb)            (MyFree(pb),TRUE)
        #define MemChk()

#endif // DBG && MEMORY_CHECK

/*
**	Purpose:
**		Frees the memory used by an sz.  This assumes the terminating
**		zero occupies the final byte of the allocated buffer.
**	Arguments:
**		sz: the buffer to free.  this must be non-NULL though it can point
**			at an empty string.
**	Returns:
**		fTrue if the Free() operation succeeds.
**		fFalse if the Free() operation fails.
*/
_dt_public
#define FFreeSz(sz)         FFree((PB)(sz),CbStrLen(sz)+1)


/*
**	Purpose:
**		Shrinks a buffer to exactly fit a string.
**	Arguments:
**		sz: the string for which the buffer should shrink to.  sz must be
**			non-NULL though it can be empty.
**		cb: the size in bytes for the buffer that was originally allocated.
**			cb must be greater than or equal to CbStrLen(sz) + 1.
**	Returns:
**		A pointer to the original string if the Realloc() operation succeeds.
**		NULL if the Realloc() operation fails.
*/
_dt_public
#define SzReallocSz(sz,cb)  (SZ)(PbRealloc((PB)(sz),CbStrLen(sz)+1,cb))


#ifdef MEM_STATS
/* Memory Stats Flags */
_dt_private
#define  wModeMemStatNone       0x0000
_dt_private
#define  wModeMemStatAll        0xFFFF

_dt_private
#define  wModeMemStatAlloc      0x0001
_dt_private
#define  wModeMemStatFree       0x0002
_dt_private
#define  wModeMemStatRealloc    0x0004
_dt_private
#define  wModeMemStatSysAlloc   0x0008
_dt_private
#define  wModeMemStatFLAlloc    0x0010
_dt_private
#define  wModeMemStatFLFree     0x0020
_dt_private
#define  wModeMemStatFLRealloc  0x0040
_dt_private
#define  wModeMemStatHistAlloc  0x0080
_dt_private
#define  wModeMemStatHistFree   0x0100
_dt_private
#define  wModeMemStatGarbage    0x0200

extern  BOOL    APIENTRY FOpenMemStats(SZ, WORD);
extern  BOOL    APIENTRY FCloseMemStats(void);
#endif /* MEM_STATS */



_dt_subsystem(File Handling)


/*	Long File Address datatype
*/
_dt_public typedef unsigned long LFA;

_dt_public
#define  lfaSeekError   ((LFA)-1)


/*
**	File Handle structure
**	Fields:
**		iDosfh: DOS file handle.
**		ofstruct: OFSTRUCT used when the file was opened.
*/
_dt_public typedef struct _fh
	{
	INT      iDosfh;
	OFSTRUCT ofstruct;
	} FH;


/*	File Handle datatype
*/
_dt_public typedef  FH *  PFH;


/*	Open File Mode datatype
*/
_dt_public typedef USHORT OFM;

_dt_public
#define  ofmExistRead      ((OFM)OF_EXIST | OF_READ)
_dt_public
#define  ofmExistReadWrite ((OFM)OF_EXIST | OF_READWRITE)

// _dt_public
// #define  ofmRead           ((OFM)OF_READ | OF_SHARE_DENY_WRITE)

_dt_public
#define  ofmRead           ((OFM)OF_READ)
_dt_public
#define  ofmWrite          ((OFM)OF_WRITE | OF_SHARE_EXCLUSIVE)
_dt_public
#define  ofmReadWrite      ((OFM)OF_READWRITE | OF_SHARE_EXCLUSIVE)
_dt_public
#define  ofmCreate         ((OFM)OF_CREATE | OF_SHARE_EXCLUSIVE)


/*	Seek File Mode datatype
*/
_dt_public typedef WORD SFM;

_dt_public
#define  sfmSet   ((SFM)0)

_dt_public
#define  sfmCur   ((SFM)1)

_dt_public
#define  sfmEnd   ((SFM)2)


  /* File handling routines */
extern  PFH     APIENTRY PfhOpenFile(SZ, OFM);
extern  BOOL    APIENTRY FCloseFile(PFH);
extern  CB      APIENTRY CbReadFile(PFH, PB, CB);
extern  CB      APIENTRY CbWriteFile(PFH, PB, CB);
extern  LFA     APIENTRY LfaSeekFile(PFH, LONG, SFM);
extern  BOOL    APIENTRY FEndOfFile(PFH);
extern  BOOL    APIENTRY FRemoveFile(SZ);
extern  BOOL    APIENTRY FWriteSzToFile(PFH, SZ);
extern  BOOL    APIENTRY FFileExists(SZ);
extern  SZ      APIENTRY szGetFileName(SZ szPath);
extern  VOID    APIENTRY FreePfh(PFH pfh);



_dt_subsystem(Path Handling)


  /* Path manipulation routines */

BOOL  FMakeFATPathFromPieces(SZ, SZ, SZ, SZ, CCHP);
BOOL  FMakeFATPathFromDirAndSubPath(SZ, SZ, SZ, CCHP);
LPSTR LocateFilenameInFullPathSpec(LPSTR);

#define FValidFATDir(sz)        fTrue
#define FValidFATPath(sz)       fTrue
#define CchlValidFATSubPath(sz) CbStrLen(sz)        // no checking for WIN32


/*
**	Purpose:
**		Determines if a path is a valid FAT directory.
**	Arguments:
**		szDir: the directory string to check.
**	Returns:
**		fTrue if the szDir is a valid FAT directory.
**		fFalse if the szDir is an invalid FAT directory.
*/
_dt_public
#define  FValidDir(szDir)  FValidFATDir(szDir)


/*
**	Purpose:
**		Determines if a string is a valid FAT SubPath (eg subdirs and filename).
**	Arguments:
**		szSubPath: the SubPath string to check.
**	Returns:
**		zero if the string is an invalid FAT subPath.
**		non-zero count of characters in sz if it is a valid FAT subPath.
*/
_dt_public
#define  CchlValidSubPath(szSubPath)  CchlValidFATSubPath(szSubPath)


/*
**	Purpose:
**		Determines if a path is a valid FAT path.
**	Arguments:
**		szPath: the path to check.
**	Returns:
**		fTrue if the szPath is a valid FAT path.
**		fFalse if the szPath is an invalid FAT path.
*/
_dt_public
#define  FValidPath(szPath)  FValidFATPath(szPath)


/*
**	Purpose:
**		Creates a valid path from volume, path, and filename arguments
**		if possible and stores it in a supplied buffer.
**	Arguments:
**		szVolume:   string containing the volume.
**		szPath:     string containing the path.
**		szFile:     string containing the filename.
**		szBuf:      the buffer in which to store the newly created path.
**		cchpBufMax: the maximum number of physical characters (including the
**			terminating zero) that can be stored in the buffer.
**	Returns:
**		fTrue if a valid FAT path can be created and stored in szBuf.
**		fFalse if szVolume is NULL or invalid (first character must be in the
**			'a' to 'z' or 'A' to 'Z', and the second character must be either
**			a ':' or a terminating zero), if szPath is NULL or invalid (it must
**			start with a '\\' and conform to 8.3 format), if szFile is NULL,
**			empty or invalid (first character cannot be a '\\' and it must
**			conform to 8.3 format), if szBuf is NULL, or if cchpBufMax is not
**			large enough to hold the resultant path.
*/
_dt_public
#define  FMakePathFromPieces(szVolume, szPath, szFile, szBuffer, cchpBufMax) \
			FMakeFATPathFromPieces(szVolume,szPath,szFile,szBuffer,cchpBufMax)


/*
**	Purpose:
**		Creates a valid path from subpath, and filename arguments if possible
**		and stores it in a supplied buffer.
**	Arguments:
**		szDir:      string containing the volume and subdirs.
**		szSubPath:  string containing subdirs and the filename.
**		szBuf:      the buffer in which to store the newly created path.
**		cchpBufMax: the maximum number of physical characters (including the
**			terminating zero) that can be stored in the buffer.
**	Returns:
**		fTrue if a valid FAT path can be created and stored in szBuf.
**		fFalse if szDir is NULL or invalid (first character must be in the
**			'a' to 'z' or 'A' to 'Z', the second character must be either
**			a ':' or a terminating zero, and the third character must be
**			a '\\' and the rest must conform to 8.3 format), if szSubPath is
**			NULL, empty or invalid (first character cannot be a '\\' and it must
**			conform to 8.3 format), if szBuf is NULL, or if cchpBufMax is not
**			large enough to hold the resultant path.
*/
_dt_public
#define  FMakePathFromDirAndSubPath(szDir, szSubPath, szBuffer, cchpBufMax) \
			FMakeFATPathFromDirAndSubPath(szDir,szSubPath,szBuffer,cchpBufMax)




#define AssertDataSeg()

#if DBG

#define  Assert(f)              \
         ((f) ? (void)0 : (void)AssertSzUs(__FILE__,__LINE__))

#define  AssertRet(f, retVal)   \
         {if (!(f)) {AssertSzUs(__FILE__,__LINE__); return(retVal);}}

#define  EvalAssert(f)          \
         ((f) ? (void)0 : (void)AssertSzUs(__FILE__,__LINE__))

#define  EvalAssertRet(f, retVal) \
         {if (!(f)) {AssertSzUs(__FILE__,__LINE__); return(retVal);}}

#define  PreCondition(f, retVal) \
         {if (!(f)) {PreCondSzUs(__FILE__,__LINE__); return(retVal);}}

#define  ChkArg(f, iArg, retVal) \
         {if (!(f)) {BadParamUs(iArg, __FILE__, __LINE__); return(retVal);}}

#else

#define  Assert(f)                 ((void)0)
#define  AssertRet(f, retVal)      ((void)0)
#define  EvalAssert(f)             ((void)(f))
#define  EvalAssertRet(f, retVal)  ((void)(f))
#define  PreCondition(f, retVal)   ((void)0)
#define  ChkArg(f, iArg, retVal)   ((void)0)

#endif


/*
**	Purpose:
**		Generates a task modal message box.
**	Arguments:
**		szTitle: title for message box.
**		szText:  text for message box.
**	Returns:
**		none
*/
_dt_private
#define  MessBoxSzSz(szTitle, szText) \
		MessageBox((HWND)NULL, (LPSTR)szText, (LPSTR)szTitle, \
				MB_TASKMODAL | MB_ICONHAND | MB_OK)


#define AssertSzUs(x, y)    TRUE
#define PreCondSzUs(x, y)   TRUE
#define BadParamUs(x, y, z) TRUE


_dt_subsystem(INF Handling)


/*
**	Inf Data Block structure
**
**	Fields:
**		pidbNext:      next IDB in linked list.
**		pchpBuffer:    character buffer.
**		cchpBuffer:    number of useful characters in pchpBuffer.
**		cchpAllocated: number of characters actually allocated with
**			pchpBuffer.  May be zero.
*/
_dt_public typedef struct _idb
	{
	struct _idb * pidbNext;
	PCHP          pchpBuffer;
	CCHP          cchpBuffer;
	CCHP          cchpAllocated;
	}  IDB;


/*	Inf Data Block datatypes
*/
_dt_public typedef  IDB *  PIDB;
_dt_public typedef  PIDB * PPIDB;

/*
    The following equate is used because of a situation like
    "abcd"+
    "efgh"
    When parsed, this will be "abcd""efgh"  -- is this two strings or
    one string with a double quote in the middle?  If it's the latter,
    we'll actually store "abcd.efgh" where . is DOUBLE_QUOTE.
*/

#define     DOUBLE_QUOTE                '\001'

#define     INFLINE_SECTION             0x01
#define     INFLINE_KEY                 0x02

  /* INF File Handling routines */
GRC  APIENTRY GrcOpenInf(SZ IniFileName, PVOID pInfTempInfo);

BOOL APIENTRY FFreeInf(void);

UINT APIENTRY CKeysFromInfSection(SZ Section, BOOL IncludeAllLines);
BOOL APIENTRY FKeyInInfLine(INT Line);

RGSZ APIENTRY RgszFromInfLineFields(INT Line,UINT StartField,UINT NumFields);
BOOL APIENTRY FFreeRgsz(RGSZ);

UINT APIENTRY CFieldsInInfLine(INT Line);

INT  APIENTRY FindInfSectionLine(SZ Section);
INT  APIENTRY FindNthLineFromInfSection(SZ Section,UINT n);
INT  APIENTRY FindLineFromInfSectionKey(SZ Section,SZ Key);
INT  APIENTRY FindNextLineFromInf(INT Line);

SZ   APIENTRY SzGetNthFieldFromInfLine(INT Line,UINT n);
SZ   APIENTRY SzGetNthFieldFromInfSectionKey(SZ Section,SZ Key,UINT n);

BOOL APIENTRY FUpdateInfSectionUsingSymTab(SZ);

SZ   APIENTRY InterpretField(SZ);

#define  RgszFromInfScriptLine(Line,NumFields) \
         RgszFromInfLineFields(Line,1,NumFields)

#define  FindFirstLineFromInfSection(Section) FindNthLineFromInfSection(Section,1)

/*
**	Option-Element Flags datatype for SFD
*/
_dt_public typedef WORD OEF;

_dt_public
#define oefVital       ((OEF)0x0001)
_dt_public
#define oefCopy        ((OEF)0x0002)
_dt_public
#define oefUndo        ((OEF)0x0004)
_dt_public
#define oefRoot        ((OEF)0x0008)
_dt_public
#define oefDecompress  ((OEF)0x0010)
_dt_public
#define oefTimeStamp   ((OEF)0x0020)
_dt_public
#define oefReadOnly    ((OEF)0x0040)
_dt_public
#define oefBackup      ((OEF)0x0080)
_dt_public
#define oefUpgradeOnly ((OEF)0x0100)

//
// The following oef means that the source file should not be deleted
// after it is copied, even if the source is the DOS setup local source.
// (Files coming from anywhere below that directory are usually deleted
// after they are copied).
//

#define oefNoDeleteSource    ((OEF)0x0200)


_dt_public
#define oefNone        ((OEF)0x0000)
_dt_public
#define oefAll         ((OEF)0xFFFF)


/*
**	Copy-Time Unit datatype for SFD
*/
_dt_public typedef WORD CTU;


/*
**	OverWrite Mode datatype for SFD
*/
_dt_public typedef WORD OWM;

_dt_public
#define owmNever              ((OWM)0x0001)
_dt_public
#define owmAlways             ((OWM)0x0002)
_dt_public
#define owmUnprotected        ((OWM)0x0004)
_dt_public
#define owmOlder              ((OWM)0x0008)
_dt_public
#define owmVerifySourceOlder  ((OWM)0x0010)

/*
**	Option-Element Record for SFD
*/
_dt_public typedef struct _oer
	{
	OEF   oef;
	CTU   ctuCopyTime;
	OWM   owm;
	LONG  lSize;
	SZ    szRename;
	SZ    szAppend;
	SZ    szBackup;
	SZ    szDescription;
	ULONG ulVerMS;
	ULONG ulVerLS;
	SZ    szDate;
	SZ    szDest;
	}  OER;


/*
**	Option-Element Record datatype for SFD
*/
_dt_public typedef OER *   POER;
_dt_public typedef POER *  PPOER;

_dt_public
#define poerNull ((POER)NULL)


/*
**	Disk ID datatype for SFD
*/
_dt_public typedef WORD DID;

_dt_public
#define didMin    1

_dt_public
#define didMost 999


/*
**	Section-File Description structure
**	Fields:
*/
_dt_public typedef struct _sfd
	{
    DID     did;
    UINT    InfId;
    SZ      szFile;
    OER     oer;
	} SFD;


/*
**	Section-File Description datatype
*/
_dt_public typedef  SFD *  PSFD;
_dt_public typedef  PSFD * PPSFD;
_dt_public
#define psfdNull ((PSFD)NULL)


extern  POER    APIENTRY PoerAlloc(VOID);
extern  BOOL    APIENTRY FFreePoer(POER);
extern  BOOL    APIENTRY FPrintPoer(PFH, POER);
extern  BOOL    APIENTRY FValidPoer(POER);

extern  PSFD    APIENTRY PsfdAlloc(VOID);
extern  BOOL    APIENTRY FFreePsfd(PSFD);
extern  GRC     APIENTRY GrcGetSectionFileLine(INT, PPSFD, POER);
extern  BOOL    APIENTRY FPrintPsfd(PFH, PSFD);
#if DBG
extern  BOOL    APIENTRY FValidPsfd(PSFD);
#endif

extern  BOOL    APIENTRY FValidOerDate(SZ);
extern  BOOL    APIENTRY FParseVersion(SZ, PULONG, PULONG);

extern  BOOL    APIENTRY FListIncludeStatementLine(INT Line);
extern  GRC     APIENTRY GrcGetListIncludeSectionLine(INT, PSZ, PSZ);



_dt_subsystem(INF Media Prompting)


/*
**	Source Description List Element data structure
*/
_dt_public typedef  struct _sdle
	{
	struct _sdle *  psdleNext;
    DID             did;           // disk id as specified in the inf
    DID             didGlobal;     // a universal id across infs
	SZ              szLabel;
	SZ              szTagFile;
	SZ              szNetPath;
	}  SDLE;

_dt_public typedef SDLE *   PSDLE;
_dt_public typedef PSDLE *  PPSDLE;


extern  PSDLE  APIENTRY PsdleAlloc(VOID);
extern  BOOL   APIENTRY FFreePsdle(PSDLE);

extern  GRC    APIENTRY GrcFillSrcDescrListFromInf(VOID);



_dt_subsystem(List Building)


/*
**	Copy List Node data structure
*/
_dt_public typedef struct _cln
	{
	SZ            szSrcDir;
	SZ            szDstDir;
	PSFD          psfd;
	struct _cln * pclnNext;
	} CLN;
_dt_public typedef CLN *   PCLN;
_dt_public typedef PCLN *  PPCLN;
_dt_public typedef PPCLN * PPPCLN;


/*
**	Section Files Operation data structure
**	REVIEW -- not really used
*/
_dt_public typedef WORD SFO;
_dt_public
#define sfoCopy   1
_dt_public
#define sfoBackup 2
_dt_public
#define sfoRemove 3

  /* in LIST.C */
extern PCLN  pclnHead;
extern PPCLN ppclnTail;



extern GRC   APIENTRY GrcFillPoerFromSymTab(POER);
extern BOOL  APIENTRY FSetPoerToEmpty(POER);

extern GRC   APIENTRY GrcAddSectionFilesToCopyList(SZ, SZ, SZ);
extern GRC   APIENTRY GrcAddSectionKeyFileToCopyList(SZ, SZ, SZ, SZ);
extern GRC   APIENTRY GrcAddNthSectionFileToCopyList(SZ, UINT, SZ, SZ);
extern GRC   APIENTRY GrcAddSectionFilesToCList(SFO, SZ, SZ, SZ, SZ, POER);
extern GRC   APIENTRY GrcAddLineToCList(INT, SFO, SZ, SZ, POER);
extern GRC   APIENTRY GrcAddPsfdToCList(SZ, SZ, PSFD);

extern PCLN  APIENTRY PclnAlloc(VOID);
extern BOOL  APIENTRY FFreePcln(PCLN);

extern BOOL  APIENTRY FPrintPcln(PFH, PCLN);
#if DBG
extern BOOL  APIENTRY FValidPcln(PCLN);
#endif



/*	Symbol Table constants */
#define  cchpSymMax   ((CCHP)255)
#define  cchpSymBuf   (cchpSymMax + 1)

  /* Symbol Table routines */
extern  BOOL            APIENTRY FAddSymbolValueToSymTab(SZ, SZ);
extern  GRC             APIENTRY GrcAddSymsFromInfSection(SZ);


	/* Message Box Routine */
extern int APIENTRY ExtMessageBox(HANDLE, HWND, WORD, WORD, WORD);



/*
**	Purpose:
**		Determines whether a symbol is defined in the symbol table.
**	Arguments:
**		szSymbol: symbol to search for.  szSymbol must be non-NULL, non-empty,
**			and start with a non-whitespace character.
**	Returns:
**		fTrue if szSymbol is defined in the symbol table (even if the associated
**			is an empty string).
**		fFalse if szSymbol is not defined in the symbol table.
*/
_dt_public
#define  FSymbolDefinedInSymTab(szSymbol) \
					((BOOL)(SzFindSymbolValueInSymTab(szSymbol)!=(SZ)NULL))


extern  SZ      APIENTRY SzFindSymbolValueInSymTab(SZ);
extern  BOOL    APIENTRY FRemoveSymbolFromSymTab(SZ);
extern  RGSZ    APIENTRY RgszFromSzListValue(SZ);
extern  SZ      APIENTRY SzListValueFromRgsz(RGSZ);
extern  BOOL    APIENTRY FFreeInfTempInfo(PVOID);
extern  BOOL    APIENTRY FCheckSymTabIntegrity(VOID);
extern  BOOL    APIENTRY FDumpSymTabToFile(PFH);
extern  SZ      APIENTRY SzGetSubstitutedValue(SZ);
extern  SZ      APIENTRY SzProcessSzForSyms(HWND, SZ);



_dt_subsystem(Parse Table)


/*	String Parse Code
*/
_dt_public typedef unsigned SPC;

_dt_public typedef SPC *  PSPC;


/*
**	String-Code Pair structure
**	Fields:
**		sz:  string.
**		spc: String Parse Code to associate with string.
*/
_dt_public typedef struct _scp
	{
	SZ  sz;
	SPC spc;
	} SCP;


/*	String-Code Pair datatype
*/
_dt_public typedef  SCP *  PSCP;


/*  String Parse Table datatypes
*/
///////////////////////////////////
// _dt_public typedef  SCP    SPT;
///////////////////////////////////

_dt_public typedef  struct _pspt
    {
    PSCP pscpSorted ;   //  Generated for binary search
    long cItems ;       //  Number of items in table
    PSCP pscpBase ;     //  Original as given to PsptInitParsingTable()
    SPC spcDelim ;      //  Table delimiter entry
    } SPT ;

_dt_public typedef  SPT *  PSPT;


/* Symbol Table routines */
extern  PSPT    APIENTRY PsptInitParsingTable(PSCP);
extern  SPC     APIENTRY SpcParseString(PSPT, SZ);
extern  BOOL    APIENTRY FDestroyParsingTable(PSPT);

/* Flow handling routines */

  /* external program, library */

BOOL APIENTRY FParseLoadLibrary(INT Line, UINT *pcFields);
BOOL APIENTRY FParseFreeLibrary(INT Line, UINT *pcFields);
BOOL APIENTRY FParseLibraryProcedure(INT Line,UINT *pcFields);
BOOL APIENTRY FParseRunExternalProgram(INT Line,UINT *pcFields);
BOOL APIENTRY FParseInvokeApplet(INT Line, UINT *pcFields);
BOOL APIENTRY FParseStartDetachedProcess(INT Line, UINT *pcFields);

  /* registry */

BOOL APIENTRY FParseRegistrySection(INT Line, UINT *pcFields, SPC spc);
BOOL APIENTRY FParseCreateRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseOpenRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseFlushRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseCloseRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseDeleteRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseDeleteRegTree(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseEnumRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseSetRegValue(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseGetRegValue(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseDeleteRegValue(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseEnumRegValue(INT Line, UINT *pcFields, SZ szHandle);

BOOL APIENTRY FParseAddFileToDeleteList(INT Line, UINT *pcFields);
BOOL APIENTRY FParseWaitOnEvent(INT Line,UINT *pcFields);
BOOL APIENTRY FParseSignalEvent(INT Line,UINT *pcFields);
BOOL APIENTRY FParseSleep(INT Line, UINT *pcFields);
BOOL APIENTRY FParseFlushInf(INT Line, UINT *pcFields);

/*
**	String Parse Codes for Flow Handling
*/
#define spcError                 0
#define spcUnknown               1
#define spcSet                   2
#define spcIfStr                 3
#define spcIfStrI                4
#define spcIfInt                 5
#define spcIfContains            6
#define spcIfContainsI           7
#define spcIfFirst               spcIfStr
#define spcIfLast                spcIfContainsI
#define spcEndIf                 8
#define spcElse                  9
#define spcElseIfStr            10
#define spcElseIfStrI           11
#define spcElseIfInt            12
#define spcElseIfContains       13
#define spcElseIfContainsI      14
#define spcEQ                   15
#define spcNE                   16
#define spcLT                   17
#define spcLE                   18
#define spcGT                   19
#define spcGE                   20
#define spcIn                   21
#define spcNotIn                22
#define spcGoTo                 23
#define spcForListDo            24
#define spcEndForListDo         25
#define spcSetSubst             26
#define spcSetSubsym            27
#define spcDebugMsg             28
#define spcHourglass            29
#define spcArrow                30
#define spcSetInstructionText   31
#define spcSetHelpFile          32
#define spcCreateRegKey         33
#define spcOpenRegKey           34
#define spcFlushRegKey          35
#define spcCloseRegKey          36
#define spcDeleteRegKey         37
#define spcDeleteRegTree        38
#define spcEnumRegKey           39
#define spcSetRegValue          40
#define spcGetRegValue          41
#define spcDeleteRegValue       42
#define spcEnumRegValue         43
#define spcSetAdd               50
#define spcSetSub               51
#define spcSetMul               52
#define spcSetDiv               53
#define spcGetDriveInPath       54
#define spcGetDirInPath         55
#define spcLoadLibrary          56
#define spcFreeLibrary          57
#define spcLibraryProcedure     58
#define spcRunExternalProgram   59
#define spcInvokeApplet         60
#define spcDebugOutput          61
#define spcSplitString          62
#define spcQueryListSize        63
#define spcSetOr                64
#define spcAddFileToDeleteList  65
#define spcInitRestoreDiskLog   66
#define spcStartDetachedProcess 67
#define spcWaitOnEvent          68
#define spcSignalEvent          69
#define spcSleep                70
#define spcSetHexToDec          71
#define spcSetDecToHex          72
#define spcFlushInf             73


extern  PSPT   psptFlow;
extern  SCP    rgscpFlow[];

extern  BOOL    APIENTRY FHandleFlowStatements(INT *, HWND, SZ, UINT *,RGSZ *);
extern  BOOL    APIENTRY FInitFlowPspt(VOID);
extern  BOOL    APIENTRY FDestroyFlowPspt(VOID);


_dt_subsystem(Error Handling)


/*
**	Expanded Error Return Code
*/
_dt_public  typedef  unsigned  EERC;
_dt_public
#define  eercAbort  ((EERC)0)
_dt_public
#define  eercRetry  ((EERC)1)
_dt_public
#define  eercIgnore ((EERC)2)

#define EercErrorHandler(HWND, GRC, BOOL, x, y, z) TRUE
#define FHandleOOM(HWND) TRUE

extern  BOOL    APIENTRY FGetSilent(VOID);
extern  BOOL    APIENTRY FSetSilent(BOOL);


VOID SetSupportLibHandle(HANDLE Handle);

extern HCURSOR CurrentCursor;


//
// Utility functions for dealing with multisz's.
//

RGSZ
MultiSzToRgsz(
    IN PVOID MultiSz
    );

PCHAR
RgszToMultiSz(
    IN RGSZ rgsz
    );


BOOL AddFileToDeleteList(PCHAR Filename);

// floppy operations/repair diskette stuff

BOOL
InitializeFloppySup(
    VOID
    );

VOID
TerminateFloppySup(
    VOID
    );

BOOL
FormatFloppyDisk(
    IN  CHAR  DriveLetter,
    IN  HWND  hwndOwner,
    OUT PBOOL Fatal
    );

BOOL
CopyFloppyDisk(
    IN CHAR  DriveLetter,
    IN HWND  hwndOwner,
    IN DWORD SourceDiskPromptId,
    IN DWORD TargetDiskPromptId
    );

UINT
__cdecl
xMsgBox(
    HWND hwnd,
    UINT CaptionResId,
    UINT MessageResId,
    UINT MsgBoxFlags,
    ...
    );


#endif // COMSTF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\main\mttf.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

#define IDD_SIGNON  100
#define IDD_EVENT   200

#define IDB_HELP    666


#define IDS_NORMAL  IDD_SIGNON+1
#define IDS_WARM    IDD_SIGNON+2
#define IDS_COLD    IDD_SIGNON+3

#define IDE_DISABLE IDD_EVENT+1

#define MAX_DIR     128
#define MAX_NAME    16
#define MAX_BUILD_W 4
#define MAX_MEM_W   8
#define MAX_DATETIME 20


typedef struct {
    DWORD Version;
    DWORD Idle;
    DWORD Busy;
    DWORD PercentTotal;
    DWORD Warm;
    DWORD Cold;
    DWORD Other;
    DWORD IdleConsec;
    } StatFileRecord;

typedef struct {
    CHAR MachineName[MAX_NAME];
    CHAR Tab1;
    CHAR MachineType;
    CHAR Tab2;
    CHAR Build[MAX_BUILD_W];
    CHAR Tab3;
    CHAR Mem[MAX_MEM_W];
    CHAR Tab4;
    CHAR UserName[MAX_NAME];
    CHAR Tab5;
    CHAR DateAndTime[MAX_DATETIME];
    CHAR CRLF[2];
    } NameFileRecord;

typedef enum {
    MTTF_TIME,
    MTTF_WARM,
    MTTF_COLD,
    MTTF_OTHER
    } StatType;


#define UNKNOWN_CPU 'U'
#define X86_CPU     'X'
#define MIP_CPU     'M'
#define AXP_CPU     'A'
#define PPC_CPU     'P'


VOID IncrementStats(StatType stattype);
VOID ReadIniFile();
INT_PTR SignonDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR EventDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\ids.h ===
#define  cchpBufTmpLongMax   255
#define  cchpBufTmpLongBuf   (cchpBufTmpLongMax + 1)
#define  cchpBufTmpShortMax   63
#define  cchpBufTmpShortBuf  (cchpBufTmpShortMax + 1)




  /* for Resource String Table */
#define IDS_NULL                     0
#define IDS_USAGE_TITLE              1
#define IDS_USAGE_MSG1               2
#define IDS_USAGE_MSG2               3
#define IDS_USAGE_USAGE              4
#define IDS_USAGE_F                  5
#define IDS_USAGE_I                  6
#define IDS_USAGE_C                  7
#define IDS_USAGE_S                  8
#define IDS_USAGE_D                  9
#define IDS_USAGE_T                 10
#define IDS_USAGE_N                 11
#define IDS_USAGE_V                 12


#define IDS_ERROR                   17
#define IDS_INTERNAL_ERROR          18
#define IDS_BAD_SHL_SCRIPT_SECT     19
#define IDS_BAD_DEST_PATH           20
#define IDS_BAD_INF_SRC             21
#define IDS_BAD_SRC_PATH            22
#define IDS_EXE_PATH_LONG           23
#define IDS_GET_MOD_FAIL            24
#define IDS_UI_EH_ERR               25
#define IDS_INTERP_ERR              26

#define IDS_CANT_FIND_SHL_SECT      27
#define IDS_REGISTER_CLASS          28
#define IDS_CREATE_WINDOW           29
#define IDS_SECOND_INSTANCE         30

#define IDS_UPDATE_INF              31
#define IDS_UI_CMD_ERROR            32

#define IDS_SETUP_INF               33
#define IDS_SHELL_CMDS_SECT         34
#define IDS_ABOUT_MENU              35
#define IDS_ABOUT_TITLE             36
#define IDS_ABOUT_MSG               37

#define IDS_SHL_CMD_ERROR           38
#define IDS_NEED_EXIT               39

#define IDS_INF_SECT_REF            40

#define IDS_CD_BLANKNAME            41
#define IDS_CD_BLANKORG             42
#define IDS_EXE_CORRUPT             43
#define IDS_WARNING                 44
#define IDS_INSTRUCTIONS            45
#define IDS_EXITNOTSETUP            46
#define IDS_EXITCAP                 47
#define IDS_MESSAGE                 48
#define IDS_CANT_END_SESSION        49
#define IDS_CANCEL                  50
#define IDS_PROGRESS                51
#define IDS_NOTDONE                 52

// error messages
#define IDS_ERROR_OOM               53
#define IDS_ERROR_OPENFILE          54
#define IDS_ERROR_CREATEFILE        55
#define IDS_ERROR_READFILE          56
#define IDS_ERROR_WRITEFILE         57
#define IDS_ERROR_REMOVEFILE        58
#define IDS_ERROR_RENAMEFILE        59
#define IDS_ERROR_READDISK          60
#define IDS_ERROR_CREATEDIR         61
#define IDS_ERROR_REMOVEDIR         62
#define IDS_ERROR_CHANGEDIR         63
#define IDS_ERROR_GENERALINF        64
#define IDS_ERROR_INFNOTSECTION     65
#define IDS_ERROR_INFBADSECTION     66
#define IDS_ERROR_INFBADLINE        67
#define IDS_ERROR_INFHASNULLS       68
#define IDS_ERROR_INFXSECTIONS      69
#define IDS_ERROR_INFXKEYS          70
#define IDS_ERROR_INFSMDSECT        71
#define IDS_ERROR_WRITEINF          72
#define IDS_ERROR_LOADLIBRARY       73
#define IDS_ERROR_BADLIBENTRY       74
#define IDS_ERROR_INVOKEAPPLET      75
#define IDS_ERROR_EXTERNALERROR     76
#define IDS_ERROR_DIALOGCAPTION     77
#define IDS_ERROR_INVALIDPOER       78
#define IDS_ERROR_INFMISSINGLINE    79
#define IDS_ERROR_INFBADFDLINE      80
#define IDS_ERROR_INFBADRSLINE      81

#define IDS_GAUGE_TEXT_1            82
#define IDS_GAUGE_TEXT_2            83
#define IDS_INS_DISK                84
#define IDS_INTO                    85
#define IDS_BAD_CMDLINE             86
#define IDS_VER_DLL                 87
#define IDS_SETUP_WARNING           88
#define IDS_BAD_LIB_HANDLE          89

#define IDS_ERROR_BADINSTALLLINE         90
#define IDS_ERROR_MISSINGDID             91
#define IDS_ERROR_INVALIDPATH            92
#define IDS_ERROR_WRITEINIVALUE          93
#define IDS_ERROR_REPLACEINIVALUE        94
#define IDS_ERROR_INIVALUETOOLONG        95
#define IDS_ERROR_DDEINIT                96
#define IDS_ERROR_DDEEXEC                97
#define IDS_ERROR_BADWINEXEFILEFORMAT    98
#define IDS_ERROR_RESOURCETOOLONG        99
#define IDS_ERROR_MISSINGSYSINISECTION  100
#define IDS_ERROR_DECOMPGENERIC         101
#define IDS_ERROR_DECOMPUNKNOWNALG      102
#define IDS_ERROR_DECOMPBADHEADER       103
#define IDS_ERROR_READFILE2             104
#define IDS_ERROR_WRITEFILE2            105
#define IDS_ERROR_WRITEINF2             106
#define IDS_ERROR_MISSINGRESOURCE       107
#define IDS_ERROR_SPAWN                 108
#define IDS_ERROR_DISKFULL              109
#define IDS_ERROR_DDEREMOVEITEM         110
#define IDS_ERROR_DDEADDITEM            111
#define IDS_ERROR_INFMISSINGSECT        112
#define IDS_SURECANCEL                  113
#define IDS_ERROR_RUNTIMEPARSE          114
#define IDS_ERROR_OPENSAMEFILE          115

// messages related to floppy operations (format/diskcopy).

#define IDS_INSERTDISKETTE              200
#define IDS_FIRSTREPAIRDISKPROMPT       201
#define IDS_SECONDREPAIRDISKPROMPT      202
#define IDS_FORMATTINGDISK              205
#define IDS_FORMATGENERALFAILURE        207
#define IDS_CANTDETERMINEFLOPTYPE       209
#define IDS_BADFLOPPYTYPE               210
#define IDS_FLOPPYWRITEPROT             211
#define IDS_FLOPPYIOERR                 212
#define IDS_FLOPPYUNKERR                213
#define IDS_RETRYFORMATREPAIRDISK       215
#define IDS_ALLDATAWILLBELOST           217
#define IDS_CANTINITFLOPPYSUP           218
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\dospif.h ===
/***************************************************************************

INCLUDE FILE: dospif.h - DOSPIF include file

   This file contains definitions (#define, #typedef, external variable and
   function declarations) used in Windows Setup for setting up DOS PIFs.

   *********  IMPORTANT  **********

   This file contains typedefs and bit masks which were copied from the pif 
   editor include files.  Do not change before consulting with pif editor 
   sources.
  
   Copyright (C) Microsoft, 1991

HISTORY:

   Modified by:      Date:       Comment:

   PAK               8/21/91     Created
   SUNILP            2/6/92      Modified, retained just PIF stuff.
                                 Added rgszApp fields ENUM.

***************************************************************************/

/* lengths of certain PIF entries */

#define PIFNAMESIZE        30
#define PIFSTARTLOCSIZE    63
#define PIFDEFPATHSIZE     64
#define PIFPARAMSSIZE      64
#define PIFSHPROGSIZE      64
#define PIFSHDATASIZE      64
#define PIFEXTSIGSIZE      16

/* Miscellaneous defines */

#define LASTHEADERPTR      0xFFFF
#define STDHDRSIG          "MICROSOFT PIFEX"
#define W386HDRSIG         "WINDOWS 386 3.0"
#define W286HDRSIG30       "WINDOWS 286 3.0"
#define DFLT_ICON_FILE     "PROGMAN.EXE"

/* Standard and enhanced modes */

#define MODE_STANDARD   "STANDARD"
#define MODE_ENHANCED   "ENHANCED"


/* String switches used in APPS.INF to set PIF options */

#define GRAF_MULTXT        "gra"
#define COM1               "c1"
#define COM2               "c2"
#define COM3               "c3"
#define COM4               "c4"
#define NO_SCRN_EXCHANGE   "nse"
#define KEYB               "kbd"
#define PREVENT_PROG_SW    "pps"
#define FULL_SCREEN        "fs"
#define WINDOWED_OPT       "win"
#define BACKGROUND         "bgd"
#define EXCLUSIVE          "exc"
#define DETECT_IDLE_TIME   "dit"
#define EMS_LOCKED         "eml"
#define XMS_LOCKED         "xml"
#define USE_HIMEM_AREA     "hma"
#define LOCK_APP_MEM       "lam"
#define LO_RES_GRAPH       "lgr"
#define HI_RES_GRAPH       "hgr"
#define EMULATE_TEXT_MODE  "emt"
#define RETAIN_VIDEO_MEM   "rvm"
#define ALLOW_FAST_PASTE   "afp"
#define ALLOW_CLOSE_ACTIVE "cwa"
#define ALT_SPACE          "asp"
#define ALT_ENTER          "aen"
#define NO_SAVE_SCREEN     "nss"
#define TEXT_OPT           "txt"
#define CLOSE_ON_EXIT      "cwe"
#define ALT_TAB            "ata"
#define ALT_ESC            "aes"
#define CTRL_ESC           "ces"
#define PRSCRN             "psc"
#define ALT_PRSCRN         "aps"

/* Standard and Enhanced section options */

#define UNKNOWN_OPTION     -1
#define PARAMS             1 
#define MINCONVMEM         2
#define VIDEOMODE          3 
#define XMSMEM             4 
#define CHECKBOXES         5 
#define EMSMEM             6 
#define CONVMEM            7 
#define DISPLAY_USAGE      8 
#define EXEC_FLAGS         9
#define MULTASK_OPT        10
#define PROC_MEM_FLAGS     11
#define DISP_OPT_VIDEO     12
#define DISP_OPT_PORTS     13
#define DISP_OPT_FLAGS     14
#define OTHER_OPTIONS      15


/* Bit masks for MSFlags field of PIFNEWSTRUCT */

#define GRAPHMASK       0x02
#define TEXTMASK        0xfd
#define PSMASK          0x04
#define SGMASK          0x08
#define EXITMASK        0x10
#define COM2MASK        0x40
#define COM1MASK        0x80

/* Bit masks for behavior field of PIFNEWSTRUCT */

#define KEYMASK         0x10

/* Bit masks for PfW286Flags field of PIF286EXT30 */

#define fALTTABdis286   0x0001
#define fALTESCdis286   0x0002
#define fALTPRTSCdis286 0x0004
#define fPRTSCdis286    0x0008
#define fCTRLESCdis286  0x0010
#define fNoSaveVid286   0x0020
#define fCOM3_286       0x4000
#define fCOM4_286       0x8000

/* Bit masks for PfW386Flags field of PIF386EXT */

#define fEnableClose    0x00000001L
#define fBackground     0x00000002L
#define fExclusive      0x00000004L
#define fFullScreen     0x00000008L
#define fALTTABdis      0x00000020L
#define fALTESCdis      0x00000040L
#define fALTSPACEdis    0x00000080L
#define fALTENTERdis    0x00000100L
#define fALTPRTSCdis    0x00000200L
#define fPRTSCdis       0x00000400L
#define fCTRLESCdis     0x00000800L
#define fPollingDetect  0x00001000L
#define fNoHMA          0x00002000L
#define fHasHotKey      0x00004000L
#define fEMSLocked      0x00008000L
#define fXMSLocked      0x00010000L
#define fINT16Paste     0x00020000L
#define fVMLocked       0x00040000L

/* Bit masks for PfW386Flags2 field of PIF386EXT */

#define fVidTxtEmulate  0x00000001L
#define fVidNoTrpTxt    0x00000002L
#define fVidNoTrpLRGrfx 0x00000004L
#define fVidNoTrpHRGrfx 0x00000008L
#define fVidTextMd      0x00000010L
#define fVidLowRsGrfxMd 0x00000020L
#define fVidHghRsGrfxMd 0x00000040L
#define fVidRetainAllo  0x00000080L


/* PIF Extension Header */
typedef struct {
    char extsig[PIFEXTSIGSIZE];
    WORD extnxthdrfloff;
    WORD extfileoffset;
    WORD extsizebytes;
    } PIFEXTHEADER, *LPPIFEXTHEADER;

/* PIF Structure */
typedef struct {
    char          unknown;
    char          id;
    char          name[PIFNAMESIZE];
    WORD          maxmem;
    WORD          minmem;
    char          startfile[PIFSTARTLOCSIZE];
    char          MSflags;
    char          reserved;
    char          defpath[PIFDEFPATHSIZE];
    char          params[PIFPARAMSSIZE];
    char          screen;
    char          cPages;
    BYTE          lowVector;
    BYTE          highVector;
    char          rows;
    char          cols;
    char          rowoff;
    char          coloff;
    WORD          sysmem;
    char          shprog[PIFSHPROGSIZE];
    char          shdata[PIFSHDATASIZE];
    BYTE          behavior;
    BYTE          sysflags;
    PIFEXTHEADER  stdpifext;
    } PIFNEWSTRUCT, *LPPIFNEWSTRUCT;

/* WINDOWS/286 3.0 PIF Extension */
typedef struct {
    WORD          PfMaxXmsK;
    WORD          PfMinXmsK;
    WORD          PfW286Flags;
    } PIF286EXT30, *LPPIF286EXT30;

/* WINDOWS/386 3.0 PIF Extension */
typedef struct {
    WORD      maxmem;
    WORD      minmem;
    WORD      PfFPriority;
    WORD      PfBPriority;
    WORD      PfMaxEMMK;
    WORD      PfMinEMMK;
    WORD      PfMaxXmsK;
    WORD      PfMinXmsK;
    DWORD     PfW386Flags;
    DWORD     PfW386Flags2;
    WORD      PfHotKeyScan;
    WORD      PfHotKeyShVal;
    WORD      PfHotKeyShMsk;
    BYTE      PfHotKeyVal;
    BYTE      PfHotKeyPad[9];
    char      params[PIFPARAMSSIZE];
    } PIF386EXT, *LPPIF386EXT;

typedef struct {
    PIFNEWSTRUCT DfltPIF;
    PIF286EXT30  DfltStd;
    PIF386EXT    DfltEnha;
    PIFNEWSTRUCT CurrPIF;
    PIFEXTHEADER StdExtHdr;
    PIF286EXT30  CurrStd;
    PIFEXTHEADER EnhaExtHdr;
    PIF386EXT    CurrEnha;
    } PIF386Combined, *LPPIF386Combined;

typedef struct {
    PIFNEWSTRUCT DfltPIF;
    PIF286EXT30  DfltStd;
    PIF386EXT    DfltEnha;
    PIFNEWSTRUCT CurrPIF;
    PIFEXTHEADER StdExtHdr;
    PIF286EXT30  CurrStd;
    } PIF286Combined, *LPPIF286Combined;

#pragma pack(1)
/* PIF Structure */
typedef struct {
    char          unknown;
    char          id;
    char          name[PIFNAMESIZE];
    WORD          maxmem;
    WORD          minmem;
    char          startfile[PIFSTARTLOCSIZE];
    char          MSflags;
    char          reserved;
    char          defpath[PIFDEFPATHSIZE];
    char          params[PIFPARAMSSIZE];
    char          screen;
    char          cPages;
    BYTE          lowVector;
    BYTE          highVector;
    char          rows;
    char          cols;
    char          rowoff;
    char          coloff;
    WORD          sysmem;
    char          shprog[PIFSHPROGSIZE];
    char          shdata[PIFSHDATASIZE];
    BYTE          behavior;
    BYTE          sysflags;
    PIFEXTHEADER  stdpifext;
    } PACKED_PIFNEWSTRUCT, *LPPACKED_PIFNEWSTRUCT;
#pragma pack()

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the PIFNEWSTRUCT
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(Dst,Src) {                                \
    ((PUCHAR1)(Dst))->Uchar[0] = ((PUCHAR1)(Src))->Uchar[0]; \
}

#define CopyUchar2(Dst,Src) {                                \
    ((PUCHAR2)(Dst))->Uchar[0] = ((PUCHAR2)(Src))->Uchar[0]; \
    ((PUCHAR2)(Dst))->Uchar[1] = ((PUCHAR2)(Src))->Uchar[1]; \
}

#define CopyUchar4(Dst,Src) {                                \
    ((PUCHAR4)(Dst))->Uchar[0] = ((PUCHAR4)(Src))->Uchar[0]; \
    ((PUCHAR4)(Dst))->Uchar[1] = ((PUCHAR4)(Src))->Uchar[1]; \
    ((PUCHAR4)(Dst))->Uchar[2] = ((PUCHAR4)(Src))->Uchar[2]; \
    ((PUCHAR4)(Dst))->Uchar[3] = ((PUCHAR4)(Src))->Uchar[3]; \
}

#define CopyUcharn(Dst, Src, n) {                            \
    memmove((PVOID)Dst, (PVOID)Src, n);                      \
}


#define PackPif(Pif,PPif) {                                                        \
    CopyUchar1(&((PPif)->unknown)    ,&((Pif)->unknown)                         ); \
    CopyUchar1(&((PPif)->id)         ,&((Pif)->id)                              ); \
    CopyUcharn(&((PPif)->name)       ,&((Pif)->name)      , PIFNAMESIZE         ); \
    CopyUchar2(&((PPif)->maxmem)     ,&((Pif)->maxmem)                          ); \
    CopyUchar2(&((PPif)->minmem)     ,&((Pif)->minmem)                          ); \
    CopyUcharn(&((PPif)->startfile)  ,&((Pif)->startfile) , PIFSTARTLOCSIZE     ); \
    CopyUchar1(&((PPif)->MSflags)    ,&((Pif)->MSflags)                         ); \
    CopyUchar1(&((PPif)->reserved)   ,&((Pif)->reserved)                        ); \
    CopyUcharn(&((PPif)->defpath)    ,&((Pif)->defpath)   , PIFDEFPATHSIZE      ); \
    CopyUcharn(&((PPif)->params)     ,&((Pif)->params)    , PIFPARAMSSIZE       ); \
    CopyUchar1(&((PPif)->screen)     ,&((Pif)->screen)                          ); \
    CopyUchar1(&((PPif)->cPages)     ,&((Pif)->cPages)                          ); \
    CopyUchar1(&((PPif)->lowVector)  ,&((Pif)->lowVector)                       ); \
    CopyUchar1(&((PPif)->highVector) ,&((Pif)->highVector)                      ); \
    CopyUchar1(&((PPif)->rows)       ,&((Pif)->rows)                            ); \
    CopyUchar1(&((PPif)->cols)       ,&((Pif)->cols)                            ); \
    CopyUchar1(&((PPif)->rowoff)     ,&((Pif)->rowoff)                          ); \
    CopyUchar1(&((PPif)->coloff)     ,&((Pif)->coloff)                          ); \
    CopyUchar2(&((PPif)->sysmem)     ,&((Pif)->sysmem)                          ); \
    CopyUcharn(&((PPif)->shprog)     ,&((Pif)->shprog)    , PIFSHPROGSIZE       ); \
    CopyUcharn(&((PPif)->shdata)     ,&((Pif)->shdata)    , PIFSHDATASIZE       ); \
    CopyUchar1(&((PPif)->behavior)   ,&((Pif)->behavior)                        ); \
    CopyUchar1(&((PPif)->sysflags)   ,&((Pif)->sysflags)                        ); \
    CopyUcharn(&((PPif)->stdpifext)  ,&((Pif)->stdpifext) , sizeof(PIFEXTHEADER));  \
}


enum tagAppRgszFields {
    nEXETYPE,
    nNAME,
    nEXE,
    nDIR,
    nPIF,
    nDEFDIR,
    nCWE,
    nSTDOPT,
    nENHOPT,
    nICOFIL,
    nICONUM
    };

typedef enum {
    ADDAPP_SUCCESS,
    ADDAPP_GENFAIL,
    ADDAPP_GRPFAIL
    } ADDAPP_STATUS;

/* Make New Long Pointer MACRO */
#define MKNLP(lp,w) (LONG)((DWORD)lp + (DWORD)w)

/* DOS PIF INTERNAL ROUTINE DECLARATIONS */

ADDAPP_STATUS
AddDosAppItem(
    IN RGSZ rgszApp,
    IN SZ   szPifDir,
    IN SZ   szGroup
    );

ADDAPP_STATUS
AddWinItem(
    IN RGSZ rgszApp,
    IN SZ   szGroup
    );


BOOL
FDeterminePIFName(
    IN     RGSZ rgszApp,
    IN     SZ   szPifDir,
    IN OUT SZ   szPIFPath
    );

BOOL
FCreatePIF(
    RGSZ  rgszApp,
    SZ    szPIFPath
    );

VOID
ProcessCommonInfo(
    RGSZ rgszApp,
    LPPIFNEWSTRUCT fpPNS
    );

BOOL
FProcessStdModeInfo(
    SZ szStdOptions,
    LPPIFNEWSTRUCT fpPNS,
    LPPIF286EXT30 fpPStd
    );

VOID
ProcessCheckBoxSwitches(
    RGSZ rgsz,
    LPPIFNEWSTRUCT fpPNS,
    LPPIF286EXT30 fpPStd
    );

BOOL
FProcessEnhaModeInfo(
    SZ szEnhOptions,
    LPPIF386EXT fpPEnha
    );

INT
GetExtOption(
    LPSTR lpsz
    );

BOOL
FInitializePIFStructs(
    BOOL bIsEnhanced,
    SZ   szDfltStdOpt,
    SZ   szDfltEnhOpt
    );

VOID
FreePIFStructs(
    VOID
    );

VOID
ExtractStrFromPIF(
    LPSTR lpsz,
    int n
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\cmnds.h ===
/* File: cmnds.h */
/**************************************************************************/
/*	Install: Commands Header File.
/**************************************************************************/

#include <comstf.h>


/*** REVIEW: put the following in common lib? ***/

/* for mkdir, rmdir */
#include <direct.h>
#include <errno.h>

/* for chmod */
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>

/* for rename */
#include <stdio.h>

_dt_system(Install)

#define szNull ((SZ)NULL)

/*	Returns the number of lines in the given section
*/
#define CLinesFromInfSection(szSect)	CKeysFromInfSection((szSect), fTrue)

/*	Renames a file
*/
#define FRenameFile(szSrc, szDst) \
	((rename((char *)(szSrc), (char *)(szDst)) == 0) ? fTrue : fFalse)

/*	Write protects a file
*/
#define FWriteProtectFile(szPath) \
	((chmod((char *)(szPath), S_IREAD) == 0) ? fTrue : fFalse)

/*	Creates a directory
*/
#define FMkDir(szDir) \
	(((mkdir((char *)(szDir)) == 0) || (errno == EACCES)) ? fTrue : fFalse)

/*	Removes a directory
*/
#define FRmDir(szDir) \
	(((rmdir((char *)(szDir)) == 0) || (errno == ENOENT)) ? fTrue : fFalse)

/*** END REVIEW ***/


/*	CoMmand Options
*/
_dt_private typedef BYTE CMO;
#define cmoVital     1
#define cmoOverwrite 2
#define cmoAppend    4
#define cmoPrepend   8
#define cmoNone   0x00
#define cmoAll    0xFF

  /* filecm.c */
extern BOOL  APIENTRY FCopyFilesInCopyList(HANDLE);
extern BOOL  APIENTRY FBackupSectionFiles(SZ, SZ);
extern BOOL  APIENTRY FBackupSectionKeyFile(SZ, SZ, SZ);
extern BOOL  APIENTRY FBackupNthSectionFile(SZ, USHORT, SZ);
extern BOOL  APIENTRY FRemoveSectionFiles(SZ, SZ);
extern BOOL  APIENTRY FRemoveSectionKeyFile(SZ, SZ, SZ);
extern BOOL  APIENTRY FRemoveNthSectionFile(SZ, USHORT, SZ);
extern BOOL  APIENTRY FCreateDir(SZ, CMO);
extern BOOL  APIENTRY FRemoveDir(SZ, CMO);

/* inicm.c */
extern BOOL  APIENTRY FCreateIniSection(SZ, SZ, CMO);
extern BOOL  APIENTRY FReplaceIniSection(SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FRemoveIniSection(SZ, SZ, CMO);
extern BOOL  APIENTRY FCreateIniKeyNoValue(SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FCreateIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FReplaceIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FAppendIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FRemoveIniKey(SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FCreateSysIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FAddDos5Help(SZ, SZ, CMO);


/* progcm.c */
extern BOOL  APIENTRY FCreateProgManGroup(SZ, SZ, CMO, BOOL);
extern BOOL  APIENTRY FRemoveProgManGroup(SZ, CMO, BOOL);
extern BOOL  APIENTRY FShowProgManGroup(SZ, SZ, CMO, BOOL);
extern BOOL  APIENTRY FCreateProgManItem(SZ, SZ, SZ, SZ, INT, CMO, BOOL);
extern BOOL  APIENTRY FRemoveProgManItem(SZ, SZ, CMO, BOOL);
extern BOOL  APIENTRY FInitProgManDde(HANDLE);
extern BOOL  APIENTRY FEndProgManDde(VOID);

/* misccm.c */

extern BOOL  APIENTRY FSetEnvVariableValue(SZ, SZ, SZ, CMO);
#ifdef UNUSED
extern BOOL  APIENTRY FAddMsgToSystemHelpFile(SZ, SZ, CMO);
#endif /* UNUSED */
extern BOOL  APIENTRY FStampFile(SZ, SZ, SZ, WORD, WORD, SZ, WORD);
extern BOOL  APIENTRY FStampResource(SZ, SZ, SZ, WORD, WORD, SZ, CB);  // 1632

/* extprog.c */

       BOOL FLoadLibrary(SZ DiskName,SZ File,SZ INFVar);
       BOOL FFreeLibrary(SZ INFVar);
       BOOL FLibraryProcedure(SZ INFVar,SZ HandleVar,SZ EntryPoint,RGSZ Args);
       BOOL FRunProgram(SZ,SZ,SZ,SZ,RGSZ);
       BOOL FStartDetachedProcess(SZ,SZ,SZ,SZ,RGSZ);
       BOOL FInvokeApplet(SZ);

/* event.c */
       BOOL FWaitForEvent(IN LPSTR InfVar,IN LPSTR EventName,IN DWORD Timeout);
       BOOL FSignalEvent(IN LPSTR InfVar,IN LPSTR EventName);
       BOOL FSleep(IN DWORD Milliseconds);

/* registry.c */

#define REGLASTERROR    "RegLastError"

       BOOL FCreateRegKey( SZ szHandle, SZ szKeyName, UINT TitleIndex, SZ szClass,
                           SZ Security, UINT Access, UINT Options, SZ szNewHandle,
                           CMO cmo );
       BOOL FOpenRegKey( SZ szHandle, SZ szMachineName, SZ szKeyName, UINT Access, SZ szNewHandle, CMO cmo );
       BOOL FFlushRegKey( SZ szHandle, CMO cmo );
       BOOL FCloseRegKey( SZ szHandle, CMO cmo );
       BOOL FDeleteRegKey( SZ szHandle, SZ szKeyName, CMO cmo );
       BOOL FDeleteRegTree( SZ szHandle, SZ szKeyName, CMO cmo );
       BOOL FEnumRegKey( SZ szHandle, SZ szInfVar, CMO cmo );
       BOOL FSetRegValue( SZ szHandle, SZ szValueName, UINT TitleIndex, UINT ValueType,
                          SZ szValueData, CMO cmo );
       BOOL FGetRegValue( SZ szHandle, SZ szValueName, SZ szInfVar, CMO cmo );
       BOOL FDeleteRegValue( SZ szHandle, SZ szValueName, CMO cmo );
       BOOL FEnumRegValue( SZ szHandle, SZ szInfVar, CMO cmo );


/* bootini.c */

       BOOL FChangeBootIniTimeout(INT Timeout);


/* restore.c */

       BOOL SaveRegistryHives(PCHAR Drive);
       BOOL GenerateRepairDisk(PCHAR Drive);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\main\mttf.c ===
/****************************************************************************

    PROGRAM: mttf.c

    AUTHOR:  Lars Opstad (LarsOp) 3/16/93

    PURPOSE: NT Mean-time-to-failure reporting tool.

    FUNCTIONS:

        WinMain() - check for local file, read ini file and display dialogs
        SignonDlgProc() - processes messages for signon dialog
        EventDlgProc() - processes messages for event (other problem) dialog

    COMMENTS:

        This program displays 2 dialog boxes to prompt the user for
        what type of problem occurred.

        Every polling period, the time in the mttf data file is updated
        (as either busy or idle based on percent of cpu usage).  If a machine
        is idle for more than 4 hrs, the "gone" field is increased by the time
        gone.  Whenever the program starts, the user is prompted for why they
        rebooted or logged off.  Other problems should be logged as they happen.

        If any machine can not access the server file for some reason, the
        data is stored in c:\mttf.dat until the next time the server file is
        opened.  At such a time, the server file is updated and the local file
        is deleted.

****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "mttf.h"      /* specific to this program */

//
// For internal use, include header for NetMessageBufferSend and set up
// alert name and unicode buffers for NetMessageBufferSend.
//
#ifndef CUSTOMER

#include <lm.h>
#define AlertName "DavidAn"
WCHAR   UniAlertName[16];
WCHAR   UnicodeBuffer[1024];

#endif

#define IniFileName "Mttf.ini"
#define LocalFileName "c:\\mttf.dat"


#define DEFAULT_IDLE_LIMIT 10
#define DEFAULT_POLLING_PERIOD 30

#define CONSEC_IDLE_LIMIT 4*60
#define POLLING_PRODUCT 60000
#define HUNDREDNS_TO_MS 10000
#define MAX_RETRIES 10

HANDLE  hInst;       // current instance
HWND    hCopying;    // handle to copying dialog box
DWORD   PollingPeriod  = DEFAULT_POLLING_PERIOD;
DWORD   IdlePercentage = DEFAULT_IDLE_LIMIT;
char    ResultsFile[MAX_DIR], NameFile[MAX_DIR];
BOOL    Enabled=TRUE;
BOOL    LocalExists=FALSE;
DWORD   Version;
DWORD   ConsecIdle=0;
SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
SYSTEM_PERFORMANCE_INFORMATION PreviousPerfInfo;

/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE:  Check for local file, read ini file and display dialogs.

    COMMENTS:

        Check to see if local data file exists and set flag appropriately.
        Initialize the performance information.
        Read the IniFile.
        Display signon dialog.
        Display event dialog (minimized).

****************************************************************************/

int WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    OFSTRUCT ofstruct;

    hInst = hInstance;

    //
    // Check for local file (if exists, write it to server at next opportunity)
    //
    LocalExists=(HFILE_ERROR!=OpenFile(LocalFileName, &ofstruct, OF_EXIST));

    //
    // Initialize performance information
    //
    Version=GetVersion();
    NtQuerySystemInformation(
        SystemPerformanceInformation,
        &PerfInfo,
        sizeof(PerfInfo),
        NULL
        );

    //
    // Read ini file
    //
    ReadIniFile();

//
// For Internal use, convert alert name to unicode for NetMessageBufferSend.
//
#ifndef CUSTOMER

    MultiByteToWideChar(CP_ACP, MB_COMPOSITE, AlertName, sizeof(UniAlertName)/2, UniAlertName, sizeof(UniAlertName)/2);

#endif

    //
    // Display signon dlg
    //
    DialogBox(hInstance, (LPCSTR)IDD_SIGNON, NULL, SignonDlgProc);

    //
    // Display event dialog
    //
    DialogBox(hInstance, (LPCSTR) IDD_EVENT, NULL, EventDlgProc);

    return(0);

} // WinMain()

/*****************************************************************************

    FUNCTION: ReadIniFile ( )

    PURPOSE:  Read values from INI file using GetPrivateProfileString/Int

    COMMENTS:

        This reads entries from the mttf.ini file (in windows nt directory)
        for NameFile, ResultsFile, PollingPeriod and IdlePercent.  Any non-
        existent entry returns a default.

*****************************************************************************/
VOID
ReadIniFile (
   )
{
    GetPrivateProfileString("Mttf",
                            "NameFile",
                            "",
                            NameFile,
                            MAX_DIR,
                            IniFileName);

    GetPrivateProfileString("Mttf",
                            "ResultsFile",
                            "",
                            ResultsFile,
                            MAX_DIR,
                            IniFileName);

    PollingPeriod = GetPrivateProfileInt("Mttf",
                                         "PollingPeriod",
                                         DEFAULT_POLLING_PERIOD,
                                         IniFileName);

    IdlePercentage = GetPrivateProfileInt("Mttf",
                                          "IdlePercent",
                                          DEFAULT_IDLE_LIMIT,
                                          IniFileName);

}

/****************************************************************************

    FUNCTION: DWORD CpuUsage ( )

    PURPOSE:  Returns percentage of cpu usage for last polling period.

    COMMENTS:

        Computes time spent in the idle thread.

        Divides this number by the number of 100nanoseconds in a millisecond.
        (This division is to prevent over-flows in later computations.)

        Returns 100-PercentIdle to get percent busy.

****************************************************************************/
DWORD
CpuUsage(
    )
{
    LARGE_INTEGER EndTime, BeginTime, ElapsedTime;
    DWORD PercentIdle, Remainder;
    PreviousPerfInfo = PerfInfo;

    //
    // Get current perf info
    //
    NtQuerySystemInformation(
        SystemPerformanceInformation,
        &PerfInfo,
        sizeof(PerfInfo),
        NULL
        );

    //
    // Get times from PerfInfo and PreviousPerfInfo
    //
    EndTime = *(PLARGE_INTEGER)&PerfInfo.IdleProcessTime;
    BeginTime = *(PLARGE_INTEGER)&PreviousPerfInfo.IdleProcessTime;

    //
    // Convert from 100 NS to Milliseconds
    //
    EndTime = RtlExtendedLargeIntegerDivide(EndTime, HUNDREDNS_TO_MS, &Remainder);
    BeginTime = RtlExtendedLargeIntegerDivide(BeginTime, HUNDREDNS_TO_MS, &Remainder);

    //
    // Compute elapsed time and percent idle
    //
    ElapsedTime = RtlLargeIntegerSubtract(EndTime,BeginTime);
    PercentIdle = (ElapsedTime.LowPart) / ((POLLING_PRODUCT/100)*PollingPeriod);

    //
    //  Sometimes it takes significantly longer than PollingPeriod
    //  to make a round trip.
    //

    if ( PercentIdle > 100 ) {

        PercentIdle = 100;
    }

    //
    // return cpuusage (100-PercentIdle)
    //
    return 100-PercentIdle;

}

/****************************************************************************

    FUNCTION: IncrementStats (StatType)

    PURPOSE:  Increments the specified stat and writes new data to mttf.dat.

    COMMENTS:

        Increment the specified stat.  For MTTF_TIME, check if it is busy
        or idle by comparing the CpuUsage to IdlePercentage.  If a machine
        is idle for 4 hrs consecutively, first time this is true set the
        IdleConsec stat to the total ConsecIdle value, otherwise set to
        polling period.  (IdleConsec should never exceed Idle.)

        Open mttf.dat.  If opening the server fails (10 times), open the
        local data file.  If server opened and local file also exists,
        open local file also for transfer.

        Search through data file for matching build number, add all values
        and write new record.  (Continue until local file is gone if
        transferring.)

****************************************************************************/
VOID
IncrementStats(
    StatType stattype
    )
{
    HANDLE         fhandle,localHandle;
    StatFileRecord newRec, curRec;
    DWORD          numBytes;
    BOOL           localToServer=FALSE;
    CHAR           buffer[1024];
    int i;

    //
    // Initialize all values to zero
    //
    memset(&newRec, 0, sizeof(newRec));

    newRec.Version=Version;

    //
    // Increment the appropriate stat.
    //
    switch (stattype) {

        //
        // MTTF_TIME stat: Get cpu usage and set idle/busy and percent fields.
        //
        // If idle for more than CONSEC_IDLE_LIMIT, Set IdleConsec.
        // If difference is less than polling period (first time), set to total
        // ConsecIdle; otherwise, just PollingPeriod.
        //
        case MTTF_TIME:
            //
            // Has the CPU been "busy"?
            //
            if ((newRec.PercentTotal=CpuUsage()) > IdlePercentage) {
                //
                // Yes, set busy to polling period and clear ConsecIdle.
                //
                newRec.Busy = PollingPeriod;
                ConsecIdle=0;

            } else {
                //
                // No, not busy, increment consec idle by PollingPeriod.
                // (Set value of idle to polling period.)
                //
                // If ConsecIdle is greater than IDLE_LIMIT, set IdleConsec.
                // If first time, set IdleConsec to ConsecIdle, else PollingPer.
                //
                ConsecIdle+=(newRec.Idle = PollingPeriod);
                if (ConsecIdle>=CONSEC_IDLE_LIMIT) {
                    if (ConsecIdle < CONSEC_IDLE_LIMIT + PollingPeriod) {
                        newRec.IdleConsec=ConsecIdle;
                    } else {
                        newRec.IdleConsec=PollingPeriod;
                    }
                }
            }
            //
            // Weight PercentTotal by number of minutes in polling period.
            //
            newRec.PercentTotal *= PollingPeriod;
            break;

        //
        // MTTF_COLD: Set cold boot count to 1
        //
        case MTTF_COLD:
            newRec.Cold = 1;
            break;
        //
        // MTTF_WARM: Set warm boot count to 1
        //
        case MTTF_WARM:
            newRec.Warm = 1;
            break;
        //
        // MTTF_OTHER: Set other problem count to 1
        //
        case MTTF_OTHER:
            newRec.Other = 1;
            break;
        default:
            ;
    }

    //
    // If there is a ResultsFile name entered in the INI file,
    //
    if (ResultsFile[0]) {

        //
        // Try to open the server file (MAX_RETRIES times).
        //
        for (i=0;i<MAX_RETRIES;i++) {
            if (INVALID_HANDLE_VALUE!=(fhandle = CreateFile(ResultsFile,
                                                 GENERIC_READ|GENERIC_WRITE,
                                                 FILE_SHARE_READ,
                                                 NULL,
                                                 OPEN_ALWAYS,
                                                 FILE_ATTRIBUTE_NORMAL,
                                                 NULL))) {
                break;
            }
            Sleep(500); // wait a half second if it failed.
        }
    } else {
        //
        // If ResultsFile name is blank, set i to MAX_RETRIES to force open
        // of local data file.
        //
        i=MAX_RETRIES;
    }

    //
    // If i is MAX_RETRIES, server file failed to open, so open local file.
    //
    if (i==MAX_RETRIES) {
        if (INVALID_HANDLE_VALUE==(fhandle = CreateFile(LocalFileName,
                                             GENERIC_READ|GENERIC_WRITE,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_ALWAYS,
                                             FILE_ATTRIBUTE_NORMAL,
                                             NULL))) {
            return;
        }
        LocalExists=TRUE;          // Set flag to indicate local file exists
    } else {
        //
        // If the server file opened and the local file exists, open local for
        // transfer (indicated by localToServer).
        //
        if (LocalExists) {
            localToServer=TRUE;
            if (INVALID_HANDLE_VALUE==(localHandle = CreateFile(LocalFileName,
                                                     GENERIC_READ,
                                                     FILE_SHARE_READ,
                                                     NULL,
                                                     OPEN_ALWAYS,
                                                     FILE_ATTRIBUTE_NORMAL,
                                                     NULL))) {
                localToServer=FALSE;
                return;
            }
        }
    }

    //
    // Outer loop is to continue searching in case of transferring local
    // file to server.
    //
    do {
        //
        // Loop through data file until versions match or end of file found.
        //
        while (1) {

            //
            // If ReadFile fails, close files (and send message if internal).
            //
            if (!ReadFile(fhandle, &curRec, sizeof(curRec), &numBytes, NULL)) {

                CloseHandle(fhandle);

                if (localToServer) {
                    CloseHandle(localHandle);
                    DeleteFile(LocalFileName);
                    LocalExists=FALSE;
                }

#ifndef CUSTOMER

                sprintf(buffer,
                       "Mttf error reading %s (error code %ld).\nPlease rename file.",
                       //
                       // If the local file exists and not transferring,
                       // local file is open; otherwise, server file.
                       //
                       (LocalExists & !localToServer ? LocalFileName : ResultsFile),
                       GetLastError());

                MultiByteToWideChar(CP_ACP, MB_COMPOSITE, buffer, sizeof(buffer), UnicodeBuffer, sizeof(UnicodeBuffer)/2);

                NetMessageBufferSend(NULL, UniAlertName, NULL, (LPBYTE)UnicodeBuffer, 2 * strlen(buffer));

#endif

                return;
            }

            //
            // If numBytes is 0, end of file reached; break out of while to
            // add a new record.
            //
            if (numBytes==0) {
                break;
            }

            //
            // If numBytes is not record size, report an error and close files.
            //
            // Reporting is a local message box for customers and a popup internally.
            //
            if (numBytes != sizeof(curRec)) {

#ifdef CUSTOMER

                sprintf(buffer,
                       "Error reading %s (error code %ld).\n\nPlease have "
                       "your administrator rename the file and contact "
                       "Microsoft regarding the Mttf (mean time to failure) "
                       "reporting tool.",
                       //
                       // If the local file exists and not transferring,
                       // local file is open; otherwise, server file.
                       //
                       (LocalExists & !localToServer ? LocalFileName : ResultsFile),
                       GetLastError());


                MessageBox(NULL, buffer, "Read File Error", MB_OK|MB_ICONHAND);

#else

                sprintf(buffer,
                       "Mttf error reading %s (error code %ld).\n(Byte count wrong.) Please rename file.",
                       //
                       // If the local file exists and not transferring,
                       // local file is open; otherwise, server file.
                       //
                       (LocalExists & !localToServer ? LocalFileName : ResultsFile),
                       GetLastError());

                MultiByteToWideChar(CP_ACP, MB_COMPOSITE, buffer, sizeof(buffer), UnicodeBuffer, sizeof(UnicodeBuffer)/2);

                NetMessageBufferSend(NULL, UniAlertName, NULL, (LPBYTE)UnicodeBuffer, 2 * strlen(buffer));

#endif

                CloseHandle(fhandle);

                if (localToServer) {
                    CloseHandle(localHandle);
                    DeleteFile(LocalFileName);
                    LocalExists=FALSE;
                }
                return;
            }

            //
            // If Versions match, increment all other stats, rewind file and
            // break out of while to do write.
            //
            if (curRec.Version==newRec.Version) {
                newRec.Idle         += curRec.Idle;
                newRec.IdleConsec   += curRec.IdleConsec;
                newRec.Busy         += curRec.Busy;
                newRec.PercentTotal += curRec.PercentTotal;
                newRec.Warm         += curRec.Warm;
                newRec.Cold         += curRec.Cold;
                newRec.Other        += curRec.Other;
                SetFilePointer(fhandle, -(LONG)sizeof(curRec), NULL, FILE_CURRENT);
                break;
            }
        }

        //
        // Write newRec at current location (end of file for new record)
        //
        WriteFile(fhandle, &newRec, sizeof(newRec), &numBytes, NULL);

        //
        // if transferring from local to server, read the next record from
        // the local file, rewind data file and loop again until end of
        // (local) file.
        //
        if (localToServer) {
            //
            // If ReadFile fails, close files (and send popup internally)
            //
            if (!ReadFile(localHandle, &newRec, sizeof(curRec), &numBytes, NULL)) {

                CloseHandle(fhandle);
                CloseHandle(localHandle);
                LocalExists=FALSE;
                DeleteFile(LocalFileName);

#ifndef CUSTOMER

                sprintf(buffer,
                       "Mttf error reading %s (error code %ld).\nLocal file access failed...data will be lost.",
                       LocalFileName,
                       GetLastError());

                MultiByteToWideChar(CP_ACP, MB_COMPOSITE, buffer, sizeof(buffer), UnicodeBuffer, sizeof(UnicodeBuffer)/2);

                NetMessageBufferSend(NULL, UniAlertName, NULL, (LPBYTE)UnicodeBuffer, 2 * strlen(buffer));

#endif

                return;

            }

            if (numBytes==0) {
                //
                // Done transferring, close both files, delete local and set
                // LocalExists and localToServer to FALSE.
                //
                CloseHandle(localHandle);
                DeleteFile(LocalFileName);
                LocalExists=localToServer=FALSE;
                CloseHandle(fhandle);
                return;
            }

            //
            // if numBytes is not record size, close files (and send popup internally)
            //
            if (numBytes != sizeof(curRec)) {

#ifndef CUSTOMER

                sprintf(buffer,
                       "Mttf error reading %s (error code %ld).\n(Byte count wrong.) Data will be lost.",
                       LocalFileName,
                       GetLastError());

                MultiByteToWideChar(CP_ACP, MB_COMPOSITE, buffer, sizeof(buffer), UnicodeBuffer, sizeof(UnicodeBuffer)/2);

                NetMessageBufferSend(NULL, UniAlertName, NULL, (LPBYTE)UnicodeBuffer, 2 * strlen(buffer));

#endif

                CloseHandle(fhandle);
                CloseHandle(localHandle);
                DeleteFile(LocalFileName);
                LocalExists=FALSE;
                return;

            }

            SetFilePointer(fhandle,0, NULL, FILE_BEGIN);
        } else {
            //
            // If not transferring, close file and exit
            //
            CloseHandle(fhandle);
            return;
        }
    } while (localToServer);

}

/****************************************************************************

    FUNCTION: CheckAndAddName ( )

    PURPOSE:  Checks name file for machine name and build number at startup.

    COMMENTS:

        Writes various system info to name file if the machine doesn't have
        an entry for this build.  This was an add-on to collect info on how
        many machines were actually running NT.

****************************************************************************/
VOID
CheckAndAddName(
    )
{
    NameFileRecord newRec, curRec;
    HANDLE         fhandle;
    DWORD          numBytes,i,ulLength=MAX_NAME;
    DWORD          dwVersion;
    SYSTEMTIME     sysTime;
    MEMORYSTATUS   memstat;
    SYSTEM_INFO    sysinfo;

    //
    // If the NameFile name is blank, exit
    //
    if (0==NameFile[0]) {
        return;
    }

    //
    // Set record to zero.
    //
    memset(&newRec, 0, sizeof(newRec));

    GetComputerName(newRec.MachineName, &ulLength);

    GetSystemInfo(&sysinfo);                    // Get system info

    switch(sysinfo.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_INTEL:
            newRec.MachineType=X86_CPU;
            break;

        case PROCESSOR_ARCHITECTURE_MIPS:
            newRec.MachineType=MIP_CPU;
            break;

        case PROCESSOR_ARCHITECTURE_ALPHA:
            newRec.MachineType=AXP_CPU;
            break;

        case PROCESSOR_ARCHITECTURE_PPC:
            newRec.MachineType=PPC_CPU;
            break;

        default:
            newRec.MachineType=UNKNOWN_CPU;
            break;
    };

    dwVersion=GetVersion();
    sprintf(newRec.Build, "%3ld", dwVersion>>16);

    memstat.dwLength=sizeof(memstat);
    GlobalMemoryStatus(&memstat);               // Get memory info

    sprintf(newRec.Mem, "%5ldMB",memstat.dwTotalPhys/(1024*1024));

    ulLength=MAX_NAME;

    GetUserName(newRec.UserName, &ulLength);

    GetLocalTime(&sysTime);
    sprintf(newRec.DateAndTime, "%2d/%2d/%4d %2d:%02ld",
            sysTime.wMonth, sysTime.wDay, sysTime.wYear,
            sysTime.wHour, sysTime.wMinute);

    newRec.Tab1=newRec.Tab2=newRec.Tab3=newRec.Tab4=newRec.Tab5=9;
    newRec.CRLF[0]=13;
    newRec.CRLF[1]=10;

    //
    // Try to open NameFile, for shared read access.
    //
    if (INVALID_HANDLE_VALUE==(fhandle = CreateFile(NameFile,
                                         GENERIC_READ,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL))) {
        return;
    }

    //
    // Read each record until a match or end-of-file is encountered.
    //
    while (ReadFile(fhandle, &curRec, sizeof(curRec), &numBytes, NULL)) {
        //
        // At end of file, break out and write new record.
        //
        if (numBytes==0) {
            break;
        }

        //
        // If there is a match, close the file and return.
        //
        if (0==strcmp(curRec.Build, newRec.Build) &&
            0==strcmp(curRec.MachineName, newRec.MachineName)) {
            CloseHandle(fhandle);
            return;
        }
    }
    //
    // Close the name file and try to open it for ExclusiveWrite
    //
    CloseHandle(fhandle);
    for (i=0;i<MAX_RETRIES;i++) {
        if (INVALID_HANDLE_VALUE!=(fhandle = CreateFile(NameFile,
                                             GENERIC_READ|GENERIC_WRITE,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_ALWAYS,
                                             FILE_ATTRIBUTE_NORMAL,
                                             NULL))) {
            break;
        }
        Sleep(500);            // wait if open failed.
    }

    //
    // If open succeeded, go to the end of file and write newRec.
    //
    if (i<MAX_RETRIES) {
        SetFilePointer(fhandle, 0, &numBytes, FILE_END);
        WriteFile(fhandle, &newRec, sizeof(newRec), &numBytes, NULL);
        CloseHandle(fhandle);
    }
}


/****************************************************************************

    FUNCTION: SignonDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for signon dialog.

    COMMENTS: The signon dialog

        WM_INITDIALOG: Checks machine name in name file and sets focus.

        WM_COMMAND:    Process the button press:
            IDOK:      Get input values and check for validity.
            IDCANCEL:  Kill the app.
            IDB_HELP:  Descriptive message box

****************************************************************************/
INT_PTR
SignonDlgProc(
              HWND hDlg,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    switch (message)
    {
        case WM_INITDIALOG:   // Checks machinename in namefile and sets focus

            CheckAndAddName();

            CheckRadioButton(hDlg, IDS_NORMAL, IDS_COLD, IDS_NORMAL);
            return (TRUE);

        case WM_COMMAND:        // command: button pressed

            switch (wParam)     // which button
            {
            //
            // OK: Update the appropriate stat if not "Normal Boot"
            //
            case IDOK:
            case IDCANCEL:

                if (IsDlgButtonChecked(hDlg, IDS_WARM)) {
                    IncrementStats(MTTF_WARM);
                } else {
                    if (IsDlgButtonChecked(hDlg, IDS_COLD)) {
                        IncrementStats(MTTF_COLD);
                    }
                }
                EndDialog(hDlg, TRUE);
                return (TRUE);

            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "Mttf tracks the amount of time your machine stays up, "
                            "the number of cold and warm boots, and "
                            "the number of other problems that occur on your machine. "
                            "All this information is written to a server that is "
                            "specified in mttf.ini (in your Windows NT directory).\n\n"
                            "The app should be placed in your start-up group and "
                            "you should respond accurately (if there was a problem) "
                            "on startup.  When you encounter other problems -- where "
                            "the system did not require a reboot, but encountered "
                            "anything you consider a problem -- double-click on the "
                            "Mttf icon and press the Other Problem button.\n\n"
                            "When you are running some test that is outside of the "
                            "realm of normal usage (e.g. Stress), please disable Mttf "
                            "by double-clicking the icon and pressing disable.  When "
                            "you are done with this test, please press the Enable "
                            "button to continue reporting.",
                            "Mean Time to Failure Help",
                            MB_OK
                           );
                return (TRUE);

            default:
                break;
            } // switch (wParam)
            break;
       default:
             break;
    } // switch (message)
    return (FALSE);     // Didn't process a message
} // SignonDlgProc()

/****************************************************************************

    FUNCTION: EventDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Processes timer and button events (disable and other problems).

    COMMENTS: Processes the following messages:

        WM_INITDIALOG: Minimize dialog and start timer
        WM_CLOSE...:   End app
        WM_TIMER:      Update Time stat (busy or idle)

        WM_COMMAND:    Process the button press:
            IDOK:        Log Other problem (and minimize).
            IDCANCEL:    Minimize without action.
            IDE_DISABLE: Disable or enable mttf reporting.
            IDB_HELP:    Descriptive message box.


****************************************************************************/
INT_PTR
EventDlgProc(
     HWND hDlg,
     UINT message,
     WPARAM wParam,
     LPARAM lParam
     )
{
    switch (message)
    {
        case WM_INITDIALOG:     // minimize and start timer

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)LoadIcon(hInst,"mttf"));
            SendMessage(hDlg, WM_SYSCOMMAND, SC_ICON, 0);
            SetTimer(hDlg, 1, POLLING_PRODUCT*PollingPeriod, NULL);
            break;

        case WM_CLOSE:
        case WM_DESTROY:
        case WM_ENDSESSION:
        case WM_QUIT:

            EndDialog(hDlg,0);
            break;

        case WM_TIMER:
            IncrementStats(MTTF_TIME);
            break;

        case WM_COMMAND:           // button was pressed
            switch(LOWORD(wParam)) // which one
            {
            //
            // OK: Other problem encountered increment # of others.
            //
            case IDOK:

                SendMessage(hDlg, WM_SYSCOMMAND, SC_ICON, 0);

                IncrementStats(MTTF_OTHER);
                break;

            //
            // DISABLE: Disable/Enable Mttf polling.
            //
            case IDE_DISABLE:

                SendMessage(hDlg, WM_SYSCOMMAND, SC_ICON, 0);

                //
                // Based on whether enabling or disabling, change button and window title
                //
                if (Enabled) {
                    SetWindowText((HWND) lParam,"&Enable Mttf Reporting");
                    SetWindowText(hDlg, "Mttf (Disabled)");
                    KillTimer(hDlg, 1);
                    Enabled = FALSE;
                } else {
                    SetWindowText((HWND) lParam,"&Disable Mttf Reporting");
                    SetWindowText(hDlg, "Mttf (Enabled)");
                    SetTimer(hDlg, 1, POLLING_PRODUCT*PollingPeriod, NULL);
                    NtQuerySystemInformation(
                        SystemPerformanceInformation,
                        &PerfInfo,
                        sizeof(PerfInfo),
                        NULL
                        );
                    Enabled = TRUE;
                }

                break;

            //
            // CANCEL: Minimize app (no problem)
            //
            case IDCANCEL:

                SendMessage(hDlg, WM_SYSCOMMAND, SC_ICON, 0);
                return (TRUE);


            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "Mttf tracks the amount of time your machine stays up, "
                            "the number of cold and warm boots, and "
                            "the number of other problems that occur on your machine. "
                            "All this information is written to a server that is "
                            "specified in mttf.ini (in your Windows NT directory).\n\n"
                            "The app should be placed in your start-up group and "
                            "you should respond accurately (if there was a problem) "
                            "on startup.  When you encounter other problems -- where "
                            "the system did not require a reboot, but encountered "
                            "anything you consider a problem -- double-click on the "
                            "Mttf icon and press the Other Problem button.\n\n"
                            "When you are running some test that is outside of the "
                            "realm of normal usage (e.g. Stress), please disable Mttf "
                            "by double-clicking the icon and pressing disable.  When "
                            "you are done with this test, please press the Enable "
                            "button to continue reporting.",
                            "Mean Time to Failure Help",
                            MB_OK
                           );
                return (TRUE);

            default:
               ;
            } // switch (LOWORD(wParam))

            break;

        default:
            ;
    } // switch (message)
    return FALSE;

} // EventDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\getmttf.c ===
/****************************************************************************

    PROGRAM: getmttf.c

    AUTHOR:  Lars Opstad (LarsOp) 3/18/93

    PURPOSE: Setup for NT Mean-time-to-failure reporting tool.

    FUNCTIONS:

        WinMain() - parse command line and starts each dialog box
        FrameWndProc() - processes messages
        About() - processes messages for "About" dialog box

    COMMENTS:

        This program displays 2 dialog boxes to prompt the user for
        who he/she is and what tests to run.  It then starts tests
        (in INIIO.c) and registers with a server (in CLIENT.c).

****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "setup.h"      /* specific to this program */

#define IniFileName "Mttf.ini"
#define MTTFEXE "Mttf.exe"
#define MTTFVWR "Mttfvwr.exe"

#ifdef MIPS
#define DEFAULT_PATH       "a:\\"
#else
#define DEFAULT_PATH       "a:\\"
#endif

#define DEFAULT_MTTF_FILE  "\\\\server\\share\\mttf.dat"
#define DEFAULT_NAMES_FILE "\\\\server\\share\\names.dat"
#define DEFAULT_IDLE_LIMIT 10
#define DEFAULT_386_IDLE_LIMIT 15
#define DEFAULT_POLLING_PERIOD 15
#define MAX_POLLING_PERIOD 60

HANDLE hInst;       // current instance
DWORD  PollingPeriod;
DWORD  IdlePercentage;
char   SetupDir[MAX_DIR];
char   ResultsFile[MAX_DIR],NameFile[MAX_DIR];
char   Path[MAX_DIR];
char   SysDir[MAX_DIR],
       Buf1[MAX_DIR],
       Buf2[MAX_DIR];


/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE:  Checks command args then displays dialogs

    COMMENTS:

        Parse the command arguments.
        If the user hasn't specified name, office and dir,
            display signon dialog.
        Display test selection dialog.

****************************************************************************/

int WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    SYSTEM_INFO sysinfo;
    char Buffer[MAX_DIR],
         WinDir[MAX_DIR],
         *EndOfPath;
    INT_PTR dlgRet=FALSE;
    CMO  cmo=cmoVital;

    hInst = hInstance;

    //
    // Get directory EXE was run from.
    //
    GetModuleFileName(NULL, SetupDir, sizeof(SetupDir));

    //
    // Strip off exe name to use as default dir to get files from.
    // Might be a:\, b:\ or \\srv\share\
    //
    _strlwr(SetupDir);
    if (EndOfPath=strstr(SetupDir,"getmttf.exe")) {
        *EndOfPath=0;
    }

    FInitProgManDde(hInst);

    GetSystemInfo(&sysinfo);                    // Get system info

    //
    // if the processortype is 386, set idle percent to 386 limit.
    //
    if (sysinfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
        sysinfo.wProcessorLevel < 4
       ) {
        IdlePercentage = DEFAULT_386_IDLE_LIMIT;
    } else {
        IdlePercentage = DEFAULT_IDLE_LIMIT;
    }
    GetSystemDirectory(SysDir, MAX_DIR);

    //
    // Try to copy the EXEs
    //
    MakeFileName(Buf1, SetupDir,MTTFEXE);
    MakeFileName(Buf2, SysDir,  MTTFEXE);

    if (CopyFile(Buf1, Buf2, FALSE)) {

        MakeFileName(Buf1, SetupDir, MTTFVWR);
        MakeFileName(Buf2, SysDir,   MTTFVWR);

        if (CopyFile(Buf1, Buf2, FALSE)) {

            MakeFileName(Buf1, SetupDir, IniFileName);
            ReadIniFile(Buf1);
            dlgRet=TRUE;            // If both EXEs copy, set flag to not show signon
        }
    }


    //
    // Only display the dialog if one of the EXEs didn't copy from default dir.
    //
    if (!dlgRet) {
        //
        // Display signon dlg
        //
        dlgRet = DialogBox(hInstance, (LPCSTR)IDD_SIGNON, NULL, SignonDlgProc);
    }

    if (dlgRet) {
        //
        // Display test selection dialog
        //
        dlgRet = DialogBox(hInstance, (LPCSTR)IDD_VALUES, NULL, ValuesDlgProc);

        if (!dlgRet) {
            goto AbortApp;
        }
        GetWindowsDirectory(WinDir, MAX_DIR);
        MakeFileName(Buffer, WinDir, IniFileName);

        WriteIniFile(Buffer);

        FCreateProgManGroup("Startup", "", cmo, TRUE);
        FCreateProgManItem("Startup", "Mttf", "Mttf.Exe", "", 0, cmo, FALSE);

        if (ResultsFile[0]) {
            sprintf(Buffer, "cmd /k Mttfvwr %s", ResultsFile);
        } else {
            sprintf(Buffer, "cmd /k mttfvwr c:\\mttf.ini");
        }

        FCreateProgManGroup("Main", "", cmo, FALSE);
        FCreateProgManItem("Main", "Mttf Viewer", Buffer, "", 0, cmo, FALSE);

        MessageBox(NULL,
                   "If you are not an Administrator and often log on to this "
                   "machine with a different username, please add mttf.exe to "
                   "the startup group for each user.\n\n"
                   "The following are the keys to valid mttf numbers:\n\n"
                   "1. Answer prompts correctly for warm/cold boot problems\n"
                   "2. Report \"Other\" problems by double-clicking the app\n"
                   "3. Disable while performing unusual tests (such as stress)\n"
                   "4. Install Mttf as soon as possible after upgrading.\n\n"
                   "Setup is now complete. Please go to ProgMan and start Mttf.",
                   "Mttf Setup Complete",
                   MB_OK|MB_ICONINFORMATION);

    } else {
AbortApp:
        MessageBox(NULL,
                   "Mttf setup did NOT install correctly.  Please rerun setup.",
                   "Mttf Setup Failed",
                   MB_OK|MB_ICONHAND);
    }

    return 0;

} // WinMain()

VOID
WriteIniFile (
    char *filename
    )
{
    char Buffer[MAX_DIR];

    WritePrivateProfileString("Mttf", "ResultsFile", ResultsFile, filename);
    WritePrivateProfileString("Mttf", "NameFile", NameFile, filename);
    sprintf(Buffer, "%ld", PollingPeriod);
    WritePrivateProfileString("Mttf", "PollingPeriod", Buffer, filename);
    sprintf(Buffer, "%ld", IdlePercentage);
    WritePrivateProfileString("Mttf", "IdlePercent", Buffer, filename);
}

VOID
ReadIniFile (
    char *filename
    )
{
    GetPrivateProfileString("Mttf",
                            "NameFile",
                            DEFAULT_NAMES_FILE,
                            NameFile,
                            MAX_DIR,
                            filename);

    GetPrivateProfileString("Mttf",
                            "ResultsFile",
                            DEFAULT_MTTF_FILE,
                            ResultsFile,
                            MAX_DIR,
                            filename);

    PollingPeriod = GetPrivateProfileInt("Mttf",
                                         "PollingPeriod",
                                         DEFAULT_POLLING_PERIOD,
                                         filename);

    IdlePercentage = GetPrivateProfileInt("Mttf",
                                          "IdlePercent",
                                          IdlePercentage,
                                          filename);

}

VOID
MakeFileName (
    char *DestBuffer,
    char *Path,
    char *FileName
    )
{
    DWORD len;
    char ch;

    len=strlen(Path);
    ch=(len?Path[len-1]:':');

    switch (ch) {
        case ':':
        case '\\':

            sprintf(DestBuffer, "%s%s", Path, FileName);
            break;

        default:
            sprintf(DestBuffer, "%s\\%s", Path, FileName);
    }
}

/****************************************************************************

    FUNCTION: SignonDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for signon dialog.

    COMMENTS: The signon dialog gets important information for locating
              machine and owner when tracking down problems.

        WM_INITDIALOG: Set default values and focus for input variables

        WM_COMMAND:    Process the button press:
            IDOK:      Get input values and check for validity.
            IDCANCEL:  Kill the app.
            IDB_HELP:  Descriptive message box

****************************************************************************/
INT_PTR
SignonDlgProc(
              HWND hDlg,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    switch (message)
    {
        case WM_INITDIALOG:     // initialize values and focus

            SetDlgItemText(hDlg, IDS_PATH, SetupDir);
            return (TRUE);

        case WM_COMMAND:        // command: button pressed

            switch (wParam)     // which button
            {
            //
            // OK: Get and check the input values and try to copy exes
            //
            case IDOK:

                GetDlgItemText(hDlg, IDS_PATH, Path, MAX_DIR);

                MakeFileName(Buf1,Path,MTTFEXE);
                MakeFileName(Buf2,SysDir, MTTFEXE);

                if (!CopyFile(Buf1, Buf2, FALSE)) {
                    sprintf(Buf1, "Error copying %s from %s to %s (%ld).  Please reenter source path.",
                            MTTFEXE, Path, SysDir, GetLastError());
                    MessageBox(NULL,
                               Buf1,
                               "Error Copying",
                               MB_OK|MB_ICONHAND);

                    return (FALSE);
                }

                MakeFileName(Buf1, Path, MTTFVWR);
                MakeFileName(Buf2, SysDir, MTTFVWR);

                if (!CopyFile(Buf1, Buf2, FALSE)) {
                    sprintf(Buf1, "Error copying %s from %s to %s (%ld).  Please reenter source path.",
                            MTTFVWR, Path, SysDir, GetLastError());
                    if (IDRETRY==MessageBox(NULL,
                               Buf1,
                               "Error Copying",
                               MB_RETRYCANCEL|MB_ICONHAND)) {
                        return (FALSE);
                    }
                }

                MakeFileName(Buf1,Path,IniFileName);
                ReadIniFile(Buf1);

                EndDialog(hDlg, TRUE);
                return (TRUE);

            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                return (TRUE);


            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "Mttf tracks the amount of time your machine stays up, "
                            "the number of cold and warm boots, and "
                            "the number of other problems that occur on your machine. "
                            "All this information is written to a server that is "
                            "specified in mttf.ini (in your Windows NT directory).\n\n"
                            "This part of setup requests the path to the distribution "
                            "files for Mttf.  This may be a:\\, a server (\\\\srv\\shr) or "
                            "any other valid specification.  If Mttf.exe can not be "
                            "copied, setup reprompts for a path.  If MttfVwr.exe can "
                            "not be copied, a warning is displayed that can be ignored "
                            "or retried.",
                            "Mean Time to Failure Setup Help",
                            MB_OK
                           );
                return (TRUE);

            default:
                break;
            } // switch (wParam)
            break;
       default:
             break;
    } // switch (message)
    return (FALSE);     // Didn't process a message
} // SignonDlgProc()

/****************************************************************************

    FUNCTION: ValuesDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for test selection dialog.

    COMMENTS: Test selection dialog allows user to add and remove tests
              before and after starting stress.

        WM_INITDIALOG: Set default values and focus for input variables
        WM_CLOSE...:   Send Shutdown message to server for any legal shutdown

        WM_COMMAND:    Process the button/listbox press:
            IDOK:      Get input values and check for validity.
            IDCANCEL:  Kill the app.
            IDB_HELP:  Descriptive message box
            IDT_SAVE:  Prompt for groupname and save selection to ini file
            IDT_ADD:   Add highlighted tests to selected list (remove from poss)
            IDT_REMOVE:Remove highlighted tests from selected list (add to poss)
            IDT_LABEL...: For labels, set selection to corresponding list/combo
            IDT_SEL:   Perform operation depending on action on selected listbox
                LBN_SELCHANGE: Activate Remove button and clear Poss highlights
                LBN_DBLCLK:    Get number of instances for the selected test
            IDT_POSS:  Perform operation depending on action on possible listbox
                LBN_SELCHANGE: Activate Add button and clear selected highlights
                LBN_DBLCLK:    Add highlighted test (simulate press to Add button)
            IDT_GROUP: Change to new group.


****************************************************************************/
INT_PTR
ValuesDlgProc(
     HWND hDlg,
     UINT message,
     WPARAM wParam,
     LPARAM lParam
     )
{
    static DWORD defPP;
    BOOL Translated;
    CHAR Buffer[MAX_DIR];
    HFILE hfile;
    OFSTRUCT ofstruct;

    switch (message)
    {
        case WM_INITDIALOG:     // initialize values and focus

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)LoadIcon(hInst,"setup"));
            SetDlgItemText(hDlg, IDV_MTTF, ResultsFile);
            SetDlgItemText(hDlg, IDV_NAMES, NameFile);
            SetDlgItemInt(hDlg, IDV_PERIOD, PollingPeriod, FALSE);
            defPP=PollingPeriod;
            return TRUE;

        case WM_CLOSE:
        case WM_DESTROY:
        case WM_ENDSESSION:
        case WM_QUIT:

            EndDialog(hDlg,FALSE);
            break;

        case WM_COMMAND:           // something happened (button, listbox, combo)
            switch(LOWORD(wParam)) // which one
            {
            //
            // OK: Other problem encountered increment # of others.
            //
            case IDOK:

                GetDlgItemText(hDlg, IDV_MTTF, ResultsFile, MAX_DIR);

                if (HFILE_ERROR==OpenFile(ResultsFile, &ofstruct, OF_EXIST|OF_SHARE_DENY_NONE)) {
                    if (HFILE_ERROR==(hfile=OpenFile(ResultsFile, &ofstruct, OF_CREATE|OF_SHARE_DENY_NONE))) {
                        if (IDRETRY==MessageBox(NULL,
                                     "File does not exist and cannot create file.\n\n"
                                     "Press Retry to reenter filename\n"
                                     "Press Cancel to use filename anyway",
                                     "Invalid file name",
                                     MB_ICONHAND|MB_RETRYCANCEL)) {
                            SetFocus(GetDlgItem(hDlg, IDV_MTTF));
                            return FALSE;
                        }
                    } else {
                        _lclose(hfile);
                    }
                }

                GetDlgItemText(hDlg, IDV_NAMES, NameFile, MAX_DIR);
                if (HFILE_ERROR==OpenFile(NameFile, &ofstruct, OF_EXIST|OF_SHARE_DENY_NONE)) {
                    if (HFILE_ERROR==(hfile=OpenFile(NameFile, &ofstruct, OF_CREATE|OF_SHARE_DENY_NONE))) {
                        if (IDRETRY==MessageBox(NULL,
                                     "File does not exist and cannot create file.\n\n"
                                     "Press Retry to reenter or Cancel to use filename anyway.",
                                     "Invalid file name",
                                     MB_RETRYCANCEL)) {
                            SetFocus(GetDlgItem(hDlg, IDV_NAMES));
                            return FALSE;
                        }
                    } else {
                        _lclose(hfile);
                    }
                }

                PollingPeriod = GetDlgItemInt(hDlg, IDV_PERIOD, &Translated, FALSE);
                if (PollingPeriod<=0 || PollingPeriod > MAX_POLLING_PERIOD) {

                    sprintf(Buffer,
                            "Polling period must be in the range [1, %d] (default %d)",
                            MAX_POLLING_PERIOD,
                            defPP);

                    MessageBox(NULL,
                               Buffer,
                               "Invalid Polling Period",
                               MB_OK|MB_ICONHAND);

                    SetDlgItemInt(hDlg, IDV_PERIOD, defPP, FALSE);
                    SetFocus(GetDlgItem(hDlg, IDV_PERIOD));
                    return (FALSE);
                }
                EndDialog(hDlg, TRUE);
                break;

            //
            // CANCEL: Dismiss dialog (use defaults)
            //
            case IDCANCEL:
                EndDialog(hDlg,FALSE);
                break;

            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "Mttf tracks the amount of time your machine stays up, "
                            "the number of cold and warm boots, and "
                            "the number of other problems that occur on your machine. "
                            "All this information is written to a server that is "
                            "specified in mttf.ini (in your Windows NT directory).\n\n"
                            "This part of setup requests the server paths for the data "
                            "files for Mttf.  The Mttf data file contains the time and "
                            "cpu usage data for all machines pointing to this server. "
                            "The Names file is just a list of all machines running mttf. "
                            "These files should both be in UNC (\\\\srv\\shr) format.\n\n"
                            "If your machine is not on the network where your mttf data "
                            "file (or names file) is, just leave these fields blank and "
                            "a small mttf.dat will be kept in the root of your c: drive. "
                            "Send this in when results are requested.\n\n"
                            "The other entry here is for the period (in minutes) that data "
                            "will be sent to the server.  More machines running to one "
                            "server would mean a higher polling period would be helpful. "
                            "Between 10 and 30 minutes seems optimal.",
                            "Mean Time to Failure Setup Help",
                            MB_OK
                           );
                return (TRUE);

            case IDV_LABEL_MTTF:
            case IDV_LABEL_NAMES:
            case IDV_LABEL_PERIOD:
                SetFocus(GetDlgItem(hDlg,1+LOWORD(wParam)));
                break;
            default:
               ;
            } // switch (LOWORD(wParam))

            break;

        default:
            ;
    } // switch (message)
    return FALSE;

} // EventDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\install.h ===
/* File: install.h */
/**************************************************************************/
/*	Install: Install Component Public Include File
/**************************************************************************/

#ifndef __install_
#define __install_

_dt_system(Install)

typedef BOOL (APIENTRY *PFNSF)(SZ, SZ);
// Function pointer for {Backup|Remove}SectionFiles
typedef BOOL (APIENTRY *PFNSKF)(SZ, SZ, SZ);
// Function pointer for {Backup|Remove}SectionKeyFile
typedef BOOL (APIENTRY *PFNSNF)(SZ, UINT, SZ);
// Function pointer for {Backup|Remove}SectionNthFile
typedef BOOL (APIENTRY *PFND)(SZ, BYTE);


extern BOOL APIENTRY FInstallEntryPoint(HANDLE, HWND, RGSZ, UINT);
extern BOOL APIENTRY FInstRemoveableDrive(CHP);
extern BOOL APIENTRY FPromptForDisk(HANDLE, SZ, SZ);
extern BOOL APIENTRY FFileFound(SZ);
extern BOOL APIENTRY FCopy(SZ, SZ, OEF, OWM, BOOL, int, USHORT, PSDLE);
extern BOOL APIENTRY FDiskReady(SZ, DID);

/* REVIEW these should be in a private H file */
extern BOOL APIENTRY FGetArgSz(INT Line,UINT *NumFields,SZ *ArgReturn);
extern BOOL APIENTRY FGetArgUINT(INT, UINT *, UINT *);
extern BOOL APIENTRY FParseSectionFiles(INT, UINT *, PFNSF);
extern BOOL APIENTRY FParseSectionKeyFile(INT, UINT *, PFNSKF);
extern BOOL APIENTRY FParseSectionNFile(INT, UINT *, PFNSNF);
extern BOOL APIENTRY FParseCopySection(INT, UINT *);
extern BOOL APIENTRY FParseCopySectionKey(INT, UINT *);
extern BOOL APIENTRY FParseCopyNthSection(INT, UINT *);
extern BOOL APIENTRY FParseDirectory(INT, UINT *, PFND);
extern BOOL APIENTRY FParseCreateIniSection(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseReplaceIniSection(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseRemoveIniSection(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseCreateIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseCreateIniKeyNoValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseReplaceIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseAppendIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseRemoveIniKey(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseIniSection(INT, UINT *, SPC);
extern BOOL APIENTRY FParseSetEnv(INT, UINT *);
#ifdef UNUSED
extern BOOL APIENTRY FParseAddMsgToSystemHelpFile(INT, UINT *);
extern BOOL APIENTRY FParseStampFile(INT, UINT *);
extern BOOL APIENTRY FUndoActions(void);
#endif /* UNUSED */
extern BOOL APIENTRY FParseStampResource(INT, UINT *);
extern BOOL APIENTRY FInitParsingTables(void);
extern BOOL APIENTRY FParseInstallSection(HANDLE hInstance, SZ szSection);
extern SZ   APIENTRY SzGetSrcDollar(SZ);
extern BOOL APIENTRY FDdeTerminate(void);
extern LONG_PTR APIENTRY WndProcDde(HWND, UINT, WPARAM, LPARAM);
extern BOOL APIENTRY FDdeInit(HANDLE);
extern VOID APIENTRY DdeSendConnect(ATOM, ATOM);
extern BOOL APIENTRY FDdeConnect(SZ, SZ);
extern BOOL APIENTRY FDdeWait(void);
extern BOOL APIENTRY FDdeExec(SZ);
extern BOOL APIENTRY FActivateProgMan(void);
extern INT  APIENTRY EncryptCDData(UCHAR *, UCHAR *, UCHAR *, INT, INT, INT, UCHAR *);
extern BOOL APIENTRY FParseCloseSystem(INT, UINT *);
extern BOOL APIENTRY FParseCreateSysIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseSearchDirList(INT, UINT *);
extern BOOL APIENTRY FParseSetupDOSAppsList(INT, UINT *);
extern BOOL APIENTRY FParseRunExternalProgram(INT, UINT *);
extern BOOL APIENTRY FStrToDate(SZ, PUSHORT, PUSHORT, PUSHORT);

extern BOOL APIENTRY FParseAddDos5Help(INT, USHORT *);
extern USHORT APIENTRY DateFromSz(SZ);
extern BOOL APIENTRY FConvertAndStoreRglInSymTab(PLONG_STF, SZ, INT);


extern BOOL APIENTRY FSearchDirList( SZ, SZ, BOOL, BOOL, SZ, SZ, SZ, SZ );
extern BOOL APIENTRY FInstallDOSPifs( SZ, SZ, SZ, SZ, SZ, SZ );






_dt_public
#define INSTALL_OUTCOME   "STF_INSTALL_OUTCOME"
_dt_public
#define SUCCESS           "STF_SUCCESS"
_dt_public
#define FAILURE           "STF_FAILURE"
_dt_public
#define USERQUIT          "STF_USERQUIT"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\setup.h ===
#include "setupdef.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "comstf.h"
#include "install.h"
#include "uilstf.h"
#include "cmnds.h"
#include "dospif.h"

//_dt_system(Install)
//_dt_subsystem(ProgMan Operations)

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );


#define MAX_DIR     128
#define MAX_NAME    16
#define MAX_BUILD_W 4
#define MAX_MEM_W   8
#define MAX_DATETIME 20



_dt_private BOOL APIENTRY FDdeInit(HANDLE hInst);
_dt_private BOOL APIENTRY FCreateProgManItem(SZ szGroup, SZ szItem, SZ szCmd, SZ szIconFile, INT nIconNum, CMO cmo, BOOL CommonGroup);
VOID MakeFileName(char *Buffer, char *Path, char *FileName);
VOID ReadIniFile(char * filename);
VOID WriteIniFile(char * filename);
INT_PTR SignonDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR ValuesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\uilstf.h ===
/***************************************************************************/
/***********************  include file for UI Library  *********************/
/***************************************************************************/

#ifndef __uilstf_
#define __uilstf_

_dt_system(User Interface Library)
_dt_subsystem(General Dialog Handling)

_dt_public
#define STF_MESSAGE               (WM_USER + 0x8000)

/*
**	Window Messages
*/
_dt_public
#define STF_UI_EVENT              (STF_MESSAGE)
_dt_public
#define STF_DESTROY_DLG           (STF_MESSAGE + 1)
_dt_public
#define STF_HELP_DLG_DESTROYED    (STF_MESSAGE + 2)
_dt_public
#define STF_INFO_DLG_DESTROYED    (STF_MESSAGE + 3)
_dt_public
#define STF_EDIT_DLG_DESTROYED    (STF_MESSAGE + 4)
_dt_public
#define STF_RADIO_DLG_DESTROYED   (STF_MESSAGE + 5)
_dt_public
#define STF_CHECK_DLG_DESTROYED   (STF_MESSAGE + 6)
_dt_public
#define STF_LIST_DLG_DESTROYED    (STF_MESSAGE + 7)
_dt_public
#define STF_MULTI_DLG_DESTROYED   (STF_MESSAGE + 8)
_dt_public
#define STF_QUIT_DLG_DESTROYED    (STF_MESSAGE + 9)
_dt_public
#define STF_DLG_ACTIVATE          (STF_MESSAGE + 10)
_dt_public
#define STF_UILIB_ACTIVATE        (STF_MESSAGE + 11)
_dt_public
#define STF_REINITDIALOG          (STF_MESSAGE + 12)
_dt_public
#define STF_SHL_INTERP            (STF_MESSAGE + 13)
_dt_hidden
#define STF_COMBO_DLG_DESTROYED   (STF_MESSAGE + 14)
_dt_hidden
#define STF_MULTICOMBO_DLG_DESTROYED (STF_MESSAGE + 15)
_dt_hidden
#define STF_DUAL_DLG_DESTROYED    (STF_MESSAGE + 16)
_dt_hidden
#define STF_MULTICOMBO_RADIO_DLG_DESTROYED (STF_MESSAGE + 17)
_dt_hidden
#define STF_MAINT_DLG_DESTROYED   (STF_MESSAGE + 18)


_dt_hidden
#define STF_SET_INSTRUCTION_TEXT  (STF_MESSAGE + 0x100)

_dt_hidden
#define STF_SET_HELP_CONTEXT      (STF_MESSAGE + 0x101)

_dt_hidden
#define STF_ENABLE_EXIT_BUTTON    (STF_MESSAGE + 0x102)

_dt_hidden
#define STF_ERROR_ABORT           (STF_MESSAGE + 0x103)

#include <setupxrc.h>

#if !defined(STF_SET_INSTRUCTION_TEXT_RC) || (STF_SET_INSTRUCTION_TEXT_RC != STF_MESSAGE + 0x104)
#error STF_SET_INSTRUCTION_TEXT_RC has changed!
#endif


//
// Button IDS to communicate help and exit button messages to shell
//
#define ID_EXITBUTTON       7
#define ID_HELPBUTTON       8


/*
**	Symbols used by Basic Dialog Class procedures
*/

#define CLS_MYDLGS          "mydlg"
#define DLGTEXT             "DlgText"
#define DLGCAPTION          "Caption"
#define DLGTYPE             "DlgType"
#define DLGTEMPLATE         "DlgTemplate"



#define INSTRUCTIONTEXT     "InstructionText"
#define HELPCONTEXT         "HelpContext"
#define EXITSTATE			"ExitState"

#define EXIT_ENABLE			 "Active"
#define EXIT_DISABLE		 "Inactive"


/*
**	PushButton Control IDs
*/
_dt_public
#define IDC_A        401
_dt_public
#define IDC_B        402
_dt_public
#define IDC_C        403
_dt_public
#define IDC_D        404
_dt_public
#define IDC_E        405
_dt_public
#define IDC_F        406
_dt_public
#define IDC_G        407
_dt_public
#define IDC_H        408
_dt_public
#define IDC_I        409
_dt_public
#define IDC_J        410
_dt_public
#define IDC_K        411
_dt_public
#define IDC_L        412
_dt_public
#define IDC_M        413
_dt_public
#define IDC_N        414
_dt_public
#define IDC_O        415
_dt_public
#define IDC_P        416
_dt_public
#define IDC_Q        417
_dt_public
#define IDC_R        418
_dt_public
#define IDC_S        419
_dt_public
#define IDC_T        420
_dt_public
#define IDC_U        421
_dt_public
#define IDC_V        422
_dt_public
#define IDC_W        423
_dt_public
#define IDC_X        424
_dt_public
#define IDC_Y        425
_dt_public
#define IDC_Z        426


/*
**	Text Control IDs
*/
_dt_public
#define IDC_TEXT1    431
_dt_public
#define IDC_TEXT2    432
_dt_public
#define IDC_TEXT3    433
_dt_public
#define IDC_TEXT4    434
_dt_public
#define IDC_TEXT5    435
_dt_public
#define IDC_TEXT6    436
_dt_public
#define IDC_TEXT7    437
_dt_public
#define IDC_TEXT8    438
_dt_public
#define IDC_TEXT9    439
_dt_public
#define IDC_TEXT10   440
_dt_public
#define IDC_TEXT11   441


/*
**	Radio and Checkbox Button Control IDs
*/
_dt_public
#define IDC_B0       450
_dt_public
#define IDC_B1       451
_dt_public
#define IDC_B2       452
_dt_public
#define IDC_B3       453
_dt_public
#define IDC_B4       454
_dt_public
#define IDC_B5       455
_dt_public
#define IDC_B6       456
_dt_public
#define IDC_B7       457
_dt_public
#define IDC_B8       458
_dt_public
#define IDC_B9       459
_dt_public
#define IDC_B10      460

_dt_public
#define IDC_RB0       610
_dt_public
#define IDC_RB1       611
_dt_public
#define IDC_RB2       612
_dt_public
#define IDC_RB3       613
_dt_public
#define IDC_RB4       614
_dt_public
#define IDC_RB5       615
_dt_public
#define IDC_RB6       616
_dt_public
#define IDC_RB7       617
_dt_public
#define IDC_RB8       618
_dt_public
#define IDC_RB9       619
_dt_public
#define IDC_RB10      620

/*
**  Generic Dialog Button IDs
*/

_dt_public
#define IDC_BTN0		630
_dt_public
#define IDC_BTN1		631
_dt_public
#define IDC_BTN2		632
_dt_public
#define IDC_BTN3		633
_dt_public
#define IDC_BTN4		634
_dt_public
#define IDC_BTN5		635
_dt_public
#define IDC_BTN6		636
_dt_public
#define IDC_BTN7		637
_dt_public
#define IDC_BTN8		638
_dt_public
#define IDC_BTN9		639


/*
**	Combo box IDs
*/
_dt_public
#define IDC_COMBO0   480
_dt_public
#define IDC_COMBO1   481
_dt_public
#define IDC_COMBO2   482
_dt_public
#define IDC_COMBO3   483
_dt_public
#define IDC_COMBO4   484
_dt_public
#define IDC_COMBO5   485
_dt_public
#define IDC_COMBO6   486
_dt_public
#define IDC_COMBO7   487
_dt_public
#define IDC_COMBO8   488
_dt_public
#define IDC_COMBO9   489

/*
**	ICON IDs
*/
_dt_public
#define IDC_ICON0    500
_dt_public
#define IDC_ICON1    501
_dt_public
#define IDC_ICON2    502
_dt_public
#define IDC_ICON3    503
_dt_public
#define IDC_ICON4    504
_dt_public
#define IDC_ICON5    505
_dt_public
#define IDC_ICON6    506
_dt_public
#define IDC_ICON7    507
_dt_public
#define IDC_ICON8    508
_dt_public
#define IDC_ICON9    509

/*
** SPECIAL PUSHBUTTONS
*/

_dt_public
#define IDC_SP1    521
_dt_public
#define IDC_SP2    522
_dt_public
#define IDC_SP3    523
_dt_public
#define IDC_SP4    524
_dt_public
#define IDC_SP5    525
_dt_public
#define IDC_SP6    526
_dt_public
#define IDC_SP7    527
_dt_public
#define IDC_SP8    528
_dt_public
#define IDC_SP9    529
_dt_public
#define IDC_SP10   530

/*
** STATUS TEXT FIELDS
*/

_dt_public
#define IDC_STATUS1    541
_dt_public
#define IDC_STATUS2    542
_dt_public
#define IDC_STATUS3    543
_dt_public
#define IDC_STATUS4    544
_dt_public
#define IDC_STATUS5    545
_dt_public
#define IDC_STATUS6    546
_dt_public
#define IDC_STATUS7    547
_dt_public
#define IDC_STATUS8    548
_dt_public
#define IDC_STATUS9    549
_dt_public
#define IDC_STATUS10   550



/*
** SIZE FIELDS ASSOCIATED WITH CHECK OPTIONAL COMPONENTS
*/

_dt_public
#define IDC_SIZE1    551
_dt_public
#define IDC_SIZE2    552
_dt_public
#define IDC_SIZE3    553
_dt_public
#define IDC_SIZE4    554
_dt_public
#define IDC_SIZE5    555
_dt_public
#define IDC_SIZE6    556
_dt_public
#define IDC_SIZE7    557
_dt_public
#define IDC_SIZE8    558
_dt_public
#define IDC_SIZE9    559
_dt_public
#define IDC_SIZE10   560



/*
** TOTALS OF SIZES
*/

_dt_public
#define IDC_TOTAL1    561
_dt_public
#define IDC_TOTAL2    562
_dt_public
#define IDC_TOTAL3    563
_dt_public
#define IDC_TOTAL4    564
_dt_public
#define IDC_TOTAL5    565
_dt_public
#define IDC_TOTAL6    566
_dt_public
#define IDC_TOTAL7    567
_dt_public
#define IDC_TOTAL8    568
_dt_public
#define IDC_TOTAL9    569
_dt_public
#define IDC_TOTAL10   570

/*
** MAXIMUM SIZES
*/

_dt_public
#define IDC_MAX1    571
_dt_public
#define IDC_MAX2    572
_dt_public
#define IDC_MAX3    573
_dt_public
#define IDC_MAX4    574
_dt_public
#define IDC_MAX5    575
_dt_public
#define IDC_MAX6    576
_dt_public
#define IDC_MAX7    577
_dt_public
#define IDC_MAX8    578
_dt_public
#define IDC_MAX9    579
_dt_public
#define IDC_MAX10   580

/*
**	Edit Control IDs
*/

#define IDC_EDIT1   581
#define IDC_EDIT2   582
#define IDC_EDIT3   583
#define IDC_EDIT4   584
#define IDC_EDIT5   585
#define IDC_EDIT6   586
#define IDC_EDIT7   587
#define IDC_EDIT8   588
#define IDC_EDIT9   589
#define IDC_EDIT10  590

/*
**	ListBox Control IDs
*/

#define IDC_LIST1   591
#define IDC_LIST2   592
#define IDC_LIST3   593
#define IDC_LIST4   594
#define IDC_LIST5   595
#define IDC_LIST6   596
#define IDC_LIST7   597
#define IDC_LIST8   598
#define IDC_LIST9   599
#define IDC_LIST10  600


/*
** MENU IDS
*/

#define ID_MAINTAIN  651


/*
** ID_MAINTAIN MENU IDS
*/

#define MENU_CHANGE           701
#define MENU_INSTALL          702
#define MENU_ADD_REMOVE       703
#define MENU_EXIT             704
#define MENU_HELPINDEX        705
#define MENU_HELPSEARCH       706
#define MENU_HELPONHELP       708
#define MENU_HELPONLINE       709
#define MENU_ABOUT            710
#define MENU_PROFILE          711
#define MENU_ADD_REMOVE_SCSI  712
#define MENU_ADD_REMOVE_TAPE  713


/*
**  Handle-Dialog type
*/
_dt_public typedef HWND     HDLG;

/*
**  Event Handler Return Code type
*/
_dt_public typedef USHORT   EHRC;

_dt_public
#define ehrcError       (EHRC) 0
_dt_public
#define ehrcNoPost      (EHRC) 1
_dt_public
#define ehrcPostInterp  (EHRC) 2
_dt_public
#define ehrcNotHandled  (EHRC) 3

/*
**  Prototype for Specific Dialog Event Handlers -- 1632
*/
_dt_public typedef EHRC ( APIENTRY *PFNEVENT)(HANDLE, HWND, UINT, WPARAM, DWORD);

    /* Standard Dialog handler routines */

extern LONG    APIENTRY LDefSetupDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstInfoDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstEditDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstMultiEditDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstGetPathDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstRadioDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstCheckDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstCheck1DlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstListDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstMultiDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstModelessDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstMultiComboDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstComboRadDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstCombinationDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstDualDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstDual1DlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstMaintDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstBillboardDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FAppAbout(HWND, UINT, WPARAM, LONG);

	/* stack manipulation routines */
extern HDLG    APIENTRY HdlgPushDbcb(HANDLE, SZ, SZ, HWND, WNDPROC, DWORD,
                                     PFNEVENT, SZ, WNDPROC);
extern BOOL	   APIENTRY FPopDbcb(VOID);
extern BOOL    APIENTRY FPopNDbcb(INT);

extern BOOL    APIENTRY FUiLibFilter(MSG *);
extern BOOL    APIENTRY FResumeStackTop(VOID);
extern SZ      APIENTRY SzStackTopName(VOID);
extern BOOL    APIENTRY FGenericEventHandler(HANDLE, HWND, UINT, WPARAM, DWORD);  // 1632
extern BOOL    APIENTRY FStackEmpty(VOID);
extern HDLG	   APIENTRY HdlgStackTop(VOID);


//
// Display of integer items in text fields
//
extern VOID MySetDlgItemInt(HDLG, INT, LONG);
extern VOID NumericFormat(SZ szSrcBuf, SZ szDispBuf);

//
// Winhelp related externals
//

extern BOOL FInitWinHelpFile(HWND, SZ, SZ, SZ, SZ);
extern BOOL FCloseWinHelp(HWND);
extern BOOL FProcessWinHelp(HWND);
extern BOOL FProcessWinHelpMenu(HWND, WORD);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\setupdef.h ===
#include <windows.h>
#define IDD_SIGNON  100
#define IDD_VALUES  200

#define IDB_HELP    666


#define IDS_PATH    IDD_SIGNON+1

#define IDV_LABEL_MTTF   IDD_VALUES+1
#define IDV_MTTF         IDD_VALUES+2
#define IDV_LABEL_NAMES  IDD_VALUES+3
#define IDV_NAMES        IDD_VALUES+4
#define IDV_LABEL_PERIOD IDD_VALUES+5
#define IDV_PERIOD       IDD_VALUES+6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\munge\datefix.c ===
/*
 * Utility program to munge a set of files, translating names from
 * one form to another.  Usage:
 *
 *      munge scriptFile files...
 *
 * where the first parameter is the name of a file that consists of
 * one or more lines of the following format:
 *
 *      oldName newName
 *
 * and the remaining parameters are the names of the files to munge.
 * Each file is _read into memory, scanned once, where each occurence
 * of an oldName string is replaced by its corresponding newName.
 * If any changes are made to a file, the old version is RMed and
 * the new version written out under the same name.
 *
 */

#include "munge.h"

int fQuery = FALSE;
int fRecurse = FALSE;
int fVerbose = FALSE;

void
DoFiles(
    char *p,
    struct findType *b,
    void *Args
    );

void
DoFile( p )
char *p;
{
    HANDLE FileHandle;
    SYSTEMTIME SystemTime;
    FILETIME CurrentTime;
    FILETIME CreationTime;
    FILETIME LastAccessTime;
    FILETIME LastWriteTime;
    BOOL DatesBogus = FALSE;

    if (fVerbose)
        fprintf( stderr, "Checking %s\n", p );

    FileHandle = CreateFile( p,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );
    if (FileHandle == NULL) {
        fprintf( stderr, "%s - unable to open (%d)\n", p, GetLastError() );
        return;
        }

    if (!GetFileTime( FileHandle,
                      &CreationTime,
                      &LastAccessTime,
                      &LastWriteTime
                    )
       ) {
        fprintf( stderr, "%s - unable to read file dates (%d)\n", p, GetLastError() );
        CloseHandle( FileHandle );
        return;
        }
    CloseHandle( FileHandle );

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &CurrentTime );

    if (CompareFileTime( &CreationTime, &CurrentTime ) > 0) {
        CreationTime = CurrentTime;
        DatesBogus = TRUE;
        }

    if (CompareFileTime( &LastAccessTime, &CurrentTime ) > 0) {
        LastAccessTime = CurrentTime;
        DatesBogus = TRUE;
        }

    if (CompareFileTime( &LastWriteTime, &CurrentTime ) > 0) {
        LastWriteTime = CurrentTime;
        DatesBogus = TRUE;
        }

    if (DatesBogus) {
        printf( "%s dates invalid", p );
        if (fQuery) {
            printf( "\n" );
            return;
            }

        FileHandle = CreateFile( p,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL
                               );
        if (FileHandle == NULL) {
            printf( " - unable to open for write (%d)\n", GetLastError() );
            }
        else {
            if (!SetFileTime( FileHandle,
                              &CreationTime,
                              &LastAccessTime,
                              &LastWriteTime
                            )
               ) {
                printf( " - unable to modify file dates (%d)\n", GetLastError() );
                }
            else {
                printf( " - reset to current date/time\n" );
                }

            CloseHandle( FileHandle );
            }
        }

    return;
}


void
DoFiles(
    char *p,
    struct findType *b,
    void *Args
    )
{
    if (strcmp (b->fbuf.cFileName, ".") &&
        strcmp (b->fbuf.cFileName, "..") &&
        _stricmp (b->fbuf.cFileName, "slm.dif")
       ) {
        if (HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) {
            switch (p[strlen(p)-1]) {
                case '/':
                case '\\':  strcat (p, "*.*");  break;
                default:    strcat (p, "\\*.*");
                }

            if (fRecurse) {
                fprintf( stderr, "Scanning %s\n", p );
                forfile( p,
                         FILE_ATTRIBUTE_DIRECTORY,
                         DoFiles,
                         NULL
                       );
                }
            }
        else {
            DoFile( p );
            }
        }

    Args;
}

void
Usage( void )
{
    fprintf( stderr, "usage: datefix [-q] [-r] [-v] [DirectorySpec(s)]\n" );
    fprintf( stderr, "Where...\n");
    fprintf( stderr, "\t-q\tQuery only - don't actually make changes.\n");
    fprintf( stderr, "\t-r\tRecurse.\n");
    fprintf( stderr, "\t-v\tVerbose - show files being checked.\n");
    fprintf( stderr, "\tDirectorySpec - one or more directories to examime.\n" );
    exit( 1 );
}

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int i;
    char *s, pathBuf[ 64 ];
    int FileArgsSeen = 0;

    if (argc < 2) {
        Usage();
        }

    fQuery = FALSE;
    fRecurse = FALSE;
    fVerbose = FALSE;

    for (i=1; i<argc; i++) {
        s = argv[ i ];
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'q':   fQuery = TRUE;  break;
                    case 'r':   fRecurse = TRUE;  break;
                    case 'v':   fVerbose = TRUE;  break;
                    default:    Usage();
                    }
                }
            }
        else {
            FileArgsSeen++;
            if (GetFileAttributes( s ) & FILE_ATTRIBUTE_DIRECTORY) {
                s = strcpy( pathBuf, s );
                switch (s[strlen(s)-1]) {
                    case '/':
                    case '\\':  strcat (s, "*.*");  break;
                    default:    strcat (s, "\\*.*");
                    }
                fprintf( stderr, "Scanning %s\n", s );
                forfile( s,
                         FILE_ATTRIBUTE_DIRECTORY,
                         DoFiles,
                         NULL
                       );
                }
            else {
                DoFile( s );
                }
            }
        }

    if (FileArgsSeen == 0) {
        s = "*.*";
        fprintf( stderr, "Scanning .\\%s\n", s );
        forfile( s,
                 FILE_ATTRIBUTE_DIRECTORY,
                 DoFiles,
                 NULL
               );
        }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\munge\munge.c ===
/*
 * Utility program to munge a set of files, translating names from
 * one form to another.  Usage:
 *
 *      munge scriptFile files...
 *
 * where the first parameter is the name of a file that consists of
 * one or more lines of the following format:
 *
 *      oldName newName
 *
 * and the remaining parameters are the names of the files to munge.
 * Each file is _read into memory, scanned once, where each occurence
 * of an oldName string is replaced by its corresponding newName.
 * If any changes are made to a file, the old version is RMed and
 * the new version written out under the same name.
 *
 */

#include "munge.h"

BOOL SymbolsInserted;
BOOL InitTokenMappingTable( void );
BOOL SaveTokenMapping( char *, char * );
char *FindTokenMapping( char * );

#define MAXFILESIZE 0x1000000L
char *InputFileBuf;
char *OutputFileBuf;
int fClean;
int fQuery;
int fFileOnly;
int fRecurse;
int fUseAttrib;
int fUseSLM;
int fForceSLM;
int fTrustMe;
int fVerbose;
int fSummary;
int fRemoveDuplicateCR;
int fRemoveImbeddedNulls;
int fTruncateWithCtrlZ;
int fInsideQuotes;
int fInsideComments;
int fNeuter;
int fCaseSensitive;
int fEntireLine;

#define MAX_LITERAL_STRINGS 64

void
DoFiles(
       char *p,
       struct findType *b,
       void *Args
       );

unsigned long NumberOfLiteralStrings;
char *LiteralStrings[ MAX_LITERAL_STRINGS ];
unsigned long LiteralStringsLength[ MAX_LITERAL_STRINGS ];
char *NewLiteralStrings[ MAX_LITERAL_STRINGS ];
char LeadingLiteralChars[ MAX_LITERAL_STRINGS+1 ];

unsigned long NumberOfFileExtensions = 0;
char *FileExtensions[ 64 ];

unsigned long NumberOfFileNames = 0;
char *FileNames[ 64  ];

unsigned long NumberOfFileNameAndExts = 0;
char *FileNameAndExts[ 64 ];


char *UndoScriptFileName;
FILE *UndoScriptFile;
int UndoCurDirCount;

void
DisplayFilePatterns( void );

char *
PushCurrentDirectory(
                    char *NewCurrentDirectory
                    );

void
PopCurrentDirectory(
                   char *OldCurrentDirectory
                   );


NTSTATUS
CreateSymbolTable(
                 IN ULONG NumberOfBuckets,
                 IN ULONG MaxSymbolTableSize,
                 OUT PVOID *SymbolTableHandle
                 );

NTSTATUS
AddSymbolToSymbolTable(
                      IN PVOID SymbolTableHandle,
                      IN PUNICODE_STRING SymbolName,
                      IN ULONG_PTR *SymbolValue OPTIONAL
                      );

NTSTATUS
LookupSymbolInSymbolTable(
                         IN PVOID SymbolTableHandle,
                         IN PUNICODE_STRING SymbolName,
                         OUT ULONG_PTR *SymbolValue OPTIONAL
                         );

BOOL
myread( int fh, unsigned long cb )
{
    HANDLE InputFileMapping;

    InputFileMapping = CreateFileMapping( (HANDLE)_get_osfhandle( fh ),
                                          NULL,
                                          PAGE_READONLY,
                                          0,
                                          cb,
                                          NULL
                                        );

    if (InputFileMapping == NULL) {
        if (cb != 0) {
            fprintf( stderr, "Unable to map file (%d) - ", GetLastError() );
        }

        return FALSE;
    }

    InputFileBuf = MapViewOfFile( InputFileMapping,
                                  FILE_MAP_READ,
                                  0,
                                  0,
                                  cb
                                );

    CloseHandle( InputFileMapping );
    if (InputFileBuf == NULL) {
        if (cb != 0) {
            fprintf( stderr, "Unable to map view (%d) - ", GetLastError() );
        }

        CloseHandle( InputFileMapping );
        return FALSE;
    } else {
        return TRUE;
    }
}

unsigned long mywrite( int fh, char *s, unsigned long cb )
{
    unsigned long cbWritten;

    if (!WriteFile( (HANDLE)_get_osfhandle( fh ), s, cb, &cbWritten, NULL )) {
        printf( "(%d)", GetLastError() );
        return 0L;
    } else {
        return cbWritten;
    }
}


static char lineBuf[ 1024 ];

ReadScriptFile( s )
char *s;
{
    FILE *fh;
    int lineNum, result;
    char *pOldName, *pNewName, *pEnd;
    unsigned n;
    char LeadingChar, QuoteChar, SaveChar;

    NumberOfLiteralStrings = 0;

    n = 0;
    fprintf( stderr, "Reading script file - %s", s );
    if ( !( fh = fopen( s, "r" ) ) ) {
        fprintf( stderr, " *** unable to open\n" );
        return FALSE;
    }

    result = TRUE;
    lineNum = -1;
    while ( pOldName = fgets( lineBuf, sizeof( lineBuf ), fh ) ) {
        lineNum++;
        while ( *pOldName == ' ' )
            pOldName++;

        if (*pOldName == '-' && (pOldName[1] == 'f' || pOldName[1] == 'F')) {
            pOldName += 2;
            while (*pOldName) {
                while (*pOldName == ' ') {
                    pOldName++;
                }

                pEnd = pOldName;
                while (*pEnd > ' ') {
                    pEnd++;
                }
                SaveChar = *pEnd;
                *pEnd = '\0';

                if (*pOldName == '.') {
                    pNewName = MakeStr( ++pOldName );
                    if (pNewName)
                        _strlwr(pNewName);
                    FileExtensions[ NumberOfFileExtensions++ ] = pNewName;
                } else
                    if (pEnd > pOldName && pEnd[ -1 ] == '.') {
                    pEnd[ - 1 ] = '\0';
                    pNewName = MakeStr(pOldName);
                    if (pNewName)
                        _strlwr(pNewName);
                    FileNames[ NumberOfFileNames++ ] = pNewName;
                } else {
                    pNewName = MakeStr(pOldName);
                    if (pNewName)
                        _strlwr(pNewName);
                    FileNameAndExts[ NumberOfFileNameAndExts++ ] = pNewName;
                }

                *pEnd = SaveChar;
                pOldName = pEnd;
            }
        } else
            if (*pOldName == '"' || *pOldName == '\'') {
            if (NumberOfLiteralStrings >= MAX_LITERAL_STRINGS) {
                fprintf( stderr, " *** too many literal strings\n" );
                fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                result = FALSE;
                break;
            }

            QuoteChar = *pOldName;
            LeadingChar = *++pOldName;
            pNewName = pOldName;
            while (*pNewName >= ' ' && *pNewName != QuoteChar) {
                pNewName++;
            }

            if (*pNewName != QuoteChar) {
                fprintf( stderr, " *** invalid literal string\n" );
                fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                result = FALSE;
                continue;
            }

            *pNewName++ = '\0';
            while ( *pNewName == ' ' )
                pNewName++;

            if (*pNewName != QuoteChar) {
                if (!fQuery) {
                    fprintf( stderr, " *** invalid literal string\n" );
                    fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                    result = FALSE;
                    continue;
                }
            } else {
                PUCHAR pDest, pSrc;
                BOOL fEscaped = FALSE;

                pEnd = ++pNewName;
                pDest = pSrc = pEnd;

                while ((*pSrc >= ' ') && ((*pSrc != QuoteChar) || fEscaped)) {
                    if (fEscaped) {
                        switch(pSrc[0]) {
                            case 'n':
                                *pDest++ = '\r';
                                *pDest++ = '\n';
                                break;
                            default:
                                *pDest++ = *pSrc;
                                break;
                        }
                        fEscaped = FALSE;
                    } else {
                        if (pSrc[0] == '\\') {
                            fEscaped = TRUE;
                        } else {
                            *pDest++ = *pSrc;
                        }
                    }
                    pSrc++;
                }

                pEnd = pSrc;

                if (*pEnd != QuoteChar) {
                    fprintf( stderr, " *** invalid literal string\n" );
                    fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                    result = FALSE;
                    continue;
                }
                *pDest = '\0';
            }

            LiteralStrings[ NumberOfLiteralStrings ] = MakeStr( ++pOldName );
            LiteralStringsLength[ NumberOfLiteralStrings ] = strlen( pOldName );
            NewLiteralStrings[ NumberOfLiteralStrings ] = MakeStr( pNewName );
            LeadingLiteralChars[ NumberOfLiteralStrings ] = LeadingChar;
            NumberOfLiteralStrings += 1;
        } else {
            pNewName = pOldName;
            while ( *pNewName != '\0' && *pNewName != ' ' ) {
                pNewName += 1;
            }

            if (*pNewName == '\0') {
                if (!fQuery) {
                    if (result)
                        fprintf( stderr, " *** invalid script file\n" );
                    fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                    result = FALSE;
                    continue;
                }

                while (pNewName > pOldName && pNewName[ -1 ] < ' ') {
                    *--pNewName = '\0';
                }

                pNewName = MakeStr( pOldName );
            } else {
                *pNewName++ = 0;
                while ( *pNewName == ' ' )
                    pNewName++;

                pEnd = pNewName;
                while ( *pEnd > ' ' )
                    pEnd++;
                *pEnd = 0;
                pNewName = MakeStr( pNewName );
            }

            if (!pNewName || !SaveTokenMapping(  pOldName, pNewName )) {
                if (result)
                    fprintf( stderr, " *** out of memory\n" );
                if (pNewName) {
                    free(pNewName);
                }
                fprintf( stderr, "%s(%d) - can't add symbol '%s'\n", s, lineNum, pOldName );
                result = FALSE;
            } else {
                SymbolsInserted = TRUE;
                n++;
            }
        }
    }

    fclose( fh );
    if (result) {
        fprintf( stderr, " %d tokens", n );
        if (NumberOfLiteralStrings) {
            fprintf( stderr, " and %d literal strings\n", NumberOfLiteralStrings );
        } else {
            fprintf( stderr, "\n" );
        }

        if (!NumberOfFileExtensions && !NumberOfFileNames && !NumberOfFileNameAndExts) {
            FileExtensions[ NumberOfFileExtensions++ ] = "asm";
            FileExtensions[ NumberOfFileExtensions++ ] = "bat";
            FileExtensions[ NumberOfFileExtensions++ ] = "c";
            FileExtensions[ NumberOfFileExtensions++ ] = "cli";
            FileExtensions[ NumberOfFileExtensions++ ] = "cpp";
            FileExtensions[ NumberOfFileExtensions++ ] = "cxx";
            FileExtensions[ NumberOfFileExtensions++ ] = "def";
            FileExtensions[ NumberOfFileExtensions++ ] = "dlg";
            FileExtensions[ NumberOfFileExtensions++ ] = "h";
            FileExtensions[ NumberOfFileExtensions++ ] = "htm";
            FileExtensions[ NumberOfFileExtensions++ ] = "hpj";
            FileExtensions[ NumberOfFileExtensions++ ] = "hxx";
            FileExtensions[ NumberOfFileExtensions++ ] = "idl";
            FileExtensions[ NumberOfFileExtensions++ ] = "inc";
            FileExtensions[ NumberOfFileExtensions++ ] = "inf";
            FileExtensions[ NumberOfFileExtensions++ ] = "lic";
            FileExtensions[ NumberOfFileExtensions++ ] = "mak";
            FileExtensions[ NumberOfFileExtensions++ ] = "mc";
            FileExtensions[ NumberOfFileExtensions++ ] = "odl";
            FileExtensions[ NumberOfFileExtensions++ ] = "rc";
            FileExtensions[ NumberOfFileExtensions++ ] = "rcv";
            FileExtensions[ NumberOfFileExtensions++ ] = "reg";
            FileExtensions[ NumberOfFileExtensions++ ] = "s";
            FileExtensions[ NumberOfFileExtensions++ ] = "src";
            FileExtensions[ NumberOfFileExtensions++ ] = "srv";
            FileExtensions[ NumberOfFileExtensions++ ] = "tk";
            FileExtensions[ NumberOfFileExtensions++ ] = "w";
            FileExtensions[ NumberOfFileExtensions++ ] = "x";
            FileNameAndExts[ NumberOfFileNameAndExts++ ] = "makefil0";
            FileNameAndExts[ NumberOfFileNameAndExts++ ] = "makefile";
            FileNameAndExts[ NumberOfFileNameAndExts++ ] = "sources";
        }
    }

    return result;
}


int
MungeFile(
         int fRepeatMunge,
         char *FileName,
         char *OldBuf,
         unsigned long OldSize,
         char *NewBuf,
         unsigned long MaxNewSize,
         unsigned long *FinalNewSize
         )
{
    unsigned long NewSize = MaxNewSize;
    unsigned Changes = 0;
    unsigned LineNumber;
    char c, *Identifier, *BegLine, *EndLine, *OrigOldBuf;
    char IdentifierBuffer[ 256 ];
    char *p, *p1;
    int i, j, k;
    BOOL TruncatedByCtrlZ;
    BOOL ImbeddedNullsStripped;
    BOOL DuplicateCRStripped;
    BOOL InSingleQuotes;
    BOOL InDoubleQuotes;
    BOOL Escape = FALSE;
    BOOL Star = FALSE;
    BOOL Backslash = FALSE;
    BOOL Pound = FALSE;
    BOOL Semi = FALSE;
    BOOL LastEscape;
    BOOL LastStar;
    BOOL LastBackslash;
    BOOL LastPound;
    BOOL LastSemi;
    BOOL SkipChar;
    BOOL InLineComment;
    BOOL InComment;

    *FinalNewSize = 0;
    LineNumber = 1;
    TruncatedByCtrlZ = FALSE;
    ImbeddedNullsStripped = FALSE;
    DuplicateCRStripped = FALSE;
    InSingleQuotes = FALSE;
    InDoubleQuotes = FALSE;
    InLineComment = FALSE;
    InComment = FALSE;
    LastEscape = FALSE;
    LastStar = FALSE;
    LastBackslash = FALSE;
    OrigOldBuf = OldBuf;

    while (OldSize) {
        OldSize--;
        c = *OldBuf++;
        if (c == '\r') {
            while (OldSize && *OldBuf == '\r') {
                DuplicateCRStripped = TRUE;
                OldSize--;
                c = *OldBuf++;
            }
        }

        if (c == 0x1A) {
            TruncatedByCtrlZ = TRUE;
            break;
        }

        SkipChar = FALSE;

        if ( !fInsideQuotes || !fInsideComments ) {
            LastEscape    = Escape;
            LastStar      = Star;
            LastBackslash = Backslash;
            LastPound     = Pound;
            LastSemi      = Semi;

            Escape    = (c == '\\');
            Star      = (c == '*' );
            Backslash = (c == '/' );
            Pound     = (c == '#' );
            Semi      = (c == ';' );

            if ( Escape && LastEscape ) {   // two in a row don't mean escape
                Escape = FALSE;
            }

            if ( c == '\r' || c == '\n' ) {
                InLineComment = FALSE;
            }


            // Don't process Include or Pragma directives
            if ( LastPound && OldSize > 6 ) {
                if ( !strncmp(OldBuf-1,"include",7)
                     || !strncmp(OldBuf-1,"pragma",6) ) {
                    InLineComment = TRUE;
                }
            }

            if (c == '"' && !InSingleQuotes && !LastEscape
                && !InLineComment && !InComment ) {
                InDoubleQuotes = !InDoubleQuotes;
                if ( fNeuter ) {
                    if ( InDoubleQuotes ) {
                        if ( NewSize < 5 ) {
                            return( -1 );
                        }
                        strcpy(NewBuf,"TEXT(");
                        NewBuf+=5;
                        NewSize -= 5;
                    } else {
                        if ( NewSize < 1 ) {
                            return( -1 );
                        }
                        *NewBuf++ = '"';
                        NewSize--;
                        c = ')';
                    }
                }
            }

            if (c == '\'' && !InDoubleQuotes && !LastEscape
                && !InLineComment && !InComment ) {
                InSingleQuotes = !InSingleQuotes;
                if ( fNeuter ) {
                    if ( InSingleQuotes ) {
                        if ( NewSize < 5 ) {
                            return( -1 );
                        }
                        strcpy(NewBuf,"TEXT(");
                        NewBuf+=5;
                        NewSize -= 5;
                    } else {
                        if ( NewSize < 1 ) {
                            return( -1 );
                        }
                        *NewBuf++ = '\'';
                        NewSize--;
                        c = ')';
                    }
                }
            }
            if ( !InDoubleQuotes && !InSingleQuotes
                 && !InLineComment && !InComment ) {
                if ( LastBackslash ) {
                    switch (c) {
                        case '*':   InComment = TRUE;       break;
                        case '/':   InLineComment = TRUE;   break;
                    }
                }
            }

            if ( InComment && LastStar && Backslash ) {
                InComment = FALSE;
            }

            if ( !fInsideQuotes && ( InSingleQuotes || InDoubleQuotes ) ) {
                SkipChar = TRUE;
            } else
                if ( !fInsideComments && ( InLineComment || InComment ) ) {
                SkipChar = TRUE;
            }
        }

        if (c != 0 && NumberOfLiteralStrings != 0 && !SkipChar ) {
            p = LeadingLiteralChars;
            while (p = strchr( p, c )) {
                i = (int)(p - LeadingLiteralChars);
                p++;
                if (OldSize >= LiteralStringsLength[ i ]) {
                    p1 = IdentifierBuffer;
                    Identifier = OldBuf;
                    j = LiteralStringsLength[ i ];
                    while (j--) {
                        *p1++ = *Identifier++;
                    }
                    *p1 = '\0';

                    if (!strcmp( LiteralStrings[ i ], IdentifierBuffer )) {
                        BegLine = OldBuf - 1;
                        OldSize -= LiteralStringsLength[ i ];
                        OldBuf = Identifier;
                        p1 = NewLiteralStrings[ i ];

                        if (!fRepeatMunge && !fSummary) {
                            if (fFileOnly) {
                                if (Changes == 0) { // Display just file name on first match
                                    printf( "%s\n", FileName );
                                }
                            } else {
                                printf( "%s(%d) : ",
                                        FileName,
                                        LineNumber
                                      );
                                if (fQuery) {
                                    EndLine = BegLine;
                                    while (*EndLine != '\0' && *EndLine != '\n') {
                                        EndLine += 1;
                                    }
                                    if (fEntireLine) {
                                        while (BegLine > OrigOldBuf && *BegLine != '\n') {
                                            BegLine -= 1;
                                        }
                                        if (*BegLine == '\n') {
                                            BegLine += 1;
                                        }
                                    }

                                    printf( "%.*s\n", EndLine - BegLine, BegLine );
                                } else {
                                    printf( "Matched \"%c%s\", replace with \"%s\"\n",
                                            c,
                                            LiteralStrings[ i ],
                                            p1
                                          );
                                }
                            }
                            fflush( stdout );
                        }

                        Changes++;
                        while (*p1) {
                            if (NewSize--) {
                                *NewBuf++ = *p1++;
                            } else {
                                return( -1 );
                            }
                        }

                        c = '\0';
                        break;
                    }
                }
            }
        } else {
            p = NULL;
        }

        if (SymbolsInserted && (p == NULL) && iscsymf( c )) {
            BegLine = OldBuf - 1;
            Identifier = IdentifierBuffer;
            k = sizeof( IdentifierBuffer ) - 1;
            while (iscsym( c )) {
                if (k) {
                    *Identifier++ = c;
                    k--;
                } else {
                    break;
                }

                if (OldSize--) {
                    c = *OldBuf++;
                } else {
                    // OldSize will get updated below...
                    c = '\0';
                }
            }

            c = '\0';       // No character to add to output stream

            --OldBuf;       // Went a little too far
            OldSize++;

            *Identifier++ = 0;

            if (k == 0 || (Identifier = FindTokenMapping( IdentifierBuffer )) == NULL || SkipChar ) {
                Identifier = IdentifierBuffer;
            } else {
                if (!fRepeatMunge && !fSummary) {
                    if (fFileOnly) {
                        if (Changes == 0) { // Display just file name on first match
                            printf( "%s\n", FileName );
                        }
                    } else {
                        printf( "%s(%d) : ", FileName, LineNumber );
                        if (fQuery) {
                            EndLine = BegLine;
                            while (*EndLine != '\0' && *EndLine != '\r' && *EndLine != '\n') {
                                EndLine += 1;
                            }
                            if (*EndLine == '\0') {
                                EndLine -= 1;
                            }
                            if (*EndLine == '\n') {
                                EndLine -= 1;
                            }
                            if (*EndLine == '\r') {
                                EndLine -= 1;
                            }

                            if (fEntireLine) {
                                while (BegLine > OrigOldBuf && *BegLine != '\n') {
                                    BegLine -= 1;
                                }
                                if (*BegLine == '\n') {
                                    BegLine += 1;
                                }
                            }

                            printf( "%.*s", EndLine - BegLine + 1, BegLine );
                        } else {
                            printf( "Matched %s replace with %s", IdentifierBuffer, Identifier );
                        }

                        printf( "\n" );
                    }

                    fflush( stdout );
                }

                Changes++;
            }

            while (*Identifier) {
                if (NewSize--) {
                    *NewBuf++ = *Identifier++;
                } else {
                    return( -1 );
                }
            }
        }

        if (c == '\n') {
            LineNumber++;
        }

        if (c != '\0') {
            if (NewSize--) {
                *NewBuf++ = c;
            } else {
                return( -1 );
            }
        } else {
            ImbeddedNullsStripped = TRUE;
        }
    }

    if (!Changes && fClean) {
        if (fTruncateWithCtrlZ && TruncatedByCtrlZ) {
            if (!fRepeatMunge && !fSummary) {
                printf( "%s(%d) : File truncated by Ctrl-Z\n",
                        FileName,
                        LineNumber
                      );
                fflush( stdout );
            }

            Changes++;
        }

        if (fRemoveImbeddedNulls && ImbeddedNullsStripped) {
            if (!fRepeatMunge && !fSummary) {
                printf( "%s(%d) : Imbedded null characters removed.\n",
                        FileName,
                        LineNumber
                      );
                fflush( stdout );
            }

            Changes++;
        }

        if (fRemoveDuplicateCR && DuplicateCRStripped) {
            if (!fRepeatMunge && !fSummary) {
                printf( "%s(%d) : Duplicate Carriage returns removed.\n",
                        FileName,
                        LineNumber
                      );
                fflush( stdout );
            }

            Changes++;
        }
    }

    *FinalNewSize = MaxNewSize - NewSize;
    return( Changes );
}


typedef struct _MUNGED_LIST_ELEMENT {
    struct _MUNGED_LIST_ELEMENT *Next;
    char *FileName;
    int NumberOfChanges;
} MUNGED_LIST_ELEMENT, *PMUNGED_LIST_ELEMENT;

PMUNGED_LIST_ELEMENT MungedListHead;

BOOL
RememberMunge(
             char *FileName,
             int NumberOfChanges
             );

BOOL
CheckIfMungedAlready(
                    char *FileName
                    );

void
DumpMungedList( void );

BOOL
RememberMunge(
             char *FileName,
             int NumberOfChanges
             )
{
    PMUNGED_LIST_ELEMENT p;

    p = (PMUNGED_LIST_ELEMENT)malloc( sizeof( *p ) + strlen( FileName ) + 4 );
    if (p == NULL) {
        return FALSE;
    }

    p->FileName = (char *)(p + 1);
    strcpy( p->FileName, FileName );
    p->NumberOfChanges = NumberOfChanges;
    p->Next = MungedListHead;
    MungedListHead = p;
    return TRUE;
}


BOOL
CheckIfMungedAlready(
                    char *FileName
                    )
{
    PMUNGED_LIST_ELEMENT p;

    p = MungedListHead;
    while (p) {
        if (!strcmp( FileName, p->FileName )) {
            return TRUE;
        }

        p = p->Next;
    }

    return FALSE;
}

void
DumpMungedList( void )
{
    PMUNGED_LIST_ELEMENT p, p1;

    if (!fSummary) {
        return;
    }

    p = MungedListHead;
    while (p) {
        p1 = p;
        printf( "%u changes made to the file %s(1).\n", p->NumberOfChanges,  p->FileName );
        p = p->Next;
        free( (char *)p1 );
    }
}


void
DoFile( p )
char *p;
{
    int fh, n;
    unsigned long oldSize;
    unsigned long newSize;
    int  count, rc;
    char newName[ 128 ];
    char bakName[ 128 ];
    char CommandLine[ 192 ];
    char *s, *CurrentDirectory;
    DWORD dwFileAttributes;
    int fRepeatMunge;

    if (CheckIfMungedAlready( p )) {
        return;
    }

    if (fVerbose)
        fprintf( stderr, "Scanning %s\n", p );

    strcpy( &newName[ 0 ], p );
    strcpy( &bakName[ 0 ], p );
    for (n = strlen( &newName[ 0 ] )-1; n > 0; n--) {
        if (newName[ n ] == '.') {
            break;
        } else
            if (newName[ n ] == '\\') {
            n = 0;
            break;
        }
    }

    if (n == 0) {
        n = strlen( &newName[ 0 ] );
    }
    strcpy( &newName[ n ], ".mge" );
    strcpy( &bakName[ n ], ".bak" );
    fRepeatMunge = FALSE;

    RepeatMunge:
    if ( (fh = _open( p, O_BINARY )) == -1) {
        fprintf( stderr, "%s - unable to open\n", p );
        return;
    }

    oldSize = _lseek( fh, 0L, 2 );
    if (_lseek( fh, 0L, 0 ) == -1) {
        fprintf(stderr, "%s - unable to seek to start of file\n", p);
        _close(fh);
        return;
    }
    count = 0;
    if (oldSize > MAXFILESIZE)
        fprintf( stderr, "%s - file too large (%ld)\n", p, oldSize );
    else
        if (!myread( fh, oldSize )) {
        if (oldSize != 0) {
            fprintf( stderr, "%s - error while reading\n", p );
        }
    } else {
        count = MungeFile( fRepeatMunge,
                           p,
                           InputFileBuf,
                           oldSize,
                           OutputFileBuf,
                           MAXFILESIZE,
                           (unsigned long *)&newSize
                         );
        if (count == -1)
            fprintf( stderr, "%s - output buffer overflow", p );

        UnmapViewOfFile( InputFileBuf );
    }
    _close( fh );

    if (count > 0) {
        if (fRepeatMunge) {
            fprintf( stderr, " - munge again" );
        } else {
            dwFileAttributes = GetFileAttributes( p );
            fprintf( stderr, "%s", p );
        }

        if (!fQuery && _access( p, 2 ) == -1) {
            if (!(fUseSLM || fUseAttrib)) {
                fprintf( stderr, "%s - write protected, unable to apply changes\n", p );
                return;
            }

            if (fRepeatMunge) {
                fprintf( stderr, " - %s failed, %s still write-protected\n",
                         fUseSLM ? "OUT" : "ATTRIB", p );
                printf( "%s(1) : UNABLE TO RUN %s command.\n", p, fUseSLM ? "OUT" : "ATTRIB" );
                fflush( stdout );
                return;
            }

            s = p + strlen( p );
            while (s > p) {
                if (*--s == '\\') {
                    *s++ = '\0';
                    break;
                }
            }

            if (s != p) {
                CurrentDirectory = PushCurrentDirectory( p );
            } else {
                CurrentDirectory = NULL;
            }

            if (fUseAttrib) {
                fprintf( stderr, " - ATTRIB -r" );
                if (SetFileAttributes( s,
                                       dwFileAttributes & ~(FILE_ATTRIBUTE_READONLY |
                                                            FILE_ATTRIBUTE_HIDDEN |
                                                            FILE_ATTRIBUTE_SYSTEM
                                                           )
                                     )
                   ) {
                } else {
                    if (CurrentDirectory) {
                        s[-1] = '\\';
                    }

                    fprintf( stderr, " - failed (rc == %d), %s still write-protected\n",
                             GetLastError(), p );
                    printf( "%s(1) : UNABLE TO MAKE WRITABLE\n", p );
                    fflush( stdout );
                    return;
                }
            } else {
                sprintf( CommandLine, "out %s%s", fForceSLM ? "-z " : "", s );
                fprintf( stderr, " - check out" );
                fflush( stdout );
                fflush( stderr );
                rc = system( CommandLine );

                if (rc == -1) {
                    if (CurrentDirectory) {
                        s[-1] = '\\';
                    }

                    fprintf( stderr, " - OUT failed (rc == %d), %s still write-protected\n", errno, p );
                    printf( "%s(1) : UNABLE TO CHECK OUT\n", p );
                    fflush( stdout );
                    return;
                }

            }

            GetCurrentDirectory( sizeof( CommandLine ), CommandLine );
            if (CurrentDirectory) {
                PopCurrentDirectory( CurrentDirectory );
                s[-1] = '\\';
            }

            if (fUseSLM && UndoScriptFile != NULL) {
                if (!(UndoCurDirCount++ % 8)) {
                    if (UndoCurDirCount == 1) {
                        fprintf( UndoScriptFile, "\ncd %s", CommandLine );
                    }

                    fprintf( UndoScriptFile, "\nin -vi" );
                }

                fprintf( UndoScriptFile, " %s", s );
                fflush( UndoScriptFile );
            }

            fRepeatMunge = TRUE;
            goto RepeatMunge;
        } else
            if (!fQuery && _access( p, 2 ) != -1 && fUseSLM && !fRepeatMunge) {
            if (!fSummary) {
                printf( "%s(1) : FILE ALREADY CHECKED OUT\n", p );
                fflush( stdout );
            }
        }

        RememberMunge( p, count );
        if (fQuery) {
            fprintf( stderr, " [%d potential changes]\n", count );
        } else {
            if ( (fh = _creat( newName, S_IWRITE | S_IREAD )) == -1 )
                fprintf( stderr, " - unable to create new version (%s)\n",
                         newName );
            else
                if (mywrite( fh, OutputFileBuf, newSize ) != newSize) {
                fprintf( stderr, " - error while writing\n" );
                _close( fh );
                _unlink( newName );
            } else {
                _close( fh );
                if (fTrustMe) {
                    _unlink( p );
                } else {
                    if (_access( bakName, 0 ) == 0) {
                        _unlink( bakName );
                    }

                    if (rename( p, bakName )) {
                        fprintf( stderr, "MUNGE: rename %s to %s failed\n",
                                 p, bakName );
                        return;
                    }
                }

                if (rename( newName, p )) {
                    fprintf( stderr, "MUNGE: rename %s to %s failed\n",
                             newName, p );
                } else {
                    if (fRepeatMunge && fUseAttrib) {
                        SetFileAttributes( p, dwFileAttributes );
                    } else {
                        fprintf( stderr, "\n" );
                    }
                    RememberMunge( p, count );
                }
            }
        }
    }
}


void
DoFiles(
       char *p,
       struct findType *b,
       void *Args
       )
{
    int SaveCurDirCount;
    char *s;
    unsigned long i;
    int FileProcessed;

    if (strcmp ((const char *)b->fbuf.cFileName, ".") &&
        strcmp ((const char *)b->fbuf.cFileName, "..") &&
        strcmp ((const char *)b->fbuf.cFileName, "slm.dif")
       ) {
        if (HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) {
            switch (p[strlen(p)-1]) {
                case '/':
                case '\\':  strcat (p, "*.*");  break;
                default:    strcat (p, "\\*.*");
            }

            if (fRecurse) {
                fprintf( stderr, "Scanning %s\n", p );
                SaveCurDirCount = UndoCurDirCount;
                UndoCurDirCount = 0;
                forfile( p,
                         FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ,
                         DoFiles,
                         NULL
                       );
                if (UndoScriptFile != NULL) {
                    if (UndoCurDirCount != 0) {
                        fprintf( UndoScriptFile, "\n" );
                        fflush( UndoScriptFile );
                        UndoCurDirCount = 0;
                    } else {
                        UndoCurDirCount = SaveCurDirCount;
                    }
                }
            }
        } else {
            s = _strlwr( (char *)b->fbuf.cFileName );
            while (*s != '.') {
                if (*s == '\0') {
                    break;
                } else {
                    s++;
                }
            }

            FileProcessed = FALSE;
            if (*s) {
                if (!strcmp( s, "mge" ) || !strcmp( s, "bak" )) {
                    FileProcessed = TRUE;
                } else {
                    for (i=0; i<NumberOfFileExtensions; i++) {
                        if (!strcmp( FileExtensions[ i ], s+1 )) {
                            FileProcessed = TRUE;
                            DoFile( p );
                            break;
                        }
                    }
                }

                if (!FileProcessed) {
                    *s = '\0';
                    for (i=0; i<NumberOfFileNames; i++) {
                        if (!strcmp( FileNames[ i ], (const char *)b->fbuf.cFileName )) {
                            FileProcessed = TRUE;
                            DoFile( p );
                            break;
                        }
                    }
                    *s = '.';
                }
            } else {
                for (i=0; i<NumberOfFileNames; i++) {
                    if (!strcmp( FileNames[ i ], (const char *)b->fbuf.cFileName )) {
                        FileProcessed = TRUE;
                        DoFile( p );
                        break;
                    }
                }
            }

            if (!FileProcessed) {
                for (i=0; i<NumberOfFileNameAndExts; i++) {
                    if (!strcmp( FileNameAndExts[ i ], (const char *)b->fbuf.cFileName )) {
                        FileProcessed = TRUE;
                        DoFile( p );
                        break;
                    }
                }
            }
        }
    }

    Args;
}

void
Usage( char *MsgFmt, int MsgArg )
{
    fputs("usage: munge scriptFile [-q [-e] [-o]] [-v] [-i] [-k] [-r] [-c [-m] [-z] [-@]]\n"
          "                        [-n] [-l | -L] [-a | -s [-f]] [-u undoFileName]\n"
          "                        filesToMunge...\n"
          "Where...\n"
          "    -q\tQuery only - don't actually make changes.\n"
          "    -e\tQuery only - display entire line for each match\n"
          "    -o\tQuery only - just display filename once on first match\n"
          "    -v\tVerbose - show files being scanned\n"
          "    -i\tJust output summary of files changed at end\n"
          "    -k\tCase - Case sensitive scriptFile\n"
          "    -r\tRecurse.\n"
          "    -c\tIf no munge of file, then check for cleanlyness\n"
          "    -m\tCollapse multiple carriage returns into one\n"
          "    -z\tCtrl-Z will truncate file\n"
          "    -@\tRemove null characters\n"
          "    -n\tNeuter - Surround all strings with TEXT()\n"
          "    -l\tLiterals - process any quoted text (includes comments too)\n"
          "    -L\tLiterals - process any quoted text (excludes comments)\n"
          "    -s\tUse OUT command command for files that are readonly\n"
          "    -a\tUse ATTRIB -r command for files that are readonly\n"
          "    -f\tUse -z flag for SLM OUT command\n"
          "    -t\tTrust me and dont create .bak files\n"
          "    -u\tGenerate an undo script file for any SLM OUT commands invoked.\n"
          "    -?\tGets you this message\n\n"
          "and scriptFile lines take any of the following forms:\n\n"
          "    oldName newName\n"
          "    \"oldString\" \"newString\"\n"
          "    -F .Ext  Name.  Name.Ext\n\n"
          "Where...\n"
          "    oldName and newName following C Identifier rules\n"
          "    oldString and newString are arbitrary text strings\n"
          "    -F limits the munge to files that match:\n"
          "        a particular extension (.Ext)\n"
          "        a particular name (Name.)\n"
          "        a particular name and extension (Name.Ext)\n"
          "    If no -F line is seen in the scriptFile, then\n"
          "    the following is the default:\n"
          "    -F .asm .bat .c .cli .cpp .cxx .def .dlg .h .htm .hpj .hxx .idl .inc\n"
          "    -F .inf .lic .mak .mc .odl .rc .rcv .reg .s .src .srv .tk .w .x\n"
          "    -F makefil0 makefile sources\n",
          stderr);

    if (MsgFmt != NULL) {
        fprintf( stderr, "\n" );
        fprintf( stderr, MsgFmt, MsgArg );
        fprintf( stderr, "\n" );
    }
    exit( 1 );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    int i;
    char *s, pathBuf[ 64 ];
    int FileArgsSeen = 0;

    ConvertAppToOem( argc, argv );
    if (argc < 3) {
        Usage( NULL, 0 );
    }

    if ( !InitTokenMappingTable()) {
        fprintf( stderr, "MUNGE: Unable to create symbol table\n" );
        exit( 1 );
    }

    OutputFileBuf = (char *)VirtualAlloc( NULL,
                                          MAXFILESIZE,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
    if ( OutputFileBuf == NULL) {
        fprintf( stderr, "not enough memory\n" );
        exit( 1 );
    }

    fClean = FALSE;
    fRemoveDuplicateCR = FALSE;
    fRemoveImbeddedNulls = FALSE;
    fTruncateWithCtrlZ = FALSE;
    fQuery = FALSE;
    fFileOnly = FALSE;
    fRecurse = FALSE;
    fUseAttrib = FALSE;
    fUseSLM = FALSE;
    fForceSLM = FALSE;
    fTrustMe = FALSE;
    fVerbose = FALSE;
    UndoScriptFileName = NULL;
    UndoScriptFile = NULL;
    fSummary = FALSE;
    fInsideQuotes = FALSE;
    fInsideComments = FALSE;
    fNeuter = FALSE;
    fEntireLine = FALSE;

    for (i=2; i<argc; i++) {
        s = argv[ i ];
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch ( tolower( *s ) ) {
                    case 'm':   fRemoveDuplicateCR = TRUE; break;
                    case '@':   fRemoveImbeddedNulls = TRUE; break;
                    case 'z':   fTruncateWithCtrlZ = TRUE; break;
                    case 'c':   fClean = TRUE;  break;
                    case 'q':   fQuery = TRUE;  break;
                    case 'o':   fFileOnly = TRUE;  break;
                    case 'r':   fRecurse = TRUE;  break;
                    case 'a':   fUseAttrib = TRUE;  break;
                    case 's':   fUseSLM = TRUE;  break;
                    case 'f':   fForceSLM = TRUE;  break;
                    case 't':   fTrustMe = TRUE;  break;
                    case 'v':   fVerbose = TRUE;  break;
                    case 'i':   fSummary = TRUE;  break;
                    case 'l':   if (*s != 'L') fInsideComments = TRUE;
                        fInsideQuotes = TRUE; break;
                    case 'n':   fNeuter = TRUE; fInsideQuotes = FALSE; break;
                    case 'k':   fCaseSensitive = TRUE; break;
                    case 'e':   fEntireLine = TRUE;  break;
                    case 'u':   UndoScriptFileName = argv[ ++i ];
                        break;

                    default:    Usage( "invalid switch - '%c'", *s );
                }
            }
        } else {
            if ((fFileOnly | fEntireLine) && !fQuery) {
                Usage( "-e or -o invalid without -q", 0 );
            }

            if (fQuery && (fClean ||
                           fRemoveDuplicateCR ||
                           fRemoveImbeddedNulls ||
                           fTruncateWithCtrlZ ||
                           fUseSLM ||
                           fForceSLM ||
                           fTrustMe ||
                           UndoScriptFile ||
                           fNeuter
                          )
               ) {
                Usage( "-q valid only with -e or -o", 0 );
            }

            if (fClean &&
                !fRemoveDuplicateCR &&
                !fRemoveImbeddedNulls &&
                !fTruncateWithCtrlZ
               ) {
                Usage( "-c requires at least one of -m, -z or -@", 0 );
            }

            if (UndoScriptFileName != NULL) {
                if (!fUseSLM) {
                    Usage ("-u invalid with -s", 0 );
                } else {
                    UndoScriptFile = fopen( UndoScriptFileName, "w" );
                    if (UndoScriptFile == NULL) {
                        fprintf( stderr, "Unable to open %s\n", UndoScriptFileName );
                        exit( 1 );
                    }
                }
            }

            if (!FileArgsSeen++) {
                if (!ReadScriptFile( argv[ 1 ] )) {
                    fprintf( stderr, "Invalid script file - %s\n", argv[ 1 ] );
                    exit( 1 );
                }

                if (fVerbose) {
                    DisplayFilePatterns();
                }
            }

            if (GetFileAttributes( s ) & FILE_ATTRIBUTE_DIRECTORY) {
                s = strcpy( pathBuf, s );
                switch (s[strlen(s)-1]) {
                    case '/':
                    case '\\':  strcat (s, "*.*");  break;
                    default:    strcat (s, "\\*.*");
                }
                fprintf( stderr, "Scanning %s\n", s );
                UndoCurDirCount = 0;
                forfile( s,
                         FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ,
                         DoFiles,
                         NULL
                       );
            } else {
                UndoCurDirCount = 0;
                DoFile( s );
            }
        }
    }

    if (FileArgsSeen == 0) {
        if (!ReadScriptFile( argv[ 1 ] )) {
            fprintf( stderr, "Invalid script file - %s\n", argv[ 1 ] );
            exit( 1 );
        }

        if (fVerbose) {
            DisplayFilePatterns();
        }

        s = "*.*";
        fprintf( stderr, "Scanning %s\n", s );
        UndoCurDirCount = 0;
        forfile( s,
                 FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ,
                 DoFiles,
                 NULL
               );
    }

    if (UndoScriptFile != NULL) {
        if (UndoCurDirCount != 0) {
            fprintf( UndoScriptFile, "\n" );
        }

        fclose( UndoScriptFile );
    }

    DumpMungedList();
    return( 0 );
}




void
DisplayFilePatterns( void )
{
    unsigned long i;

    if (NumberOfFileExtensions) {
        fprintf( stderr, "Munge will look at files with the following extensions:\n   " );
        for (i=0; i<NumberOfFileExtensions; i++) {
            fprintf( stderr, " %s", FileExtensions[ i ] );
        }
        fprintf( stderr, "\n" );
    }

    if (NumberOfFileNames) {
        fprintf( stderr, "Munge will look at files with the following names:\n   " );
        for (i=0; i<NumberOfFileNames; i++) {
            fprintf( stderr, " %s", FileNames[ i ] );
        }
        fprintf( stderr, "\n" );
    }

    if (NumberOfFileNameAndExts) {
        fprintf( stderr, "Munge will look at files with the following name and extensions:\n   " );
        for (i=0; i<NumberOfFileNameAndExts; i++) {
            fprintf( stderr, " %s", FileNameAndExts[ i ] );
        }
        fprintf( stderr, "\n" );
    }
}


char *
PushCurrentDirectory(
                    char *NewCurrentDirectory
                    )
{
    char *OldCurrentDirectory;

    if (OldCurrentDirectory = malloc( MAX_PATH )) {
        GetCurrentDirectory( MAX_PATH, OldCurrentDirectory );
        SetCurrentDirectory( NewCurrentDirectory );
    } else {
        fprintf( stderr,
                 "MUNGE: (Fatal Error) PushCurrentDirectory out of memory\n"
               );
        exit( 16 );
    }

    return( OldCurrentDirectory );
}


void
PopCurrentDirectory(
                   char *OldCurrentDirectory
                   )
{
    if (OldCurrentDirectory) {
        SetCurrentDirectory( OldCurrentDirectory );
        free( OldCurrentDirectory );
    }
}


PVOID SymbolTableHandle;


BOOL
InitTokenMappingTable( void )
{
    NTSTATUS Status;

    Status = CreateSymbolTable( 257, 0x20000, &SymbolTableHandle );
    if (NT_SUCCESS( Status )) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
SaveTokenMapping(
                char *String,
                char *Value
                )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING SymbolName;
    ULONG_PTR SymbolValue;

    RtlInitString( &AnsiString, String );
    Status = RtlAnsiStringToUnicodeString( &SymbolName, &AnsiString, TRUE );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    SymbolValue = (ULONG_PTR)Value;
    Status = AddSymbolToSymbolTable( SymbolTableHandle,
                                     &SymbolName,
                                     &SymbolValue
                                   );
    RtlFreeUnicodeString( &SymbolName );
    if (NT_SUCCESS( Status )) {
        return TRUE;
    } else {
        return FALSE;
    }
}


char *
FindTokenMapping(
                char *String
                )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING SymbolName;
    ULONG_PTR SymbolValue;

    RtlInitString( &AnsiString, String );
    Status = RtlAnsiStringToUnicodeString( &SymbolName, &AnsiString, TRUE );
    if (!NT_SUCCESS( Status )) {
        return NULL;
    }

    Status = LookupSymbolInSymbolTable( SymbolTableHandle,
                                        &SymbolName,
                                        &SymbolValue
                                      );
    RtlFreeUnicodeString( &SymbolName );
    if (NT_SUCCESS( Status )) {
        return (char *)SymbolValue;
    } else {
        return NULL;
    }
}


typedef struct _SYMBOL_TABLE_ENTRY {
    struct _SYMBOL_TABLE_ENTRY *HashLink;
    ULONG_PTR Value;
    UNICODE_STRING Name;
} SYMBOL_TABLE_ENTRY, *PSYMBOL_TABLE_ENTRY;

typedef struct _SYMBOL_TABLE {
    ULONG NumberOfBuckets;
    PSYMBOL_TABLE_ENTRY Buckets[1];
} SYMBOL_TABLE, *PSYMBOL_TABLE;

NTSTATUS
CreateSymbolTable(
                 IN ULONG NumberOfBuckets,
                 IN ULONG MaxSymbolTableSize,
                 OUT PVOID *SymbolTableHandle
                 )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSYMBOL_TABLE p;
    ULONG Size;

    RtlLockHeap( GetProcessHeap() );

    if (*SymbolTableHandle == NULL) {
        Size = sizeof( SYMBOL_TABLE ) +
               (sizeof( SYMBOL_TABLE_ENTRY ) * (NumberOfBuckets-1));

        p = (PSYMBOL_TABLE)RtlAllocateHeap( GetProcessHeap(), 0, Size );
        if (p == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {
            RtlZeroMemory( p, Size );
            p->NumberOfBuckets = NumberOfBuckets;
            *SymbolTableHandle = p;
        }
    }

    RtlUnlockHeap( GetProcessHeap() );

    return( Status );
}


PSYMBOL_TABLE_ENTRY
BasepHashStringToSymbol(
                       IN PSYMBOL_TABLE p,
                       IN PUNICODE_STRING Name,
                       OUT PSYMBOL_TABLE_ENTRY **PreviousSymbol
                       )
{
    ULONG n, Hash;
    WCHAR c;
    PWCH s;
    PSYMBOL_TABLE_ENTRY *pps, ps;

    n = Name->Length / sizeof( c );
    s = Name->Buffer;
    if ( fCaseSensitive ) {
        Hash = 0;
        while (n--) {
            c = *s++;
            Hash = Hash + (c << 1) + (c >> 1) + c;
        }
    } else {
        Hash = 0;
        while (n--) {
            c = RtlUpcaseUnicodeChar( *s++ );
            Hash = Hash + (c << 1) + (c >> 1) + c;
        }
    }

    pps = &p->Buckets[ Hash % p->NumberOfBuckets ];
    while (ps = *pps) {
        if (RtlEqualUnicodeString( &ps->Name, Name, (BOOLEAN)!fCaseSensitive )) {
            break;
        } else {
            pps = &ps->HashLink;
        }
    }

    *PreviousSymbol = pps;
    return( ps );
}


NTSTATUS
AddSymbolToSymbolTable(
                      IN PVOID SymbolTableHandle,
                      IN PUNICODE_STRING SymbolName,
                      IN ULONG_PTR * SymbolValue OPTIONAL
                      )
{
    NTSTATUS Status;
    PSYMBOL_TABLE p = (PSYMBOL_TABLE)SymbolTableHandle;
    PSYMBOL_TABLE_ENTRY ps, *pps;
    ULONG_PTR Value;

    if (ARGUMENT_PRESENT( SymbolValue )) {
        Value = *SymbolValue;
    } else {
        Value = 0;
    }

    Status = STATUS_SUCCESS;

    RtlLockHeap( GetProcessHeap() );
    try {
        ps = BasepHashStringToSymbol( p, SymbolName, &pps );
        if (ps == NULL) {
            ps = RtlAllocateHeap( GetProcessHeap(), 0, (sizeof( *ps ) + SymbolName->Length) );
            if (ps != NULL) {
                ps->HashLink = NULL;
                ps->Value = Value;
                ps->Name.Buffer = (PWSTR)(ps + 1);
                ps->Name.Length = SymbolName->Length;
                ps->Name.MaximumLength = (USHORT)(SymbolName->Length + sizeof( UNICODE_NULL ));
                RtlMoveMemory( ps->Name.Buffer, SymbolName->Buffer, SymbolName->Length );
                *pps = ps;
            } else {
                Status = STATUS_NO_MEMORY;
            }
        }

        else {
            Status = STATUS_OBJECT_NAME_EXISTS;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    RtlUnlockHeap( GetProcessHeap() );

    return( Status );
}

NTSTATUS
LookupSymbolInSymbolTable(
                         IN PVOID SymbolTableHandle,
                         IN PUNICODE_STRING SymbolName,
                         OUT ULONG_PTR *SymbolValue OPTIONAL
                         )
{
    NTSTATUS Status;
    PSYMBOL_TABLE p = (PSYMBOL_TABLE)SymbolTableHandle;
    PSYMBOL_TABLE_ENTRY ps, *pps;
    ULONG_PTR Value;

    RtlLockHeap( GetProcessHeap() );
    try {
        ps = BasepHashStringToSymbol( p, SymbolName, &pps );
        if (ps == NULL) {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            Value = 0;
        } else {
            Status = STATUS_SUCCESS;
            Value = ps->Value;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    RtlUnlockHeap( GetProcessHeap() );

    if (NT_SUCCESS( Status )) {
        if (ARGUMENT_PRESENT( SymbolValue )) {
            *SymbolValue = Value;
        }
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\setup\progcm.c ===
/* File: progcm.c */
/**************************************************************************/
/*	Install: Program Manager commands.
/*	Uses DDE to communicate with ProgMan
/*	Can create groups, delete groups, add items to groups
/*	Originally written 3/9/89 by toddla (the stuff that looks terrible)
/*	Munged greatly for STUFF 4/15/91 by chrispi (the stuff that doesn't work)
/**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <cmnds.h>
#include <dde.h>
#include "install.h"
#include "uilstf.h"

#define BIG_ENUF 1024
_dt_system(Install)
_dt_subsystem(ProgMan Operations)

HANDLE
ExecuteApplication(
    LPSTR lpApp,
    WORD  nCmdShow
    );

HWND hwndFrame;
HWND hwndProgressGizmo;

CHAR	szProgMan[] = "PROGMAN";
HWND	hwndDde     = NULL;        // dummy window to handle DDE messages
HWND	hwndProgMan = NULL;        // global handle of progman window
BOOL	fInitiate   = fFalse;      // are we initializing?
BOOL    fAck        = fFalse;
BOOL    fProgManExeced     = fFalse;
HANDLE  hInstCur    = NULL;


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeTerminate(VOID)
{
	PreCondition(hwndProgMan != NULL, fFalse);
    PreCondition(hwndDde     != NULL, fFalse);

    SetForegroundWindow(hwndFrame);
    UpdateWindow(hwndFrame);
    MPostWM_DDE_TERMINATE( hwndProgMan, hwndDde );
	hwndProgMan = NULL;

	return(fTrue);
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
LONG_PTR
APIENTRY
WndProcDde(
           HWND hwnd,
           UINT uiMessage,
           WPARAM wParam,
		   LPARAM lParam
           )
{
	AssertDataSeg();

    switch (uiMessage) {

    case WM_DDE_TERMINATE:

        if(hwndProgMan == NULL) {
            DestroyWindow(hwnd);
            hwndDde = NULL;
        }
        else {
            EvalAssert(FDdeTerminate());
        }

        DDEFREE( uiMessage, lParam );
        return(0L);

    case WM_DDE_ACK:

        if (fInitiate) {

            ATOM aApp   = LOWORD(lParam);
            ATOM aTopic = HIWORD(lParam);

            hwndProgMan = (HWND)wParam;     //conversation established 1632
            GlobalDeleteAtom (aApp);
            GlobalDeleteAtom (aTopic);
        }

        else {

            WORD   wStatus   = GET_WM_DDE_EXECACK_STATUS(wParam, lParam);
            HANDLE hCommands = GET_WM_DDE_EXECACK_HDATA(wParam, lParam);
            if (hCommands) {
                fAck = ((DDEACK *)(&wStatus))->fAck;
                GlobalFree(hCommands);
            }

            DDEFREE( uiMessage, lParam );
        }

        return(0L);

    default:

        break;

    }

	return(DefWindowProc(hwnd, uiMessage, wParam, lParam));
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeInit(
         HANDLE hInst
         )
{

    if (hInst == NULL) {

        /* try to re-init with hInst from last FDdeInit call */

        if (hInstCur == NULL) {
            return(fFalse);
        }

		hInst = hInstCur;
    }
    else {

        hInstCur = hInst;

    }

    if (hwndDde == NULL) {

		static CHP szClassName[] = "ddeClass";
		WNDCLASS rClass;

		Assert(hwndProgMan == NULL);

        if (!GetClassInfo(hInst, szClassName, &rClass)) {
			rClass.hCursor       = NULL;
			rClass.hIcon         = NULL;
			rClass.lpszMenuName  = NULL;
			rClass.lpszClassName = szClassName;
			rClass.hbrBackground = NULL;
			rClass.hInstance     = hInst;
			rClass.style         = 0;
			rClass.lpfnWndProc   = WndProcDde;
			rClass.cbClsExtra    = 0;
			rClass.cbWndExtra    = 0;

            if (!RegisterClass(&rClass)) {
                return(fFalse);
            }

        }

        hwndDde = CreateWindow(
                       szClassName,
                       NULL,
                       0L,
                       0, 0, 0, 0,
                       (HWND)NULL,
                       (HMENU)NULL,
                       (HANDLE)hInst,
                       (LPSTR)NULL
                       );
    }

	return(hwndDde != NULL);
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
VOID
APIENTRY
DdeSendConnect(
               ATOM aApp,
               ATOM aTopic
               )
{
    fInitiate = fTrue;
    SendMessage(
        (HWND)-1,
        WM_DDE_INITIATE,
        (WPARAM)hwndDde,
        MAKELONG(aApp, aTopic)
        );
    fInitiate = fFalse;
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeConnect(
            SZ szApp,
            SZ szTopic
            )
{
    BOOL   fStatus = fTrue;
    MSG    rMsg;
    HANDLE hProcess = NULL;

    //
    // Form the Global Atoms used to indicate the app and topic
    //

	ATOM aApp   = GlobalAddAtom(szApp);
	ATOM aTopic = GlobalAddAtom(szTopic);

    //
    // Connect to the progman dde server
    //

    DdeSendConnect(aApp, aTopic);

    if (hwndProgMan == NULL) {

        //
        // If the connect failed then try to run progman.
        //

        if ((hProcess = ExecuteApplication("PROGMAN /NTSETUP", SW_SHOWNORMAL)) == NULL ) {
            fStatus = fFalse;
        }
        else {
            INT i;
            DWORD dw;
            #define TIMEOUT_INTERVAL  120000

            //
            // Indicate that Progman has been execed
            //

            fProgManExeced = fTrue;

            //
            // exec was successful, first wait for input idle
            //

            if( (dw = WaitForInputIdle( hProcess, TIMEOUT_INTERVAL )) != 0 ) {
                CloseHandle( hProcess );
                fStatus = fFalse;
            }
            else {
                CloseHandle( hProcess );

                //
                // Empty the message queue till no messages
                // are left in the queue or till WM_ACTIVATEAPP is processed. Then
                // try connecting to progman.  I am using PeekMessage followed
                // by GetMessage because PeekMessage doesn't remove some messages
                // ( WM_PAINT for one ).
                //

                while ( PeekMessage( &rMsg, hwndFrame, 0, 0, PM_NOREMOVE ) &&
                        GetMessage(&rMsg, NULL, 0, 0) ) {

                    if (TRUE
                            && (hwndProgressGizmo == NULL
                                || !IsDialogMessage(hwndProgressGizmo, &rMsg))) {
                        TranslateMessage(&rMsg);
                        DispatchMessage(&rMsg);
                    }

                    if ( rMsg.message == WM_ACTIVATEAPP ) {
                        break;
                    }

                }
                DdeSendConnect(aApp, aTopic);
            }
        }
    }

    //
    // Delete the atom resources
    //

	GlobalDeleteAtom(aApp);
    GlobalDeleteAtom(aTopic);

    return ( fStatus );
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeWait(VOID)
{
    MSG   rMsg;
    BOOL  fResult   = fTrue;
    DWORD dwTimeOut, dwTickDelta, dwLastTick, dwCurrentTick;

	Assert(hwndProgMan != NULL);
	Assert(hwndDde != NULL);

    //
    // Set timeout for 30 seconds from now.  This assumes that it will
    // take less than 30 seconds for Progman to respond.
    //

    dwTimeOut  = 30000L;
    dwLastTick = GetTickCount();

    while (TRUE) {

        //
        // While there is a connection established to progman and there
        // are DDE messages we can fetch, fetch the messages dispatch them
        // and try to find out if they are terminators (data, ack or terminate)
        //

        while (
            hwndProgMan != NULL &&
            PeekMessage(&rMsg, NULL, WM_DDE_FIRST, WM_DDE_LAST, PM_REMOVE)
            ) {

            TranslateMessage(&rMsg);
            DispatchMessage(&rMsg);

            if (rMsg.wParam == (WPARAM)hwndProgMan) {
                switch (rMsg.message) {

                case WM_DDE_ACK:
                    return ( fAck );

                case WM_DDE_DATA:
                    return (fTrue);

                default:
                    break;
                }
            }
        }


        //
        // If connection to progman has been broken, this may be resulting
        // from a terminate, so return true
        //

        if (hwndProgMan == NULL) {
            return (fTrue);
        }

        //
        // Check to see if timeout hasn't been reached.  If the timeout is
        // reached we will assume that our command succeeded (for want of
        // a better verification scheme
        //
        dwTickDelta = ((dwCurrentTick = GetTickCount()) < dwLastTick) ?
                             dwCurrentTick : (dwCurrentTick - dwLastTick);

        if (dwTimeOut < dwTickDelta) {
            return (fTrue);
        }

        dwTimeOut  = dwTimeOut - dwTickDelta;
        dwLastTick = dwCurrentTick;

        //
        // Lastly, since user doesn't have idle detection, we will be
        // sitting in a tight loop here.  To prevent this just do a
        // sleep for 250 milliseconds.
        //

        Sleep( 250 );

    }

    return(fTrue);
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeExec(
         SZ szCmd
         )
{
	BOOL   bResult = fFalse;
	HANDLE hCmd;

	Assert(hwndProgMan != NULL);
	Assert(hwndDde != NULL);

    hCmd = GlobalAlloc(GMEM_DDESHARE, (LONG)CchpStrLen(szCmd) + 1);
    if (hCmd != NULL) {

		LPSTR lpCmd = GlobalLock(hCmd);

        if (lpCmd != NULL) {
			lstrcpy(lpCmd, szCmd);
            GlobalUnlock(hCmd);
            MPostWM_DDE_EXECUTE(hwndProgMan, hwndDde, hCmd);
            bResult = FDdeWait();
        }

        else {
            GlobalFree(hCmd);
        }
    }

	return(bResult);
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FActivateProgMan(VOID)
{
    //
    // Find out if the dde client window has been started, if not start it
    //

    if (hwndDde == NULL) {
        if (!FDdeInit(NULL)) {
            return(fFalse);
        }
		Assert(hwndDde != NULL);
    }

    //
    // Find out if the connection has been established with the progman
    // server, if not try to connect
    //

    if (hwndProgMan == NULL) {
        //
        // Try to conncect and then see if we were successful
        //
        if ( (!FDdeConnect(szProgMan, szProgMan)) ||
             (hwndProgMan == NULL)
           ) {
            return(fFalse);
        }
    }

    //
    // Bring progman to the foreground
    //

    SetForegroundWindow(hwndProgMan);

    //
    // If progman is iconic restore it
    //

    if (GetWindowLong(hwndProgMan, GWL_STYLE) & WS_ICONIC) {
        ShowWindow(hwndProgMan, SW_RESTORE);
    }

	return(fTrue);
}


/*
**	Purpose:
**		Creates a new Program Manager group.
**	Arguments:
**		Valid command options:
**			cmoVital
**	Notes:
**		Initializes and activates the DDE communication if it is not
**		currently open.
**	Returns:
**		fTrue if group was created, or already existed
**		fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FCreateProgManGroup(
                    SZ szGroup,
                    SZ szPath,
                    CMO cmo,
                    BOOL CommonGroup
                    )
{
    static CHP szCmdBase[] = "[CreateGroup(%s%s%s,%s)]";
	CCHP cchp;
    char szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
	EERC eerc;

    if (szPath == NULL) {
        szPath = "";
    }

    FActivateProgMan();

    wsprintf(szBuf, szCmdBase, szGroup, (*szPath ? "," : szPath), szPath, CommonGroup ? "1" : "0");

    FDdeExec(szBuf);

	return(fTrue);
}


/*
**	Purpose:
**		Removes a Program Manager group.
**	Arguments:
**		Valid command options:
**			cmoVital
**	Notes:
**		Initializes and activates the DDE communication if it is not
**		currently open.
**	Returns:
**		fTrue if successful if removed, or didn't exist
**		fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FRemoveProgManGroup(
                    SZ szGroup,
                    CMO cmo,
                    BOOL CommonGroup
                    )
{
    static CHP szCmdBase[] = "[DeleteGroup(%s,%s)]";
	CCHP cchp;
    char szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
	EERC eerc;

    FActivateProgMan();

    wsprintf(szBuf, szCmdBase, szGroup, CommonGroup ? "1" : "0");

    FDdeExec(szBuf);

	return(fTrue);
}


/*
**	Purpose:
**		Shows a program manager group in one of several different ways
**		based upon the parameter szCommand.
**	Arguments:
**		szGroup:   non-NULL, non-empty group to show.
**		szCommand: non-NULL, non-empty command to exec.
**		cmo:       Valid command options - cmoVital and cmoNone.
**	Notes:
**		Initializes and activates the DDE communication if it is not
**		currently open.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FShowProgManGroup(
                  SZ szGroup,
                  SZ szCommand,
                  CMO cmo,
                  BOOL CommonGroup
                  )
{
    static CHP szCmdBase[] = "[ShowGroup(%s, %s,%s)]";
	CCHP cchp;
    CHP  szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
	EERC eerc;

	ChkArg((szGroup   != (SZ)NULL) && (*szGroup != '\0'), 1, fFalse);
	ChkArg((szCommand != (SZ)NULL) && (*szCommand != '\0'), 2, fFalse);

    FActivateProgMan();

    wsprintf(szBuf, szCmdBase, szGroup, szCommand, CommonGroup ? "1" : "0");

    FDdeExec(szBuf);

	return(fTrue);
}


/*
**	Purpose:
**		Creates a new Program Manager item.
**		Always attempts to create the group if it doesn't exist.
**	Arguments:
**		Valid command options:
**			cmoVital
**			cmoOverwrite
**	Notes:
**		Initializes and activates the DDE communication if it is not
**		currently open.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private BOOL APIENTRY
FCreateProgManItem(
    SZ  szGroup,
    SZ  szItem,
    SZ  szCmd,
    SZ  szIconFile,
    INT nIconNum,
    CMO cmo,
    BOOL CommonGroup
    )
{
    static CHP szCmdBase[] = "[AddItem(%s, %s, %s, %d)]";

	CCHP cchp;
    char szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
    EERC eerc;
    BOOL bStatus;

    FActivateProgMan();

    wsprintf(szBuf, szCmdBase, szCmd, szItem, szIconFile, nIconNum+666);

    bStatus = FDdeExec(szBuf);

    return(bStatus);
}


/*
**	Purpose:
**		Removes a program manager item.
**	Arguments:
**		Valid command options:
**			cmoVital
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FRemoveProgManItem(
                   SZ szGroup,
                   SZ szItem,
                   CMO cmo,
                   BOOL CommonGroup
                   )
{
    static CHP szCmdBase[] = "[DeleteItem(%s)]";

	CCHP cchp;
    char szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
    EERC eerc;
    BOOL bStatus;

    FActivateProgMan();

    FCreateProgManGroup(szGroup, NULL, cmoVital, CommonGroup);

    wsprintf(szBuf, szCmdBase, szItem);

    bStatus = FDdeExec(szBuf);

    return(bStatus);

}


/*
**	Purpose:
**		Initializes the DDE window for communication with ProgMan
**		Does not actually initiate a conversation with ProgMan
**	Arguments:
**		hInst	instance handle for the setup application
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FInitProgManDde(
                HANDLE hInst
                )
{
    if (hwndDde == NULL) {
        return(FDdeInit(hInst));
    }

	return(fTrue);
}


/*
**	Purpose:
**		Closes conversation with ProgMan (if any) and destroys
**		the DDE communication window (if any)
**	Arguments:
**		(none)
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FEndProgManDde(VOID)
{

    //
    // if we execed progman then we should try to close it down.  When we
    // send a close message it will post us a WM_DDE_TERMINATE message
    // eventaully.  else we haven't started progman so we just need to
    // terminate the connection.
    //

    if (fProgManExeced) {

        fProgManExeced = fFalse;

        //
        // Clean up connection to progman
        //

        if (hwndProgMan) {
            SetForegroundWindow(hwndFrame);
            UpdateWindow(hwndFrame);
            FDdeExec("[exitprogman(1)]");  // close save state
            hwndProgMan = NULL;
        }

        //
        // Destroy the DDE Window if need be
        //

        if (hwndDde) {
            DestroyWindow(hwndDde);
            hwndDde = NULL;
        }

    }

    else if (hwndProgMan != NULL) {
        EvalAssert( FDdeTerminate() );
    }

    else if (hwndDde != NULL) {
        DestroyWindow (hwndDde);
        hwndDde = NULL;
    }

    return (fTrue);

}


/*
**	Purpose:
**  Arguments:
**  Returns:
**
**************************************************************************/
HANDLE
ExecuteApplication(
    LPSTR lpApp,
    WORD  nCmdShow
    )
{
    BOOL                fStatus;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

#if DBG
    DWORD               dwLastError;
#endif

    //
    // Initialise Startup info
    //

    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpDesktop = NULL;
    si.lpTitle = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = nCmdShow;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;

    //
    // Execute using Create Process
    //

    fStatus = CreateProcess(
                  (LPSTR)NULL,                  // lpApplicationName
                  lpApp,                        // lpCommandLine
                  (LPSECURITY_ATTRIBUTES)NULL,  // lpProcessAttributes
                  (LPSECURITY_ATTRIBUTES)NULL,  // lpThreadAttributes
                  DETACHED_PROCESS,             // dwCreationFlags
                  FALSE,                        // bInheritHandles
                  (LPVOID)NULL,                 // lpEnvironment
                  (LPSTR)NULL,                  // lpCurrentDirectory
                  (LPSTARTUPINFO)&si,           // lpStartupInfo
                  (LPPROCESS_INFORMATION)&pi    // lpProcessInformation
                  );

    //
    // Since we are execing a detached process we don't care about when it
    // exits.  To do proper book keeping, we should close the handles to
    // the process handle and thread handle
    //

    if (fStatus) {
        CloseHandle( pi.hThread );
        return( pi.hProcess );
    }
#if DBG
    else {
        dwLastError = GetLastError();
    }
#endif

    //
    // Return the status of this operation

    return ( (HANDLE)NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mttf\vwr\mttfvwr.c ===
#include "..\main\mttf.h"

VOID
__cdecl
main(
    int argc,
    char * argv[]
    )
{
HANDLE statFile;
StatFileRecord statRec;
DWORD numBytes;

    if (argc==1) {
        printf("Usage: mttfvwr <datafile> [/t]\n\n/t for terse (Excel text format)\n");
        return;
    }
    if (INVALID_HANDLE_VALUE==(statFile= CreateFile(argv[1],
                                         GENERIC_READ,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL))) {
        printf("Unable to open %s: %ld\n", argv[1], GetLastError());
        return;
    }
    if (argc<3 || tolower(argv[2][1])!='t') {
        printf("Mean Time To Failure data for %s\n\n", argv[1]);
        printf("Build:    minor version number for each set of stats.\n");
        printf("Busy:     number of minutes with cpu usage greater than idle threshhold.\n");
        printf("Idle:     number of minutes with cpu usage less than idle threshhold.\n");
        printf("Gone:     minutes with cpu less than threshhold for 4 consecutive hrs.\n");
        printf("CpuUsage: average percentage of cpu usage for all machines on that build.\n");
        printf("Cold:     number of cold boots due to a problem.\n");
        printf("Warm:     number of warm boots due to a problem.\n");
        printf("Other:    number of other problems.\n\n");
        printf(" Build    Busy    Idle    Gone  CpuUsg    Cold    Warm   Other\n");
        printf(" -----    ----    ----    ----  ------    ----    ----   -----\n");
    } else {
        printf("Build\011Busy\011Idle\011Gone\011CpuUsg\011Cold\011Warm\011Other\n");
    }

    while (ReadFile(statFile, &statRec, sizeof(statRec), &numBytes, NULL)) {
        if (numBytes==0) {
            return;
        }
        if (argc==3 && tolower(argv[2][1])=='t') {
            printf("%ld\011%ld\011%ld\011%ld\011%ld\011%ld\011%ld\011%ld\n",
                statRec.Version>>16,
                statRec.Busy,
                statRec.Idle,
                statRec.IdleConsec,
                (statRec.Busy+statRec.Idle?statRec.PercentTotal/(statRec.Busy+statRec.Idle):0),
                statRec.Cold,
                statRec.Warm,
                statRec.Other);
        } else {
            printf("%6ld\t%6ld\t%6ld\t%6ld\t%6ld\t%6ld\t%6ld\t%6ld\n",
                statRec.Version>>16,
                statRec.Busy,
                statRec.Idle,
                statRec.IdleConsec,
                (statRec.Busy+statRec.Idle?statRec.PercentTotal/(statRec.Busy+statRec.Idle):0),
                statRec.Cold,
                statRec.Warm,
                statRec.Other);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\munge\munge.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    munge.h

Abstract:

    This is the main include file for the source file munger.

Author:

    Steve Wood (stevewo) 16-May-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <tools.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mv\mv.c ===
/* move from one file to another */


#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <ctype.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

__cdecl main (c, v)
int c;
char *v[];
{
    struct findType fbuf;
    char src[MAX_PATH], dst[MAX_PATH], name[MAX_PATH];
    char *s;
    int i, erc;
    char *y;
    BOOL fExpunge, fDelayUntilReboot;
    DWORD dwMoveFileFlags;

    ConvertAppToOem( c, v );
    SHIFT (c,v);
    if (c < 2) {
ShowUsage:
        printf ("Usage: mv [/x [/d]] file1 [ file2 ...] target\n");
        printf ("   /x     dont save deleted files in deleted subdirectory\n");
        printf ("   /d     specifies to delay the rename until the next reboot.\n");
        exit (1);
        }

    dwMoveFileFlags = MOVEFILE_REPLACE_EXISTING |
                      MOVEFILE_COPY_ALLOWED;

    fExpunge = FALSE;
    fDelayUntilReboot = FALSE;
    for (i=0; i<c; i++) {
nextArg:
        s = v[i];
        if (*s == '/' || *s == '-') {
            SHIFT (c,v);
            while (*++s) {
                switch (tolower(*s)) {
                case 'x':   fExpunge = TRUE;    break;
                case 'd':   if (fExpunge) {
                                dwMoveFileFlags |= MOVEFILE_DELAY_UNTIL_REBOOT;
                                dwMoveFileFlags &= ~MOVEFILE_COPY_ALLOWED;
                                break;
                            }

                default:    goto ShowUsage;
                }

            goto nextArg;
            }
        } else {
            findpath (v[i], src, FALSE);
            pname (src);
            v[i] = _strdup (src);
        }
    }

    if (rootpath (v[c-1], dst) == -1) {
        printf ("Cannot move to %s - %s\n", v[c-1], error ());
        exit (1);
    } else {
        if ( dst[0] == '\\' && dst[1] == '\\' ) {
            y = strbscan (&dst[3], "/\\");
            if ( *y != '\0' ) {
                y = strbscan( y+1, "/\\");
                if ( *y == '\0' ) {
                    strcat(dst, "\\" );
                }
            }
        }
    }

    if (fPathChr (dst[strlen(dst)-1])) {
        SETFLAG (fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
    }
    else if (ffirst (dst, FILE_ATTRIBUTE_DIRECTORY, &fbuf)) {
        findclose( &fbuf );  /* Let next ffirst work */
        RSETFLAG (fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
    }
    else if (TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        strcat (dst, "\\");
    }

    /* if more than 1 source and dest is a file */
    if (c != 2 && !TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        printf ("Cannot move > 1 file to another file\n");
        exit (1);
    }

    erc = 0;
    for (i=0; i < c-1; i++) {

        if (rootpath (v[i], src) == -1) {
            printf ("Cannot move %s - %s\n", v[i], error ());
            erc++;
            continue;
            }
        strcpy (name, dst);
        if (TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            if (!fPathChr (name[strlen(name)-1])) {
                strcat (name, "\\");
            }
            upd (src, name, name);
        }
        if (strcmp (src, name)) {
            printf ("%s => %s ", src, name);
            fflush (stdout);
            if (fExpunge) {
                if (MoveFileEx( src, dst, dwMoveFileFlags )) {
                    if (dwMoveFileFlags & MOVEFILE_DELAY_UNTIL_REBOOT)
                        printf ("[ok, will happen next reboot]\n");
                    else
                        printf ("[ok]\n");
                    }
                else {
                    printf( "failed - Error Code == %u\n", GetLastError() );
                    }
                }
            else {
                s = fmove( src, name );
                if (s) {
                    erc++;
                    printf ("[%s]\n", s);
                    }
                else
                    printf ("[ok]\n");
                }
            }
        else
            printf ("Source and destination the same, %s\n", src);
        }
    return(erc != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\netperm\netperm.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    netperm.c

Abstract:

    This is the main source file for the NETPERM tool, which insures that you
    have persistent connections to a set of servers.

Author:

    Steve Wood (stevewo) 23-Jan-1996

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

__cdecl
main (
    int argc,
    char *argv[]
    )
{
    DWORD           Status;
    DWORD           i, j;
    char            *Local;
    char            *Remote;
    HANDLE          enumHandle;
    DWORD           numEntries;
    BOOL            endOfList;
    NETRESOURCE     netResource[8192/sizeof(NETRESOURCE)];
    DWORD           bufferSize = sizeof(netResource);
    DWORD           NumberOfRemoteNamesToCheck;
    char            *RemoteNamesToCheck[ 16 ];
    BOOLEAN         RemoteNamesFound[ 16 ];


    NumberOfRemoteNamesToCheck = 0;
    while (--argc) {
        RemoteNamesFound[ NumberOfRemoteNamesToCheck ] = FALSE;
        RemoteNamesToCheck[ NumberOfRemoteNamesToCheck ] = *++argv;
        NumberOfRemoteNamesToCheck += 1;
        }
    if (NumberOfRemoteNamesToCheck == 0) {
        fprintf( stderr, "List of persistent drive letters currently defined:\n" );
        }

    Status = WNetOpenEnum(
                 RESOURCE_REMEMBERED,
                 RESOURCETYPE_DISK,
                 RESOURCEUSAGE_CONNECTABLE,
                 NULL,
                 &enumHandle );

    if (Status != NO_ERROR) {
        fprintf( stderr, "Cannot enumerate network connections (%d)\n", Status );
        exit( 1 );
        }

    endOfList = FALSE;

    do {
        numEntries = 0xFFFFFFFF;
        Status = WNetEnumResource( enumHandle, &numEntries, netResource, &bufferSize );

        switch( Status ) {

            case NO_ERROR:
                break;

            case ERROR_NO_NETWORK:
                //
                //  If the network has not started we'll continue
                //  (so users can work in local projects).
                //
            case ERROR_NO_MORE_ITEMS:
                endOfList = TRUE;
                numEntries = 0;
                break;

            case ERROR_EXTENDED_ERROR: {
                CHAR ErrorString [256];
                CHAR Network[256];
                DWORD dwError;

                WNetGetLastError(&dwError, ErrorString, 256, Network, 256);
                fprintf( stderr,
                         "Cannot enumerate network connections (%d)\n"
                         "Net: %s\n"
                         "Error: (%d) %s\n",
                         Status,
                         Network,
                         dwError,
                         ErrorString
                       );
                }
                break;

            default:
                fprintf( stderr, "Cannot enumerate network connections (%d)\n", Status );
                exit( 1 );
            }

        for (i = 0; i<numEntries; i++) {
            if (netResource[i].lpLocalName != NULL) {
                if (NumberOfRemoteNamesToCheck == 0) {
                    fprintf( stderr,
                             "%s => %s\n",
                             netResource[i].lpLocalName,
                             netResource[i].lpRemoteName
                           );
                    }
                else {
                    for (j=0; j<NumberOfRemoteNamesToCheck; j++) {
                        if (!RemoteNamesFound[ j ] &&
                            !_stricmp( netResource[i].lpRemoteName, RemoteNamesToCheck[ j ] )
                           ) {
                            RemoteNamesFound[ j ] = TRUE;
                            break;
                            }
                        }
                    }
                }
            }
        }
    while (!endOfList);

    WNetCloseEnum( enumHandle );

    Status = 0;
    for (j=0; j<NumberOfRemoteNamesToCheck; j++) {
        if (!RemoteNamesFound[ j ]) {
            fprintf( stderr, "No persistent drive letter found for %s\n", RemoteNamesToCheck[ j ] );
            Status = 1;
            }
        }

    exit( Status );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\netjoin\netjoin.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <windows.h>
#include <lmcons.h>
#include <stdlib.h>
#include <stdio.h>

#include <crypt.h>      // logonmsv.h needs this
#include <logonmsv.h>   // SSI_SECRET_NAME defined here.

#define TRUST_ENUM_PERF_BUF_SIZE    sizeof(LSA_TRUST_INFORMATION) * 1000
                    // process max. 1000 trusted account records at atime !!

#define NETLOGON_SECRET_NAME  L"NETLOGON$"


NTSTATUS
OpenAndVerifyLSA(
    IN OUT PLSA_HANDLE LsaHandle,
    IN ACCESS_MASK DesiredMask,
    IN LPWSTR DomainName,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO * ReturnPrimaryDomainInfo OPTIONAL
    );

NTSTATUS
AddATrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainAccountInfo,
    IN LPWSTR TrustedAccountSecret
    );

NTSTATUS
DeleteATrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainAccountInfo
    );

NTSTATUS
MakeNetlogonSecretName(
    IN OUT PUNICODE_STRING SecretName
    );

VOID
FailureMessage(
    IN char *ProcName,
    IN NTSTATUS NtStatus
    );


VOID
FailureMessage(
    IN char *ProcName,
    IN NTSTATUS NtStatus
    )
{
    fprintf( stderr, "NETJOIN: %s failed - Status == %x\n", ProcName, NtStatus );
}

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS NtStatus;

    HKEY hKey;

    WCHAR UnicodeDomainName[ 32 ];
    WCHAR UnicodePassword[ 32 ];
    DWORD cbUnicodePassword = sizeof( UnicodePassword );
    DWORD cbUnicodeDomainName = sizeof( UnicodeDomainName );

    DWORD dwType;
    DWORD rc;

    ACCESS_MASK         DesiredAccess;
    LSA_HANDLE          PolicyHandle = NULL;

    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;

    LSA_ENUMERATION_HANDLE      TrustEnumContext = 0;
    PLSA_TRUST_INFORMATION      TrustEnumBuffer = NULL;
    DWORD                       TrustEnumCount = 0;

    //
    // Get computer name as the password to use.
    //

    if (!GetComputerNameW( UnicodePassword, &cbUnicodePassword )) {
        fprintf( stderr, "NETJOIN: Unable to read computer name from registry - %u\n", GetLastError() );
        exit( 1 );
        }

    if ((rc = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                           L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters",
                           &hKey
                         )
        ) ||
        (rc = RegQueryValueExW( hKey,
                                L"Domain",
                                NULL,
                                &dwType,
                                (LPBYTE)UnicodeDomainName,
                                &cbUnicodeDomainName
                              )
        )
       ) {
        fprintf( stderr, "NETJOIN: Unable to read domain name from registry - %u\n", rc );
        exit( 1 );
        }

    DesiredAccess = POLICY_VIEW_LOCAL_INFORMATION |
                        // needed to read domain info and trusted account info
                    POLICY_TRUST_ADMIN |
                        // needed to add and delete trust accounts
                    POLICY_CREATE_SECRET ;
                        // needed to add and delete secret

    NtStatus = OpenAndVerifyLSA( &PolicyHandle,
                                 DesiredAccess,
                                 UnicodeDomainName,
                                 &PrimaryDomainInfo
                               );

    if (!NT_SUCCESS( NtStatus )) {
        fprintf( stderr, "NETJOIN: Unable to read domain name from registry - %u\n", GetLastError() );
        exit( 1 );
        }

    //
    // now the domain names match and the PrimaryDomainInfo has the SID of the
    // domain, we can add trust entry and secret in LSA for this domain.
    // Before adding this, clean up old entries.
    //

    for(;;) {

        DWORD i;
        PLSA_TRUST_INFORMATION  TrustedDomainAccount;

        NtStatus = LsaEnumerateTrustedDomains( PolicyHandle,
                                               &TrustEnumContext,
                                               (PVOID *)&TrustEnumBuffer,
                                               TRUST_ENUM_PERF_BUF_SIZE,
                                               &TrustEnumCount
                                             );

        if (NtStatus == STATUS_NO_MORE_ENTRIES) {

            //
            // we are done
            //

            break;
            }

        if (NtStatus != STATUS_MORE_ENTRIES) {
            if (!NT_SUCCESS( NtStatus )) {
                FailureMessage( "LsaEnumerateTrustedDomains", NtStatus );
                goto Cleanup;
                }
            }

        //
        // delete trusted accounts and the corresponding secrets
        //

        for( i = 0, TrustedDomainAccount = TrustEnumBuffer;
                    i < TrustEnumCount;
                        TrustedDomainAccount++, i++ ) {

            NtStatus = DeleteATrustedDomain( PolicyHandle,
                                             TrustedDomainAccount
                                           );

            if (!NT_SUCCESS( NtStatus )) {
                FailureMessage( "DeleteATrustedDomain", NtStatus );
                goto Cleanup;
                }
            }

        if (NtStatus != STATUS_MORE_ENTRIES) {

            //
            // we have cleaned up all old entries.
            //

            break;
            }

        //
        // free up used enum buffer
        //

        if (TrustEnumBuffer != NULL) {
            LsaFreeMemory( TrustEnumBuffer );
            TrustEnumBuffer = NULL;
            }
        }

    //
    // add a new trust for the specified domain
    //

    NtStatus = AddATrustedDomain( PolicyHandle,
                                  (PLSA_TRUST_INFORMATION) PrimaryDomainInfo,
                                  UnicodePassword
                                );
    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "AddATrustedDomain", NtStatus );
        }
    else {
        //
        // Give LSA a chance to do its thing.
        //

        Sleep( 10000 );
        }

Cleanup:

    if (PrimaryDomainInfo != NULL) {
        LsaFreeMemory( PrimaryDomainInfo );
        }

    if (TrustEnumBuffer != NULL) {
        LsaFreeMemory( TrustEnumBuffer );
        }

    if (PolicyHandle != NULL) {
        LsaClose( PolicyHandle );
        }

    if (NT_SUCCESS( NtStatus )) {
        fprintf( stderr,
                 "NETJOIN: Computer == '%ws' joined the '%ws' domain.\n",
                 UnicodePassword,
                 UnicodeDomainName
               );
        return 0;
        }
    else {
        fprintf( stderr,
                 "NETJOIN: Computer == '%ws' unable to join the '%ws' domain - Status == %08x\n",
                 UnicodePassword,
                 UnicodeDomainName,
                 NtStatus
               );
        return 1;
        }
}


NTSTATUS
OpenAndVerifyLSA(
    IN OUT PLSA_HANDLE PolicyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPWSTR DomainName,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO * ReturnPrimaryDomainInfo OPTIONAL
    )
/*++

Routine Description:

    This function opens the local LSA policy and verifies that the LSA is
    configured for the workstation. Optionally it returns the primary
    domain information that is read form the LSA.

Arguments:

    LsaHandle - Pointer to location where the LSA handle will be retured.

    DesiredMask - Access mask used to open the LSA.

    DomainName - Name of the trusted domain.

    ReturnPrimaryDomainInfo - Primary domain info is returned here.

Return Value:

    Error code of the operation.

--*/
{
    NTSTATUS        NtStatus;

    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;

    OBJECT_ATTRIBUTES   ObjectAttributes;

    DWORD       PrimaryDomainNameLength;
    LPWSTR      PrimaryDomainName = NULL;

    //
    // open LSA

    *PolicyHandle = NULL;

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0,
                                NULL,
                                NULL
                              );

    NtStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              DesiredAccess,
                              PolicyHandle
                            );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "OpenAndVerifyLSA: LsaOpenPolicy", NtStatus );
        return NtStatus;
        }

    //
    // now read primary domain info from LSA.
    //

    NtStatus = LsaQueryInformationPolicy( *PolicyHandle,
                                          PolicyPrimaryDomainInformation,
                                          (PVOID *) &PrimaryDomainInfo
                                        );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "OpenAndVerifyLSA: LsaQueryInformationPolicy", NtStatus );
        return NtStatus;
        }


    //
    // compare domain names
    //

    PrimaryDomainNameLength = PrimaryDomainInfo->Name.Length + sizeof( WCHAR );
    PrimaryDomainName = malloc( PrimaryDomainNameLength );
    if (PrimaryDomainName == NULL) {
        NtStatus = STATUS_NO_MEMORY;
        FailureMessage( "OpenAndVerifyLSA: malloc", NtStatus );
        goto Cleanup;
        }

    RtlMoveMemory( PrimaryDomainName,
                   PrimaryDomainInfo->Name.Buffer,
                   PrimaryDomainInfo->Name.Length
                 );
    PrimaryDomainName[ PrimaryDomainInfo->Name.Length / sizeof(WCHAR) ] = UNICODE_NULL;
    if (_wcsicmp( DomainName, PrimaryDomainName )) {

        //
        // domain names don't match
        //

        NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        FailureMessage( "OpenAndVerifyLSA: wcsicmp", NtStatus );
        goto Cleanup;
        }


    NtStatus = STATUS_SUCCESS;

Cleanup:

    if (PrimaryDomainName != NULL) {
        free( PrimaryDomainName );
        }

    if (PrimaryDomainInfo != NULL) {
        if (ARGUMENT_PRESENT( ReturnPrimaryDomainInfo ) ) {
            if (NT_SUCCESS( NtStatus )) {

                *ReturnPrimaryDomainInfo = PrimaryDomainInfo;
            }
            else {

                LsaFreeMemory( PrimaryDomainInfo );
                *ReturnPrimaryDomainInfo = NULL;
            }
        }
        else {
            LsaFreeMemory( PrimaryDomainInfo );
            }
        }

    if (!NT_SUCCESS( NtStatus ) && *PolicyHandle != NULL) {
        //
        // close LSA if an error occurred.
        //

        LsaClose( *PolicyHandle );
        *PolicyHandle = NULL;
        }

    return NtStatus;
}


#if 0
NET_API_STATUS NET_API_FUNCTION
I_NetGetDCList(
    IN  LPWSTR ServerName OPTIONAL,
    IN  LPWSTR TrustedDomainName,
    OUT PULONG DCCount,
    OUT PUNICODE_STRING * DCNames
    );
#endif


NTSTATUS
AddATrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainAccountInfo,
    IN LPWSTR TrustedAccountSecret
    )
/*++

Routine Description:

    This function adds trusted domain account and a secret for the
    corresponding account in LSA. This function does not do any check
    before adding this account in LSA.

Arguments:

    PolicyHandle - LSA policy handle

    TrustedDomainAccountInfo - Pointer to the LSA_TRUST_INFORMATION structure.

    TrustedAccountSecret - Pointer to the secret for the trusted domain
                            account.

Return Value:

    Error code of the operation.

--*/
{

    NTSTATUS        NtStatus;

    LSA_HANDLE      TrustedDomainHandle = NULL;

    DWORD           DCCount;
    PUNICODE_STRING DCNames = NULL;

    TRUSTED_CONTROLLERS_INFO    TrustedControllersInfo;

    UNICODE_STRING  SecretName = {0, 0, NULL};
    LSA_HANDLE      SecretHandle = NULL;

    UNICODE_STRING  CurrentSecretValue;

    DWORD           UnicodeDomainNameLength;
    LPWSTR          UnicodeDomainName = NULL;

    NtStatus = LsaCreateTrustedDomain( PolicyHandle,
                                       TrustedDomainAccountInfo,
                                       TRUSTED_SET_CONTROLLERS | DELETE,
                                       &TrustedDomainHandle
                                     );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "AddATrustedDomain: LsaCreateTrustedDomain", NtStatus );
        return NtStatus;
        }

    //
    // Determine the DC List. This list will be stored in trusted domain
    // account.
    //
    // Specify the server name NULL, the domain name is the primary domain
    // of this workstation and so it must be listening DC announcements.
    //

    UnicodeDomainNameLength = TrustedDomainAccountInfo->Name.Length +
                                sizeof(WCHAR);
    UnicodeDomainName = malloc( UnicodeDomainNameLength );
    if (UnicodeDomainName == NULL) {
        NtStatus = STATUS_NO_MEMORY;
        FailureMessage( "AddATrustedDomain: malloc", NtStatus );
        goto Cleanup;
        }

    RtlMoveMemory( UnicodeDomainName,
                   TrustedDomainAccountInfo->Name.Buffer,
                   TrustedDomainAccountInfo->Name.Length
                 );

    UnicodeDomainName[ (UnicodeDomainNameLength / sizeof(WCHAR)) - 1 ] = '\0';

#if 0
    if (I_NetGetDCList( NULL,
                        UnicodeDomainName,
                        &DCCount,
                        &DCNames
                      )
       ) {
        //
        // if unable to find the DC list for the specified domain, set
        // the Dc list to null and proceed.
        //
        DCCount = 0;
        DCNames = NULL;
        }
#else
        DCCount = 0;
        DCNames = NULL;
#endif

    TrustedControllersInfo.Entries = DCCount;
    TrustedControllersInfo.Names = DCNames;

    //
    // set controller info in trusted domain object.
    //

    NtStatus = LsaSetInformationTrustedDomain( TrustedDomainHandle,
                                               TrustedControllersInformation,
                                               &TrustedControllersInfo
                                             );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "AddATrustedDomain: LsaSetInformationTrustedDomain", NtStatus );
        goto Cleanup;
        }

    //
    // Add a secret for this trusted account
    //

    MakeNetlogonSecretName( &SecretName );
    NtStatus = LsaCreateSecret( PolicyHandle,
                                &SecretName,
                                SECRET_SET_VALUE,
                                &SecretHandle
                              );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "AddATrustedDomain: LsaCreateSecret", NtStatus );
        goto Cleanup;
        }


    RtlInitUnicodeString( &CurrentSecretValue, TrustedAccountSecret );
    NtStatus = LsaSetSecret( SecretHandle,
                             &CurrentSecretValue,
                             &CurrentSecretValue
                           );

Cleanup:

    if (DCNames != NULL) {
        free( DCNames );
        }

    if (UnicodeDomainName != NULL) {
        free( UnicodeDomainName );
        }

    if (SecretHandle != NULL) {
        if (!NT_SUCCESS( NtStatus)) {

            //
            // since we are not successful completely to create the trusted
            // account, delete it.
            //

            LsaDelete( SecretHandle );
            }
        else {
            LsaClose( SecretHandle );
            }
        }


    if (TrustedDomainHandle != NULL) {
        if (!NT_SUCCESS( NtStatus)) {
            //
            // since we are not successful completely to create the trusted
            // account, delete it.
            //

            LsaDelete( TrustedDomainHandle );
            }
        else {
            LsaClose( TrustedDomainHandle );
            }
        }

    return NtStatus;
}


NTSTATUS
DeleteATrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainAccountInfo
    )
/*++

Routine Description:

    This function deletes a trusted domain account and the corresponding
    secret from LSA. This function however does not check any conditions
    before deleting this account.

Arguments:

    PolicyHandle - LSA policy handle

    TurstedDoaminAccountInfo - Pointer to the LSA_TRUST_INFORMATION structure.

Return Value:

    Error code of the operation.

--*/
{

    NTSTATUS        NtStatus;

    LSA_HANDLE      TrustedDomainHandle = NULL;
    LSA_HANDLE      SecretHandle = NULL;

    UNICODE_STRING  SecretName = { 0, 0, NULL };

    MakeNetlogonSecretName( &SecretName );

    //
    // open trusted domain account secret
    //

    NtStatus = LsaOpenSecret(
                    PolicyHandle,
                    &SecretName,
                    DELETE,
                    &SecretHandle );

    if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {
        if (!NT_SUCCESS( NtStatus )) {
            FailureMessage( "DeleteATrustedDomain: LsaOpenSecret", NtStatus );
            goto Cleanup;
            }

        LsaDelete( SecretHandle );
        }

    //
    // open trusted domain account
    //

    NtStatus = LsaOpenTrustedDomain(
                    PolicyHandle,
                    TrustedDomainAccountInfo->Sid,
                    DELETE,
                    &TrustedDomainHandle );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "DeleteATrustedDomain: LsaOpenTrustedDomain", NtStatus );
        goto Cleanup;
        }

    LsaDelete( TrustedDomainHandle );

Cleanup:

    return NtStatus;

}

NTSTATUS
MakeNetlogonSecretName(
    IN OUT PUNICODE_STRING SecretName
    )
/*++

Routine Description:

    This function makes a secret name that is used for the netlogon.

Arguments:

    SecretName - Pointer to a unicode structure in which the netlogon
                    secret name will be returned.

Return Value:

    NERR_Success;

--*/
{

    SecretName->Length = wcslen(SSI_SECRET_NAME) * sizeof(WCHAR);
    SecretName->MaximumLength = SecretName->Length + 2;
    SecretName->Buffer = SSI_SECRET_NAME;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\action.cpp ===
//  ACTION.C -- routines called by the parser
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains the routines called during parsing of a makefile.
//
// Revision History:
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  13-Feb-1990 SB  nextComponent() missed out mixed case of quoted/non-quote list
//  02-Feb-1990 SB  Add nextComponent() for Longfilename handling
//  08-Dec-1989 SB  removed local used without initialization warnings for -Oes
//  07-Dec-1989 SB  removed register to compile using C6 -Oes (warning gone)
//  06-Dec-1989 SB  changed expandFileNames() type to void instead of void *
//  22-Nov-1989 SB  Changed free() to FREE()
//  13-Nov-1989 SB  Removed an unreferenced local in endNameList()
//  02-Oct-1989 SB  add dynamic inline file handling support
//  04-Sep-1989 SB  Add A_DEPENDENT and fix macro inheritance
//  24-Aug-1989 SB  Allow $* on dependency lines
//  14-Jul-1989 SB  Environment macro was getting updated even when CMDLINE
//                  macro was present
//  29-Jun-1989 SB  addItemToList() now maintains Global inline file List
//  26-Jun-1989 SB  Fixed -e for recursive NMAKE
//  22-May-1989 SB  NZ options work independently. -NZ does both stuff now
//  13-May-1989 SB  Changed delList to contain just names of files and no "del "
//  14-Apr-1989 SB  made targetList NEAR, no 'del inlinefile' cmd for -n now
//  05-Apr-1989 SB  Added parameters to makeRule() & makeTarget(); this get rid
//                  of globals
//  03-Apr-1989 SB  changed all functions to NEAR to get them into one module
//  21-Mar-1989 SB  changed assignDependents() and assignCommands() to handle
//                  multiple target case correctly.
//  20-Mar-1989 SB  startNamelist() doesn't flag error if target macro is null
//                  and >1 target given; commented startNameList()
//  16-Feb-1989 SB  addItemToList() now appends to delList instead of List so
//                  that all 'del scriptFile' cmds can be at the end of the make
//  29-Jan-1989 SB  added targList but not used as yet
//  19-Jan-1989 SB  changed startNameList() to avoid GP fault, bug# 162
//  18-Jan-1989 SB  modified endNameList(), added makeList() and makeBuildList()
//                  and added a parameter to makeTarget() for bug# 161
//  21-Dec-1988 SB  use scriptFileList to handle multiple scriptFiles
//                  Improve KEEP/NOKEEP;each file can have its own action
//  16-Dec-1988 SB  addItemToList() is now equipped for KEEP/NOKEEP
//  14-Dec-1988 SB  addItemToList() modified for 'Z' option -- adds a delete
//                  command for deleting temporary script files
//   5-Nov-1988 RB  Fixed macro inheritance for recursive definitions.
//  27-Oct-1988 SB  put malloc for allocate in putEnvStr() -- error checking
//  23-Oct-1988 SB  Using putEnvStr() for putenv() to simplify code
//  21-Oct-1988 SB  Added fInheritUserEnv flag modifications to makeMacro()
//                  and putMacro() for macro inheritance
//  19-Sep-1988 RB  Remove warning for MAKE redefinition.
//  22-Aug-1988 RB  Clean up for !UNDEF'ed macros.
//  17-Aug-1988 RB  Clean up.
//  14-Jul-1988 rj  Added initialization of dateTime field of BUILDBLOCKs.
//   7-Jul-1988 rj  Added targetFlag parameter to hash() calls.
//                  Fixed bug: redefined macros didn't get flags reset.
//  09-May-1988 rb  Don't swallow no-match wildcards.

#include "precomp.h"
#pragma hdrstop

void       startNameList(void);
void       makeRule(STRINGLIST *, BOOL fBatch);
void       makeTarget(char*, BOOL, BUILDBLOCK**);
void       appendPseudoTargetList(STRINGLIST**, STRINGLIST*);
void       clearSuffixes(void);
BOOL       doSpecial(char*);
BUILDLIST  * makeBuildList(BUILDBLOCK *);
char     * nextComponent(char **);

// created by endNameList() & freed by assignBuildCommands(). In use because
// although global 'list' has this list is used by too many routines and the
// complete sequence of actions on 'list' is unknown

STRINGLIST    * targetList;         // corr to a dependency block


//  makeName -- create copy of a name seen by lexer
//
// Purpose:
//  Create a copy of a macro or 1st name in a target/dependency list. It also
//  does the groundwork for expansion of macros in name and saves values.
//
// Assumes: That the lexical routines save the token in buf
//
// Modifies Globals:
//  name   -- the pointer to the copy created, gets allocated memory
//  macros -- the list of macro values in name. Used later by startNameList()
//           to expand macros in name and get expanded target name.
//
// Uses Globals:
//  buf    -- the lexical routines return a token in this
//
// Notes:
//  The token in buf could be part of a macrodefinition or a target list. The
//  next token determines if it is a macrodefn or a targetlist we are parsing.
//  The next token would overwrite the current token and so it is saved in name.

void
makeName()
{
    findMacroValues(buf, &macros, NULL, NULL, 0, 0, 0);
    name = makeString(buf);
}


// don't expand build lines for rules now -- expand after everything read in
// that way CC and CFLAGS used in rules from tools.ini but not defined until
// the makefile will have appropriate values.    Redefining macros for use
// in targets w/o explicit build commands doesn't work.  Macros in rules have
// the value of their last definition in the makefile.

void
addItemToList()
{
    STRINGLIST *p;                  // from lexer
    STRINGLIST *NewList;

    if (name) {
        SET(actionFlags, A_TARGET);
        startNameList();
        name = NULL;
    }
    if (ON(actionFlags, A_TARGET)) {
        if (isRule(buf)) {
            if (ON(actionFlags, A_RULE))
                makeError(currentLine, TOO_MANY_RULE_NAMES);
            makeError(currentLine, MIXED_RULES);
        }
    }
    p = makeNewStrListElement();
    if (ON(actionFlags, A_STRING)) {    // we collect macros
        p->text = string;               // for dependents &
        string = NULL;                  // build lines for
    } else                              // non-implicit rules
        p->text = makeString(buf);

    NewList = p;                        // build lines for
    if (OFF(actionFlags, A_RULE)        // rules get expanded
        || ON(actionFlags, A_TARGET))   // after entire make-
    {
        findMacroValues(p->text, &macros, NULL, NULL, 0, 0, 0); //  file parsed
    }

    if (ON(actionFlags, A_TARGET)) {
        p = macros;
        expandFileNames("$", &NewList, &macros);
        expandFileNames("*?", &NewList, NULL);
        while (macros = p) {
            p = p->next;
            FREE_STRINGLIST(macros);
        }
    }

    appendItem(&list, NewList);
}


//  startNameList -- puts in the first element into list
//
// Scope:           Local.
//
// Purpose:         Puts in the first name seen into a list
//
// Errors/Warnings: TARGET_MACRO_IS_NULL -- if the macro used as a target expands to null
//
// Assumes:
//  The global 'list' is originally a null list, & the global 'macro' points to
//  a list of values used for expanding the macros in global 'name'.
//
// Modifies Globals:
//  list    -- the list of names; set to contain the first name here or to a
//             list of values if 'name' contains a macro invocation.
//  macros  -- the list of values reqd for macro expansion; the list is
//             freed and macros is made NULL
//  currentFlags -- the flags for current target; set to global flags
//  actionFlags  -- determine actions to be done; if the name is a rule then set
//                  the rule bit
//
// Uses Globals:
//  name        -- the first name seen in a list of names.
//  flags       -- the global flags setup by the options specified
//  actionFlags -- if handling targets then no error as we have > 1 target
//
// Notes:
//  If there is more than one target then actionFlags has A_TARGET flag set and
//  startNameList() is called from addItemToList. In this case don't flag error.

void
startNameList()
{
    STRINGLIST *p;

    currentFlags = flags;               // set flags for cur target
    p = makeNewStrListElement();
    p->text = name;
    list = p;                           // list contains name
    p = macros;
    expandFileNames("$", &list, &macros);   // expand macros in name
    expandFileNames("*?", &list, NULL);     // expand wildcards
    while (macros = p) {                    // free macro list
        p = p->next;
        FREE_STRINGLIST(macros);
    }
    if (!list && OFF(actionFlags, A_TARGET))
        makeError(line, TARGET_MACRO_IS_NULL, name);    // target null & 1 target

    if (list && isRule(list->text))
        SET(actionFlags, A_RULE);
}


//  endNameList -- semantic actions when a list is fully seen
//
// Purpose:
//  When the parser has seen an entire list then it needs to do some semantic
//  actions. It calls endNameList() to do these actions. The action depends on
//  the values in certain globals.
//
// Modifies Globals:    actionFlags --
//
// Uses Globals:
//  name         -- The first element seen (if non null)
//  actionFlags  -- The flag determining semantic & data structure actions
//  buf          -- The delimiter seen after list
//  list         -- The list of elements seen

void
endNameList()
{
    if (name) {                     // if only one name to left of :
        startNameList();            // it hasn't been put in list yet
        name = NULL;
    } else
        CLEAR(actionFlags, A_TARGET);       // clear target flag

    if (buf[1])
        SET(currentFlags, F2_DOUBLECOLON);  //  so addItemToList()

    if (!list)                                          //  won't expand names
        makeError(currentLine, SYNTAX_NO_TARGET_NAME);  //  of dependents

    if (ON(actionFlags, A_RULE)) {
		BOOL fBatch;
		// A rule with a doublecolon on the dependency line
		// is a "batch rule", i.e., a rule that applies the 
		// command block in batch mode for all affected 
		// dependents.  
        fBatch = !!(ON(currentFlags, F2_DOUBLECOLON));
        makeRule(list, fBatch);
        FREE_STRINGLIST(list);
    }
    else if (!(list->next) && doSpecial(list->text)) { // special pseudotarget ...
        FREE(list->text);           // don't need ".SUFFIXES" etc
        FREE_STRINGLIST(list);
    }
    else                            // regular target
        targetList = list;

    list = NULL;
    // We are now looking for a dependent
    SET(actionFlags, A_DEPENDENT);
}


BOOL
doSpecial(
    char *s)
{
    BOOL status = FALSE;

    if (!_tcsicmp(s, silent)) {
        SET(actionFlags, A_SILENT);
        setFlags('s', TRUE);
        status = TRUE;
    }

    if (!_tcsicmp(s, ignore)) {
        SET(actionFlags, A_IGNORE);
        setFlags('i', TRUE);
        status = TRUE;
    }
    else if (!_tcscmp(s, suffixes)) {
        SET(actionFlags, A_SUFFIX);
        status = TRUE;
    }
    else if (!_tcscmp(s, precious)) {
        SET(actionFlags, A_PRECIOUS);
        status = TRUE;
    }
    return(status);
}


void
expandFileNames(
    char *string,
    STRINGLIST **sourceList,
    STRINGLIST **macroList
    )
{
    char *s,
     *t = NULL;
    STRINGLIST *p;                  // Main list pointer
    STRINGLIST *pNew,               // Pointer to new list
               *pBack;              // Pointer to one element back
    char *saveText = NULL;

    for (pBack = NULL, p = *sourceList; p;) {

        // If no expand-character is found, continue to next list element.
        if (!_tcspbrk(p->text, string)) {
            pBack = p;
            p = pBack->next;
            continue;
        }

        // Either expand macros or wildcards.
        if (*string == '$') {
            t = expandMacros(p->text, macroList);
            FREE(p->text);
        } else {

            // If the wildcard string does not expand to anything, go to
            // next list elment.  Do not remove p from the original list
            // else we must check for null elsewhere.

            // CAVIAR 3912 -- do not attempt to expand wildcards that
            // occur in inference rules [rm]

            if (isRule(p->text) || (pNew = expandWildCards(p->text)) == NULL) {
                pBack = p;
                p = pBack->next;
                continue;
            }
            saveText = p->text;
        }

        // At this point we have a list of expanded names to replace p with.
        if (pBack) {
            pBack->next = p->next;
            FREE_STRINGLIST(p);
            p = pBack->next;
        } else {
            *sourceList = p->next;
            FREE_STRINGLIST(p);
            p = *sourceList;
        }

        if (*string == '$') {       // if expanding macros
            char *str = t;
            if (s = nextComponent(&str)) {
                do {                // put expanded names
                    pNew = makeNewStrListElement();     //  at front of list
                    pNew->text = makeString(s);         //  so we won't try to
                    prependItem(sourceList, pNew);      //  re-expand them
                    if (!pBack)
                        pBack = pNew;
                } while (s = nextComponent(&str));
            }
            FREE(t);
            continue;
        }
        else if (pNew) {            // if matches for * ?
            // Wild cards within Quoted strings will fail
            if (!pBack)
                for (pBack = pNew; pBack->next; pBack = pBack->next)
                    ;
            appendItem(&pNew, *sourceList);     // put at front of old list
            *sourceList = pNew;
        }
        FREE(saveText);
    }
}


//  nextComponent - returns next component from expanded name
//
// Scope:   Local (used by expandFilenames)
//
// Purpose:
//  Given a target string (target with macros expanded) this function returns a
//  name component. Previously _tcstok(s, " \t") was used but with the advent of
//  quoted filenames this is no good.
//
// Input:   szExpStr - the target name with macros expanded
//
// Output:  Returns pointer to next Component; NULL means no more components left.
//
// Assumes: That that two quoted strings are seperated by whitespace.

char *
nextComponent(
    char **szExpStr
    )
{
    char *t, *next;

    t = *szExpStr;

    while (WHITESPACE(*t))
        t++;

    next = t;
    if (!*t)
        return(NULL);

    if (*t == '"') {
        for (; *++t && *t != '"';)
            ;
    } else {
        for (; *t && *t != ' ' && *t != '\t'; t++)
            ;
    }

    if (WHITESPACE(*t)) {
        *t = '\0';
    } else if (*t == '"') {
        t++;
        if(*t=='\0') t--;   // If this is the end of the string, backup a byte, so we don't go past next time
            else *t = '\0';	    // else stop here for this time.
    } else if (!*t) {
        // If at end of string then backup a byte so that next time we don't go past
        t--;
    }

    *szExpStr = t+1;
    return(next);
}


// append dependents to existing ones (if any)
void
assignDependents()
{
    const char *which = NULL;

    if (ON(actionFlags, A_DEPENDENT))
        CLEAR(actionFlags, A_DEPENDENT);

    if (ON(actionFlags, A_RULE)) {
        if (list)
            makeError(currentLine, DEPENDENTS_ON_RULE);
    }
    else if (ON(actionFlags, A_SILENT) || ON(actionFlags, A_IGNORE)) {
        if (list) {
            if (ON(actionFlags, A_SILENT))
                which = silent;
            else if (ON(actionFlags, A_IGNORE))
                which = ignore;
            makeError(currentLine, DEPS_ON_PSEUDO, which);
        }
    }
    else if (ON(actionFlags, A_SUFFIX)) {
        if (!list)
            clearSuffixes();
        else
            appendPseudoTargetList(&dotSuffixList, list);
    }
    else if (ON(actionFlags, A_PRECIOUS)) {
        if (list)
            appendPseudoTargetList(&dotPreciousList, list);
    }
    else {
        block = makeNewBuildBlock();
        block->dependents = list;
        block->dependentMacros = macros;
    }
    list = NULL;
    macros = NULL;
    SET(actionFlags, A_STRING);             // expecting build cmd
}

void
assignBuildCommands()
{
    BOOL okToFreeList = TRUE;
    BOOL fFirstTarg = (BOOL)TRUE;
    STRINGLIST *p;
    const char *which = NULL;

    if (ON(actionFlags, A_RULE))        // no macros found yet for inference rules
        rules->buildCommands = list;
    else if (ON(actionFlags, A_SILENT) ||
             ON(actionFlags, A_IGNORE) ||
             ON(actionFlags, A_PRECIOUS) ||
             ON(actionFlags, A_SUFFIX)
            ) {
        if (list) {
            if (ON(actionFlags, A_SILENT))
                which = silent;
            else if (ON(actionFlags, A_IGNORE))
                which = ignore;
            else if (ON(actionFlags, A_PRECIOUS))
                which = precious;
            else if (ON(actionFlags, A_SUFFIX))
                which = suffixes;
            makeError(currentLine, CMDS_ON_PSEUDO, which);
        }
    } else {
        block->buildCommands = list;
        block->buildMacros = macros;
        block->flags = currentFlags;
        while (p = targetList) {                        // make a struct for each targ
            if (doSpecial(p->text))                     // in list, freeing list when
                makeError(currentLine, MIXED_TARGETS);
            makeTarget(p->text, fFirstTarg, &block);    // done, don't free name
            if (!makeTargets) {                         // field -- it's still in use
                makeTargets = p;                        // if no targs given on cmdlin
                okToFreeList = FALSE;                   // put first target(s) from
            }                                           // mkfile in makeTargets list
            targetList =  p->next;                      // (makeTargets defined in
            if (okToFreeList)                           // nmake.c)
                FREE_STRINGLIST(p);
            if (fFirstTarg)
                fFirstTarg = (BOOL)FALSE;
        }
    }
    targetList = NULL;
    list = NULL;
    macros = NULL;
    block = NULL;
    actionFlags = 0;
}

//  makeMacro -- define macro with name and string taken from global variables
//
// Modifies:
//  fInheritUserEnv    set to TRUE
//
// Notes:
//  Calls putMacro() to place expanded Macros in the NMAKE table. By setting
//  fInheritUserEnv those definitions that change Environment variables are
//  inherited by the environment.

void
makeMacro()
{
    STRINGLIST *q;
    char *t;

    if (_tcschr(name, '$')) {              // expand name
        q = macros;
        t = expandMacros(name, &macros);    // name holds result
        if (!*t)                            // error if macro to left of = is undefined
            makeError(currentLine, SYNTAX_NO_MACRO_NAME);
        while (macros = q) {
            q = q->next;
            FREE_STRINGLIST(macros);
        }
        FREE(name);
        name = t;
    }

    for (t = name; *t && MACRO_CHAR(*t); t = _tcsinc (t))   // Check for illegal chars
        ;

    if (*t)
        makeError(currentLine, SYNTAX_BAD_CHAR, *t);

    fInheritUserEnv = (BOOL)TRUE;

    // Put Env Var in Env & macros in table.

    if (!putMacro(name, string, 0)) {
        FREE(name);
        FREE(string);
    }
    name = string = NULL;
}


//  defineMacro -- check macro's syntax for illegal chars., then define it
//
//  actions:    check all of macro's characters
//        if one's bad and it's an environment macro, bag it
//            else flag error
//        call putMacro to do the real work
//
// can't use macro invocation to left of = in macro def from commandline
//  it doesn't make sense to do that, because we're not in a makefile
//  the only way to get a comment char into the makefile w/o having it really
//  mark a comment is to define a macro A=# on the command line

BOOL
defineMacro(
    char *s,                        // commandline or env definitions
    char *t,
    UCHAR flags
    )
{
    char *u;

    for (u = s; *u && MACRO_CHAR(*u); u = _tcsinc(u))  // check for illegal
        ;
    if (*u) {
        if (ON(flags, M_ENVIRONMENT_DEF)) { // ignore bad macros
            return(FALSE);
        }
        makeError(currentLine, SYNTAX_BAD_CHAR, *u);    // chars,  bad syntax
    }
    return(putMacro(s, t, flags));          // put macro in table
}


//  putMacro - Put the macro definition into the Macro Table / Environmnet
//
// Scope:
//  Global.
//
// Purpose:
//  putMacro() inserts a macro definition into NMAKE's macro table and also into
//  the environment. If a macro name is also an environment variable than its
//  value is inherited into the environment. While replacing older values by new
//  values NMAKE needs to follow the precedence of macro definitions which is
//  as per the notes below.
//
// Input:
//  name  - Name of the macro
//  value - Value of the macro
//  flags - Flags determining Precedence of Macro definitions (see Notes)
//
// Output:
//
// Errors/Warnings:
//  OUT_OF_ENV_SPACE - If putenv() returns failure in adding to the environment.
//
// Assumes:
//  Whatever it assumes
//
// Modifies Globals:
//  fInheritUserEnv - Set to False.
//
// Uses Globals:
//  fInheritUserEnv  - If True then Inherit definition to the Environment.
//  gFlags           - Global Options Flag. If -e specified then Environment Vars
//                       take precedence.
//  macroTable       - NMAKE's internal table of Macro Definitions.
//
// Notes:
//  1> If the same macro is defined in more than one place then NMAKE uses the
//     following order of Precedence (highest to lowest) --
//
//     -1- Command line definitions
//     -2- Description file/Include file definitions
//     -3- Environment definitions
//     -4- TOOLS.INI definitions
//     -5- Predefined Values (e.g. for CC, AS, BC, RC)
//     If -e option is specified then -3- precedes -2-.
//
//  2> Check if the macro already exists in the Macro Table. If the macro is not
//     redefinable (use order of precedence) then return. Make a new string
//     element to hold macro's new value. If the macro does not exist then create
//     new entry in the Macro table. Set Macro's flag to be union of Old and new
//     values. Add the new value to macro's value entry. If a new macro then add
//     it to the macro table. Test for Cyclic definitions.
//
// Undone/Incomplete:
//  1> Investigate into possibility of removing fInheritUserEnv variable.
//      Can be done. Use CANT_REDEFINE(p) || OFF((A)->flags,M_ENVIRONMENT_DEF)
//  2> Probably should warn when $(MAKE) is being changed.

BOOL
putMacro(
    char *name,
    char *value,
    UCHAR flags
    )
{
    MACRODEF *p;
    STRINGLIST *q;
    BOOL defined = FALSE;
    BOOL fSyntax = TRUE;

    // Inherit macro definitions.  Call removeMacros() to expand sub-macro
    // definitions.  Must be done before macro is put in table, else
    // recursive definitions won't work.

    if (ON(flags, M_NON_RESETTABLE)) {
        if (*value)
            if ((putEnvStr(name,removeMacros(value)) == -1))
                makeError(currentLine, OUT_OF_ENV_SPACE);
    } else
    if (fInheritUserEnv &&
        OFF(gFlags, F1_USE_ENVIRON_VARS) &&
        getenv(name)
       ) {
        if (p = findMacro(name)) {  // don't let user
            if (CANT_REDEFINE(p))   // redefine cmdline
                return(FALSE);      // macros, MAKE, etc.
        }
        if ((putEnvStr(name,removeMacros(value)) == -1))
            makeError(currentLine, OUT_OF_ENV_SPACE);
    }

    fInheritUserEnv = (BOOL)FALSE;
    if (p = findMacro(name)) {      // don't let user
        if (CANT_REDEFINE(p))       // redefine cmdline
            return(FALSE);          // macros, MAKE, etc.
    }

    q = makeNewStrListElement();
    q->text = value;

    if (!p) {
        p = makeNewMacro();
        p->name = name;
        assert(p->flags == 0);
        assert(p->values == NULL);
    } else
        defined = TRUE;

    p->flags &= ~M_UNDEFINED;       // Is no longer undefined
    p->flags |= flags;              // Set flags to union of old and new
    prependItem((STRINGLIST**)&(p->values), (STRINGLIST*)q);
    if (!defined)
        insertMacro((STRINGLIST*)p);

    if (OFF(flags, M_LITERAL) && _tcschr(value, '$')) {     // Check for cyclic Macro Definitions
        SET(p->flags, M_EXPANDING_THIS_ONE);
        // NULL -> don't build list
        fSyntax = findMacroValues(value, NULL, NULL, name, 1, 0, flags);
        CLEAR(p->flags, M_EXPANDING_THIS_ONE);
    }

    if (!fSyntax) {
        p->values = NULL;
        p->flags |= M_UNDEFINED;
        //return(FALSE);
		// return TRUE since p has been added to the macro table
		// Otherwise the caller may free name and value leaving
		// dangling pointers in the macro table. [DS 18040]
		return(TRUE);
    }
    return(TRUE);
}


//  makeRule -- makes an inference rule
//
// Scope:
//  Local
//
// Purpose:
//  Allocates space for an inference rule and adds rule to the beginning of the
//  doubly linked inference rule list. The name of the rule is also added.
//
// Input:
//  rule -- The name of the inference rule
//	fBatch -- True if command block should be executed in batch mode
//
// Output:
//
// Errors/Warnings:
//
// Assumes:
//
// Modifies Globals:
//  rules -- The doubly linked inference rule list to which the rule is added
//
// Uses Globals:
//
// Notes:
//  The syntax of an inference rule is --
//
//  {frompath}.fromext{topath}.toext:    # Name of the inference rule
//      command ...                      # command block of the inference rule

void
makeRule(
    STRINGLIST *rule,
	BOOL fBatch
    )
{
    RULELIST *rList;

    rList = makeNewRule();
    rList->name = rule->text;
	rList->fBatch = fBatch;
    prependItem((STRINGLIST**)&rules, (STRINGLIST*)rList);
    if (rList->next)
        rList->next->back = rList;
}


//  makeTarget -- add target to targetTable
//
//  actions:    if no block defined, create one and initialize it
//        make new build list entry for this target
//        if the target's already in the table,
//            flag error if : and :: mixed
//            else add new buildlist object to target's current buildlist
//        else allocate new object, initialize it, and stick it in table

void
makeTarget(
    char *s,
    BOOL firstTarg,
    BUILDBLOCK **block
    )
{
    BUILDLIST  *build;
    MAKEOBJECT *object;

    if (!*block)
        *block = makeNewBuildBlock();

    if (firstTarg) {
        build = makeNewBldListElement();
        build->buildBlock = *block;
    } else
        build = makeBuildList(*block);

    if (object = findTarget(s)) {
        if (ON(object->flags2, F2_DOUBLECOLON) != ON(currentFlags, F2_DOUBLECOLON))
            makeError(currentLine, MIXED_SEPARATORS);
        appendItem((STRINGLIST**)&(object->buildList), (STRINGLIST*)build);
        FREE(s);
    } else {
        build->next = NULL;
        object = makeNewObject();
        object->name = s;
        object->buildList = build;
        object->flags2 = currentFlags;
        prependItem((STRINGLIST**)targetTable+hash(s, MAXTARGET, (BOOL)TRUE),
                    (STRINGLIST*)object);
    }
}


void
clearSuffixes()
{
    STRINGLIST *p;

    while (p = dotSuffixList) {
    dotSuffixList = dotSuffixList->next;
    FREE(p->text);
    FREE_STRINGLIST(p);
    }
}


void
appendPseudoTargetList(
    STRINGLIST **pseudo,
    STRINGLIST *list
    )
{
    STRINGLIST  *p, *q, *r;
    char *t, *u;

    while (p = list) {
        if (!_tcschr(p->text, '$')) {
            list = list->next;
            p->next = NULL;
            appendItem(pseudo, p);
        } else {
            r = macros;
            t = expandMacros(p->text, &macros);
            while (r != macros) {
                q = r->next;
                FREE_STRINGLIST(r);
                r = q;
            }
            for (u = _tcstok(t, " \t"); u; u = _tcstok(NULL, " \t")) {
                q = makeNewStrListElement();
                q->text = makeString(u);
                appendItem(pseudo, q);
            }
            FREE(t);
            FREE(p->text);
            list = list->next;
            FREE_STRINGLIST(p);
        }
    }
}

//  putEnvStr -- Extends putenv() standard function
//
// Purpose:
//  Library function putenv() expects one string argument of the form
//    "NAME=value"
//  Most of the times when putenv() is to be used we have two strings
//    name   -- of the variable to add to the environment, and
//    value  -- to be set
//  putEnvStr takes these 2 parameters and calls putenv with the reqd
//  format
//
// Input:
//  name  -- of var to add to the env
//  value -- reqd to be set
//
// Output:
//  Same as putenv()

int
putEnvStr(
    char *name,
    char *value
    )
{
   char *envPtr;
   envPtr = (char *)rallocate(_tcslen(name)+1+_tcslen(value)+1);
//                                         ^                 ^
//                                    for '='             for '\0'

   return(PutEnv(_tcscat(_tcscat(_tcscpy(envPtr, name), "="), value)));
}


//  makeBuildList -- takes a build block and copies into a buildlist
//
// Purpose:
//  Routine creates a copy of a buildlist and returns a pointer to a copy.
//  When multiple targets have the same description block then there is a
//  need for each of them to get seperate build blocks. makeBuildList()
//  helps achieve this by creating a copy for each target.
//
// Input:
//  bBlock  --  the build block whose copy is to be added to a build block
//
// Output:
//  Returns a pointer to the copy of buildlist it creates

BUILDLIST *
makeBuildList(
    BUILDBLOCK *bBlock
    )
{
    BUILDLIST *tList = makeNewBldListElement();
    BUILDBLOCK *tBlock = makeNewBuildBlock();

    tBlock->dependents = bBlock->dependents;
    tBlock->dependentMacros = bBlock->dependentMacros;
    tBlock->buildCommands = bBlock->buildCommands;
    tBlock->buildMacros = bBlock->buildMacros;
    tBlock->flags = bBlock->flags;
    tBlock->dateTime = bBlock->dateTime;

    tList->buildBlock = tBlock;
    return(tList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\charmap.h ===
//
// Access to charmap functions
//
#define OPERATORMSK 0x80        // Is this character the startof an operator
#define LX_OPERATOR 0x80
#define IS_OPERATORCHAR(c) ((Charmap[(UCHAR)(c)] & OPERATORMSK) != 0)

#define MACROMSK 0x01           // Is this character a valid macro character
#define LX_MACRO 0x01
#define IS_MACROCHAR(c) ((Charmap[(UCHAR)(c)] & MACROMSK) != 0)

#define LX_EOS      0x00
#define LX_ILL      0x00
#define LX_WHITE    0x00
#define LX_NL       0x00
#define LX_CR       0x00
#define LX_DQUOTE   0x00
#define LX_POUND    0x00
#define LX_ASCII    0x00
#define LX_SQUOTE   0x00
#define LX_COMMA    0x00
#define LX_MINUS    0x00
#define LX_DOT      0x00
#define LX_NUMBER   0x00
#define LX_COLON    0x00
#define LX_SEMI     0x00
#define LX_EACH     0x00
#define LX_ID       0x00
#define LX_OBRACK   0x00
#define LX_CBRACK   0x00
#define LX_OBRACE   0x00
#define LX_CBRACE   0x00

#define CHARMAP_SIZE 256

extern UCHAR Charmap[CHARMAP_SIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\build.cpp ===
//  BUILD.C -- build routines
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains routines to build targets
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  18-Jul-1996 GP  Support "batch" inference rules
//  15-Nov-1993 JR  Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  04-Aug-1993 HV  Fixed Ikura bug #178.  This is a separate bug but ArunJ
//                  just reopen 178 anyway.
//  07-Jul-1993 HV  Fixed Ikura bug #178: Option K does not give non zero
//                  return code when it should.
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Jun-1992 SS  Port to DOSX32
//  16-May-1991 SB  Truncated History ... rest is now on SLM
//  16-May-1991 SB  Separated parts that should be in other modules

#include "precomp.h"
#pragma hdrstop

//  In order to make comparing dates easier, we cast the FILEINFO buffer to
//  be of type BOGUS, which has one long where the two unsigneds (for date
//  and time) are in the original buffer.  That way only need a single compare.

#ifdef CHECK_RECURSION_LEVEL
#define MAXRECLEVEL 10000                // Maximum recursion level
#endif

// function prototypes for the module
// I make as many things static as possible, just to be extra cautious


int          build(MAKEOBJECT*, UCHAR, time_t *, BOOL, char *, BATCHLIST**);

MAKEOBJECT * makeTempObject(char*, UCHAR);
void         insertSort(DEPLIST **pDepList, DEPLIST *pElement);
BOOL         nextToken(char**, char**);
DEPLIST    * createDepList(BUILDBLOCK *pBlock, char *objectName);
void         addBatch(BATCHLIST **pBatchList, RULELIST *pRule,
                            MAKEOBJECT *pObject, char *dollarLt);
int          doBatchCommand (BATCHLIST *pBatch);
int RecLevel = 0;           // Static recursion level.  Changed from function
                            // parameter because of treatment of recursive makes.
int   execBatchList(BATCHLIST *);
void  freeBatchList(BATCHLIST **);
int   invokeBuildEx(char *, UCHAR, time_t *, char *, BATCHLIST **);

// we have to check for expansion on targets -- firstTarget had to be
// expanded earlier to tell whether or not we were dealing w/ a rule, etc.,
// but targets from commandline might have macros, wildcards in them

int
processTree()
{
    STRINGLIST *p;
    char *v;
    NMHANDLE searchHandle;
    int status;
    time_t dateTime;

    for (p = makeTargets; p; p = makeTargets) {
        if (_tcspbrk(makeTargets->text, "*?")) {   // expand wildcards
            struct _finddata_t finddata;
            char *szFilename;

            if (szFilename = findFirst(makeTargets->text, &finddata, &searchHandle)) {
                do {
                    v = prependPath(makeTargets->text, szFilename);
                    dateTime = getDateTime(&finddata);
                    status = invokeBuild(v, flags, &dateTime, NULL);
                    FREE(v);
                    if ((status < 0) && (ON(gFlags, F1_QUESTION_STATUS))) {
                        freeStringList(p);  // Was not being freed
                        return(-1);
                    }
                } while (szFilename = findNext(&finddata, searchHandle));
            } else {
                makeError(0, NO_WILDCARD_MATCH, makeTargets->text);
            }
        } else {
            dateTime = 0L;
            status = invokeBuild(makeTargets->text, flags, &dateTime, NULL);
            if ((status < 0) && (ON(gFlags, F1_QUESTION_STATUS))) {
                freeStringList(p);          // Was not being freed
                return(255);    // Haituanv: change -1 to 255 to follow the manual
            }
        }
        makeTargets = p->next;
        FREE_STRINGLIST(p);
    }
    return(0);
}

int
invokeBuild(
    char *target,
    UCHAR pFlags,
    time_t *timeVal,
    char *pFirstDep)
{
    int status = 0;
    BATCHLIST *pLocalBatchList = NULL;
    status += invokeBuildEx(target,
                    pFlags,
                    timeVal,
                    pFirstDep,
                    &pLocalBatchList);

    if (pLocalBatchList) {
        status += execBatchList (pLocalBatchList);
        freeBatchList (&pLocalBatchList);
    }

    return status;
}


int
invokeBuildEx(
    char *target,
    UCHAR pFlags,
    time_t *timeVal,
    char *pFirstDep,
    BATCHLIST **ppBatchList)
{
    MAKEOBJECT *object;
    BOOL fInmakefile = TRUE;
    int  rc;

    ++RecLevel;
#ifdef CHECK_RECURSION_LEVEL
    if (RecLevel > MAXRECLEVEL)
        makeError(0, TOO_MANY_BUILDS_INTERNAL);
#endif
    if (!(object = findTarget(target))) {
        object = makeTempObject(target, pFlags);
        fInmakefile = FALSE;
    }
    rc = build(object, pFlags, timeVal, fInmakefile, pFirstDep, ppBatchList);
    --RecLevel;
    return(rc);
}


int
build(
    MAKEOBJECT *object,
    UCHAR parentFlags,
    time_t *targetTime,
    BOOL fInmakefile,
    char *pFirstDep,
    BATCHLIST **ppBatchList)
{
    STRINGLIST *questionList,
               *starList,
               *temp,
               *implComList;
    struct _finddata_t finddata;    // buffer for getting file times
    NMHANDLE tHandle;
    BUILDLIST  *b;
    RULELIST *rule;                 // pointer to rule found to build target
    BUILDBLOCK *L_block,
               *explComBlock;
    DEPLIST *deps, *deplist;
    char L_name[MAXNAME];
    int rc, status = 0;
    time_t        targTime,         // target's time in file system
                  newTargTime,      // target's time after being rebuilt
                  tempTime,
                  depTime,          // time of dependency just built
                  maxDepTime;       // time of most recent dependency built
    BOOL built;                     // flag: target built with doublecolon commands
    time_t        *blockTime;       // points to dateTime of cmd. block
    extern char *makeStr;
    extern UCHAR okToDelete;
    UCHAR okDel;
    BATCHLIST *pLocalBatchList;


#ifdef DEBUG_ALL
    printf("Build '%s'\n", object->name);
#endif

    // The first dependent or inbuilt rule dependent is reqd for extmake syntax
    // handling. If it has a value then it is the dependent corr to the inf rule
    // otherwise it should be the first dependent specified

    if (!object) {
        *targetTime = 0L;
        return(0);
    }

    if (ON(object->flags3, F3_BUILDING_THIS_ONE))       // detect cycles
        makeError(0, CYCLE_IN_TREE, object->name);

    if (object->ppBatch) {
        // we need to build an object that is already placed in a batch list
        // Go ahead and build the whole batch list
        BATCHLIST **ppBatch = object->ppBatch;
        status += execBatchList (*ppBatch);
        freeBatchList(ppBatch);
        *targetTime = object->dateTime;
        return status;
    }

    if (ON(object->flags3, F3_ALREADY_BUILT)) {
        if (ON(parentFlags, F2_DISPLAY_FILE_DATES))
            printDate(RecLevel*2, object->name, object->dateTime);
        *targetTime = object->dateTime;
        if ( OFF(gFlags, F1_QUESTION_STATUS) &&
             RecLevel == 1 &&
             OFF(object->flags3, F3_OUT_OF_DATE) &&
             findFirst(object->name, &finddata, &tHandle)) {
            // Display 'up-to-date' msg for built level-1 targets
            // that exist as files. [VS98 1930]
            makeMessage(TARGET_UP_TO_DATE, object->name);
        }
        return(ON(object->flags3, F3_OUT_OF_DATE)? 1 : 0);
    }

    questionList = NULL;
    starList = NULL;
    implComList = NULL;
    explComBlock = NULL;
    L_block = NULL;
    targTime = 0L;
    newTargTime = 0L;
    tempTime = 0L;
    depTime = 0L;
    maxDepTime = 0L;
    blockTime = NULL;
    pLocalBatchList = NULL;


    SET(object->flags3, F3_BUILDING_THIS_ONE);
    dollarStar = dollarAt = object->name;

    // For Double Colon case we need the date of target before it's target's are
    //  built. For all other cases the date matters only if dependents are up
    //  to date. NOT TRUE: WE ALSO NEED THE TARGET'S TIME for @?

    b = object->buildList;
    if (b && ON(b->buildBlock->flags, F2_DOUBLECOLON)
            && findFirst(object->name, &finddata, &tHandle)) {
        targTime = getDateTime(&finddata);

    }

    for (; b; b = b->next) {
        depTime = 0L;
        L_block = b->buildBlock;
        if (L_block->dateTime != 0) {         // cmd. block already executed
            targTime = __max(targTime, L_block->dateTime);
            built = TRUE;
            continue;                       // so set targTime and skip this block
        }
        blockTime = &L_block->dateTime;

        deplist = deps = createDepList(L_block, object->name);
        for (;deps; deps = deps->next) {
            tempTime = deps->depTime;
            rc = invokeBuildEx(deps->name,    // build the dependent
                             L_block->flags,
                             &tempTime, NULL, &pLocalBatchList);
            status += rc;
            if (fOptionK && rc) {
                MAKEOBJECT *obj = findTarget(deps->name);
                assert(obj != NULL);
                if (OFF(obj->flags3, F3_ERROR_IN_CHILD)) {
                    fSlashKStatus = FALSE;
                    makeError(0, BUILD_FAILED_SLASH_K, deps->name);
                }
                SET(object->flags3, F3_ERROR_IN_CHILD);
            }
            depTime = __max(depTime, tempTime);/*if rebuilt, change time*/

            // If target exists then we need it's timestamp to correctly construct $?

            if (!targTime && OFF(L_block->flags, F2_DOUBLECOLON) &&
                    findFirst(object->name, &finddata, &tHandle)) {
                object->dateTime = targTime = getDateTime(&finddata);
            }

            // If dependent was rebuilt, add to $?.  [RB]

            if (ON(object->flags2, F2_FORCE_BUILD) ||
                targTime < tempTime ||
                (fRebuildOnTie && targTime == tempTime)
               ) {
                temp = makeNewStrListElement();
                temp->text = makeString(deps->name);
                appendItem(&questionList, temp);
            }

            // Always add dependent to $**. Must allocate new item because two
            // separate lists.  [RB]

            temp = makeNewStrListElement();
            temp->text = makeString(deps->name);
            appendItem(&starList, temp);
        }

        if (pLocalBatchList) {
            // Perform deferred batch builds and free batch list
            status += execBatchList (pLocalBatchList);
            freeBatchList(&pLocalBatchList);
        }

        // Free dependent list

        for (deps = deplist; deps ; deps = deplist) {
            FREE(deps->name);
            deplist = deps->next;
            FREE(deps);
        }

        // Now, all dependents are built.

        if (ON(L_block->flags, F2_DOUBLECOLON)) {

            // do doublecolon commands

            if (L_block->buildCommands) {
                dollarQuestion = questionList;
                dollarStar = dollarAt = object->name;
                dollarLessThan = dollarDollarAt = NULL;
                dollarStarStar = starList;
                if (((fOptionK && OFF(object->flags3, F3_ERROR_IN_CHILD)) ||
                      status == 0) &&
                    (targTime < depTime) ||
                    (fRebuildOnTie && (targTime == depTime)) ||
                    (targTime == 0 && depTime == 0) ||
                    (!L_block->dependents)
                   ) {

                    // do commands if necessary

                    okDel = okToDelete;
                    okToDelete = TRUE;

                    // if the first dependent is not set use the first one
                    // from the list of dependents

                    pFirstDep = pFirstDep ? pFirstDep : (dollarStarStar ?
                        dollarStarStar->text : NULL);
                    status += doCommands(object->name,
                                         L_block->buildCommands,
                                         L_block->buildMacros,
                                         L_block->flags,
                                         pFirstDep);

                    if (OFF(object->flags2, F2_NO_EXECUTE) &&
                            findFirst(object->name, &finddata, &tHandle))
                        newTargTime = getDateTime(&finddata);
                    else if (maxDepTime)
                        newTargTime = maxDepTime;
                    else
                        curTime(&newTargTime);      // currentTime

                    // set time for this block
                    L_block->dateTime = newTargTime;
                    built = TRUE;

                    // 5/3/92  BryanT   If these both point to the same list,
                    //                  don't free twice.

                    if (starList != questionList) {
                        freeStringList(starList);
                        freeStringList(questionList);
                    } else {
                        freeStringList(starList);
                    }

                    starList = questionList = NULL;
                    okToDelete = okDel;
                }

                if (fOptionK && ON(object->flags3, F3_ERROR_IN_CHILD))
                    makeError(0, TARGET_ERROR_IN_CHILD, object->name);
            }
        } else {

            // singlecolon; set explComBlock

            if (L_block->buildCommands)
                if (explComBlock)
                    makeError(0, TOO_MANY_RULES, object->name);
                else
                    explComBlock = L_block;
            maxDepTime = __max(maxDepTime, depTime);
        }

        if (ON(L_block->flags, F2_DOUBLECOLON) && !b->next) {
            CLEAR(object->flags3, F3_BUILDING_THIS_ONE);
            SET(object->flags3, F3_ALREADY_BUILT);
            if (status > 0)
                SET(object->flags3, F3_OUT_OF_DATE);
            else
                CLEAR(object->flags3, F3_OUT_OF_DATE);
            targTime = __max(newTargTime, targTime);
            object->dateTime = targTime;
            *targetTime = targTime;
            return(status);
        }
    }

    dollarLessThan = dollarDollarAt = NULL;

    if (!(targTime = *targetTime)) {                            //???????
        if (object->dateTime) {
            targTime = object->dateTime;
        } else if (findFirst(object->name, &finddata, &tHandle)) {
            targTime = getDateTime(&finddata);
        }
    }

    if (ON(object->flags2, F2_DISPLAY_FILE_DATES)) {
        printDate(RecLevel*2, object->name, targTime);
    }

    built = FALSE;

    // look for implicit dependents and use rules to build the target

    // The order of the if's decides whether the dependent is inferred
    // from the inference rule or not, even when the explicit command block is
    // present, currently it is infered (XENIX MAKE compatibility)

    if (rule = useRule(object,
                        L_name,
                        targTime,
                        &questionList,
                        &starList,
                        &status,
                        &maxDepTime,
                        &pFirstDep)
       ) {
        if (!explComBlock) {
            dollarLessThan = L_name;
            implComList = rule->buildCommands;
        }
   }

    dollarStar = dollarAt = object->name;
    dollarQuestion = questionList;
    dollarStarStar = starList;

    if (((fOptionK && OFF(object->flags3, F3_ERROR_IN_CHILD)) || status == 0) &&
        (targTime < maxDepTime ||
         (fRebuildOnTie && (targTime == maxDepTime)) ||
         (targTime == 0 && maxDepTime == 0) ||
         ON(object->flags2, F2_FORCE_BUILD)
        )
       ) {
        okDel = okToDelete;         // Yes, can delete while executing commands
        okToDelete = TRUE;

        if (explComBlock) {
            // if the first dependent is not set use the first one from the
            // list of dependents
            pFirstDep = pFirstDep ? pFirstDep :
                (dollarStarStar ? dollarStarStar->text : NULL);
            status += doCommands(object->name,      // do singlecolon commands
                                 explComBlock->buildCommands,
                                 explComBlock->buildMacros,
                                 explComBlock->flags,
                                 pFirstDep);
        }
        else if (implComList) {
            if (rule->fBatch && OFF(gFlags, F1_NO_BATCH)) {
                addBatch(ppBatchList,
                        rule,
                        object,
                        dollarLessThan);
            }
            else {
                status += doCommands(object->name,      // do rule's commands
                                 implComList,
                                 rule->buildMacros,
                                 object->flags2,
                                 pFirstDep);
            }
        }
        else if (ON(gFlags, F1_TOUCH_TARGETS)) {      // for /t with no commands...
            if (L_block)
                status += doCommands(object->name,
                                 L_block->buildCommands,
                                 L_block->buildMacros,
                                 L_block->flags,
                                 pFirstDep);
        }
        // if Option K specified don't exit ... pass on return code
        else if (!fInmakefile && targTime == 0) {    // lose
            // Haituanv: If option K, then set the return code 'status'
            // to 1 to indicate a failure.  This fixes Ikura bug #178.
            if (fOptionK) {
                status = 1;
#ifdef DEBUG_OPTION_K
                printf("DEBUG: %s(%d): status = %d\n", __FILE__, __LINE__, status);
#endif
            } else
                makeError(0, CANT_MAKE_TARGET, object->name);
        }
        okToDelete = okDel;
        // if cmd exec'ed or has 0 deps then currentTime else max of dep times
        if (explComBlock || implComList || !dollarStarStar) {
            curTime(&newTargTime);

            // Add 2 to ensure the time for this node is >= the time the file
            // system might have used (mainly useful when running a very fast
            // machine where the file system doesn't have the resolution of the
            // system timer... We don't have to to this in the curTime
            // above since it's only hit when nothing is built anywhere...

            newTargTime +=2;
        } else
            newTargTime = maxDepTime;

        if (blockTime && explComBlock)
            // set block's time, if a real cmd. block was executed
            *blockTime = newTargTime;
    }
    else if (OFF(gFlags, F1_QUESTION_STATUS) &&
             RecLevel == 1 &&
             !built &&
             OFF(object->flags3, F3_ERROR_IN_CHILD))
        makeMessage(TARGET_UP_TO_DATE, object->name);

    if (fOptionK && status) {
        // 4-Aug-1993 Haituanv: Ikura bug #178 again:  We should set fSlashKStatus=FALSE
        // so that main() knows the build failed under /K option.
        fSlashKStatus = FALSE;

        if (ON(object->flags3, F3_ERROR_IN_CHILD))
            makeError(0, TARGET_ERROR_IN_CHILD, object->name);
        else if (RecLevel == 1)
            makeError(0, BUILD_FAILED_SLASH_K, object->name);
    }

    if (ON(gFlags, F1_QUESTION_STATUS) && RecLevel == 1 ) {
        // 5/3/92  BryanT   If these both point to the same list, don't
        //                  free twice.

        if (starList!= questionList) {
            freeStringList(starList);
            freeStringList(questionList);
        } else {
            freeStringList(starList);
        }

        return(numCommands ? -1 : 0);
    }

    CLEAR(object->flags3, F3_BUILDING_THIS_ONE);
    if (!object->ppBatch) {
        SET(object->flags3, F3_ALREADY_BUILT);
        if (status > 0)
            SET(object->flags3, F3_OUT_OF_DATE);
        else
            CLEAR(object->flags3, F3_OUT_OF_DATE);
    }

    targTime = __max(newTargTime, targTime);
    object->dateTime = targTime;

    *targetTime = targTime;

    // 5/3/92  BryanT   If these both point to the same list, don't
    //                  free twice.

    if (starList!= questionList) {
        freeStringList(starList);
        freeStringList(questionList);
    } else {
        freeStringList(starList);
    }

    return(status);
}

DEPLIST *
createDepList(
    BUILDBLOCK *bBlock,
    char *objectName
    )
{
    BOOL again;  // flag: wildcards found in dependent name
    char *s, *t;
    char *source, *save, *token;
    char *depName, *depPath;
    char *tempStr;
    STRINGLIST *sList, *pMacros;
    DEPLIST *depList = NULL, *pNew;
    struct _finddata_t finddata;
    NMHANDLE searchHandle;

    pMacros = bBlock->dependentMacros;

    // expand Macros in Dependent list
    for (sList = bBlock->dependents; sList; sList = sList->next) {
        for (s = sList->text; *s && *s != '$'; s = _tcsinc(s)) {
            if (*s == ESCH)
                s++;
        }
        if (*s) {
            // set $$@ properly, The dependency macros will then expand right
            dollarDollarAt = objectName;
            source = expandMacros(sList->text, &pMacros);
        } else
            source = sList->text;

        save = makeString(source);
        // build list for all dependents
        for (t = save; nextToken(&t, &token);) {
            if (*token == '{') {
                // path list found
                for (depName = token; *depName && *depName != '}'; depName = _tcsinc(depName)) {
                    if (*depName == ESCH) {
                        depName++;
                    }
                }

                if (*depName) {
                    *depName++ = '\0';
                    ++token;
                }
            } else {
                depName = token;    // If no path list, set
                token = NULL;       // token to null.
            }

            // depName is now name of dependency file ...

            again = FALSE;
            putDateTime(&finddata, 0L);
            depPath = makeString(depName);
            if (_tcspbrk(depName, "*?") || token) { // do wildcards in filename
                if (tempStr = searchPath(token, depName, &finddata, &searchHandle)){
                    again = TRUE;
                    FREE(depPath);
                    depName = tempStr;              // depName gets actual name
                    depPath = prependPath(depName, getFileName(&finddata));
                }                                   // depPath gets full path
            }

            // Add to the dependent list

            do {
                pNew = MakeNewDepListElement();
                // if name contains spaces and has no quotes,
                // add enclosing quotes around it [DS 14575]
                if (_tcschr(depPath, ' ') && !_tcschr(depPath, '\"')) {
                    pNew->name = (char *)rallocate (_tcslen(depPath)+3);
                    *(pNew->name) = '\"';
                    *(pNew->name+1) = '\0';
                    _tcscat (pNew->name, depPath);
                    _tcscat (pNew->name, "\"");
                }
                else {
                    pNew->name = makeString(depPath);
                }

                if (!fDescRebuildOrder || findFirst(depPath, &finddata, &searchHandle)) {
                    pNew->depTime = getDateTime(&finddata);
                } else {
                    pNew->depTime = 0L;
                }

                if (fDescRebuildOrder) {
                    insertSort(&depList, pNew);
                } else {
                    appendItem((STRINGLIST**)&depList, (STRINGLIST*)pNew);
                }
                FREE(depPath);
            } while (again &&
                     _tcspbrk(depName, "*?") &&    // do all wildcards
                     findNext(&finddata, searchHandle) &&
                     (depPath = prependPath(depName, getFileName(&finddata)))
                    );
        }
        // One dependent (w/wildcards?) was expanded

        if (source != sList->text) {
            FREE(source);
        }

        FREE(save);
    }

    // Now, all dependents are done ...

    return(depList);
}

void
insertSort(
    DEPLIST **pDepList,
    DEPLIST *pElement
    )
{
    time_t item;
    DEPLIST *pList, *current;

    item = pElement->depTime;
    pList = current = *pDepList;

    for (;pList && item <= pList->depTime; pList = pList->next) {
        current = pList;
    }

    if (current == pList) {
        *pDepList = pElement;
    } else {
        current->next = pElement;
        pElement->next = pList;
    }
}


BOOL
nextToken(
    char **pNext,
    char **pToken
    )
{
    char *s = *pNext;

    while (*s && WHITESPACE(*s)) {
        ++s;
    }

    if (!*(*pToken = s)) {
        return(FALSE);
    }

    // Token begins here
    *pToken = s;

    if (*s == '"') {
        while (*s && *++s != '"')
            ;

        if (!*s) {
            // lexer possible internal error: missed a quote
            makeError(0, LEXER_INTERNAL);
        }

        if (*++s) {
            *s++ = '\0';
        }

        *pNext = s;
        return(TRUE);
    } else if (*s == '{') {
        // skip to '}' outside quotes
        for (;*s;) {
            s++;
            if (*s == '"') {
                s++;        // Skip the first quote
                while (*s && *s++ != '"'); // Skip all including the last quote
            }
            if (*s == '}') {
                break;
            }
        }

        if (!*s) {
            // lexer possible internal error: missed a brace
            makeError(0, MISSING_CLOSING_BRACE);
         }

        if (*++s == '"') {
            while (*s && *++s != '"')
                ;

            if (!*s) {
                // lexer possible internal error: missed a quote
                makeError(0, LEXER_INTERNAL);
            }

            if (*++s) {
                *s++ = '\0';
            }

            *pNext = s;
            return(TRUE);
        }
    }

    while (*s && !WHITESPACE(*s)) {
        ++s;
    }

    if (*s) {
        *s++ = '\0';
    }

    *pNext = s;

    return(TRUE);
}


void
freeStringList(
    STRINGLIST *list
    )
{
    STRINGLIST *temp;

    while (temp = list) {
        list = list->next;
        FREE(temp->text);
        FREE_STRINGLIST(temp);
    }
}


// makeTempObject -- make an object to represent implied dependents
//
//   We add implied dependents to the target table, but use a special struct
//   that has  no pointer to a build list -- they never get removed.
//   time-space trade-off -- can remove them, but will take more proc time.

MAKEOBJECT *
makeTempObject(
    char *target,
    UCHAR flags
    )
{
    MAKEOBJECT *object;
    unsigned i;

    object = makeNewObject();
    object->name = makeString(target);
    object->flags2 = flags;
    object->flags3 = 0;
    object->dateTime = 0L;
    object->buildList = NULL;
    i = hash(target, MAXTARGET, (BOOL) TRUE);
    prependItem((STRINGLIST**)targetTable+i, (STRINGLIST*)object);
    return(object);
}


void
addBatch(
    BATCHLIST **ppBatchList,
    RULELIST *pRule,
    MAKEOBJECT *pObject,
    char *dollarLt
    )
{
    STRINGLIST *temp;
    BATCHLIST *pBatch;
    BATCHLIST *pBatchPrev = 0;

    for(pBatch = *ppBatchList; pBatch; pBatch = pBatch->next) {
        if (pBatch->pRule == pRule &&
            pBatch->flags == pObject->flags2)
            break;
        pBatchPrev = pBatch;
    }
    if (!pBatch) {
        pBatch = makeNewBatchListElement();
        pBatch->pRule = pRule;
        pBatch->flags = pObject->flags2;
        if (pBatchPrev) {
            pBatchPrev->next = pBatch;
        }
        else if(*ppBatchList) {
            (*ppBatchList)->next = pBatch;
        }
        else
            *ppBatchList = pBatch;
    }

    temp = makeNewStrListElement();
    temp->text = makeString(pObject->name);
    appendItem(&pBatch->nameList, temp);

    temp = makeNewStrListElement();
    temp->text = makeString(dollarLessThan);
    appendItem(&pBatch->dollarLt, temp);

    assert(!pObject->ppBatch);
    pObject->ppBatch = ppBatchList;
}


int doBatchCommand (
    BATCHLIST *pBatch
    )
{
    size_t      cbStr = 0;
    int         rc;
    char        *pchBuf;
    STRINGLIST  *pStrList;
    RULELIST    *pRule = pBatch->pRule;
    assert (pBatch->dollarLt);
    assert (pBatch->nameList);

    // form $<
    for (pStrList = pBatch->dollarLt; pStrList; pStrList = pStrList->next) {
        cbStr += _tcslen(pStrList->text) + 1;
        // allow space for quotes if text contains spaces
        if (_tcschr(pStrList->text, ' '))
            cbStr += 2;
    }
    pchBuf = (char *)allocate(cbStr + 1);
    *pchBuf = 0;
    for (pStrList = pBatch->dollarLt; pStrList; pStrList = pStrList->next) {
        BOOL fQuote;
        // Quote only if not quoted and contains spaces [vs98:8677]
        fQuote = pStrList->text[0] != '"' && _tcschr(pStrList->text, ' ');
        if (fQuote)
            _tcscat(pchBuf, "\"");
        _tcscat(pchBuf, pStrList->text);
        _tcscat(pchBuf, fQuote ? "\" " : " ");
    }
    dollarLessThan = pchBuf;

    rc = doCommandsEx(pBatch->nameList,
                    pRule->buildCommands,
                    pRule->buildMacros,
                    pBatch->flags,
                    NULL);

    if (rc == 0) {
        STRINGLIST *pName;
        MAKEOBJECT *pObject;
        for (pName = pBatch->nameList; pName; pName = pName->next) {
            pObject = findTarget(pName->text);
            assert (pObject);

            SET(pObject->flags3, F3_ALREADY_BUILT);
            CLEAR(pObject->flags3, F3_OUT_OF_DATE);

            pObject->ppBatch = 0;
        }
    }

    FREE (pchBuf);
    return rc;
}




int
execBatchList(
    BATCHLIST *pBList
    )
{
    int status = 0;
    if (pBList) {
        BATCHLIST *pBatch;
        for (pBatch = pBList; pBatch; pBatch=pBatch->next) {
            status += doBatchCommand (pBatch);
        }
    }
    return status;
}


void
freeBatchList(
    BATCHLIST **ppBList
    )
{
    BATCHLIST *pBatch = *ppBList;

    while (pBatch) {
        BATCHLIST *pTmp;
        free_stringlist(pBatch->nameList);
        free_stringlist(pBatch->dollarLt);
        pTmp = pBatch;
        pBatch = pBatch->next;
        FREE(pTmp);
    }
    *ppBList = NULL;
}


#ifdef DEBUG_ALL
void
DumpList(
    STRINGLIST *pList
    )
{
    // STRINGLIST *p;
    printf("* ");
    while (pList) {
        printf(pList->text);
        printf(",");
        pList = pList->next;
    }
    printf("\n");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\charmap.cpp ===
#include "precomp.h"
#pragma hdrstop

//
// Map to determine characteristics of text
//
UCHAR   Charmap[CHARMAP_SIZE] = {
LX_EOS,         // 0x0, <end of string marker>
LX_ILL,         // 0x1
LX_ILL,         // 0x2
LX_ILL,         // 0x3
LX_ILL,         // 0x4
LX_ILL,         // 0x5
LX_ILL,         // 0x6
LX_ILL,         // 0x7
LX_ILL,         // 0x8
LX_WHITE,       // <horizontal tab>
LX_NL,          // <newline>
LX_WHITE,       // <vertical tab>
LX_WHITE,       // <form feed>
LX_CR,          // <really a carriage return>
LX_ILL,         // 0xe
LX_ILL,         // 0xf
LX_ILL,         // 0x10
LX_ILL,         // 0x11
LX_ILL,         // 0x12
LX_ILL,         // 0x13
LX_ILL,         // 0x14
LX_ILL,         // 0x15
LX_ILL,         // 0x16
LX_ILL,         // 0x17
LX_ILL,         // 0x18
LX_ILL,         // 0x19
LX_EOS,         // 0x1a, ^Z
LX_ILL,         // 0x1b
LX_ILL,         // 0x1c
LX_ILL,         // 0x1d
LX_ILL,         // 0x1e
LX_ILL,         // 0x1f
LX_WHITE,       // 0x20
LX_OPERATOR,    // !
LX_DQUOTE,      // "
LX_POUND,       // #
LX_ASCII,       // $
LX_OPERATOR,    // %
LX_OPERATOR,    // &
LX_SQUOTE,      // '
LX_OPERATOR,    // (
LX_OPERATOR,    // )
LX_OPERATOR,    // *
LX_OPERATOR,    // +
LX_COMMA,       // ,
LX_MINUS,       // -
LX_DOT,         // .
LX_OPERATOR,    // /
LX_NUMBER,      // 0
LX_NUMBER,      // 1
LX_NUMBER,      // 2
LX_NUMBER,      // 3
LX_NUMBER,      // 4
LX_NUMBER,      // 5
LX_NUMBER,      // 6
LX_NUMBER,      // 7
LX_NUMBER,      // 8
LX_NUMBER,      // 9
LX_COLON,       // :
LX_SEMI,        // ;
LX_OPERATOR,    // <
LX_OPERATOR,    // =
LX_OPERATOR,    // >
LX_EOS,         // ?
LX_EACH,        // @
LX_ID,          // A
LX_ID,          // B
LX_ID,          // C
LX_ID,          // D
LX_ID,          // E
LX_ID,          // F
LX_ID,          // G
LX_ID,          // H
LX_ID,          // I
LX_ID,          // J
LX_ID,          // K
LX_ID,          // L
LX_ID,          // M
LX_ID,          // N
LX_ID,          // O
LX_ID,          // P
LX_ID,          // Q
LX_ID,          // R
LX_ID,          // S
LX_ID,          // T
LX_ID,          // U
LX_ID,          // V
LX_ID,          // W
LX_ID,          // X
LX_ID,          // Y
LX_ID,          // Z
LX_OBRACK,      // [
LX_EOS,         // \ (backslash)
LX_CBRACK,      // ]
LX_OPERATOR,    // ^
LX_MACRO,       // _
LX_ASCII,       // `
LX_ID,          // a
LX_ID,          // b
LX_ID,          // c
LX_ID,          // d
LX_ID,          // e
LX_ID,          // f
LX_ID,          // g
LX_ID,          // h
LX_ID,          // i
LX_ID,          // j
LX_ID,          // k
LX_ID,          // l
LX_ID,          // m
LX_ID,          // n
LX_ID,          // o
LX_ID,          // p
LX_ID,          // q
LX_ID,          // r
LX_ID,          // s
LX_ID,          // t
LX_ID,          // u
LX_ID,          // v
LX_ID,          // w
LX_ID,          // x
LX_ID,          // y
LX_ID,          // z
LX_OBRACE,      // {
LX_OPERATOR,    // |
LX_CBRACE,      // }
LX_OPERATOR,    // ~
LX_ILL,         // 0x7f
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
};

void initCharmap(void)
{
    int i;
    for (i = 0; i <= 127; i++) {

        // Initialize valid macro chars (besides '_' and >= 128)
        if (_istalnum(i)) {
            Charmap[i] |= LX_MACRO;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\command.cpp ===
//  COMMAND.C - NMAKE 'command line' handling routines
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains routines to handle NMAKE 'command line' syntax. NMAKE can be
//  optionally called by using the syntax 'NMAKE @commandfile'. This allows more
//  flexibility and preents a way of getting around DOS's 128-byte limit on the
//  length of a command line. Additionally, it saves keystrokes for frequently
//  run commands for NMAKE.
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JR  Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  14-Aug-1992 SS  CAVIAR 2735: handle quoted macro values in command files
//  02-Feb-1990 SB  Replace fopen() by FILEOPEN
//  01-Dec-1989 SB  Changed realloc() to REALLOC()
//  22-Nov-1989 SB  Changed free() to FREE()
//  17-Aug-1989 SB  Add error check to closing file
//  05-Apr-1989 SB  made func calls NEAR to put all funcs into 1 module
//  20-Oct-1988 SB  Notes added to readCommandFile()
//  17-Aug-1988 RB  Clean up.

#include "precomp.h"
#pragma hdrstop

void addArgument(char*,unsigned,char***);
void processLine(char*,unsigned*,char***);
void tokenizeLine(char*,unsigned*,char***);

// readCommandFile()
//
// arguments:  name    pointer to name of command file to read
//
// actions:    opens command file
//             reads in lines and calls processLine() to
//               break them into tokens and to build
//               an argument vector (a la argv[])
//             calls parseCommandLine() recursively to process
//               the accumulated "command line" arguments
//             frees space used by the arg vector
//
// modifies:   makeFiles   in main() by modifying contents of parameter list
//             makeTargets in main() by modifying contents of targets parameter
//             buf         global buffer
//
// notes:      function is not ANSI portable because it uses fopen()
//             with "rt" type and text mode is a Microsoft extension
//

void
readCommandFile(
    char *name
    )
{
    char *s,                        // buffer
         **vector;                  // local versions of arg vector
    unsigned count = 0;             // count
    size_t n;

    if (!(file = FILEOPEN(name,"rt")))
        makeError(0,CANT_OPEN_FILE,name);
    vector = NULL;                      // no args yet
    while (fgets(buf,MAXBUF,file)) {
        n = _tcslen(buf);

        // if we didn't get the whole line, OR the line ended with a backSlash

        if ((n == MAXBUF-1 && buf[n-1] != '\n') ||
            (buf[n-1] == '\n' && buf[n-2] == '\\')
           ) {
            if (buf[n-2] == '\\' && buf[n-1] == '\n') {
                // Replace \n by \0 and \\ by a space; Also reset length
                buf[n-1] = '\0';
                buf[n-2] = ' ';
                n--;
            }
            s = makeString(buf);
            getRestOfLine(&s,&n);
        } else
            s = buf;

        processLine(s,&count,&vector);  // separate into args
        if (s != buf)
            FREE(s);
    }

    if (fclose(file) == EOF)
        makeError(0, ERROR_CLOSING_FILE, name);

    parseCommandLine(count,vector);     // evaluate the args
    while (count--)                     // free the arg vector
        if(vector[count])
            FREE(vector[count]);        // NULL entries mean that the space the
}                                       //  entry used to pt to is still in use


// getRestOfLine()
//
// arguments:   s    pointer to readCommandFile()'s buffer
//                    holding line so far
//              n    pointer to readCommandFile()'s count of
//                    the chars in *s
//
// actions:     keeps reading in text until it sees a newline
//              or the end of file
//              reallocs space for the old buffer plus the
//               contents of the new buffer each time
//              appends new buffer's text to existing text
//
// modifies:    s    readCommandFile()'s text buffer by realloc'ing
//                    more space for incoming text
//              n    readCommandFile()'s count of bytes in s
//              buf  global buffer

void
getRestOfLine(
    char *s[],
    size_t *n
    )
{
    size_t temp;
    char *t;

    t = buf;
    while ((*s)[*n-1] != '\n') {    // get rest of line
        if (!fgets(t,MAXBUF,file))
            break;                  // we hit EOF
        temp = _tcslen(t);
        if (t[temp-2] == '\\' && t[temp-1] == '\n') {
            //Replace \n by \0 and \\ by a space; Also reset length
            t[temp-1] = '\0';
            t[temp-2] = ' ';
        }
        temp = *n;
        *n += _tcslen(t);
        {
            void *pv = REALLOC(*s,*n+1);     // + 1 for NULL byte
            if (!pv)
                makeError(line, MACRO_TOO_LONG);
            else
                *s = (char *)pv;
        }
        _tcscpy(*s+temp,t);
    }
}


// processLine()
//
// arguments:  s       pointer to readCommandFile()'s buffer
//                       holding "command line" to be processed
//             count   pointer to readCommandFile()'s count of
//                       "command line" arguments seen so far
//             vector  pointer to readCommandFile()'s vector of
//                       pointers to character strings
//
// actions:    if the line to be broken into "command line arguments" contains '"'
//             breaks all the text before '"' into tokens
//             delimited by whitespace (which get put in vector[] by
//              tokenizeLine())
//             finds the closing '"' and treats the quoted string
//              as a single token, adding it to the vector
//             recurses on the tail of the line (to check for
//              other quoted strings)
//             else breaks all text in line into tokens delimited
//              by whitespace
//
// modifies:   vector  readCommandFile()'s vector of pointers to
//                      "command line argument" strings (by modifying
//                      the contents of the parameter pointer, vector)
//             count   readCommandFile()'s count of the arguments in
//                      the vector (by modifying the contents of the
//                      parameter pointer, count)

void
processLine(
    char *s,
    unsigned *count,
    char **vector[]
    )
{
    char *t;
    char *u;
    size_t m;
    size_t n;
    BOOL allocFlag = FALSE;

    if (!(t = _tcschr(s,'"'))) {            // no quoted strings,
        tokenizeLine(s,count,vector);       // just standard fare
    } else {
        // There are two kinds of situations in which quotes can occur:
        //   1. "FOO = bar baz"
        //   2. FOO="bar baz"

        if ((t == s) || (*(t-1) != '='))  {
            // Case 1 above
            *t++ = '\0';                    // quoted macrodef
            tokenizeLine(s,count,vector);   // get tokens before "
        } else {
            // Case 2 above
            *t-- = ' ';
            for (u = t; u > s; --u) //    find the beginning of the macro name
                if (*u == ' ' || *u == '\t' || *u == '\n')
                    break;

            if (u != s) {
                *u++ = '\0';
                tokenizeLine(s, count, vector);
            }

            t = u;
        }

        n = _tcslen(t);
        for (u = t; *u; ++u) {              // look for closing "
            if (*u == '"') {                // need " and not ""
                if (*(u+1) == '"') {
                    _tcscpy(u,u+1);
                    continue;
                }
                *u++ = '\0';                // terminate macrodef
                addArgument(t,*count,vector);   // treat as one arg
                ++*count;
                processLine(u+1,count,vector);  // recurse on rest of line
                break;
            }                       // TAIL RECURSION -- eliminate later?

            if ((*u == '\\')
                && WHITESPACE(*(u-1))
                && (*(u+1) == '\n')) {      // \n always last char
                *u = '\0';                  // 2 chars go to 1
                m = (n = n-2);              // adjust length count
                if (!allocFlag) {
                    allocFlag = TRUE;
                    t = makeString(t);
                }
                getRestOfLine(&t,&n);       // get some more text
                u = t + m ;                 // reset u & continue looping
            }
        }

        if (u == t + n) {                   // if at end of line
            makeError(0,SYNTAX_NO_QUOTE);   // and no ", error
        }

        if (allocFlag) {
            FREE(t);
        }
    }
}


// tokenizeLine()
//
// arguments:  s       pointer to readCommandFile()'s buffer
//                      holding "command line" to be tokenized
//             count   pointer to readCommandFile()'s count of
//                      "command line" arguments seen so far
//             vector  pointer to readCommandFile()'s vector of
//                      pointers to character strings
//
// actions:    breaks the line in s into tokens (command line
//              arguments) delimited by whitespace
//             adds each token to the argument vector
//             adjusts the argument counter
//
// modifies:   vector  readCommandFile()'s vector of pointers to
//                      "command line argument" strings (by modifying
//                      the contents of the parameter pointer, vector)
//             count   readCommandFile()'s count of the arguments in
//                      the vector (by modifying the contents of the
//                      parameter pointer, count)
//
// If the user ever wants '@' to be part of an argument in a command file,
// he has to enclose that argument in quotation marks.

void
tokenizeLine(                       // gets args delimited
    char *s,                        // by whitespace and
    unsigned *count,                // constructs an arg
    char **vector[]                 // vector
    )
{
    char *t;

    if (t = _tcschr(s,'\\')) {
        if (WHITESPACE(*(t-1)) && (*(t+1) == '\n')) {
            *t = '\0';
        }
    }

    for (t = _tcstok(s," \t\n"); t; t = _tcstok(NULL," \t\n")) {
        if (*t == '@') {
            makeError(0,SYNTAX_CMDFILE,t+1);
            break;                  // should we keep on parsing here?
        }
        addArgument(t,*count,vector);
        ++*count;
    }
}


// addArgument()
//
// arguments:  s       pointer to text of argument to be added
//                      to the "command line argument" vector
//             count   pointer to readCommandFile()'s count of
//                      "command line" arguments seen so far
//             vector  pointer to readCommandFile()'s vector of
//                      pointers to character strings
//
// actions:    allocates space in the vector for the new argument
//             allocates space for argument string
//             makes vector entry point to argument string
//
// modifies:   vector  readCommandFile()'s vector of pointers to
//                      "command line argument" strings (by modifying
//                      the contents of the parameter pointer, vector)
//             (count gets incremented by caller)
//
// To keep from fragmenting memory by doing many realloc() calls for very
// small amounts of space, we get memory in small chunks and use that until
// it is depleted, then we get another chunk . . . .

void
addArgument(                        // puts s in vector
    char *s,
    unsigned count,
    char **vector[]
    )
{
    if (!(*vector)) {
        *vector = (char**) allocate(CHUNKSIZE*sizeof(char*));
    } else if (!(count % CHUNKSIZE)) {
        void *pv = REALLOC(*vector,(count+CHUNKSIZE)*sizeof(char*));
        if (!pv) {
            makeError(0,OUT_OF_MEMORY);
        } else {
            *vector = (char**) pv;
        }
    }
    (*vector)[count] = makeString(s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\getmsg.h ===
// getmsg.h

#ifndef __GETMSG_H__
#define __GETMSG_H__

char *  get_err(int);
int SetErrorFile(char *szFilename, char *szExeName, int fSearchExePath);
long SetHInstace(long hInstModule);

#endif __GETMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\getrcmsg.c ===
// getrcmsg.c

#include "windows.h"

static HINSTANCE    hInstModule = NULL;

HINSTANCE
SetHInstance(HINSTANCE h)
{
    HINSTANCE   hRet = hInstModule;
    hInstModule = h;
    return hRet;
}

char  *
get_err(int msg_num)
{

    static char rgchErr[1024];

#if !defined(HARD_LINK)
    static HMODULE hmodUser32;
    static int (WINAPI *pfnLoadStringA)(HINSTANCE, UINT, LPSTR, int);

    if (hmodUser32 == NULL) {
        hmodUser32  = LoadLibrary("USER32.DLL");

        if (hmodUser32 == NULL) {
            return NULL;
        }
    }

    if (pfnLoadStringA == NULL) {
        pfnLoadStringA = (int (WINAPI *)(HINSTANCE, UINT, LPSTR, int))
                             GetProcAddress(hmodUser32, "LoadStringA");

        if (pfnLoadStringA == NULL) {
            return NULL;
        }
    }

    if ((*pfnLoadStringA)(hInstModule, msg_num, rgchErr, sizeof(rgchErr)) == 0) {
        rgchErr[0] = '\0';
    }
#else
#pragma comment(lib, "user32")

    if (LoadString(hInstModule, msg_num, rgchErr, sizeof(rgchErr)) == 0) {
        rgchErr[0] = '\0';
    }
#endif
    return rgchErr;
}

int
SetErrorFile(char *pFilename, char *pExeName, int fSearchExePath)
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\file.cpp ===
//  FILE.C -- Utilities for File handling
//
//    Copyright (c) 1989, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains routines that help in file handling. These routines
//  have a behaviour which depends upon the Operating System Version.
//
// Revision History:
//   08-Jun-1992 SS Port to DOSX32
//   20-Apr-1989 SB Created
//
// Notes:   Created to give OS/2 Version 1.2 filename support.

#include "precomp.h"
#pragma hdrstop

#define bitsin(type)   sizeof(type) * 8

//  getFileName -- get file name from struct
//
// Purpose: returns filename from file search structure passed to it.
//
// Input:   findBuf -- address of pointer to structure
//
// Output:  Returns a pointer to filename in the file search structure.
//
// Assumes:
//  That the structure of appropriate size is given to it. This means that the
//  size is as per --
//      find_t         :    DOS         Real Mode
//      _finddata_t    :    FLAT        Protect Mode
//
// Notes:   The functionality depends upon the OS version and mode

char *
getFileName(
    void *findBuf
    )
{
    char *fileName;

    fileName = ((struct _finddata_t *) findBuf)->name;

    return(fileName);
}

//  getDateTime -- get file timestamp from struct
//
// Purpose: returns timestamp from the file search structure passed to it.
//
// Input:   findBuf -- address of pointer to structure
//
// Output:  Returns timestamp of the file in the structure
//
// Assumes:
//  That the structure of appropriate size is given to it. This means that the
//  size is as per --
//      find_t         :    DOS     Real Mode
//      _finddata_t    :    FLAT    Protect Mode
//
// Notes:
//  The timestamp is an unsigned long value that gives the date and time of last
//  change to the file. If the date is high byte then two times of creation of
//  two files can be compared by comparing their timestamps. This is easy in the
//  DOS struct but becomes complex for the OS/2 structs because the order of date
//  and time has been reversed (for some unexplicable reason).
//
//  The functionality depends upon the OS version and mode.

time_t
getDateTime(
    const _finddata_t *pfd
    )
{
    time_t  dateTime;

    if( pfd->attrib & _A_SUBDIR ) {
        // subdir return create date
        if (pfd->time_create == -1) {
            // except on FAT
            dateTime = pfd->time_write;
        }
        else {
            dateTime = pfd->time_create;
        }
    }
    else {
        dateTime = pfd->time_write ;
    }

    return dateTime;
}

//  putDateTime -- change the timestamp in the struct
//
// Purpose: changes timestamp in the file search structure passed to it.
//
// Input:   findBuf   -- address of pointer to structure
//          lDateTime -- new value of timestamp
//
// Assumes:
//  That the structure of appropriate size is given to it. This means that the
//  size is as per --
//      find_t          :    DOS                  Real Mode
//      FileFindBuf    :    OS/2 (upto Ver 1.10)       Protect Mode
//      _FILEFINDBUF   :    OS/2 (Ver 1.20 & later)    Protect Mode
//
// Notes:
//  The timestamp is a time_t value that gives the date and time of last
//  change to the file. If the date is high byte then two times of creation of
//  two files can be compared by comparing their timestamps. This is easy in the
//  DOS struct but becomes complex for the OS/2 structs because the order of date
//  and time has been reversed (for some unexplicable reason).
//
//  The functionality depends upon the OS version and mode.
//
//  Efficient method to get a long with high and low bytes reversed is
//      (long)high << 16 | (long)low           //high, low being short

void
putDateTime(
    _finddata_t *pfd,
    time_t lDateTime
    )
{
    if (pfd->attrib & _A_SUBDIR) {
        // return the creation date on directories
        pfd->time_create = lDateTime;
    }
    else {
        pfd->time_write = lDateTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\globals.cpp ===
//  globals.c - global variables/needed across modules
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This is the routine in which global variables reside.
//
// HackAlert:
//  The functionality explained in the Notes below work only because of the way
//  Microsoft Compiler's upto C6.0A allocate initialized data ... in the order
//  in which it is specified. All variables between startOfSave and endOfSave
//  have to be initialized. According to ChuckG this functionality is not
//  guaranteed in C7.0 and so these should be moved to a struct.
//
// Notes:
//  This module was created for an interesting reason. NMAKE handles recursive
//  calls by saving its global variables somewhere in memory. It handles this by
//  allocating all global variables which have value changes in each recursive
//  in adjacent memory. The routine called recursively is doMake() and before it
//  is called the address of this chunk of memory is stored. When the recursive
//  call returns the memory is restored using the stored address. startOfSave and
//  endOfSave give the location of this chunk. The reason this method was opted
//  for is that spawning of NMAKE would consume a lot of memory under DOS. This
//  might not be very efficient under OS/2 because the code gets shared.
//
// Revision History:
//  15-Nov-1993 JR Major speed improvements
//  04-Apr-1990 SB Add fHeapChk
//  01-Dec-1989 SB Made some variables near and pushed some into saveArea
//  19-Oct-1989 SB variable fOptionK added (ifdef SLASHK)
//  02-Oct-1989 SB add dynamic inline file handling support
//  18-May-1989 SB Support of H and NOLOGO in MAKEFLAGS
//  24-Apr-1989 SB Added ext_size, filename_size, filenameext_size &
//                  resultbuf_size for OS/2 1.2 support
//  05-Apr-1989 SB made revList, delList, scriptFileList NEAR
//  22-Mar-1989 SB removed tmpFileStack and related variables
//  16-Feb-1989 SB added delList to have scriptfile deletes at end of make
//  21-Dec-1988 SB Added scriptFileList to handle multiple script files
//                  removed tmpScriptFile and fKeep (not reqd anymore)
//  19-Dec-1988 SB Added fKeep to handle KEEP/NOKEEP
//  14-Dec-1988 SB Added tmpScriptFile to handle 'z' option
//  30-Nov-1988 SB Added revList to handle 'z' option
//  23-Nov-1988 SB Added CmdLine[] to handle extmake syntax
//                  made pCmdLineCopy Global in build.c
//  21-Oct-1988 SB Added fInheritUserEnv to inherit macros
//  15-Sep-1988 RB Move some def's here for completeness.
//  17-Aug-1988 RB Declare everything near.
//  06-Jul-1988 rj Ditched shell and argVector globals.

#include "precomp.h"
#pragma hdrstop

#if defined(STATISTICS)
unsigned long CntfindMacro;
unsigned long CntmacroChains;
unsigned long CntinsertMacro;
unsigned long CntfindTarget;
unsigned long CnttargetChains;
unsigned long CntStriCmp;
unsigned long CntunQuotes;
unsigned long CntFreeStrList;
unsigned long CntAllocStrList;
#endif

BOOL          fOptionK;             // TRUE if user specifies /K
BOOL          fDescRebuildOrder;    // TRUE if user specifies /O
BOOL          fSlashKStatus = TRUE; // no error when slash K specified


// Used by action.c & nmake.c
//
// Required to make NMAKE inherit user modified changes to the environment. To
// be set to true before defineMacro() is called so that user defined changes
// in environment variables are reflected in the environment. If set to false
// then these changes are made only in NMAKE tables and the environment remains
// unchanged

BOOL          fInheritUserEnv;

BOOL fRebuildOnTie;                 //  TRUE if /b specified, Rebuild on tie

// Used by action.c and nmake.c
//
// delList is the list of delete commands for deleting inline files which are
// not required anymore (have a NOKEEP action specified.

STRINGLIST  * delList;

// Complete list of generated inline files. Required to avoid duplicate names
// NOTNEEDED

STRINGLIST  * inlineFileList;

// from NMAKE.C
      // No of blanks is same as no of Allowed options in NMAKE; currently 14
      // L = nologo, H = help
      //      corr to                  ABCDEHIKLNPQRSTUY?
char          makeflags[] = "MAKEFLAGS=                  ";
BOOL          firstToken;           // to initialize parser
BOOL          bannerDisplayed;
UCHAR         flags;                // holds -d -s -n -i -u
UCHAR         gFlags;               // "global" -- all targets
FILE        * file;
STRINGLIST  * makeTargets;          // list of targets to make
STRINGLIST  * makeFiles;            // user can specify > 1
BOOL          fDebug;
MACRODEF    * pMacros;
STRINGLIST  * pValues;

// from LEXER.C
BOOL          colZero       = TRUE; // global flag set if at column zero of a makefile/tools.ini
unsigned      line;
char        * fName;
char        * string;
INCLUDEINFO   incStack[MAXINCLUDE]; //Assume this is initialized to null
int           incTop;

// Inline file list -- Gets created in lexer.c and is used by action.c to
// produce a delete command when 'NOKEEP' or Z option is set
//
SCRIPTLIST  * scriptFileList;

// from PARSER.C
BOOL          init;                 // global boolean value to indicate if tools.ini is being parsed
UCHAR         stack[STACKSIZE];
int           top       = -1;       // gets pre-incremented before use
unsigned      currentLine;          // used for all error messages

// from ACTION.C


MACRODEF    * macroTable[MAXMACRO];
MAKEOBJECT  * targetTable[MAXTARGET];
STRINGLIST  * macros;
STRINGLIST  * dotSuffixList;
STRINGLIST  * dotPreciousList;
RULELIST    * rules;
STRINGLIST  * list;
char        * name;
BUILDBLOCK  * block;
UCHAR         currentFlags;
UCHAR         actionFlags;

// from BUILD.C


unsigned      errorLevel;
unsigned      numCommands;
char        * shellName;
char        * pCmdLineCopy;
char          CmdLine[MAXCMDLINELENGTH];

// from IFEXPR.C

UCHAR         ifStack[IFSTACKSIZE];
int           ifTop     = -1;       // pre-incremented
char        * lbufPtr;              // ptr to alloced buf
char        * prevDirPtr;           // ptr to directive
unsigned      lbufSize;             // initial size
int           chBuf     = -1;


// from UTIL.C

char        * dollarDollarAt;
char        * dollarLessThan;
char        * dollarStar;
char        * dollarAt;
STRINGLIST  * dollarQuestion;
STRINGLIST  * dollarStarStar;

// from parser.c

char          buf[MAXBUF];

// from action.c

const char    suffixes[]  = ".SUFFIXES";
const char    ignore[]    = ".IGNORE";
const char    silent[]    = ".SILENT";
const char    precious[]  = ".PRECIOUS";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\globals.h ===
//  globals.h - global variables/needed across modules
//
//   Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Globals.c is the routine in which global variables reside. Globals.h mirrors
//  the declarations in globals.c as externs and is included in all routines that
//  use globals.
//
// Notes:
//  This module was created for an interesting reason. NMAKE handles recursive
//  calls by saving its global variables somewhere in memory. It handles this by
//  allocating all global variables which have value changes in each recursive
//  in adjacent memory. The routine called recursively is doMake() and before it
//  is called the address of this chunk of memory is stored. When the recursive
//  call returns the memory is restored using the stored address. startOfSave and
//  endOfSave give the location of this chunk. The reason this method was opted
//  for is that spawning of NMAKE would consume a lot of memory under DOS. This
//  might not be very efficient under OS/2 because the code gets shared.
//
// Revision History:
//  15-Nov-1993 JdR Major speed improvements
//  04-Apr-1990 SB  Add fHeapChk
//  01-Dec-1989 SB  Made some variables near and pushed some into saveArea
//  19-Oct-1989 SB  variable fOptionK added (ifdef SLASHK)
//  02-Oct-1989 SB  add dynamic inline file handling support
//  24-Apr-1989 SB  Added ext_size, filename_size, filenameext_size &
//                  resultbuf_size for OS/2 1.2 support
//  05-Apr-1989 SB  made revList, delList, scriptFileList NEAR
//  22-Mar-1989 SB  removed tmpFileStack and related variables
//  16-Feb-1989 SB  added delList to have scriptfile deletes at end of make
//  21-Dec-1988 SB  Added scriptFileList to handle multiple script files
//                  removed tmpScriptFile and fKeep (not reqd anymore)
//  19-Dec-1988 SB  Added fKeep to handle KEEP/NOKEEP
//  14-Dec-1988 SB  Added tmpScriptFile for 'z' option
//  30-Nov-1988 SB  Added revList to handle 'z' option
//  23-Nov-1988 SB  Added CmdLine[] to handle extmake syntax
//                  made pCmdLineCopy Global in build.c
//  21-Oct-1988 SB  Added fInheritUserEnv to inherit macros
//  20-Sep-1988 RB  Clean up.
//  17-Aug-1988 RB  Declare everything NEAR.
//  06-Jul-1988 rj  Ditched shell and argVector globals.
//                  Put all ECS declarations as macros in here.

#if defined(STATISTICS)
extern unsigned long CntfindMacro;
extern unsigned long CntmacroChains;
extern unsigned long CntinsertMacro;
extern unsigned long CntfindTarget;
extern unsigned long CnttargetChains;
extern unsigned long CntStriCmp;
extern unsigned long CntunQuotes;
extern unsigned long CntFreeStrList;
extern unsigned long CntAllocStrList;
#endif

extern BOOL  fOptionK;              // user specified /K ?
extern BOOL  fDescRebuildOrder;     // user specified /O ?
extern BOOL  fSlashKStatus;

// boolean used by action.c & nmake.c

// Required for NMAKE enhancement -- to make NMAKE inherit user modified
// changes in the environment. To be set to true before defineMacro() is
// called so that user defined changes in environment variables are
// reflected in the environment. If set to false then these changes are
// made only in NMAKE tables and the environment remains unchanged

extern BOOL fInheritUserEnv;

extern BOOL fRebuildOnTie;          // TRUE if /b specified, Rebuild on tie

// Used by action.c and nmake.c

// delList is the list of delete commands for deleting inline files which are
// to be deleted before NMAKE exits & have a NOKEEP action specified.

extern STRINGLIST * delList;

// Complete list of generated inline files. Required to avoid duplicate names

extern STRINGLIST * inlineFileList;

// from NMAKE.C

extern BOOL     firstToken;         // to initialize parser
extern BOOL     bannerDisplayed;
extern UCHAR    flags;              // holds -d -s -n -i
extern UCHAR    gFlags;             // "global" -- all targets
extern char     makeflags[];
extern FILE   * file;
extern STRINGLIST * makeTargets;    // list of targets to make
extern STRINGLIST * makeFiles;      // user can specify > 1
extern BOOL     fDebug;


// from LEXER.C

extern unsigned     line;
extern BOOL     colZero;            // global flag set if at column zero
                                    //  of a makefile/tools.ini
extern char   * fName;
extern char   * string;
extern INCLUDEINFO  incStack[MAXINCLUDE];
extern int      incTop;

// Inline file list -- Gets created in lexer.c and is used by action.c to
// produce a delete command when 'NOKEEP' or Z option is set

extern SCRIPTLIST * scriptFileList;

// from PARSER.C

#define STACKSIZE 16

extern UCHAR    stack[STACKSIZE];
extern int      top;                // gets pre-incremented before use
extern unsigned currentLine;        // used for all error messages
extern BOOL     init;               // global boolean value to indicate
                                    // if tools.ini is being parsed
// from ACTION.C

extern MACRODEF   * macroTable[MAXMACRO];
extern MAKEOBJECT * targetTable[MAXTARGET];
extern STRINGLIST * macros;
extern STRINGLIST * dotSuffixList;
extern STRINGLIST * dotPreciousList;
extern RULELIST   * rules;
extern STRINGLIST * list;
extern char       * name;
extern BUILDBLOCK * block;
extern UCHAR        currentFlags;
extern UCHAR        actionFlags;


// from BUILD.C

extern unsigned errorLevel;
extern unsigned numCommands;
extern char   * pCmdLineCopy;

// Used to store expanded Command Line returned by SPRINTF, the result on
// expanding extmake syntax part in the command line
extern char      CmdLine[MAXCMDLINELENGTH];

// from IFEXPR.C

#define IFSTACKSIZE     16

extern UCHAR    ifStack[IFSTACKSIZE];
extern int      ifTop;              // gets pre-incremented before use
extern char   * lbufPtr;            // pointer to alloc'd buffer
                                    // we don't use a static buffer so
                                    // that buffer may be realloced
extern char   * prevDirPtr;         // ptr to directive to be processed
extern unsigned lbufSize;           // initial size of the buffer


// from UTIL.C

extern char   * dollarDollarAt;
extern char   * dollarLessThan;
extern char   * dollarStar;
extern char   * dollarAt;
extern STRINGLIST * dollarQuestion;
extern STRINGLIST * dollarStarStar;

extern char     buf[MAXBUF];        // from parser.c

extern const char suffixes[];       // from action.c
extern const char ignore[];
extern const char silent[];
extern const char precious[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\exec.cpp ===
//  Exec.C - Contains routines that have do to with execing programs
//
// Copyright (c) 1988-1991, Microsoft Corporation. All Rights Reserved.
//
// Purpose:
//  Contains routines that spawn programs ...
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  06-Oct-1992 GBS Removed extern for _pgmptr
//  10-Aug-1992 GBS Change file parsing in execLine to use splitpath
//  19-Aug-1992 SS  Remove Quotes from cd argument.
//  08-Jun-1992 SS  add IDE feedback support
//  08-Jun-1992 SS  Port to DOSX32
//  16-May-1991 SB  Created from routines that existed elsewhere

#include "precomp.h"
#pragma hdrstop

#define SLASH '\\'
#define PUBLIC
#define QUOTE '\"'

extern BOOL processInline(char *, char **, STRINGLIST **, BOOL);

#ifdef _M_IX86
extern UCHAR fRunningUnderChicago;
#else
#define fRunningUnderChicago FALSE
#endif

char * getComSpec(void);
BOOL   iterateCommand(char*, STRINGLIST*, UCHAR, UCHAR, char *, unsigned*);
void   removeQuotes(int, char **);
void   touch(char*, BOOL);


//buffer for path of .cmd/.bat
extern char * makeStr;
extern char * shellName;


char szCmdLineBuf[MAXCMDLINELENGTH];
char *szNmakeProgName;

//  buildArgumentVector -- builds an argument vector from a command line
//
// Scope:
//  Local.
//
// Purpose:
//  It builds an argument vector for a command line. This argument vector can
//  be used by spawnvX routines. The algorithm is explained in the notes below.
//
// Input:
//  argc    -- The number of arguments created in the argument vector
//  argv    -- The actual argument vector created
//              (Ignored if NULL)
//  cmdline -- The command line whose vector is required
//
// Output:
//  Returns the number of arguments and the argument vector as parameters
//
// Errors/Warnings:
// Assumes:
//  That the behaviour of cmd.exe i.e. parses quotes but does not disturb them.
//  Assumes that the SpawnVX routines will handle quotes as well as escaped
//  chars.
//
// Modifies Globals:
// Uses Globals:
// Notes:
//  Scan the cmdline from left to the end building the argument vector along
//  the way. Whitespace delimits arguments except for the first argument for
//  which the switch char '/' is also allowed. Backslash can be used to escape
//  a char and so ignore the character following it. Parse the quotes along
//  the way. If an argument begins with a double-quote then all characters till
//  an unescaped double-quote are part of that argument. Likewise, if an
//  unescaped Doublequote occurs within an argument then the above follows. If
//  the end of the command line comes before the closing quote then the
//  argument goes as far as that.

void
buildArgumentVector(
    unsigned *argc,
    char **argv,
    char *cmdline
    )
{
    char *p;                        // current loc in cmdline
    char *end;                      // end of command line
    BOOL    fFirstTime = TRUE;      // true if 1st argument

    // 11-May-1993 HV _mbschr() bug: return NULL
    // end = _tcschr(p = cmdline, '\0');
    // Work around:
    end = p = cmdline;
    while (*end)
        end++;

    for (*argc = 0; p < end; ++*argc) {
        p += _tcsspn(p, " \t");    // skip whitespace
        if (p >= end)
            break;
        if (argv)
            *argv++ = p;
        if (*p == '\"') {

            // If the word begins with double-quote, find the next
            // occurrence of double-quote which is not preceded by backslash
            // (same escape as C runtime), or end of string, whichever is
            // first.  From there, find the next whitespace character.

            for (++p; p < end; p = _tcsinc(p)) {
                if (*p == '\\')
                    ++p;            // skip escaped character
                else if (*p == '\"')
                    break;
            }
            if (p >= end)
                continue;
            ++p;
            p = _tcspbrk(p, " \t");
        } else {

            // For the first word on the command line, accept the switch
            // character and whitespace as terminators.  Otherwise, just
            // whitespace.

            p = _tcspbrk(p, " \t\"/");
            for (;p && p < end;p = _tcspbrk(p+1, " \t\"/")) {
                if (*p == '/' && !fFirstTime)
                    continue;       // after 1st word '/' is !terminator
                else break;
            }
            if (p && *p == '\"') {
                for (p++;p < end;p++) {     // inside quote so skip to next one
                    if (*p == '\"')
                        break;
                }
                p = _tcspbrk(p, " \t");    // after quote go to first whitespace
            }
            if (fFirstTime) {
                fFirstTime = FALSE;

                // If switch char terminates the word, replace it with 0,
                // re-allocate the word on the heap, restore the switch and set
                // p just before the switch.  It would be easier to shift
                // everything right but then we have to worry about overflow.

                if (p && *p == '/' && argv) {
                    *p = '\0';
                    argv[-1] = makeString(argv[-1]);
                    *p-- = '/';
                }
            }
        }
        if (!p)
            p = end;
        // Now, p points to end of command line argument
        if (argv)
            *p++ = '\0';
    }
    if (argv)
        *argv = NULL;
}

PUBLIC int
doCommands(
    char *name,
    STRINGLIST *s,
    STRINGLIST *t,
    UCHAR buildFlags,
    char *pFirstDep
    )
{
    STRINGLIST *temp;
    int rc;
    temp = makeNewStrListElement();
    temp->text = makeString(name);
    rc = doCommandsEx (temp, s, t, buildFlags, pFirstDep);
    free_stringlist(temp);
    return rc;
}

PUBLIC int
doCommandsEx(
    STRINGLIST *nameList,
    STRINGLIST *s,
    STRINGLIST *t,
    UCHAR buildFlags,
    char *pFirstDep
    )
{
    char *u, *v;
    UCHAR cFlags;
    unsigned status = 0;
    int retryCount = 0;
    char c;
    char *Cmd;
    char *pLine;
    BOOL fExpanded;
    char *pCmd;
    size_t cbLine;

#ifdef DEBUG_ALL
    if (fDebug) {
        printf("* doCommands:");
        DumpList(nameList);
        DumpList(s);
        DumpList(t);
    }
#endif

#ifdef DEBUG_ALL
    printf("DEBUG: doCommands 1\n");
#endif
    ++numCommands;
    if (ON(gFlags, F1_QUESTION_STATUS))
        return(0);

    if (ON(gFlags, F1_TOUCH_TARGETS)) {
        STRINGLIST *pName;
        for (pName = nameList; pName; pName = pName->next) {
            touch(pName->text, (USHORT) ON(buildFlags, F2_NO_EXECUTE));
        }
        return(0);
    }

#ifdef DEBUG_ALL
    printf("DEBUG: doCommands 2\n");
#endif

    for (; s; s = s->next) {
        fExpanded = processInline(s->text, &Cmd, &t,
            ON(buildFlags, F2_DUMP_INLINE));
        cFlags = 0;
        errorLevel = 0;
        u = Cmd;
        for (v = u; *v; v = _tcsinc(v)) {
            if (*v == ESCH) ++v;
            else if (*v == '$') {
                if (*++v == '$')
                    continue;
// commented out 15-Apr-93 by JonM.  This code forces recursive nmake to be
// executed even if -n, but it's hosed (the -n is not passed to the recursive
// nmake), and the whole thing sounds like a bad idea anyway, so I'm going to
// turn it off.
//              if (!_tcsncmp(v, "(MAKE)", 6)) {
//                  SET(cFlags, C_EXECUTE);
//                  break;
//              }
            }
        }
#ifdef DEBUG_ALL
    printf("DEBUG: doCommands 2.1\n");
#endif
        for (c = *u; c == '!'  ||
                     c == '-'  ||
                     c == '@'  ||
                     c == ESCH ||
                     WHITESPACE(c); u = _tcsinc(u), c = *u) {
            switch (c) {
                case ESCH:
                    if (c = *++u, WHITESPACE(c))
                        c = ' ';    // keep going
                    else
                        c = ESCH;
                    break;

                case '!':
                    SET(cFlags, C_ITERATE);
                    break;

                case '-':
                    SET(cFlags, C_IGNORE);
                    ++u;
                    if (_istdigit(*u)) {
                        char *pNumber = u;

                        errorLevel = _tcstoul(u, &u, 10);
                        if (errno == ERANGE) {
                            *u = '\0';
                            makeError(line, CONST_TOO_BIG, pNumber);
                        }
                        while(_istspace(*u))
                            u++;
                    } else
                        errorLevel = UINT_MAX;
                    --u;
                    break;
                case '@':
                    if (
                        OFF(flags, F2_NO_EXECUTE)) {
                            SET(cFlags, C_SILENT);
                        }
                    break;
            }
            if (c == ESCH)
                break;              // stop parsing for cmd-line options
        }
#ifdef DEBUG_ALL
        printf("DEBUG: doCommands 2.2\n");
#endif
        if (ON(cFlags, C_ITERATE) &&
            iterateCommand(u, t, buildFlags, cFlags, pFirstDep, &status)
           ) {
            // The macros used by the command have to be freed & so we do so

            v = u;

#ifdef DEBUG_ALL
            printf("DEBUG: doCommands 2.21\n");
#endif
            if (_tcschr(u, '$'))
                u = expandMacros(u, &t);

#ifdef DEBUG_ALL
            printf("DEBUG: doCommands 2.22\n");
#endif
            if (v != u)
                FREE(u);
            if (OFF(buildFlags, F2_IGNORE_EXIT_CODES) &&
                fOptionK &&
                status &&
                status > errorLevel)
            {
                break;
            }
            continue;
        }
        v = u;

#ifdef DEBUG_ALL
        printf("DEBUG: doCommands 2.23\n");
#endif
        if (!fExpanded && _tcschr(u, '$'))
            u = expandMacros(u, &t);

#ifdef DEBUG_ALL
        printf("DEBUG: doCommands 2.24\n");
#endif

        cbLine = _tcslen(u) + 1;
        pLine = (char *) rallocate (__max(cbLine, MAXCMDLINELENGTH));
        _tcscpy(pLine, u);

        // by this time $< has already been expanded.
        // in order to allow processing of long commands that are due to
        // batch-mode rules, use a buffer that may be larger than MAXCMDLINELENGTH
        // Later we'll attempt to execute the long command directly, instead of
        // passing it to the shell.
        // Note: the macros expanded by ZFormat are not normally found in the
        // command block of a batch-mode rule, so it should be safe to use
        // max(cbLine, MAXCMDLINELENGTH) as a limit for ZFormat
        if (ZFormat (pLine, __max(cbLine, MAXCMDLINELENGTH), u, pFirstDep))
            makeError(0, COMMAND_TOO_LONG, u);

retry:
            status = execLine(pLine,
                              (BOOL)(ON(buildFlags, F2_NO_EXECUTE)
                                  || (OFF(buildFlags,F2_NO_ECHO)
                                  && OFF(cFlags,C_SILENT))),
                              (BOOL)((OFF(buildFlags, F2_NO_EXECUTE)
                                     )
                                     || ON(cFlags, C_EXECUTE)),
                              (BOOL)ON(cFlags, C_IGNORE), &pCmd);
            if (OFF(buildFlags, F2_IGNORE_EXIT_CODES)) {
                if (status == STATUS_PENDING) {
                    // Hack for ntvdm problem returning correct error code.
                    if (retryCount < 10) {
                        retryCount++;
                        goto retry;
                    }
                }
                if (status && status > errorLevel) {
                    if (!fOptionK)
                        makeError(0, BAD_RETURN_CODE, pCmd, status);
                }
            }
        if (v != u)
            FREE(u);
        FREE(Cmd);
        FREE(pLine);
        if (OFF(buildFlags, F2_IGNORE_EXIT_CODES) &&
            fOptionK &&
            status &&
            status > errorLevel)
        {
            break;
        }
    }

#ifdef DEBUG_ALL
    printf("DEBUG: doCommands 3\n");
#endif

    if (OFF(buildFlags, F2_IGNORE_EXIT_CODES) && fOptionK &&
            (status > errorLevel))
        return(status);
    else
        return(0);
}


//  expandCommandLine -- expands %name% strings in the Command Line
//
// Purpose:
//  The function expands '%name%' type strings in the Command Line. Its main
//  job is to assist FEmulateCommand() in emulating set for OS/2.
//
// Modifies:    buf -- The Command Line available globally
//
// Output:
//  Returns -- the position of 'name=value' part in the Command Line.
//          -- Null when no '=' is found so that FEmulateCommand() can pass the
//              line to the shell to signal syntax error.
// Note:
//  The shell does not give a syntax error for unmatched '%' and assumes it
//  as just another character in this case. This behaviour is duplicated
//  by expandCommandLine()

char *
expandCommandLine(
    void
    )
{
    char *Buf;                          // Buffer for expanded string
    char *pBuf;
    char *EnvBuf;                       // getenv returned string copy
    char *posName,                      // position of 'name=string' in Buf or buf
         *p,                            // points into buf
         *pEnv;                         // points into Env
    char ExpandName[MAXNAME];           // %name% string
    char *pExpandName;

    Buf = (char *)malloc(MAXCMDLINELENGTH);
    if (!Buf) {
        makeError(0, OUT_OF_MEMORY);
        return NULL;
    }

    EnvBuf = (char *)malloc(MAXCMDLINELENGTH);
    if (!EnvBuf) {
        makeError(0, OUT_OF_MEMORY);
        free(Buf);
        return NULL;
    }

    pBuf = Buf;
    _tcscpy(pBuf, "set");
    p = szCmdLineBuf + 3;               // go beyond 'set'
    pBuf +=3;
    /* Skip whitespace */
    for (;;p++) {
        if (!(WHITESPACE(*p)))
            break;                      // argc>1  this will happen
        else *pBuf++ = *p;
    }

    if (!_tcschr(p, '=')) {
        free(EnvBuf);
        free(Buf);
        return("");                     // Syntax error so pass to the shell
    } else {
        posName = pBuf;                 // fixes position of Name in Buf
    }

    // Now we look for environment variables and expand if required
    for (;*p != '=';p++)
        *pBuf++ = *p;

    for (;*p;) {
        if (*p == '%') {
            pExpandName = &ExpandName[0];
            while (*++p != '%' && *p)
                *pExpandName++ = *p;
            *pExpandName = '\0';
            if (!*p++) {                // unmatched %;so don't expand
                *pBuf='\0';             // from the environment; like set
                _tcscat(Buf, ExpandName);
                pBuf += _tcslen(ExpandName);
                break;                  // Done precessing quit #43290
            } else {                    // matched %;so expand from the environment
                EnvBuf[0] = '\0';
                if ((pEnv = getenv(ExpandName)) != (char *)NULL) {
                    *pBuf='\0';

                    // If the expanded command line is too long
                    // just say that we can't expand it!!! #43290
                    size_t len = _tcslen(pEnv) + _tcslen(Buf) + 1;
                    if (len > MAXCMDLINELENGTH) {
                        free(EnvBuf);
                        free(Buf);
                        return NULL;
                    }

                    _tcscat(EnvBuf, pEnv);
                    _tcscat(Buf,EnvBuf);
                    pBuf += _tcslen(EnvBuf);
                }
            }
        } else
            *pBuf++ = *p++;
    }
    *pBuf = '\0';
    _tcscpy(szCmdLineBuf, Buf);
    *posName = '\0';
    posName = szCmdLineBuf + _tcslen(Buf);          // Offset into buf
    free(EnvBuf);
    free(Buf);
    return(posName);
}

// expandEnvVars -- expands %name% strings in szArg
//
// Returns -- szNew: the resulting expanded string
//          (szNew should be FREEd by the caller)
//
char *
expandEnvVars(
    char *szArg
    )
{
    char *pchLeft = NULL;
    char *pchRight = NULL;
    char *pchStart = szArg;

    char *szNew = makeString("");

    while (*pchStart) {
        pchLeft = _tcschr(pchStart, '%');
        if (pchLeft) {
            pchRight = _tcschr(pchLeft + 1, '%');
        }

        if (pchLeft && pchRight) {
            char *szEnv;
            *pchLeft = '\0';
            *pchRight = '\0';
            szNew = reallocString(szNew, pchStart);
            if (szEnv = getenv(pchLeft + 1)) {
                szNew = reallocString(szNew, szEnv);
            }
            else {
                // no matching env var was found
                // append the %..% string literary
                *pchLeft = '%';
                szNew = reallocString(szNew, pchLeft);
                szNew = reallocString(szNew, "%");
            }
            *pchLeft = '%';
            *pchRight = '%';
            pchStart = pchRight + 1;
            pchLeft = NULL;
            pchRight = NULL;
        }
        else {
            szNew = reallocString(szNew, pchStart);
            pchStart += _tcslen(pchStart);
        }
    }
    return szNew;
}


//  FEmulateCommand - look for certain commands and emulate them
//
// Emulate $(MAKE), cd, chdir, and <drive letter>:.
// Also emulates 'set'.
//
// RETURNS:    TRUE if command emulated, FALSE if not.
//
// Note:
//  In set emulation if a syntax error is discovered then it lets the
//  shell handle it. It does this by returning FALSE.

BOOL
FEmulateCommand(
    int argc,
    char **argv,
    int *pStatus
    )
{
    char *pArg0 = argv[0];
    char *pArg1 = argv[1];

    if (_istalpha(*pArg0) && pArg0[1] == ':' && !pArg0[2]) {
        // If "<drive letter>:" then change drives.  Ignore everything after
        // the drive letter, just like the shell does.

        _chdrive(_totupper(*pArg0) - 'A' + 1);
        *pStatus = 0;
        return(TRUE);
    }

    if (!_tcsicmp(pArg0, "set")) {
        char *pNameVal;         // the "name=value" string

        // If "set" then pass it to the shell and if "set string" then put it
        // into the environment. Let the shell handle the syntax errors.

        if (argc == 1) {
            return(FALSE);          // pass it to the shell
        }

        // expandCommandLine cannot handle lines > MAXCMDLINELENGTH
        // In that case szCmdLineBuf will be empty
        if (!szCmdLineBuf[0])
            return (FALSE);

        pNameVal = expandCommandLine();

        if (pNameVal == NULL)
        {
            // Expanded commad line too long
            return FALSE;
        }

        if (!*pNameVal) {
            // If there is a syntax error let the shell handle it

            return(FALSE);
        }

        if ((*pStatus = PutEnv(makeString(pNameVal))) == -1) {
            makeError(currentLine, OUT_OF_ENV_SPACE);
        }
    } else {
        // If "cd foo" or "chdir foo", do a chdir() else in protect mode this
        // would be a no-op.  Ignore everything after 1st arg, just like the
        // shell does.

        char *szArg;

        if (!_tcsnicmp(pArg0, "cd", 2)) {
            pArg0 += 2;
        } else if (!_tcsnicmp(pArg0, "chdir", 5)) {
            pArg0 += 5;
        } else {
            return(FALSE);
        }

        // At this point, a prefix of argv[0] matches cd or chdir and pArg0
        // points to the next char.  Check for a path separator in argv[0]
        // (e.g., cd..\foo) or else use the next arg if present.

        // if there are more than two arguments then let the shell handle it
        if (argc > 2) {
            return(FALSE);
        }

        // Remove quotes, if any from the argument
        removeQuotes(argc, argv);

        if (!*pArg0 && pArg1) {
            // Under certain circumstances the C RunTime does not help us
            // e.g. 'd:', in this case let the shell do it ...
            if (isalpha(*pArg1) && pArg1[1] == ':' && !pArg1[2]) {
                return(FALSE);
            }

            szArg = expandEnvVars(pArg1); // [VS98 2251]
            *pStatus = _chdir(szArg);
            FREE (szArg);
        } else if (*pArg0 == '.' || PATH_SEPARATOR(*pArg0)) {
            szArg = expandEnvVars(pArg0); // [VS98 2251]
            *pStatus = _chdir(szArg);
            FREE (szArg);
        } else {
            // Unrecognized syntax--we can't emulate.

            return(FALSE);
        }
    }

    // If error, simulate a return code of 1.

    if (*pStatus != 0) {
        *pStatus = 1;
    }

    return(TRUE);
}

#ifdef WIN95

int __cdecl
cmpSzPsz(
    const void *sz,
    const void *psz
    )
{
   const char *sz1 = (char *) sz;
   const char *sz2 = *(char **) psz;

   return(_tcsicmp(sz1, sz2));
}


BOOL
FInternalCommand(
    const char *szName
    )
{
    const char * const *pszInternal;

    static const char * const rgszInternal[] =
    {
        "BREAK",
        "CALL",
        "CD",
        "CHDIR",
        "CLS",
        "COPY",
        "CTTY",
        "DATE",
        "DEL",
        "DIR",
        "DIR.",
        "ECHO",
        "ECHO.",
        "ERASE",
        "EXIT",
        "FOR",
        "GOTO",
        "IF",
        "MD",
        "MKDIR",
        "PATH",
        "PAUSE",
        "PROMPT",
        "RD",
        "REM",
        "REN",
        "RENAME",
        "RMDIR",
        "SET",
        "SHIFT",
        "TIME",
        "TYPE",
        "VER",
        "VERIFY",
        "VOL"
    };


    pszInternal = (const char * const *) bsearch(szName,
                                                 rgszInternal,
                                                 sizeof(rgszInternal) / sizeof(rgszInternal[0]),
                                                 sizeof(rgszInternal[0]),
                                                 &cmpSzPsz);

    return(pszInternal != NULL);
}

#endif  // WIN95

// redirect -- handles redirection of input or output.
//
// arguments:   dir - READ => input,
//                    WRITE => output,
//                    APPEND => append to end of the file.
//
//              p - pointer to buffer that has the filename as
//                  well as the rest of the command string.
//
// return value     FALSE => error (freopen fails)
//                  TRUE => normal return.
//
// the freopen() call sets up the redirection. the rest of the
// command string is then copied forward.

BOOL
redirect(
    char *name,
    unsigned which
    )
{
    char *p;
    char c = '\0';
    BOOL fStatus;
    char *mode;
    FILE *stream;
    FILE *newFile;

    while (WHITESPACE(*name)) {
        name++;
    }

    if (p = _tcspbrk(name, " \t<>\r")) {
        c = *p;

        *p = '\0';
    }

    if (which == READ) {
        mode = "r";
        stream = stdin;
    } else {
        stream = stdout;

        if (which == WRITE) {
            mode = "w";
        } else {
            mode = "a";
        }
    }

    newFile = freopen(name, mode, stream);

    fStatus = (newFile != NULL);

    if (fStatus && (which == APPEND)) {
        if (_lseek(_fileno(newFile), 0L, SEEK_END) == -1)
            return FALSE;
    }

    while (*name) {
        *name++ = ' ';
    }

    if (p) {
        *p = c;
    }

    return(fStatus);
}


BOOL
FDoRedirection(
    char *p,
    int *oldIn,
    int *oldOut
    )
{
    BOOL in = FALSE;
    BOOL out = FALSE;
    BOOL fReturn = FALSE;
    char *q;
    unsigned which;
    char *save = NULL;


    while (q = _tcspbrk(p, "<>|")) {
        switch (*q) {
            case '<':
                if (in) {
                    fReturn = TRUE;
                    break;
                }

                if (!save) {
                    save = makeString(p);
                }

                *q++ = ' ';
                p = q;
                in = TRUE;
                *oldIn = _dup(_fileno(stdin));

                if ((*oldIn == -1) || !redirect(q, READ)) {
                    fReturn = TRUE;
                    break;
                }
                break;

            case '>':
                if (out) {
                    fReturn = TRUE;
                    break;
                }

                if (!save) {
                    save = makeString(p);
                }

                *q++ = ' ';
                p = q;
                out = TRUE;

                if (*q == '>') {
                    *q++ = ' ';
                    which = APPEND;
                } else {
                    which = WRITE;
                }

                *oldOut = _dup(_fileno(stdout));

                if ((*oldOut == -1) || !redirect(q, which)) {
                    fReturn = TRUE;
                    break;
                }
                break;

            case '|':
                fReturn = TRUE;
                break;

            default :
                makeError(0, BUILD_INTERNAL);
        }

        if (fReturn) {
            break;
        }
    }

    if (fReturn) {
        if (save != NULL) {
            _tcscpy(p, save);
            FREE(save);
        }

        if (in && (*oldIn != -1)) {
            if (_dup2(*oldIn, _fileno(stdin)) == -1) {
                makeError(0, BUILD_INTERNAL);
            }

            _close(*oldIn);

            *oldIn = -1;
        }

        if (out && (*oldOut != -1)) {
            if (_dup2(*oldOut, _fileno(stdout)) == -1) {
                makeError(0, BUILD_INTERNAL);
            }

            _close(*oldOut);

            *oldOut = -1;
        }

    }

    return(fReturn);
}


BOOL
FSearchForExecutableExt(
    const char *szFilename,
    const char *szExt,
    BOOL fHasPath,
    char *szPath
    )
{
    char szFullName[_MAX_PATH] = {0};

    strncat(szFullName, szFilename, sizeof(szFullName)-1);
    strncat(szFullName, szExt, sizeof(szFullName)-strlen(szFullName)-1);
    if (fHasPath) {
       if (_access(szFullName, 0) == 0) {
          szPath[0] = '\0';
          strncat(szPath, szFullName, _MAX_PATH);

          return(TRUE);
       }

       return(FALSE);
    }

    _searchenv(szFullName, "PATH", szPath);

    return(szPath[0] != '\0');
}


BOOL
FSearchForExecutable(char *szFullName, char *szPath, BOOL *fBat)
{
    char szDrive[_MAX_DRIVE];
    char szDir[_MAX_DIR];
    char szFileName[_MAX_FNAME];
    char szNoExt[_MAX_PATH];
    BOOL fHasPath;
    char *szEndQuote;
    BOOL fHasQuotes = FALSE;

    // Ignore any given extension.  This is what COMMAND.COM does,

    char *szToPass = szFullName;

    if (*szFullName == QUOTE) {
        // get rid of any number of quotes at the beginning and at the end of the
        // string. This allows handling names enclosed in multiple quotes that are
        // accepted by the shell (DS 14300)
        szEndQuote = _tcsdec(szFullName, szFullName + _tcslen(szFullName));

        if (szEndQuote) {
            if (QUOTE == *szEndQuote) {
    
                while (QUOTE == *szToPass)
                    szToPass ++;
    
                while (szEndQuote > szToPass) {
                    char *szPrev = _tcsdec (szToPass, szEndQuote);
                    if (szPrev) {
                        if (QUOTE != *szPrev)
                            break;
                    }
                    szEndQuote = szPrev;
                }

                if (szEndQuote) {
                    *szEndQuote = '\0';
                    fHasQuotes = TRUE;
                }
            }
        }
    }

    _splitpath(szToPass, szDrive, szDir, szFileName, NULL);
    _makepath(szNoExt, szDrive, szDir, szFileName, NULL);
    fHasPath = (szDrive[0] != '\0') || (szDir[0] != '\0');

    *fBat = FALSE;

    // Search for .COM file

    if (FSearchForExecutableExt(szNoExt, ".com", fHasPath, szPath)) {
        goto success;
    }

    // Search for .EXE file

    if (FSearchForExecutableExt(szNoExt, ".exe", fHasPath, szPath)) {
        goto success;
    }

    // Search for .BAT file

    if (FSearchForExecutableExt(szNoExt, ".bat", fHasPath, szPath)) {
        *fBat = TRUE;

        goto success;
    }

    return(FALSE);

success:
    if (fHasQuotes) {
        size_t size = _tcslen(szPath);
        memmove(szPath+1, szPath, size);
        *szPath = '"';
        *(szPath + size + 1) = '"';
        *(szPath + size + 2) = '\0';
        *szEndQuote = '"';
    }
    return TRUE;

}


//  execLine -- execute a command line
//
// Scope:   Global (build.c, rpn.c)
//
// Purpose:
//  Parses the command line for redirection characters and redirects stdin and
//  stdout if "<", ">", or ">>" are seen.  If any of the following occur,
//  restore the original stdin and stdout, pass the command to the shell, and
//  invoke the shell:
//     - the command line contains "|" (pipe)
//     - a syntax error occurs in parsing the command line
//     - an error occurs in redirection
//  Otherwise, attempt to invoke the command directly, then restore the
//  original stdin and stdout.  If this invocation failed because of
//  file-not-found then pass the command to the shell and invoke the shell.
//
// Input:   line         -- The command line to be executed
//          echoCmd      -- determines if the command line is to be echoed
//          doCmd        -- determines if the command is to be actually executed
//          ignoreReturn -- determines if NMAKE is to ignore the return code on
//                          execution
//          ppCmd        -- if non-null then on error returns command executed
//
// Output:  Returns ... return code from child process
//                  ... -1 if error occurs
//
// Notes:
//  1/ Quoted strings can have redir chars "<>" which will be skipped over.
//  2/ Unmatched quotes cause error; redir chars are replaced by space char.
//  3/ Dup stdin file handle then redirect it. If we have to use the shell,
//     restore the original command line.
//  4/ Emulate certain commands such as "cd" to help prevent some makefiles
//     from breaking when ported from DOS to OS/2.
//
// Algorithm for spawning commands:
//  If we can't handle the syntax, let the shell do everything.  Otherwise,
//  first check to see if the command (without extension) is a DOS built-in &
//  if it is, call the shell to execute it (this is how cmd.exe behaves)
//  If it's not a built-in, we check to see if it has a .cmd or a .bat
//  extension (depending on whether we're in DOS or OS/2). If it does, we
//  call system() to execute it.
//  If it has some other extension, we ignore the extension and go looking for
//  a .cmd or .bat file.  If we find it, we execute it with system().
//  Otherwise, we try to spawn it (without extension). If the spawn fails,
//  we issue an unknown program error.

int
execLine(
    char *line,
    BOOL echoCmd,
    BOOL doCmd,
    BOOL ignoreReturn,
    char **ppCmd
    )
{
    char **argv;
    BOOL fUseShell;
    BOOL fLongCommand;
    int status;
    unsigned argc;

    if (!shellName) {
        shellName = getComSpec();
    }

    switch (*line) {
        case '@':
            // Turn off echo if it was on.  This handles the case where the "@"
            // was in a macro.
            //
            line++;
            if (doCmd)
                echoCmd = 0;
            break;

        case '-':
            ignoreReturn = TRUE;
            ++line;
            if (_istdigit(*line)) {
                char * pNumber = line;
                errorLevel = _tcstoul(line, &line, 10);
                if (errno == ERANGE) {
                    *line = '\0';
                    makeError(0, CONST_TOO_BIG, pNumber);       // Todo: replace 0 with line number
                }
                while(_istspace(*line))
                      line++;
            } else
                errorLevel = UINT_MAX;
            break;
    }

    // handle null command ...
    if (!line[0])
        return(0);

#if 0
    // 10/10/96: disabled to allow execution of long
    // commands that are produced by batch-mode rules

    // copy command line into buffer
    if (_tcslen(line) < MAXCMDLINELENGTH)
        _tcscpy(szCmdLineBuf, line);
    else
        makeError(0, COMMAND_TOO_LONG, line);
#endif

    fLongCommand = _tcslen(line) >= MAXCMDLINELENGTH;
    if (!fLongCommand)
        _tcscpy(szCmdLineBuf, line);
    else
        *szCmdLineBuf = '\0';

    // Allocate a copy of the command line on the heap because in a
    // recursive call to doMake(), argv pointers will be allocated from
    // the static buffer which will then be trashed.  For buildArg...().

    pCmdLineCopy = makeString(line);

    // If -n then echo command if not '$(MAKE)'
    if (echoCmd) {
        printf("\t%s\n", pCmdLineCopy);
        fflush(stdout);
    }

    // Build arg vector.  This is a waste on Windows NT since we're probably
    // going to use the shell, except we have to check for cd, $(MAKE),
    // etc. so we take advantage of the parsing code.

    buildArgumentVector(&argc, NULL, pCmdLineCopy);

    if (argc == 0) {
        return(0);                     // for case when macro command is null
    }

    // allocate argv. Leave space for extra arguments
    // (like "cmd", "/k", quotes) that may be added later
    argv = (char **) rallocate((argc + 5) * sizeof (char *));
    buildArgumentVector(&argc, argv, pCmdLineCopy);


    // 11-May-1993 HV The _mbsicmp() does not like NULL pointer
    //                so I have to check before calling it.
    if (argv[0] && makeStr && !_tcsicmp(argv[0], makeStr)) {
        if(!szNmakeProgName) {
            szNmakeProgName = _pgmptr;
            if( _tcspbrk( szNmakeProgName," " )) {      // If the program name has an embedded space in it
                // Let's put quotes around it
                szNmakeProgName = (char *)rallocate(_tcslen(szNmakeProgName)+3);
                *szNmakeProgName = QUOTE;               // First quote
                *(szNmakeProgName+1) = '\0';
                _tcscat( szNmakeProgName, _pgmptr );    // copy the full program name (self)
                _tcscat( szNmakeProgName, "\"");        // Final quote and \0
            }
        }
        argv[0]=szNmakeProgName;
    }

    if (!doCmd) {                   // don't execute command if doCmd false
        // For -n, emulate if possible.

        if (FEmulateCommand(argc, argv, &status)) {
            if (status && ppCmd) {
                *ppCmd = makeString(*argv);
            }

            return(status);         // return status
        }

        return(0);
    }

    // Try emulating the command if appropriate.  If not, and we should not
    // use the shell, try spawning command directly.

    // Check status when emulating

    if (FEmulateCommand(argc, argv, &status)) {
        // Command has been emulated.  Don't execute it again.

        fUseShell = FALSE;

    } else if (!fRunningUnderChicago && !fLongCommand) {
        // Use the shell for Windows NT unless the command is too long

        fUseShell = TRUE;

#ifdef WIN95
    } else if (fRunningUnderChicago && FInternalCommand(argv[0])) {
        // Under Windows 95 or MS-DOS, use the shell for internal commands

        fUseShell = TRUE;
#endif  // WIN95

    } else {
        int oldIn = -1;                // Old stdin file handle
        int oldOut = -1;               // Old stdout file handle

        // Under Windows 95 or MS-DOS, COMMAND.COM doesn't return child return
        // codes.  Try spawning the child application directly.

        // This code is also now used if the line is too long to be handled by
        // the NT command interpreter.

        fUseShell = FDoRedirection(line, &oldIn, &oldOut);

        if (!fUseShell) {
            char szPath[_MAX_PATH];
            char szQuotedPath[_MAX_PATH];
            BOOL fBat;

            if (oldIn != -1 || oldOut != -1) { // If there was a redirection
                // Need to re-build the argument vector without the
                // redirection characters
                FREE(pCmdLineCopy);
                pCmdLineCopy = makeString(line);
                buildArgumentVector(&argc, argv, pCmdLineCopy);
            }

            if (!FSearchForExecutable(argv[0], szPath, &fBat)) {
                /* If not found, set up an error since COMMAND will
                 * return 0.  This risks future incompatibility if new
                 * COMMAND.COM internal commands are added.
                 */
                if (fRunningUnderChicago) {
                    errno = ENOENT;
                    status = -1;
                } else {
                    fUseShell = TRUE;
                }
            } else if (fBat) {
                // If .bat extension, use COMMAND.COM.

                // UNDONE: CreateProcess is supposed to handle this.  Try it.

                fUseShell = TRUE;
            } else {
                // Spawn command directly.
                // DevStudio#8911, cannot use quotes in szPath
                if (*szPath == QUOTE && *(szPath + _tcslen(szPath) - 1) == QUOTE) {
                    // unquote the path.
                    size_t  cb = _tcslen(szPath);
                    memmove(szPath, szPath + 1, cb);
                    *(szPath + cb - 2) = '\0';
                }
#if 0
                {
                    int i;
                    printf("Spawning \"%s\" directly\n", szPath);
                    for (i = 0; i < argc; i++) {
                        printf ( "Arg[%d] = \"%s\"\n", i, argv[i] );
                    }
                }
#endif
                // DS 14300: Use full path for argv[0]
                // otherwise a shell command may be invoked
                // instead of an intended executable with the
                // same name. Enclosing quotes are needed if
                // string has embedded spaces

                argv[0] = szPath;
                if (_tcschr (argv[0], ' ')) {
                    *szQuotedPath = QUOTE;
                    _tcscpy (szQuotedPath+1, szPath);
                    _tcscat (szQuotedPath, "\"");
                    argv[0] = szQuotedPath;
                }
                status = (int)_spawnvp(P_WAIT, szPath, argv);   // REVIEW:WIN64 cast
            }
        }

        if (oldIn != -1) {
            if (_dup2(oldIn, _fileno(stdin)) == -1) {
                makeError(0, BUILD_INTERNAL);
            }

            _close(oldIn);
        }

        if (oldOut != -1) {
            if (_dup2(oldOut, _fileno(stdout)) == -1) {
                makeError(0, BUILD_INTERNAL);
            }

            _close(oldOut);
        }
    }

    if (fUseShell) {
        int i;
        BOOL fExtraQuote = FALSE;

        // copy command line into buffer
        if (_tcslen(line) < MAXCMDLINELENGTH)
            _tcscpy(szCmdLineBuf, line);
        else
            makeError(0, COMMAND_TOO_LONG, line);

        // Workaround for cmd bug (DevStudio #11253):
        // IF argv[0] (before we rearrange with cmd.exe /c) is quoted AND
        // any of the other argv[1...n] args have quotes   AND
        // running on NT
        // THEN we add an extra quote before argv[0] and one after argv[n].

        if ((*argv[0] == QUOTE) &&
            (*(argv[0] + _tcslen(argv[0]) - 1) == QUOTE) &&
            !fRunningUnderChicago) {
            for (i = argc - 1; i >= 1; i--) {
                if( _tcspbrk( argv[i],"\"" )) {
                    fExtraQuote = TRUE;
                    break;
                }
            }
        }

        if (fExtraQuote) {
            argv[argc++] = "\"";
            argv[argc] = NULL;
        }

        for (i = argc; i >= 0; i--) {
            argv[i+2] = argv[i];
        }

        argv[0] = shellName;
        argv[1] = fExtraQuote ? "/c \"" : "/c";

#if 0
        printf("Shelling \"%s\"\n", szCmdLineBuf);
        for (i = 0; i < argc + 2; i++) {
            printf ( "Arg[%d] = \"%s\"\n", i, argv[i] );
        }
#endif

        status = (int)_spawnvp(P_WAIT, argv[0], (const char * const *) argv);   // REVIEW:WIN64 cast
    }

    // Check for errors spawning command (distinct from errors *returned*
    // from a successfully spawned command).

    if (status == -1) {
        if (ignoreReturn) {
            status = 0;
        } else {
            switch (errno) {
                case 0:
                    // We (ie: nmake) didn't fail, but the spawned program did.
                    break;

                case ENOENT:
                    makeError(0, CANT_FIND_PROGRAM, argv[0]);
                    break;

                case ENOMEM:
                    makeError(0, EXEC_NO_MEM, fUseShell ? argv[2] : argv[0]);
                    break;

                default:
                    // Done to flag possibly erroneous decision made here [SB]
                    makeError(0, SPAWN_FAILED_ERROR, _strerror(NULL));
            }
        }
    }

    if (status && ppCmd) {
        *ppCmd = makeString(fUseShell ? argv[2] : argv[0]);
    }

    FREE(argv);
    FREE(pCmdLineCopy);
    return(status);
}


// getComSpec()
//
// actions:        Attempts to find system shell.
//
// First look for COMSPEC.  If not found, look for COMMAND.COM or CMD.EXE
// in the current directory then the path.  If not found, fatal error.
// It would make sense to give an error if COMSPEC is not defined but
// test suites are easier if no user-defined environment variables are
// required.

char *
getComSpec()
{
    char *szShell;
    char szPath[_MAX_PATH];

    if ((szShell = getenv("COMSPEC")) != NULL) {
        return(szShell);
    }

    if (fRunningUnderChicago) {
        szShell = "COMMAND.COM";
    } else {
        szShell = "CMD.EXE";
    }

    _searchenv(szShell, "PATH", szPath);

    if (szPath[0] == '\0') {
        makeError(0, NO_COMMAND_COM);
    }

    return(makeString(szPath));
}


BOOL
iterateCommand(
    char *u,
    STRINGLIST *t,
    UCHAR buildFlags,
    UCHAR cFlags,
    char *pFirstDep,
    unsigned *status
    )
{
    BOOL parens;
    char c = '\0';
    char *v;
    STRINGLIST *p = NULL,
               *q;
    char *pLine;
    char *pCmd;

    for (v = u; *v ; ++v) {
        parens = FALSE;
        if (*v == '$') {
            if (*(v+1) == '(') {
                ++v;
                parens = TRUE;
            }
            if (*(v+1) == '?') {
                if (parens
                    && !(_tcschr("DFBR", *(v+2)) && *(v+3) == ')')
                    && *(v+2) != ')')
                    continue;
                p = dollarQuestion;
                c = '?';
                break;
            }
            if (*++v == '*' && *(v+1) == '*') {
                if (parens
                    && !(_tcschr("DFBR", *(v+2)) && *(v+3) == ')')
                    && *(v+2) != ')')
                    continue;
                p = dollarStarStar;
                c = '*';
                break;
            }
        }
    }

    if (!*v) {
        return(FALSE);
    }

    v = u;
    q = p;
    while (p) {
        macros = t;
        if (c == '*') {
            p = dollarStarStar->next;
            dollarStarStar->next = NULL;
        } else {
            p = dollarQuestion->next;
            dollarQuestion->next = NULL;
        }
        u = expandMacros(v, &macros);

        expandExtmake(CmdLine, u, pFirstDep);
            pLine = CmdLine;
            *status = execLine(pLine,
                              (BOOL)(ON(buildFlags, F2_NO_EXECUTE)
                                  || (OFF(buildFlags,F2_NO_ECHO)
                                     && OFF(cFlags,C_SILENT))),
                              (BOOL)((OFF(buildFlags, F2_NO_EXECUTE)
                                     )
                                     || ON(cFlags, C_EXECUTE)),
                              (BOOL)ON(cFlags, C_IGNORE), &pCmd);
            if (OFF(buildFlags, F2_IGNORE_EXIT_CODES)) {
                if (*status && *status > errorLevel)
                    if (!fOptionK)
                        makeError(0, BAD_RETURN_CODE, pCmd, *status);
            }

        if (c == '*')
            dollarStarStar = dollarStarStar->next = p;
        else
            dollarQuestion = dollarQuestion->next = p;
        FREE(u);
        if (OFF(buildFlags, F2_IGNORE_EXIT_CODES) &&
            fOptionK &&
            *status &&
            *status > errorLevel)
        {
            break;
        }
    }
    if (c == '*')
        dollarStarStar = q;
    else
        dollarQuestion = q;
    return(TRUE);
}


void
removeQuotes(
    int argc,
    char **argv
    )
{
    char *t,
         *L_string;

    for (; argc--; argv++) {
        L_string = *argv;
        for (t = L_string; *t;) {
            if (*t == SLASH || *t == ESCH) {
                if (t[1] == QUOTE)
                   *(L_string)++ = *(t++);
                *(L_string++) = *(t++);
                continue;
            }
            if (*t == QUOTE)
                ++t;
            else {
                if (_istlead(* (unsigned char *)t))
                    *(L_string++) = *(t++);
                *(L_string++) = *(t++);
            }
        }
        *L_string = '\0';
    }
}

void
touch(
    char *s,
    BOOL minusN
    )
{
    int fd;
    char c;
    FILE * L_file;

    makeMessage(TOUCHING_TARGET, s);
    if (!minusN &&
            ((L_file = FILEOPEN(s, "r+b")) != NULL)) {
        fd = _fileno(L_file);
        if (_read(fd, &c, 1) > 0) {
            if (_lseek(fd, 0L, SEEK_SET)!=-1) {
                _write(fd, &c, 1);
            }
        }
        _close(fd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\error.cpp ===
//  ERROR.C -- error handling functions
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Revision History:
//  23-Feb-1994 HV  Change Copyright years to 1988-94
//  01-Feb-1994 HV  Move messages to external file.
//  29-Oct-1993 HV  Change the version scheme.
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  18-May-1993 HV  Change reference to messageTable[] to __MSGTAB.  The new
//                  (and more standard) mkmsg.exe output __MSGTAB instead
//                  of messageTable.  See message.h
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Jun-1992 SS  add IDE feedback support
//  08-Jun-1992 SS  Port to DOSX32
//  23-Feb-1990 SB  Version No correctly displayed
//  31-Jan-1990 SB  Debug version changes
//  05-Jan-1990 SB  Rev no in std format; #ifdef LEADING_ZERO for old code
//  07-Dec-1989 SB  Changed CopyRight Years to 1988-90; Add #ifdef DEBUG_HEAP
//  06-Nov-1989 SB  Error messages now show NMAKE and not argv0
//  04-Sep-1989 SB  heapdump() has two extra parameters
//  18-Aug-1989 SB  For -z nothing done by makeMessage; Fix later
//  05-Jul-1989 SB  localize rest of the messages in makeError()
//  14-Jun-1989 SB  modified to localize all messages and auto update version no
//  05-Jun-1989 SB  modified heapdump(), has a previous member in the list too
//  14-Apr-1989 SB  modified heapdump() for better error messages when DEBUG
//  05-Apr-1989 SB  made functions NEAR; all funcs to one code segment
//                  modified heapdump() to give better heap violations
//  22-Mar-1989 SB  del call to unlinkTmpFiles() ;add call to delScriptFiles().
//  17-Mar-1989 SB  heapdump() has an additional check built-in
//  10-Mar-1989 SB  Changed makeMessage() for -z to get echo CMD's into PWB.SHL
//  16-Feb-1989 SB  changed makeError() and makeMessage() to handle -help
//  09-Jan-1989 SB  changes in makeError() to handle -help correctly
//  05-Dec-1988 SB  Added CDECL for makeError(), makeMessage(); Pascal calling
//                  #ifdef'd heapdump prototype
//  20-Oct-1988 SB  Changed some eoln comments to be in the same column
//  12-Oct-1988 SB  Made GetFarMsg() to be Model independent & efficient
//  17-Aug-1988 RB  Clean up.
//  24-Jun-1988 rj  Added doError flag to unlinkTmpFiles call.

#include "precomp.h"
#pragma hdrstop

#include "verstamp.h"

#define FATAL       1               // error levels for
#define ERROR       2               // systems lanuguages
#define RESERVED    3               // products
#define WARNING     4

#define CopyRightYrs "1988-2000"
#define NmakeStr "NMAKE"


void __cdecl
makeError (
    unsigned lineNumber,
    unsigned msg,
    ...)
{
    unsigned exitCode = 2;          // general program err
    unsigned level;
    va_list args;                   // More arguments

    va_start(args, msg);            // Point 'args' at first extra arg

    if (ON(gFlags,F1_CRYPTIC_OUTPUT) && (msg / 1000) == WARNING) {
        return;
    }

    displayBanner();

    if (lineNumber) {
        fprintf(stderr, "%s(%u) : ", fName, lineNumber);
    } else {
        fprintf(stderr, "%s : ", NmakeStr);
    }

    switch (level = msg / 1000) {
        case FATAL:
            makeMessage(FATAL_ERROR_MESSAGE);
            if (msg == OUT_OF_MEMORY) {
                exitCode = 4;
            }
            break;

        case ERROR:
            makeMessage(ERROR_MESSAGE);
            break;

        case WARNING:
            makeMessage(WARNING_MESSAGE);
            break;
    }

    fprintf(stderr, " U%04d: ",msg);     // U for utilities
    vfprintf(stderr, get_err(msg), args);
    putc('\n', stderr);
    fflush(stderr);

    if (level == FATAL) {
        fprintf(stderr, "Stop.\n");
        delScriptFiles();

#if !defined(NDEBUG)
        printStats();
#endif
        exit(exitCode);
    }
}


void __cdecl
makeMessage(
    unsigned msg,
    ...)
{
    va_list args;
    FILE *stream = stdout;

    va_start(args, msg);

    if (msg != USER_MESSAGE && ON(gFlags, F1_CRYPTIC_OUTPUT)) {
        return;
    }

    displayBanner();

    if (msg >= FATAL_ERROR_MESSAGE && msg <= COPYRIGHT_MESSAGE_2) {
        stream = stderr;
    }

    if (msg == COPYRIGHT_MESSAGE_1) {
        putc('\n', stream);
    }

    vfprintf(stream, get_err(msg), args);

    if ((msg < COMMANDS_MESSAGE || msg > STOP_MESSAGE) && msg != MESG_LAST) {
        putc('\n', stream);
    }

    fflush(stream);
}


//  displayBanner - display SignOn Banner
//
// Scope:       Global
//
// Purpose:     Displays SignOn Banner (Version & Copyright Message)
//
// Assumes:     If rup is 0 then build version is to be suppressed
//
// Modifies Globals:
//  bannerDisplayed -- Set to TRUE
//
// Notes:
//  1> Display Banner to stderr for compatibility with Microsoft C Compiler.
//  2> rmj, rmm, rup are set by SLM as #define's in VERSION.H
//  3> szCopyrightYrs is a macro set in this file

void
displayBanner()
{
    if (bannerDisplayed) {
        return;
    }

    bannerDisplayed = TRUE;

    makeMessage(COPYRIGHT_MESSAGE_1, VER_PRODUCTVERSION_STR);
    makeMessage(COPYRIGHT_MESSAGE_2, CopyRightYrs);

    fflush(stderr);
}

//  usage - prints the usage message
//
// Scope:   Extern
//
// Purpose: Prints a usage message
//
// Output:  to screen
//
// Assumes: The usage messages are in order between MESG_FIRST and MESG_LAST in the
// messages file.


void
usage(void)
{
    unsigned mesg;

    for (mesg = MESG_FIRST; mesg < MESG_A; ++mesg) {
        makeMessage(mesg, "NMAKE");
    }

    for (mesg = MESG_A; mesg <= MESG_LAST; mesg++) {
        if (mesg == MESG_M) {
            mesg++;
        }

        if (mesg == MESG_V) {
            mesg++;
        }
        makeMessage(mesg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\ifexpr.cpp ===
//  IFEXPR.C -- routines to handle directives
//
//    Copyright (c) 1988-1989, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains routines to handle !directives. This module is transparent to
//  rest of NMAKE. It also contains lgetc() used by lexer.c
//
// Revision History:
//   15-Oct-1993 HV Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//   01-Jun-1993 HV Created UngetTxtChr()
//   01-Jun-1993 HV Change #ifdef KANJI to _MBCS.
//                  Eliminate #include <jctype.h>
//   10-May-1993 HV Add include file mbstring.h
//                  Change the str* functions to STR*
//   30-Jul-1990 SB Freeing ptr in the middle of a string for 'undef foo' case
//   01-Dec-1989 SB Changed realloc() to REALLOC()
//   22-Nov-1989 SB Changed free() to FREE()
//   05-Apr-1989 SB made all funcs NEAR; Reqd to make all function calls NEAR
//   19-Sep-1988 RB Remove ESCH processing from readInOneLine().
//   15-Sep-1988 RB Move chBuf to GLOBALS.
//   17-Aug-1988 RB Clean up.
//   29-Jun-1988 rj Added support for cmdswitches e,q,p,t,b,c in tools.ini.
//   23-Jun-1988 rj Fixed GP fault when doing directives in tools.ini.
//   23-Jun-1988 rj Add support for ESCH to readInOneLine().
//   25-May-1988 rb Add missing argument to makeError() call.

#include "precomp.h"
#pragma hdrstop

//  function prototypes

void    skipToNextDirective(void);
void    processIfs(char*, UCHAR);
UCHAR   ifsPresent(char*, unsigned, char**);
void    processCmdSwitches(char*);
char  * readInOneLine(void);
char  * getDirType(char*, UCHAR*);

//  macros that deal w/ the if/else directives' stack

#define ifStkTop()      (ifStack[ifTop])
#define popIfStk()      (ifStack[ifTop--])
#define pushIfStk(A)    (ifStack[++ifTop] = A)

#define INCLUDE         0x09
#define CMDSWITCHES     0x0A
#define ERROR           0x0B
#define MESSAGE         0x0C
#define UNDEF           0x0D


#ifdef _MBCS

//  GetTxtChr : get the next character from a text file stream
//
//    This routine handles mixed DBCS and ASCII characters as
//    follows:
//
//    1.  The second byte of a DBCS character is returned in a
//    word with the high byte set to the lead byte of the character.
//    Thus the return value can be used in comparisions with
//    ASCII constants without being mistakenly matched.
//
//    2.  A DBCS space character (0x8140) is returned as two
//    ASCII spaces (0x20).  I.e. return a space the 1st and 2nd
//    times we're called.
//
//    3.  ASCII characters and lead bytes of DBCS characters
//    are returned in the low byte of a word with the high byte
//    set to 0.

int GetTxtChr(FILE *bs)
{
    extern int  chBuf;      // Character buffer
    int         next;       // The next byte
    int         next2;      // The one after that

    // -1 in chBuf means it doesn't contain a valid character

    // If we're not in the middle of a double-byte character,
    // get the next byte and process it.

    if(chBuf == -1) {
        next = getc(bs);
        // If this byte is a lead byte, get the following byte
        // and store both as a word in chBuf.

        if (_ismbblead(next)) {
            next2 = getc(bs);
            chBuf = (next << 8) | next2;
            // If the pair matches a DBCS space, set the return value
            // to ASCII space.

            if(chBuf == 0x8140)
                next = 0x20;
        }
    } else {
        // Else we're in the middle of a double-byte character.

        if(chBuf == 0x8140) {
            // If this is the 2nd byte of a DBCS space, set the return
            // value to ASCII space.

            next = 0x20;
        } else {
            // Else set the return value to the whole DBCS character

            next = chBuf;
        }
        // Reset the character buffer
        chBuf = -1;
    }

    // Return the next character
    return(next);
}

#endif // _MBCS


#ifdef _MBCS

//  UngetTxtChr -- Unget character fetched by GetTxtChr
//
// Scope:
//  Global.
//
// Purpose:
//  Since GetTxtChr() sometimes reads ahead one character and saves it in chBuf,
//  ungetc() will sometimes put back characters in incorrect sequence.
//  UngetTxtChr, on the other hand, understands how GetTxtChr works and will
//  correctly put those characers back.
//
// Input:
//  c    -- The character read by GetTxtChr()
//  bs    -- The file buffer which c was read from.
//
// Output:
//  Returns c if c is put back OK, otherwise returns EOF
//
// Errors/Warnings:
//
// Assumes:
//  Assumes that characters are read only by GetTxtChr(), not by getc, etc.
//
// Modifies Globals:
//  chBuf -- The composite character, read ahead by GetTxtChr()
//
// Uses Globals:
//  chBuf -- The composite character, read ahead by GetTxtChr()
//
// Notes:
//  There are three cases to consider:
//  1. Normal character (chBuf == -1 && c == 0x00XX)
//     In this case, just put back c is sufficient.
//  2. Trail byte character (chBuf == -1 && c = LB|TB)
//     chBuf = c;
//  3. Lead byte character (chBuf == LB|TB && c == LB)
//     put back TB
//     put back LB
//     chBuf = -1
//
// History:
//   01-Jun-1993 HV Created.

int
UngetTxtChr(int c, FILE *bs)
{
    extern int  chBuf;                  // Character buffer
    int         nTrailByte;             // The trail byte to put back

    if (-1 == chBuf) {                  // We're not in the middle of a DB character
        if (0 == (c >> 8)) {            // CASE 1: normal character
            c = ungetc(c, bs);          // putback normal char
        } else {                        // CASE 2: at trail byte (c=LBTB)
            chBuf = c;                  // change chBuf is sufficient
        }
    } else {                            // CASE 3: at lead byte (c=LB, chBuf=LBTB)
        nTrailByte = chBuf & (int)0xff; // Figure out the trail byte to putback
        ungetc(nTrailByte, bs);         // putback trail byte
        c = ungetc(c, bs);              // putback lead byte
        chBuf = -1;
    }
    return (c);
}

#endif // _MBCS

//  lgetc()        local getc - handles directives and returns char
//
//  arguments:        init    global boolean value -- TRUE if tools.ini
//                is the file being parsed
//              colZero     global boolean value -- TRUE if at first column
//
//  actions:
//          gets a character from the currently open file.
//          loop
//            if it is column zero and the char is '!' or
//               there is a previous directive to be processed do
//               read in one line into buffer.
//               find directive type and get a pointer to rest of
//              text.
//              case directive of:
//
//              CMDSWITCHES  : set/reset global flags
//              ERROR        : set up global error message
//                         printed by error routine on
//                     termination. (not implemented yet )
//              INCLUDE      : calls processInclude
//                     continues with new file...
//              UNDEF        : undef the macro in the table
//                  IF
//              IFDEF
//              IFNDEF
//              ELSE
//              ENDIF        : change the state information
//                              on the ifStack
//                     evaluate expression if required
//                     skip text if required (and look
//                          for the next directive)
//                     ( look at processIfs() )
//            free extra buffers used (only one buffer need be
//                 maintained )
//            increment lexer's line count
//            we 're now back at column zero
//            get next char from current file
//           end if
//         end loop
//         return a char
//
//  returns :    a character (that is not part of any directive...)
//
//  modifies:        ifStack    if directives' stack, static to this module
//            ifTop     index of current element at top of stack
//            line        lexer's line count...
//
//            file        current file, if !include is found...
//                  fName       if !include is processed...

int
lgetc()
{
    UCHAR dirType;
    int c;
    char *s, *t;
    MACRODEF *m;

    for (c = GetTxtChr(file); prevDirPtr || (colZero && (c == '!'));
                    ++line, c = GetTxtChr(file)) {
        colZero = FALSE;                // we saw a '!' incolZero
        if (!prevDirPtr) {
            s = readInOneLine();        // might modify lbufPtr -
                                        // if input text causes realloc */
        } else {
            UngetTxtChr(c, file);
            s = prevDirPtr;
            prevDirPtr = NULL;
        }

        t = getDirType(s, &dirType);

        if (dirType == INCLUDE) {
            if (init) {
                makeError(line, SYNTAX_UNEXPECTED_TOKEN, s);
            }

            // processInclude eats up first char in new file
            // if it is space char. we check for that and break out.

            if (processIncludeFile(t) == (UCHAR) NEWLINESPACE) {
                c = ' ';                // space character is returned
                break;                  // colZero is now FALSE
            }
        }
        else if (dirType == CMDSWITCHES) {
            processCmdSwitches(t);
        }
        else if (dirType == ERROR) {
            makeError(line, USER_CONTROLLED, t);
        }
        else if (dirType == MESSAGE) {
            if (!_tcsnicmp(t, "\\t", 2)) {
                printf("\t");
                t+=2;
            }
            makeMessage(USER_MESSAGE, t);
        }
        else if (dirType == UNDEF) {
            char *tmp;
            tmp = _tcstok(t, " \t");
            if (_tcstok(NULL, " \t")) {
                makeError(line, SYNTAX_UNEXPECTED_TOKEN, tmp);
            }
            if (NULL != (m = findMacro(tmp))) {
                SET(m->flags, M_UNDEFINED);
            }
            // CONSIDER:  why not remove symbol from table? [RB]
        }
        else processIfs(t, dirType);
            colZero = TRUE;             // finished with this directive
        if (s != lbufPtr)               // free buffer if it had expanded macros
            FREE(s);
    }
    return(c);                          // return a character to the lexer
}


//  readInOneLine()
//
//  arguments:  lbufPtr   pointer(static/global to this module) to buffer that
//                    will hold text of line being read in
//              lbufSize  size of buffer(static/global to this module), updated
//                if buffer is realloc'd
//  actions  :  skip spaces/tabs and look for the directive.
//              line continuations allowed in usual way
//              if space-backslash-nl keep looking...
//              if colZero of next line has comment char
//                    (#, or ; in tools.ini), look at next line...
//              if first non-space char is '\n' or EOF report
//                fatal-error and stop.
//
//          keep reading in chars and storing in the buffer until
//               a newline, EOF or a '#' which is NOT in column
//               zero is seen
//          if comment char in column zero ('#' or ';' in tools.ini)
//             skip the line, continue with text on next line.
//          if buffer needs to be realloc'd increase size by
//             MAXBUF, a global constant.
//          if newline was found, eat up newline.
//          null terminate string for return.
//          if '#' was found discard chars till the a newline or EOF.
//          if EOF was found, push it back on stream for return
//             to the lexer the next time.
//
//          now expand macros. get a different buffer with clean
//          text after expansion of macros.
//
//   modifies :   colZero    global boolean value ( thru' call to
//                            skipBackSlash())
//                lbufPtr    buffer pointer, in case of reallocs.
//                lbufSize   size of buffer, increased if buffer is realloc'd
//   Note:  the buffer size will grow to be just greater than the size
//        of the longest directive in any of the files processed,
//        if it calls for any realloc's
//        Do NOT process ESCH here.  It is processed at a higher level.
//
//   returns  :   pointer to buffer.
//

char *
readInOneLine()
{
    extern STRINGLIST *eMacros;
    int c;
    unsigned index = 0;
    register char *s;

    if (((c = skipWhiteSpace(FROMSTREAM)) == '\n') || (c == EOF))
        makeError(line, SYNTAX_MISSING_DIRECTIVE);

    UngetTxtChr(c, file);

    for (;;) {
        c = GetTxtChr(file);
        c = skipBackSlash(c, FROMSTREAM);
        if (c == '#' || c == '\n' || c == EOF) {
            break;
        }
        if ((index+2) > lbufSize) {
            lbufSize += MAXBUF;
            if (!lbufPtr) {
                lbufPtr = (char *) allocate(lbufSize+1);    // +1 for NULL byte
            } else {
                void *pv = REALLOC(lbufPtr, lbufSize+1);
                if (pv) {
                    lbufPtr = (char *) pv;
                } else {
                    makeError(line, MACRO_TOO_LONG);
                }
            }
        }
        *(lbufPtr + (index++)) = (char) c;
    }
    *(lbufPtr + index) = '\0';          // null terminate the string
    if (c == '#') {
        for(c = GetTxtChr(file); (c != '\n') && (c != EOF); c = GetTxtChr(file))
            ;
                                        // newline at end is eaten up
    }

    if (c == EOF) {
        UngetTxtChr(c, file);           // this directive is to be processed
    }

    s = lbufPtr;                        // start expanding macros here
    s = removeMacros(s);                // remove and expand macros in string s
    return(s);
}


//  getDirType()
//
//  arguments:  s         -   pointer to buffer that has directive text.
//            dirType   -   pointer to unsigned char that gets set
//                   with directive type.
//
//  actions  :  goes past directive keyword, sets the type code and
//        returns a pointer to rest of test.

char *
getDirType(
    char *s,
    UCHAR *dirType
    )
{
    char *t;
    int len;

    *dirType = 0;
    for (t = s; *t && !WHITESPACE(*t); ++t);
    len = (int) (t - s);                // store len of directive
    while (*t && WHITESPACE(*t)) {
        ++t;                            // go past directive keyword
    } if (!_tcsnicmp(s, "INCLUDE", 7) && (len == 7)) {
        *dirType = INCLUDE;
    } else if (!_tcsnicmp(s, "CMDSWITCHES", 11) && (len == 11)) {
        *dirType = CMDSWITCHES;
    } else if (!_tcsnicmp(s, "ERROR", 5) && (len == 5)) {
        *dirType = ERROR;
    } else if (!_tcsnicmp(s, "MESSAGE", 7) && (len == 7)) {
        *dirType = MESSAGE;
    } else if (!_tcsnicmp(s, "UNDEF", 5) && (len == 5)) {
        *dirType = UNDEF;
    } else {
        *dirType = ifsPresent(s, len, &t) ;     // directive one of "if"s?
    }

    if (!*dirType) {
        makeError(line, SYNTAX_BAD_DIRECTIVE, lbufPtr);
    }
    return(t);
}


//  processCmdSwitches() -- processes command line switches in makefiles
//
//  arguments:      t         pointer to flag settings specified.
//
//  actions  :    sets or resets global flags as specified in the directive.
//          The allowed flags are:
//          s - silent mode,     d - debug output (dates printed)
//          n - no execute mode, i - ignore error returns from commands
//          u - dump inline files
//          If parsing tools.ini, can also handle epqtbc
//                reports a bad directive error for any other flags
//          specified
//
//  modifies :    nothing
//
//  returns  :    nothing

void
processCmdSwitches(
    char *t                         // pointer to switch values
    )
{
    for (; *t; ++t) {               // ignore errors in flags specified
        switch (*t) {
            case '+':
                while (*++t && *t != '-') {
                    if (_tcschr("DINSU", (unsigned short)_totupper(*t))) {
                        setFlags(*t, TRUE);
                    } else if (init && _tcschr("ABCEKLPQRTY", (unsigned short)_totupper(*t))) {
                        setFlags(*t, TRUE);
                    } else {
                        makeError(line, SYNTAX_BAD_CMDSWITCHES);
                    }
                }

                if (!*t) {
                    break;
                }

            case '-':
                while (*++t && *t != '+') {
                    if (_tcschr("DINSU", (unsigned short)_totupper(*t))) {
                        setFlags(*t, FALSE);
                    } else if (init && _tcschr("ABCEKLMPQRTV", (unsigned short)_totupper(*t))) {
                        setFlags(*t, FALSE);
                    } else {
                        makeError(line, SYNTAX_BAD_CMDSWITCHES);
                    }
                }
                break;

            default:
                if (!WHITESPACE(*t)) {
                    makeError(line, SYNTAX_BAD_CMDSWITCHES);
                }
                break;
        }
        if (!*t) {
            break;
        }
    }
}

//  ifsPresent() -- checks if current directive is one of the "if"s
//
//  arguments:  s       pointer to buffer with directive name in it
//              len     length of the directive that was seen
//              t       pointer to address upto which processed
//
//  actions  :  does a string compare in the buffer for one of the
//              directive keywords. If string matches true, it returns
//              a non-zero value, the code for the specific directive
//
//  modifies :  nothing
//
//  returns  :  a zero if no match, or the code for directive found.

UCHAR
ifsPresent(
    char *s,
    unsigned len,
    char **t
    )
{
    UCHAR ifFlags = 0;              // takes non-zero value when one of
                                    // if/else etc is to be processed

    if (!_tcsnicmp(s, "IF", 2) && (len == 2)) {
        ifFlags = IF_TYPE;
    } else if (!_tcsnicmp(s, "IFDEF", 5) && (len == 5)) {
        ifFlags = IFDEF_TYPE;
    } else if (!_tcsnicmp(s, "IFNDEF", 6) && (len == 6)) {
        ifFlags = IFNDEF_TYPE;
    } else if (!_tcsnicmp(s, "ELSE", 4) && (len == 4)) {
        // 'else' or 'else if' or 'else ifdef' or 'else ifndef'
        char *p = *t;

        if (!*p) {
            ifFlags = ELSE_TYPE;
        } else {
            for (s = p; *p && !WHITESPACE(*p); p++)
                ;
            len = (unsigned) (p - s);
            while (*p && WHITESPACE(*p)) {
                p++;
            }
            *t = p;
            if (!_tcsnicmp(s, "IF", 2) && (len == 2)) {
                ifFlags = ELSE_IF_TYPE;
            } else if (!_tcsnicmp(s, "IFDEF", 5) && (len == 5)) {
                ifFlags = ELSE_IFDEF_TYPE;
            } else if (!_tcsnicmp(s, "IFNDEF", 6) && (len == 6)) {
                ifFlags = ELSE_IFNDEF_TYPE;
            }
        }
    }
    else if (!_tcsnicmp(s, "ELSEIF", 6) && (len == 6)) {
        ifFlags = ELSE_IF_TYPE;
    }
    else if (!_tcsnicmp(s, "ELSEIFDEF", 9) && (len == 9)) {
        ifFlags = ELSE_IFDEF_TYPE;
    }
    else if (!_tcsnicmp(s, "ELSEIFNDEF", 10) && (len == 10)) {
        ifFlags = ELSE_IFNDEF_TYPE;
    }
    else if (!_tcsnicmp(s, "ENDIF", 5) && (len == 5)) {
        ifFlags = ENDIF_TYPE;
    }

    return(ifFlags);
}


//  processIfs() -- sets up / changes state information on "if"s
//
//  arguments:  s       pointer to "if" expression ( don't care
//                       for "endif" )
//
//              kind    code indicating if processing if/else/ifdef etc.
//
//  actions  :  modifies a stack (ifStack) by pushing/popping or
//              sets/resets bits in the top element on the
//              stack(examining the previous element pushed if
//              required).
//              case (kind) of
//                  IF
//                  IFDEF
//                  IFNDEF
//                  IF defined() : if no more space on ifStack
//                                  (too many nesting levels) abort...
//                      set IFELSE bit in elt.
//                      push elt on ifStack.
//                      if more than one elt on stack
//                          and outer level "ifelse" false
//                          set IGNORE bit, skipToNextDirective
//                      else
//                          evaluate expression of
//                           current "if"
//                          if expr true set CONDITION bit in elt
//                          else skipToNextDirective.
//                  ELSE         : if no elt on stack or previous
//                                  directive was "else", flag error, abort
//                       clear IFELSE bit in elt on stack.
//                       if current ifelse block is to
//                        be skipped (IGNORE bit is on
//                        in outer level if/else),skip...
//                       else FLIP condition bit.
//                          if "else" part is false
//                             skipToNextDirective.
//                  ENDIF        : if no elt on stack, flag error,abort
//                       pop an elt from ifStack.
//                       if there are elts on stack
//                        and we are in a "false" block
//                        skipToNextDirective.
//                  end case
//
//  modifies:   ifStack     if directives' stack, static to this module
//              ifTop       index of current element at top of stack
//              line        lexer's line count  (thru calls to
//                            skipToNextDirective())
//
//  returns  :      nothing

void
processIfs(
    char *s,
    UCHAR kind
    )
{
    UCHAR element;          // has its bits set and is pushed on the ifStack

    switch (kind) {
        case IF_TYPE:
        case IFDEF_TYPE:
        case IFNDEF_TYPE:
            if (ifTop == IFSTACKSIZE-1) {
                makeError(line, SYNTAX_TOO_MANY_IFS);
            }
            element = (UCHAR) 0;
            SET(element, NMIFELSE);
            pushIfStk(element);
            if (ifTop && OFF(ifStack[ifTop-1], NMCONDITION)) {
                SET(ifStkTop(), NMIGNORE);
                skipToNextDirective();
            } else if (evalExpr(s, kind)) {
                SET(ifStkTop(), NMCONDITION);
            } else {
                skipToNextDirective();
            }
            break;

        case ELSE_TYPE:
            if ((ifTop < 0) || (OFF(ifStkTop(), NMIFELSE) && OFF(ifStkTop(), NMELSEIF))) {
                makeError(line, SYNTAX_UNEXPECTED_ELSE);
            }
            CLEAR(ifStkTop(), NMIFELSE);
            CLEAR(ifStkTop(), NMELSEIF);
            if (ON(ifStkTop(), NMIGNORE)) {
                skipToNextDirective();
            } else {
                FLIP(ifStkTop(), NMCONDITION);
                if (OFF(ifStkTop(), NMCONDITION)) {
                    skipToNextDirective();
                }
            }
            break;

        case ELSE_IF_TYPE:
        case ELSE_IFDEF_TYPE:
        case ELSE_IFNDEF_TYPE:
            if ((ifTop < 0) || (OFF(ifStkTop(), NMIFELSE) && OFF(ifStkTop(), NMELSEIF))) {
                makeError(line, SYNTAX_UNEXPECTED_ELSE);
            }
            CLEAR(ifStkTop(), NMIFELSE);
            SET(ifStkTop(), NMELSEIF);
            if (ON(ifStkTop(), NMIGNORE)) {
                skipToNextDirective();
            } else {
                if (ON(ifStkTop(), NMCONDITION)) {
                    SET(ifStkTop(), NMIGNORE);
                    CLEAR(ifStkTop(), NMCONDITION);
                    skipToNextDirective();
                } else if (evalExpr(s, kind)) {
                    SET(ifStkTop(), NMCONDITION);
                } else {
                    skipToNextDirective();
                }
            }
            break;

        case ENDIF_TYPE:
            if (ifTop < 0) {
                makeError(line, SYNTAX_UNEXPECTED_ENDIF);
            }
            popIfStk();
            if (ifTop >= 0) {
                if (OFF(ifStkTop(), NMCONDITION)) {
                    skipToNextDirective();
                }
            }

        default:
            break;  // default should never happen
    }
}


//  skipToNextDirective() -- skips to next line that has '!' in column zero
//
//  actions  :  gets first char of the line to be skipped if it is
//               not a directive ( has no '!' on column zero ).
//              a "line" that is skipped may in fact span many
//               lines ( by using sp-backslash-nl to continue...)
//              comments in colZero are skipped as part of the previous
//               line ('#' or ';' in tools.ini)
//              comment char '#' elsewhere in line implies the end of
//               that line (with the next newline / EOF)
//              if a '!' is found in colZero, read in the next directive
//              if the directive is NOT one of if/ifdef/ifndef/else/
//               endif, keep skipping more lines and look for the
//               next directive ( go to top of the routine here ).
//              if EOF found before next directive, report error.
//
//  modifies :  line    global lexer line count
//
//  returns  :  nothing

void
skipToNextDirective()
{
    register int c;
    UCHAR type;

repeat:

    for (c = GetTxtChr(file); (c != '!') && (c != EOF) ;c = GetTxtChr(file)) {
        ++line;                         // lexer's line count

        do {
            if (c == '\\') {
                c = skipBackSlash(c, FROMSTREAM);
                if (c == '!' && colZero) {
                    break;
                } else {
                    colZero = FALSE;
                }
            }
            if ((c == '#') || (c == '\n') || (c == EOF)) {
                break;
            }
            c = GetTxtChr(file);
        } while (TRUE);

        if (c == '#') {
            for (c = GetTxtChr(file); (c != '\n') && (c != EOF); c = GetTxtChr(file))
                ;
        }
        if ((c == EOF) || (c == '!')) {
            break;
        }
    }

    if (c == '!') {
        if (prevDirPtr && (prevDirPtr != lbufPtr)) {
            FREE(prevDirPtr);
        }
        prevDirPtr = readInOneLine();
        getDirType(prevDirPtr, &type);
        if (type > ENDIF_TYPE) {        // type is NOT one of the "if"s
            ++line;
            goto repeat;
        }
    } else if (c == EOF) {
        makeError(line, SYNTAX_EOF_NO_DIRECTIVE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\grammar.h ===
// GRAMMAR.H -- Contains grammar of NMAKE ************************************
//
//  Copyright (c) 1988-1989, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains grammar of NMAKE and definitions used by lexer & parser
//
// Revision History:
//  08-Oct-1989 SB Added QUOTE_ and NOQ and QUO to handle OS/2 1.2 quoted names
//  31-Jul-1989 SB Added BKS, DEF and BEG to add lookahead to the lexer
//  18-May-1989 SB Added BKSLH_ definition for use by lexer's nameStates[]

//  This file contains the grammar for nmake.
//
//
//
//  e is the symbol epsilon
//
//
//  nonterminals begin w/ capitals
//
//
//  terminals begin w/ lower-case letters
//
//
//  terminals: name newline newlineWhitespace semicolon colon equals string e
//      doublecolon value
//
//
//  Makefile ->     e |
//              BlankLines Makefile |
//              newline name Body Makefile
//
//  Body ->         NameList Separator BuildInfo |
//              equals value
//
//  NameList ->     e |
//              name NameList
//
//  Commands ->     e |
//              MoreBuildLines |
//              semicolon string MoreBuildLines
//
//  MoreBuildLines ->   e |
//              newlineWhitespace string MoreBuildLines |
//              newline MoreBuildLines
//
//  BlankLines ->       e |
//              newline BlankLines |
//              newlineWhitespace BlankLines
//
//  BuildInfo ->        e |
//              NameList Commands
//
//  Separator ->        colon | doublecolon
//
//
//
//
//
//  note:   a "string" is everything from the current input character up
//      to the first newline which is not preceded by a backslash, or
//      end of file (whichever comes first).  a macro "value" is the
//      same as a "string" with the exception that comments are stripped
//      from it (a comment ending in a backslash does not cause the
//      value to be continued on the next line).


//  Compute FIRST() and FOLLOW() for each nonterminal in order to construct
//  parse table (it'd be nice to have a simple utility to build the
//  table, but it's still a pretty easy thing to do by hand).
//
//
//  FIRST(Makefile)         =   e newline FIRST(BlankLines)
//                  = e newline newlineWhitespace
//
//  FIRST(Body)         =   equals FIRST(NameList) FIRST(Separator)
//                  = equals name colon doublecolon
//
//  FIRST(NameList)         =   e name
//
//  FIRST(Commands)         =   e semicolon FIRST(BuildLine)
//                  = e semicolon newlineWhitespace
//
//  FIRST(MoreBuildLines)       =   e FIRST(BuildLine) FIRST(BlankLines)
//                  = e newlineWhitespace newline
//
//  FIRST(BlankLines)       =   e newline newlineWhitespace
//
//  FIRST(BuildInfo)        =   FIRST(NameList) FIRST(Commands)
//                  = e name semicolon newlineWhitespace
//
//  FIRST(Separator)        =   colon doublecolon


//  ---------------------------------------------------------------
//
//
//  FOLLOW(Makefile)        =   $
//
//  FOLLOW(Body)            =   FIRST(Makefile) FOLLOW(Makefile)
//                  = newline newlineWhitespace $
//
//  FOLLOW(NameList)        =   FIRST(Commands) FIRST(MoreBuildLines)
//                  colon FOLLOW(Body)
//                  = colon semicolon newlineWhitespace
//                    newline $
//
//  FOLLOW(Commands)        =   FOLLOW(Body)
//                  = newline newlineWhitespace $
//
//  FOLLOW(MoreBuildLines)      =   FOLLOW(Commands)
//                  = newline newlineWhitespace $
//
//  FOLLOW(BlankLines)      =   FIRST(Body) FOLLOW(Makefile)
//                  = newlineWhitespace newline $
//
//  FOLLOW(BuildInfo)       =   FOLLOW(Body)
//                  = newline newlineWhitespace $
//
//  FOLLOW(Separator)       =   FIRST(BuildInfo) FOLLOW(Body)
//                  = name semicolon newlineWhitespace
//                    newline $
//

//------------------------------------------------------------------------------
//
//  for building the table, I number the productions:
//
//
//
//  0.  Makefile ->     e
//
//  1.  Makefile ->     BlankLines Makefile
//
//  2.  MakeFile ->     newline name Body Makefile
//
//  3.  Body ->         NameList Separator BuildInfo
//
//  4.  Body ->         equals value
//
//  5.  NameList ->     e
//
//  6.  NameList ->     name NameList
//
//  7.  Commands ->     e
//
//  8.  Commands ->     MoreBuildLines
//
//  9.  Commands ->     semicolon string MoreBuildLines
//
//  10. MoreBuildLines ->   newlineWhiteSpace string MoreBuildLines
//
//  11. MoreBuildLines ->   e
//
//  12. MoreBuildLines ->   newline MoreBuildLines
//
//  13. BlankLines ->       e
//
//  14. BlankLines ->       newline BlankLines
//
//  15. BlankLines ->       newlineWhitespace BlankLines
//
//  16. BuildInfo ->        e
//
//  17. BuildInfo ->        NameList Commands
//
//  18. Separator ->        colon
//
//  19. Separator ->        doublecolon
//



//------------------------------------------------------------------------------
//
//  NOTE THAT THIS GRAMMAR IS NOT LL(1) (it's really LL(2) because we need
//  an extra symbol of lookahead to decide which production to use in
//  a few cases)
//
//
//  the resulting parse table (empty entries are error conditions):
//
//
//                      newline-
//                              White-  semi-           double-
//             |name   |newline| space | colon | colon | colon |equals |$      |
//             -----------------------------------------------------------------
//  A          |       |       |       |       |       |       |       |       |
//    Makefile |       |  1,2  |   1   |       |       |       |       |   0   |
//             |       |       |       |       |       |       |       |       |
//             -----------------------------------------------------------------
//  B          |       |       |       |       |       |       |       |       |
//    Blank-   |       | 13,14 | 13[15]|       |       |       |       |   13  |
//     Lines   |       |       | --    |       |       |       |       |       |
//             -----------------------------------------------------------------
//  C          |       |       |       |       |       |       |       |       |
//    More-    |       | 11,12 |   10  |       |       |       |       |   11  |
//     Build-  |       |       |       |       |       |       |       |       |
//  Lines      -----------------------------------------------------------------
//  D          |       |       |       |       |       |       |       |       |
//    Commands |       |   7   | [7]8  |   9   |       |       |       |   7   |
//             |       |       |    -  |       |       |       |       |       |
//             -----------------------------------------------------------------
//  E          |       |       |       |       |       |       |       |       |
//    Body     |   3   |       |       |       |   3   |       |   4   |       |
//             |       |       |       |       |       |       |       |       |
//             -----------------------------------------------------------------
//  F          |       |       |       |       |       |       |       |       |
//    NameList |   6   |   5   |   5   |   5   |   5   |   5   |       |   5   |
//             |       |       |       |       |       |       |       |       |
//             -----------------------------------------------------------------
//  G          |       |       |       |       |       |       |       |       |
//    Build-   |   17  |   16  |[16]17 |   17  |       |       |       |   16  |
//     Info    |       |       |    -- |       |       |       |       |       |
//             -----------------------------------------------------------------
//  H          |       |       |       |       |       |       |       |       |
//    Separ-   |       |       |       |       |   18  |   19  |       |       |
//     ator    |       |       |       |       |       |       |       |       |
//             -----------------------------------------------------------------
//
//  G2 -- always uses 17 -- anytime the user puts a line beginning w/
//      whitespace immediately after a target-dependency line, it's
//      a build line.  Same for D2.



//  IMPORTANT:  IF YOU CHANGE THE VALUES OF ANY OF THE FOLLOWING
//  CONSTANTS FOR TERMINAL OR NONTERMINAL SYMBOLS, YOU MUST ADJUST
//  THE APPROPRIATE TABLES (AND STRING LITERALS) ACCORDINGLY.
//
//  Nonterminal symbols first (these are used to index the parse table
//  along the first dimension):
//
// define nonterminals . . .

#define MAKEFILE    0x00            // productions w/ 2
#define BLANKLINES  0x01            //  alternatives in a
#define MOREBUILDLINES  0x02        //  table entry must
#define COMMANDS    0x03            //  come first (so
#define BODY        0x04            //  that I can use
#define NAMELIST    0x05            //  them as array
#define BUILDINFO   0x06            //  subscripts when
#define SEPARATOR   0x07            //  resolving the
                                    //  conflict)

#define START       MAKEFILE
#define LAST_PRODUCTION SEPARATOR

// Now the terminal symbols (the 4 low bits of which are used to index
// the parse table alone 2nd dimension -- bit 5 simply distinguishes
// tokens from nonterminals in productions):

#define NAME        0x10            // TOKEN_MASK | 0
#define NEWLINE     0x11            // TOKEN_MASK | 1
#define NEWLINESPACE    0x12        // TOKEN_MASK | 2
#define SEMICOLON   0x13            // TOKEN_MASK | 3
#define COLON       0x14            // TOKEN_MASK | 4
#define DOUBLECOLON 0x15            // etc.
#define EQUALS      0x16
#define ACCEPT      0x17            // this is $
#define STRING      0x18            // no columns in table
#define VALUE       0x19            //  for these two

// Error values    -- these are equal to the error exit code minus 1000
// if you change them, you must change the corresponding values in
// nmmsg.txt

#define MACRO       0x20            // ERROR_MASK | 0
#define SYNTAX      0x21            // ERROR_MASK | 1
#define SEPRTR      0x22            // ERROR_MASK | 2
#define SEPEQU      0x23            // ERROR_MASK | 3
#define NAMES       0x24            // ERROR_MASK | 4
#define NOTARG      0x25            // ERROR_MASK | 5
#define LEXER       0x26            // ERROR_MASK | 6
#define PARSER      0x27            // ERROR_MASK | 7

// Parser actions  -- these are indexes into the "action" function table,
// telling the parser which function to call at a certain point in
// a production

#define DONAME      0x40            // ACTION_MASK | 0
#define DONAMELIST  0x41
#define DOMACRO     0x42
#define DODEPENDS   0x43
#define DOLASTNAME  0x44
#define DOBUILDCMDS 0x45

//  a few macros to simplify dealing w/ tokens:

#define TOKEN_MASK  0x10
#define ERROR_MASK  0x20
#define ACTION_MASK 0x40
#define AMBIG_MASK  0x80            // conflict in table
#define LOW_NIBBLE  0x0F

//  values for alternate productions table
//  (a YES in the slot for a given input token and a given nonterminal
//  on top of the stack means use the next production (+1) from the
//  one given in the production table)

#define YES 1
#define NO  0


//  values for lexer's state machine that recognizes names
//  append an underscore to distinguish these from parser's tokens

#define DEFAULT_    0x00            // char not defined
#define COMMENT_    0x01            //  below
#define EQUALS_     0x02
#define SEMICOLON_  0x03
#define COLON_      0x04
#define WHITESPACE_ 0x05            // \t and ' '
#define NEWLINE_    0x06            // \n and EOF
#define DOLLAR_     0x07
#define OPENPAREN_  0x08
#define CLOSEPAREN_ 0x09
#define MACROCHAR_  0x0A            // A-Z,a-z,0-9,_
#define OPENCURLY_  0x0B
#define CLOSECURLY_ 0x0C
#define BKSLSH_     0x0D
#define QUOTE_      0x0E

#define STAR_       0x0B            // only for strings:
#define SPECIAL1_   0x0C            // @ * < ?
#define SPECIAL2_   0x0D            // B F D R
#define BACKSLASH_  0x03            // don't need semi if
                                    //  we have backslash
                                    //  (names need ; but
                                    //  strings need \)

//  values for state tables -- for error values, mask off the error bit (0x20)
//  to get the message number.

#define OK      0x40                // means accept token
#define BEG     0x00                // means beginning
#define DEF     0x01                // means normal name
#define BKS     0x0f                // processing bkslash
#define PAR     0x20                // close paren missing
#define CHR     0x21                // bad char in macro
#define BAD     0x22                // single $ w/o macro
#define EQU     0x23                // substitution w/o =
#define NAM     0x24                // illegal macro name
#define SEQ     0x25                // subst w/o strings
#define NOQ     0x26                // no matching quote
#define QUO     0x27                // illegal " in name
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\lexer.cpp ===
//  LEXER.C -- gets tokens from input, returns them to parse() in parser.c
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains the lexical routines of nmake
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  01-Jun-1993 HV  Use UngetTxtChr() instead of ungetc()
//  01-Jun-1993 HV  Change #ifdef KANJI to _MBCS
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  06-Apr-1993 HV  Change createDosTmp() to use _makepath()
//  22-Mar-1993 HV  Rewrite getPath() to make use of the new _splitpath() and
//                  _makepath() functions.
//  04-Aug-1992 SS  CAVIAR 2266: expand INCLUDE macro in processIncludeFile()
//  08-Jun-1992 SS  Port to DOSX32
//  02-Feb-1990 SB  change fopen() to FILEOPEN()
//  01-Dec-1989 SB  Changed realloc() to REALLOC()
//  22-Nov-1989 SB  Changed free() to FREE()
//  19-Oct-1989 SB  searchHandle passed around as extra param
//  08-Oct-1989 SB  handle OS/2 1.2 quoted filenames
//  04-Sep-1989 SB  temporary filename generated has a trailing '.' for LINK.EXE
//  24-Aug-1989 SB  Allow $* and $@ in dependency lines
//  18-Aug-1989 SB  Added fclose() return code check
//  31-Jul-1989 SB  Added lookahead to the lexer for \ on dependency lines
//  06-Jul-1989 SB  Remove escaping abilities of '^' in command lines totally
//  29-Jun-1989 SB  Add duplicateInline() to detect duplicate inline filenames
//                  and issue error if duplicates are found
//  26-Jun-1989 SB  Modify ParseScriptFileList() and add nextInlineFile() to
//                  handle complex syntax of Inline file command line.
//  15-Jun-1989 SB  issue error for usage of inline file in an inference rule
//  18-May-1989 SB  Added getPath(), changed processIncludeFile() to have C like
//                  processing of include files
//  16-May-1989 SB  expand macros in include file names; handle '\' processing
//                  in same way for macros and dependency lines
//  15-May-1989 SB  Changed nameStates to 16x14
//  13-May-1989 SB  don't remove ESCH on reading cmd block
//  24-Apr-1989 SB  made FILEINFO as void * and corrected regression in parsing
//                  inline file names
//  14-Apr-1989 SB  inline file names are correctly expanded now
//  06-Apr-1989 SB  ren removeFirstLtLt() as delInlineSymbol().
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  22-Mar-1989 SB  removed unlinkTmpFiles() function; not needed
//  19-Jan-1989 SB  added function removeFirstLtLt() to remove '<<' appearing
//                  in -n output
//  30-Dec-1988 SB  Fixed GP fault for KEEP/NOKEEP in parseScriptFileList()
//                  and makeScriptFileList()
//  21-Dec-1988 SB  Added parseScriptFileList() and appendScript() to allow
//                  handling of multiple script files inside a makefile
//                  Improved KEEP/NOKEEP so that each file can have its own
//                  action
//  16-Dec-1988 SB  Added to makeScriptFile() for KEEP/NOKEEP
//  14-Dec-1988 SB  Added tmpScriptFile so that a delete command can be
//                  added for unnamed script files for Z option
//  13-Dec-1988 SB  Added processEschIn() to improve response files
//   5-Oct-1988 RB  Strip trailing whitespace from macro defs, build lines.
//  22-Sep-1988 RB  Fix skipComments() to not parse \\nl.
//  20-Sep-1988 RB  Error if named script file creation fails.
//                  Count line numbers in script files.
//  18-Sep-1988 RB  Handle mktemp() small limit.
//  17-Aug-1988 RB  Clean up.
//  14-Jul-1988 rj  Fixed handling of ^ before !, @, or -.
//   8-Jul-1988 rj  Added handler to ignore ^ inside quotes.
//                  Made \ carry comments over lines.
//                  Made ^ carry comments over lines.
//  27-Jun-1988 rj  Fixed bug with handling of response files.
//  16-Jun-1988 rj  Finished up ESCH.
//  15-Jun-1988 rj  Added support for ESCH escape:  modified skipWhiteSpace
//                  (adding some redundancy in setting colZero), getString,
//                  getName; removed \\nl escape.
//  13-Jun-1988 rj  Fixed backslashes to work as in nmake, with addition of
//                  double-backslash escape.  (v1.5)

#include "precomp.h"
#pragma hdrstop

#define COMMENT(A,B,C)      (((A) == ';' && B && C) || ((A) == '#'))
#ifdef _MBCS
#define GET(A)              A ? GetTxtChr(file) : lgetc()
#else
#define GET(A)              A ? getc(file) : lgetc()
#endif

extern char       * makeInlineFiles(char*, char**, char**);
extern void         removeTrailChars(char *);

void          skipComments(UCHAR);
void          getString(UCHAR,char*,char*);
void          getName(char*,char*);
UCHAR         determineTokenFor(int,char*,char*);
void          popFileStack(void);
UCHAR         include(int);
char        * getPath(const char *);

extern const UCHAR nameStates[18][15];
extern const UCHAR stringStates[13][14];
extern STRINGLIST *targetList;


//  getToken()
//
//  arguments:  init        global boolean value -- TRUE if tools.ini is the
//                           file being lexed
//              n           size of s[]
//              expected    kind of token expected by parser -- only
//                           needed when parser wants a whole string
//                           (meaning everything left on the current line)
//                           -- this way getToken() doesn't break strings
//                           into their separate tokens
//
//  actions:    if no tokens have been read from current file,
//              returns some kind of newline to initialize the parser
//               (if 1st char in file is whitespace, returns NEWLINESPACE
//              else returns NEWLINE -- w/o actually getting a token
//               from the input)
//              if the parser wants a whole string, reads rest of line
//               into s and returns STRING
//              if at end of file, return ACCEPT (which is the last
//               symbol on the parser's stack)
//              if input char is newline
//              if followed by whitespace, return NEWLINESPACE
//              if the next char is [ and we're reading tools.ini
//               pretend that we've reached end of file and
//               return ACCEPT
//              otherwise return NEWLINE
//              if input char is colon
//              if following char is also colon,
//                (put both chars in s) return DOUBLECOLON
//              otherwise return SINGLECOLON
//              if input char is semicolon return SEMICOLON
//              if input char is equals return EQUALS
//              if input char is exclamation handle directives
//               (not yet implemented)
//              otherwise char must be part of a name, so gather
//              the rest of the identifier and return NAME
//
//  returns:    token type: NEWLINE NEWLINESPACE NAME EQUALS COLON
//              SEMICOLON STRING ACCEPT
//
//  modifies:   buf     by modifying *s, which points somewhere into buf
//              line    global line count
//              fname   will change when !include is handled
//              colZero global flag set if at column zero of a file
//
//  The lexer has to keep track of whether or not it is at the beginning
//  of a line in the makefile (i.e. in column zero) so that it will know
//  whether to ignore comments.  If init is TRUE, meaning that we are
//  lexing tools.ini, then we have to treat lines beginning with ';' as
//  comment lines.  If the parser expects a string, only comments beginning
//  in column zero are ignored; all others are returned as part of the
//  string.  Comments are stripped from macro values (strings that are
//  part of macro definitions).
//
//  The user can specify a macro definition or a build line that
//  spans several lines (using the \<newline> to "continue" the lines) while
//  interspersing comment lines with the text.

UCHAR
getToken(
    unsigned n,                         // size of s[]
    UCHAR expected                      // STRING means get line
    )                                   //  w/o checking for #;:=
{
    char *s;
    char *end;
    int c;

    s = buf;
    end = buf + n;
    if (firstToken) {                   // global var
        ++line;
        firstToken = FALSE;             // parser needs to see some kind of
        c = lgetc();                    // newline to initialize it
        if (colZero = (BOOL) !WHITESPACE(c)) {
            if (c == EOF)
                return(determineTokenFor(c,s,end));
            else
                UngetTxtChr(c,file);
            return(NEWLINE);
        }
        return(NEWLINESPACE);
    }

    if (expected == STRING || expected == VALUE) {  // get everything up to \n
        getString(expected,s,end);
        return(expected);
    }                                   // were/are we
    c = skipWhiteSpace(FROMLOCAL);      //  past col 0?
    *s++ = (char) c;                    // save the letter
    *s = '\0';                          // terminate s
    return(determineTokenFor(c,s,end));
}


//  determineTokenFor()
//
//  arguments:  c       current input character
//              s       buffer to place token in for return to parser
//              end     end of the token return buffer
//
//  returns:    token type: NEWLINE NEWLINESPACE NAME EQUALS COLON
//                          SEMICOLON ACCEPT
//
//  modifies:   buf     by modifying *s, which points somewhere into buf
//              line    global line count
//              fname   will change when include is handled
//              init    global flag - set if parsing tools.ini
//              colZero global flag set if at column zero of a file

UCHAR
determineTokenFor(
    int c,
    char *s,
    char *end
    )
{
    switch (c) {
        case EOF:
            if (!feof(file))
                makeError(line,LEXER+FATAL_ERR);
            if (incTop)
                popFileStack();
            else if (ifTop >= 0)        // all directives not processed
                makeError(line,SYNTAX_EOF_NO_DIRECTIVE);
            else
                return(ACCEPT);

        case '\n':
            ++line;
            colZero = TRUE;
            c = lgetc();
            if (COMMENT(c,TRUE,init)) {
                skipComments(FROMLOCAL);
                ++line;
                colZero = TRUE;         // manis - 11/13/87
                c = lgetc();
            }
            if (colZero = (BOOL) !WHITESPACE(c)) {
                if (c == EOF)
                    return(determineTokenFor(c,s,end));
                else
                    UngetTxtChr(c,file);    //save for next token
                return(NEWLINE);
            }
            return(NEWLINESPACE);

        case ':':
            colZero = FALSE;
            if ((c = lgetc()) == ':') {
                *s++ = (char) c;
                *s = '\0';
                return(DOUBLECOLON);
            }
            UngetTxtChr(c,file);
            return(COLON);

        case ';':
            colZero = FALSE;
            return(SEMICOLON);

        case '=':
            colZero = FALSE;
            return(EQUALS);

        case '[':
            if (init && colZero)
                return(ACCEPT);

        case ESCH:
            UngetTxtChr(c, file);       // getName has to get esch
            s--;                        // so we don't double the caret

        default:
            getName(s,end);
            if (colZero && !_tcsicmp(buf, "include")) {
                colZero = FALSE;
                if ((c = skipWhiteSpace(FROMLOCAL)) != ':'
                        && c != '=')  {
                    if (init)
                        makeError(line, SYNTAX_UNEXPECTED_TOKEN, s);
                    return(include(c));
                }
                UngetTxtChr(c,file);
            } else
                colZero = FALSE;
            return(NAME);
    }
}


//  skipWhiteSpace()
//
//  arguments:  c       current input character
//              init    global boolean value -- TRUE if we're lexing tools.ini
//              colZero global boolean value -- TRUE if the current
//                       input char is at the beginning of the line
//
//  actions:    reads and discards characters until it gets a
//              non-whitespace char that isn't part of a comment
//              or hits the end of the line (NEWLINE and NEWLINESPACE
//              are valid tokens and shouldn't be skipped w/ whitespace)
//              backslash-newline ('\\''\n') is treated as whitespace
//              comments are treated as whitespace
//              escaped whitespace is treated as whitespace (v1.5)
//
//  modifies:   colZero global boolean value to :
//              TRUE if by skipping whitespace and comments we're
//              at the beginning of a line
//              else if we skipped characters and are not at the
//              beginning of a line, FALSE
//              else if we did not skip any characters, leave
//              colZero unchanged
//
//  returns:    c       the current non-whitespace input char

int
skipWhiteSpace(
    UCHAR stream
    )
{
    int c;

    do {
        c = GET(stream);
        if (WHITESPACE(c) || c == ESCH) {
            if (c == ESCH) {
                c = GET(stream);
                if (!WHITESPACE(c)) {   // push char back out, return esch
                    UngetTxtChr(c, file);
                    c = ESCH;
                    break;
                }
            }
            colZero = FALSE;            // we've moved past col 0
        }

        if (c == '\\')
            c = skipBackSlash(c, stream);
    } while(WHITESPACE(c));

    if (COMMENT(c,colZero,init)) {
        skipComments(stream);           // current char is always
        c = '\n';                       // \n after comments
        colZero = TRUE;                 // always in col 0 after a comment
    }
    return(c);                          // true if we're in col 0
}


//  ----------------------------------------------------------------------------
//  skipComments()
//
//  arguments:  c       pointer to current input character
//              init    global boolean value -- TRUE if tools.ini is the
//                       file being lexed
//
//  actions:    reads and discards characters until it hits the end of
//              the line
//              checks to see if 1st char on next line is comment,
//              and if so, discards that line, too
//              DO NOT parse backslash-newline.  That would break our
//              precedence of comments over escaped newlines, the reverse
//              of Xenix.
//
//  modifies:   line    global line count
//              colZero

void
skipComments(
    UCHAR stream
    )
{
    int c;

    for (;;) {
        colZero = FALSE;                // manis 11/13/87
        do {
            c = GET(stream);
        } while (c != EOF && c != '\n');

        if (c == EOF)
            return;
        colZero = TRUE;
        c = GET(stream);
        if (!COMMENT(c,TRUE,init)) {    // if next line comment,
            UngetTxtChr(c,file);        //  go around again
            return;
        }
        ++line;
    }
}


//  skipBackSlash()  - skips backslash-newline sequences
//
//
//  arguments:  c       current input char
//              stream  flag to determine if chars are to be got
//                       from the raw stream or thru' lgetc()

int
skipBackSlash(
    int c,
    UCHAR stream
    )
{
    while (c == '\\') {                     // treat \newline as space
        if ((c = GET(stream)) == '\n') {    //    and consume it too
            colZero = TRUE;                 // manis - 11/13-87
            ++line;                         // adjust line count
            c = GET(stream);                // skip over newline
            if (COMMENT(c,TRUE,init)) {     // skip comment line after
                skipComments(stream);       //    continuation char
                ++line;                     // manis - 11/13/87
                c = GET(stream);
            }
        } else {
            UngetTxtChr(c,file);
            c = '\\';
            return(c);
        }
    }
    return(c);
}


//  getString()
//
//  arguments:  type    says which kind of token we're getting,
//                       a build STRING, or macro VALUE
//                       (we strip comments from VALUEs, but not
//                       from STRINGs)
//              s       pointer to buffer that will hold string
//              init    global boolean value -- TRUE if tools.ini is the
//                       file being lexed
//              colZero global boolean value -- true if we 're in
//                       1st position of line when invoked
//              end     pointer to end of s[]
//
//  actions:    gets all chars up to the end of line or end of file
//              and stores them in s[]
//              backslash followed by newline is replaced by a single
//              space, and getString() continues getting characters
//              comments beginning in column 0 are ignored, as are
//              comments anywhere on a VALUE line
//
//  modifies:   buf     by modifying *s
//              line    global line count
//              colZero thru' calls to lgetc()
//
//  When build strings or macro values are continued on the next line w/
//  a backslash before the newline, leading whitespace after the newline
//  is omitted.  This is for xmake compatibility.
//
//  The continuation character is backslash immediately before newline.
//
//  The only difference between build strings and macro values is that
//  comments are stripped from macro values and not from build strings.
//
//  Modifications:
//
//    06-Jul-1989 SB remove escaping in command lines
//    15-Jun-1988 rj Added escape functionality.  Escape char., before
//               certain characters, causes those characters to bypass
//               the normal mechanism determining their type; they are
//               placed directly into the string.  Some characters cause
//               the escape character itself to be placed into the
//               string.

void
getString(
    UCHAR type,                         // build string or macro value?
    char *s,
    char *end
    )
{
    int c;                              // buffer
    UCHAR state, input;
    int tempC;
    unsigned size;                      // whenever state
    char *begin;                        //    is 0, we're in
                                        //    column zero
    BOOL parsechar;                     // flag to examine char. type
    BOOL inQuotes = (BOOL) FALSE;       // flag when inside quote marks

    begin = s;
    c = lgetc();
    if (type == STRING)
        state = (UCHAR) 2;
    else if (WHITESPACE(c)) {
        state = (UCHAR) 2;
        c = skipWhiteSpace(FROMLOCAL);
    } else if (c == ESCH) {
        c = lgetc();
        if (WHITESPACE(c)) {
            state = (UCHAR) 2;
            c = skipWhiteSpace(FROMLOCAL);
        } else {
            UngetTxtChr(c, file);
            state = (UCHAR) 1;          // default state
            c = ESCH;
        }
    } else
        state = (UCHAR) 1;              // default state

    for (;;c = lgetc()) {
        if (c == '\"')
            inQuotes = (BOOL) !inQuotes;
        parsechar = 1;                  // Default is examine character.
        if (c == ESCH && !inQuotes && type == VALUE) {
            c = lgetc();
            switch (c) {
                case '$': case ESCH:    // Special characters; must
                case '{': case '}':     // not elide esch from string
                case '(': case ')':
                case '!': case '-': case '@':
                    *s++ = ESCH;
                    if (s == end) {
                        if (string == NULL) {       // Increase size of s
                            string = (char *) allocate(MAXBUF<<1);
                            _tcsncpy(string,begin,MAXBUF);
                            s = string + MAXBUF;
                            size = MAXBUF << 1;
                            end = string + size;
                        } else {
                            void *pv;
                            if ((size + MAXBUF < size) || !(pv = REALLOC(string,size+MAXBUF))) {
                                makeError(line, MACRO_TOO_LONG);
                            } else {
                                string = (char *)pv;
                            }
                            s = string + size;
                            size += MAXBUF;
                            end = string + size;
                        }
                        begin = string;
                    }
                case '#': case '\n':        // elide esch right now!
                case '\\': case '\"':
                    input = DEFAULT_;
                    parsechar = 0;          // DON'T examine character
                    break;
                default:
                    break;                  // DO examine character.
            }
        } else if (c == ESCH) {
            c = lgetc();
            UngetTxtChr(c, file);
            c = ESCH;
        }

        if (parsechar) {
            switch (c) {
                case '#':   input = COMMENT_;       break;
                case '=':   input = EQUALS_;        break;
                case ':':   input = COLON_;         break;
                case '$':   input = DOLLAR_;        break;
                case '(':   input = OPENPAREN_;     break;
                case ')':   input = CLOSEPAREN_;    break;
                case '\\':  input = BACKSLASH_;     break;
                case '\n':
                case EOF:   input = NEWLINE_;       break;
                case ' ':
                case '\t':  input = WHITESPACE_;    break;
                case '*':   input = STAR_;          break;
                case '@':
                case '<':
                case '?':   input = SPECIAL1_;      break;
                case 'F':
                case 'D':
                case 'B':
                case 'R':   input = SPECIAL2_;      break;
                case ';':   input = (UCHAR) (!state && init ? COMMENT_ : DEFAULT_);
                    break;          /* Handle comments in tools.ini */

                default:    input = (UCHAR) (MACRO_CHAR(c) ? MACROCHAR_:DEFAULT_);
                    break;
            }
        }
        if (input == SPECIAL1_ && type == STRING && c == '<') {
            if ((tempC = lgetc()) == '<') {             // << means start
                s = makeInlineFiles(s, &begin, &end);   // an inline file
                input = NEWLINE_;
                c = '\n'; line--;       // adding a '\n', we need to remove a line to compensate
            } else {
                UngetTxtChr(tempC,file);
            }
            state = stringStates[state][input];
        } else if (input == COMMENT_) {                 // Handle comments
            if (!state) {
                inQuotes = (BOOL) FALSE;
                skipComments(FROMLOCAL);
                ++line;
                continue;
            }
            else if (type == VALUE)
                state = OK;             // don't elide from command
            else
                state = stringStates[state][input];
        } else
            state = stringStates[state][input];

        if (state == OK) {              // Accept end of string
            inQuotes = (BOOL) FALSE;
            UngetTxtChr(c,file);

            // Strip trailing whitespace from string.  Easier to do it here,
            // else we have to treat a multi-string value (OBJS=a b c) as
            // separate tokens.  [RB]

            while (s > begin && _istspace(s[-1]))
                --s;
            *s = '\0';
            if (string) {
                if (s = (char *) REALLOC(string, (size_t) (s - string + 1)))
                    string = s;
            } else
                string = makeString(begin);
            return;
        } else if (ON(state,ERROR_MASK))        // Error code from table
            makeError(line,(state&~ERROR_MASK)+FATAL_ERR,c);

        if (!state) {                   // Col 0; we just hit \nl
            *--s = ' ';                 // so treat it like white-
            ++s;  ++line;               // space; overwrite the
            colZero = TRUE;             // backslash with a space.
            c = lgetc();
            colZero = FALSE;
            if (WHITESPACE(c)) {
                state = 2;
                do {
                    c = lgetc();
                } while (WHITESPACE(c));
            }
            UngetTxtChr(c,file);
        } else {                        // Keep storing string
            *s++ = (char) c;
            if (s == end) {
                if (!string) {          // Increase size of s
                    string = (char *) allocate(MAXBUF<<1);
                    _tcsncpy(string,begin,MAXBUF);
                    s = string + MAXBUF;
                    size = MAXBUF << 1;
                    end = string + size;
                } else {
                    void *pv;
                    if ((size + MAXBUF < size) || !(pv = REALLOC(string,size+MAXBUF))) {
                        makeError(line, MACRO_TOO_LONG);
                    } else {
                        string = (char *)pv;
                    }
                    s = string + size;
                    size += MAXBUF;
                    end = string + size;
                }
            }
        }
    }
}


//  getName()
//
//  arguments:  s       pointer into buffer that will hold string
//                       (s is pointing to buf+1 when passed, because
//                       the caller, getToken(), has already seen and
//                       saved one char)
//              init    global boolean value -- TRUE if tools.ini is the
//                       file being lexed
//                       used by routine called - lgetc()
//              end     pointer to end of s[]
//
//  actions:    gets all chars up to first token delimiter and stores
//              them in s[] (delimiters are ' ', '\t', '\n' and (when
//              not inside a macro invocation) ':' and '='
//              note that backslash-newline is treated as a space,
//              which is a delimiter
//              if the current input char is '$' this must be a macro
//              invocation
//              if the macro name is in parentheses
//                get all chars up to and including close paren
//                (if ')' not found, error)
//
//  We check the syntax within the name here -- thus errors in macro
//  invocation syntax will be caught.  Special macros cannot be used
//  as part of names, with the exception of the dynamic dependency macros.
//
//  We can probably never overrun our buffer, because it would be extremely
//  difficult for the user to get a name with 1024 characters or more into
//  his makefile.
//
//  we never end up in column zero, because we push the delimiter back
//  out on the input
//
//  uses state table defined in table.h, defs from grammar.h
//
//    modifies: line    (possibly) thru' call to lgetc()
//              file    (possibly) if lgetc() finds a !include
//              fName   (possibly) if lgetc() finds a !include

void
getName(
    char *s,
    char *end                           // pts to end of s
    )
{
    int c;
    UCHAR state, input;
    BOOL seenBackSlash = FALSE;
    BOOL fQuoted = FALSE;
    char *beg = s - 1;
    BOOL parsechar;                     // flag to examine char. type

    switch (*(s-1)) {
        case '$':   state = (UCHAR) 2;    break;
        case '{':   state = (UCHAR) 8;    break;
        case '"':   fQuoted = TRUE; state = (UCHAR)16; break;
        default:    state = (UCHAR) 0;    break;
    }

    for (;;) {
        c = lgetc();
        parsechar = 1;                  // Default is examine char.
        if (c == ESCH) {
            c = lgetc();
            switch (c) {
                case '{':               // Special characters; must
                case '}':               // not elide esch from string
                case '(':
                case ')':
                case '$':
                case ESCH:
                    *s++ = ESCH;

                case '#':               // elide esch right now!
                case '\n':
                case '\\':
                    input = DEFAULT_;
                    parsechar = 0;      // DON'T examine character
                    break;
                default:
                    break;              // DO examine character.
        }
    }
    if (parsechar) {
        switch (c) {
            case '#' :  input = COMMENT_;        break;
            case '=' :  input = EQUALS_;        break;
            case ';' :  input = SEMICOLON_;     break;
            case ':' :  input = COLON_;        break;
            case '$' :  input = DOLLAR_;        break;
            case '(' :  input = OPENPAREN_;     break;
            case ')' :  input = CLOSEPAREN_;    break;
            case '{' :  input = OPENCURLY_;     break;
            case '}' :  input = CLOSECURLY_;    break;
            case ' ' :
            case '\t':  input = (UCHAR)((fQuoted)
                       ? DEFAULT_ : WHITESPACE_);
                break;
            case '\n':
            case EOF :  input = NEWLINE_;        break;
            case '\\':  input = BKSLSH_;        break;
            case '"' :  input = QUOTE_; 
				if (state == 18) {
					// found a quote after a path list {...}
					// handle as quoted name
					fQuoted = 1;
				}
				break;

            // Add support for $* and $@ on the dependency line
            default  :
                if (ON(actionFlags, A_DEPENDENT))
                    input = (UCHAR)((MACRO_CHAR(c) || c == '*' || c == '@')
                         ?MACROCHAR_:DEFAULT_);
                else
                    input = (UCHAR)(MACRO_CHAR(c)?MACROCHAR_:DEFAULT_);
                break;
        }
    }
    state = nameStates[state][input];

    // Cheat lex table to think that you are handling quoted string case

    if (fQuoted && state == 1)
        state = 16;
	
    // seenBackSlash is used to provide lookahead when \ is seen on a
    // dependency line
    if (seenBackSlash)
        // if \ followed by \n then use it as a continuation
        if (input == NEWLINE_) {
            ++line;
            colZero = TRUE;
            c = lgetc();
            colZero = FALSE;
            if (WHITESPACE(c)) {
                state = OK;
                do {
                    c = lgetc();
                } while (WHITESPACE(c));
            } else
                state = (UCHAR)((s == buf + 1) ? BEG : DEF);
        } else
            *s++ = '\\';
        seenBackSlash = FALSE;
        if (s >= end)
            makeError(line,NAME_TOO_LONG);
        if (state == OK) {
            UngetTxtChr(c,file);
            *s = '\0';
            removeTrailChars(beg);
            return;
        } else if (ON(state,ERROR_MASK))
            makeError(line,(state&~ERROR_MASK)+FATAL_ERR,c);

        if (state == BKS) {
            seenBackSlash = TRUE;       //set lookahead flag
        } else
            *s++ = (char) c;
    }
}


//  createDosTmp -- Creates a unique temporary file.
//
// Scope:
//  Global.
//
// Purpose:
//  To create a unique temporary file by calling _mktemp() but it gets
//  over _mktemp() limitation to be able to create more files.
//
// Input:
//  path -- The buffer initially contain the directory to store the temp
//          file.  On exit, if success, the temp file is appended to it.
//          In case of failure, the its contents is undetermined.
//
// Output:
//  If successful, temporary file name is appended to path and
//  the function returns the file pointer, else NULL.
//
// History:
//  06-Apr-1993 HV Change createDosTmp() to use _makepath()

FILE *
createDosTmp(
    char *path
    )
{
    FILE       *fd = NULL;

    // CONSIDER: is the size of szDir too big for the stack?  We can
    //           make it a little smaller if we take the risk.

    char        szDir[_MAX_PATH];

    // CONSIDER: The path supplied by the caller might contain both
    //           the drive and probably some level of directories
    //           (e.g. c:\win\tmp)  Right now, _makepath happily takes
    //           the whole thing as the directory component, but that
    //           might change in the future.  In such case, we should
    //           first break up path to drive/dir compents before we
    //           construct the full pathname of the template.  There
    //           is something to watch out: for "c:\win\tmp", _splitpath
    //           will split as: "c:", "\win\", and "tmp", which is not
    //           what we want.  To fix it, append a backslash to the
    //           end before calling _splitpath.  "c:\win\tmp\" will
    //           be broken up correctly to "c:" and "\win\tmp\"

    if (!path || !*path) {             // If path is empty, use "."
        _tcscpy(szDir, ".");
    } else {
        _tcscpy(szDir, path);
    }

#if 0
    static char filetemplate[] = "nmXXXXXX";
    static char szExtension[] = ".";    // just a dot to make Mr. linker happy.
    // Construct the full pathname.  _mktemp() doesn't seem to like
    // template with trailing dot (".") so instead of specifying "."
    // for the extension, we defer it later and _tcscat the dot to
    // its tail.
    _makepath(path, NULL, szDir, filetemplate, NULL);

    if (_mktemp(path) == NULL) {
        // Mktemp() has a limit of 27 files per template.  If it fails, assume
        // the limit has overflowed and increment the second letter of the template.

        if (filetemplate[1] == 'z') {
            filetemplate[1] = 'a';
        } else {
            ++filetemplate[1];          // ASSUMPTION: that this will work with DBCS
        }

        _makepath(path, NULL, szDir, filetemplate, NULL);

        if (_mktemp(path) == NULL) {
            return(NULL);
        }
    }

    // add a trailing "." for the linker's sake
    _tcscat(path, szExtension);

#endif


    // Use GetTempFileName to overcome limitations of _mktemp 
    // regarding the max number of generated files [vs7:5255]
    char szTempFile[_MAX_PATH];
    if (GetTempFileName (path, "nm", 0, szTempFile)) {
        _tcscpy(path, szTempFile);
        // Open the file and return the file's descriptor.
        fd = FILEOPEN(path, "w");
    }

    return fd;
}


void
popFileStack()
{
    if (fclose(file) == EOF)
       makeError(0, ERROR_CLOSING_FILE, fName);
    FREE(fName);
    file = incStack[--incTop].file;
    fName = incStack[incTop].name;
    line = incStack[incTop].line;
}


//  include()  -- handle include files
//
//  arguments:  c       first non-whitespace char after the string
//                       INCLUDE on the line...
//              colZero global boolean value, set if currently at
//                       column zero of a file.
//
//  modifies:   line     global line count - if include file opened
//              file     global pointer to current file
//              fName    global pointer to name of current file
//              colZero  global boolean value, changed if include
//                        file opened and char from colZero is returned

UCHAR
include(
    int c
    )
{
    size_t n;
    char *s;

    if (c == '\n' || c == EOF)
        makeError(line,SYNTAX_NO_NAME);

    *buf = (char) c;
    if (!fgets(buf+1,MAXBUF - 1,file)) {
        if (feof(file))
            makeError(line,SYNTAX_UNEXPECTED_TOKEN,"EOF");
        makeError(line,CANT_READ_FILE);
    }
    n = _tcslen(buf) - 1;
    if (buf[n] == '\n') {
        buf[n] = '\0';
    }
    s = buf;
    while (WHITESPACE(*s))
        ++s;
    return(processIncludeFile(s));
}


//  processIncludeFile()  -- checks for include file and switches state
//
//  arguments:  s       buffer that has include file name
//              colZero global boolean value, set if currently at
//                       column zero of a file.
//              init    global boolean - set if tools.ini is being lexed
//                       used by lgetc() which is called from here...
//
//  modifies:   line    global line count - if include file opened
//              file    global pointer to current file
//              fName   global pointer to name of current file
//              colZero global boolean value, changed if include
//                       file opened and char from colZero is returned

UCHAR
processIncludeFile(
    char *s
    )
{
    MACRODEF *m;
    struct _finddata_t finddata;
    NMHANDLE searchHandle;
    char *t, *p, *u;
    int c = 0;
    int i;

    if (!*s || *s == '#') {
        makeError(line, SYNTAX_NO_NAME);
    }

    if (t = _tcspbrk(s,"\t#")) {
        if (*t == '#') {
            c = *t;
        }

        *t = '\0';

        if (!c) {
            for (u = t; *++u;) {        // check for extra
                if (*u == '#') {
                    break;              // text on line
                }

                if (!WHITESPACE(*u)) {
                    makeError(line, SYNTAX_UNEXPECTED_TOKEN, u);
                }
            }
        }
    } else {
        t = s + _tcslen(s);
    }

	// remove trailing white space
	while (t > s) {
		char *prev;
		prev = _tcsdec(s, t);
        if (prev) {
    		if (!WHITESPACE(*prev))
	    		break;
            t = prev;
        }
	}
	*t = '\0';

    if (*s == '<' && *(t-1) == '>') {
        char *pt;

        *--t = '\0';
        p = removeMacros(++s);
        p = p == s ? makeString(s) : p;
        t = (m = findMacro("INCLUDE")) ? m->values->text : (char*) NULL;
        if (t != NULL) {        // expand INCLUDE macro before passing it on
            char * pt1;

            pt1= makeString(t);
            pt = removeMacros(pt1);
            if (pt != pt1) {
                FREE(pt1);             // we've got a new string, free old one
            }
        } else {
            pt = NULL;
        }

        if (!(u = searchPath(pt, p, &finddata, &searchHandle))) {
            makeError(line, CANT_OPEN_FILE, p);
        }

        if (pt) {
            FREE(pt);
        }

        FREE(p);
        s = u;
    } else {
        if (*s == '"' && *(t-1) == '"') {
            *--t = '\0';
            ++s;
        }
        p = removeMacros(s);
        p = p == s ? makeString(s) : p;
        if (!findFirst(p, &finddata, &searchHandle)) {
            if (!_tcspbrk(p, "\\/:")) {
                //use C sematics for include
                for (i = incTop;i >= 0;i--) {
                    t = (i == incTop) ? fName : incStack[i].name;
                    if (!(t = getPath(t)))
                        continue;
                    u = (char *)allocate(_tcslen(t) + 1 + _tcslen(p) + 1);
                    _tcscat(_tcscat(_tcscpy(u, t), "\\"), p);
                    if (findFirst(u, &finddata, &searchHandle)) {
                        s = u;
                        FREE(t);
                        break;
                    }
                    FREE(t);
                    FREE(u);
                }
                FREE(p);
                if (i < 0) {
                    makeError(line, CANT_OPEN_FILE, s);
                }
            } else {
                makeError(line, CANT_OPEN_FILE, p);
            }
        }
    }

    for (i = 0; i < incTop; ++i) {      // test for cycles
        if (!_tcsicmp(s,incStack[i].name)) {
            makeError(line, CYCLE_IN_INCLUDES, s);
        }
    }

    incStack[incTop].file = file;       // push info on stack
    incStack[incTop].line = line;
    incStack[incTop++].name = fName;
    currentLine = 0;

    if (!(file = OpenValidateMakefile(s,"rt"))) {   // read, text mode
        makeError(line,CANT_OPEN_FILE,s);
    }

    fName = makeString(s);
    line = 1;
    colZero = TRUE;                     // parser needs to see some kind of
    c = lgetc();                        //  newline to initialize it for this

    if (colZero = (BOOL) !WHITESPACE(c)) {  // file
        UngetTxtChr(c,file);
        line=0;                         // We did not start reading the file
        return(NEWLINE);
    }

    return(NEWLINESPACE);
}


//  getPath -- return the drive/directory parts of a full path
//
// Scope:
//  Local
//
// Purpose:
//  This function returns the drive/directory parts of a full path.  Space is
//  allocated for the resulting string, so the caller is responsible for freeing
//  it after use.
//
// Input:   pszFullPath -- The full pathname.
//
// Assumes: Pathnames use MS-DOS file naming convension.
//
// Notes:
//  To allocate temporary memory for the drive and path components, I have used
//  _MAX_DRIVE and _MAX_DIR.  Under Windows NT there are two possibilities:
//  1. These two parameters can be so large that the stack will be overflow
//  2. They are not large enough (?)
//
// History:
//  22-Mar-1993 HV Rewrite getPath() to make use of the new _splitpath() and
//          _makepath() functions.

char *
getPath(
    const char *pszFullPath
    )
{
    // HV: Are _MAX_DRIVE and _MAX_DIR good size under NT?  Does it
    // work under Windows NT?
    char szDrive[_MAX_DRIVE];
    char szDir[_MAX_DIR];
    char *szPath;
    char *pszSlash;

    // Separate the components of the fullpath
    _splitpath(pszFullPath, szDrive, szDir, NULL, NULL);

    // Allocate just enough memory to hold the drive/path combo then
    // Glue just the drive and dir component back together.
    szPath = (char *) rallocate(_tcslen(szDrive) + _tcslen(szDir) + 1);
    _makepath(szPath, szDrive, szDir, NULL, NULL);

    // Eliminate the trailing slash/blackslash to retain compatibility with
    // the older version of getPath()
    pszSlash = szPath + _tcslen(szPath) - 1;
    if ('\\' == *pszSlash || '/' == *pszSlash) {
        *pszSlash = '\0';
    }

    return szPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\init.cpp ===
//  INIT.C -- routines to handle TOOLS.INI
//
//    Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains routines to deal with TOOLS.INI file. Functions in TOOLS.LIB
//  have not been used because NMAKE needs to be small and the overhead is too
//  much.
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Oct-1993 HV Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV Add include file mbstring.h
//                 Change the str* functions to STR*
//  10-May-1993 HV Revise SearchFileInEnv to take care of cases when path
//                 characters (\,/,:) are used.  This fixed the recursive
//                 problem.
//  22-Apr-1993 HV Rewrite SearchRunPath() to use _makepath(), _searchenv()
//                 Add SearchFileInEnv() helper for SearchRunPath()
//  08-Jun-1992 SS Port to DOSX32
//  02-Feb-1990 SB Replace fopen() by FILEOPEN
//  22-Nov-1989 SB Changed free() to FREE()
//  19-Oct-1989 SB searchHandle passed around as extra param
//  16-Aug-1989 SB error check for fclose() added
//  24-Apr-1989 SB made FILEINFO as void * for OS/2 1.2 support
//  05-Apr-1989 SB made all funcs NEAR; Reqd to make all function calls NEAR
//  20-Sep-1988 RB Add SearchRunPath().
//          Remove TOOLS.INI warning.
//  17-Aug-1988 RB Clean up.
//  10-May-1988 rb Find tools.ini in current directory first.
//  27-May-1988 rb Remove NO_INIT_ENTRY warning because of built-ins.

#include "precomp.h"
#pragma hdrstop

//  findTag()
//
//  arguments:  tag     pointer to tag name to be searched for
//
//  actions:    reads tokens from file
//              whenever it sees a newline, checks the next token
//               to see if 1st char is opening paren
//              if no, reads and discards rest of line and
//               checks next token to see if it's newline or EOF
//               and if newline loops to check next token . . .
//              if yes ('[' found), looks on line for tag
//              if tag found, looks for closing paren
//              if ']' found, discards rest of line and returns
//              else keeps looking until end of file or error
//
//  returns:    if successful, returns TRUE
//              if tag never found, returns FALSE

BOOL
findTag(
    char *tag
    )
{
    BOOL endTag;                       // TRUE when find [...]
    size_t n;
    char *s;

    for (line = 0; fgets(buf, MAXBUF, file); ++line) {
        if (*buf == '[') {
            endTag = FALSE;
            for (s = _tcstok(buf+1," \t\n");
                 s && !endTag;
                 s = _tcstok(NULL," \t\n")
                ) {
                n = _tcslen(s) - 1;

                if (s[n] == ']') {
                    endTag = TRUE;
                    s[n] = '\0';
                }

                if (!_tcsicmp(s,tag)) {
                    return(TRUE);
                }
            }
        }
    }

    if (!feof(file)) {
        currentLine = line;
        makeError(0, CANT_READ_FILE);
    }

    return(FALSE);
}


//  tagOpen()
//
//  arguments:  where   pointer to name of environment variable
//                       containing path to search
//              name    pointer to name of initialization file
//              tag     pointer to name of tag to find in file
//
//  actions:    looks for file in current directory
//              if not found, looks in each dir in path (semicolons
//                separate each path from the next in the string)
//              if file is found and opened, looks for the given tag
//
//              (if ported to xenix, tagOpen() and searchPath()
//               should probably use access() and not findFirst().)
//
//  returns:    if file and tag are found, returns pointer to file,
//                opened for reading and positioned at the line
//                following the tag line
//              else returns NULL

BOOL
tagOpen(
    char *where,
    char *name,
    char *tag
    )
{
    char szPath[_MAX_PATH];

    // Look for 'name' in current directory then path.

    _searchenv(name, where, szPath);

    if (szPath[0] == '\0') {
        return(FALSE);
    }

    if (!(file = FILEOPEN(szPath, "rt"))) {
        makeError(0, CANT_READ_FILE, szPath);
    }

    if (findTag(tag)) {
        return(TRUE);                   // look for tag in file
    }

    if (fclose(file) == EOF) {          // if tag not found, close
        makeError(0, ERROR_CLOSING_FILE, szPath);
    }

    return(FALSE);                      // file and pretend file not found
}



//  searchPath()
//
//  arguments:  p       pointer to string of paths to be searched
//              name    name of file being searched for
//
//  actions:    looks for name in current directory, then each
//                directory listed in string.
//
//  returns:    pointer to path spec of file found, else NULL
//
//  I don't use _tcstok() here because that modifies the string that it "token-
//  izes" and we cannot modify the environment-variable string.  I'd have to
//  make a local copy of the whole string, and then make another copy of each
//  directory to which I concatenate the filename to in order to test for the
//  file's existence.

char *
searchPath(
    char *p,
    char *name,
    void *findBuf,
    NMHANDLE *searchHandle
    )
{
    char *s;                           // since it's not in use

    // CONSIDER: Why aren't we using access() here?  FindFirst has problems
    // CONSIDER: with networks and DOS 2.x.  Also maybe cheaper.  [RLB]. */

    // We use FindFirst() because the dateTime of file matters to us
    // We don't need it always but then access() probably uses findFirst()
    // -Sundeep-

    if (findFirst(name, findBuf, searchHandle)) {   // check current dir first
        return(makeString(name));
    }

    // Check if environment string is NULL.  Unnecessary if check is done
    // elsewhere, but it's more convenient and safer to do it here.

    if (p == NULL) {
        return(NULL);
    }

    for (s = buf; ;) {
		while (*p && '\"' == *p) {
			// Quotes should not be used in search paths. If we find any,
			// we ignore them. This way we can form the full path and the
			// filename without quotes and add an enclosing pair of quotes
			// later, if necessary. [DS 14575]
			p++;
		}
        if (!*p || (*s = *p++) == ';') {    // found a dir separator
            if (s == buf) {                 // ignore ; w/out name
                if (*p) {
                    continue;
                }

                return(NULL);               // list exhausted ...
            }

            if (*(s-1) != '\\' && *(s-1) != '/') {  // append path separator
                *s++ = '\\';
            }

            *s = '\0';

            if (_tcspbrk(buf,"*?")) {      // wildcards not allowed
                s = buf;
                continue;
            }

            _tcscpy(s, name);              // append file name, zap

            if (findFirst(buf, findBuf, searchHandle)) {
                return(makeString(buf));
            }

            s = buf;                        // reset ptr to begin of
        }                                   // buf and check next dir
        else {
            ++s;                            // we keep copying chars
        }                                   //  until find ';' or '\0'
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\inline.cpp ===
//  INLINE.C - contains routines used to handle processing of in-line files
//
//    Copyright (c) 1989-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains the in-line file handling routines of NMAKE.
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  01-Jun-1993 HV Use UngetTxtChr() instead of ungetc()
//  10-May-1993 HV Add include file mbstring.h
//                 Change the str* functions to STR*
//  02-Feb-1990 SB change fopen() to FILEOPEN()
//  03-Jan-1990 SB removed unitiallized variable
//  04-Dec-1989 SB Removed to unreferenced variables in makeInlineFiles()
//  01-Dec-1989 SB Changed realloc() to REALLOC()
//  22-Nov-1989 SB Changed free() to FREE()
//  07-Nov-1989 SB Length of action word not evaluated correct for multiple
//          inline files for the same command
//  06-Nov-1989 SB allow macros in action word for inline files
//  24-Sep-1989 SB added processInline(), createInline()
//  20-Sep-1989 SB Created from routines previously scattered in the sources.
//
// Notes:
//  Sections with 'NOTE:' inside comments marks important/incomplete items.

// NOTE: Function headers yet to be completed; other comments are incomplete

#include "precomp.h"
#pragma hdrstop

void        processEschIn(char *);
// NOTE: This may go soon (use nextInlineFile ?)
void        parseInlineFileList(char *);
// NOTE: The next one has to go soon
void        appendScript(SCRIPTLIST**,SCRIPTLIST*);
void        delInlineSymbol(char*);
char      * nextInlineFile(char **);

// NOTE: Probably needs a new name
void        replaceLtLt(char **, char *);
void        createInline(FILE *, const char *, char **, BOOL);
char *      getLine(char *, int);
void        echoLine(char *, const char *, BOOL);


// NOTE: delScriptFiles() from nmake.c not yet brought in here
extern FILE      * createDosTmp(char *);

      char      * makeInlineFiles(char *, char **, char **);
      BOOL        processInline(char *, char **, STRINGLIST **, BOOL);

//  makeInlineFiles - creates memory images for in-line files
//
// Scope:   Global.
//
// Purpose: This is the function that handles dynamic in-line files
//
// Input:   s - Input command line string after first << (pts to char Buffer)
//
// Output:  Returns ...
//
// Errors/Warnings:
//  SYNTAX_UNEXPECTED_TOKEN - The makefile cannot end without the in-line file
//                            ending.
//  CANT_READ_FILE          - When the makefile is unreadable.
//  SYNTAX_KEEP_INLINE_FILE - An inline file should end
//  OUT_OF_MEMORY           - On failing to extend in-memory in-line file.
//
// Uses Globals:
//  file - global stream
//  line - lexer's line count
//
// Notes:
//  Usage notes and other important notes

char *
makeInlineFiles(
    char *s,
    char **begin,
    char **end
    )
{
    char rgchBuf[MAXBUF];
    char *t;
    unsigned size;
    BOOL fPastCmd = FALSE;              // If seen line past Cmd line
    // used when rgchBuf is insuff for in-memory-inline file
    char *szTmpBuf = NULL;

    _tcscpy(rgchBuf, "<<");            // to help parseInlineFileList
    if (!getLine(rgchBuf+2,MAXBUF - 2)) {
        if (feof(file))
            makeError(line, SYNTAX_UNEXPECTED_TOKEN, "EOF");
        makeError(line, CANT_READ_FILE);
    }

    parseInlineFileList(rgchBuf);
    for (;scriptFileList;scriptFileList = scriptFileList->next) {
        for (;;) {
            for (t = rgchBuf;;) {
                *s++ = *t++;
                if (s == *end) {
                    if (!szTmpBuf) {              /* Increase size of s */
                        szTmpBuf = (char *) allocate(MAXBUF<<1);
                        _tcsncpy(szTmpBuf, *begin, MAXBUF);
                        s = szTmpBuf + MAXBUF;
                        size = MAXBUF << 1;
                        *end = szTmpBuf + size;
                    } else {
                        void *pv;
                        if ((size + MAXBUF < size) || !(pv = REALLOC(szTmpBuf,size+MAXBUF))) {
                            makeError(line, MACRO_TOO_LONG);
                        } else {
                            szTmpBuf = (char *) pv;
                        }
                        s = szTmpBuf + size;
                        size += MAXBUF;
                        *end = szTmpBuf + size;
                    }
                    *begin = szTmpBuf;
                }
                if (!*t)
                    break;
            }
            if (fPastCmd && rgchBuf[0] == '<' && rgchBuf[1] == '<') {
                //We don't care about action specified here; could be a macro
                if (scriptFileList->next) {
                    if (!getLine(rgchBuf, MAXBUF)) {
                        if (feof(file))
                            makeError(line, SYNTAX_UNEXPECTED_TOKEN, "EOF");
                        makeError(line, CANT_READ_FILE);
                    }
                }
                break;
            }
            fPastCmd = TRUE;
            if (!getLine(rgchBuf,MAXBUF)) {
                if (feof(file))
                    makeError(line, SYNTAX_UNEXPECTED_TOKEN, "EOF");
                makeError(line,CANT_READ_FILE);
            }
        }
    }
    *s = '\0';
    return(s);
}

//  processEschIn - Handles Esch characters in Script File lines
//
// Scope:   Global.
//
// Purpose:
//  Inline file lines are handled for escape characters. If a line contains an
//  escaped newline then append the next line to it.
//
// Input:   buf - the command line to be processed for ESCH characters
//
// Errors/Warnings:
//  SYNTAX_UNEXPECTED_TOKEN - The makefile cannot end without the in-line file
//                 ending.
//  CANT_READ_FILE - When the makefile is unreadable.
//
// Assumes:
//  If the newline is escaped the newline is last char in 'pGlobalbuf'. Safe
//  to do so because we got 'pGlobalBuf' via fgets(). ????
//
// Modifies Globals:
//  line - if newline was Escaped update line
//  file - the makefile being processed
//  buf    - gets next line appended if newline was Escaped (indirectly)
//
// Uses Globals:
//  buf - Indirectly

void
processEschIn(
    char *pGlobalBuf
    )
{
    char *p, *q;

    p = pGlobalBuf;
    while (p = _tcschr(p, '\n')) {
        if (p > pGlobalBuf) {
            char * pprev = _tcsdec(pGlobalBuf, p);
            if (pprev) {
                if (*pprev != ESCH) {
                    break;
                }
            }
        }

        p++;

        if (!(q = fgets(p, (int)(size_t) (MAXBUF - (p - pGlobalBuf)), file))) {
            if (feof(file)) {
                makeError(line, SYNTAX_UNEXPECTED_TOKEN, "EOF");
            }

            makeError(line, CANT_READ_FILE);
        }

        line++;
    }
}


//  parseInlineFileList - Parses file list and makes list of Inline files
//
// Scope:   Global.
//
// Purpose:
//  To handle multiple inline files, the names of the files are to be stored
//  in a list. This function creates the list by parsing the command file
//
// Input:   buf - the line to be parsed
//
// Modifies Globals:
//  scriptFileList -- the list of script files.

void
parseInlineFileList(
    char *buf
    )
{
    char *token;

    processEschIn(buf);

    token = nextInlineFile(&buf);       //next inline file

    while (token != NULL) {
        SCRIPTLIST *newScript;

        newScript = makeNewScriptListElement();
        newScript->sFile = makeString(token);
        appendScript(&scriptFileList, newScript);

        token = nextInlineFile(&buf);   // next inline file
    }
}

//  appendScript  --  appends an element to the tail of a scriptlist
//
// Purpose:
//  Traverse to the end of the list and append element there.
//
// Input:
//  list     --    the list to append to
//  element  --    the element inserted
//
// Modifies:
//  the global list

void
appendScript(
    SCRIPTLIST **list,
    SCRIPTLIST *element
    )
{
    for (; *list; list = &(*list)->next)
        ;

    *list = element;
}

char tok[MAXNAME];

// Space not included in the following macro as it is now a valid
// character for filenames [DS 14966]
#define NAME_CHAR(c) (c) != '>' && (c) != '<' && \
             (c) != '^' && (c) != ',' && (c) != '\t' && \
             (c) != '\n'

//  nextInlineFile - gets next Inline file name from command line
//
// Scope:   Local.
//
// Purpose:
//  The command line syntax is complex. This function returns the next Inline
//  file in the command line part passed to it. As a side effect it changes the
//  pointer to just after this inline file name.
//
// Input:   str - address of the part of command line under consideration.
//
// Output:  Returns the next inline filename.
//
// Modifies Globals:
//  Global - How and why modified
//
// Uses Globals:
//  tok - the address of this static array is returned.

char *
nextInlineFile(
    char **str
    )
{
    char *t = tok, *pStr = *str;
    BOOL fFound = FALSE;                // '<<' not found
    BOOL fQuoted = FALSE;               // found '\"'

    while (!fFound) {
        if (!(pStr = _tcschr(pStr, '<'))) {
            return(NULL);
        }

        if (*++pStr == '<') {
            fFound = TRUE;
        }
    }

    // Since '<<' has been found we definitely have another Inline File
    pStr++;
    while (*pStr && NAME_CHAR(*pStr)) {
        if (*pStr == '\"') {
            fQuoted = !fQuoted;
        }

        if (*pStr == ' ' && !fQuoted) {
            break;
        }

        if (*pStr == '$' && pStr[1] == '(') {
            *t = '$';
            *++t = '(';

            while (*++pStr != '\n' && *pStr != ')') {
                *t++ = *pStr;
            }

            if (*pStr == '\n') {
                break;
            }
        } else {
            *t = *pStr;
            ++t; ++pStr;
        }
    }

    *t = '\0';
    *str = pStr;
    return(tok);
}

//  processInline - Brief description of the function
//
// Output:  Returns ... TRUE if cmdline returned is expanded

BOOL
processInline(
    char *szCmd,
    char **szCmdLine,
    STRINGLIST **pMacroList,
    BOOL fDump
    )
{
    char *szInline, *szUnexpInline;     // Inline name, unexpanded
    char *pCmdLine;                     // The executable line
    FILE *infile;                       // The inline file
    char *begInBlock, *inBlock, *pInBlock;  // inline block
    char szTmp[MAXNAME + 2];                // add 2 to allow space for quotes
    STRINGLIST *newString;
    int iKeywordLen;

    if (begInBlock = _tcschr(szCmd, '\n')) {
        *begInBlock = '\0';
        *szCmdLine = expandMacros(szCmd, pMacroList);
        *begInBlock = '\n';
        begInBlock++;
        // if not expanded, allocate a copy
        if (*szCmdLine == szCmd)
            *szCmdLine = makeString(szCmd);
    } else {
        *szCmdLine = makeString(szCmd);
        return(FALSE);
    }

    pCmdLine = *szCmdLine;
    //expand macros in the inline file ...
    pInBlock = inBlock = expandMacros(begInBlock, pMacroList);

    while (szUnexpInline = nextInlineFile(&pCmdLine)) {
        BOOL fKeep = FALSE;             // default is NOKEEP
        char *newline;

        // CAVIAR 3410 -- the inline filename has already been expaned
        // by the time we get here... we just need to dup the name
        // so that it is preserved long enough to delete it later... [rm]
        //
        // szInline = removeMacros(szUnexpInline);

        szInline = makeString(szUnexpInline);

        if (!*szInline) {
            char *nmTmp;

            if ((nmTmp = getenv("TMP")) != NULL && *nmTmp) {
                assert(_tcslen(nmTmp) <= MAXNAME);
                _tcsncpy(szTmp, nmTmp, MAXNAME);
            } else
                szTmp[0] = '\0';

            if (!(infile = createDosTmp(szTmp)))
                makeError(line, CANT_MAKE_INLINE, szTmp);

            if (_tcschr(szTmp, ' ') && !_tcschr(szTmp, '"')) {
                // if the filename (str) contains spaces
                // and is unquoted, quote it, so that we can
                // feed it properly to the command interpreter! [VS98 1931]
                size_t size = _tcslen(szTmp);
                memmove(szTmp+1, szTmp, size);
                *szTmp = '"';
                *(szTmp + size + 1) = '"';
                *(szTmp + size + 2) = '\0';
            }

            replaceLtLt(szCmdLine, szTmp);

            FREE(szInline);
            szInline = makeString(szTmp);
        } else if (!(infile = FILEOPEN(szInline, "w")))
            makeError(line, CANT_MAKE_INLINE, szInline);
        else
            delInlineSymbol(*szCmdLine);
        pCmdLine = *szCmdLine;          // Because szCmdLine changed

        createInline(infile, szInline, &pInBlock, fDump);

        // Add handling of KEEP and NOKEEP here
        // iKeywordLen is length of word after << on that line
        newline = _tcschr(pInBlock , '\n');
        iKeywordLen = newline ? ((int) (newline - pInBlock)) : _tcslen(pInBlock);

        if (iKeywordLen > 3 && !_tcsnicmp(pInBlock, "keep", 4)) {
            pInBlock +=4;
            fKeep = (BOOL)TRUE;
        } else if (iKeywordLen > 5 && !_tcsnicmp(pInBlock, "nokeep", 6))
            pInBlock += 6;
        else if (iKeywordLen)
            makeError(line, SYNTAX_KEEP_INLINE_FILE);

        if (*pInBlock == '\n')
            pInBlock++;
        fclose(infile);
        // Add the file to list to be deleted; except for "KEEP"
        if (!fKeep) {
            newString = makeNewStrListElement();
            newString->text = makeString(szInline);
            appendItem(&delList, newString);
        }
        FREE(szInline);
    }

    if (inBlock != begInBlock)
        FREE(inBlock);
    return(TRUE);
}


void
replaceLtLt(
    char **source,
    char *str
    )
{
    char *szBuf;
    char *p, *q;
    void *pv;

    // Don't subtract two for the << and forget to add 1 for the null termination.

    szBuf = (char *) malloc(_tcslen(*source) - 1 + _tcslen(str));
    if (!szBuf) {
        makeError(0, OUT_OF_MEMORY);
    }
    for (p = *source, q = szBuf;;++p,++q)
    if (*p != '<')
        *q = *p;
    else if (*(p+1) != '<') {
        *q = '<';
    } else {
        *q = '\0';
        _tcscat(_tcscat(szBuf, str), p+2);
        pv = REALLOC(*source, _tcslen(szBuf) + 1);
        if (pv) {
            *source = (char *) pv;
        } else {
            makeError(0, OUT_OF_MEMORY);
        }
        _tcscpy(*source, szBuf);
        break;
    }

    free(szBuf);
}

void
createInline(
    FILE *file,
    const char *szFName,
    char **szString,
    BOOL fDump
    )
{
    char *t, *u;
    BOOL fFirstLine = TRUE;

    while (t = _tcschr(*szString, '\n'))
    if (!_tcsncmp(*szString, "<<", 2)) {
        *szString += 2;
        break;
    } else {
        // [msdev96 #3036]
        // "nmake /n" should somehow show the contents of
        // response files (esp. temp ones that are deleted
        // right after use). In order to preserve the batch
        // file format of the output (at least in common
        // cases), we use a syntax like
        // "echo. command >> resp_file" (the dot after
        // the "echo" command is useful for echo'ing
        // empty strings.)
        //
        // A new switch has been added for this
        // purpose ("nmake /u" dumps inline files)
        if (fDump) {
            *t = '\0';
            echoLine(*szString, szFName, !fFirstLine);
            *t = '\n';
        }
        for (u = *szString; u <= t; u++)
        fputc(*u, file);
        *szString = u;
        fFirstLine = FALSE;
    }

    if (!t && !_tcsncmp(*szString, "<<", 2))
        *szString += 2;
}


// echoLine
//
// Usage:   echoLine (szLine, szFName, fAppend)
//
// Description:
//      prints an "echo szLine >> szFName"-like command
//      uses ">>" if fAppend is TRUE, ">" otherwise

void
echoLine(char *szLine, const char *szFName, BOOL fAppend)
{
    // use a 1024-byte buffer to split long lines, so that "echo"
    // commands can be handled by the command interpreter
    static char L_buf[1024];
    BOOL fBlankLine = TRUE;
    char *pch;
    char *szCur = szLine;
    size_t cbBuf;

    for (pch = szLine; *pch; pch = _tcsinc (pch)) {
        if (!_istspace((unsigned char)*pch)) {
            fBlankLine = FALSE;
            break;
        }
    }

    if (fBlankLine) {
        printf("\techo. %s %s\n",
            fAppend ? ">>" : ">",
            szFName);
        return;
    }

    // calculate available buffer length for szLine
    // assuming space for "\techo. ", " >> " and szFName
    cbBuf = sizeof(L_buf) - 11 - _tcslen( szFName ) - 1;

    while (*szCur) {
        size_t iLast;
        _tcsncpy (L_buf, szCur, cbBuf);
        iLast = _tcslen (L_buf);
        if (cbBuf < _tcslen (szCur)) {
            // find index of character next to the
            // last occurence of white space in buffer
            for (pch = L_buf; *pch; pch = _tcsinc(pch)) {
                if (_istspace((unsigned char)*pch)) {
                    iLast = (size_t) (pch - L_buf + 1);
                }
            }
        }

        L_buf[iLast] = 0;
        printf("\techo %s %s %s\n",
            L_buf,
            fAppend ? ">>" : ">",
            szFName);

        szCur += iLast;
        fAppend = TRUE;
    }
}


void
delInlineSymbol(
    char *s
    )
{
    char *p = _tcschr(s, '<');
    while (p[1] != '<')
    p = _tcschr(p+1, '<');
    // "<<" found
    _tcscpy(p, p+2);
}



//  getLine - get next line processing NMAKE conditionals enroute
//
// Scope:   Local
//
// Purpose:
//  This function handles directives in inline files. This function gets the
//  next line of input ... managing conditionals on the way.
//
// Input:
//  pchLine - pointer to buffer where line is copied
//  n - size of buffer
//
// Output:
//  Returns ... NULL, on EOF
//       ... non-zero on success
//
// Uses Globals:
//  line    - lexer's line count
//  colZero - if starting from colZero, needed by lgetc()
//
// Notes:
//  Similar to fgets() without stream
//
// Implementation Notes:
//  lgetc() handles directives while getting the next character. It handles
//  directives when the global colZero is TRUE.

char *
getLine(
    char *pchLine,
    int n
    )
{
    char *end = pchLine + n;
    int c;

    while (c = lgetc()) {
        switch (c) {
            case EOF:
                *pchLine = '\0';
                return(NULL);

            default:
                *pchLine++ = (char)c;
                break;
        }

        if (pchLine == end) {
            pchLine[-1] = '\0';
            UngetTxtChr(c, file);
            return(pchLine);
        } else if (c == '\n') {
            colZero = TRUE;
            ++line;
            *pchLine = '\0';
            return(pchLine);
        } else
            colZero = FALSE;    // the last character was not a '\n' and
                                // we are not at the beginning of the file
    }
    return(pchLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\makefile.inc ===
$(O)\errstr.rc : nmmsg.us
   mkmsg -rc $@ $?

$(O)\nmmsg.h : nmmsg.us
   mkmsg -h $@ $?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\nmake.cpp ===
//  NMAKE.C - main module
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This is the main module of nmake
//
// Revision History:
//  01-Feb-1994 HV  Move messages to external file.
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  26-Mar-1992 HV  Rewrite filename() to use _splitpath()
//  06-Oct-1992 GBS Removed extern for _pgmptr
//  08-Jun-1992 SS  add IDE feedback support
//  08-Jun-1992 SS  Port to DOSX32
//  29-May-1990 SB  Fix precedence of predefined inference rules ...
//  25-May-1990 SB  Various fixes: 1> New inference rules for fortran and pascal;
//                  2> Resolving ties in timestamps in favour of building;
//                  3> error U1058 does not echo the filename anymore (ctrl-c
//                  caused filename and lineno to be dispalyed and this was
//                  trouble for PWB
//  01-May-1990 SB  Add predefined rules and inference rules for FORTRAN
//  23-Apr-1990 SB  Add predefined rules and inference rules for COBOL
//  20-Apr-1990 SB  Don't show lineno for CTRL+C handler error
//  17-Apr-1990 SB  Pass copy of makeflags to putenv() else freeing screws the
//                  DGROUP.
//  23-Feb-1990 SB  chdir(MAKEDIR) to avoid returning to bad directory in DOS
//  02-Feb-1990 SB  change fopen() to FILEOPEN()
//  31-Jan-1990 SB  Postpone defineMAcro("MAKE") to doMAke(); Put freshly
//                  allocated strings in the macro table as freeStructures()
//                  free's the macroTable[]
//  24-Jan-1990 SB  Add byte to call for sprintf() for "@del ..." case for /z
//  29-Dec-1989 SB  ignore /Z when /T also specified
//  29-Dec-1989 SB  nmake -? was giving error with TMP directory nonexistent
//  19-Dec-1989 SB  nmake /z requests
//  14-Dec-1989 SB  Trunc MAKEFLAGS averts GPF;Silently ignore /z in protect mode
//  12-Dec-1989 SB  =c, =d for NMAKE /Z
//  08-Dec-1989 SB  /NZ causes /N to override /Z; add #define TEST_RUNTIME stuff
//  01-Dec-1989 SB  Contains an hack #ifdef'ed for Overlayed version
//  22-Nov-1989 SB  Changed free() to FREE()
//  17-Nov-1989 SB  defined INCL_NOPM; generate del commands to del temps
//  19-Oct-1989 SB  ifdef SLASHK'ed stuff for -k
//  04-Sep-1989 SB  echoing and redirection problem for -z fixed
//  17-Aug-1989 SB  added #ifdef DEBUG's and error -nz incompatible
//  31-Jul-1989 SB  Added check of return value -1 (error in spawning) for -help
//                  remove -z option help message
//  12-Jul-1989 SB  readEnvironmentVars() was not using environ variable but an
//                  old pointer (envPtr) to it. In the meantime environ was
//                  getting updated. Safer to use environ directly.
//  29-Jun-1989 SB  freeStructures() now deletes inlineFileList also
//  28-Jun-1989 SB  changed deletion of inline files to end of mainmain() instead of
//                  doMake() to avoid deletion when a child make quits.
//  19-Jun-1989 SB  modified .bas.obj to have ';' at end of cmd line
//  21-May-1989 SB  freeRules() gets another parameter to avoid bogus messages
//  18-May-1989 SB  change delScriptFiles() to do unlink instead of calling
//                  execLine. Thus, ^C handling is better now. No more hangs
//  15-May-1989 SB  Added /make support; inherit /nologo
//  13-May-1989 SB  Changed delScriptFiles(); added MAKEDIR; Added BASIC rules
//                  Changed chkPrecious()
//  01-May-1989 SB  Changed FILEINFO to void *; OS/2 Version 1.2 support
//  17-Apr-1989 SB  on -help spawn 'qh /u nmake' instead. rc = 3 signals error
//  14-Apr-1989 SB  no 'del inlinefile' cmd for -n. -z now gives 'goto NmakeExit'
//                  CC and AS allocated of the heap and not from Data Segment
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  27-Mar-1989 SB  Changed unlinkTmpFiles() to delScriptFiles()
//  10-Mar-1989 SB  Removed blank link from PWB.SHL output
//  09-Mar-1989 SB  changed param in call to findRule. fBuf is allocated on the
//                  heap in useDefaultMakefile()
//  24-Feb-1989 SB  Inherit MAKEFLAGS to Env for XMake Compatibility
//  22-Feb-1989 SB  Ignore '-' or '/' in parseCommandLine()
//  16-Feb-1989 SB  add delScriptFiles() to delete temp script files at the
//                  end of the make. Also called on ^c and ^break
//  15-Feb-1989 SB  Rewrote useDefaultMakefile(); MAKEFLAGS can contain all flags
//                  now
//  13-Feb-1989 SB  Rewrote filename() for OS/2 1.2 support, now returns BOOL.
//   3-Feb-1989 SB  Renamed freeUnusedRules() to freeRules(); moved prototype to
//                  proto.h
//   9-Jan-1989 SB  Improved /help;added -?
//   3-Jan-1989 SB  Changes for /help and /nologo
//   5-Dec-1988 SB  Made chkPrecious() CDECL as signal() expects it
//                  main has CDECL too; cleaned prototypes (added void)
//  30-Nov-1988 SB  Added for 'z' option in setFlags() and chkPrecious()
//  10-Nov-1988 SB  Removed '#ifndef IBM' as IBM ver has a separate tree
//  21-Oct-1988 SB  Added fInheritUserEnv to inherit macro definitions
//  22-Sep-1988 RB  Changed a lingering reference of /B to /A.
//  15-Sep-1988 RB  Move some def's out to GLOBALS.
//  17-Aug-1988 RB  Clean up.
//  15-Aug-1988 RB  /B ==> /A for XMAKE compatibility.
//  11-Jul-1988 rj  Removed OSMODE definition.
//                  Removed NMAKE & NMAKEFLAGS (sob!).
//   8-Jul-1988 rj  Added OSMODE definition.
//   7-Jul-1988 rj  #ifndef IBM'ed NMAKE & NMAKEFLAGS
//   6-Jul-1988 rj  Ditched shell, argVector, moved getComSpec to build.c.
//   5-Jul-1988 rj  Fixed (*pfSPAWN) declarations.
//  28-Jun-1988 rj  Added NMAKEFLAGS predefined macro.
//  24-Jun-1988 rj  Added NMAKE predefined macro.
//                  Added doError flag to unlinkTmpFiles call.
//  23-Jun-1988 rj  Fixed okToDelete to delete less often.
//  22-Jun-1988 rj  Make chkPrecious use error messages
//  25-May-1988 rb  Make InitLeadByte() smarter.
//  20-May-1988 rb  Change built-in macro names.
//  18-May-1988 rb  Remove comment about built-in rules and macros.
//  17-May-1988 rb  Load built-in rules in right place.
//  16-May-1988 rb  Conditionalize recursive make feature.
//   8-May-1988 rb  Better initialization of system shell.

#include "precomp.h"
#pragma hdrstop

#include "verstamp.h"

void      readEnvironmentVars(void);
void      readMakeFiles(void);
void      useDefaultMakefile(void);
BOOL      filename(const char*, char**);
void  __cdecl  chkPrecious(int sig);
UCHAR     isPrecious(char*);
      void      removeTrailChars(char *);

void usage (void);

char *makeStr;                         // this make invocation name

UCHAR  okToDelete;                     // do not del unless exec'ing cmd

#ifdef _M_IX86
UCHAR  fRunningUnderChicago;

extern UCHAR FIsChicago(void);
#endif

const char * const builtInTarg[] = {
    ".SUFFIXES",
    ".c.obj",
    ".c.exe",
    ".cpp.obj",
    ".cpp.exe",
    ".cxx.obj",
    ".cxx.exe",
#if defined(_M_IX86) || defined(_M_MRX000)
    ".asm.obj",
    ".asm.exe",
#endif
#if !defined(_M_IX86)
    ".s.obj",
#endif
    ".bas.obj",
    ".cbl.obj",
    ".cbl.exe",
    ".f.obj",
    ".f.exe",
    ".f90.obj",
    ".f90.exe",
    ".for.obj",
    ".for.exe",
    ".pas.obj",
    ".pas.exe",
    ".rc.res",
    NULL
};

const char * const bltInCmd0[] = {
    ":",
    ".exe",
    ".obj",
#if defined(_M_IX86) || defined(_M_MRX000)
    ".asm",
#endif
#if !defined(_M_IX86)
    ".s",
#endif
    ".c",
    ".cpp",
    ".cxx",
    ".bas",
    ".cbl",
    ".f",
    ".f90",
    ".for",
    ".pas",
    ".res",
    ".rc",
    NULL
};

// Single colon (":") specifies ordinary rules
// Double colon ("::") specifies batch rules
const char * const bltInCmd1[]  = {":", "$(CC) $(CFLAGS) /c $<", NULL};
const char * const bltInCmd2[]  = {":", "$(CC) $(CFLAGS) $<", NULL};
const char * const bltInCmd3[]  = {":", "$(CPP) $(CPPFLAGS) /c $<", NULL};
const char * const bltInCmd4[]  = {":", "$(CPP) $(CPPFLAGS) $<", NULL};
const char * const bltInCmd5[]  = {":", "$(CXX) $(CXXFLAGS) /c $<", NULL};
const char * const bltInCmd6[]  = {":", "$(CXX) $(CXXFLAGS) $<", NULL};
#if defined(_M_IX86) || defined(_M_MRX000)
const char * const bltInCmd7[]  = {":", "$(AS) $(AFLAGS) /c $*.asm", NULL};
const char * const bltInCmd8[]  = {":", "$(AS) $(AFLAGS) $*.asm", NULL};
#endif
#if !defined(_M_IX86)
#if defined(_M_MRX000)
const char * const bltInCmd9[]  = {":", "$(AS) $(AFLAGS) /c $*.s", NULL};
#else
const char * const bltInCmd9[]  = {":", "$(AS) $(AFLAGS) $*.s", NULL};
#endif
#endif
const char * const bltInCmd10[] = {":", "$(BC) $(BFLAGS) $*.bas;", NULL};
const char * const bltInCmd11[] = {":", "$(COBOL) $(COBFLAGS) $*.cbl;", NULL};
const char * const bltInCmd12[] = {":", "$(COBOL) $(COBFLAGS) $*.cbl, $*.exe;", NULL};
const char * const bltInCmd13[] = {":", "$(FOR) /c $(FFLAGS) $*.f", NULL};
const char * const bltInCmd14[] = {":", "$(FOR) $(FFLAGS) $*.f", NULL};
const char * const bltInCmd15[] = {":", "$(FOR) /c $(FFLAGS) $*.f90", NULL};
const char * const bltInCmd16[] = {":", "$(FOR) $(FFLAGS) $*.f90", NULL};
const char * const bltInCmd17[] = {":", "$(FOR) /c $(FFLAGS) $*.for", NULL};
const char * const bltInCmd18[] = {":", "$(FOR) $(FFLAGS) $*.for", NULL};
const char * const bltInCmd19[] = {":", "$(PASCAL) /c $(PFLAGS) $*.pas", NULL};
const char * const bltInCmd20[] = {":", "$(PASCAL) $(PFLAGS) $*.pas", NULL};
const char * const bltInCmd21[] = {":", "$(RC) $(RFLAGS) /r $*", NULL};

const char * const * const builtInCom[] = {
    bltInCmd0,
    bltInCmd1,
    bltInCmd2,
    bltInCmd3,
    bltInCmd4,
    bltInCmd5,
    bltInCmd6,
#if defined(_M_IX86) || defined(_M_MRX000)
    bltInCmd7,
    bltInCmd8,
#endif
#if !defined(_M_IX86)
    bltInCmd9,
#endif
    bltInCmd10,
    bltInCmd11,
    bltInCmd12,
    bltInCmd13,
    bltInCmd14,
    bltInCmd15,
    bltInCmd16,
    bltInCmd17,
    bltInCmd18,
    bltInCmd19,
    bltInCmd20,
    bltInCmd21,
    NULL
};

//  main
//
// actions:  saves the initial global variables in a
//           block. calls doMake() and then delTempScriptFiles()

void __cdecl
main(
    unsigned argc,
    char *argv[],
    char *envp[]
    )
{
    int status;                         // returned by doMake

#ifdef _M_IX86
    fRunningUnderChicago = FIsChicago();
#endif

    initCharmap();

    initMacroTable(macroTable);

#ifdef DEBUG_COMMANDLINE
    {
        int iArg = argc;
        char **chchArg = argv;
        for (; iArg--; chchArg++) {
            printf("'%s' ", *chchArg);
        }
        printf("\n");
    }
#endif

    if (!makeStr) {
        // extract file name
        if (!filename(_pgmptr, &makeStr)) {
            makeStr = "NMAKE";
        }
    }

    // set up handler for .PRECIOUS  the handler tries to remove the
    // current target when control-C'd, unless it is "precious"

    signal(SIGINT, chkPrecious);
    signal(SIGTERM, chkPrecious);

    status = doMake(argc, argv, NULL);

    delScriptFiles();

    if (!fSlashKStatus) {
        status = 1;                     // error when slashK specified
    }

#if !defined(NDEBUG)
    printStats();
#endif

    exit(status);
}

extern void endNameList(void);
extern void addItemToList(void);
extern void assignDependents(void);
extern void assignBuildCommands(void);

//  loadBuiltInRules() -- Loads built in Rules to the NMAKE Tables
//
// Modifies:
//  fInheritUserEnv  --    is set to TRUE to inherit CC, AS
//
// Notes:
//  Does this by calls to defineMacro(), which calls putMacro(). Since,
//  fInheritUserEnv is set to TRUE, putMacro() will add to the Environment.

void
loadBuiltInRules(
    void
    )
{
    const char *tempTarg;
    const char * const *tempCom;
    unsigned index;
    char *macroName, *macroValue;
    extern char *makestr;

    // We dynamically allocate CC and AS because they need to be freed in a
    // recursive MAKE

    macroName = makeString("CC");
    macroValue = makeString("cl");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("CXX");
    macroValue = makeString("cl");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("CPP");
    macroValue = makeString("cl");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("AS");
#if   defined(_M_ALPHA)
    macroValue = makeString("asaxp");
#else
    // UNDONE: What is appropriate for IA64?

    macroValue = makeString("ml");
#endif
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("BC");
    macroValue = makeString("bc");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("COBOL");
    macroValue = makeString("cobol");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("FOR");
    macroValue = makeString("fl32");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("PASCAL");
    macroValue = makeString("pl");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("RC");
    macroValue = makeString("rc");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("_NMAKE_VER");
    macroValue = makeString(VER_PRODUCTVERSION_STR);
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("MAKE");
    macroValue = makeString(makeStr);
    // From environment so it won't get exported ; user can reset MAKE

    defineMacro(macroName, macroValue, M_ENVIRONMENT_DEF|M_WARN_IF_RESET);

    for (index = 0; tempTarg = builtInTarg[index]; index++) {
        name = makeString(tempTarg);
        tempCom = builtInCom[index];
        // tempCom should now contain a single or double colon
        assert (tempCom && *tempCom && **tempCom == ':');
        _tcscpy(buf, *tempCom);
        endNameList();
        for (tempCom++; *tempCom; tempCom++) {
            _tcscpy(buf, *tempCom);
            addItemToList();
        }
        if (index == 0) {
            assignDependents();
        }
        assignBuildCommands();
    }
}


//  doMake()
//
// actions:  prints a version message
//           reads the environment variable MAKEFLAGS
//           if MAKEFLAGS defined
//           defines MAKEFLAGS to have that value w/in nmake
//           sets a flag for each option if MAKEFLAGS defined
//           else defines the macro MAKEFLAGS to be NULL
//           parses commandline (adding option letters to MAKEFLAGS)
//           reads all environment variables
//           reads tools.ini
//           reads makefile(s) (if -e flag set, new definitions in
//           makefile won't override environment variable defs)
//           prints information if -p flag
//           processes makefile(s)
//           prints information if -d flag and not -p flag (using both
//           is overkill)
//
// In effect, the order for making assignments is (1 = least binding,
//   4 = most binding):
//
//   1)  TOOLS.INI
//   2)  environment (if -e flag, makefile)
//   3)  makefile    (if -e flag, environment)
//   4)  command line
//
// The user can put anything he wants in the MAKEFLAGS environment variable.
// I don't check it for illegal flag values, because there are many xmake
// flags that we don't support.  He shouldn't have to change his MAKEFLAGS
// to use nmake. Xmake always puts 'b' in MAKEFLAGS for "backward com-
// patibility" (or "botch") for the original Murray Hill version of make.
// It doesn't make sense to use -f in MAKEFLAGS, thus it is disallowed.
// It also makes little sense to let the default flags be -r, -p, or -d,
// so they aren't allowed in MAKEFLAGS, either.
//
// Even though DOS only uses uppercase in environment variables, this
// program may be ported to xenix in the future, thus we allow for the
// possibility that MAKEFLAGS and commandline options will be in upper
// and/or lower case.
//
// modifies:   init    global flag set if tools.ini is being parsed...

int
doMake(
    unsigned argc,
    char *argv[],
    char *parentBlkPtr          // state of parent, restored prior to return
    )
{
    int status = 0;
    char *p;
    extern char *makeStr;               // the initial make invok name
    char *makeDir, *curDir;

#ifdef DEBUG_ALL
    printf ("DEBUG: In doMake\n");
#endif

    assert(parentBlkPtr == NULL);

    // Load built-ins here rather than in main().  Otherwise in a recursive
    // make, doMake() will initialize rules to some value which has been
    // freed by sortRules(). [RB]
    // UNDONE:    why is sortRules() not setting rules to NULL?  [RB]

    inlineFileList = (STRINGLIST *)NULL;
    makeDir = makeString("MAKEDIR");
    curDir  = getCurDir();
    // Use M_LITERAL flag to prevent nmake from trying to
    // interpret $ in path as an embedded macro. [DS 14983]
    defineMacro(makeDir, curDir, M_LITERAL);

    // TEMPFIX: We are truncating MAKEFLAGS environment variable to its limit
    // to avoid GP Faults
    if (p = getenv("MAKEFLAGS")) {      // but not MAKEFLAGS
        _tcsncpy(makeflags+10, p, _tcslen(makeflags + 10));
    }

    // fInheritUserEnv is set to TRUE so that the changes made get inherited

    fInheritUserEnv = TRUE;

    // 07-05-92  BryanT    Simply adding global strings to the macro array
    //                     causes problems later when you go to free them
    //                     from a recursive $(MAKE).  Both the macro name
    //                     and the macro's value must be created with
    //                     makeString.

    defineMacro(makeString("MAKEFLAGS"), makeString(makeflags+10), M_NON_RESETTABLE|M_ENVIRONMENT_DEF);

    for (;p && *p; p++) {               // set flags in MAKEFLAGS
        setFlags(*p, TRUE);             // TRUE says turn bits ON
    }

    parseCommandLine(--argc, ++argv);   // skip over program name

#ifdef DEBUG_ALL
    printf ("DEBUG: Command Line parsed\n");
#endif

    if (!bannerDisplayed) {
        displayBanner();                // version number, etc.
    }

    if (OFF(gFlags, F1_IGNORE_EXTERN_RULES)) {  // read tools.ini
#ifdef DEBUG_ALL
        printf ("DEBUG: Read Tools.ini\n");
#endif
        loadBuiltInRules();
#ifdef DEBUG_ALL
        printf ("DEBUG: loadBuiltInRules\n");
#endif
        fName = "tools.ini";

        if (tagOpen("INIT", fName, makeStr)) {
            ++line;
            init = TRUE;                // tools.ini being parsed

#ifdef DEBUG_ALL
            printf ("DEBUG: Start Parse\n");
#endif
            parse();

#ifdef DEBUG_ALL
            printf ("DEBUG: Parsed\n");
#endif
            if (fclose(file) == EOF)
                makeError(0, ERROR_CLOSING_FILE, fName);
        }
    }

#ifdef DEBUG_ALL
    printf ("after tagopen\n");
#endif

    // For XMake Compatibility MAKEFLAGS should always be inherited to the Env
    // Put copy of makeflags so that the environment can be freed on return
    // from a recursive make

    if (PutEnv(makeString(makeflags)) == -1) {
        makeError(0, OUT_OF_ENV_SPACE);
    }

#ifdef DEBUG_ALL
    printf ("after putenv\n");
#endif

    if (!makeFiles) {
        useDefaultMakefile();           // if no -f makefile given
    }

    readEnvironmentVars();
    readMakeFiles();                    // read description files

#ifdef DEBUG_ALL
    printf ("DEBUG: Read makefile\n");
#endif

    currentLine = 0;                    // reset line after done
    sortRules();                        // reading files (for error messages)

    if (ON(gFlags, F1_PRINT_INFORMATION)) {
        showMacros();
        showRules();
        showTargets();
    }

    // free buffer used for conditional processing - not required now
    if (lbufPtr) {
        FREE(lbufPtr);
    }

    status = processTree();

    // We ignore retval from chdir because we cannot do anything if it fails
    // This accomplishes a 'cd $(MAKEDIR)'.
    _chdir(curDir);
    return(status);
}


//  filename -- filename part of a name
//
// Scope:   Local
//
// Purpose:
//  A complete file name is of the form  <drive:><path><filename><.ext>. This
//  function returns the filename part of the name.
//
// Input:   src -- The complete file name
//          dst -- filename part of the complete file name
//
// Output:  Returns TRUE if src has a filename part & FALSE otherwise
//
// Assumes: That the file name could have either '/' or '\' as path separator.
//
// Notes:
//  Allocates memory for filename part. Function was rewritten to support OS/2
//  Ver 1.2 filenames.
//
//  HV: One concern when I rewrite filename() to use _splitpath(): I declared
//  szFilename with size _MAX_FNAME, which could blow up the stack if _MAX_FNAME
//  is too large.

BOOL
filename(
    const char *src,
    char **dst
    )
{
    char szFilename[_MAX_FNAME];        // The filename part

    // Split the full pathname to components
    _splitpath(src, NULL, NULL, szFilename, NULL);

    // Allocate & copy the filename part to the return string
    *dst = makeString(szFilename);

    // Finished
    return (BOOL) _tcslen(*dst);
}


// readMakeFiles()
//
// actions:  walks through the list calling parse on each makefile
//           resets the line number before parsing each file
//           removes name of parsed file from list
//           frees removed element's storage space
//
// modifies: file      global file pointer (FILE*)
//           fName     global pointer to file name (char*)
//           line      global line number used and updated by the lexer
//           init      global flag reset for parsing makefiles
//                      ( files other than tools.ini )
//           makeFiles in main() by modifying contents of local pointer (list)
//
// We keep from fragmenting memory by not allocating and then freeing space
// for the (probably few) names in the files and targets lists.  Instead
// we use the space already allocated for the argv[] vars, and use the space
// we alloc for the commandfile vars.  The commandfile vars that could be
// freed here, but they aren't because we can't tell them from the argv[]
// vars.  They will be freed at the end of the program.

void
readMakeFiles(
    void
    )
{
    STRINGLIST *q;

    for (q = makeFiles; q ; q = q->next) {          // for each name in list
        if ((q->text)[0] == '-' && !(q->text)[1]) {
            fName = makeString("STDIN");
            file = stdin;
        } else {
            fName = makeString(q->text);
            if (!(file = FILEOPEN(fName, "rt")))    // open to read, text mode
                makeError(0, CANT_OPEN_FILE, fName);
            if (!IsValidMakefile(file))
                makeError(0, CANT_SUPPORT_UNICODE, fName);
        }
        line = 0;
        init = FALSE;                   // not parsing tools.ini
        parse();
        if (file != stdin && fclose(file) == EOF)
            makeError(0, ERROR_CLOSING_FILE, fName);
    }

    // free the list of makefiles
    freeStringList(makeFiles);
}


//  readEnvironmentVars - Read in environment variables into Macro table
//
// Scope:   Local.
//
// Purpose:
//  Reads environment variables into the NMAKE macro Table. It walks through envp
//  using environ making entries in NMAKE's hash table of macros for each string
//  in the table.
//
// Assumes: That the env contains strings of the form "VAR=value" i.e. '=' present.
//
// Modifies Globals:    fInheritUserEnv - set to false.
//
// Uses Globals:
//  environ - Null terminated table of pointers to environment variable
//         definitions of the form "name=value" (Std C Runtime variable)
//
// Notes:
//  If the user specifies "set name=value" as a build command for a target being
//  built, the change in the environment will not be reflected in nmake's set of
//  defined variables in the macro table.
//
// Undone/Incomplete:
//  1> Probably do not need envPtr global in NMAKE. (to be removed)
//  2> Probably don't need fInheritUserEnv (see PutMacro)

void
readEnvironmentVars(
    void
    )
{
    char *macro, *value;
    char *t;
    char **envPtr;

    envPtr = environ;
    for (;*envPtr; ++envPtr) {
        if (t = _tcschr(*envPtr, '=')) {   // should always be TRUE
            if (!_tcsnicmp(*envPtr, "MAKEFLAGS", 8))
                continue;
            *t = '\0';
            // Don't add empty names.
            if (**envPtr == '\0')
                continue;
            // ALLOC: here we make copies of the macro name and value to define
            macro = _tcsupr(makeString(*envPtr));

            value = makeString(t+1);
            *t = '=';
            fInheritUserEnv = (BOOL)FALSE;
            if (!defineMacro(macro, value, M_ENVIRONMENT_DEF)) {
                // ALLOC: here we free the copies if they were not added.
                FREE(macro);
                FREE(value);
            }
        }
    }
}


//  parseCommandLine()
//
// arguments:  argc    count of arguments in argv vector
//             argv    table of pointers to commandline arguments
//
// actions:    reads a command file if necessary
//             sets switches
//             defines macros
//             makes a list of makefiles to read
//             makes a list of targets to build
//
// modifies:   makeFiles   in main() by modifying contents of parameter
//                          pointer (list) to STRINGLIST pointer
//                          (makeFiles)
//             makeTargets     in main() by modifying contents of param
//                              pointer (targets) to STRINGLIST pointer
//             fInheritUserEnv set to TRUE so that user defined changes in the
//                              environment variables get inherited by the Env
//
// nmake doesn't make new copies of command line macro values or environment
// variables, but instead uses pointers to the space already allocated.
// This can cause problems if the envp, the environment pointer, is accessed
// elsewhere in the program (because the vector's strings will contain '\0'
// where they used to contain '=').  I don't foresee any need for envp[] to
// be used elsewhere.  Even if we did need to use the environment, we could
// access the environ variable or use getenv().
//
// I don't care what the current DOS "switch" character is -- I always
// let the user give either.

void
parseCommandLine(
    unsigned argc,
    char *argv[]
    )
{
    STRINGLIST *p;
    char *s;
    char *t;
    FILE *out;
    BOOL fUsage = FALSE;

    for (; argc; --argc, ++argv) {
        if (**argv == '@') {           // cmdfile
            readCommandFile((char *) *argv+1);
        } else if (**argv == '-'|| **argv == '/') {   // switch
            s = *argv + 1;
            if (!_tcsicmp(s, "help")) {
                fUsage = TRUE;
                break;
            }

            // if '-' and '/' specified then ignores it
            for (; *s; ++s) {
                if (!_tcsicmp(s, "nologo")) {
                    setFlags(s[2], TRUE);
                    break;
                } else if (*s == '?') {
                    fUsage = TRUE;
                    break;
                } else if (*s == 'f' || *s == 'F') {
                    char *mkfl = s+1;

                    //if '/ffoo' then use 'foo'; else use next argument
                    if (!*mkfl && (!--argc || !*++argv || !*(mkfl = *argv))) {
                        makeError(0, CMDLINE_F_NO_FILENAME);
                    }
                    p = makeNewStrListElement();
                    p->text = makeString(mkfl);
                    appendItem(&makeFiles, p);
                    break;
                } else if (*s == 'x' || *s == 'X') {
                    char *errfl = s+1;

                    //if '/xfoo' then use 'foo'; else use next argument
                    if (!*errfl && (!--argc || !*++argv || !*(errfl = *argv))) {
                        makeError(0, CMDLINE_X_NO_FILENAME);
                    }

                    if (*errfl == '-' && !errfl[1]) {
                        _dup2(_fileno(stdout), _fileno(stderr));
                    } else {
                        if ((out = fopen(errfl, "wt")) == NULL) {
                            makeError(0, CANT_WRITE_FILE, errfl);
                        } else {
                            _dup2(_fileno(out), _fileno(stderr));
                            fclose(out);
                        }
                    }
                    break;
                } else {
                    setFlags(*s, TRUE);
                }
            }
        } else {
            if (s = _tcschr(*argv, '=')) {         // macro
                if (s == *argv) {
                    makeError(0, CMDLINE_NO_MACRONAME);    // User has specified "=value"
                }
                *s = '\0';
                for (t = s++ - 1; WHITESPACE(*t); --t)
                    ;
                *(t+1) = '\0';
                fInheritUserEnv = (BOOL)TRUE;
                defineMacro(makeString(*argv+_tcsspn(*argv, " \t")),
                makeString( s+_tcsspn(s," \t")),
                M_NON_RESETTABLE);
            } else {
                removeTrailChars(*argv);
                if (**argv) {
                    p = makeNewStrListElement();    // target
                    // use quotes around name if it contains spaces [vs98 1935]
                    if (_tcschr(*argv, ' ')) {
                        p->text = makeQuotedString(*argv);
                    }
                    else {
                        p->text = makeString(*argv);    // needs to be on heap [rm]
                    }
                    appendItem(&makeTargets, p);
                }
            }
            *argv = NULL;               // so we won't try to free this space
        }                               //  if processing command file stuff
    }

    if (fUsage) {
        usage();
        exit(0);
    }
}


//  useDefaultMakefile -- tries to use the default makefile
//
// Scope:
//  Local
//
// Purpose:
//  When no makefile has been specified by the user, set up the default makefile
//  to be used.
//
// Input:
// Output:
// Errors/Warnings:
//  CMDLINE_NO_MAKEFILE -- 'makefile' does not exist & no target specified
//
// Assumes:
// Modifies Globals:
//  makeTargets -- if 'makefile' does not exist then the first target is removed
//                   from this list,
//  makeFiles -- if 'makefile' does not exist then the first target is attached
//                   to this list.
//
// Uses Globals:
//  makeTargets -- the list of targets to be made
//
// Notes:
//  Given a commandline not containing a '-f makefile', this is how NMAKE
//  behaves --
//      If ['makefile' exists] then use it as the makefile,
//      if [(the first target exists and has no extension) or
//       (if it exists and has an extension for which no inference rule
//        exists)]
//      then use it as the makefile.

void
useDefaultMakefile(
    void
    )
{
    STRINGLIST *p;
    char *s, *ext;
    char nameBuf[MAXNAME];
    struct _finddata_t finddata;

    if (!_access("makefile", READ)) {
        // if 'makefile' exists then use it
        p = makeNewStrListElement();
        p->text = makeString("makefile");
        makeFiles = p;
    } else if (makeTargets) {
        //check first target
        s = makeTargets->text;
        if (_access(s, READ) ||         // 1st target does not exist
              ((ext = _tcsrchr(s, '.'))
            && findRule(nameBuf, s, ext, &finddata))) {  //has no ext or inf rule
            return;
        }

        p = makeTargets;
        makeTargets = makeTargets->next;    // one less target
        makeFiles = p;                      // 1st target is the makefile
    } else if (OFF(gFlags, F1_PRINT_INFORMATION)) {
        //if -p and no makefile, simply give information ...
        makeError(0, CMDLINE_NO_MAKEFILE);  //  no 'makefile' or target
    }
}


//  setFlags()
//
// arguments:  line    current line number in makefile (or 0
//                      if still parsing commandline)
//             c       letter presumed to be a commandline option
//             value   TRUE if flag should be turned on, FALSE for off
//
// actions:    checks to see if c is a valid option-letter
//             if no, error, halt
//             if value is TRUE, sets corresponding flag bit
//               and adds flag letter to MAKEFLAGS macro def
//             else if flag is resettable, clears corresponding bit
//               and removes letter from MAKEFLAGS macro def
//
// modifies:   flags       external resettable-flags
//             gFlags      external non-resettable flags
//             (MAKEFLAGS  nmake internal macrodefs)
//
// Only the flags w/in the "flags" variable can be turned off.  Once the
// bits in "gFlags" are set, they remain unchanged.  The bits in "flags"
// are modified via the !CMDSWITCHES directive.

void
setFlags(
    char c,
    BOOL value
    )
{
    // Use lexer's line count.  If this gets called w/in mkfil, might be from
    // directive, which never makes it to the parser, so parser's line count
    // might be out of sync.

    char d = c;
    UCHAR arg;
    UCHAR *f;
    char *s;
    extern char *makeStr;
    extern MACRODEF * pMacros;
    extern STRINGLIST * pValues;

    f = &flags;
    switch(c = (char) _totupper(c)) {
        case 'A':
            arg = F2_FORCE_BUILD;
            break;

        case 'B':
            fRebuildOnTie = TRUE;
            return;

        case 'C':
            arg = F1_CRYPTIC_OUTPUT;
            f = &gFlags;
            bannerDisplayed = TRUE;
            break;

        case 'D':
            arg = F2_DISPLAY_FILE_DATES;
            break;

        case 'E':
            arg = F1_USE_ENVIRON_VARS;
            f = &gFlags;
            break;

        case 'I':
            arg = F2_IGNORE_EXIT_CODES;
            break;

        case 'K':
            fOptionK = TRUE;
            return;

        case 'L':
            arg = F1_NO_LOGO;
            f = &gFlags;
            bannerDisplayed = TRUE;
            break;

        case 'N':
            arg = F2_NO_EXECUTE;
            break;

        case 'O':
            fDescRebuildOrder = TRUE;
            return;

        case 'P':
            arg = F1_PRINT_INFORMATION;
            f = &gFlags;
            break;

        case 'Q':
            arg = F1_QUESTION_STATUS;
            f = &gFlags;
            break;

        case 'R':
            arg = F1_IGNORE_EXTERN_RULES;
            f = &gFlags;
            break;

        case 'S':
            arg = F2_NO_ECHO;
            break;

        case 'T':
            arg = F1_TOUCH_TARGETS;
            f = &gFlags;
            break;

        case 'U':
            arg = F2_DUMP_INLINE;
            break;

        case 'Y':
            arg = F1_NO_BATCH;
            f = &gFlags;
            break;

        case ' ':
            return;                     // recursive make problem

        default:
            makeError(0, CMDLINE_BAD_OPTION, d);
    }

    if (!pMacros) {
        pMacros = findMacro("MAKEFLAGS");
        pValues = pMacros->values;
    }

    if (value) {
        SET(*f, arg);                   // set bit in flags variable
        if (c == 'Q') SET(*f, F1_CRYPTIC_OUTPUT);
            if (!_tcschr(pValues->text, c)) {          // don't want to dup any chars
                if (s = _tcschr(pValues->text, ' '))   // append ch to MAKEFLAGS
                    *s = c;
            if (PutEnv(makeString(makeflags)) == -1)    // pValues->text pts into makeflags
                makeError(line, OUT_OF_ENV_SPACE);
        }
    } else if (f == &flags
        ) {
        // make sure pointer is valid (we can't change gFlags, except if /Z
        CLEAR(*f, arg);
        if (s = _tcschr(pValues->text, c)) // adjust MAKEFLAGS
            do {
                *s = *(s+1);                //  move remaining chars over
            } while (*(++s));
        if (PutEnv(makeString(makeflags)) == -1)
            makeError(line, OUT_OF_ENV_SPACE);
    }
}

//  chkPrecious -- handle ^c or ^Break
//
// Actions:    unlink all non-precious files and unrequired scriptFiles
//             quit with error message (makeError unlinks temp. files)

void __cdecl
chkPrecious(
    int sig
    )
{
    // disable ctrl-C during handler
    signal(SIGINT, SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    if (okToDelete &&
        OFF(flags, F2_NO_EXECUTE) &&
        OFF(gFlags, F1_TOUCH_TARGETS) &&
        dollarAt &&
        _access(dollarAt, 0x00) &&      // existence check
        !isPrecious(dollarAt)
       ) {
        if (_unlink(dollarAt) == 0)
            makeError(line, REMOVED_TARGET, dollarAt);
    }
    makeError(0, USER_INTERRUPT);
    delScriptFiles();
}

UCHAR
isPrecious(
    char *p
    )
{
    STRINGLIST *temp;

    for (temp = dotPreciousList; temp; temp = temp->next)
        if (!_tcsicmp(temp->text, p))
            return(1);
    return(0);
}

//  delScriptFiles -- deletes script files
//
// Scope:   Global
//
// Purpose:
//  Since script files may be reused in the makefile the script files which have
//  NOKEEP action specified are deleted at the end of the make.
//
// Uses Globals:    delList -- the list of script files to be deleted
//
// Notes:
//  We ignore the exit code as a result of a delete because the system will
//  inform the user that a delete failed.

void
delScriptFiles(
    void
    )
{
    STRINGLIST *del;

    _fcloseall();

    for (del = delList; del;del = del->next) {
        _unlink(del->text);
        // UNDONE: Investigate whether next is really needed
        if (ON(flags, F2_NO_EXECUTE)) {
            printf("\tdel %s\n", del->text);
            fflush(stdout);
        }
    }
}


//  removeTrailChars - removes trailing blanks and dots
//
// Scope:   Local.
//
// Purpose:
//  OS/2 1.2 filenames dictate removal of trailing blanks and periods. This
//  function removes them from filenames provided to it.
//
// Input:   szFile - name of file
//
// Notes:
//  This function handles Quoted filenames as well. It maintains the quotes if
//  they were present. This is basically for OS/2 1.2 filename support.

void
removeTrailChars(
    char *szFile
    )
{
    char *t = szFile + _tcslen(szFile) - 1;
    BOOL fQuoted = FALSE;

    if (*szFile == '"' && *t == '"') {
        // Quoted so set flag
        t--;
        fQuoted = TRUE;
    }

    // Scan backwards for trailing characters
    while (t > szFile && (*t == ' ' || *t == '.'))
        t--;

    // t points to last non-trailing character.  It it was quited, add quotes
    // to the end
    if (fQuoted)
        *++t = '"';

    t[1] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\macro.cpp ===
//  Macro.C - contains routines that have to do with macros
//
//  Copyright (c) 1988-1991, Microsoft Corporation. All Rights Reserved.
//
// Purpose:
//  Contains routines that have to do with macros
//
// Revision History:
//  16-May-1991 SB  Created from routines that existed elsewhere

#include "precomp.h"
#pragma hdrstop

static STRINGLIST **lastMacroChain = NULL;

// findMacro - look up a string in a hash table
//
//  Look up a macro name in a hash table and return the entry
//  or NULL.
//  If a macro and undefined, return NULL.

MACRODEF * findMacro(char *str)
{
    unsigned n;
    char *L_string = str;
    STRINGLIST *found;

    if (*L_string) {
        for (n = 0; *L_string; n += *L_string++);   	//Hash
        n %= MAXMACRO;
#if defined(STATISTICS)
        CntfindMacro++;
#endif
        lastMacroChain = (STRINGLIST **)&macroTable[n];
        for (found = *lastMacroChain; found; found = found->next) {
#if defined(STATISTICS)
            CntmacroChains++;
#endif
            if (!_tcscmp(found->text, str)) {
                return((((MACRODEF *)found)->flags & M_UNDEFINED) ? NULL : (MACRODEF *)found);
            }
        }
    } else {
        // set lastMacroChain, even for an empty name
        lastMacroChain = (STRINGLIST **)&macroTable[0];
    }
    return(NULL);
}

// insertMacro
//
// Macro insertion requires that we JUST did a findMacro, which action set lastMacroChain.

void insertMacro(STRINGLIST * p)
{
#ifdef STATISTICS
    CntinsertMacro++;
#endif
    assert(lastMacroChain != NULL);
    prependItem(lastMacroChain, p);
    lastMacroChain = NULL;
}

// 16/May/92  Bryant    Init the macro table to a known state before
//                      continuing.

void initMacroTable(MACRODEF *table[])
{
    unsigned num;
    for (num = 0; num < MAXMACRO; num++) {
        table[num] = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\nmtime.h ===
//  nmtime.h - defines DOS packed date and time types
//
//  Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//    This file defines the DOS packed date and time types.
//
// Revision History:
//  19-May-1993 HV  Changed _dtoxtime() to _dostotime_t() so that we can
//                  use the standard llibce.lib instead of the private
//                  llibcer.lib.
//  04-Dec-1989 SB  added proper fn proto for _dtoxtime() (c6 -W3 reqmemt)
//  05-Dec-1988 SB  added CDECL for _dtoxtime()
//  ??-???-???? ??  Taken from dostypes.h


#define MASK4   0xf     // 4 bit mask
#define MASK5   0x1f    // 5 bit mask
#define MASK6   0x3f    // 6 bit mask
#define MASK7   0x7f    // 7 bit mask

#define DAYLOC      0   // day value starts in bit 0
#define MONTHLOC    5   // month value starts in bit 5
#define YEARLOC     9   // year value starts in bit 9

#define SECLOC      0   // seconds value starts in bit 0
#define MINLOC      5   // minutes value starts in bit 5
#define HOURLOC     11  // hours value starts in bit 11

#define DOS_DAY(dword)      (((dword) >> DAYLOC) & MASK5)
#define DOS_MONTH(dword)    (((dword) >> MONTHLOC) & MASK4)
#define DOS_YEAR(dword)     (((dword) >> YEARLOC) & MASK7)

#define DOS_HOUR(tword) (((tword) >> HOURLOC) & MASK5)
#define DOS_MIN(tword)  (((tword) >> MINLOC) & MASK6)
#define DOS_SEC(tword)  (((tword) >> SECLOC) & MASK5)

extern time_t CDECL _dostotime_t(int, int, int, int, int, int);

#define XTIME(d,t)  _dostotime_t(DOS_YEAR(d),                      \
            DOS_MONTH(d),                          \
            DOS_DAY(d),                        \
            DOS_HOUR(t),                           \
            DOS_MIN(t),                        \
            DOS_SEC(t)*2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\parser.cpp ===
//  PARSER.C -- parsing routines
//
//  Copyright (c) 1988-1989, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains the NMAKE grammar parser. It parses input and uses the
//  getToken() routine to get the next token.
//
// Revision History:
//   05-Apr-1989 SB made all funcs NEAR; Reqd to make all function calls NEAR
//   17-Aug-1988 RB Clean up.

#include "precomp.h"
#pragma hdrstop

#include "table.h"

// macros that deal w/ the productions stack and the actions function table

#define topStack()  (stack[top])
#define popStack()  (stack[top--])
#define pushStack(A)    (stack[++top] = A)
#define doAction(A) (*(actions[A & LOW_NIBBLE]))()



//  parse()     table-driven parser for makefile grammar
//
// arguments:       init    global boolean value -- TRUE if tools.ini is the
//              file being parsed
//
// actions:     initializes the stack (by pushing the empty-stack symbol
//      and the start symbol)
//      keeps track of current line (because the lexer may have
//      read '\n' as a delimiter, and will thus be one line
//      ahead of the parser)
//      while the stack is not empty
//      if the top symbol on the stack is an action
//          do the action, popping the stack
//      if the symbol on top of the stack now is a token
//          if it's not the token we're expecting
//          syntax error, halt
//          else
//          pop token off the stack
//          if the top symbol on the stack is an action
//              do the action, popping the stack
//          reset curent line to lexer's current line
//          get another token (use the lookahead token
//              if it exists, and if it had caused the
//              lexer's line count to be incremented,
//              decrement our local count because we're
//              still parsing the preceding line)
//      else the symbol on top of the stack is a production
//          find next production to do in production table
//          (based on current input token and current
//          production on stack)
//          if the table entry is an error condition
//          print appropriate error message, halt
//          pop current production off stack
//          if the "next production" can be one of two
//          things, decide which one to use by peeking
//          at the next input token and looking in the
//          "useAlternate" decision table (using the last
//          production and next input token as indexes)
//          if the appropriate table entry is YES,
//              use the next larger production from the one
//              we found in the production table
//          push each symbol in the production on the stack
//      loop
//
// modifies:        stack   production stack, static to this module
//      top     index of current symbol at top of stack
//
// Use extreme care in modifying this code or any of the tables associated
// with it.  The methods used to build the tables are described in detail
// in grammar.h and table.h.  This parser is based on the predictive parser
// described on pages 186-191 of Aho & Ullman "Principles of Compiler Design."
// I have modified it to use an extra symbol of lookahead to deal w/ an
// ambiguous grammar and have added code to perform appropriate actions as
// it parses the productions.

void
parse()
{
    UCHAR stackTop, token, nextToken = 0;
    register unsigned n, i;

    firstToken = TRUE;                      // global var
    pushStack(ACCEPT);                      // init stack
    pushStack(START);
    currentLine = line;
    token = getToken(MAXBUF,START);         // get first token
    while ((stackTop = topStack()) != ACCEPT) {
        if (ON(stackTop,ACTION_MASK)) {
            doAction(popStack());
        } else if (ON(stackTop,TOKEN_MASK)) {
            if (stackTop != token) {
                makeError(currentLine,SYNTAX+FATAL_ERR,buf);
            } else {
                popStack();
#ifdef DEBUG_ALL
                printf ("DEBUG: parse 1: %d\n", line);
#endif
                if (ON(topStack(),ACTION_MASK)) {
                    doAction(popStack());
                }
#ifdef DEBUG_ALL
                printf ("DEBUG: parse 2: %d\n", line);
#endif
                currentLine = line;
                if (nextToken) {                        // if we already
                    if (*buf == '\n') --currentLine;    //  have a token,
                    token = nextToken;                  //  use it . . .
                    nextToken = 0;
                } else {
                    token = getToken(MAXBUF,topStack());
                    currentLine = line;
                }
            }
        } else {
            n = table[stackTop][token & LOW_NIBBLE];
#ifdef DEBUG_ALL
            printf ("DEBUG: parse 3: %x %d %x %x\n", n, stackTop, token & LOW_NIBBLE, token);
#endif
            if (ON(n,ERROR_MASK)) {
#ifdef DEBUG_ALL
                printf ("DEBUG: parse 4: %d %s\n", line, buf);
#endif
                makeError(currentLine,n+FATAL_ERR,buf);
            }
            popStack();
            if (ON(n,AMBIG_MASK)) {             // 2 possible prod
                n &= LOW_NIBBLE;                // only use 4 bits
                if (!nextToken) {               // peek to decide
                    nextToken = getToken(MAXBUF,stackTop);
                }
                n += (useAlternate[stackTop][nextToken & LOW_NIBBLE]);
            }
            for (i = productions[n][0]; i; --i) {   // put production
                pushStack(productions[n][i]);       //  on stack
            }
        }                           // 1st elt in prod
    }                               //  is its length
    popStack();    // pop the ACCEPT off the stack
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\precomp.h ===
#include "nmake.h"
#include "nmmsg.h"
#include "proto.h"
#include "globals.h"
#include "grammar.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\nmake.h ===
//  NMAKE.H -- main header file
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This file is the main header file for NMAKE and contains global typedef and
//  macros. Global constants are also defined here. Global data is in global.h
//
// Revision History:
//  01-Feb-1994 HV  Move messages to external file.
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  23-Jun-1993 HV  Kill the near keyword
//  01-Jun-1993 HV  Change #ifdef KANJI to _MBCS
//  10-May-1993 HV  Add _MBCS version of the string library.
//  10-Jul-1992 SB  Port to NTMIPS
//  08-Jun-1992 SS  Port to DOSX32
//  02-Feb-1990 SB  add definition of FILEOPEN
//  04-Dec-1989 SB  Changed definition of PFV to have prototype of function
//                  which it dereferences
//  01-Dec-1989 SB  Contains an hack #ifdef'ed for Overlayed version
//                  also defined REALLOC
//  22-Nov-1989 SB  #define FREE
//  13-Nov-1989 SB  Definitions CCHMAXPATH(COMP) conform with bsedos.h
//  02-Oct-1989 SB  added support for dynamic inline files
//  14-Sep-1989 SB  added inLines field to block
//  04-Sep-1989 SB  Added M_COMMAND_LINE but not used
//  24-Aug-1989 SB  Add A_DEPENDENT for NMAKE to know that it is to look for a
//                  dependent
//  16-May-1989 SB  NOLOGO flag /L set up for passing to recursive builds
//  24-Apr-1989 SB  added CCHMAXPATH & CCHMAXPATHCOMP for OS/2 ver 1.2 support
//                  & removed FILEINFO typedef's (not needed anymore)
//  22-Feb-1989 SB  changed value of MAXCMDLINELENGTH to 2k
//  03-Feb-1989 SB  Added struct for FILEINFO for OS2 ver 1.2
//  02-Feb-1989 SB  Redefined SPAWNV(P) and SYSTEM as NMAKE was really not
//                  supporting KANJI
//  31-Jan-1989 SB  Changed MAXNAME to 257 for OS2 Ver 1.2 support
//  21-Dec-1988 SB  Added SCRIPTLIST and makeNewScriptListElement() to allow
//                  multiple script fileseach with its KEEP/NOKEEP action
//  06-Dec-1988 SB  Updated Comment about bits corr to flags set
//  05-Dec-1988 SB  Added #define CDECL; NMAKE now uses Pascal Calling
//                  Add SIG_IGN to handle compiler problem
//  30-Nov-1988 SB  Added suppport for 'z' option in setFlags()
//  23-Nov-1988 SB  Defined MAXCMDLINELENGTH for extmake syntax
//  10-Nov-1988 SB  Changed BOOL as 'unsigned short' as in 'os2.h'
//  17-Aug-1988 RB  Clean up.
//  14-Jul-1988 rj  Added dateTime to BUILDBLOCK def to support multiple
//                  targets with the same command block.
//  07-Jul-1988 rj  Added targetFlag parameter to findMacro, findTarget
//  15-Jun-1988 rj  Add definition of EScapeCHaracter.
//  25-May-1988 rb  Clean up definition of LOCAL.
//                  Better char-type defs for ECS.

// Include from the LANGAPI (shared components) project

#include <assert.h>
#include <direct.h>
#include <dos.h>
#include <errno.h>
#include <io.h>
#include <limits.h>
#include <malloc.h>
#include <mbctype.h>
#include <process.h>
#include <share.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "getmsg.h"

#define STRICT

#define NOMINMAX               // windef.h
#define NOGDI                  // wingdi.h
#define NOIME                  // ime.h
#define NOUSER                 // winuser.h
#define NOHELP
#define NOPROFILER
#define NOSYSPARAMSINFO
#define NONLS                  // winnls.h
#define NOSERVICE              // winsvc.h
#include <windows.h>

#define FILEOPEN open_file

#define FREE_STRINGLIST free_stringlist
#define ALLOC_STRINGLIST(type) (STRINGLIST *)alloc_stringlist()

#define FREE free
#define REALLOC realloc

typedef char CHAR;
typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;

#define NMHANDLE INT_PTR

typedef void (*PFV) (void);            // pointer to void function

//  size constants for buffers
//
//  I impose an arbitrary limit of 128 bytes for a macro or target name.
//  This should be much larger than any intelligent user would need.
//  The value of a macro can be longer -- up to MAXBUF in length.
//
//  The hash table for macros was only 64 pointers long. That seemed a
//  reasonable number, since most makefiles have fewer than 64 variables
//  defined. Measurements on real makefiles (P1) showed that we had almost
//  8 elements per chain, so it was increased to 256 on FLAT architectures.
//  The hashing algorithm isn't perfect, but it should be good
//  enough.  Even if the macro we're looking up is in a bucket w/ more
//  than one entry, we'll only have to chain one or two links down the
//  list to find it.  When we add macros a bucket's list we prepend them,
//  so we don't have to chain at all there.

#define MAXNAME     257
#define MAXMACRO    256
#define MAXTARGET   128
#define MAXBUF      1024
#define MAXSEGMENT  65535
#define MAXARG      MAXNAME / 2 - 1
#define CHUNKSIZE   8

#define MAXCMDLINELENGTH  8192

//  constants used by error.c
//
//  error numbers are of the form Unxxx, where the 'U' stands for utility,
//  n is the 1st digit of one of the values below indicating the type of
//  error, and xxx is the number of the error (error messages aren't in any
//  order right now -- related ones should probably be grouped together
//  when all error messages have been added)

#define FATAL_ERR   1000
#define NONFATAL_ERR    2000
#define WARNING_ERR 4000

//  other constants

#define WRITE   2               // READ,WRITE,APPEND used by
#define APPEND  3               //  redirect() in build.c
#define READ    4               // also value for access()
#define ESCH    '^'             // general escape character

typedef struct INCLUDEINFO
{
    unsigned line;
    char *name;
    FILE *file;
} INCLUDEINFO;

#define MAXINCLUDE  16

//  STRINGLIST structure is used to construct lists that keep track of the
//      makefiles to read, the targets to update, the dependency list for each
//  target, the list of build commands for each target, and the values
//  for a macro.

typedef struct strlist {
    struct strlist *next;
    char *text;
} STRINGLIST;

typedef struct inlinelist {
    struct inlinelist *next;
    char *text;
    char *name;
    BOOL fKeep;
    unsigned size;
} INLINELIST;

typedef struct scrptlist {          // List used to handle multiple
    struct scrptlist *next;         //      scriptfiles
    char *sFile;                    // -- Script file name & its
    BOOL fKeep;                     // -- keep status (default nokeep)
} SCRIPTLIST;

typedef struct BLOCK {
    STRINGLIST *dependents;         // dependents of the target
    STRINGLIST *dependentMacros;    //
    STRINGLIST *buildCommands;      // command list to build target
    STRINGLIST *buildMacros;
    UCHAR flags;
    time_t dateTime;
} BUILDBLOCK;

typedef struct bldlist {
    struct bldlist *next;
    BUILDBLOCK *buildBlock;
} BUILDLIST;

typedef struct BATCH {				// State info for deferred batch commands
	struct BATCH *next;		
	struct RULE *pRule;				// batch inference rule
	UCHAR flags;					// build flags
	STRINGLIST *nameList;			// list of names to be "touched" (nmake -t)
	STRINGLIST *dollarLt;			// list for constructing batch $< 
} BATCHLIST;

typedef struct OBJECT {
    struct OBJECT *next;
    char *name;
    UCHAR flags2;
    UCHAR flags3;
    time_t dateTime;
    BUILDLIST *buildList;
	BATCHLIST **ppBatch;			// batch list that contains this object,
									// if being built in batch-mode
} MAKEOBJECT;

typedef struct iobject {            // used for dependents NOT in
    struct object *next;            //  the makefile.  We add them
    char *name;                     //  to the target table w/ a
    UCHAR flags2;                   //  flag that says "already
    UCHAR flags3;                   //  built" and then we never
    long datetime;                  //  have to time-stamp again
} IMPLIEDOBJECT;

typedef struct RULE {
    struct RULE *next;
    struct RULE *back;              // doubly-link rules for ease
    char *name;                     //  in sorting later . . .
    STRINGLIST *buildCommands;      // (# of rules is mostly small
    STRINGLIST *buildMacros;        //  so not much memory used
	BOOL fBatch;					// TRUE if batch rule (doublecolon)
} RULELIST;


typedef struct deplist {
    struct deplist *next;
    char *name;
    time_t depTime;
} DEPLIST;


//  Bits in flags/gFlags indicate which cmdline options are set
//
//  -a  sets FORCE_BUILD
//  -c  sets CRYPTIC_OUTPUT (only fatal errors get displayed)
//  -d  sets DISPLAY_FILE_DATES
//  -e  sets USE_ENVIRON_VARS
//  -i  sets IGNORE_EXIT_CODES
//  -n  sets NO_EXECUTE
//  -p  sets PRINT_INFORMATION
//  -q  sets QUESTION_STATUS
//  -r  sets IGNORE_EXTERN_RULES
//  -s  sets NO_ECHO
//  -t  sets TOUCH_TARGETS
//  -z  sets REVERSE_BATCH_FILE (Required by PWB)
//  -l  sets NO_LOGO (internally /l actually -nologo)
//
//  Also included are  bits for
//
//     BUILDING_THIS_ONE  -  to detect cycles in dependencies
//     DOUBLECOLON    -  to indicate type of separator found between
//              the targets and dependencies (':' or '::')
//     ALREADY_BUILT      -  to indicate that a target has been built
//     OUT_OF_DATE    -  to indicate that this target is out of date

#define F1_PRINT_INFORMATION    0x01        // "global" flags that affect
#define F1_IGNORE_EXTERN_RULES  0x02        //  all targets (it doesn't
#define F1_USE_ENVIRON_VARS 0x04        //  make sense to allow the
#define F1_QUESTION_STATUS  0x08        //  user to change these)
#define F1_TOUCH_TARGETS    0x10
#define F1_CRYPTIC_OUTPUT   0x20
#define F1_NO_BATCH			0x40		// disable batching functionality
#define F1_NO_LOGO      0x80

#define F2_DISPLAY_FILE_DATES   0x01        // these are resettable w/in
#define F2_IGNORE_EXIT_CODES    0x02        //  the makefile
#define F2_NO_EXECUTE       0x04        // each target keeps own copy
#define F2_NO_ECHO      0x08
#define F2_FORCE_BUILD      0x10        // build even if up-to-date
#define F2_DOUBLECOLON      0x20        // indicates separator type
#define F2_DUMP_INLINE		0x40		// dump inline files

#define F3_BUILDING_THIS_ONE    0x01        // finds cyclical dependencies
#define F3_ALREADY_BUILT    0x02
#define F3_OUT_OF_DATE      0x04        // reuse :: bit after target
                        //  has been built
#define F3_ERROR_IN_CHILD   0x08        // used to implement slash k

//  ----------------------------------------------------------------------------
//  MACRODEF structure is used to make a list of macro definitions from the
//      commandline, makefile, TOOLS.INI file, and environment.  It contains
//      a flag which is set for macros defined in the command line so that
//      a later definition of the same macro will be ignored.  It also contains
//      a flag that gets set when NMAKE is expanding the macro so that recursive
//      definitions can be detected.
///

typedef struct macro {
    struct macro *next;
    char *name;
    STRINGLIST *values;             // can just be list of size 1
    UCHAR flags;
} MACRODEF;



//  Bits in flags field for macros.  We really only need to know if a macro
//  was defined on the commandline (in which case we ignore all redefinitions),
//  or if we're currently expanding macros in its value (so when we look
//  up a macro and that bit is set we can tell that the macro is defined
//  recursively).

#define M_EXPANDING_THIS_ONE    0x01
#define M_NON_RESETTABLE    0x02
#define M_ENVIRONMENT_DEF   0x04
#define M_WARN_IF_RESET     0x08
#define M_UNDEFINED     0x10
#define M_COMMAND_LINE      0x20
#define M_LITERAL			0x40	// value contains no other macros
									// treat $ literary


//  macros to simplify dealing w/ bits in flags, allocating memory, and
//  testing characters

#define SET(A,B)        ((A) |= (UCHAR)(B)) // turn bit B on in A
#define CLEAR(A,B)      ((A) &= (UCHAR)(~B))    // turn bit B off in A
#define ON(A,B)         ((A) &  (UCHAR)(B)) // is bit B on in A?
#define OFF(A,B)        (!ON(A,B))      // is bit B off in A?
#define FLIP(A,B)       (ON(A,B)) ? (CLEAR(A,B)) : (SET(A,B))
#define CANT_REDEFINE(A)    (ON((A)->flags,M_NON_RESETTABLE)           \
                    || (ON(gFlags,F1_USE_ENVIRON_VARS)         \
                    && ON((A)->flags,M_ENVIRONMENT_DEF)))


#define ALLOCATE_OBJECT(type) ((type *) allocate(sizeof(type)))

#define makeNewStrListElement()     ALLOC_STRINGLIST(STRINGLIST)
#define makeNewInlineListElement()  ALLOCATE_OBJECT(INLINELIST)
#define makeNewScriptListElement()  ALLOCATE_OBJECT(SCRIPTLIST)
#define makeNewMacro()          ALLOCATE_OBJECT(MACRODEF)
#define makeNewObject()         ALLOCATE_OBJECT(MAKEOBJECT)
#define makeNewImpliedObject()      ALLOCATE_OBJECT(MAKEOBJECT)
#define makeNewBuildBlock()     ALLOCATE_OBJECT(BUILDBLOCK)
#define makeNewBldListElement()     ALLOCATE_OBJECT(BUILDLIST)
#define makeNewRule()           ALLOCATE_OBJECT(RULELIST)
#define MakeNewDepListElement()     ALLOCATE_OBJECT(DEPLIST)
#define makeNewBatchListElement()	ALLOCATE_OBJECT(BATCHLIST)


#define WHITESPACE(A)       ((A) == ' '  || (A) == '\t')
#if 1       //JdR       see charmap.h
// #define MACRO_CHAR(A)    IS_MACROCHAR(A) 
// Modified MACRO_CHAR to fix handling of mbcs characters.
// 'A' may combine the bytes of the mbcs char in a single value and 
// end up being >= 256. All values >=128 can be treated as 
// valid macro characters [vc98 #9973 georgiop 9/19/97]
#define MACRO_CHAR(A)       (IS_MACROCHAR(A) || ((unsigned)(A)) >= 128)
#else
#define MACRO_CHAR(A)       ((A) == '_' || _istalnum(A) || ((unsigned)(A)) >= 128)
#endif
#define PATH_SEPARATOR(A)   ((A) == '\\' || (A) == '/')
#define DYNAMIC_DEP(A)      ((A)[2] == '('                     \
                    && (A)[3] == '@'                   \
                    && (A)[5] == ')'                   \
                    && (((A)[4] == 'F'                 \
                    || (A)[4] == 'D'               \
                    || (A)[4] == 'B'               \
                    || (A)[4] == 'R')))

//  values passed to getSpecialValue() to indicate which type of macro
//  we're expanding

#define SPECIAL_MACRO    0x01               // $* $@ $? $< $**
#define DYNAMIC_MACRO    0x02               // $$@
#define X_SPECIAL_MACRO  0x03               // $(*F) $(@D) etc.
#define X_DYNAMIC_MACRO  0x04               // $$(@F) $$(@D)
#define DOLLAR_MACRO     0x05               // $$ -> $


//  Bits in elements placed in the stack (ifStack) that keeps state
//  information about if/else/endif directives. Here "if" directive
//  includes if/ifdef/ifndef/if defined().
//                              -- used in routine lgetc() in ifexpr.c

#define NMIFELSE    0x01            // set for if/ifdef etc...reset for else
#define NMCONDITION 0x02            // set if condition part of if is true
#define NMIGNORE    0x04            // set if if/endif block is to be ignored/skipped
#define NMELSEIF    0x08            // set for else if/ifdef etc...reset for else


//  Values to record which of if/ifdef/ifndef/etc was seen to decide
//  the kind of processing to be done.

#define IF_TYPE         0x01
#define ELSE_TYPE       0x02
#define ELSE_IF_TYPE        0x03
#define ELSE_IFDEF_TYPE     0x04
#define ELSE_IFNDEF_TYPE    0x05
#define IFDEF_TYPE      0x06
#define IFNDEF_TYPE     0x07
#define ENDIF_TYPE      0x08


// Values to indicate if we are reading from the raw stream or thru'
// the routine lgetc() which preprocesses directives. These are used
// by a routine common to lgetc() module and the lexer.

#define FROMLOCAL    0x00
#define FROMSTREAM   0x01

//  macros to simplify accessing hash tables
//  find() returns a STRINGLIST pointer, which is then cast to a pointer
//  of the appropriate structure type

#define findTarget(A) (MAKEOBJECT*) find(A, MAXTARGET,                 \
                     (STRINGLIST**)targetTable,        \
                     (BOOL)TRUE)

//  "action" flags for building target-table entries
//  if any of the bits in A_SUFFIX to A_RULE is set, the action routines
//  WON'T build a targetblock for the current target (really pseudotarget
//  or rule)

// A_TARGET says expand names on input (dependent names get expanded when
// target is built) */

#define A_SUFFIX    0x01
#define A_SILENT    0x02
#define A_IGNORE    0x04
#define A_PRECIOUS  0x08
#define A_RULE      0x10
#define A_TARGET    0x20
#define A_STRING    0x40
#define A_DEPENDENT 0x80

//  "build" flags used by recursive target-building function

#define B_COMMANDS  0x01
#define B_BUILD     0x02
#define B_INMAKEFILE    0x04
#define B_NOTARGET  0x08
#define B_ADDDEPENDENT  0x10
#define B_DOUBLECOLON   0x20
#define B_DEP_OUT_OF_DATE 0x40

//  "command" flags used by doCommand function

#define C_SILENT    0x01
#define C_IGNORE    0x02
#define C_ITERATE   0x04
#define C_EXECUTE   0x08
#define C_EXPANDED  0x10

//  keyword for better profiling, normally set to "static".

#ifndef LOCAL
#define LOCAL static
#endif

// GetTxtChr and UngetTxtChr are the MBCS counterparts of getc and ungetc.
#ifdef _MBCS
extern int GetTxtChr(FILE*);
extern int UngetTxtChr(int, FILE*);
#else
#define GetTxtChr(a)    getc(a)
#define UngetTxtChr(c,f) ungetc(c,f)
#endif

#define strend(p) (p + _tcslen(p))

#include "charmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\register.h ===
//  register.h - definitions for register variable specifiers
//
//  Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
//
//Purpose:
//  This file contains definitions for register variable specifiers.
//  [Internal]
//
//Revision History:
//  06-08-88  SKS   Removed M_M68000 ifdef
//  08-22-89  GJF   Fixed copyright (again)

#define REG1    register
#define REG2    register

#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\rpn.cpp ===
//  RPN.C -- expression evaluator
//
//    Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains NMAKE's expression evaluator routines.
//
// Revision History:
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  04-Dec-1989 SB  Add prototype for match() and chkInvokeAndPush()
//  09-Oct-1989 SB  Added HACK to handle pointer arithmetic quirks; Done to
//                  avoid rewriting entire module
//  08-Oct-1989 SB  '!if' expressions can be decimal, octal or hex now
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  19-Sep-1988 RB  Split ptr_to_string().  Process ESCH in program invocations.
//  17-Aug-1988 RB  Clean up.
//  28-Jun-1988 rj  Added doCmd parameter to execLine.
//  23-Jun-1988 rj  Add parameter to execLine (no echo of command).
//  25-May-1988 rb  Change isspace to _istspace, isdigit to _istdigit.

#include "precomp.h"
#pragma hdrstop

#include "rpn.h"

char      * GetEndQuote(void);
char      * GetEndBracket(void);
void      check_syntax_error(UCHAR);
void      type_and_val(UCHAR, INT_PTR);
void      pushIntoList(void);
void      printList(void);
BOOL      handleExpr(void);
BOOL      handleExists(char*);
BOOL      handleDefines(char*);
void      getTok(void);
BOOL      do_binary_op(UCHAR);
BOOL      do_unary_op(UCHAR);
UCHAR     match(char *tokPtr);
void      chkInvocAndPush(RPNINFO *pListPtr);

#define TEMPSTACKSIZE   512         // size of temporary stack
#define LISTSIZE        1024        // size of list of rpn-form items

RPNINFO     tempStack[TEMPSTACKSIZE];   // temporary/operand stack
RPNINFO     rpnList[LISTSIZE];      // list of items in rpn order
char    * text;               // pointer to expr text in lbufPtr
UCHAR     prevTok;            // initial token put on tempstack
BOOL      done;               // true if there are no more tokens
UCHAR     errRow;             // first token is '(' so error table
                                    //  row val is 3. See check_syntax....
RPNINFO * pTop;               // top item on tempStack
RPNINFO * pList;              // next free slot in list
RPNINFO * pEnd     = &(tempStack[TEMPSTACKSIZE-1]);
RPNINFO * pListEnd = &(rpnList[LISTSIZE-1]);
RPNINFO   tokRec;


// do_binary_op() - do operation on two stack operands
//
// arguments:  type - operator type code
//
// actions  :  pops first operand from the stack (tempStack).
//             checks the types of the two operands (the operand
//             that was popped as well as the operand currently
//             on top of the stack).
//             if both operands are integers then do the operation
//             else if both operands are strings and operation is
//               the equality operation then do it.
//             else return FALSE ( illegal operation )
//
// modifies :  tempStack - top element will now be the result of
//                   the operation.

BOOL
do_binary_op(
    UCHAR type
    )
{
    INT_PTR *left;
    INT_PTR *right;
    RPNINFO *pOldTop;

    pOldTop = pTop--;               // pop one item off stack, with a ptr to it
    right = &pOldTop->valPtr;
    left = &pTop->valPtr;

    if ((pOldTop->type == INTEGER) && (pTop->type == INTEGER)) {
        switch (type) {
            case LOGICAL_OR:
                *left = *left || *right;
                break;

            case LOGICAL_AND:
                *left = *left && *right;
                break;

            case BIT_OR:
                *left |= *right;
                break;

            case BIT_XOR:
                *left ^= *right;
                break;

            case BIT_AND:
                *left &= *right;
                break;

            case NOT_EQUAL:
                *left = *right != *left;
                break;

            case EQUAL:
                *left = *right == *left;
                break;

            case GREATER_THAN:
                *left = *left > *right;
                break;

            case LESS_THAN:
                *left = *left < *right;
                break;

            case GREATER_EQ:
                *left = *left >= *right;
                break;

            case LESS_EQ:
                *left = *left <= *right;
                break;

            case SHFT_RIGHT:
                *left >>= *right;
                break;

            case SHFT_LEFT:
                *left <<= *right;
                break;

            case BINARY_MINUS:
                *left -= *right;
                break;

            case ADD:
                *left += *right;
                break;

            case MODULUS:
                if (!*right)
                    makeError(line, DIVIDE_BY_ZERO);
                *left %= *right;
                break;

            case DIVIDE:
                if (!*right)
                    makeError(line, DIVIDE_BY_ZERO);
                *left /= *right;
                break;

            case MULTIPLY:
                *left *= *right;
                break;

            default:
                return(FALSE);
                break;
        }
    } else if ((pOldTop->type == STR) &&
                (pTop->type == STR) &&
                ((type == EQUAL) || (type == NOT_EQUAL))) {
        pTop->type = INTEGER;
        *left = !_tcscmp((char *) *left, (char *) *right);
        if (type == NOT_EQUAL) {
            if (!do_unary_op(LOGICAL_NOT)) {
                return(FALSE);
            }
        }
    } else {
        return(FALSE);
    }

    return(TRUE);
}


// do_unary_op() - do operation on top stack operand
//
// arguments:  type - operator type code
//
// actions  :  checks the type of the top operand on the stack
//             if operand is an integer then do the operation
//             else return FALSE ( illegal operation )
//
// modifies :  tempStack - top element will now be the result of
//                   the operation.

BOOL
do_unary_op(
    UCHAR type
    )
{
    INT_PTR *L_top;

    L_top = &pTop->valPtr;

    if (pTop->type == INTEGER) {
        switch (type) {
            case UNARY_MINUS:
                *L_top = -*L_top;
                break;

            case COMPLEMENT:
                *L_top = ~*L_top;
                break;

            case LOGICAL_NOT:
                *L_top = !*L_top;
                break;

            default:
                return(FALSE);
                break;
        }
    } else {
        return(FALSE);
    }

    return(TRUE);
}



// GetEndQuote
//
// Return the pointer to the next double-quote character in text.  A
// double-quote followed immediately by a double-quote is skipped.
//
// text : the global ptr to the buffer is moved up beyond this string.

char *
GetEndQuote()
{
    char *pStart;

    for (pStart = ++text; *text; ++text)
        if (*text == '\"') {
            if (text[1] == '\"')
                ++text;
            else
                break;
        }

    if (!*text)
        makeError(line, SYNTAX_MISSING_END_CHAR, '\"');

    *text++ = '\0';                     // null byte over closing quote
    return(pStart);
}


// GetEndBracket
//
// Lexes a program invocation.
//
// Program invocation is of the form: [ prog <arglist> ].
// Process escaped ']' here because this is where we do the lexing.
//
// text : the global ptr to the buffer is moved up beyond this string.

char *
GetEndBracket()
{
    char *pStart;

    for (pStart = ++text; *text; text = _t