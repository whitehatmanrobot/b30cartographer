      default:
            Win4Assert(!"How did we get here?");
            break;
    }

    Win4Assert(dwMinWordlistBattery <= CI_MIN_WORDLIST_BATTERY_MAX &&
               dwMinWordlistBattery >= CI_MIN_WORDLIST_BATTERY_MIN);
    Win4Assert(dwWordlistUserIdle <= CI_WORDLIST_USER_IDLE_MAX &&
               dwWordlistUserIdle >= CI_WORDLIST_USER_IDLE_MIN);
    Win4Assert(dwScanBackoff <= CI_SCAN_BACKOFF_MAX &&
               dwScanBackoff >= CI_SCAN_BACKOFF_MIN);
    Win4Assert(dwLowResourceSleep <= CI_LOW_RESOURCE_SLEEP_MAX &&
               dwLowResourceSleep >= CI_LOW_RESOURCE_SLEEP_MIN);
    Win4Assert(dwUsnReadTimeout <= CI_USN_READ_TIMEOUT_MAX &&
               dwUsnReadTimeout >= CI_USN_READ_TIMEOUT_MIN);
    Win4Assert(dwUsnReadMinSize <= CI_USN_READ_MIN_SIZE_MAX &&
               dwUsnReadMinSize >= CI_USN_READ_MIN_SIZE_MIN);

    SetDWORDParam( wcsMinWordlistBattery, dwMinWordlistBattery );
    SetDWORDParam( wcsWordlistUserIdle, dwWordlistUserIdle );
    SetDWORDParam( wcsScanBackoff, dwScanBackoff );
    SetDWORDParam( wcsLowResourceSleep, dwLowResourceSleep );
    SetDWORDParam( wcsUsnReadTimeout, dwUsnReadTimeout );
    SetDWORDParam( wcsUsnReadMinSize, dwUsnReadMinSize );
    SetDWORDParam( wcsDelayUsnReadOnLowResource, dwDelayUsnReadOnLowResource );
}

#pragma warning(pop)

//+---------------------------------------------------------------------------
//
//      Function:   IsMsNetwork
//
//      Synopsis:   Resolves whether or not we're attempting to connect to
//                  a MS network
//
//      Arguments:  [pwszMachine] -- Name of the machine to check
//
//      Returns:    TRUE if it's a Microsoft server or FALSE otherwise
//
//      History:    11/12/00        DGrube  Created in a different codebase
//                  2/1/02          dlee    Modified for Indexing Service
//
//----------------------------------------------------------------------------

BOOL IsMsNetwork( LPCWSTR pwszMachine )
{
    // Reserve extra space for prepending \\ and for a null-terminator

    unsigned cwc = wcslen( pwszMachine ) + 3;

    XArray<WCHAR> xMachine( cwc );

    // Check name -- it needs to have \\ at the start for better performance.
    // It works otherwise, but takes forever.

    if ( *pwszMachine != L'\\' )
        wcscpy( xMachine.Get(), L"\\\\" );
    else
        xMachine[0] = 0;

    wcscat( xMachine.Get(), pwszMachine );

    //
    // Fill a block of memory with zeroes; then initialize the NETRESOURCE
    // structure.
    //

    NETRESOURCE nr;
    ZeroMemory( &nr, sizeof nr );

    nr.dwScope = RESOURCE_GLOBALNET;
    nr.dwType = RESOURCETYPE_ANY;
    nr.lpRemoteName = xMachine.Get();

    //
    // First call the WNetGetResourceInformation function with
    //  memory allocated to hold only a NETRESOURCE structure. This
    //  method can succeed if all the NETRESOURCE pointers are NULL.
    //

    NETRESOURCE nrOut;
    LPTSTR pszSystem = 0;              // pointer to variable-length strings
    NETRESOURCE * lpBuffer = &nrOut;   // buffer
    DWORD cbResult = sizeof( nrOut ); // buffer size

    CDynLoadMpr dlMpr;

    DWORD dwError = dlMpr.WNetGetResourceInformationW( &nr, lpBuffer, &cbResult, &pszSystem );

    //
    // If the call fails because the buffer is too small,
    // call the LocalAlloc function to allocate a larger buffer.
    //

    XArray<BYTE> xBuffer;

    if ( ERROR_MORE_DATA == dwError )
    {
        xBuffer.Init( cbResult );
        lpBuffer = (NETRESOURCE *) xBuffer.Get();

        // Call WNetGetResourceInformation again with the larger buffer.

        dwError = dlMpr.WNetGetResourceInformationW( &nr, lpBuffer, &cbResult, &pszSystem );
    }

    if ( NO_ERROR != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    BOOL bReturn = TRUE;

    // If the call succeeds, process the contents of the
    //  returned NETRESOURCE structure and the variable-length
    //  strings in lpBuffer. 
    //

    if ( 0 != lpBuffer->lpProvider )
    {
        NETINFOSTRUCT NetInfo;

        NetInfo.cbStructure = sizeof( NetInfo );
        dwError = dlMpr.WNetGetNetworkInformationW( lpBuffer->lpProvider, &NetInfo );

        if ( NO_ERROR != dwError )
        {
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        //
        // Need to shift 16 bits for masks below because their a DWORD starting at the
        // 16th bit and wNetType is a word starting at 0
        //

        if ( !( ( NetInfo.wNetType == ( WNNC_NET_MSNET  >> 16 ) ) ||
                ( NetInfo.wNetType == ( WNNC_NET_LANMAN >> 16 ) ) ) )
        {
            bReturn = FALSE;
        }
    }
    else
    {
        bReturn = FALSE;
    }

    return bReturn;
} //IsMsNetwork
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\ci\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF

$(_OBJ_DIR)\$(TARGET_DIRECTORY)\query.def: query.def ..\query.org
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\xact.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   XACT.CXX
//
//  Contents:   Transaction support
//
//  Classes:    CTransaction
//
//  History:    29-Mar-91   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <xact.hxx>
#include <pstore.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     CTransaction::CTransaction, public
//
//  Synopsis:   Begins a new transaction.
//
//  Requires:   Transactions are not nested too deep.
//
//  History:    23-Apr-91       KyleP       Replaces sesid with CSession
//              01-Apr-91       KyleP       Created.
//              13-Jan-92       BartoszM    Changed status to Abort
//
//----------------------------------------------------------------------------

CTransaction::CTransaction()
{
    _status = XActAbort;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\shtole.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000.
//
// File:        ShtOle.cxx
//
// Contents:    Minimal implementation of OLE persistent handlers
//
// Classes:     CShtOle
//
// History:     30-Jan-96       KyleP       Added header
//              30-Jan-96       KyleP       Add support for embeddings.
//              18-Dec-97       KLam        Added ability to flush idle filters
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <regacc.hxx>
#include <shtole.hxx>
#include <eventlog.hxx>
#include <ciregkey.hxx>
#include <cievtmsg.h>

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Shutdown, public
//
//  Synopsis:   Clean up.  Close any open dlls.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CShtOle::Shutdown()
{
    if (! _fInit)
    {
        Win4Assert( 0 == _pserverList && 0 == _pclassList );
        return;
    }

    //
    // Global object unload.  Sometimes this object will be
    // destroyed after the heap manager.  The workaround is to call
    // CIShutdown from the .exe before falling out of main.
    //

    try
    {
        CLock lock( _mutex );

        while ( _pserverList )
        {
            CServerNode * ptmp = _pserverList;
            _pserverList = ptmp->Next();
            delete ptmp;
        }
        while ( _pclassList )
        {
            CClassNode * ptmp = _pclassList;
            _pclassList = ptmp->Next();
            delete ptmp;
        }
    }
    catch( ... )
    {
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::GetFilterIdleTimeout, private
//
//  Synopsis:   Returns the idle timeout period from the registery.
//
//  History:    18-Dec-97   KLam    Added header.
//
//----------------------------------------------------------------------------

ULONG CShtOle::GetFilterIdleTimeout ()
{
    ULONG ulTimeout;

    TRY
    {
        CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );
        ulTimeout = reg.Read( wcsFilterIdleTimeout,
                              CI_FILTER_IDLE_TIMEOUT_DEFAULT,
                              CI_FILTER_IDLE_TIMEOUT_MIN,
                              CI_FILTER_IDLE_TIMEOUT_MAX);
    }
    CATCH( CException, e )
    {
        ulTimeout = CI_FILTER_IDLE_TIMEOUT_DEFAULT;
    }
    END_CATCH;

    return ulTimeout;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::FlushIdle, public
//
//  Synopsis:   Asks idle classes and servers to unload
//
//  History:    18-Dec-97   KLam    Added header.
//
//----------------------------------------------------------------------------

void CShtOle::FlushIdle ()
{
    Win4Assert( _fInit );
    CLock lock ( _mutex );

    // Classes should be flushed first since they reference servers
    _pclassList = FlushList ( _pclassList );
    _pserverList = FlushList ( _pserverList );

    // lock falling out of scope automatically releases it
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::CServerNode::SetModule, public
//
//  Synopsis:   Sets the module handle for this server and gets the pointer
//              to the DllCanUnload now function from the module.
//
//  History:    18-Dec-97   KLam    Added header.
//
//----------------------------------------------------------------------------

void CShtOle::CServerNode::SetModule( HMODULE hmod )
{
    Win4Assert( 0 == _hModule );
    _hModule = hmod;

    if ( _hModule )
        // COM DLLs should export DllCanUnloadNow.
        _pfnCanUnloadNow = (LPFNCANUNLOADNOW)GetProcAddress( _hModule, "DllCanUnloadNow" );
}

SCODE CShtOle::CServerNode::CreateInstance( IUnknown * pUnkOuter,
                                            REFIID     riid,
                                            void **    ppv )
{
    SCODE sc = E_FAIL;

    //
    // Touch the node so that we know when it was last used
    //

    Touch();

    //
    // A class factory is only held for single-threaded factories.
    //

    if ( 0 != _pCF )
        sc = _pCF->CreateInstance( pUnkOuter, riid, ppv );
    else
        sc = CoCreateInstance( _guid, pUnkOuter, CLSCTX_INPROC_SERVER, riid, ppv );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::CServerNode::CanUnloadNow, public
//
//  Synopsis:   Determines whether the server can be unloaded.
//
//  History:    18-Dec-97   KLam    Added header.
//
//----------------------------------------------------------------------------

BOOL CShtOle::CServerNode::CanUnloadNow (DWORD cMaxIdle)
{
    BOOL fCanUnload = FALSE;

    if ( _pfnCanUnloadNow && (GetTickCount() - _cLastUsed > cMaxIdle) )
    {
        // If there is a class factory then it has a lock on the server.
        if ( _pCF )
            _pCF->LockServer ( FALSE );

        fCanUnload = (S_OK == (_pfnCanUnloadNow) ());

        if ( _pCF )
            _pCF->LockServer ( TRUE );
    }

    return fCanUnload;
}


//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Load and bind object to specific interface.
//
//  Arguments:  [pwszPath]          -- Path of file to load.
//              [riid]              -- Interface to bind to.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppvObject]         -- Object returned here.
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( WCHAR const * pwszPath,
                     REFIID riid,
                     IUnknown * pUnkOuter,
                     void  ** ppvObject,
                     BOOL fFreeThreadedOnly )
{
    Win4Assert( riid == IID_IFilter && "This function only supports binding to IFilter" );
    Win4Assert( _fInit );

    SCODE sc = S_OK;

    //
    // Get the extension
    //

    WCHAR const * pExt = wcsrchr( pwszPath, '.' );

    //
    // Allow filter decisions on the null extension.
    //

    if ( 0 == pExt )
    {
        static const WCHAR pSmallExt[] = L".";

        pExt = pSmallExt;
    }

    if ( wcslen(pExt) > CClassNode::ccExtLen )
        return( E_FAIL );

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( pExt );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( pExt, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            WCHAR wcsKey[200];
            WCHAR wcsValue[150];
            BOOL  fPersHandler;
            GUID  classid;

            {
                //
                // Look up class of file by extension
                //

                swprintf( wcsKey,
                          L"\\Registry\\Machine\\Software\\Classes\\%ws",
                          pExt );

                CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );

                //
                // First, look for a persistent handler entry on the extension.
                // This overrides a generic class-level handler.
                //

                TRY
                {
                    swprintf( wcsKey,
                              L"\\Registry\\Machine\\Software\\Classes\\%ws\\PersistentHandler",
                              pExt );

                    CRegAccess regPH( RTL_REGISTRY_ABSOLUTE, wcsKey );
                    regPH.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );

                    StringToGuid( wcsValue, classid );
                    fPersHandler = TRUE;
                }
                CATCH( CException, e )
                {
                    fPersHandler = FALSE;
                }
                END_CATCH

                if ( !fPersHandler )
                    regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );
            }

            CServerNode * pserver;

            if ( fPersHandler )
                pserver = FindServerFromPHandler( classid, riid );
            else
            {
                //
                // Look up classid of file class
                //

                swprintf( wcsKey,
                          L"\\Registry\\Machine\\Software\\Classes\\%ws\\CLSID",
                          wcsValue );

                CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
                regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );

                StringToGuid( wcsValue, classid );
                pnode->SetClassId( classid );

                pserver = FindServer( classid, riid );
            }

            pnode->SetServer( pserver );

            //
            // Link new node to front of list.
            //

        }
        CATCH( CException, e )
        {
            sc = E_FAIL;
        }
        END_CATCH;

        // ======================= lock ======================
        {
            CLock lock( _mutex );

            for ( CClassNode * pnode2 = _pclassList;
                  pnode2 != 0 && !pnode2->IsMatch( pExt );
                  pnode2 = pnode2->Next() )
                continue;       // NULL body

            //
            // Duplicate addition?
            //

            if ( 0 == pnode2 )
            {
                pnode->Link( _pclassList );
                _pclassList = pnode;
            }
            else
            {
                delete pnode;
                pnode = pnode2;
            }
        }
        // ======================= unlock ====================
    }

    if ( pnode )
    {
        if ( fFreeThreadedOnly && pnode->IsSingleThreaded() )
            sc = S_FALSE;
        else
        {
            //
            // Bind to the requested interface
            //

            IPersistFile * pf;

            sc = pnode->CreateInstance( pUnkOuter, IID_IPersistFile, (void **)&pf );

            if ( SUCCEEDED(sc) )
            {
                sc = pf->Load( pwszPath, 0 );

                if ( SUCCEEDED(sc) )
                    sc = pf->QueryInterface( riid, ppvObject );

                pf->Release();
            }
        }
    }
    else
        sc = E_FAIL;

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Load and bind object to specific interface.  Assumes class
//              of object has been pre-determined in some way (e.g. the
//              docfile was already opened for property enumeration)
//
//  Arguments:  [pwszPath]          -- Path of file to load.
//              [classid]           -- Pre-determined class id of object
//              [riid]              -- Interface to bind to.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppvObject]         -- Object returned here.
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( WCHAR const * pwszPath,
                     GUID const & classid,
                     REFIID riid,
                     IUnknown * pUnkOuter,
                     void  ** ppvObject,
                     BOOL fFreeThreadedOnly )
{
    Win4Assert( riid == IID_IFilter && "This function only supports binding to IFilter" );
    Win4Assert( _fInit );

    SCODE sc = E_FAIL;

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( classid );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( classid, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            CServerNode * pserver = FindServer( classid, riid );

            pnode->SetServer( pserver );

            pnode = InsertByClass( classid, pnode );
        }
        CATCH( CException, e )
        {
            delete pnode;
            pnode = 0;
            sc = E_FAIL;
        }
        END_CATCH;
    }

    if ( pnode )
    {
        if ( fFreeThreadedOnly && pnode->IsSingleThreaded() )
            sc = S_FALSE;
        else
        {
            //
            // Bind to the requested interface
            //

            IPersistFile * pf;

            sc = pnode->CreateInstance( pUnkOuter, IID_IPersistFile, (void **)&pf );

            if ( SUCCEEDED(sc) )
            {
                sc = pf->Load( pwszPath, 0 );

                if ( SUCCEEDED(sc) )
                    sc = pf->QueryInterface( riid, ppvObject );

                pf->Release();
            }
        }
    }
    else
        sc = E_FAIL;

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Bind embedding to specific interface.
//
//  Arguments:  [pStg]              -- IStorage of embedding.
//              [riid]              -- Interface to bind to.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppvObject]         -- Object returned here.
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( IStorage * pStg,
                     REFIID riid,
                     IUnknown * pUnkOuter,
                     void  ** ppvObject,
                     BOOL fFreeThreadedOnly )
{
    Win4Assert( riid == IID_IFilter && "This function only supports binding to IFilter" );
    Win4Assert( _fInit );

    //
    // Get the class id.
    //

    STATSTG statstg;

    SCODE sc = pStg->Stat( &statstg, STATFLAG_NONAME );

    if ( FAILED(sc) )
        return sc;

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( statstg.clsid );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( statstg.clsid, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            CServerNode * pserver = FindServer( statstg.clsid, riid );

            pnode->SetServer( pserver );

            pnode = InsertByClass( statstg.clsid, pnode );
        }
        CATCH( CException, e )
        {
            delete pnode;
            pnode = 0;
            sc = E_FAIL;
        }
        END_CATCH;
    }

    if ( pnode )
    {
        if ( fFreeThreadedOnly && pnode->IsSingleThreaded() )
            sc = S_FALSE;
        else
        {
            //
            // Bind to the requested interface
            //

            IPersistStorage * pPersStore;

            sc = pnode->CreateInstance( pUnkOuter, IID_IPersistStorage, (void **)&pPersStore );

            if ( SUCCEEDED(sc) )
            {
                sc = pPersStore->Load( pStg );

                if ( SUCCEEDED(sc) )
                    sc = pPersStore->QueryInterface( riid, ppvObject );

                pPersStore->Release();
            }
        }
    }
    else
        sc = E_FAIL;

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::Bind, public
//
//  Synopsis:   Bind embedding to specific interface.
//
//  Arguments:  [pStm]              -- IStream of embedding.
//              [riid]              -- Interface to bind to.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppvObject]         -- Object returned here.
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    28-Jun-96   KyleP       Added header.
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CShtOle::Bind( IStream * pStm,
                     REFIID riid,
                     IUnknown * pUnkOuter,
                     void  ** ppvObject,
                     BOOL fFreeThreadedOnly )
{
    Win4Assert( riid == IID_IFilter && "This function only supports binding to IFilter" );
    Win4Assert( _fInit );

    //
    // Get the class id.
    //

    STATSTG statstg;

    SCODE sc = pStm->Stat( &statstg, STATFLAG_NONAME );

    if ( FAILED(sc) )
        return sc;

    //
    // Look for a class factory in cache
    //

    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( statstg.clsid );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( statstg.clsid, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            CServerNode * pserver = FindServer( statstg.clsid, riid );

            pnode->SetServer( pserver );

            pnode = InsertByClass( statstg.clsid, pnode );
        }
        CATCH( CException, e )
        {
            delete pnode;
            pnode = 0;
            sc = E_FAIL;
        }
        END_CATCH;
    }

    if ( pnode )
    {
        if ( fFreeThreadedOnly && pnode->IsSingleThreaded() )
            sc = S_FALSE;
        else
        {
            //
            // Bind to the requested interface
            //

            IPersistStream * pPersStream;

            sc = pnode->CreateInstance( pUnkOuter, IID_IPersistStream, (void **)&pPersStream );

            if ( SUCCEEDED(sc) )
            {
                sc = pPersStream->Load( pStm );

                if ( SUCCEEDED(sc) )
                    sc = pPersStream->QueryInterface( riid, ppvObject );

                pPersStream->Release();
            }
        }
    }
    else
        sc = E_FAIL;

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::NewInstance, public
//
//  Synopsis:   Create a new instance of specified class.
//
//  Arguments:  [classid]   -- Class of object to create.
//              [riid]      -- Interface to bind to.
//              [ppvObject] -- Object returned here.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

SCODE CShtOle::NewInstance( GUID const & classid,
                            REFIID riid,
                            void  ** ppvObject )
{
    return CoCreateInstance( classid, 0, CLSCTX_INPROC_SERVER, riid, ppvObject );

#if 0
    Win4Assert( _fInit );
    SCODE sc = E_FAIL;

    //
    // Look for a class factory in cache
    //

    CServerNode * pserver = 0;
    CClassNode * pprev = 0;
    CClassNode * pnode;

    // ======================= lock ======================
    {
        CLock lock( _mutex );

        for ( pnode = _pclassList;
              pnode != 0 && !pnode->IsMatch( classid );
              pprev = pnode, pnode = pnode->Next() )
            continue;       // NULL body
    }
    // ======================= unlock ====================

    //
    // Add to cache if necessary
    //

    if ( 0 == pnode )
    {
        // create new CClassNode
        pnode = new CClassNode( classid, 0 );

        //
        // Find class in registry
        //

        TRY
        {
            WCHAR wcsKey[200];
            WCHAR wcsValue[150];

            //
            // See if the server is already in the list
            //

            // ======================= lock ======================
            {
                CLock lock( _mutex );

                for ( pserver = _pserverList;
                      pserver != 0 && !pserver->IsMatch( classid );
                      pserver = pserver->Next() )
                    continue;       // NULL body
            }
            // ======================= unlock ====================


            if( 0 == pserver )
            {
                pserver = new CServerNode( classid, 0 );

                {
                    GuidToString( classid, &wcsValue[0] );

                    //
                    // Look up name of server
                    //

                    swprintf( wcsKey,
                              L"\\Registry\\Machine\\Software\\Classes\\CLSID\\{%ws}\\"
                              L"InprocServer32",
                              wcsValue );

                    CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
                    regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );
                }

                //
                // Load the server and cache the IClassFactory *
                //

                HMODULE hmod = LoadLibrary( wcsValue );

                if ( 0 != hmod )
                {
                    pserver->SetModule( hmod );

                    LPFNGETCLASSOBJECT pfn = (LPFNGETCLASSOBJECT)GetProcAddress( hmod, "DllGetClassObject" );

                    if (pfn)
                    {
                        IClassFactory * pCF;

                        sc = (pfn)( classid, IID_IClassFactory, (void **)&pCF );

                        if ( SUCCEEDED(sc) )
                            pserver->SetCF( pCF );
                    }
                }

                pserver = InsertByClass( classid, pserver );
            }

            pnode->SetServer( pserver );

            pnode = InsertByClass( classid, pnode );
        }
        CATCH( CException, e )
        {
            delete pserver;
            pserver = 0;

            delete pnode;
            pnode = 0;

            sc = E_FAIL;
        }
        END_CATCH;
    }
#if 0 // can't do this, no lock is held!
    else
    {
        //
        // Move found node to front of list.
        //

        if ( 0 != pprev )
        {
            pprev->Link( pnode->Next() );
            pnode->Link( _pclassList );
            _pclassList = pnode;
        }
    }
#endif

    if ( pnode && pnode->GetCF() )
    {
        //
        // Touch the node so that we know when it was last used
        //
        pnode->Touch();

        //
        // Bind to the requested interface
        //

        sc = pnode->GetCF()->CreateInstance( 0, riid, ppvObject );
    }
    else
        sc = E_FAIL;

    return( sc );
#endif // 0
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::FindServer, private
//
//  Synopsis:   Look up server in cache (or registry)
//
//  Arguments:  [classid] -- Guid of object class.
//              [riid]    -- Interface to bind to.
//
//  Returns:    Persistent server node for class/interface combination, or
//              zero if none can be found or loaded.
//
//  History:    30-Jan-96   KyleP       Broke out of ::Bind.
//
//----------------------------------------------------------------------------

CShtOle::CServerNode * CShtOle::FindServer( GUID const & classid, REFIID riid )
{
    CServerNode * pserver = 0;

    TRY
    {
        WCHAR wcsKey[200];
        WCHAR wcsValue[150];

        GuidToString( classid, wcsValue );

        {
            //
            // Look up classid of persistent handler
            //

            swprintf( wcsKey,
                      L"\\Registry\\Machine\\Software\\Classes\\CLSID\\{%ws}\\PersistentHandler",
                      wcsValue );

            CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
            regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );
        }

        GUID clsPH;
        StringToGuid( wcsValue, clsPH );

        pserver = FindServerFromPHandler( clsPH, riid );
    }
    CATCH( CException, e )
    {
        delete pserver;
        pserver = 0;
    }
    END_CATCH

    return pserver;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::FindServerFromPHandler, private
//
//  Synopsis:   Look up server in cache (or registry) starting with
//              persistent handler.
//
//  Arguments:  [classid] -- Guid of object persistent handler.
//              [riid]    -- Interface to bind to.
//
//  Returns:    Persistent server node for class/interface combination, or
//              zero if none can be found or loaded.
//
//  History:    30-Jan-96   KyleP       Broke out of ::Bind.
//
//----------------------------------------------------------------------------

CShtOle::CServerNode * CShtOle::FindServerFromPHandler( GUID const & clsPH, REFIID riid )
{
    CServerNode * pserver = 0;

    TRY
    {
        WCHAR wcsKey[200];
        WCHAR wcsValue[150];
        GUID  guidServer;

        GuidToString( clsPH, wcsValue );

        //
        // Look up classid of IFilter server
        //
        {
            swprintf( wcsKey,
                      L"\\Registry\\Machine\\Software\\Classes\\CLSID\\{%ws}\\"
                      L"PersistentAddinsRegistered\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                      wcsValue,
                      riid.Data1,
                      riid.Data2,
                      riid.Data3,
                      riid.Data4[0], riid.Data4[1],
                      riid.Data4[2], riid.Data4[3],
                      riid.Data4[4], riid.Data4[5],
                      riid.Data4[6], riid.Data4[7] );

            CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
            regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );

            StringToGuid( wcsValue, guidServer );

        }

        //
        // See if the server is already in the list
        //

        // ======================= lock ======================
        {
            CLock lock( _mutex );

            for ( pserver = _pserverList;
                  pserver != 0 && !pserver->IsMatch( guidServer );
                  pserver = pserver->Next() )
                continue;       // NULL body
        }
        // ======================= unlock ====================

        if( 0 == pserver )
        {
            pserver = new CServerNode( guidServer, 0 );

            {
                //
                // Look up name of IFilter server
                //

                swprintf( wcsKey,
                          L"\\Registry\\Machine\\Software\\Classes\\CLSID\\%ws\\"
                          L"InprocServer32",
                          wcsValue );

                CRegAccess regFilter( RTL_REGISTRY_ABSOLUTE, wcsKey );
                regFilter.Get( L"", wcsValue, sizeof(wcsValue)/sizeof(WCHAR) );

                //
                // Since we have the key open, get the threading model now too.
                //

                TRY
                {
                    WCHAR wcsThreading[35];

                    regFilter.Get( L"ThreadingModel", wcsThreading, sizeof(wcsThreading)/sizeof(WCHAR) );

                    if ( 0 == _wcsicmp( wcsThreading, L"Both" ) ||
                         0 == _wcsicmp( wcsThreading, L"Free" ) )
                        pserver->SetSingleThreaded( FALSE );
                    else
                        pserver->SetSingleThreaded( TRUE );
                }
                CATCH( CException, e )
                {
                    //
                    // No news is bad news...
                    //

                    pserver->SetSingleThreaded( TRUE );
                }
                END_CATCH
            }

            //
            // Use COM to handle all the work for non-single threaded DLLs.
            //

            if ( pserver->IsSingleThreaded() )
            {
                //
                // Load the server and cache the IClassFactory *
                //

                HMODULE hmod = LoadLibrary( wcsValue );

                if ( 0 != hmod )
                {
                    pserver->SetModule( hmod );

                    LPFNGETCLASSOBJECT pfn = (LPFNGETCLASSOBJECT)GetProcAddress( hmod, "DllGetClassObject" );

                    if (pfn)
                    {
                        IClassFactory * pCF;

                        SCODE sc = (pfn)( guidServer, IID_IClassFactory, (void **)&pCF );

                        if ( FAILED(sc) )
                            THROW( CException( sc ) );

                        pserver->SetCF( pCF );
                    }
                }
            }

            pserver = InsertByClass( guidServer, pserver );
        }
    }
    CATCH( CException, e )
    {
        delete pserver;
        pserver = 0;
    }
    END_CATCH

    return pserver;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::InsertByClass, private
//
//  Synopsis:   Insert new class node. Only handles nodes named by clsid
//
//  Arguments:  [classid] -- Class id
//
//  Returns:    Pointer to node with [classid]
//
//  History:    18-Oct-96   KyleP       Created
//
//----------------------------------------------------------------------------

CShtOle::CClassNode * CShtOle::InsertByClass( GUID const & classid,
                                              CShtOle::CClassNode * pnode )
{
    CLock lock( _mutex );

    //
    // Link new node to front of list.
    //

    for ( CClassNode * pnode2 = _pclassList;
          pnode2 != 0 && !pnode2->IsMatch( classid );
          pnode2 = pnode2->Next() )
        continue;       // NULL body

    //
    // Duplicate addition?
    //

    if ( 0 == pnode2 )
    {
        pnode->Link( _pclassList );
        _pclassList = pnode;
    }
    else
    {
        delete pnode;
        pnode = pnode2;
    }

    return pnode;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::InsertByClass, private
//
//  Synopsis:   Insert new server node. Only handles nodes named by clsid
//
//  Arguments:  [classid] -- Class id
//
//  Returns:    Pointer to node with [classid]
//
//  History:    18-Oct-96   KyleP       Created
//
//----------------------------------------------------------------------------

CShtOle::CServerNode * CShtOle::InsertByClass( GUID const & classid,
                                               CShtOle::CServerNode * pnode )
{
    CLock lock( _mutex );

    //
    // Link new node to front of list.
    //

    for ( CServerNode * pnode2 = _pserverList;
          pnode2 != 0 && !pnode2->IsMatch( classid );
          pnode2 = pnode2->Next() )
        continue;       // NULL body

    //
    // Duplicate addition?
    //

    if ( 0 == pnode2 )
    {
        pnode->Link( _pserverList );
        _pserverList = pnode;
    }
    else
    {
        delete pnode;
        pnode = pnode2;
    }

    return pnode;
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::StringToGuid, private static
//
//  Synopsis:   Helper function to convert string-ized guid to guid.
//
//  Arguments:  [wcsValue] -- String-ized guid.
//              [guid]     -- Guid returned here.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CShtOle::StringToGuid( WCHAR * wcsValue, GUID & guid )
{
    //
    // If the first character is a '{', skip it.
    //
    if ( wcsValue[0] == L'{' )
        wcsValue++;

    //
    // Convert classid string to guid
    // (since wcsValue may be used again below, no permanent modification to
    //  it may be made)
    //

    WCHAR wc = wcsValue[8];
    wcsValue[8] = 0;
    guid.Data1 = wcstoul( &wcsValue[0], 0, 16 );
    wcsValue[8] = wc;
    wc = wcsValue[13];
    wcsValue[13] = 0;
    guid.Data2 = (USHORT)wcstoul( &wcsValue[9], 0, 16 );
    wcsValue[13] = wc;
    wc = wcsValue[18];
    wcsValue[18] = 0;
    guid.Data3 = (USHORT)wcstoul( &wcsValue[14], 0, 16 );
    wcsValue[18] = wc;

    wc = wcsValue[21];
    wcsValue[21] = 0;
    guid.Data4[0] = (unsigned char)wcstoul( &wcsValue[19], 0, 16 );
    wcsValue[21] = wc;
    wc = wcsValue[23];
    wcsValue[23] = 0;
    guid.Data4[1] = (unsigned char)wcstoul( &wcsValue[21], 0, 16 );
    wcsValue[23] = wc;

    for ( int i = 0; i < 6; i++ )
    {
        wc = wcsValue[26+i*2];
        wcsValue[26+i*2] = 0;
        guid.Data4[2+i] = (unsigned char)wcstoul( &wcsValue[24+i*2], 0, 16 );
        wcsValue[26+i*2] = wc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CShtOle::GuidToString, private static
//
//  Synopsis:   Helper function to convert guid to string-ized guid.
//
//  Arguments:  [guid]     -- Guid to convert.
//              [wcsValue] -- String-ized guid.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CShtOle::GuidToString( GUID const & guid, WCHAR * wcsValue )
{
    swprintf( wcsValue,
              L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
              guid.Data1,
              guid.Data2,
              guid.Data3,
              guid.Data4[0], guid.Data4[1],
              guid.Data4[2], guid.Data4[3],
              guid.Data4[4], guid.Data4[5],
              guid.Data4[6], guid.Data4[7] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\lib\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\querymsg.mc: $(PROJECT_ROOT)\published\query\cierror.mc \
             $(PROJECT_ROOT)\published\query\filterr.mc \
             ..\..\h\cievtmsg.mc \
             ..\..\sqltext\parserr.mc
    copy $(PROJECT_ROOT)\published\query\cierror.mc+$(PROJECT_ROOT)\published\query\filterr.mc+..\..\h\cievtmsg.mc+..\..\sqltext\parserr.mc $@
    echo Build_Status querymsg.mc was rebuilt...
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\ci\isacl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       isacl.cxx
//
//+-------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

//
// Maximum number of ACE descriptions used in one ACL.
//
#define ACE_COUNT 3

// NOTE:  Portions of the code below were borrowed from
//        \nt\private\windows\setup\syssetup\applyacl.c.

typedef struct _ACE_DATA {
    ACCESS_MASK AccessMask;
    SID_IDENTIFIER_AUTHORITY SidIdAuth;
    DWORD       dwSubAuth0, dwSubAuth1;
    BYTE        cSubAuthorities;
    UCHAR       AceType;
    UCHAR       AceFlags;
} ACE_DATA, *PACE_DATA;

BOOL
ApplyAcl(
    WCHAR const *pwcDir,
    unsigned cAces,
    ACE_DATA *pAceData
    );

DWORD
ApplyAclToDirOrFile(
    IN WCHAR const * FullPath,
    unsigned cAces,
    PACCESS_ALLOWED_ACE Aces[]
    );

DWORD
InitializeSids(
    unsigned cAces,
    ACE_DATA *pAceData,
    PSID apSid[]
    );

VOID
TearDownSids(
    unsigned cAces,
    PSID apSid[]
    );

DWORD
InitializeAces(
    unsigned cAces,
    ACE_DATA const *pAceData,
    PACCESS_ALLOWED_ACE Aces[],
    PSID apSid[]
    );

VOID
TearDownAces(
    unsigned cAces,
    PACCESS_ALLOWED_ACE Aces[]
    );

//
// This structure is valid for access allowed, access denied, audit,
// and alarm ACEs.
//
typedef struct _ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    //
    // The SID follows in the buffer
    //
} ACE, *PACE;


//
// Table describing the data to put into each ACE.
//
// NOTE:  The order of the table is significant because it is used to
//        create two different ACLs.  ACE 0 is used by itself for one ACL,
//        and all three ACEs are used for the other ACL.
//
ACE_DATA AceDataTable[ACE_COUNT] = {

    //
    // ACE 0 - Full access, System account
    //
    {
        GENERIC_ALL,
                SECURITY_NT_AUTHORITY,
                SECURITY_LOCAL_SYSTEM_RID, 0,
                1,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 1 - Full access, Administrators group
    //
    {
        GENERIC_ALL,
                SECURITY_NT_AUTHORITY,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                2,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 2 - Full access, Creator/owner
    //
    {
        GENERIC_ALL,
                SECURITY_CREATOR_SID_AUTHORITY,
                SECURITY_CREATOR_OWNER_RID, 0,
                1,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

};


//
// arg0 = Filename

BOOL ApplySystemAcl( WCHAR const *pwcDir )
{
    return ApplyAcl( pwcDir, ACE_COUNT, AceDataTable );
}

BOOL ApplySystemOnlyAcl( WCHAR const *pwcDir )
{
    return ApplyAcl( pwcDir, 1, AceDataTable );
}

BOOL ApplyAcl( WCHAR const *pwcDir, unsigned cAces, ACE_DATA *pAceData )
{
    WCHAR achDrive[4];
    for (unsigned i = 0; i < 3; i++)
        achDrive[i] = pwcDir[i];
    achDrive[3] = 0;

    DWORD dwFsFlags;
    BOOL b = GetVolumeInformation( achDrive, NULL, 0, NULL, NULL, &dwFsFlags, NULL, 0);
    if (!b || ! (dwFsFlags & FS_PERSISTENT_ACLS))
    {
        // NOTE: We could return a different result here and warn about
        //       the lack of ACLs, but it isn't worth the trouble of
        //       explaining to (and worrying) the user.
        return TRUE;
    }

    //
    // Array of SID pointers used in the ACL.  They are
    // initialized based on the data in the AceDataTable.
    //
    PSID apSids[ACE_COUNT];

    if (InitializeSids(cAces, pAceData, apSids) != NO_ERROR)
        return FALSE;

    //
    // Array of ACEs to be applied to the objects.  They are
    // initialized based on the data in the AceDataTable.
    //
    PACCESS_ALLOWED_ACE aAces[ACE_COUNT];

    if (InitializeAces(cAces, pAceData, aAces, apSids) != NO_ERROR)
    {
        TearDownSids(cAces, apSids);
        return FALSE;
    }

    BOOL fOK = ( ApplyAclToDirOrFile( pwcDir, cAces, aAces ) == NO_ERROR );

    TearDownAces(cAces, aAces);
    TearDownSids(cAces, apSids);
    return fOK;
} //ApplySystemAcl


DWORD
ApplyAclToDirOrFile(
    IN WCHAR const * FullPath,
    unsigned cAces,
    PACCESS_ALLOWED_ACE Aces[]
    )

/*++

Routine Description:

    Applies an ACL to a specified file or directory.

Arguments:

    FullPath - supplies full win32 path to the file or directory
        to receive the ACL

Return Value:

--*/

{
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Acl;
    UCHAR AclBuffer[2048];
    BOOL b;

    //
    // Initialize a security descriptor and an ACL.
    // We use a large buffer on the stack to contain the ACL.
    //
    Acl = (PACL)AclBuffer;
    if (!InitializeAcl(Acl,sizeof(AclBuffer),ACL_REVISION2) ||
        !InitializeSecurityDescriptor(&SecurityDescriptor,SECURITY_DESCRIPTOR_REVISION))
    {
        return GetLastError();
    }

    //
    // Build up the DACL from the indices on the list.
    //

    DWORD rc = NO_ERROR;
    for ( unsigned AceIndex = 0;
          (rc == NO_ERROR) && (AceIndex < cAces);
          AceIndex++ )
    {
        b = AddAce( Acl,
                    ACL_REVISION2,
                    0xFFFFFFFF,
                    Aces[AceIndex],
                    Aces[AceIndex]->Header.AceSize
                  );

        //
        // Track first error we encounter.
        //
        if (!b && (rc == NO_ERROR)) {
            rc = GetLastError();
        }
    }

    if (rc != NO_ERROR)
        return rc;

    //
    // Add the ACL to the security descriptor as the DACL
    //
    rc = SetSecurityDescriptorDacl(&SecurityDescriptor,TRUE,Acl,FALSE)
                                ? NO_ERROR
                                : GetLastError();

    if (rc != NO_ERROR)
        return rc;

    //
    // Finally, apply the security descriptor.
    //
    rc = SetFileSecurity(FullPath,DACL_SECURITY_INFORMATION,&SecurityDescriptor)
       ? NO_ERROR
       : GetLastError();

    return(rc);
}


DWORD
InitializeSids(
    unsigned cAces,
    ACE_DATA *pAceData,
    PSID apSids[]
    )

/*++

Routine Description:

    This function initializes the global variables used by and exposed
    by security.

Arguments:

    None.

Return Value:

    Win32 error indicating outcome.

--*/

{
    //
    // Ensure the SIDs are in a well-known state
    //

    for (unsigned i=0; i<cAces; i++)
    {
        apSids[i] = 0;
    }

    //
    // Allocate and initialize the universal SIDs
    //
    for (i=0; i<cAces; i++)
    {
        BOOL b = AllocateAndInitializeSid( &pAceData[i].SidIdAuth,
                                           pAceData[i].cSubAuthorities,
                                           pAceData[i].dwSubAuth0,
                                           pAceData[i].dwSubAuth1,
                                           0,0,0,0,0,0,
                                           &apSids[i] );
        if (!b)
        {
            DWORD rc = GetLastError();
            TearDownSids(cAces, apSids);
            return rc;
        }
    }

    return NO_ERROR;
}


VOID
TearDownSids(
    unsigned cAces,
    PSID apSids[]
    )
{
    for (unsigned i=0; i<cAces; i++)
        if (apSids[i])
            FreeSid(apSids[i]);
}

#define MyMalloc(cb)    GlobalAlloc( 0, cb )
#define MyFree(pv)      GlobalFree( pv )

DWORD
InitializeAces(
    unsigned cAces,
    ACE_DATA const *pAceData,
    PACCESS_ALLOWED_ACE Aces[],
    PSID apSids[]
    )

/*++

Routine Description:

    Initializes the array of ACEs as described in the pAceData table

Arguments:

    None

Return Value:

    Win32 error code indicating outcome.

--*/

{
    //
    // Initialize to a known state.
    //
    ZeroMemory(Aces, cAces*sizeof Aces[0]);

    //
    // Create ACEs for each item in the data table.
    // This involves merging the ace data with the SID data, which
    // are initialized in an earlier step.
    //
    for (unsigned u=0; u<cAces; u++) {

        ULONG cbSid = GetLengthSid( apSids[u] );
        DWORD Length = cbSid + sizeof(ACCESS_ALLOWED_ACE) - sizeof DWORD;

        Aces[u] = (PACCESS_ALLOWED_ACE) MyMalloc(Length);
        if (!Aces[u]) {
            TearDownAces(cAces, Aces);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        Aces[u]->Header.AceType  = pAceData[u].AceType;
        Aces[u]->Header.AceFlags = pAceData[u].AceFlags;
        Aces[u]->Header.AceSize  = (WORD)Length;

        Aces[u]->Mask = pAceData[u].AccessMask;

        BOOL b = CopySid( cbSid,
                          (PUCHAR) &(Aces[u]->SidStart),
                          apSids[u] );

        if (!b) {
            DWORD rc = GetLastError();
            TearDownAces(cAces, Aces);
            return(rc);
        }
    }

    return NO_ERROR;
}


VOID
TearDownAces(
    unsigned cAces,
    PACCESS_ALLOWED_ACE Aces[]
    )

/*++

Routine Description:

    Destroys the array of ACEs as described in the AceDataTable

Arguments:

    None

Return Value:

    None

--*/

{
    for (unsigned u=0; u<cAces; u++) {

        if (Aces[u]) {
            MyFree(Aces[u]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\ci\cisecret.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       cisecret.cxx
//
//  Functions:  CiGetPassword, GetSecret SetSecret
//
//  History:    10-18-96   dlee   Created, mostly from w3svc sources
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma  hdrstop

extern "C"
{
    #include <ntsam.h>
    #include <ntlsa.h>
}

#include <cisecret.hxx>

//+-------------------------------------------------------------------------
//
//  Function:   CiGetPassword
//
//  Synopsis:   Looks up a password from the lsa database
//
//  Arguments:  [pcsCatalogName] - friendly name of the catalog
//              [pwcUserName]    - domain\user
//              [pwcPassword]    - returns the password
//
//  Returns:    TRUE if a password was found, FALSE otherwise
//
//  History:    29-Oct-96 dlee      created
//
//--------------------------------------------------------------------------

BOOL CiGetPassword(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcUsername,
    WCHAR *       pwcPassword )
{
    Win4Assert( 0 != pwcCatalog );
    Win4Assert( 0 != pwcUsername );

    // look for a match of catalog name and domain\user

    CCiSecretRead secret;
    CCiSecretItem * pItem = secret.NextItem();

    while ( 0 != pItem )
    {
        if ( ( !_wcsicmp( pwcCatalog, pItem->getCatalog() ) ) &&
             ( !_wcsicmp( pwcUsername, pItem->getUser() ) ) )
        {
            wcscpy( pwcPassword, pItem->getPassword() );
            return TRUE;
        }

        pItem = secret.NextItem();
    }

    return FALSE;
} //CiGetPassword

//+-------------------------------------------------------------------------
//
//  Function:   SetSecret
//
//  Synopsis:   Creates or resets a secret value
//
//  Arguments:  [Server]       - Server secret lives on, 0 for local machine
//              [SecretName]   - name of the secret
//              [pSecret]      - secret to set
//              [cbSecret]     - # of bytes in pSecret
//
//  History:    18-Oct-96 dlee   copied from w3svc code and ci-ized
//
//--------------------------------------------------------------------------

void SetSecret(
    WCHAR const *  Server,
    WCHAR const *  SecretName,
    WCHAR const *  pSecret,
    DWORD          cbSecret )
{
    UNICODE_STRING unicodeServer;
    RtlInitUnicodeString( &unicodeServer,
                          Server );

    //
    //  Initialize the unicode string by hand so we can handle '\0' in the
    //  string
    //

    UNICODE_STRING unicodePassword;
    unicodePassword.Buffer        = (WCHAR *) pSecret;
    unicodePassword.Length        = (USHORT) cbSecret;
    unicodePassword.MaximumLength = (USHORT) cbSecret;

    //
    //  Open a policy to the remote LSA
    //

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    LSA_HANDLE hPolicy;
    NTSTATUS ntStatus = LsaOpenPolicy( &unicodeServer,
                                       &ObjectAttributes,
                                       POLICY_ALL_ACCESS,
                                       &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        THROW( CException( ntStatus ) );

    //
    //  Create or open the LSA secret
    //

    UNICODE_STRING unicodeSecret;
    RtlInitUnicodeString( &unicodeSecret,
                          SecretName );

    LSA_HANDLE        hSecret;
    ntStatus = LsaCreateSecret( hPolicy,
                                &unicodeSecret,
                                SECRET_ALL_ACCESS,
                                &hSecret );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        // If the secret already exists, then we just need to open it

        if ( STATUS_OBJECT_NAME_COLLISION == ntStatus )
            ntStatus = LsaOpenSecret( hPolicy,
                                      &unicodeSecret,
                                      SECRET_ALL_ACCESS,
                                      &hSecret );

        if ( !NT_SUCCESS( ntStatus ) )
        {
            LsaClose( hPolicy );
            THROW( CException( ntStatus ) );
        }
    }

    //
    //  Set the secret value
    //

    ntStatus = LsaSetSecret( hSecret,
                             &unicodePassword,
                             &unicodePassword );

    LsaClose( hSecret );
    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        THROW( CException( ntStatus ) );
} //SetSecret

//+-------------------------------------------------------------------------
//
//  Function:   GetSecret
//
//  Synopsis:   Retrieves a secret value
//
//  Arguments:  [Server]      - Server secret lives on, 0 for local machine
//              [SecretName]  - name of the secret
//              [ppSecret]    - returns the secret value that must be deleted
//                              with LocalFree
//              [pcbSecret]   - Returns the count of bytes in the secret
//
//  Returns:    TRUE if secret was found, FALSE if secret didn't exist
//              throws on all other errors.
//
//  History:    18-Oct-96 dlee   added header and and ci-ized
//
//--------------------------------------------------------------------------

// These defines are used in the GetSecret function call.

WCHAR  g_wchUnicodeNull[] = L"";

#define _InitUnicodeString( pUnicode, pwch )                       \
   {                                                               \
        (pUnicode)->Buffer    = pwch;                              \
        (pUnicode)->Length    = wcslen( pwch ) * sizeof(WCHAR);    \
        (pUnicode)->MaximumLength = (pUnicode)->Length + sizeof(WCHAR); \
   }

#define InitUnicodeString( pUnicode, pwch)  \
   if (pwch == NULL) { _InitUnicodeString( pUnicode, g_wchUnicodeNull); } \
   else              { _InitUnicodeString( pUnicode, pwch);             } \


BOOL GetSecret(
    WCHAR const * Server,
    WCHAR const * SecretName,
    WCHAR **      ppSecret,
    ULONG *       pcbSecret )
{
    
    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    UNICODE_STRING unicodeServer;
    InitUnicodeString( &unicodeServer,
                       (WCHAR *) Server );

    //
    //  Open a policy to the remote LSA
    //

    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    LSA_HANDLE hPolicy;
    NTSTATUS ntStatus = LsaOpenPolicy( &unicodeServer,
                                       &ObjectAttributes,
                                       POLICY_ALL_ACCESS,
                                       &hPolicy );

    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    if ( !NT_SUCCESS( ntStatus ) )
        THROW( CException( LsaNtStatusToWinError( ntStatus ) ) );

    UNICODE_STRING unicodeSecret;
    InitUnicodeString( &unicodeSecret,
                       (WCHAR *) SecretName );

    //
    //  Query the secret value
    //

    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    UNICODE_STRING * punicodePassword;
    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    LsaClose( hPolicy );

    // Don't throw if the secret didn't exist -- just return FALSE

    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus )
        return FALSE;

    if ( STATUS_LOCAL_USER_SESSION_KEY == ntStatus )
        return FALSE;

    if ( !NT_SUCCESS( ntStatus ))
        THROW( CException( ntStatus ) );


    Win4Assert ( 0 != ppSecret );
    Win4Assert ( 0 != SecretName );

    ULONG cbSecret = punicodePassword->Length + sizeof WCHAR;

    *ppSecret = (WCHAR *) LocalAlloc( LPTR, cbSecret );

    if ( 0 == *ppSecret )
    {
        RtlZeroMemory( punicodePassword->Buffer,
                       punicodePassword->MaximumLength );

        LsaFreeMemory( (PVOID) punicodePassword );
        THROW( CException( E_OUTOFMEMORY ) );
    }

    *pcbSecret = cbSecret;

    //
    //  Copy it into the buffer, Length is count of bytes
    //

    RtlCopyMemory( *ppSecret,
                   punicodePassword->Buffer,
                   punicodePassword->Length );

    (*ppSecret)[punicodePassword->Length/sizeof(WCHAR)] = L'\0';

    RtlZeroMemory( punicodePassword->Buffer,
                   punicodePassword->MaximumLength );

    LsaFreeMemory( (PVOID) punicodePassword );

    return TRUE;
} //GetSecret
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\h\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF

qutilerr.h msb00001.bin qutilerr.rc: qutilerr.mc

.SUFFIXES:  .mc

.mc.h:
    @ech Build_Status Compiling - $(<F) for all platforms ;
    mc -v $(@B).mc -h . -r .


.mc.rc:
    @ech Build_Status Compiling - $(<F) for all platforms ;
    mc -v $(@B).mc -h . -r .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\h\monquery.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       monquery.h
//
//  Contents:   Index Server <==> Monarch interface functions
//
//  History:    24 Jan 1997    AlanW    Created
//
//----------------------------------------------------------------------------

#ifndef _MONQUERY_H_
#define _MONQUERY_H_

#if defined(__cplusplus)
extern "C"
{
#endif


typedef struct tagCIPROPERTYDEF
{
    LPWSTR      wcsFriendlyName;
    DWORD       dbType;
    DBID        dbCol;
} CIPROPERTYDEF;

// Create an ICommand, specifying scopes and a catalog.
STDAPI CIMakeICommand( ICommand **           ppQuery,
                       ULONG                 cScope,
                       DWORD const *         aDepths,
                       WCHAR const * const * awcsScope,
                       WCHAR const * const * awcsCat,
                       WCHAR const * const * awcsMachine );

// Convert pwszRestriction in Triplish to a command tree.
STDAPI CITextToSelectTree( WCHAR const * pwszRestriction,
                     DBCOMMANDTREE * * ppTree,
                     ULONG cProperties,
       /*optional*/  CIPROPERTYDEF * pReserved );

// Convert pwszRestriction in Triplish to a command tree.
STDAPI CITextToFullTree( WCHAR const * pwszRestriction,
                         WCHAR const * pwszColumns,
                         WCHAR const * pwszSortColumns,
                         DBCOMMANDTREE * * ppTree,
                         ULONG cProperties,
           /*optional*/  CIPROPERTYDEF * pReserved );

#if defined(__cplusplus)
}
#endif

#endif // _MONQUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\qresult\qresult.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       qresult.cxx
//
//  Contents:   Storage/picklers for results of a query
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <sstream.hxx>
#include <sizeser.hxx>

#include "qresult.hxx"

// Smart pointer for aPathNew (see Add() below )
class XPath 
{
public:
    XPath( WCHAR** p = 0 )
    {
        _p = p;
    }

    ~XPath()
    {
        delete _p;
    }

    WCHAR** Acquire()
    {
        WCHAR** ptmp = _p;
        _p = 0;
        return( ptmp );
    }

private:
    WCHAR** _p;

};

//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::CQueryResults
//
//  Synopsis:   simple constructor
//
//----------------------------------------------------------------------------


CQueryResults::CQueryResults()
        : _size(0), _cWid(0), _aRank(0), _aPath(0), pRst(0),
        _fNotOwnPRst( FALSE )
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::~CQueryResults
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------

CQueryResults::~CQueryResults()
{
    if( !_fNotOwnPRst )
        delete pRst;

    delete _aRank;

    for( unsigned i = 0; i < _cWid; i++ )
        delete _aPath[i];
    delete _aPath;
}




//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::CQueryResults
//
//  Synopsis:   Constructor that unmarshalls stream
//
//  Arguments:  [stream] -- stream to unmarshall from
//
//----------------------------------------------------------------------------

CQueryResults::CQueryResults ( PDeSerStream& stream )
        : _fNotOwnPRst( FALSE )
{
    _cWid = stream.GetULong();
    _size = _cWid;
    _aRank = new ULONG [_size];
    _aPath = new WCHAR * [_size];
    for (unsigned i = 0; i < _cWid; i++ )
    {
        _aRank[i] = stream.GetULong();
        _aPath[i] = stream.GetWString();
    }

    BYTE fRst = stream.GetByte();
    if ( fRst )
        pRst = CRestriction::UnMarshall( stream );
    else
        pRst = 0;

    END_CONSTRUCTION ( CQueryResults );
}



//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::Size
//
//  Returns:   return size of marshalled CQueryResults
//
//  History:    26-Sep-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

ULONG CQueryResults::Size()
{
    CSizeSerStream stream;

    stream.PutULong( _cWid );

    for ( unsigned i=0; i<_cWid; i++ )
    {
        stream.PutULong( _aRank[i] );
        stream.PutWString( _aPath[i] );
    }

    if ( pRst == 0 )
        stream.PutByte( FALSE );
    else
    {
        stream.PutByte( TRUE );
        pRst->Marshall( stream );
    }

    return ( stream.Size() );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::Serialize
//
//  Synopsis:   Marshalls CQueryResults
//
//  Arguments:  [stream] -- marshalled into stream
//
//  History:    26-Sep-94   SitaramR    Created by modifying exisiting code
//
//----------------------------------------------------------------------------

void CQueryResults::Serialize( PSerStream & stream ) const
{
    stream.PutULong( _cWid );

    for (unsigned i = 0; i < _cWid; i++)
    {
        stream.PutULong( _aRank[i] );
        stream.PutWString( _aPath[i] );
    }

    if ( pRst == 0 )
        stream.PutByte( FALSE );
    else
    {
        stream.PutByte( TRUE );
        pRst->Marshall( stream );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResults::Add
//
//  Synopsis:   Adds file path and rank
//
//  Arguments:  [wszPath] -- file path to be added
//              [uRank] -- rank to be added
//
//  History:    26-Sep-94   SitaramR    Created by modifying existing code.
//
//----------------------------------------------------------------------------

void CQueryResults::Add ( WCHAR *wszPath, ULONG uRank )
{
    if (_cWid == _size)
    {
        _size = (_size == 0)? 4: (2 * _size);
        WCHAR** aPathNew = new WCHAR *[_size];

        XPath xPath( aPathNew );

        ULONG*  aRankNew = new ULONG [_size];
        for (unsigned i = 0; i < _cWid; i++)
        {
            aPathNew[i] = _aPath[i];
            aRankNew[i] = _aRank[i];
        }
        delete []_aPath;
        delete []_aRank;

        _aPath = xPath.Acquire();
        _aRank = aRankNew;
    }
    ULONG len = wcslen( wszPath );
    _aPath[_cWid] = new WCHAR[ len+1 ];
    memcpy( _aPath[_cWid], wszPath, (len+1) * sizeof (WCHAR) );
    _aRank [_cWid] = uRank;
    _cWid++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\qresult\dbqrslt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       dbqrslt.cxx
//
//  Contents:   Storage/picklers for results of a query
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <sstream.hxx>
#include <sizeser.hxx>
#include <dbqrslt.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::CDbQueryResults
//
//  Synopsis:   simple constructor
//
//----------------------------------------------------------------------------


CDbQueryResults::CDbQueryResults()
        : _size(0), _cHits(0), _aRank(0), _aPath(0), _pDbRst(0),
        _fNotOwnPRst( FALSE )
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::~CDbQueryResults
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------

CDbQueryResults::~CDbQueryResults()
{
    if( !_fNotOwnPRst )
        delete _pDbRst;

    delete _aRank;

    for( unsigned i = 0; i < _cHits; i++ )
        delete _aPath[i];
    delete _aPath;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::CDbQueryResults
//
//  Synopsis:   Constructor that unmarshalls stream
//
//  Arguments:  [stream] -- stream to unmarshall from
//
//----------------------------------------------------------------------------

CDbQueryResults::CDbQueryResults ( PDeSerStream& stream )
        : _fNotOwnPRst( FALSE )
{
    _cHits = stream.GetULong();
    _size = _cHits;
    _aRank = new ULONG [_size];
    _aPath = new WCHAR * [_size];
    for (unsigned i = 0; i < _cHits; i++ )
    {
        _aRank[i] = stream.GetULong();
        _aPath[i] = stream.GetWString();
    }

    BYTE fRst = stream.GetByte();

    if ( fRst )
        _pDbRst = (CDbRestriction *) CDbCmdTreeNode::UnMarshallTree( stream );
    else
        _pDbRst = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::Size
//
//  Returns:   return size of marshalled CDbQueryResults
//
//  History:    26-Sep-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

ULONG CDbQueryResults::Size()
{
    CSizeSerStream stream;

    stream.PutULong( _cHits );

    for ( unsigned i=0; i<_cHits; i++ )
    {
        stream.PutULong( _aRank[i] );
        stream.PutWString( _aPath[i] );
    }

    if ( _pDbRst == 0 )
        stream.PutByte( FALSE );
    else
    {
       stream.PutByte( TRUE );
       _pDbRst->Marshall( stream );
    }

    return ( stream.Size() );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::Serialize
//
//  Synopsis:   Marshalls CDbQueryResults
//
//  Arguments:  [stream] -- marshalled into stream
//
//  History:    26-Sep-94   SitaramR    Created by modifying exisiting code
//
//----------------------------------------------------------------------------

void CDbQueryResults::Serialize( PSerStream & stream ) const
{
    stream.PutULong( _cHits );

    for (unsigned i = 0; i < _cHits; i++)
    {
        stream.PutULong( _aRank[i] );
        stream.PutWString( _aPath[i] );
    }

    if ( _pDbRst == 0 )
        stream.PutByte( FALSE );
    else
    {

        stream.PutByte( TRUE );
        _pDbRst->Marshall( stream );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbQueryResults::Add
//
//  Synopsis:   Adds file path and rank
//
//  Arguments:  [wszPath] -- file path to be added
//              [uRank] -- rank to be added
//
//  History:    26-Sep-94   SitaramR    Created by modifying existing code.
//
//----------------------------------------------------------------------------

void CDbQueryResults::Add ( WCHAR *wszPath, ULONG uRank )
{
    if (_cHits == _size)
    {
        _size = (_size == 0)? 4: (2 * _size);
        WCHAR** aPathNew = new WCHAR *[_size];

        XArray<WCHAR *> xPath;
        xPath.Set( _size, aPathNew );

        ULONG*  aRankNew = new ULONG [_size];
        for (unsigned i = 0; i < _cHits; i++)
        {
            aPathNew[i] = _aPath[i];
            aRankNew[i] = _aRank[i];
        }
        delete []_aPath;
        delete []_aRank;

        _aPath = xPath.Acquire();
        _aRank = aRankNew;
    }
    ULONG len = wcslen( wszPath );
    _aPath[_cHits] = new WCHAR[ len+1 ];
    memcpy( _aPath[_cHits], wszPath, (len+1) * sizeof (WCHAR) );
    _aRank [_cHits] = uRank;
    _cHits++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\qresult\sizeser.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       SizeSer.cxx
//
//  Contents:   Class to compute size of serialized structure.
//
//  History:    28-Jul-94 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <sizeser.hxx>

CSizeSerStream::CSizeSerStream()
        : _cb( 0 )
{
}

CSizeSerStream::~CSizeSerStream()
{
}

void CSizeSerStream::PutByte( BYTE b )
{
    Win4Assert( sizeof(BYTE) == 1 );
    _cb += 1;
}

void CSizeSerStream::PutChar( char const * pc, ULONG cc )
{
    Win4Assert( sizeof(char) == 1 );
    _cb += cc;
}

void CSizeSerStream::PutWChar( WCHAR const * pwc, ULONG cc )
{
    Win4Assert( sizeof(WCHAR) == 2 );
    _cb = (unsigned)((ULONG_PTR)AlignWCHAR((BYTE *) UIntToPtr( _cb ) )) + sizeof(WCHAR) * cc;
}

void CSizeSerStream::PutUShort( USHORT us )
{
    Win4Assert( sizeof(USHORT) == 2 );
    _cb = (unsigned)((ULONG_PTR)AlignUSHORT((BYTE *) UIntToPtr( _cb ) )) + sizeof(USHORT);
}

void CSizeSerStream::PutULong( ULONG ul )
{
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG);
}

void CSizeSerStream::PutLong( long l )
{
    Win4Assert( sizeof(long) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignLong((BYTE *) UIntToPtr( _cb ) )) + sizeof(long);
}

void CSizeSerStream::PutFloat( float f )
{
    Win4Assert( sizeof(float) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignFloat((BYTE *) UIntToPtr( _cb ) )) + sizeof(float);
}

void CSizeSerStream::PutDouble( double d )
{
    Win4Assert( sizeof(double) == 8 );
    _cb = (unsigned)((ULONG_PTR)AlignDouble((BYTE *) UIntToPtr( _cb ) )) + sizeof(double);
}

void CSizeSerStream::PutString( char const * psz )
{
    Win4Assert( sizeof(char) == 1 );
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG) + strlen(psz);
}

void CSizeSerStream::PutWString( WCHAR const * pwsz )
{
    Win4Assert( sizeof(WCHAR) == 2 );
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG) +
        wcslen(pwsz) * sizeof(WCHAR);
}

void CSizeSerStream::PutBlob( BYTE const * pb, ULONG cb )
{
    Win4Assert( sizeof(BYTE) == 1 );
    _cb += cb;
}

void CSizeSerStream::PutGUID( GUID const & guid )
{
    Win4Assert( sizeof(GUID) == 16 );
    _cb = (unsigned)((ULONG_PTR)AlignGUID((BYTE *) UIntToPtr( _cb ) )) + sizeof(GUID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\catstate.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:   catstate.CXX
//
//  Contents:   CCatState implementation
//
//  History:    19-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <catstate.hxx>
#include <doquery.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::CCatState, public
//
//  Synopsis:   Initializes global state info.
//
//  History:    06-May-92   AmyA        Created
//
//----------------------------------------------------------------------------

CCatState::CCatState()
        : _wcsProperty( 0 ), _propType( CONTENTS ),
          _prstLast( 0 ),
          _ulMethod( VECTOR_RANK_JACCARD ),
          _isDeep( FALSE ),
          _isVirtual( FALSE ),
          _eType( CiNormal ),
          _pwcsColumns( 0 ), _nColumns( 0 ),
          _nSort( 0 ), _psi( 0 ),
          _lcid( GetSystemDefaultLCID() ),
          _fIsSC( FALSE ),
          _fUseCI( FALSE ),
          _cCategories( 0 ),
          _aCategories( 0 ),
          _iCategorizationRow( 0 ),
          _cMaxResults( 0 ),
          _cFirstRows( 0 ),
          _wcsCDOld (MAX_PATH ),
          _wcsCD (MAX_PATH)
{
    // set default output format
    SetColumn( L"path", 0 );
    SetColumn( L"filename", 1 );
    SetNumberOfColumns( 2 );
    SetDefaultProperty ( L"contents" );
    SetDeep (TRUE);

    _cCatSets = 0;

    DWORD rc = GetCurrentDirectory( _wcsCDOld.Count(), _wcsCDOld.Get() );

    if( 0 == rc )
    {
        THROW( CQueryException( QUERY_GET_CD_FAILED ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::~CCatState, public
//
//  Synopsis:   Frees memory used by CCatState
//
//  History:    25-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

CCatState::~CCatState()
{
    // free current propery name
    delete [] _wcsProperty;

    // free output column names
    if( _pwcsColumns )
    {
        unsigned int cColumns;

        for( cColumns = 0; cColumns < _nColumns; cColumns++ )
        {
            delete [] _pwcsColumns[ cColumns ];
        }

        delete [] _pwcsColumns;
    }

    // free sort info
    if( _psi )
    {
        unsigned int cProp;

        for( cProp = 0; cProp < _nSort; cProp++ )
        {
            delete [] _psi[ cProp ].wcsProp;
        }

        delete [] _psi;
    }

    // restore current directory
    if( _wcsCDOld.Get() )
        SetCurrentDirectory( _wcsCDOld.Get() );

    delete _prstLast;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddCatSetWithDefaults, public
//
//  Synopsis:   Adds a row with default <machine, catalog, scope, depth> values
//
//  Arguments:
//
//  Notes:
//
//  History:    21-Jan-97   krishnaN     Created
//
//----------------------------------------------------------------------------

SCODE CCatState::AddCatSetWithDefaults()
{
   CString *pStr = new CString( L"\\" );
   _aCatalogs.Add (pStr, _cCatSets);
   pStr = new CString( L"." );
   _aMachines.Add (pStr, _cCatSets);
   pStr =  new CString( L"\\" );
   _aCatScopes.Add (pStr, _cCatSets);
   _afIsDeep.Add (TRUE, _cCatSets);
   _cCatSets++;
   return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetDefaultProperty, public
//
//  Synopsis:   Changes the property passed to the parser on initialization
//              (the 'global default' property)
//
//  Arguments:  [wcsProperty] -- friendly name of property
//                               (can be 0)
//
//  Notes:      Makes its own copy of the property name
//              (unlike GetDefaultProperty, which just returns a pointer)
//
//  History:    18-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetDefaultProperty( WCHAR const * wcsProperty )
{
    delete [] _wcsProperty;

    if( wcsProperty == 0 )
    {
        _wcsProperty = 0;
    }
    else
    {
        int iLength = wcslen( wcsProperty ) + 1;

        _wcsProperty = new WCHAR[ iLength ];
        memcpy( _wcsProperty, wcsProperty, iLength * sizeof(WCHAR) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetCD, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsCD] -- new current directory
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetCD( WCHAR const * wcsCD )
{
    if ( _isVirtual )
    {
        unsigned cc = wcslen( wcsCD ) + 1;

        if ( _wcsCD.Count() < cc )
        {
            delete [] _wcsCD.Acquire();
            _wcsCD.Init( cc );
        }

        RtlCopyMemory( _wcsCD.Get(), wcsCD, cc * sizeof(WCHAR) );
    }
    else
    {
        if( !SetCurrentDirectory( wcsCD ) )
        {
            THROW( CQueryException( QUERY_GET_CD_FAILED ) );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::GetCD, public
//
//  Synopsis:   Returns the current directory.
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

WCHAR const * CCatState::GetCD()
{
    if ( _isVirtual )
        return _wcsCD.Get();

    DWORD rc = GetCurrentDirectory( _wcsCD.Count(), _wcsCD.Get() );

    if( rc == 0 )
    {
        THROW( CQueryException( QUERY_GET_CD_FAILED ) );
    }

    return _wcsCD.Get();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddDir, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsCD] -- new current directory
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::AddDir( XPtrST<WCHAR> & wcsScope )
{
    SCODE sc = AddCatSetWithDefaults();
    if (sc == S_OK)
    {
       // Use previous set's machine and catalog, if available.
       ChangeCurrentScope(wcsScope.GetPointer());
       if (_cCatSets > 1)
       {
          ChangeCurrentMachine(_aMachines[_cCatSets-2]->GetString());
          ChangeCurrentCatalog(_aCatalogs[_cCatSets-2]->GetString());
       }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddCatalog, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsCatalog] -- new current directory
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::AddCatalog( XPtrST<WCHAR> & wcsCatalog )
{
    SCODE sc = AddCatSetWithDefaults();
    if (sc == S_OK)
    {
       // Use previous set's machine, if available, and a default scope
       ChangeCurrentCatalog(wcsCatalog.GetPointer());
       if (_cCatSets > 1)
       {
          ChangeCurrentMachine(_aMachines[_cCatSets-2]->GetString());
       }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddMachine, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsMachine] -- new current directory
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::AddMachine( XPtrST<WCHAR> & wcsMachine )
{
    SCODE sc = AddCatSetWithDefaults();
    if (sc == S_OK)
       ChangeCurrentMachine(wcsMachine.GetPointer());
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::ChangeCurrentCatalog, public
//
//  Synopsis:   Changes the current catalog.
//
//  Arguments:  [wcsCatalog] -- new catalog
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::ChangeCurrentCatalog (WCHAR const * wcsCatalog)
{
   if (_cCatSets == 0)       // if we don't have a row to change, add one
       AddCatSetWithDefaults();

   // replace the current row's catalog value
   _aCatalogs[_cCatSets-1]->Replace(wcsCatalog);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::ChangeCurrentDepth, public
//
//  Synopsis:   Changes the current catalog.
//
//  Arguments:  [wcsCatalog] -- new catalog
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::ChangeCurrentDepth (BOOL fDepth)
{
   if (_cCatSets == 0)       // if we don't have a row to change, add one
      AddCatSetWithDefaults();
   // replace the current row's catalog value
   _afIsDeep[_cCatSets-1] = fDepth;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::ChangeCurrentMachine, public
//
//  Synopsis:   Changes the current Machine.
//
//  Arguments:  [wcsMachine] -- new Machine
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::ChangeCurrentMachine (WCHAR const * wcsMachine)
{
   if (_cCatSets == 0)       // if we don't have a row to change, add one
      AddCatSetWithDefaults();

   // replace the current row's Machine value
   _aMachines[_cCatSets-1]->Replace(wcsMachine);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::ChangeCurrentScope, public
//
//  Synopsis:   Changes the current scope.
//
//  Arguments:  [wcsScope] -- new scope
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::ChangeCurrentScope (WCHAR const * wcsScope)
{
   if (_cCatSets == 0)       // if we don't have a row to change, add one
      AddCatSetWithDefaults();
   // replace the current row's scope value
   _aCatScopes[_cCatSets-1]->Replace(wcsScope);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::AddDepthFlag, public
//
//  Synopsis:   Changes the current query directory.
//
//  Arguments:  [wcsCD] -- new current directory
//
//  History:    21-Jan-97   KrishnaN     Created
//
//----------------------------------------------------------------------------

void CCatState::AddDepthFlag( BOOL fIsDeep )
{
    if (_cCatSets == 0)       // if we don't have a row to change, add one
       AddCatSetWithDefaults();

    _afIsDeep[_cCatSets-1] = fIsDeep;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetCatalog, public
//
//  Synopsis:   Changes the current catalog directory.
//
//  Arguments:  [wcsCatalog] -- new catalog location
//                              (0 indicates the catalog is at or above _wcsCD)
//
//  Notes:      Makes & owns a copy of the path.
//
//  History:    21-Jul-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetCatalog( WCHAR const * wcsCatalog )
{
    delete [] _wcsCatalog.Acquire();

    if( wcsCatalog != 0 )
    {
        int iLength = wcslen( wcsCatalog ) + 1;

        _wcsCatalog.Init( iLength );
        memcpy( _wcsCatalog.Get(), wcsCatalog, iLength * sizeof(WCHAR) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetColumn, public
//
//  Synopsis:   Sets the property for the specified output column.
//
//  Arguments:  [wcsColumn] -- friendly property name
//              [uPos] -- 0-based column number
//
//  Notes:      Makes its own copy of the property name.
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetColumn( WCHAR const * wcsColumn, unsigned int uPos )
{
    // does _pwcsColumns need to be extended?
    if( uPos >= _nColumns )
    {
        WCHAR ** pwcsTemp = new WCHAR *[ uPos + 1 ];

        unsigned int cCol;

        // copy the old pointers and 0 any new ones
        for( cCol = 0; cCol < uPos + 1; cCol++ )
        {
            if( cCol < _nColumns )
                pwcsTemp[ cCol ] = _pwcsColumns[ cCol ];
            else
                pwcsTemp[ cCol ] = 0;
        }

        delete [] _pwcsColumns;

        _nColumns = uPos + 1;
        _pwcsColumns = pwcsTemp;
    }

    // free any previous column string
    delete [] _pwcsColumns[ uPos ];

    // copy & set the column
    if( wcsColumn == 0 )
    {
        _pwcsColumns[ uPos ] = 0;
    }
    else
    {
        int iLength = wcslen( wcsColumn ) + 1;

        _pwcsColumns[ uPos ] = new WCHAR[ iLength ];
        memcpy( _pwcsColumns[ uPos ], wcsColumn, iLength * sizeof(WCHAR) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::GetColumn, public
//
//  Synopsis:   Gets the property for the specified output column.
//
//  Arguments:  [uPos] -- 0-based column number
//
//  Notes:      Returns 0 if the column number is out of range.
//              Only returns a pointer the string; does not copy it.
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

WCHAR const * CCatState::GetColumn( unsigned int uPos ) const
{
    if( uPos >= _nColumns )
        return 0;

    return _pwcsColumns[ uPos ];
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetNumberOfColumns, public
//
//  Synopsis:   sets the number of columns in the output
//
//  Arguments:  [cCol] -- number of output columns
//
//  Notes:      Used after all columns have been set with
//              SetColumn().
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetNumberOfColumns( unsigned int cCol )
{
    if( cCol < _nColumns )
    {
        for( ; cCol < _nColumns; cCol++ )
        {
            delete [] _pwcsColumns[ cCol ];
            _pwcsColumns[ cCol ] = 0;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::NumberOfColumns, public
//
//  Synopsis:   Returns the number of output columns
//
//  History:    31-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

unsigned int CCatState::NumberOfColumns() const
{
    unsigned int cCol;

    for( cCol = 0; cCol < _nColumns; cCol++ )
    {
        if( _pwcsColumns[ cCol ] == 0 )
            break;
    }

    return cCol;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetSortProp, public
//
//  Synopsis:   Sets a property for sorting
//
//  Arguments:  [wcsProp] -- friendly property name
//              [sd] -- sort direction
//              [uPos] -- 0-based sort order
//
//  Notes:      Makes its own copy of the property name.
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetSortProp( WCHAR const * wcsProp, SORTDIR sd, unsigned int uPos )
{
    // does _psi need to be extended?
    if( uPos >= _nSort )
    {
        SSortInfo * psiTemp = new SSortInfo[ uPos + 1 ];

        unsigned int cProp;

        // copy the old entries and 0 any new ones
        for( cProp = 0; cProp < uPos + 1; cProp++ )
        {
            if( cProp < _nSort )
                psiTemp[ cProp ] = _psi[ cProp ];
            else
                psiTemp[ cProp ].wcsProp = 0;
        }

        delete [] _psi;

        _nSort = uPos + 1;
        _psi = psiTemp;
    }

    // free any previous property string
    delete [] _psi[ uPos ].wcsProp;

    // copy & set the column
    if( wcsProp == 0 )
    {
        _psi[ uPos ].wcsProp = 0;
    }
    else
    {
        int iLength = wcslen( wcsProp ) + 1;

        _psi[ uPos ].wcsProp = new WCHAR[ iLength ];
        memcpy( _psi[ uPos ].wcsProp, wcsProp, iLength * sizeof(WCHAR) );
    }

    _psi[ uPos ].sd = sd;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetNumberOfSortProps, public
//
//  Synopsis:   sets the number of sort keys
//
//  Arguments:  [cProp] -- number of sort keys
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::SetNumberOfSortProps( unsigned int cProp )
{
    if( cProp < _nSort )
    {
        for( ; cProp < _nSort; cProp++ )
        {
            delete [] _psi[ cProp ].wcsProp;
            _psi[ cProp ].wcsProp = 0;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::GetSortProp, public
//
//  Synopsis:   Returns sort information about a specific key
//
//  Arguments:  [uPos] -- 0-based sort ordinal (ie uPos=0 gives the primary sort key)
//              [*pwcsName] -- friendly name of the property
//              [*psd] -- sort order for this property
//
//  Notes:      Only returns a pointer the string; does not copy it.
//              Returns 0 in *pwcsName if uPos is out of range.
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CCatState::GetSortProp( unsigned int uPos,
                             WCHAR const ** pwcsName,
                             SORTDIR * psd ) const
{
    if( uPos >= _nColumns )
    {
        if( pwcsName )
            *pwcsName = 0;
    }
    else
    {
        if( pwcsName )
            *pwcsName = _psi[ uPos ].wcsProp;
        if( psd )
            *psd = _psi[ uPos ].sd;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatState::NumberOfSortProps, public
//
//  Synopsis:   Returns the number of sort keys
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

unsigned int CCatState::NumberOfSortProps() const
{
    unsigned int cProp;

    for( cProp = 0; cProp < _nSort; cProp++ )
    {
        if( _psi[ cProp ].wcsProp == 0 )
            break;
    }

    return cProp;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetLocale, public
//
//  Synopsis:   Sets the new locale
//
//  Arguments:  [wcsLocale] -- Three letter abbreviation of locale
//
//  History:    29-Nov-94   SitaramR     Created
//
//----------------------------------------------------------------------------

void CCatState::SetLocale(WCHAR const *wcsLocale )
{
    WCHAR wszAbbrev[6];
    LCID lcid;

    // check for neutral langauge and neutral sub language
    if ( _wcsicmp( wcsLocale, L"neutral" ) == 0 )
    {
        _lcid = 0;
        return;
    }

    // decreasing for-loops, because we want to match  LANG_NEUTRAL and
    //    SUBLANG_NEUTRAL, which are 0, last
    for ( INT lang=0x20; lang>-1; lang-- )
        for ( INT subLang=7; subLang>-1; subLang-- )
            for ( unsigned sort=0; sort<2; sort++ )
            {
                lcid = MAKELCID( MAKELANGID( lang, subLang), sort );
                if ( GetLocaleInfoW( lcid, LOCALE_SABBREVLANGNAME, wszAbbrev, 6) )
                {
                    if ( _wcsicmp( wcsLocale, wszAbbrev ) == 0 )
                    {
                        _lcid = lcid;
                        return;
                    }
                }
            }
    THROW( CException( STATUS_INVALID_PARAMETER ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatState::SetCategory, public
//
//  Synopsis:   Sets the new category
//
//  Arguments:  [wcsCategory] -- friendly category name
//              [uPos]        -- position of category
//
//  History:    21-Aug-95   SitaramR     Created
//
//----------------------------------------------------------------------------

void CCatState::SetCategory( WCHAR const *pwcsCategory, unsigned uPos )
{
    Win4Assert( pwcsCategory );

    CString *pString = new CString( pwcsCategory );
    _aCategories.Add( pString, uPos );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatState::GetCategory, public
//
//  Synopsis:   Returns the required category
//
//  Arguments:  [uPos] -- position of category
//
//  History:    21-Aug-95   SitaramR     Created
//
//----------------------------------------------------------------------------

WCHAR const *CCatState::GetCategory( unsigned uPos ) const
{
    Win4Assert( uPos < _cCategories );

    CString *pString = _aCategories.Get( uPos );
    if ( pString )
        return pString->GetString();
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\cgiesc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       cgiesc.cxx
//
//  Contents:   WEB CGI escape & unescape classes
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cgiesc.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   DecodeURLEscapes - Decode URL escapes
//
//  Synopsis:   Removes the escape characters from a string, converting to
//              Unicode along the way.
//
//  Arguments:  [pIn]        - string to convert
//              [l]          - length of string in chars, updated on return
//              [pOut]       - converted string
//              [ulCodePage] - code page for translation
//
//----------------------------------------------------------------------------

void DecodeURLEscapes( BYTE * pIn, ULONG & l, WCHAR * pOut, ULONG ulCodePage )
{
    WCHAR * p2 = pOut;
    WCHAR c1;
    WCHAR c2;

    XArray<BYTE> xDeferBuf;
    BYTE * pDefer = 0;

    ULONG l2 = l;

    for( ; l2; l2-- )
    {
        BOOL fSaveAsUnicode = FALSE;

        //  Convert ASCII to corresponding character
        //  If Latin-1 character, save for MB translation, accumulate char
        //  If Unicode escape, flush accumulated chars and save converted char

        c1 = *pIn;

        //
        //  Spaces are escaped by converting them into plus signs.
        //  Convert them back.
        //
        if ( c1 == '+' )
        {
            c1 = ' ';
            pIn++;
        }
        else if (c1 == '%')
        {
            //
            //  Special characters are converted to values of the format %XY
            //  where XY is the HEX code for the ASCII character.
            //
            //  A percent sign is transmitted as %%.
            //
            if (*(pIn+1) == '%')
            {
               c1 = '%';
               pIn += 2;
               l2--;
            }
            else if (l2 >= 3)
            {
                pIn++;
                c1 = (WCHAR) toupper(*pIn);
                c2 = (WCHAR) toupper(*(pIn+1));

                if ( c1 == 'U' && l2 >= 6 )
                {
                    // Unicode escape, %uxxxx
                    c1 = c2;
                    c2 = (WCHAR) toupper(*(pIn+2));
                    WCHAR c3 = (WCHAR) toupper(*(pIn+3));
                    WCHAR c4 = (WCHAR) toupper(*(pIn+4));
                    if ( isxdigit( c1 ) && isxdigit( c2 ) &&
                         isxdigit( c3 ) && isxdigit( c4 ) )
                    {
                        c1  = ((c1 >= 'A') ? (c1-'A')+10 : c1-'0') << 12;
                        c1 += ((c2 >= 'A') ? (c2-'A')+10 : c2-'0') << 8;
                        c1 += ((c3 >= 'A') ? (c3-'A')+10 : c3-'0') << 4;
                        c1 += ((c4 >= 'A') ? (c4-'A')+10 : c4-'0');

                        if ( pDefer )
                        {
                            unsigned cchDefer = CiPtrToUint( pDefer - xDeferBuf.GetPointer() );

                            cchDefer = MultiByteToWideChar( ulCodePage,
                                                            0,
                                                   (char *) xDeferBuf.GetPointer(),
                                                            cchDefer,
                                                            p2,
                                                            cchDefer );

                            Win4Assert( cchDefer != 0 );
                            pDefer = 0;
                            p2 += cchDefer;
                        }
                        pIn += 5;
                        l2 -= 5;
                        fSaveAsUnicode = TRUE;
                    }
                    else
                    {
                        c1 = '%';
                    }
                }
                else if ( isxdigit( c1 ) && isxdigit( c2 ) )
                {
                    c1 = ( ((c1 >= 'A') ? (c1-'A')+10 : c1-'0')*16 +
                           ((c2 >= 'A') ? (c2-'A')+10 : c2-'0') );
                    pIn += 2;
                    l2 -= 2;
                    if ( c1 >= 0x80 && 0 == pDefer )
                    {
                        // The character needs to be deferred for MBCS
                        // translation.
                        if (xDeferBuf.GetPointer() == 0)
                        {
                            xDeferBuf.Init( l2+1 );
                        }
                        pDefer = xDeferBuf.GetPointer();
                    }
                }
                else
                    c1 = '%';
            }
            else
            {
                pIn++;
                if ( c1 >= 0x80 && 0 == pDefer )
                {
                    // The character needs to be deferred for MBCS
                    // translation.
                    if (xDeferBuf.GetPointer() == 0)
                    {
                        xDeferBuf.Init( l2+1 );
                    }
                    pDefer = xDeferBuf.GetPointer();
                }
            }
        }
        else
        {
            pIn++;
        }

        if (! fSaveAsUnicode)
        {
            if ( c1 >= 0x80 && 0 == pDefer )
            {
                // The character needs to be deferred for MBCS
                // translation.
                if (xDeferBuf.GetPointer() == 0)
                {
                    xDeferBuf.Init( l2+1 );
                }
                pDefer = xDeferBuf.GetPointer();
            }
        }
        else
        {
            Win4Assert( pDefer == 0 );
        }

        if (pDefer)
        {
            Win4Assert( c1 < 0x100 );
            *pDefer++ = (BYTE) c1;
        }
        else
        {
            *p2++ = c1;
        }
    }

    if ( pDefer )
    {
        unsigned cchDefer = CiPtrToUint( pDefer - xDeferBuf.GetPointer() );

        cchDefer = MultiByteToWideChar( ulCodePage,
                                        0,
                               (char *) xDeferBuf.GetPointer(),
                                        cchDefer,
                                        p2,
                                        cchDefer );

        Win4Assert( cchDefer != 0 );
        pDefer = 0;
        p2 += cchDefer;
    }
    *p2 = 0;
    l = CiPtrToUlong( p2 - pOut );
}


void DecodeEscapes( WCHAR * p, ULONG & l )
{
    DecodeEscapes( p, l, p );
}

void DecodeEscapes( WCHAR * pIn, ULONG & l, WCHAR * pOut )
{
    WCHAR * p2;
    int c1;
    int c2;
    ULONG l2 = l;

    for( p2=pOut; l2; l2-- )
    {
        //
        //  Spaces are escaped by converting them into plus signs.
        //  Convert them back.
        //
        if ( *pIn == L'+' )
        {
            *p2++ = L' ';
            pIn++;
        }
        else if (*pIn == L'%')
        {
            //
            //  Special characters are converted to values of the format %XY
            //  where XY is the HEX code for the ASCII character.
            //
            //  A percent sign is transmitted as %%.
            //
            if (*(pIn+1) == L'%')
            {
               *p2++ = L'%';
               pIn += 2;
               l2--;
            }
            else if (l2 > 2)
            {
                pIn++;

                c1=towupper(*pIn);
                c2=towupper(*(pIn+1));

                if ( isxdigit( c1 ) && isxdigit( c2 ) )
                {
                    *p2++ = ( ((c1 >= L'A') ? (c1-L'A')+10 : c1-L'0')*16 +
                              ((c2 >= L'A') ? (c2-L'A')+10 : c2-L'0')
                            );
                    pIn += 2;
                    l2 -= 2;
                }
                else
                    *p2++ = L'%';
            }
            else
            {
                *p2++ = *pIn++;
            }
        }
        else
        {
            *p2++ = *pIn++;
        }
    }

    *p2 = 0;
    l = CiPtrToUlong( p2 - pOut );
}

//+---------------------------------------------------------------------------
//
//  Function:   DecodeHtmlNumeric - decode HTML numeric entity
//
//  Synopsis:   Looks for sequences like "&#12345;" and converts in-place
//              to a single unicode character.
//
//  Arguments:  [pIn] - string to convert
//
//----------------------------------------------------------------------------

void DecodeHtmlNumeric( WCHAR * pIn )
{
    pIn = wcschr( pIn, L'&' );
    WCHAR * p2 = pIn;

    while (pIn && *pIn)
    {
        if (*pIn == L'&' && pIn[1] == L'#')
        {
            pIn += 2;
            USHORT ch = 0;
            while (*pIn && *pIn != L';')
            {
                if (*pIn >= L'0' && *pIn <= L'9')
                    ch = ch*10 + (*pIn - L'0');
                pIn++;
            }
            if (*pIn)
                pIn++;
            *p2++ = ch;
        }
        else
        {
            *p2++ = *pIn++;
        }
    }

    if (p2)
        *p2 = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\caturl.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       caturl.cxx
//
//  Contents:   Functions dealing with catalog URLs
//
//  History:    12 Mar 1997    AlanW    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <caturl.hxx>

const WCHAR achQueryProtocol[] = L"query:";
const unsigned cchQueryProtocol = (sizeof achQueryProtocol /
                                     sizeof achQueryProtocol[0]) - 1;

//+---------------------------------------------------------------------------
//
//  Function:   ParseCatalogURL - public
//
//  Synopsis:   Parse a catalog URL into its machine and catalog components
//
//  Arguments:  [pwszInput] - the string containing the catalog URL
//              [xpCatalog] - pointer where catalog is returned if any
//              [xpMachine] - pointer where machine is returned if any
//
//  Notes:      If there is no machine name specified, the default machine
//              name ( "." ) is used.
//
//  History:    12 Mar 1997    AlanW    Created
//
//----------------------------------------------------------------------------

SCODE ParseCatalogURL( const WCHAR * pwszInput,
                       XPtrST<WCHAR> & xpCatalog,
                       XPtrST<WCHAR> & xpMachine )
{
    Win4Assert( 0 != pwszInput );

    if (_wcsnicmp( pwszInput, achQueryProtocol, cchQueryProtocol ) == 0 )
    {
        //
        //  It's in the URL format.  Find the machine and catalog.
        //
        pwszInput += cchQueryProtocol;

        if (pwszInput[0] == L'/' && pwszInput[1] == L'/')
        {
            // Get the machine string and save a copy

            pwszInput += 2;
            const WCHAR * pwszMachEnd = wcschr( pwszInput, L'/' );
            if ( 0 == pwszMachEnd )
                pwszMachEnd = pwszInput + wcslen( pwszInput );

            WCHAR * pwszTmp = new WCHAR[ (size_t)(pwszMachEnd - pwszInput) + 1 ];

            xpMachine.Free();
            xpMachine.Set(pwszTmp);
            RtlCopyMemory( pwszTmp, pwszInput, (pwszMachEnd-pwszInput) * sizeof (WCHAR) );
            pwszTmp[ pwszMachEnd-pwszInput ] = L'\0';
            pwszInput = pwszMachEnd;
        }
        else
        {
            xpMachine.Free();
        }

        if (pwszInput[0] == L'/')
            pwszInput++;
    }
    else
    {
        xpMachine.Free();
    }

    //
    //  The rest of the string is just the catalog name.
    //

    if (pwszInput[0] != L'\0')
    {
        // Get the catalog string and save a copy

        unsigned cch = wcslen( pwszInput );

        WCHAR * pwszTmp = new WCHAR[ cch + 1 ];

        xpCatalog.Free();
        xpCatalog.Set(pwszTmp);
        RtlCopyMemory( pwszTmp, pwszInput, cch * sizeof (WCHAR) );
        pwszTmp[ cch ] = L'\0';
    }
    else
    {
        xpCatalog.Free();
    }

    //
    //  If no machine was specified, use the local machine
    //
    if ( 0 == xpMachine.GetPointer() )
    {
        ULONG cwc = 1 + wcslen( CATURL_LOCAL_MACHINE );
        xpMachine.Set( new WCHAR[ cwc ] );
        wcscpy( xpMachine.GetPointer(), CATURL_LOCAL_MACHINE );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\gibralt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:   gibralt.cxx
//
//  Contents:   Abstraction of the interface to gibraltar
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <gibralt.hxx>
#include <cgiesc.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CWebServer::GetPhysicalPath - public
//
//  Synopsis:   Converts a virtual path to a physical path
//
//  Arguments:  [wcsVirtualPath]  - virtual path to convert
//              [wcsPhysicalPath] - resulting physical path
//              [cwcPhysicalPath] - length of string
//              [dwAccessMask]    - HSE_URL_FLAGS_* required,
//                                  or 0 for any access
//
//  Returns:    Flags for the virtual path (HSE_URL_FLAGS_*)
//
//  History:    96/Feb/29   DwightKr    Created.
//
//----------------------------------------------------------------------------
DWORD CWebServer::GetPhysicalPath(
    WCHAR const * wcsVirtualPath,
    WCHAR *       wcsPhysicalPath,
    ULONG         cwcPhysicalPath,
    DWORD         dwAccessMask )
{
    Win4Assert( 0 != wcsVirtualPath );

    ULONG cwcVirtualPath = wcslen( wcsVirtualPath ) + 1;

    //
    // We only support paths up to MAX_PATH for now
    //

    if ( cwcVirtualPath >= ( MAX_PATH - 1 ) )
        THROW( CException( QUTIL_E_CANT_CONVERT_VROOT ) );

    CHAR  pszVirtualPath[_MAX_PATH];
    ULONG cbVirtualPath = _MAX_PATH;

    ULONG cbConverted = ::WideCharToMultiByte( _codePage,
                                               WC_COMPOSITECHECK,
                                               wcsVirtualPath,
                                               cwcVirtualPath,
                                     (CHAR *)  pszVirtualPath,
                                               cbVirtualPath,
                                               NULL,
                                               NULL );

    HSE_URL_MAPEX_INFO MapInfo;
    DWORD cbMappedPath = sizeof pszVirtualPath;

    //
    // Note: if the mapped path is >= MAX_PATH the function succeeds and
    // truncates the physical path without null-terminating it.  But
    // the mapped size is > MAX_PATH, so key off that to check for overflow.
    //

    if ( (0 == cbConverted) ||
         ( !_pEcb->ServerSupportFunction( _pEcb->ConnID,
                                          HSE_REQ_MAP_URL_TO_PATH_EX,
                                          pszVirtualPath,
                                          &cbMappedPath,
                                          (PDWORD) &MapInfo ) ) ||
         ( cbMappedPath >= ( _MAX_PATH - 1 ) ) ||
         ( ( 0 != dwAccessMask ) &&
           (  0 == ( dwAccessMask & MapInfo.dwFlags ) ) )
       )
    {
        //
        // We could not translate the virtual path to a real path,
        // or the access permissions didn't match, so this must be a
        // bogus virtual path.
        //

        qutilDebugOut(( DEB_ERROR,
                        "Could not translate vpath=>ppath, mask 0x%x, flags 0x%x, '%ws'\n",
                        dwAccessMask, MapInfo.dwFlags, wcsVirtualPath ));
        THROW( CException( QUTIL_E_CANT_CONVERT_VROOT ) );
    }

    if ( 0 == MultiByteToWideChar( _codePage,
                                   0,
                                   MapInfo.lpszPath,
                                   strlen( MapInfo.lpszPath) + 1,
                                   wcsPhysicalPath,
                                   cwcPhysicalPath) )
    {
        //
        //  We could not translate the ASCII string to WCHAR
        //

        qutilDebugOut(( DEB_ERROR,
                        "Gibraltar could not convert ppath to unicode '%ws'\n",
                        wcsVirtualPath ));
        THROW( CException( QUTIL_E_CANT_CONVERT_VROOT ) );
    }

    return MapInfo.dwFlags;
} //GetPhysicalPath

//+---------------------------------------------------------------------------
//
//  Member:     CWebServer::GetCGIVariable - public
//
//  Synopsis:   Gets the CHAR version of a CGI variable
//
//  Arguments:  [pszVariableName] - name of variable to lookup
//              [wcsValue]        - resulting variable
//              [cwcValue]        - length of variable
//
//  History:    96/Feb/29   DwightKr    Created.
//
//----------------------------------------------------------------------------
BOOL CWebServer::GetCGIVariable( CHAR const * pszVariableName,
                                 XArray<WCHAR> & wcsValue,
                                 ULONG & cwcValue )
{
    Win4Assert ( IsValid() );

    BYTE pbBuffer[512];
    ULONG cbBuffer = sizeof( pbBuffer );

    if ( !_pEcb->GetServerVariable( _pEcb->ConnID,
                          (char *)  pszVariableName,
                                    pbBuffer,
                                   &cbBuffer ) )
    {
        return FALSE;
    }

    cwcValue = MultiByteToXArrayWideChar(
                          (BYTE * const) pbBuffer,
                                         cbBuffer,
                                         _codePage,
                                         wcsValue );

    return cwcValue > 0;
} //GetCGIVariable

//+---------------------------------------------------------------------------
//
//  Member:     CWebServer::GetCGIVariable - public
//
//  Synopsis:   Gets the WCHAR version of a CGI variable
//
//  Arguments:  [wcsVariableName] - name of variable to lookup
//              [wcsValue]        - resulting variable
//              [cwcValue]        - length of variable (out only)
//
//  History:    96/Mar/29   DwightKr    Created.
//
//----------------------------------------------------------------------------
BOOL CWebServer::GetCGIVariableW( WCHAR const * wcsVariableName,
                                  XArray<WCHAR> & wcsValue,
                                  ULONG & cwcBuffer )
{
    ULONG cwcVariableName = wcslen( wcsVariableName ) + 1;
    XArray<BYTE> pszVariableName( cwcVariableName*2 );

    if ( 0 == WideCharToXArrayMultiByte( wcsVariableName,
                                         cwcVariableName,
                                         _codePage,
                                         pszVariableName )
       )
    {
        //
        //  We could not translate the WCHAR string to ASCII
        //

        return FALSE;
    }

    return GetCGIVariable( (const char *) pszVariableName.GetPointer(),
                           wcsValue,
                           cwcBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\fmapio.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:   fmapio.cxx
//
//  Contents:   A class to read lines from a unicode or an ascii file.
//
//  History:    96/Jan/3    DwightKr    Created
//              Aug 20 1996 SrikantS    Moved from web
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CFileMapView::CFileMapView - public
//
//  Synopsis:   Maps a file in its entirety
//
//  Arguments:  [wcsFileName] - full path of file to map
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CFileMapView::CFileMapView( WCHAR const * wcsFileName ) :
                           _hFile(INVALID_HANDLE_VALUE),
                           _hMap(0),
                           _pbBuffer(0),
                           _cbBuffer(0),
                           _IsUnicode(FALSE)
{
    //
    //  Open the file
    //

    _hFile = CreateFile( wcsFileName,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         0,
                         OPEN_EXISTING,
                         0,
                         0 );


    if ( INVALID_HANDLE_VALUE == _hFile )
    {
        qutilDebugOut(( DEB_IWARN, "Unable to open %ws for mapping\n", wcsFileName ));
        THROW( CException() );
    }

    _cbBuffer = GetFileSize( _hFile, 0 );

    END_CONSTRUCTION(CFileMapView);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileMapView::~CFileMapView - public
//
//  Synopsis:   Release handles & unmap file
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CFileMapView::~CFileMapView()
{
    if ( 0 != _pbBuffer )
    {
        UnmapViewOfFile( _pbBuffer );
    }

    if ( 0 != _hMap )
    {
        CloseHandle( _hMap );
    }

    if ( INVALID_HANDLE_VALUE != _hFile )
    {
        CloseHandle( _hFile );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileMapView::Init - public
//
//  Synopsis:   Maps the file
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CFileMapView::Init()
{
    //
    //  Create a map of the file
    //
    _hMap = CreateFileMapping( _hFile,
                               0,
                               PAGE_READONLY,
                               0,
                               _cbBuffer,
                               0 );

    if ( 0 == _hMap )
    {
        qutilDebugOut(( DEB_IWARN, "CreateFileMapping failed\n" ));
        THROW( CException() );
    }

    _pbBuffer = (BYTE *) MapViewOfFile( _hMap,
                                        FILE_MAP_READ,
                                        0,
                                        0,
                                        _cbBuffer );

    if ( 0 == _pbBuffer )
    {
        qutilDebugOut(( DEB_IWARN, "MapViewOfFile failed\n" ));
        THROW( CException() );
    }

    _IsUnicode = (GetBufferSize() > 3) &&    // At least one unicode character
                 (_pbBuffer[0] == 0xFF) &&   // Begins with OxFF 0xFE
                 (_pbBuffer[1] == 0xFE) &&
                 ((GetBufferSize() & 1) == 0); // Must be an even # of bytes

}

//+---------------------------------------------------------------------------
//
//  Member:     CFileBuffer::CFileBuffer - public
//
//  Synopsis:   Constructor
//
//  Arguments:  [fileMap]  - a mapped file
//
//  History:    96/May/06   DwightKr    created
//
//----------------------------------------------------------------------------
CFileBuffer::CFileBuffer( CFileMapView & fileMap,
                          UINT codePage )
{
    //
    //  We need to return unicode data from methods of this class.  If the file
    //  contains ASCII data, convert it to unicode here.
    //

    if ( !fileMap.IsUnicode() )
    {
        _cwcFileBuffer = MultiByteToXArrayWideChar( fileMap.GetBuffer(),
                                                    fileMap.GetBufferSize(),
                                                   codePage,
                                                   _pwBuffer );

        _wcsNextLine   = _pwBuffer.Get();
    }
    else
    {
        //
        //  We have a unicode file.  Skip past the leading 0xFF - 0xFE bytes
        //
        _wcsNextLine   = (WCHAR *) (fileMap.GetBuffer() + 2);
        _cwcFileBuffer = (fileMap.GetBufferSize() - 2) / sizeof(WCHAR);
    }

    END_CONSTRUCTION(CFileBuffer);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileBuffer::fgetsw - public
//
//  Synopsis:   Gets the next line from the file
//
//  Arguments:  [wcsLine]  - buffer to return next line into
//              [cwcLine]  - size of the buffer in characters
//
//  History:    96/May/06   DwightKr    created
//
//----------------------------------------------------------------------------
ULONG CFileBuffer::fgetsw( XGrowable<WCHAR> & xLine )
{
    ULONG cwcCopied = 0;

    //
    //  Copy characters upto either cwcLine, a CR, or the end of
    //  the string.
    //

    while ( (_cwcFileBuffer > 0) )
    {
        xLine.SetSize( cwcCopied + 1 );
        xLine[ cwcCopied] = *_wcsNextLine;
        cwcCopied++;

        _wcsNextLine++;
        _cwcFileBuffer--;

        //
        //  If we just copied over a CR, then break out of the
        //  loop; we've found the end of a line.
        //

        if ( L'\n' == xLine[ cwcCopied - 1] )
        {
            break;
        }
    }

    xLine.SetSize( cwcCopied + 1 );
    xLine[ cwcCopied ] = 0;               // Null terminate

    return cwcCopied;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\doquery.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       DOQUERY.CXX
//
//  Contents:   Functions to make query nodes and trees, and to execute
//              queries.
//
//  History:    02 Nov 94   alanw     Created from main.cxx and screen.cxx.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <doquery.hxx>
#include <catstate.hxx>

static const GUID guidBmk =       DBBMKGUID;

static const GUID psGuidStorage = PSGUID_STORAGE;

static const GUID psGuidQuery = DBQUERYGUID;

static const GUID guidQueryExt = DBPROPSET_QUERYEXT;
static const GUID guidRowset = DBPROPSET_ROWSET;

static CDbColId psRank( psGuidQuery, DISPID_QUERY_RANK );
static CDbColId psBookmark( guidBmk, PROPID_DBBMK_BOOKMARK );
static CDbColId psPath( psGuidStorage, PID_STG_PATH );

//+---------------------------------------------------------------------------
//
//  Function:   FormTableNode
//
//  Synopsis:   Forms a selection node and if needed a sort node
//
//  Arguments:  [rst]    - Restriction tree describing the query
//              [states] - global state info
//              [plist]  - friendly property name list
//
//  Returns:    A pointer to a commandtree node
//
//  History:    9-4-95   SitaramR   Created
//
//----------------------------------------------------------------------------

CDbCmdTreeNode *FormTableNode(
    CDbCmdTreeNode & rst,
    CCatState &      states,
    IColumnMapper *  plist )
{
    //
    // First create a selection node and append the restriction tree to it
    //
    XPtr<CDbSelectNode> xSelect( new CDbSelectNode() );

    if ( xSelect.IsNull() || !xSelect->IsValid() )
        THROW( CException( STATUS_NO_MEMORY ) );

    //
    // Clone the restriction and use it.
    //
    CDbCmdTreeNode * pExpr = rst.Clone();
    if ( 0 == pExpr )
    {
        THROW( CException( STATUS_NO_MEMORY ) );
    }

    //
    // Now make the restriction a child of the selection node.
    //
    xSelect->SetRestriction( pExpr );

    XPtr<CDbCmdTreeNode> xTable;

    unsigned int cSortProp = states.NumberOfSortProps();
    if ( cSortProp > 0 )
    {
        CDbSortNode * pSort = new CDbSortNode();
        if ( 0 == pSort )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        XPtr<CDbCmdTreeNode> xSort( pSort );

        for( unsigned i = 0; i < cSortProp; i++ )
        {
            WCHAR const * wcsName;
            SORTDIR sd;

            states.GetSortProp( i,
                                &wcsName,
                                &sd );

            DBID *pdbid = 0;
            if( FAILED(plist->GetPropInfoFromName( wcsName,
                                    &pdbid,
                                    0,
                                    0 )) )
                THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_SORT ) );

            //
            // Add the sort column.
            //
            CDbColId *pprop = (CDbColId *)pdbid;
            if ( !pSort->AddSortColumn( *pprop,
                                        (sd == SORT_DOWN) ? TRUE : FALSE,
                                        states.GetLocale()))
            {
                THROW( CException( STATUS_NO_MEMORY ) );
            }
        }

        if ( pSort->AddTable( xSelect.GetPointer() ) )
            xSelect.Acquire();
        else
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        xTable.Set( xSort.Acquire() );
    }
    else
        xTable.Set( xSelect.Acquire() );

    return xTable.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Function:   FormQueryTree
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              selection node, sort node(s) and the restriction tree.
//
//  Arguments:  [rst]    - Restriction tree describing the query
//              [states] - global state info
//              [plist]  - friendly property name list
//
//  Returns:    A pointer to the query tree. It is the responsibility of
//              the caller to later free it.
//
//  History:    6-20-95   srikants   Created
//
//----------------------------------------------------------------------------

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode & rst,
                                CCatState & states,
                                IColumnMapper * plist,
                                BOOL fAddBmkCol,
                                BOOL fAddRankForBrowse )
{
    CDbCmdTreeNode *pTable = FormTableNode( rst, states, plist );
    XPtr<CDbCmdTreeNode> xTable( pTable );

    XPtr<CDbCmdTreeNode> xQuery;

    unsigned cCategories = states.NumberOfCategories();
    if ( cCategories > 0 )
    {
        //
        // First create nesting node for the base table
        //
        CDbNestingNode *pNestNodeBase = new CDbNestingNode;
        if ( pNestNodeBase == 0 )
            THROW ( CException( STATUS_NO_MEMORY ) );

        XPtr<CDbCmdTreeNode> xNestNodeBase( pNestNodeBase );

        BOOL fNeedPath = TRUE;
        BOOL fNeedRank = fAddRankForBrowse;

        //
        // Next add all the columns in the state.
        //
        CDbColId * pprop = 0;
        DBID *pdbid = 0;

        unsigned int cCol = states.NumberOfColumns();
        for ( unsigned int i = 0; i < cCol; i++ )
        {
            if( FAILED(plist->GetPropInfoFromName( states.GetColumn( i ),
                                    &pdbid,
                                    0,
                                    0 )) )
                THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_OUTPUT ) );

            pprop = (CDbColId *)pdbid;
            if ( *pprop == psPath )
            {
                fNeedPath = FALSE;
            }
            else if ( *pprop == psRank )
            {
                fNeedRank = FALSE;
            }

            if ( !pNestNodeBase->AddChildColumn( *pprop ) )
            {
                THROW( CException( STATUS_NO_MEMORY ) );
            }
        }

        if ( fNeedPath && !pNestNodeBase->AddChildColumn( psPath ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        if ( fNeedRank && !pNestNodeBase->AddChildColumn( psRank ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        //
        // Add categories to the output column
        //
        for ( i = 0; i < cCategories; i++ )
        {
            //
            // We need to ensure that we don't add categories that have already been
            // added above. The following test can be speeded up from O( i*j ) to O( i+j ),
            // but the the number of categories and the number of columns are usually very small.
            //
            BOOL fFound = FALSE;
            for ( unsigned j=0; j<states.NumberOfColumns(); j++ )
            {
                if ( _wcsicmp( states.GetCategory(i), states.GetColumn( j ) ) == 0 )
                {
                    fFound = TRUE;
                    break;
                }
            }

            if ( !fFound )
            {
                if( FAILED(plist->GetPropInfoFromName( states.GetCategory( i ),
                                        &pdbid,
                                        0,
                                        0 )) )
                    THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_CATEGORIZATION ) );

                pprop = (CDbColId *)pdbid;
                if ( !pNestNodeBase->AddChildColumn( *pprop ) )
                    THROW( CException( STATUS_NO_MEMORY ) );
            }
        }

        if ( pNestNodeBase->AddTable( xTable.GetPointer() ) )
            xTable.Acquire();
        else
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        if ( FAILED(plist->GetPropInfoFromName( states.GetCategory( cCategories - 1 ),
                                 &pdbid,
                                 0,
                                 0 )) )
            THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_OUTPUT ) );

        pprop = (CDbColId *)pdbid;
        if ( !pNestNodeBase->AddGroupingColumn( *pprop ) )
            THROW( CException( STATUS_NO_MEMORY ) );

        if ( !pNestNodeBase->AddParentColumn( *pprop ) )
            THROW( CException( STATUS_NO_MEMORY ) );

        if ( !pNestNodeBase->AddParentColumn( psBookmark ) )
            THROW( CException( STATUS_NO_MEMORY ) );

        //
        // Now create the nesting nodes for remaining categories, if any
        //
        XPtr<CDbCmdTreeNode> xCategChild( xNestNodeBase.Acquire() );

        for ( int j=cCategories-2; j>=0; j-- )
        {
            if ( FAILED(plist->GetPropInfoFromName( states.GetCategory( j ),
                                     &pdbid,
                                     0,
                                     0 )) )
            {
                THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_OUTPUT ) );
            }

            pprop = (CDbColId *)pdbid;
            CDbNestingNode *pCategParent = new CDbNestingNode;
            if ( pCategParent == 0 )
                THROW( CException( STATUS_NO_MEMORY ) );

            XPtr<CDbCmdTreeNode> xCategParent( pCategParent );

            if ( pCategParent->AddTable( xCategChild.GetPointer() ) )
                xCategChild.Acquire();
            else
            {
                THROW( CException( STATUS_NO_MEMORY ) );
            }

            if ( !pCategParent->AddGroupingColumn( *pprop ) )
                THROW( CException( STATUS_NO_MEMORY ) );

            if ( !pCategParent->AddParentColumn( *pprop ) )
                THROW( CException( STATUS_NO_MEMORY ) );

            if ( !pCategParent->AddParentColumn( psBookmark ) )
                THROW( CException( STATUS_NO_MEMORY ) );

            xCategChild.Set( xCategParent.Acquire() );
        }

        xQuery.Set( xCategChild.Acquire() );
    }
    else
    {
        //
        // Create the projection node
        //
        CDbProjectNode * pProject = new CDbProjectNode();
        if ( 0 == pProject )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        XPtr<CDbCmdTreeNode> xProject( pProject );

        //
        // Add the selection/sort node
        //
        if ( pProject->AddTable( xTable.GetPointer() ) )
            xTable.Acquire();
        else
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        //
        // We query with two additional, but hidden, columns: path and rank,
        // because this information is needed by the browser (via Clipboard).
        // Care is taken in CRows::DisplayHeader and CRows::DisplayRows so that
        // the hidden columns are not displayed to the user
        //

        BOOL fNeedPath = TRUE;
        BOOL fNeedRank = fAddRankForBrowse;

        //
        // Next add all the columns in the state.
        //
        unsigned int cCol = states.NumberOfColumns();

        for ( unsigned int i = 0; i < cCol; i++ )
        {
            CDbColId * pprop = 0;
            DBID *pdbid = 0;

            if( FAILED(plist->GetPropInfoFromName( states.GetColumn( i ),
                                    &pdbid,
                                    0,
                                    0 )) )
                THROW( CQueryException( QUERY_UNKNOWN_PROPERTY_FOR_OUTPUT ) );

            pprop = (CDbColId *)pdbid;
            if ( *pprop == psPath )
            {
                fNeedPath = FALSE;
            }
            else if ( *pprop == psRank )
            {
                fNeedRank = FALSE;
            }

            if ( !pProject->AddProjectColumn( *pprop ) )
            {
                THROW( CException( STATUS_NO_MEMORY ) );
            }
        }


        if ( fNeedPath && !pProject->AddProjectColumn( psPath ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        if ( fNeedRank && !pProject->AddProjectColumn( psRank ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        if (fAddBmkCol &&  !pProject->AddProjectColumn( psBookmark ) )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        xQuery.Set( xProject.Acquire() );
    }

    CDbTopNode *pTop = 0;

    if ( states.IsMaxResultsSpecified() )
    {
        //
        // Use the top node to set a cap on the number of query results
        //
        pTop = new CDbTopNode();
        if ( pTop == 0 )
            THROW( CException( STATUS_NO_MEMORY ) );

        pTop->SetChild( xQuery.Acquire() );
        pTop->SetValue( states.GetMaxResults() );
    }

    //
    //  Set FirstRows here
    //
    if ( states.IsFirstRowsSpecified() )
    {
        CDbFirstRowsNode *pFR = new CDbFirstRowsNode();
        if ( pFR == 0 )
            THROW( CException( STATUS_NO_MEMORY ) );

        CDbCmdTreeNode *pChild = pTop ? pTop : xQuery.Acquire();
        pFR->SetChild( pChild );
        pFR->SetValue( states.GetFirstRows() );

        return pFR;
    }  

    if ( 0 != pTop )
        return pTop;
        
    return xQuery.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Function:   SetScopePropertiesNoThrow
//
//  Synopsis:   Sets rowset properties pertaining to scope on command object.
//
//  Arguments:  [pCmd]       -- Command object
//              [cDirs]      -- Number of elements in following arrays
//              [apDirs]     -- Array of scopes
//              [aulFlags]   -- Array of flags (depths)
//              [apCats]     -- Array of catalogs
//              [apMachines] -- Array of machines
//
//  Notes:      Either apDirs and aulFlags, or apCats and apMachines may be
//              NULL.
//
//  History:    03-Mar-1997    KyleP     Created
//              14-May-1997    mohamedn  use real BSTRs
//              19-May-1997    KrishnaN  Not throwing exceptions.
//
//----------------------------------------------------------------------------

SCODE SetScopePropertiesNoThrow( ICommand * pCmd,
                                unsigned cDirs,
                                WCHAR const * const * apDirs,
                                ULONG const *  aulFlags,
                                WCHAR const * const * apCats,
                                WCHAR const * const * apMachines )
{
    SCODE sc = S_OK;

    TRY
    {
        XInterface<ICommandProperties> xCmdProp;

        sc = pCmd->QueryInterface( IID_ICommandProperties, xCmdProp.GetQIPointer() );

        if ( FAILED( sc ) )
            return sc;

        //
        // It's expensive to convert all of these to BSTRs, but we have
        // to since our public API just takes regular strings.
        //

        CDynArrayInPlace<XBStr> aMachines(cDirs);
        CDynArrayInPlace<XBStr> aCatalogs(cDirs);
        CDynArrayInPlace<XBStr> aScopes(cDirs);
        unsigned i;

        //
        // init array of BSTRs of machines
        //

        if ( 0 != apMachines)
        {
            for ( i = 0; i < cDirs; i++ )
            {
                XBStr  xBstr;

                xBstr.SetText( (WCHAR *)apMachines[i]);
                aMachines.Add(xBstr,i);
                xBstr.Acquire();
            }
        }

        //
        // init array of BSTRs of catalogs
        //
        if ( 0 != apCats)
        {
            for ( i = 0; i < cDirs; i++ )
            {
                XBStr  xBstr;

                xBstr.SetText( (WCHAR *)apCats[i]);
                aCatalogs.Add(xBstr,i);
                xBstr.Acquire();
            }
        }

        //
        // init array of BSTRs of scopes
        //
        if ( 0 != apDirs)
        {
            for ( i = 0; i < cDirs; i++ )
            {
                XBStr  xBstr;

                xBstr.SetText( (WCHAR *)apDirs[i]);
                aScopes.Add(xBstr,i);
                xBstr.Acquire();
            }
        }

        SAFEARRAY saScope = { 1,                            // Dimension
                              FADF_AUTO | FADF_BSTR,        // Flags: on stack, contains BSTRs
                              sizeof(BSTR),                 // Size of an element
                              1,                            // Lock count.  1 for safety.
                              (void *) aScopes.GetPointer(),// The data
                              { cDirs, 0 } };               // Bounds (element count, low bound)

        SAFEARRAY saDepth = { 1,                            // Dimension
                              FADF_AUTO,                    // Flags: on stack
                              sizeof(LONG),                 // Size of an element
                              1,                            // Lock count.  1 for safety.
                              (void *)aulFlags,             // The data
                              { cDirs, 0 } };               // Bounds (element count, low bound)

        SAFEARRAY saCatalog = { 1,                          // Dimension
                                FADF_AUTO | FADF_BSTR,      // Flags: on stack, contains BSTRs
                                sizeof(BSTR),               // Size of an element
                                1,                          // Lock count.  1 for safety.
                                (void *) aCatalogs.GetPointer(), // The data
                                { cDirs, 0 } };             // Bounds (element count, low bound)

        SAFEARRAY saMachine = { 1,                          // Dimension
                                FADF_AUTO | FADF_BSTR,      // Flags: on stack, contains BSTRs
                                sizeof(BSTR),               // Size of an element
                                1,                          // Lock count.  1 for safety.
                                (void *) aMachines.GetPointer(), // The data
                                { cDirs, 0 } };             // Bounds (element count, low bound)


        DBPROP    aScopeProps[2] = {
                        { DBPROP_CI_INCLUDE_SCOPES ,   0, DBPROPSTATUS_OK, {0, DBKIND_GUID_PROPID, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saScope } },
                        { DBPROP_CI_DEPTHS         ,   0, DBPROPSTATUS_OK, {0, DBKIND_GUID_PROPID, 0}, { VT_I4   | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saDepth } } };

        DBPROP    aCatalogProps[1]  = {
                        { DBPROP_CI_CATALOG_NAME   ,   0, DBPROPSTATUS_OK, {0, DBKIND_GUID_PROPID, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saCatalog } } };


        DBPROP    aMachineProps[1]  = {
                        { DBPROP_MACHINE           ,   0, DBPROPSTATUS_OK, {0, DBKIND_GUID_PROPID, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saMachine } } };

        DBPROPSET aAllPropsets[3] = {
                      { aScopeProps,   2, DBPROPSET_FSCIFRMWRK_EXT   } ,
                      { aCatalogProps, 1, DBPROPSET_FSCIFRMWRK_EXT   } ,
                      { aMachineProps, 1, DBPROPSET_CIFRMWRKCORE_EXT } };

        DBPROPSET * pPropsets = 0;
        ULONG cPropsets = 0;

        if ( 0 != apDirs )
        {
            pPropsets = &aAllPropsets[0];
            cPropsets = 1;
        }
        else
        {
            pPropsets = &aAllPropsets[1];
        }


        if ( 0 != apCats && 0 != apMachines )
        {
            cPropsets += 2;
        }

        sc = xCmdProp->SetProperties( cPropsets, pPropsets );
    }
    CATCH(CException, e)
    {
        sc = GetOleError(e);
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetScopeProperties
//
//  Synopsis:   Sets rowset properties pertaining to scope on command object.
//
//  Arguments:  [pCmd]       -- Command object
//              [cDirs]      -- Number of elements in following arrays
//              [apDirs]     -- Array of scopes
//              [aulFlags]   -- Array of flags (depths)
//              [apCats]     -- Array of catalogs
//              [apMachines] -- Array of machines
//
//  History:    03-Mar-1997    KyleP     Created
//
//----------------------------------------------------------------------------

void SetScopeProperties( ICommand * pCmd,
                         unsigned cDirs,
                         WCHAR const * const * apDirs,
                         ULONG const *  aulFlags,
                         WCHAR const * const * apCats,
                         WCHAR const * const * apMachines )
{
    SCODE sc = SetScopePropertiesNoThrow(pCmd, cDirs, apDirs,
                                         aulFlags, apCats, apMachines);

    if (FAILED(sc))
        THROW( CException(sc) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\cpid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       cpid.cxx
//
//  Contents:   codepage functions
//
//  History:    97-Jun-09   t-elainc    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <gibralt.hxx>
#include <codepage.hxx>
#include <cphash.hxx>
#include <cpid.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   GetBrowserCodepage - public
//
//  Synposis:   returns the ULONG value of the codepage determined by the
//      query string
//
//  Arguments:  CWebServer & webServer, LCID locale
//
//  History:    97-Jun-09   t-elainc    Created
//
//----------------------------------------------------------------------------

ULONG GetBrowserCodepage( CWebServer & webServer, LCID locale )
{
    ULONG cpval=0;

    //first get value of CICodepage specified in the query string
    CHAR acCPString[20];

    //if a codepage string is specified
    if ( GetCodepageValue( webServer, acCPString, sizeof(acCPString) ) )
    {
        WCHAR awcCPString[100];
        unsigned int ccString = strlen( acCPString ) + 1;
        unsigned int numconverted = MultiByteToWideChar(CP_ACP, 0, acCPString, ccString, awcCPString, 100);

        //make sure everything was converted properly. Otherwise throw an exception
        if (ccString != numconverted)
        {
            THROW ( CException () );
        }

        //Check to see if the string is one of the values in the code page hash table
        BOOL valid = CCodePageTable::Lookup(awcCPString, wcslen(awcCPString), cpval);

        //code page string is not in the hash table
        if (!valid)
        {
            CHAR* pctmp;
            cpval = strtoul(acCPString, &pctmp, 10);

            //if the codepage value is not a number
            if (!cpval)
            {
                LCID lcid = GetLCIDFromString(awcCPString);

                //if the codepage value is not a legitimate lcid
                if (InvalidLCID == lcid)
                {
                    THROW ( CException (QUTIL_E_INVALID_CODEPAGE) );
                }

                //use the locale to determine the proper codepage
                cpval = LocaleToCodepage(lcid);
            }
        }
    }

    else //no codepage string specified, use locale to determine proper codepage
    {
        //ciGibDebugOut((DEB_ITRACE, "No codepage specified.  Using default codepage by locale."));
        cpval = LocaleToCodepage(locale);
    }

    return cpval;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCodePageValue
//
//  Synposis:   Returns the string contained withing the Query String that
//              specifies the codepage.  If no string is there, returns 0.
//
//  Arguments:  [webServer]  -- Web server
//              [pcCPString] -- String containing CiCodepage returned here
//              [ccCPString] -- Size (in chars) of [pcCPString]
//
//  Returns:    TRUE if a codepage parameter was found and fits in buffer.
//
//  History:    97-Jun-11   t-elainc    Created
//
//----------------------------------------------------------------------------

BOOL GetCodepageValue( CWebServer & webServer,
                       char * pcCPString,
                       unsigned ccCPString )
{
    unsigned ccValue = 0xFFFFFFFF;
    char* ISAPI_CI_CODEPAGE_A = "CICODEPAGE";

        char const * pcStart = webServer.GetQueryString();

    while ( 0 != pcStart && 0 != pcStart[0] )
    {
        if ( 0 == _strnicmp( pcStart,
                             ISAPI_CI_CODEPAGE_A,
                             strlen(ISAPI_CI_CODEPAGE_A) ) &&
             '=' == pcStart[strlen(ISAPI_CI_CODEPAGE_A)] )
            break;

        pcStart = strchr( pcStart, '&' );

        if ( 0 != pcStart )
            pcStart++;
    }

    if ( 0 != pcStart && 0 != pcStart[0] )
    {
        pcStart += strlen(ISAPI_CI_CODEPAGE_A)+1;  // sizeof includes null

        char* pcEnd = strchr(pcStart, '&');

        if (pcEnd)
            ccValue = CiPtrToUint( pcEnd - pcStart );
        else
            ccValue = strlen( pcStart );

        if ( ccValue < ccCPString )
        {
            strncpy( pcCPString, pcStart, ccValue );
            pcCPString[ccValue] = 0;
        }
    }

    return (ccValue < ccCPString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\htmlchar.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       htmlchar.cxx
//
//  Contents:   Contains a translate table from WCHAR to HTML WCHAR
//              Translates an WCHAR string to its HTML equivalent
//
//  History:    96/Jan/3    DwightKr    Created
//              19 Nov 1997 AlanW       Added missing named entities.  Allow
//                                      for outputing numeric entities if
//                                      codepage translation fails.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <htmlchar.hxx>

struct WCHAR_TO_HTML
{
    WCHAR * wszTranslated;
    ULONG   cchTranslated;
};

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
static const struct WCHAR_TO_HTML WCHAR_TO_HTML[] =
{
   L"never",           0xffffffff,        //   0  end-of-string
    0,                          0,        //   1
    0,                          0,        //   2
    0,                          0,        //   3
    0,                          0,        //   4
    0,                          0,        //   5
    0,                          0,        //   6
    0,                          0,        //   7
    0,                          0,        //   8
   L"\t",                       1,        //   9  tab
   L"\n",                       1,        //  10  newline
    0,                          0,        //  11
    0,                          0,        //  12
   L"\r",                       1,        //  13  carriage return
    0,                          0,        //  14
    0,                          0,        //  15
    0,                          0,        //  16
    0,                          0,        //  17
    0,                          0,        //  18
    0,                          0,        //  19
    0,                          0,        //  20
    0,                          0,        //  21
    0,                          0,        //  22
    0,                          0,        //  23
    0,                          0,        //  24
    0,                          0,        //  25
    0,                          0,        //  26
    0,                          0,        //  27
    0,                          0,        //  28
    0,                          0,        //  29
    0,                          0,        //  30
    0,                          0,        //  31
   L" ",                        1,        //  32
   L"!",                        1,        //  33
   L"&quot;",                   6,        //  34
   L"#",                        1,        //  35
   L"$",                        1,        //  36
   L"%",                        1,        //  37
   L"&amp;",                    5,        //  38
   L"'",                        1,        //  39
   L"(",                        1,        //  40
   L")",                        1,        //  41
   L"*",                        1,        //  42
   L"+",                        1,        //  43
   L",",                        1,        //  44
   L"-",                        1,        //  45
   L".",                        1,        //  46
   L"/",                        1,        //  47
   L"0",                        1,        //  48
   L"1",                        1,        //  49
   L"2",                        1,        //  50
   L"3",                        1,        //  51
   L"4",                        1,        //  52
   L"5",                        1,        //  53
   L"6",                        1,        //  54
   L"7",                        1,        //  55
   L"8",                        1,        //  56
   L"9",                        1,        //  57
   L":",                        1,        //  58
   L";",                        1,        //  59
   L"&lt;",                     4,        //  60
   L"=",                        1,        //  61
   L"&gt;",                     4,        //  62
   L"?",                        1,        //  63
   L"@",                        1,        //  64
   L"A",                        1,        //  65
   L"B",                        1,        //  66
   L"C",                        1,        //  67
   L"D",                        1,        //  68
   L"E",                        1,        //  69
   L"F",                        1,        //  70
   L"G",                        1,        //  71
   L"H",                        1,        //  72
   L"I",                        1,        //  73
   L"J",                        1,        //  74
   L"K",                        1,        //  75
   L"L",                        1,        //  76
   L"M",                        1,        //  77
   L"N",                        1,        //  78
   L"O",                        1,        //  79
   L"P",                        1,        //  80
   L"Q",                        1,        //  81
   L"R",                        1,        //  82
   L"S",                        1,        //  83
   L"T",                        1,        //  84
   L"U",                        1,        //  85
   L"V",                        1,        //  86
   L"W",                        1,        //  87
   L"X",                        1,        //  88
   L"Y",                        1,        //  89
   L"Z",                        1,        //  90
   L"[",                        1,        //  91
   L"\\",                       1,        //  92
   L"]",                        1,        //  93
   L"^",                        1,        //  94
   L"_",                        1,        //  95
   L"`",                        1,        //  96
   L"a",                        1,        //  97
   L"b",                        1,        //  98
   L"c",                        1,        //  99
   L"d",                        1,        // 100
   L"e",                        1,        // 101
   L"f",                        1,        // 102
   L"g",                        1,        // 103
   L"h",                        1,        // 104
   L"i",                        1,        // 105
   L"j",                        1,        // 106
   L"k",                        1,        // 107
   L"l",                        1,        // 108
   L"m",                        1,        // 109
   L"n",                        1,        // 110
   L"o",                        1,        // 111
   L"p",                        1,        // 112
   L"q",                        1,        // 113
   L"r",                        1,        // 114
   L"s",                        1,        // 115
   L"t",                        1,        // 116
   L"u",                        1,        // 117
   L"v",                        1,        // 118
   L"w",                        1,        // 119
   L"x",                        1,        // 120
   L"y",                        1,        // 121
   L"z",                        1,        // 122
   L"{",                        1,        // 123
   L"|",                        1,        // 124
   L"}",                        1,        // 125
   L"~",                        1,        // 126
     0,                         0,        // 127
     0,                         0,        // 128
     0,                         0,        // 129
     0,                         0,        // 130
     0,                         0,        // 131
     0,                         0,        // 132
     0,                         0,        // 133
     0,                         0,        // 134
     0,                         0,        // 135
     0,                         0,        // 136
     0,                         0,        // 137
     0,                         0,        // 138
     0,                         0,        // 139
     0,                         0,        // 140
     0,                         0,        // 141
     0,                         0,        // 142
     0,                         0,        // 143
     0,                         0,        // 144
     0,                         0,        // 145
     0,                         0,        // 146
     0,                         0,        // 147
     0,                         0,        // 148
     0,                         0,        // 149
     0,                         0,        // 150
     0,                         0,        // 151
     0,                         0,        // 152
     0,                         0,        // 153
     0,                         0,        // 154
     0,                         0,        // 155
     0,                         0,        // 156
     0,                         0,        // 157
     0,                         0,        // 158
     0,                         0,        // 159
   L"&nbsp;",                   6,        // 160
   L"&iexcl;",                  7,        // 161
   L"&cent;",                   6,        // 162
   L"&pound;",                  7,        // 163
   L"&curren;",                 8,        // 164
   L"&yen;",                    5,        // 165
   L"&brvbar;",                 8,        // 166
   L"&sect;",                   6,        // 167
   L"&uml;",                    5,        // 168
   L"&copy;",                   6,        // 169
   L"&ordf;",                   6,        // 170 - feminine ordinal indicator
   L"&laquo;",                  7,        // 171
   L"&not;",                    5,        // 172 - not sign
   L"&shy;",                    5,        // 173 - soft hyphen
   L"&reg;",                    5,        // 174
   L"&macr;",                   6,        // 175
   L"&deg;",                    5,        // 176
   L"&plusmn;",                 8,        // 177
   L"&sup2;",                   6,        // 178
   L"&sup3;",                   6,        // 179
   L"&acute;",                  7,        // 180
   L"&micro;",                  7,        // 181
   L"&para;",                   6,        // 182
   L"&middot;",                 8,        // 183
   L"&cedil;",                  7,        // 184
   L"&sup1;",                   6,        // 185
   L"&ordm;",                   6,        // 186 - masculine ordinal indicator
   L"&raquo;",                  7,        // 187
   L"&frac14;",                 8,        // 188
   L"&frac12;",                 8,        // 189
   L"&frac34;",                 8,        // 190
   L"&iquest;",                 8,        // 191
   L"&Agrave;",                 8,        // 192
   L"&Aacute;",                 8,        // 193
   L"&Acirc;",                  7,        // 194
   L"&Atilde;",                 8,        // 195
   L"&Auml;",                   6,        // 196
   L"&Aring;",                  7,        // 197
   L"&AElig;",                  7,        // 198
   L"&Ccedil;",                 8,        // 199
   L"&Egrave;",                 8,        // 200
   L"&Eacute;",                 8,        // 201
   L"&Ecirc;",                  7,        // 202
   L"&Euml;",                   6,        // 203
   L"&Igrave;",                 8,        // 204
   L"&Iacute;",                 8,        // 205
   L"&Icirc;",                  7,        // 206
   L"&Iuml;",                   6,        // 207
   L"&ETH;",                    5,        // 208
   L"&Ntilde;",                 8,        // 209
   L"&Ograve;",                 8,        // 210
   L"&Oacute;",                 8,        // 211
   L"&Ocirc;",                  7,        // 212
   L"&Otilde;",                 8,        // 213
   L"&Ouml;",                   6,        // 214
   L"&times;",                  7,        // 215
   L"&Oslash;",                 8,        // 216
   L"&Ugrave;",                 8,        // 217
   L"&Uacute;",                 8,        // 218
   L"&Ucirc;",                  7,        // 219
   L"&Uuml;",                   6,        // 220
   L"&Yacute;",                 8,        // 221
   L"&THORN;",                  7,        // 222
   L"&szlig;",                  7,        // 223
   L"&agrave;",                 8,        // 224
   L"&aacute;",                 8,        // 225
   L"&acirc;",                  7,        // 226
   L"&atilde;",                 8,        // 227
   L"&auml;",                   6,        // 228
   L"&aring;",                  7,        // 229
   L"&aelig;",                  7,        // 230
   L"&ccedil;",                 8,        // 231
   L"&egrave;",                 8,        // 232
   L"&eacute;",                 8,        // 233
   L"&ecirc;",                  7,        // 234
   L"&euml;",                   6,        // 235
   L"&igrave;",                 8,        // 236
   L"&iacute;",                 8,        // 237
   L"&icirc;",                  7,        // 238
   L"&iuml;",                   6,        // 239
   L"&eth;",                    5,        // 240
   L"&ntilde;",                 8,        // 241
   L"&ograve;",                 8,        // 242
   L"&oacute;",                 8,        // 243
   L"&ocirc;",                  7,        // 244
   L"&otilde;",                 8,        // 245
   L"&ouml;",                   6,        // 246
   L"&divide;",                 8,        // 247
   L"&oslash;",                 8,        // 248
   L"&ugrave;",                 8,        // 249
   L"&uacute;",                 8,        // 250
   L"&ucirc;",                  7,        // 251
   L"&uuml;",                   6,        // 252
   L"&yacute;",                 8,        // 253
   L"&thorn;",                  7,        // 254
   L"&yuml;",                   6,        // 255
};

//+---------------------------------------------------------------------------
//
//  Function:   HTMLEscapeW, public
//
//  Synopsis:   Appends an escaped version of a string to a virtual string.
//
//  Arguments:  [wcsString] - string to be translated
//              [StrResult] - CVirtualString to which result will be appended
//              [ulCodePage] - output codepage
//
//  History:    96/Apr/03   dlee    Created.
//
//----------------------------------------------------------------------------

void HTMLEscapeW( WCHAR const * wcsString,
                  CVirtualString & StrResult,
                  ULONG ulCodePage )
{
    unsigned iUnicodeOutputMethod = 0;

    do
    {
        if ( *wcsString < 256 )
        {
            const struct WCHAR_TO_HTML &Entry = WCHAR_TO_HTML[*wcsString];

            if ( 1 == Entry.cchTranslated )
            {
                StrResult.CharCat( *Entry.wszTranslated );
                wcsString++;
                continue;
            }

            // Do the check for end-of-string here, as this is an
            // unusual code-path.  This saves a compare per loop.

            if ( 0 == *wcsString )
                break;

            // it's ok to pass 0 to StrCat

            StrResult.StrCat( Entry.wszTranslated,
                              Entry.cchTranslated );
        }
        else
        {
            //
            //  A unicode character >= 256 has been found.  Either leave it
            //  as-is in the output string, or convert to the numeric HTML
            //  entity, depending on whether all unicode characters in the
            //  string can be translated using the codepage.
            //
            if ( 0 == iUnicodeOutputMethod )
            {
                iUnicodeOutputMethod++;
                
                BOOL fUsedDefaultChar = FALSE;
                int cchOut = WideCharToMultiByte( ulCodePage,
#if (WINVER >= 0x0500)
                                                  WC_NO_BEST_FIT_CHARS |
#endif // (WINVER >= 0x0500)
                                                    WC_COMPOSITECHECK |
                                                    WC_DEFAULTCHAR,
                                                  wcsString,
                                                  -1,
                                                  0,
                                                  0,
                                                  0,
                                                  &fUsedDefaultChar );
                Win4Assert( cchOut != 0 ||
                            ERROR_INVALID_PARAMETER == GetLastError() );

                if ( fUsedDefaultChar ||
                     cchOut == 0 && ERROR_INVALID_PARAMETER == GetLastError() )
                    iUnicodeOutputMethod++;
            }

            if ( 1 == iUnicodeOutputMethod )
            {
                StrResult.CharCat( *wcsString );
            }
            else
            {
                Win4Assert( 2 == iUnicodeOutputMethod );

                // Output the numeric html entity
                USHORT wch = *wcsString;
                WCHAR achNum[6];
                _itow( wch, achNum, 10 );
                StrResult.CharCat( L'&' );
                StrResult.CharCat( L'#' );
                StrResult.StrCat( achNum );
                StrResult.CharCat( L';' );
            }
        }

        wcsString++;
    } while( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\cphash.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1997 Microsoft Corporation.
//
//  File:       cphash.cxx
//
//  Contents:   Table that maps strings to codepages
//
//  Classes:    CCodePageTable
//
//  Note:       Derived from SitaramR's hash table
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cphash.hxx>

const ULONG CODE_JPN_JIS = 1;
const ULONG CODE_JPN_EUC = 2;

//
// Note: These must be all lowercase and kept in alphabetical order
//

const CCodePageEntry CCodePageTable::_aEntries[] =
{
    { L"ansi_x3.4-1968", 1252 },
    { L"ansi_x3.4-1986", 1252 },
    { L"ascii", 1252 },
    { L"big5", 950 },
    { L"chinese", 936 },
    { L"cp367", 1252 },
    { L"cp819", 1252 },
    { L"csascii", 1252 },
    { L"csbig5", 950 },
    { L"cseuckr", 949 },
    { L"cseucpkdfmtjapanese", CODE_JPN_EUC },
    { L"csgb2312", 936 },
    { L"csiso2022jp", CODE_JPN_JIS },
    { L"csiso2022kr", 50225 },
    { L"csiso58gb231280", 936 },
    { L"csisolatin2", 28592 },
    { L"csisolatinhebrew", 1255 },
    { L"cskoi8r", 20866 },
    { L"csksc56011987",  949 },
    { L"csshiftjis", 932 },
    { L"euc-kr", 949 },
    { L"extended_unix_code_packed_format_for_japanese", CODE_JPN_EUC },
    { L"gb2312", 936 },
    { L"gb_2312-80", 936 },
    { L"hebrew", 1255 },
    { L"hz-gb-2312", 936 },
    { L"ibm367", 1252 },
    { L"ibm819", 1252 },
    { L"ibm852", 852 },
    { L"ibm866", 866 },
    { L"iso-2022-jp", CODE_JPN_JIS },
    { L"iso-2022-kr", 50225 },
    { L"iso-8859-1", 1252 },
    { L"iso-8859-2", 28592 },
    { L"iso-8859-8", 1255 },
    { L"iso-ir-100", 1252 },
    { L"iso-ir-101", 28592 },
    { L"iso-ir-138", 1255 },
    { L"iso-ir-149", 949 },
    { L"iso-ir-58", 936 },
    { L"iso-ir-6", 1252 },
    { L"iso646-us", 1252 },
    { L"iso8859-1", 1252 },
    { L"iso8859-2", 28592 },
    { L"iso_646.irv:1991", 1252 },
    { L"iso_8859-1", 1252 },
    { L"iso_8859-1:1987", 1252 },
    { L"iso_8859-2", 28592 },
    { L"iso_8859-2:1987", 28592 },
    { L"iso_8859-8", 1255 },
    { L"iso_8859-8:1988", 1255 },
    { L"koi8-r", 20866 },
    { L"korean", 949 },
    { L"ks-c-5601", 949 },
    { L"ks-c-5601-1987", 949 },
    { L"ks_c_5601", 949 },
    { L"ks_c_5601-1987", 949 },
    { L"ks_c_5601-1989", 949 },
    { L"ksc-5601", 949 },
    { L"ksc5601", 949 },
    { L"ksc_5601", 949 },
    { L"l2", 28592 },
    { L"latin1", 1252 },
    { L"latin2", 28592 },
    { L"ms_kanji", 932 },
    { L"shift-jis", 932 },
    { L"shift_jis", 932 },
    { L"us", 1252 },
    { L"us-ascii", 1252 },
    { L"windows-1250", 1250 },
    { L"windows-1251", 1251 },
    { L"windows-1252", 1252 },
    { L"windows-1253", 1253 },
    { L"windows-1254", 1254 },
    { L"windows-1255", 1255 },
    { L"windows-1256", 1256 },
    { L"windows-1257", 1257 },
    { L"windows-1258", 1258 },
    { L"windows-874", 874 },
    { L"x-cp1250", 1250 },
    { L"x-cp1251", 1251 },
    { L"x-euc", CODE_JPN_EUC },
    { L"x-euc-jp", CODE_JPN_EUC },
    { L"x-sjis", 932 },
    { L"x-x-big5", 950 },
};

const unsigned CCodePageTable::_cEntries = sizeof CCodePageTable::_aEntries /
                                           sizeof CCodePageTable::_aEntries[0];

//+---------------------------------------------------------------------------
//
//  Method:     EntryCompare, private, static
//
//  Synposis:   Compares a string with a string in a CCodePageEntry.
//              Called by bsearch.
//
//  Arguments:  [pwcKey]    -- key for comparison
//              [pEntry]    -- entry for comparison
//
//  Returns:    < 0 if pwcKey < pEntry
//              0 if identical
//              > 0 if pwcKey > pEntry
//
//  History:    27-Aug-97   dlee Created
//
//----------------------------------------------------------------------------

int __cdecl CCodePageTable::EntryCompare(
    WCHAR const *          pwcKey,
    CCodePageEntry const * pEntry )
{
    return wcscmp( pwcKey, pEntry->pwcName );
} //EntryCompare

//+---------------------------------------------------------------------------
//
//  Method:     Lookup, public, static
//
//  Synposis:   Finds a codepage based on string and returns the codepage
//              The lookup is case-insensitive.
//
//  Arguments:  [pwcName]    -- not-necessarily null terminated string
//              [cwcName]    -- # of wide characters in pwcName
//              [ulCodePage] -- returns the corresponding codepage
//
//  Returns:    TRUE if the codepage name was found, FALSE otherwise
//
//  History:    27-Aug-97   dlee Created
//
//----------------------------------------------------------------------------

BOOL CCodePageTable::Lookup(
    WCHAR const * pwcName,
    unsigned      cwcName,
    ULONG &       ulCodePage )
{
    //
    // Limit the length of codepage strings
    //

    WCHAR awcLowcase[ 100 ];

    if ( cwcName >= ( sizeof awcLowcase / sizeof WCHAR ) )
        return FALSE;

    //
    // Convert the string to lowercase.
    //

    RtlCopyMemory( awcLowcase, pwcName, cwcName * sizeof WCHAR );
    awcLowcase[ cwcName ] = 0;
    _wcslwr( awcLowcase );

    //
    // Try to find the codepage using the C runtime binary search function
    //

    CCodePageEntry * pEntry = (CCodePageEntry *)
                              bsearch( awcLowcase,
                                       _aEntries,
                                       _cEntries,
                                       sizeof CCodePageEntry,
                                       (int (__cdecl *)(const void *, const void *) )
                                       EntryCompare );

    if ( 0 == pEntry )
        return FALSE;

    ulCodePage = pEntry->ulCodePage;
    return TRUE;
} //Lookup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\lgplist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       lgplist.cxx
//
//  Contents:   Index server wide local/global property list class.
//
//  History:    05 May 1997      Alanw    Created
//              27 Aug 1997      KrishnaN Moved from ixsso to querylib
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//-----------------------------------------------------------------------------
// Include Files
//-----------------------------------------------------------------------------

#include <cidebug.hxx>
#include <dynstack.hxx>
#include <funypath.hxx>
#include <dblink.hxx>
#include <imprsnat.hxx>

// class declaration

CStaticPropertyList GlobalStaticList;
CPropListFile * CLocalGlobalPropertyList::_pGlobalPropListFile = 0;
CStaticMutexSem g_mtxFilePropList;  // regulates access to the global file prop list.

CRegChangeEvent     CGlobalPropFileRefresher::_regChangeEvent( wcsRegCommonAdminTree, TRUE );
WCHAR               CGlobalPropFileRefresher::_wcsFileName[];
FILETIME            CGlobalPropFileRefresher::_ftFile;
DWORD               CGlobalPropFileRefresher::_dwLastCheckMoment;
BOOL                CGlobalPropFileRefresher::_fInited = FALSE;
HKEY                CGlobalPropFileRefresher::_hKey;
LONG                CGlobalPropFileRefresher::_lRegReturn;

CGlobalPropFileRefresher gRefresher;

//+-------------------------------------------------------------------------
//
//  Member:     CDefColumnRegEntry::CDefColumnRegEntry, public
//
//  Synopsis:   Constructor for registry param object
//
//  Arguments:  [pwcName]    - 0 or name of the catalog from the registry
//
//  History:    12-Oct-96 dlee  Created
//
//--------------------------------------------------------------------------

CDefColumnRegEntry::CDefColumnRegEntry()
{
    // set default
    wcscpy( _awcDefaultColumnFile, L"" );

} //CDefColumnRegEntry

//+-------------------------------------------------------------------------
//
//  Member:     CDefColumnRegEntry::Refresh, public
//
//  Synopsis:   Reads the values from the registry
//
//  History:    12-Oct-96 dlee  Added header, reorganized
//
//--------------------------------------------------------------------------

void CDefColumnRegEntry::Refresh( BOOL fUseDefaultsOnFailure )
{
    TRY
    {
        //  Query the registry.

        CRegAccess regAdmin( RTL_REGISTRY_CONTROL, wcsRegCommonAdmin );

        XPtrST<WCHAR> xRegValue(regAdmin.Read(wcsDefaultColumnFile, L""));

        wcsncpy( _awcDefaultColumnFile, xRegValue.GetPointer(), MAX_PATH );
    }
    CATCH (CException, e)
    {
        // Only store defaults when told to do so -- the params
        // are still in good shape at this point and are more
        // accurate than the default settings.

        if ( fUseDefaultsOnFailure )
            wcscpy( _awcDefaultColumnFile, L"" );           
    }
    END_CATCH
} //Refresh

//-----------------------------------------------------------------------------
//
//  Member:     CPropListFile::CPropListFile
//
//  Synopsis:   Constructor of a property list from a file
//
//  Arguments:  [pDefaultList]    -- The default property list
//              [fDynamicRefresh] -- True, if list should be dynamically
//                                   refreshed when file changes.
//              [pwcPropFile]     -- The property file.  If this is null,
//                                   use the registry.
//              [ulCodePage]      -- Codepage to interpret the property list.
//
//  Notes:      
//
//  History:    08 Sep 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------

CPropListFile::CPropListFile( CEmptyPropertyList *pDefaultList,
                              BOOL fDynamicRefresh,
                              WCHAR const * pwcPropFile,
                              ULONG ulCodePage ) :
    CCombinedPropertyList(pDefaultList, ulCodePage),
    _scError( S_OK ),
    _iErrorLine( 0 ),
    _xErrorFile( 0 ),
    _ulCodePage( ulCodePage ),
    _fDynamicRefresh( fDynamicRefresh ),
    _dwLastCheckMoment( GetTickCount() )
{
    if (pwcPropFile)
        Load(pwcPropFile);
    else
    {
        WCHAR wszFile[MAX_PATH+1];
        _RegParams.GetDefaultColumnFile( wszFile, MAX_PATH );
        Load(wszFile);
    }
}

CPropListFile::~CPropListFile()
{
    ClearList();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListFile::Load - public
//
//  Synopsis:   Loads the file into the property list.
//
//  Arguments:  [pwszFile] -- File name for property definitions
//
//  History:    06 May 1997     AlanW       Created
//
//----------------------------------------------------------------------------

void CPropListFile::Load(WCHAR const * const pwszFile )
{
    if (0 == pwszFile || 0 == *pwszFile)
        return;

    CImpersonateSystem impersonateSystem;

    // prevent multiple loads at the same time

    CLock lock(_mtx);

    // Erase any previous error settings.
    _scError = S_OK;
    _iErrorLine = 0;
    _xErrorFile.Free();

    SCODE sc = GetLastWriteTime(pwszFile, _ftFile);
    if (S_OK == sc)
    {
        // ParseNameFile should not throw exceptions.
        sc = ParseNameFile( pwszFile );
    }
    else
        sc = QPLIST_E_CANT_OPEN_FILE;

    if (FAILED(sc))
    {
        qutilDebugOut(( DEB_WARN, "Can't open column file named %ws\n", pwszFile ));
        _scError = sc;
        _iErrorLine = 0;

        if (0 == _xErrorFile.GetPointer())
        {
            WCHAR * pwcErrorFile = new WCHAR[wcslen(pwszFile)+1];
            wcscpy(pwcErrorFile, pwszFile);
            _xErrorFile.Set( pwcErrorFile );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListFile::IsMapUpToDate - public
//
//  Synopsis:   Determines if the file is still vaid, or if it has
//              changed since it was last read.
//
//  History:    06 May 1997     AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CPropListFile::IsMapUpToDate()
{
    //
    // Has the file been modified since last loaded?
    //
    
    FILETIME ft;
    SCODE sc = GetLastWriteTime(_xFileName.GetPointer(), ft);


    if (FAILED(sc))
        return E_HANDLE;

    if ( (_ftFile.dwLowDateTime == ft.dwLowDateTime) &&
         (_ftFile.dwHighDateTime == ft.dwHighDateTime) )
        return S_OK;
    
    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPropListFile::GetLastWriteTime, static
//
//  Purpose:    Gets the last change time of the file specified
//
//  Arguments:  [wcsFileName] - name of file to get last write time of
//              [ftLastWrite] - on return, last mod. time of file
//
//  Returns:    SCODE - S_OK if successful.
//
//  History:    96/Jan/23   DwightKr    Created
//              96/Mar/13   DwightKr    Changed to use GetFileAttributesEx()
//
//----------------------------------------------------------------------------

SCODE CPropListFile::GetLastWriteTime( WCHAR const * wcsFileName,
                                       FILETIME & ftLastWrite )
{
    if ( 0 == wcsFileName )
        return E_INVALIDARG;

    WIN32_FIND_DATA ffData;

    if ( !GetFileAttributesEx( wcsFileName, GetFileExInfoStandard, &ffData ) )
    {
        ULONG error = GetLastError();

        qutilDebugOut(( DEB_IERROR,
                        "Unable to GetFileAttributesEx(%ws) GetLastError=0x%x\n",
                        wcsFileName,
                        error ));
        return HRESULT_FROM_WIN32(error);
    }

    ftLastWrite = ffData.ftLastWriteTime;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListfile::ParseNameFile, public
//
//  Synopsis:   Parses the given file name and creates a list of 'friendly
//              name' to CDbColId equivalences.
//
//  Arguments:  szFileName -- name of the file to parse
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

SCODE CPropListFile::ParseNameFile( WCHAR const * wcsFileName )
{
    int iLength;
    BOOL fRememberFileName = FALSE;
    
    if( wcsFileName == 0 )
    {
        // use the last specified property file
        if( !_xFileName.IsNull() )
        {
            wcsFileName = _xFileName.GetPointer();
            iLength = wcslen( wcsFileName ) + 1;
        }
        else
            return QPLIST_E_CANT_OPEN_FILE;
    }
    else
    {
        // make a copy of the file name
        _xFileName.Free();

        iLength = wcslen( wcsFileName ) + 1;

        _xFileName.Set( new WCHAR[ iLength ] );

        memcpy( _xFileName.GetPointer(), wcsFileName, iLength * sizeof WCHAR );
    }

    CSFile pfile( OpenFileFromPath( wcsFileName ) );

    if( pfile == 0 )
        return QPLIST_E_CANT_OPEN_FILE;
    
    //
    //  Process a line at a time, skip ahead until we find the [Names]
    //  or [Query] section and process lines within that section only.
    //
    BOOL fNameSection  = FALSE;
    SCODE sc = S_OK;

    int iLine = 0;

    for( ;; )
    {
        TRY
        {
            iLine++;
    
            // line buffers
            char szLine[ MAX_LINE_LENGTH ];
            WCHAR wcsLine[ MAX_LINE_LENGTH ];
    
            if( !fgets( szLine, MAX_LINE_LENGTH, pfile ) )
            {
                if( feof( pfile ) )
                    break;
    
                THROW( CPListException( QPLIST_E_READ_ERROR, iLine ) );
            }
    
            //
            //  Skip ahead until we find a [Names] section
            //
            if ( *szLine == '[' )
            {
                if ( _strnicmp(szLine, "[Names]", 7) == 0 )
                {
                    fNameSection = TRUE;
                    continue;
                }
                else
                {
                    fNameSection = FALSE;
                    continue;
                }
            }
            else if ( *szLine == '#' )
            {
                continue;
            }
    
            if ( fNameSection )
            {
                if( MultiByteToWideChar( _ulCodePage,
                                         MB_COMPOSITE,
                                         szLine,
                                         -1,
                                         wcsLine,
                                         MAX_LINE_LENGTH )
                    == 0 )
                {
                    THROW( CException() );
                }
    
                CQueryScanner scanner( wcsLine, FALSE );
                XPtr<CPropEntry> propentry;
                CPropertyList::ParseOneLine( scanner, iLine, propentry );
                if (propentry.GetPointer())
                {
                    AddEntry( propentry.GetPointer(), iLine );
                    propentry.Acquire();
                }
            }
        }
        CATCH( CPListException, e )
        {
            qutilDebugOut(( DEB_WARN,
                            "Plist exception %08x caught parsing default column file at line %d. Line ignored.\n",
                            e.GetErrorCode(), e.GetLine() ));
            
            sc = _scError = e.GetErrorCode();
            _iErrorLine = e.GetLine();
            fRememberFileName = TRUE;
        }
        AND_CATCH ( CException, e )
        {
            qutilDebugOut(( DEB_WARN,
                            "Exception caught parsing default column file %08x\n",
                            e.GetErrorCode() ));
            sc = _scError = e.GetErrorCode();
            fRememberFileName = TRUE;
        }
        END_CATCH

        if (fRememberFileName && 0 == _xErrorFile.GetPointer())
        {
            fRememberFileName = FALSE;
            WCHAR * pwcErrorFile = new WCHAR[wcslen(wcsFileName)+1];
            wcscpy(pwcErrorFile, wcsFileName);
            _xErrorFile.Set( pwcErrorFile );
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListfile::CheckError, public
//
//  Synopsis:   Checks if there was an error in the parsing of the file.
//
//  Arguments:  iLine  -- error line number returned here.
//              ppFile -- file name returned here. can be 0 if not needed.
//
//  History:    17-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

SCODE CPropListFile::CheckError( ULONG & iLine, WCHAR ** ppFile )
{
    iLine = _iErrorLine;
    if (ppFile)
        *ppFile = _xErrorFile.GetPointer();
    return _scError;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropListfile::Refresh, private
//
//  Synopsis:   Reloads the property list if prop. file has been modified.
//
//  History:    15-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

void CPropListFile::Refresh()
{
    if (!_fDynamicRefresh)
        return;
    
    // Don't check more than once in a few seconds
    if (abs(GetTickCount() - _dwLastCheckMoment) < REFRESH_INTERVAL)
        return;
    _dwLastCheckMoment = GetTickCount();

    if (S_OK != IsMapUpToDate())
    {
        //
        // Reload.
        //

        ClearList();
        Load(_xFileName.GetPointer());
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::Find, public
//
//  Synopsis:   Attempt to find an entry in the list.
//
//  Arguments:  wcsName -- friendly property name to find
//
//  Returns a pointer to the CPropEntry if found, 0 otherwise.
//
//  History:    17-May-94   t-jeffc     Created.
//              28-Aug-97   KrishnaN    modified.
//
//----------------------------------------------------------------------------

CPropEntry const * CCombinedPropertyList::Find( WCHAR const * wcsName )
{
    if( 0 == wcsName )
        return 0;

    //
    // First look in the default list, and if not found, look
    // in the overrides.
    //

    CPropEntry const * ppentry = _xDefaultList->Find(wcsName);
    if (ppentry)
        return ppentry;

    return (_xOverrideList.GetPointer() ? _xOverrideList->Find(wcsName) : 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::Next, public
//
//  Synopsis:   Gets the next property during an enumeration
//
//  Returns:    The next property entry or 0 for end of enumeration
//
//  History:    21-Jul-97   dlee  Moved from .hxx and added header
//
//----------------------------------------------------------------------------

CPropEntry const * CCombinedPropertyList::Next()
{
    //
    // First look in the static list, and if not found, look in the overrides.
    //

    CPropEntry const *pEntry = 0;

    if (!_fOverrides)
        pEntry = _xDefaultList->Next();
    
    if (pEntry)
        return pEntry;

    _fOverrides = TRUE;
    return (_xOverrideList.GetPointer() ? _xOverrideList->Next() : 0);
} //Next

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::InitIterator, public
//
//  Synopsis:   Initialize the iterator
//
//  History:    29-Aug-97  KrishnaN  Created
//
//----------------------------------------------------------------------------

void CCombinedPropertyList::InitIterator()
{
    // causes the default list to be iterated before the overrides

    _fOverrides = FALSE;

    // Initialize the iterators of the two lists

    _xDefaultList->InitIterator();

    if (_xOverrideList.GetPointer())
        _xOverrideList->InitIterator();
} //InitIterator

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::AddEntry, private
//
//  Synopsis:   Adds a CPropEntry to the overriding list.  Verifies that the name
//              isn't already in the default list or the overriding list.
//
//  Arguments:  ppentryNew -- pointer to the CPropEntry to add
//              iLine      -- line number we're parsing
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

void CCombinedPropertyList::AddEntry( CPropEntry * ppentryNew, int iLine )
{
    // protect _xOverrideList
    CLock lock(_mtxAdd);

    if (0 == _xOverrideList.GetPointer())
    {
        _xOverrideList.Set(new CPropertyList(_ulCodePage));
    }

    //
    // We do not allow entries in the override list that have the same name
    // as the default list.
    //

    if( _xDefaultList->Find( ppentryNew->GetName() ) ||
        _xOverrideList->Find( ppentryNew->GetName() ) )
        THROW( CPListException( QPLIST_E_DUPLICATE, iLine ) );

    _xOverrideList->AddEntry(ppentryNew, iLine);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::ClearList, public
//
//  Synopsis:   Frees the memory used by the list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

void CCombinedPropertyList::ClearList()
{
    // protect _xOverrideList
    CLock lock(_mtxAdd);

    //
    // Just free it now. It will be created, if necessary,
    // on AddEntry().
    //

    _xOverrideList.Free();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::SetDefaultList, public
//
//  Synopsis:   Sets the default list.
//
//  Arguments:  pDefaultList -- The list to set as default list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

void CCombinedPropertyList::SetDefaultList(CEmptyPropertyList *pDefaultList)
{
    Win4Assert(pDefaultList);

    // Jettison any existing property list
    _xDefaultList.Free();

    _xDefaultList.Set(pDefaultList);
    pDefaultList->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::GetCount, public
//
//  Synopsis:   Returns cardinality of list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------
ULONG CCombinedPropertyList::GetCount()
{
    ULONG ulTotal = _xDefaultList->GetCount();
    if (_xOverrideList.GetPointer())
    {
        ulTotal += _xOverrideList->GetCount();
    }

    return ulTotal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCombinedPropertyList::GetAllEntries, public
//
//  Synopsis:   Returns cardinality of list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------
SCODE CCombinedPropertyList::GetAllEntries(CPropEntry **ppPropEntries,
                                           ULONG ulMaxCount)
{
    ULONG ulSize = _xDefaultList->GetCount();
    // get the first set of entries from the default list
    SCODE sc = _xDefaultList->GetAllEntries(ppPropEntries, min(ulSize, ulMaxCount));

    // get the remaining entries from the override list
    if (S_OK == sc && ulMaxCount > ulSize && _xOverrideList.GetPointer())
    {
        sc = _xOverrideList->GetAllEntries(ppPropEntries+ulSize, ulMaxCount-ulSize);
    }

    return sc;
}

//-----------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::CLocalGlobalPropertyList
//
//  Synopsis:   Constructor of a overridable file based property list.
//              The file name will always be obtained through the registry.
//
//  Arguments:  [ulCodePage] -- Codepage to interpret the property list.
//
//  Notes:      
//
//  History:    08 Sep 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------

CLocalGlobalPropertyList::CLocalGlobalPropertyList( ULONG ulCodePage ) :
    CCombinedPropertyList(ulCodePage),
    _ulCodePage( ulCodePage ),
    _dwLastCheckMoment( GetTickCount() ),
    _mtx()
{
    XInterface<CPropListFile> xPropListFile(GetGlobalPropListFile());
    SetDefaultList(xPropListFile.GetPointer());
}

//-----------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::CLocalGlobalPropertyList
//
//  Synopsis:   Constructor of a overridable file based property list.
//              The file name will always be obtained through the registry.
//
//  Arguments:  [pDefaultList]    -- The default property list
//              [fDynamicRefresh] -- True, if list should be dynamically
//                                   refreshed when file changes.
//              [pwcPropFile]     -- The property file. If this is null,
//                                   use the registry.
//              [ulCodePage]      -- Codepage to interpret the property list.
//
//  Notes: This constructor is used by clients who use their own file based
//         list instead of using the registry based file.
//
//  History:    08 Sep 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------

CLocalGlobalPropertyList::CLocalGlobalPropertyList
                             (CEmptyPropertyList *pDefaultList,
                              BOOL fDynamicRefresh,
                              WCHAR const * pwcsPropFile,
                              ULONG ulCodePage) :
    CCombinedPropertyList(ulCodePage),
    _ulCodePage( ulCodePage ),
    _dwLastCheckMoment( GetTickCount() ),
    _mtx()
{
    XInterface<CPropListFile> xPropListFile(
                                new CPropListFile(pDefaultList,
                                                  fDynamicRefresh,
                                                  pwcsPropFile,
                                                  ulCodePage));
    SetDefaultList(xPropListFile.GetPointer());
}


//+---------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::IsMapUpToDate - public
//
//  Synopsis:   Determines if the file is still valid, or if it has
//              changed since it was last read.
//
//  History:    06 May 1997     AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CLocalGlobalPropertyList::IsMapUpToDate()
{
    ULONG cchRequired = _RegParams.GetDefaultColumnFile( 0, 0 );
    WCHAR wszFile[MAX_PATH + 1];
    wszFile[0] = 0;
    
    if ( 0 != cchRequired )
    {
        _RegParams.GetDefaultColumnFile( wszFile, MAX_PATH );
    }

    //
    // If the current file and the one in the registry are not the same,
    // we are outdated.
    //

    if (0 != _wcsicmp(_xFileName.GetPointer(), wszFile))
        return S_FALSE;

    //
    // The filelist takes care of file modifications, so ask it
    // directly if it is up to date.
    //

    return GetDefaultList().IsMapUpToDate();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::CheckError, public
//
//  Synopsis:   Checks if there was an error in the parsing of the file.
//
//  Arguments:  iLine  -- error line number returned here.
//              ppFile -- file name returned here. can be 0 if not needed.
//
//  History:    17-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

SCODE CLocalGlobalPropertyList::CheckError( ULONG & iLine, WCHAR ** ppFile )
{
    return ((CPropListFile &)GetDefaultList()).CheckError(iLine, ppFile);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalGlobalPropertyList::Load - public
//
//  Synopsis:   Loads the file into the property list.
//
//  Arguments:  [pwszFile] -- File name for property definitions
//
//  History:    19 Sep 1997     KrishnaN       Created
//
//----------------------------------------------------------------------------

void CLocalGlobalPropertyList::Load(WCHAR const * const pwszFile )
{
    ((CPropListFile &)GetDefaultList()).Load(pwszFile);
}

// Miscellaneous

CStaticPropertyList * GetGlobalStaticPropertyList()
{
    GlobalStaticList.AddRef();
    return &GlobalStaticList;
}

//
// Return an AddRef'd global prop file list. The caller will release
// when done using the global prop file list.
//

CPropListFile * GetGlobalPropListFile()
{
    CImpersonateSystem impersonateSystem;

    CLock lock(g_mtxFilePropList);

    if (!CLocalGlobalPropertyList::_pGlobalPropListFile)
    {
        // The global property list will be controlled by CLocalGlobalPropertyList, so
        // we disable its ability to refresh dynamically.
        CLocalGlobalPropertyList::_pGlobalPropListFile =
                     new CPropListFile(GetGlobalStaticPropertyList(), FALSE);
    }
    else
    {
        //
        // If the refresher replaces the global property list, that would
        // AddRef the newly created global proplist, so we should not AddREf
        // again. If DoIt fails, no need to AddRef.
        //
        if (!gRefresher.DoIt())
            CLocalGlobalPropertyList::_pGlobalPropListFile->AddRef();
    }

    Win4Assert(CLocalGlobalPropertyList::_pGlobalPropListFile);

    return CLocalGlobalPropertyList::_pGlobalPropListFile;
}

//+---------------------------------------------------------------------------
//
//  Member:     CreateNewGlobalPropFileList - public
//
//  Synopsis:   Creates a new global file based property list.
//
//  History:    15-Sep-1997     KrishnaN       Created
//
//  Notes: This function replaces the global property file list so that newer
//         clients asking for the list will get an updated list (if the file has
//         been modified or replaced.)
//
//----------------------------------------------------------------------------

void CreateNewGlobalPropFileList(WCHAR CONST *wcsFileName)
{
    CLock lock(g_mtxFilePropList);

    Win4Assert(CLocalGlobalPropertyList::_pGlobalPropListFile);

    // The global property list will be controlled by CLocalGlobalPropertyList, so
    // we disable its ability to refresh dynamically.
    CLocalGlobalPropertyList::_pGlobalPropListFile =
                           new CPropListFile(GetGlobalStaticPropertyList(),
                                             FALSE,
                                             wcsFileName);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGlobalPropFileRefresher::DoIt - public
//
//  Synopsis:   Creates a new global file based property list if necessary.
//
//  Returns:    True if refresh happened. False otherwise.
//
//  History:    15-Sep-1997     KrishnaN       Created
//
//  Notes:      This function monitors the registry and the file so the list
//              can be updated if the underlying property file changes.
//
//----------------------------------------------------------------------------

BOOL CGlobalPropFileRefresher::DoIt()
{
    //
    // We don't need to lock this because currently it is only
    // being called after obtaining a lock elsewhere. If that
    // changes, then a lock may be needed here.
    //

    // Don't check more than once in a few seconds
    if (abs(GetTickCount() - _dwLastCheckMoment) < REFRESH_INTERVAL)
        return FALSE;
    
    CImpersonateSystem impersonateSystem;

    if (!_fInited)
        Init();
    
    BOOL fRefresh = FALSE;

    _dwLastCheckMoment = GetTickCount();

    // First check the registry, then check the file itself
    ULONG res = WaitForSingleObject( _regChangeEvent.GetEventHandle(), 0 );
    if (WAIT_OBJECT_0 == res)
    {
        _regChangeEvent.Reset();

        // the registry changed, but the value may not have. check that.

        WCHAR wszFile[MAX_PATH];

        GetDefaultColumnFile(wszFile);

        // Are the file names the same?
        if (0 != _wcsicmp(wszFile, _wcsFileName))
        {
            wcscpy(_wcsFileName, wszFile);
            fRefresh = TRUE;
            GetLastWriteTime(_ftFile);
        }
    }

    if (! fRefresh)
    {
        FILETIME ft;
        GetLastWriteTime(ft);
        if ((_ftFile.dwLowDateTime != ft.dwLowDateTime) ||
            (_ftFile.dwHighDateTime != ft.dwHighDateTime) )
        {
            _ftFile = ft;
            fRefresh = TRUE;
        }
    }

    if (fRefresh)
    {
        // refresh

        CreateNewGlobalPropFileList(_wcsFileName);
    }

    return fRefresh;
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlobalPropFileRefresher::Init - public
//
//  Synopsis:   Initializes this class.
//
//  Returns:    Nothing. Can throw.
//
//  History:    15-Sep-1997     KrishnaN       Created
//
//----------------------------------------------------------------------------

void CGlobalPropFileRefresher::Init()
{
    _regChangeEvent.Init();

    _lRegReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,    // Root
                             wcsRegCommonAdminSubKey,
                             0,                    // Reserved
                             KEY_READ,             // Access
                             &_hKey);               // Handle

    GetDefaultColumnFile(_wcsFileName);
    GetLastWriteTime(_ftFile);
    
    _fInited = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\mbutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       mbutil.cxx
//
//  Contents:   MultiByte To Unicode and ViceVersa utility functions and
//              classes.
//
//  History:    96/Jan/3    DwightKr    Created
//              Aug 20 1996 Srikants    Moved from escurl.hxx to this file
//
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   MultiByteToXArrayWideChar
//
//  Arguments:  [pbBuffer]  - ASCII buffer to convert to WCHAR
//              [cbBuffer]  - length of the buffer, not including the null
//              [codePage]  - codePage for conversion
//              [wcsBuffer] - resulting WCHAR buffer
//
//  Synopsis:   Converts a multibyte string to a wide character string
//
//----------------------------------------------------------------------------
ULONG MultiByteToXArrayWideChar( BYTE const * pbBuffer,
                                 ULONG cbBuffer,
                                 UINT codePage,
                                 XArray<WCHAR> & wcsBuffer )
{
    Win4Assert( 0 != pbBuffer );

    //
    // MultiByteToWideChar expects a length of at least 1 char.
    //

    int cwcBuffer = cbBuffer + (cbBuffer/2) + 2;

    if ( wcsBuffer.Get() == 0 || (ULONG) cwcBuffer > wcsBuffer.Count() )
    {
        delete [] wcsBuffer.Acquire();
        wcsBuffer.Init(cwcBuffer);
    }

    if ( 0 == cbBuffer )
    {
        wcsBuffer[0] = 0;
        return 0;
    }

    int cwcConvert;

    do
    {
        cwcConvert = MultiByteToWideChar( codePage,
                                          0,
                           (const char *) pbBuffer,
                                          cbBuffer,        // Size of input buf
                                          wcsBuffer.Get(), // Ptr to output buf
                                          cwcBuffer - 1 ); // Size of output buf

        if ( 0 == cwcConvert )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                cwcBuffer += (cwcBuffer/2);
                delete wcsBuffer.Acquire();
                wcsBuffer.Init(cwcBuffer);
            }
            else
            {
                THROW( CException() );
            }
        }
        else
        {
            wcsBuffer[cwcConvert] = 0;      // Null terminate the buffer
        }
    } while ( 0 == cwcConvert );

    if ( 0 == pbBuffer[cbBuffer-1] )
        return cwcConvert - 1;

    return cwcConvert;
} //MultiByteToXArrayWideChar

//+---------------------------------------------------------------------------
//
//  Function:   WideCharToXArrayMultiByte
//
//  Arguments:  [wcsMesage]  - WCHAR buffer to convert to ASCII
//              [cwcMessage] - length of the buffer, not including the null
//              [codePage]   - code page for conversion
//              [pszBuffer]  - resulting CHAR buffer
//
//  Synopsis:   Converts a wide character string to ASCII
//
//----------------------------------------------------------------------------
DWORD WideCharToXArrayMultiByte( WCHAR const * wcsMessage,
                                 ULONG cwcMessage,
                                 UINT codePage,
                                 XArray<BYTE> & pszMessage )
{
    Win4Assert( 0 != cwcMessage );
    
    DWORD cbConvert;
    ULONG cbMessage = pszMessage.Count();

    do
    {
        cbConvert = ::WideCharToMultiByte( codePage,
                                           WC_COMPOSITECHECK,
                                           wcsMessage,
                                           cwcMessage,
                                 (CHAR *)  pszMessage.Get(),
                                           cbMessage,
                                           NULL,
                                           NULL );

        if ( (0 == cbConvert) || (0 == cbMessage) )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                 cbMessage += ++cbMessage;
                 delete pszMessage.Acquire();
                 pszMessage.Init(cbMessage);
            }
            else
            {
                THROW( CException() );
            }
       }
    } while ( 0 == cbConvert );

    if ( cwcMessage > 0  && 0 == wcsMessage[cwcMessage-1] )
        return cbConvert - 1;
    else
        return cbConvert;
}

//+---------------------------------------------------------------------------
//
//  Function:   wcsipattern
//
//  Synopsis:   A case-insensitive, WCHAR implemtation of strstr.
//
//  Arguments:  [wcsString]  - string to search
//              [wcsPattern] - pattern to look for
//
//  Returns:    pointer to pattern, 0 if no match found.
//
//  History:    96/Jan/03   DwightKr    created
//
//  NOTE:       Warning the first character of wcsPattern must be a case
//              insensitive letter.  This results in a significant performance
//              improvement.
//
//----------------------------------------------------------------------------
WCHAR * wcsipattern( WCHAR * wcsString, WCHAR const * wcsPattern )
{
    Win4Assert ( (wcsPattern != 0) && (*wcsPattern != 0) );

    ULONG cwcPattern = wcslen(wcsPattern);
    Win4Assert( *wcsPattern == towupper(*wcsPattern) );

    while ( *wcsString != 0 )
    {
        while ( (*wcsString != 0) &&
                (*wcsString != *wcsPattern) )
        {
            wcsString++;
        }

        if ( 0 == *wcsString )
        {
            return 0;
        }

        if ( _wcsnicmp( wcsString, wcsPattern, cwcPattern) == 0 )
        {
            return wcsString;
        }

        wcsString++;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#define COTASKDECLSPEC extern

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <shellapi.h>

#include <stdlib.h>
#include <stddef.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <direct.h>
#include <crt\io.h>

#define _CAIROSTG_
#define _DCOM_
// #define OLEDBVER 0x0250 // enable ICommandTree interface
// #define deprecated      // enable IRowsetExactScroll

#include <cidebnot.h>
#include <cierror.h>

#include <oleext.h>
#include <oledberr.h>
#include <oledb.h>
#include <dbcmdtre.hxx>
#include <query.h>

#include <filterr.h>            // used in webhits!

//
// Query-specific
//

#include <stgprop.h>

#include <restrict.hxx>
#include <stgvar.hxx>
#include <vquery.hxx>

#include <ciexcpt.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <xolemem.hxx>
#include <cisem.hxx>
#include <dynarray.hxx>
#include <readwrit.hxx>
#include <ci.h>
#include <ci64.hxx>

#include <qutildbg.hxx>

#include <align.hxx>

#include <params.hxx>
#include <tgrow.hxx>
#include <propspec.hxx>

#include <dbqrslt.hxx>
#include <tfilt.hxx>

#include <qlibutil.hxx>
#include <parser.hxx>
#include <lgplist.hxx>
#include <scanner.hxx>
#include <plist.hxx>
#include <wcstoi64.hxx>
#include <strrest.hxx>

#include <string.hxx>
#include <fmapio.hxx>
#include <mbutil.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\monarch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:       monarch.cxx
//
//  Contents:   Public interfaces to Index Server
//
//  History:    24 Jan 1997      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <pvarset.hxx>
#include <strsort.hxx>
#include <ciplist.hxx>
#include <doquery.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   AddToPropertyList, private
//
//  Synopsis:   Adds an array of properties to a property list
//
//  Arguments:  [PropertyList] -- destination for the props
//              [cProperties]  -- # of properties to add
//              [pProperties]  -- source of props
//              [lcid]         -- Locale (used for uppercasing)
//
//  History:    21 Jul 1997      dlee    Created
//
//----------------------------------------------------------------------------

void AddToPropertyList( CLocalGlobalPropertyList & PropertyList,
                        ULONG                      cProperties,
                        CIPROPERTYDEF *            pProperties,
                        LCID                       lcid )
{
    if ( ( 0 != cProperties ) && ( 0 == pProperties ) )
        THROW( CException( E_INVALIDARG ) );

    XGrowable<WCHAR> xTemp;

    for ( unsigned i = 0; i < cProperties; i++ )
    {
        //
        // Uppercase the friendly name.  Done at this level of code to
        // optimize other property lookup paths.
        //

        int cc = wcslen( pProperties[i].wcsFriendlyName ) + 1;

        xTemp.SetSize( cc + cc/2 );

        int ccOut = LCMapString( lcid,
                                 LCMAP_UPPERCASE,
                                 pProperties[i].wcsFriendlyName,
                                 cc,
                                 xTemp.Get(),
                                 xTemp.Count() );

        Win4Assert( 0 != ccOut );
        Win4Assert( 0 == xTemp[ccOut-1] );

        if ( 0 == ccOut )
            THROW( CException() );

        XPtr<CPropEntry> xEntry;

        //
        // Did the string change?
        //

        if ( ccOut == cc &&
             RtlEqualMemory( pProperties[i].wcsFriendlyName, xTemp.Get(), cc*sizeof(WCHAR) ) )
        {
            xEntry.Set( new CPropEntry( pProperties[i].wcsFriendlyName,
                                        0,
                                        (DBTYPE) pProperties[i].dbType,
                                        pProperties[i].dbCol ) );
        }
        else
        {
            XPtrST<WCHAR> xFName( new WCHAR[ccOut] );
            RtlCopyMemory( xFName.GetPointer(), xTemp.Get(), ccOut * sizeof(WCHAR) );

            xEntry.Set( new CPropEntry( xFName,
                                        (DBTYPE) pProperties[i].dbType,
                                        pProperties[i].dbCol ) );
        }

        //
        // Add new property to list.
        //

        PropertyList.AddEntry( xEntry.GetPointer(), 0 );
        xEntry.Acquire();
    }
} //AddToPropertyList

//+---------------------------------------------------------------------------
//
//  Function:   CITextToSelectTree, public
//
//  Synopsis:   Converts a Tripoli query string into a DBCOMMANDTREE
//
//  Arguments:  [pwszRestriction] - input query string
//              [ppTree] - output command tree
//              [cProperties] - number of extension properties
//              [pProperties] - pointer to extension property array
//
//  History:    29 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

SCODE CITextToSelectTree(
    WCHAR const *     pwszRestriction,
    DBCOMMANDTREE * * ppTree,
    ULONG             cProperties,
    CIPROPERTYDEF *   pProperties,
    LCID              LocaleID )
{
    return CITextToSelectTreeEx( pwszRestriction,
                                 ISQLANG_V1,
                                 ppTree,
                                 cProperties,
                                 pProperties,
                                 LocaleID );
} //CITextToSelectTree

//+---------------------------------------------------------------------------
//
//  Function:   CITextToFullTree
//
//  Synopsis:   Forms a DBCOMMANDTREE from the given restriction, output
//              columns and sort columns.
//
//  Arguments:  [pwszRestriction] - Input query string in "Triplish"
//              [pwszColumns]     - List of comma separated output columns.
//              [pwszSortColumns] - sort specification, may be NULL
//              [pwszGrouping]    - grouping specification, may be NULL
//              [ppTree]          - [out] The DBCOMMANDTREE representing the
//                                  query.
//              [cProperties]     - [in] Number of properties in pProperties
//              [pProperties]     - [in] List of custom properties
//              [LocaleID]        - [in] The locale for query parsing
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    3-03-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CITextToFullTree( WCHAR const *     pwszRestriction,
                        WCHAR const *     pwszColumns,
                        WCHAR const *     pwszSortColumns,
                        WCHAR const *     pwszGrouping,
                        DBCOMMANDTREE * * ppTree,
                        ULONG             cProperties,
                        CIPROPERTYDEF *   pProperties,
                        LCID              LocaleID )
{
    return CITextToFullTreeEx( pwszRestriction,
                               ISQLANG_V1,
                               pwszColumns,
                               pwszSortColumns,
                               pwszGrouping,
                               ppTree,
                               cProperties,
                               pProperties,
                               LocaleID );
} //CITextToFullTree

//+---------------------------------------------------------------------------
//
//  Function:   CITextToSelectTreeEx, public
//
//  Synopsis:   Converts a Tripoli query string into a DBCOMMANDTREE
//
//  Arguments:  [pwszRestriction] - input query string
//              [ulDialect]       - dialect of triplish
//              [ppTree] - output command tree
//              [cProperties] - number of extension properties
//              [pProperties] - pointer to extension property array
//
//  History:    29 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

SCODE CITextToSelectTreeEx(
    WCHAR const *     pwszRestriction,
    ULONG             ulDialect,
    DBCOMMANDTREE * * ppTree,
    ULONG             cProperties,
    CIPROPERTYDEF *   pProperties,
    LCID              LocaleID )
{
    if ( 0 == pwszRestriction || 0 == *pwszRestriction || 0 == ppTree )
        return E_INVALIDARG;

    if ( ISQLANG_V1 != ulDialect &&
         ISQLANG_V2 != ulDialect )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        LCID lcid = LocaleID;
        if (lcid == -1)
            lcid = GetSystemDefaultLCID();

        XInterface<CLocalGlobalPropertyList> xPropertyList(new CLocalGlobalPropertyList(lcid));
        AddToPropertyList( xPropertyList.GetReference(),
                           cProperties,
                           pProperties,
                           LocaleID );

        //
        //  Setup the variables needed to execute this query; including:
        //
        //      CiRestriction
        //      CiMaxRecordsInResultSet
        //      CiSort
        //

        // ixssoDebugOut(( DEB_TRACE, "ExecuteQuery:\n" ));
        // ixssoDebugOut(( DEB_TRACE, "\tCiRestriction = '%ws'\n", pwszRestriction ));

        *ppTree = GetStringDbRestriction( pwszRestriction,
                                          ulDialect,
                                          xPropertyList.GetPointer(),
                                          lcid )->CastToStruct();

    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CITextToSelectTreeEx

//+---------------------------------------------------------------------------
//
//  Function:   CITextToFullTreeEx
//
//  Synopsis:   Forms a DBCOMMANDTREE from the given restriction, output
//              columns and sort columns.
//
//  Arguments:  [pwszRestriction] - Input query string in "Triplish"
//              [ulDialect]       - Dialect of Triplish
//              [pwszColumns]     - List of comma separated output columns.
//              [pwszSortColumns] - sort specification, may be NULL
//              [pwszGrouping]    - grouping specification, may be NULL
//              [ppTree]          - [out] The DBCOMMANDTREE representing the
//                                  query.
//              [cProperties]     - [in] Number of properties in pProperties
//              [pProperties]     - [in] List of custom properties
//              [LocaleID]        - [in] The locale for query parsing
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    3-03-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CITextToFullTreeEx( WCHAR const * pwszRestriction,
                          ULONG         ulDialect,
                          WCHAR const * pwszColumns,
                          WCHAR const * pwszSortColumns,
                          WCHAR const * pwszGrouping,
                          DBCOMMANDTREE * * ppTree,
                          ULONG cProperties,
                          CIPROPERTYDEF * pProperties,
                          LCID           LocaleID )
{
    if ( 0 == ppTree ||
         0 == pwszRestriction ||
         0 == *pwszRestriction ||
         0 == pwszColumns ||
         0 == *pwszColumns )
        return E_INVALIDARG;

    if ( ISQLANG_V1 != ulDialect &&
         ISQLANG_V2 != ulDialect )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        LCID lcid = LocaleID;
        if (lcid == -1)
            lcid = GetSystemDefaultLCID();

        XInterface<CLocalGlobalPropertyList> xPropertyList(new CLocalGlobalPropertyList(lcid));
        AddToPropertyList( xPropertyList.GetReference(),
                           cProperties,
                           pProperties,
                           LocaleID );

        CTextToTree textToTree( pwszRestriction,
                                ulDialect,
                                pwszColumns,
                                xPropertyList.GetPointer(),
                                lcid,
                                pwszSortColumns,
                                pwszGrouping );

        *ppTree = textToTree.FormFullTree();
    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CITextToFullTreeEx

//+---------------------------------------------------------------------------
//
//  Function:   CIBuildQueryNode
//
//  Synopsis:   Build a simple restriction node.
//
//  Arguments:  [wcsProperty]       - Target property
//              [dwOperator]        - Enumerated operator
//              [pvarPropertyValue] - property value
//              [ppTree]            - [out] The DBCOMMANDTREE representing the
//                                    simple restriction.
//              [cProperties]       - # of props in the pProperties array
//              [pProperties]       - Array of properties
//              [LocaleId]          - Locale to use.
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    July 22 1997   KrishnaN   Created
//
//----------------------------------------------------------------------------

SCODE CIBuildQueryNode(WCHAR const *wcsProperty,
                       DBCOMMANDOP dbOperator,
                       PROPVARIANT const *pvarPropertyValue,
                       DBCOMMANDTREE ** ppTree,
                       ULONG cProperties,
                       CIPROPERTYDEF const * pProperties, // Can be 0.
                       LCID LocaleID)
{
    if (0 == pvarPropertyValue || 0 == ppTree ||
        (cProperties > 0 && 0 == pProperties))
        return E_INVALIDARG;

    XInterface<CLocalGlobalPropertyList> xPropertyList;

    SCODE sc = S_OK;
    *ppTree = 0;

    CTranslateSystemExceptions translate;
    TRY
    {
        xPropertyList.Set( new CLocalGlobalPropertyList( LocaleID ) );

        //
        // No need to add to prop list if this is dbop_content.
        // CITextToSelectTree does that.
        //

        if (pProperties && dbOperator != DBOP_content)
        {
            AddToPropertyList( xPropertyList.GetReference(),
                               cProperties,
                               (CIPROPERTYDEF *)pProperties,
                               LocaleID );
        }

        DBID *pdbid = 0;
        CDbColId *pcdbCol = 0;
        DBTYPE ptype;

        // dbop_content prop info is taken care in citexttoselecttree call
        if (dbOperator != DBOP_content)
        {
            if( FAILED(xPropertyList->GetPropInfoFromName( wcsProperty,
                                     &pdbid,
                                     &ptype,
                                     0 )) )
                THROW( CParserException( QPARSE_E_NO_SUCH_PROPERTY ) );
        }

        pcdbCol = (CDbColId *)pdbid;

        switch (dbOperator)
        {
            //
            // The caller passes a chunk of text. Pass it
            // to the parser and have it build a restriction
            // for us.
            //

            case DBOP_content:
            {
                if (pvarPropertyValue->vt != VT_LPWSTR &&
                    pvarPropertyValue->vt != (DBTYPE_WSTR|DBTYPE_BYREF))
                    THROW( CException( E_INVALIDARG ) );

                sc = CITextToSelectTree(pvarPropertyValue->pwszVal,
                                        ppTree,
                                        cProperties,
                                        (CIPROPERTYDEF *)pProperties,
                                        LocaleID );
                break;
            }

            //
            // The caller passes a chunk of text which should be
            // interpreted as free text. Build a natlang restriction.
            //

            case DBOP_content_freetext:
            {
                if (pvarPropertyValue->vt != VT_LPWSTR &&
                    pvarPropertyValue->vt != (DBTYPE_WSTR|DBTYPE_BYREF))
                    THROW( CException( E_INVALIDARG ) );

                XPtr<CDbNatLangRestriction> xNatLangRst( new CDbNatLangRestriction( pvarPropertyValue->pwszVal,
                                                                                    *pcdbCol,
                                                                                    LocaleID ) );
                if ( xNatLangRst.IsNull() || !xNatLangRst->IsValid() )
                    THROW( CException( E_OUTOFMEMORY ) );

                *ppTree = xNatLangRst->CastToStruct();
                xNatLangRst.Acquire();

                break;
            }

            //
            // Regular expressions and  property value queries
            //

            case DBOP_like:
            case DBOP_equal:
            case DBOP_not_equal:
            case DBOP_less:
            case DBOP_less_equal:
            case DBOP_greater:
            case DBOP_greater_equal:
            case DBOP_allbits:
            case DBOP_anybits:

            case DBOP_equal_all:
            case DBOP_not_equal_all:
            case DBOP_greater_all:
            case DBOP_greater_equal_all:
            case DBOP_less_all:
            case DBOP_less_equal_all:
            case DBOP_allbits_all:
            case DBOP_anybits_all:

            case DBOP_equal_any:
            case DBOP_not_equal_any:
            case DBOP_greater_any:
            case DBOP_greater_equal_any:
            case DBOP_less_any:
            case DBOP_less_equal_any:
            case DBOP_allbits_any:
            case DBOP_anybits_any:
            {
                XPtr<CDbPropertyRestriction> xPrpRst( new CDbPropertyRestriction
                                                       (dbOperator,
                                                        *(pcdbCol->CastToStruct()),
                                                        *(CStorageVariant const *)(void *)pvarPropertyValue) );
                if ( xPrpRst.IsNull() || !xPrpRst->IsValid() )
                    THROW( CException( E_OUTOFMEMORY ) );

                *ppTree = xPrpRst->CastToStruct();
                xPrpRst.Acquire();

                break;
            }

            default:
                sc = E_INVALIDARG;
                break;
        }
    }
    CATCH(CException, e)
    {
        sc = GetScodeError( e );
        Win4Assert(0 == *ppTree);
    }
    END_CATCH

    return sc;
} //CIBuildQueryNode

//+---------------------------------------------------------------------------
//
//  Function:   CIBuildQueryTree
//
//  Synopsis:   Build a restriction tree from an existing tree (could be empty)
//              and a newly added node/tree.
//
//  Arguments:  [pExistingTree]  - Ptr to existing command tree
//              [dwBoolOp]       - Enumerated boolean operator
//              [cSiblings]      - Number of trees to combine at the same level.
//              [ppSibsToCombine]- Array of sibling tree to combine.
//              [ppTree]         - [out] The DBCOMMANDTREE representing the
//                                 combined restriction.
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    July 22 1997   KrishnaN   Created
//
//----------------------------------------------------------------------------

SCODE CIBuildQueryTree(DBCOMMANDTREE const *pExistingTree,
                       DBCOMMANDOP dbBoolOp,
                       ULONG cSiblings,
                       DBCOMMANDTREE const * const *ppSibsToCombine,
                       DBCOMMANDTREE ** ppTree)
{
    if (0 == cSiblings || 0 == ppTree ||
        0 == ppSibsToCombine || 0 == *ppSibsToCombine)
        return E_INVALIDARG;

    // AND and OR should have at least two operands
    if ((dbBoolOp == DBOP_and || dbBoolOp == DBOP_or) &&
        0 == pExistingTree && cSiblings < 2)
        return E_INVALIDARG;

    // NOT should have only one operand
    if (dbBoolOp == DBOP_not && (pExistingTree || cSiblings > 1))
        return E_INVALIDARG;

    *ppTree = 0;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        switch(dbBoolOp)
        {
            case DBOP_and:
            case DBOP_or:
            {
                CDbBooleanNodeRestriction *pAndOrCombiner = new CDbBooleanNodeRestriction( dbBoolOp );
                if (0 == pAndOrCombiner)
                    THROW( CException( E_OUTOFMEMORY ) );

                if (pExistingTree)
                    pAndOrCombiner->AppendChild((CDbRestriction *)CDbCmdTreeNode::CastFromStruct(pExistingTree));

                for (ULONG i = 0; i < cSiblings; i++)
                    pAndOrCombiner->AppendChild((CDbRestriction *)CDbCmdTreeNode::CastFromStruct(ppSibsToCombine[i]));

                *ppTree = pAndOrCombiner->CastToStruct();

                break;
            }

        case DBOP_not:
            {
                CDbNotRestriction *pNotCombiner = new CDbNotRestriction((CDbRestriction *)
                                                      CDbCmdTreeNode::CastFromStruct(ppSibsToCombine[0]));
                if (0 == pNotCombiner)
                    THROW( CException( E_OUTOFMEMORY ) );
                *ppTree = pNotCombiner->CastToStruct();

                break;
            }

            default:
                sc = E_INVALIDARG;
                break;
        }
    }
    CATCH(CException, e)
    {
        sc = GetScodeError( e );
        Win4Assert(0 == *ppTree);
    }
    END_CATCH

    return sc;
} //CIBuildQueryTree

//+---------------------------------------------------------------------------
//
//  Function:   CIRestrictionToFullTree
//
//  Synopsis:   Forms a DBCOMMANDTREE from the given restriction, output
//              columns and sort columns.
//
//  Arguments:  [pTree]           - Input query tree
//              [pwszColumns]     - List of comma separated output columns.
//              [pwszSortColumns] - sort specification, may be NULL
//              [pwszGrouping]    - grouping specification, may be NULL
//              [ppTree]          - [out] The DBCOMMANDTREE representing the
//                                  query.
//              [cProperties]     - [in] Number of properties in pProperties
//              [pProperties]     - [in] List of custom properties
//              [LocaleID]        - [in] The locale for query parsing
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    3-03-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CIRestrictionToFullTree( DBCOMMANDTREE const *pTree,
                               WCHAR const * pwszColumns,
                               WCHAR const * pwszSortColumns,
                               WCHAR const * pwszGrouping,
                               DBCOMMANDTREE * * ppTree,
                               ULONG cProperties,
                               CIPROPERTYDEF * pProperties,
                               LCID           LocaleID )
{
    if ( 0 == ppTree ||
         0 == pTree ||
         0 == pwszColumns ||
         0 == *pwszColumns )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        LCID lcid = LocaleID;
        if (lcid == -1)
            lcid = GetSystemDefaultLCID();

        XInterface<CLocalGlobalPropertyList> xPropertyList(new CLocalGlobalPropertyList(LocaleID));
        AddToPropertyList( xPropertyList.GetReference(),
                           cProperties,
                           pProperties,
                           LocaleID );

        CTextToTree RestrictionToTree( pTree,
                                       pwszColumns,
                                       xPropertyList.GetPointer(),
                                       lcid,
                                       pwszSortColumns,
                                       pwszGrouping );

        *ppTree = RestrictionToTree.FormFullTree();
    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CIRestrictionToFullTree

//+---------------------------------------------------------------------------
//
//  Function:   CIMakeICommand
//
//  Synopsis:   Creates an ICommand
//
//  Arguments:  [ppCommand]   -- where the ICommand is returned
//              [cScope]      -- # of items in below arrays
//              [aDepths]     -- array of depths
//              [awcsScope]   -- array of scopes
//              [awcsCat]     -- array of catalogs
//              [awcsMachine] -- array of machines
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    6-11-97   dlee      Fixed and added header
//
//----------------------------------------------------------------------------

SCODE CIMakeICommand( ICommand **           ppCommand,
                      ULONG                 cScope,
                      DWORD const *         aDepths,
                      WCHAR const * const * awcsScope,
                      WCHAR const * const * awcsCat,
                      WCHAR const * const * awcsMachine )
{
    if ( 0 == ppCommand ||
         0 == aDepths ||
         0 == awcsScope ||
         0 == awcsCat ||
         0 == awcsMachine ||
         0 == cScope )
        return E_INVALIDARG;

    *ppCommand = 0;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        // First get an ICommand object as an IUnknown

        XInterface<IUnknown> xUnk;
        sc = MakeICommand( xUnk.GetIUPointer(), 0, 0, 0 );

        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        // QI to ICommand

        XInterface<ICommand> xCommand;
        sc = xUnk->QueryInterface( IID_ICommand,
                                   xCommand.GetQIPointer() );

        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        // SetScopeProperties throws

        SetScopeProperties( xCommand.GetPointer(),
                            cScope,
                            awcsScope,
                            aDepths,
                            awcsCat,
                            awcsMachine );

        *ppCommand = xCommand.Acquire();
    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CIMakeICommand

//+---------------------------------------------------------------------------
//
//  Function:   CICreateCommand
//
//  Synopsis:   Creates an ICommand
//
//  Arguments:  [ppResult]    -- where the resulting interface is returned
//              [pUnkOuter]   -- outer unknown
//              [riid]        -- iid of interface to return.  Must be
//                               IID_IUnknown unless pUnkOuter == 0
//              [pwcsCatalog] -- catalog
//              [pwcsMachine] -- machine
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    6-11-97   dlee      Fixed and added header
//
//----------------------------------------------------------------------------

SCODE CICreateCommand( IUnknown **   ppResult,
                       IUnknown *    pUnkOuter,
                       REFIID        riid,
                       WCHAR const * pwcsCatalog,
                       WCHAR const * pwcsMachine )
{
    if ( 0 != pUnkOuter && IID_IUnknown != riid )
        return CLASS_E_NOAGGREGATION;

    if ( 0 == ppResult ||
         0 == pwcsCatalog ||
         0 == pwcsMachine )
        return E_INVALIDARG;

    // try to AV

    *ppResult = 0;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        //
        // First get an ICommand object as an IUnknown
        //

        XInterface<IUnknown> xUnk;
        sc = MakeICommand( xUnk.GetIUPointer(),
                           0,
                           0,
                           pUnkOuter );

        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        //
        // QI to the interface requested
        //

        if ( IID_IUnknown != riid )
        {
            IUnknown *pUnk;
            sc = xUnk->QueryInterface( riid,
                                       (void **) & pUnk );

            if ( FAILED( sc ) )
                THROW( CException( sc ) );

            xUnk.Free();
            xUnk.Set( pUnk );
        }

        //
        // Set the scope, catalogs, and machines
        //

        {
            // SetScopeProperties throws

            DWORD dwFlags = QUERY_DEEP;
            WCHAR const * pwcScope = L"\\";

            //
            // cheezy hack cast, since I can't QI for the ICommand yet
            // if the outer unknown is specified.  Assume MakeICommand
            // returns an ICommand under the IUnknown.
            //

            SetScopeProperties( (ICommand *) xUnk.GetPointer(),
                                1,
                                &pwcScope,
                                &dwFlags,
                                &pwcsCatalog,
                                &pwcsMachine );
        }

        *ppResult = xUnk.Acquire();
    }
    CATCH ( CException, e )
    {
        //
        // This is Index Server's function, not OLE-DB's, so don't mask
        // errors as E_FAIL with GetOleError
        //

        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CICreateCommand

//+---------------------------------------------------------------------------
//
//  Class:      CIPropertyList
//
//  Synopsis:   allow access to the default property list used by CITextTo*Tree
//
//  History:    08-Aug-97   alanw     Created
//
//----------------------------------------------------------------------------

class CIPropertyList : public ICiPropertyList
{
public:

    CIPropertyList() : _cRef( 1 )
    {
        _xproplist.Set( new CLocalGlobalPropertyList() );
    }

    ~CIPropertyList()
    {
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( )
    {
        return InterlockedIncrement(&_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( )
    {
        ULONG uTmp = InterlockedDecrement(&_cRef);
        if (uTmp == 0)
        {
            delete this;
            return 0;
        }
        return uTmp;
    }

    virtual BOOL GetPropInfo( WCHAR const * wcsPropName,
                              DBID ** ppPropid,
                              DBTYPE * pPropType,
                              unsigned int * puWidth )
    {
        return (S_OK == _xproplist->GetPropInfoFromName(
                                               wcsPropName,
                                               ppPropid,
                                               pPropType,
                                               puWidth ));
    }

    virtual BOOL GetPropInfo( DBID  const & prop,
                              WCHAR const ** pwcsName,
                              DBTYPE * pPropType,
                              unsigned int * puWidth )
    {
        return (S_OK == _xproplist->GetPropInfoFromId(
                                         &prop,
                                         (WCHAR **)pwcsName,
                                         pPropType,
                                         puWidth ));
    }

    virtual BOOL EnumPropInfo( ULONG const & iEntry,
                               WCHAR const ** pwcsName,
                               DBID  ** ppProp,
                               DBTYPE * pPropType,
                               unsigned int * puWidth )
    {
        return FALSE; // Not implemented because no one needs it.
    }

private:
    XInterface<CLocalGlobalPropertyList> _xproplist;
    LONG _cRef;

};

//+---------------------------------------------------------------------------
//
//  Function:   CIGetGlobalPropertyList, public
//
//  Synopsis:   Gets a reference to the property list used by CITextToSelectTree
//
//  Arguments:  [ppPropList]  -- where the ICiPropertyList is returned
//
//  Returns:    S_OK if successful; Error code otherwise
//
//  History:    08-Aug-97   alanw     Created
//
//----------------------------------------------------------------------------

SCODE CIGetGlobalPropertyList( ICiPropertyList ** ppPropList )
{
    if ( 0 == ppPropList )
        return E_INVALIDARG;

    *ppPropList = 0;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        XPtr<CIPropertyList> xProplist( new CIPropertyList() );

        *ppPropList = xProplist.Acquire();
    }
    CATCH ( CException, e )
    {
        sc = GetScodeError( e );
    }
    END_CATCH;

    return sc;
} //CIGetGlobalPropertyList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\parser.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       PARSER.CXX
//
//  Contents:   Implementation of the CQueryParser class
//
//  History:    30-Apr-92   AmyA        Created.
//              23-Jun-92   MikeHew     Added weight parsing.
//              11-May-94   t-jeffc     Rewrote to support new queries;
//                                      added exception handling
//              02-Mar-95   t-colinb    Added CPropertyValueParser and
//                                      augmented the parser to generate
//                                      a CPropertyRestriction with a
//                                      value
//              25-Sep-95   sundarA     Modified relative date calculation;
//                                      Replaced 'c' runtime dependant time
//                                      functions.  Modified 
//                                      CPropertyValueParser::CheckForRelativeDate
//
//  Notes:      See bnf.txt for a complete listing of the grammar.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cichkstk.hxx>
#include <parser.hxx>

DECLARE_INFOLEVEL(qutil);

static const GUID guidSystem = PSGUID_STORAGE;
static CDbColId psContents( guidSystem, PID_STG_CONTENTS );

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::ParseQueryPhrase, public
//
//  Synopsis:   Parses a query and returns it in the form of a tree.
//
//  Arguments:  - none -
//
//  History:    03 Feb 1998   AlanW       Added error checks
//
//----------------------------------------------------------------------------

CDbRestriction *  CQueryParser::ParseQueryPhrase()
{
    CTrackRecursionDepth<CQueryParser> track( *this );

    XDbRestriction prstQuery( Query( 0 ) );

    // extraneous input at the end of the query?
    if( !_scan.IsEmpty() )
    {
        SCODE sc = QPARSE_E_EXPECTING_EOS;
        if ( _scan.LookAhead() == NOT_TOKEN )
            sc = QPARSE_E_UNEXPECTED_NOT;
        THROW( CParserException( sc ) );
    }

    return prstQuery.Acquire();
} //ParseQueryPhrase

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::Query, private
//
//  Synopsis:   Recursive function that calls QExpr and creates a vector node
//              if necessary.
//
//  Arguments:  [prstVector] -- if non-null, a Vector node that can be added to.
//
//  Production: Query    : QExpr
//                       | QExpr COMMA_TOKEN Query
//
//  History:    01-May-92   AmyA        Created
//              23-Jun-92   MikeHew     Added weight parsing.
//              10-Feb-93   KyleP       Convert to restrictions
//              11-May-94   t-jeffc     Rewrote to support vectors
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::Query( CDbNodeRestriction * prstVector )
{
    CTrackRecursionDepth<CQueryParser> track( *this );

    XDbRestriction prstExpr( QExpr( 0 ) );
    unsigned pos;

    if( _scan.LookAhead() == COMMA_TOKEN )
    {
        _scan.Accept();

        if ( prstVector == 0 )
        {
            //
            // Special case: If the first value is a rank method specifier.
            //

            if ( prstExpr->GetCommandType() == DBOP_content )
            {
                CDbContentRestriction * pContent = (CDbContentRestriction *)prstExpr.GetPointer();

                WCHAR const * pPhrase = pContent->GetPhrase();

                if ( pPhrase[0] == L'-')
                {
                    if ( 0 == _wcsicmp( L"--Jaccard--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_JACCARD;
                        delete prstExpr.Acquire();
                    }
                    else if ( 0 == _wcsicmp( L"--Dice--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_DICE;
                        delete prstExpr.Acquire();
                    }
                    else if ( 0 == _wcsicmp( L"--Inner--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_INNER;
                        delete prstExpr.Acquire();
                    }
                    else if ( 0 == _wcsicmp( L"--Max--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_MAX;
                        delete prstExpr.Acquire();
                    }
                    else if ( 0 == _wcsicmp( L"--Min--", pPhrase) )
                    {
                        _rankMethod = VECTOR_RANK_MIN;
                        delete prstExpr.Acquire();
                    }
                }
            }

            qutilDebugOut(( DEB_TRACE,
                            "setting rank method to: %d\n",
                            _rankMethod ));

            // create smart Vector node

            XDbVectorRestriction prstNew( new CDbVectorRestriction( _rankMethod ) );
            if ( prstNew.IsNull() )
                THROW( CException( E_OUTOFMEMORY ) );

            // add left expression & release its smart pointer
            if ( !prstExpr.IsNull() )
            {
                prstNew->AppendChild( prstExpr.GetPointer() );
                prstExpr.Acquire();
            }

            if ( !prstNew->IsValid() )
                THROW( CException( E_OUTOFMEMORY ) );

            // parse right expression

            CDbRestriction * prst = Query( prstNew.GetPointer() );

            // release pointer to the vector node
            prstNew.Acquire();

            return prst;
        }
        else    // there already is a vector node
        {
            // add expression & release its smart pointer
            prstVector->AppendChild( prstExpr.GetPointer() );
            prstExpr.Acquire();

            // parse right expression
            return Query( prstVector );
        }
    }
    else    // no more COMMA_TOKENs
    {
        if( prstVector != 0 )   // add last child
        {
            // add expression & release its smart pointer
            prstVector->AppendChild( prstExpr.GetPointer() );
            prstExpr.Acquire();

            return prstVector;
        }
        else                    // no vector nodes
        {
            // release & return expression
            return prstExpr.Acquire();
        }
    }
} //Query

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QExpr, private
//
//  Synopsis:   Recursive function that calls QTerm and creates an Or
//              node if necessary.
//
//  Arguments:  [prstOr] -- if non-null, an Or node that can be added to.
//
//  Production: QExpr   :   QTerm
//                      |   QTerm OR_TOKEN QExpr
//
//  History:    05-May-94   t-jeffc         Created
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QExpr( CDbBooleanNodeRestriction * prstOr )
{
    CTrackRecursionDepth<CQueryParser> track( *this );

    XDbRestriction prstTerm( QTerm( 0 ) );

    if ( _scan.LookAhead() == OR_TOKEN )
    {
        _scan.Accept();

        if ( 0 == prstOr )
        {
            // create smart Or node
            XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_or ) );
            if ( prstNew.IsNull() )
                THROW( CException( E_OUTOFMEMORY ) );

            // add left term & release its smart pointer
            prstNew->AppendChild( prstTerm.GetPointer() );

            // release smart Or node pointer
            prstTerm.Acquire();

            // parse right expression
            CDbRestriction * prst = QExpr( prstNew.GetPointer() );

            // release smart Or node pointer
            prstNew.Acquire();

            return prst;
        }
        else    // there already is an Or node to add to
        {
            // add left term & release its smart pointer
            prstOr->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            // add more children
            return QExpr( prstOr );
        }
    }
    else    // no more OR_TOKENs
    {
        if( prstOr != 0 )   // add last child
        {
            // add term & release its smart pointer
            prstOr->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            return prstOr;
        }
        else                // no OR_TOKENs at all
            // release & return term
            return prstTerm.Acquire();
    }
} //QExpr

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QTerm, private
//
//  Synopsis:   Recursive function that calls QFactor and creates an And
//              node if necessary.
//
//  Arguments:  [prstAnd] -- if non-null, an And node that can be added to.
//
//  Production: QTerm   :   (NOT_TOKEN) QProp (W_OPEN_TOKEN Weight W_CLOSE_TOKEN)
//                      |   (NOT_TOKEN) QProp (W_OPEN_TOKEN Weight W_CLOSE_TOKEN) AND_TOKEN QTerm
//
//  History:    01-May-92   AmyA        Created
//              11-May-94   t-jeffc     Added NOTs; moved weights to this level
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QTerm( CDbBooleanNodeRestriction * prstAnd )
{
    CTrackRecursionDepth<CQueryParser> track( *this );

    XDbRestriction prstTerm;

    if ( _scan.LookAhead() == NOT_TOKEN )
    {
        _scan.Accept();

        // create smart Not node

        XDbNotRestriction prstNot( new CDbNotRestriction );
        if ( prstNot.IsNull() )
            THROW( CException( E_OUTOFMEMORY ) );

        // parse factor

        XDbRestriction prst( QProp() );

        // set child of Not node & release smart factor pointer

        prstNot->SetChild( prst.GetPointer() );
        prst.Acquire();

        // transfer ownership from prstNot to prstTerm

        prstTerm.Set( prstNot.Acquire() );
    }
    else
    {
        // wrap just the factor in the smart pointer

        prstTerm.Set( QProp() );
    }

    LONG lWeight;
    if( _scan.LookAhead() == W_OPEN_TOKEN )
    {
        _scan.Accept();

        BOOL fAtEnd;
        BOOL isNumber = _scan.GetNumber( lWeight, fAtEnd );

        if( !isNumber )
            THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

        _scan.Accept();

        if( _scan.LookAhead() != W_CLOSE_TOKEN )
            THROW( CParserException( QPARSE_E_EXPECTING_BRACE ) );

        _scan.Accept();

        if ( lWeight > MAX_QUERY_RANK )
            THROW( CParserException( QPARSE_E_WEIGHT_OUT_OF_RANGE ) );
    }
    else
    {
        lWeight = MAX_QUERY_RANK;
    }

    // We should be able to set weights on all the nodes.

    prstTerm->SetWeight( lWeight );

    if ( _scan.LookAhead() == AND_TOKEN )
    {
        _scan.Accept();

        if( 0 == prstAnd )
        {
            // create smart And node

            XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_and ) );
            if ( prstNew.IsNull() )
                THROW( CException( E_OUTOFMEMORY ) );

            // add left factor & release its smart pointer

            prstNew->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            // parse right expression

            CDbRestriction * prst = QTerm( prstNew.GetPointer() );

            // release smart And node pointer

            prstNew.Acquire();

            return prst;
        }
        else    // there already is an And node to add to
        {
            // add left factor & release its smart pointer

            prstAnd->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            // add more children

            return QTerm( prstAnd );
        }
    }
    else    // no more AND_TOKENs
    {
        if ( 0 != prstAnd )   // add last child
        {
            // add factor & release its smart pointer

            prstAnd->AppendChild( prstTerm.GetPointer() );
            prstTerm.Acquire();

            return prstAnd;
        }

        // no AND_TOKENs at all
        // release & return factor

        return prstTerm.Acquire();
    }
} //QTerm

//
// array for converting token to relop - this relies on the order
// of the token enumeration in scanner.hxx
//
enum DBOPModifier
{
    DBOPModifyNone = 0,
    DBOPModifyAll  = 1,
    DBOPModifyAny  = 2
};

static const DBCOMMANDOP rgRelopToken[] =
{
    DBOP_equal,
    DBOP_not_equal,
    DBOP_greater,
    DBOP_greater_equal,
    DBOP_less,
    DBOP_less_equal,
    DBOP_allbits,
    DBOP_anybits,

    DBOP_equal_all,
    DBOP_not_equal_all,
    DBOP_greater_all,
    DBOP_greater_equal_all,
    DBOP_less_all,
    DBOP_less_equal_all,
    DBOP_allbits_all,
    DBOP_anybits_all,

    DBOP_equal_any,
    DBOP_not_equal_any,
    DBOP_greater_any,
    DBOP_greater_equal_any,
    DBOP_less_any,
    DBOP_less_equal_any,
    DBOP_allbits_any,
    DBOP_anybits_any,
};

const unsigned cRelopToken = sizeof rgRelopToken / sizeof rgRelopToken[0];

inline DBCOMMANDOP FormDBOP( ULONG op, ULONG opModifier )
{
    Win4Assert( cRelopToken == (SOMEOF_TOKEN+1) * (DBOPModifyAny+1) );
    Win4Assert( op <= SOMEOF_TOKEN );
    Win4Assert( opModifier <= DBOPModifyAny );

    return rgRelopToken[ opModifier*(SOMEOF_TOKEN+1) + op ];
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QProp, private
//
//  Synopsis:   Allows a prop specification or uses the current property
//              for the following factor.
//
//  Production: QProp : QFactor
//                    | PROP_TOKEN property QFactor
//                    | PROP_REGEX_TOKEN property (EQUAL_TOKEN) REGEX
//                    | PROP_NATLANG_TOKEN property QPhrase
//
//  History:    05-May-92   AmyA        Created
//              11-May-94   t-jeffc     Added regex support and expanded
//                                      property restrictions
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QProp()
{
    CTrackRecursionDepth<CQueryParser> track( *this );

    XDbRestriction prstFactor;
    XPtrST<WCHAR> wcsProperty;

    switch( _scan.LookAhead() )
    {
    case PROP_TOKEN:
    {
        _scan.Accept();

        // parse property name & cache in smart pointer
        wcsProperty.Set( _scan.AcqColumn() );

        if( wcsProperty.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_PROPERTY ) );

        _scan.AcceptColumn();

        // make this property the current one
        SetCurrentProperty( wcsProperty.GetPointer(), CONTENTS );

        prstFactor.Set( QFactor() );
        break;
    }

    case PROP_REGEX_TOKEN:      // process 'PROP_REGEX_TOKEN property regex' rule
    {
        _scan.Accept();

        // get property name & cache in smart pointer
        wcsProperty.Set( _scan.AcqColumn() );

        if( wcsProperty.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_PROPERTY ) );

        _scan.AcceptColumn();

        SetCurrentProperty( wcsProperty.GetPointer(), REGEX );

        // allow optional equal token in regex queries

        if ( EQUAL_TOKEN == _scan.LookAhead() )
            _scan.Accept();

        prstFactor.Set( QPhrase() );
        break;
    }

    case PROP_NATLANG_TOKEN:    // process 'PROP_NATLANG_TOKEN property QGroup' rule
         _scan.Accept();

        // get property name & cache in smart pointer
        wcsProperty.Set( _scan.AcqColumn() );

        if( wcsProperty.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_PROPERTY ) );

        _scan.AcceptColumn();

        SetCurrentProperty( wcsProperty.GetPointer(), NATLANGUAGE );

        prstFactor.Set( QPhrase() );
        break;

    default:         // No property name
        prstFactor.Set( QFactor() );
        break;

    } // switch( _scan.LookAhead() )

    // release & return smart factor
    return prstFactor.Acquire();
} //QProp

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QFactor, private
//
//  Synopsis:   Calls Query if parentheses are detected.  Processes property
//              query if a PROP_TOKEN, PROP_REGEX_TOKEN or OP_TOKEN are found.
//              Otherwise calls QGroup.
//
//  Production: QFactor  : QGroup
//                       | OPEN_TOKEN Query CLOSE_TOKEN
//                       | OP_TOKEN phrase
//
//  History:    05-May-92   AmyA        Created
//              11-May-94   t-jeffc     Added regex support and expanded
//                                      property restrictions
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QFactor()
{
    CTrackRecursionDepth<CQueryParser> track( *this );

    XDbRestriction prstFactor;
    XPtrST<WCHAR> wcsProperty;

    switch( _scan.LookAhead() )
    {
    case OPEN_TOKEN:        // process 'OPEN_TOKEN Query CLOSE_TOKEN' rule
    {
        _scan.Accept();

        // save-away the current property so it can be restored after
        // the expression in parenthesis is parsed.

        unsigned cwc = wcslen( GetCurrentProperty() );

        XGrowable<WCHAR, 20> xSaveProp( cwc + 1 );
        wcscpy( xSaveProp.Get(), GetCurrentProperty() );
        PropertyType ptSave = _propType;

        // parse expression
        prstFactor.Set( Query( 0 ) );

        if( _scan.LookAhead() != CLOSE_TOKEN )
        {
            SCODE sc = QPARSE_E_EXPECTING_PAREN;
            if ( _scan.LookAhead() == NOT_TOKEN )
                sc = QPARSE_E_UNEXPECTED_NOT;
            THROW( CParserException( sc ) );
        }

        _scan.Accept();

        SetCurrentProperty( xSaveProp.Get(), ptSave );

        break;
    }

    case EQUAL_TOKEN:           // process 'OP_TOKEN phrase' rule
    case NOT_EQUAL_TOKEN:       // (only if in non-regex mode)
    case GREATER_TOKEN:
    case GREATER_EQUAL_TOKEN:
    case LESS_TOKEN:
    case LESS_EQUAL_TOKEN:
    case ALLOF_TOKEN:
    case SOMEOF_TOKEN:
        if( !IsRegEx() )
        {
            prstFactor.Set( ParsePropertyRst() );
            break;
        }

        // FALL THROUGH

    default:                    // No parentheses or op token
        prstFactor.Set( QGroup( 0 ) );
        break;

    } // switch( _scan.LookAhead() )

    // release & return smart factor
    return prstFactor.Acquire();
} //QFactor

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::ParsePropertyRst, private
//
//  Synopsis:   Parses a relational property restriction and returns
//              a CPropertyRestriction
//
//  History:    26-May-94   t-jeffc     Created
//              02-Mar-95   t-colinb    Added the parsing of vector properties
//
//----------------------------------------------------------------------------

CDbRestriction * CQueryParser::ParsePropertyRst()
{
    CTrackRecursionDepth<CQueryParser> track( *this );

    // create smart Property node
    XDbPropertyRestriction prstProp( new CDbPropertyRestriction );
    if ( prstProp.IsNull() )
        THROW( CException( E_OUTOFMEMORY ) );

    DBID *pdbid = 0;
    DBTYPE ptype;

    if( FAILED(_xList->GetPropInfoFromName(
                             GetCurrentProperty(),
                             &pdbid,
                             &ptype,
                             0 )) )
        THROW( CParserException( QPARSE_E_NO_SUCH_PROPERTY ) );

    CDbColId * pps = (CDbColId *)pdbid;
    Win4Assert( 0 != pps && pps->IsValid() );

    if (! prstProp->SetProperty( *pps ) )
        THROW( CException( E_OUTOFMEMORY ) );

    // don't allow @contents <relop> X -- it's too expensive and we'll
    // never find any hits anyway (until we implement this feature)

    if ( *pps == psContents )
        THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

    ULONG op = _scan.LookAhead();
    _scan.Accept();

    ULONG opModifier = DBOPModifyNone;

    //
    // look for a relop modifier like allof or anyof
    //
    switch( _scan.LookAhead() )
    {
        case ALLOF_TOKEN :
            opModifier = DBOPModifyAll;
            _scan.Accept();
            break;
        case SOMEOF_TOKEN :
            opModifier = DBOPModifyAny;
            _scan.Accept();
            break;
    }

    prstProp->SetRelation( FormDBOP( op, opModifier ) );

    switch( _scan.LookAhead() )
    {
    case PROP_TOKEN:
    case PROP_REGEX_TOKEN:  // process 'PROP_TOKEN property OP_TOKEN PROP_TOKEN property' rule
    #if 0
        {
            _scan.Accept();
            THROW( CParserException( QPARSE_E_NOT_YET_IMPLEMENTED ) );
        }
    #endif // 0

    default:                // process 'PROP_TOKEN property OP_TOKEN string' rule
    {

        CPropertyValueParser PropValueParser( _scan, ptype, _locale );

        XPtr<CStorageVariant> pStorageVar( PropValueParser.AcquireStgVariant() );

        if ( 0 != pStorageVar.GetPointer() )
        {
            // This should always be the case  - else PropValueParser would have thrown

            if ( ! ( ( prstProp->SetValue( pStorageVar.GetReference() ) ) &&
                     ( prstProp->IsValid() ) ) )
                THROW( CException( E_OUTOFMEMORY ) );
        }
    }

    } // switch

    // release & return property restriction
    return prstProp.Acquire();
} //ParsePropertyRst
 
//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QGroup, private
//
//  Synopsis:   Recursive function that calls QPhrase and creates a Proximity
//              node if necessary.
//
//  Arguments:  [prstProx] -- if non-null, a Proximity node that can be added to.
//
//  Production: QGroup  :   QPhrase
//                      |   QPhrase PROX_TOKEN QGroup
//
//  History:    04-May-92   AmyA        Created
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QGroup( CDbProximityNodeRestriction * prstProx )
{
    CTrackRecursionDepth<CQueryParser> track( *this );

    XDbRestriction prst;

    if ( 0 == prstProx )
        prst.Set( QPhrase() );
    else 
        prst.Set( QProp() );

    if( _scan.LookAhead() == PROX_TOKEN )
    {
        _scan.Accept();

        if ( 0 == prstProx )
        {
            // create smart Prox node
            XDbProximityNodeRestriction prstNew(new CDbProximityNodeRestriction());

            if( prstNew.IsNull() || !prstNew->IsValid() )
                THROW( CException( E_OUTOFMEMORY ) );

            // add left phrase & release its smart pointer
            prstNew->AppendChild( prst.GetPointer() );
            prst.Acquire();

            // parse right expression
            CDbRestriction * prst = QGroup( prstNew.GetPointer() );

            // release smart Prox node pointer
            prstNew.Acquire();

            return prst;
        }
        else    // there already is a Prox node to add to
        {
            // add left phrase & release its smart pointer
            prstProx->AppendChild( prst.GetPointer() );
            prst.Acquire();

            // add more children
            return QGroup( prstProx );
        }
    }
    else    // no more PROX_TOKENs
    {
        if( prstProx != 0 )   // add last child
        {
            // add phrase & release its smart pointer
            prstProx->AppendChild( prst.GetPointer() );
            prst.Acquire();

            return prstProx;
        }
        else                // no PROX_TOKENs at all
            // release & return phrase
            return prst.Acquire();
    }
} //QGroup

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::QPhrase, private
//
//  Synopsis:   If expecting a content query, acquires the phrase, determines
//              the fuzzy level and creates a ContentRestriction. If expecting
//              a natural language query, acquires the phrase and creates a
//              NatLanguageRestriction. If expecting a regular expression,
//              acquires that from the scanner and creates a new PropertyRestriction.
//
//  Production: QPhrase  : phrase(FUZZY_TOKEN | FUZ2_TOKEN)
//                       | REGEX
//                       | QUOTES_TOKEN extended_phrase(FUZZY_TOKEN | FUZ2_TOKEN)
//
//  History:    01-May-92   AmyA        Created
//              25-May-93   BartoszM    Changed fuzzy syntax
//              10-May-94   t-jeffc     Recognizes regex phrases
//
//----------------------------------------------------------------------------

CDbRestriction* CQueryParser::QPhrase()
{
    CTrackRecursionDepth<CQueryParser> track( *this );

    CDbColId * pps = 0;
    DBID *pdbid = 0;
    DBTYPE dbType;

    if( FAILED(_xList->GetPropInfoFromName( GetCurrentProperty(),
                             &pdbid,
                             &dbType,
                             0 )) )
        THROW( CParserException( QPARSE_E_NO_SUCH_PROPERTY ) );

    pps = (CDbColId *)pdbid;

    if( IsRegEx() )   // used PROP_REGEX_CHAR to specify property
    {
        if ( ( ( DBTYPE_WSTR|DBTYPE_BYREF ) != dbType ) &&
             ( ( DBTYPE_STR|DBTYPE_BYREF ) != dbType ) &&
             ( VT_BSTR != dbType ) &&
             ( VT_LPWSTR != dbType ) &&
             ( VT_LPSTR != dbType ) )
            THROW( CParserException( QPARSE_E_EXPECTING_REGEX_PROPERTY ) );

        XPtrST<WCHAR> phraseRegEx( _scan.AcqRegEx() );

        if( phraseRegEx.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_REGEX ) );

        _scan.Accept();

        // create smart Property node
        XDbPropertyRestriction prstProp( new CDbPropertyRestriction );
        if ( prstProp.IsNull() )
            THROW( CException( E_OUTOFMEMORY ) );

        prstProp->SetRelation(DBOP_like);      // LIKE relation

        if ( ( ! prstProp->SetProperty( *pps ) ) ||
             ( ! prstProp->SetValue( phraseRegEx.GetPointer() ) ) ||
             ( ! prstProp->IsValid() ) )
            THROW( CException( E_OUTOFMEMORY ) );

        // release & return smart Property node
        return prstProp.Acquire();
    }
    else
    {
        XPtrST<WCHAR> phrase;
        if ( _scan.LookAhead() == QUOTES_TOKEN )
        {
            _scan.AcceptQuote();
            phrase.Set( _scan.AcqPhraseInQuotes() );
        }
        else
            phrase.Set( _scan.AcqPhrase() );

        if( phrase.GetPointer() == 0 )
            THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

        _scan.Accept();

        int fuzzy = 0;
        Token tok = _scan.LookAhead();

        if ( tok == FUZZY_TOKEN )
        {
            _scan.Accept();
            fuzzy = 1;
        }
        else if ( tok == FUZ2_TOKEN )
        {
            _scan.Accept();
            fuzzy = 2;
        }

        if ( _propType == CONTENTS ) // used PROP_TOKEN to specify property
        {
            // create smart Content node

            XDbContentRestriction prstContent( new CDbContentRestriction( phrase.GetPointer(),
                                                                          *pps,
                                                                          fuzzy,
                                                                          _locale ));
            if ( prstContent.IsNull() || !prstContent->IsValid() )
                THROW( CException( E_OUTOFMEMORY ) );

            // release & return smart Content node
            return prstContent.Acquire();
        }
        else   // used PROP_NATLANG_TOKEN to specify property
        {
            // create smart Natural Language node

            XDbNatLangRestriction pNatLangRst( new CDbNatLangRestriction( phrase.GetPointer(),
                                                                          *pps,
                                                                          _locale ));
            if ( pNatLangRst.IsNull() || !pNatLangRst->IsValid() )
                THROW( CException( E_OUTOFMEMORY ) );

            // release & return smart Natural Language node
            return pNatLangRst.Acquire();
        }
    }
} //QPhrase

//+---------------------------------------------------------------------------
//
//  Member:     CQueryParser::SetCurrentProperty, private
//
//  Synopsis:   Changes the property used in content and property restrictions
//              from this point on in the input line.
//
//  Arguments:  wcsProperty -- friendly name of property
//                             (can be 0)
//              propType -- specifies the property type
//
//  Notes:      Makes its own copy of the property name
//              (unlike GetCurrentProperty, which just returns a pointer)
//
//  History:    18-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

void CQueryParser::SetCurrentProperty( WCHAR const * wcsProperty,
                                       PropertyType propType )
{
    delete [] _wcsProperty;
    _wcsProperty = 0;

    if ( 0 != wcsProperty )
    {
        int cwc = wcslen( wcsProperty ) + 1;

        _wcsProperty = new WCHAR[ cwc ];
        RtlCopyMemory( _wcsProperty, wcsProperty, cwc * sizeof WCHAR );
    }

    _propType = propType;
} //SetCurrentProperty

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyValueParser::CPropertyValueParser, public
//
//  Synopsis:  This constructor reads token from scanner and
//             generates the corresponding CStorageVariant
//
//  History:   02-Mar-95   t-colinb     Created.
//             02-Sep-98   KLam         Added locale
//
//----------------------------------------------------------------------------

CPropertyValueParser::CPropertyValueParser(
    CQueryScanner &scanner,
    DBTYPE PropType,
    LCID locale ) :
        _pStgVariant( 0 ),
        _locale ( locale )
{
    unsigned cElements=0;
    BOOL fParsingVector = (C_OPEN_TOKEN == scanner.LookAhead());

    if ( fParsingVector )
    {
        // this is a vector
        if ( DBTYPE_VECTOR != ( PropType & DBTYPE_VECTOR ) )
            THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

        scanner.Accept();
        VARENUM ve = (VARENUM ) PropType;
        if ( PropType == ( DBTYPE_VECTOR | DBTYPE_WSTR ) )
            ve = (VARENUM) (VT_VECTOR | VT_LPWSTR);
        else if ( PropType == ( DBTYPE_VECTOR | DBTYPE_STR ) )
            ve = (VARENUM) (VT_VECTOR | VT_LPSTR);

        _pStgVariant.Set( new CStorageVariant( ve, cElements ) );
    }
    else
    {
        // ok to look for singletons with a vector (sometimes)

        _pStgVariant.Set( new CStorageVariant() );
    }

    if ( 0 == _pStgVariant.GetPointer() )
        THROW( CException( E_OUTOFMEMORY ) );

    // first check for an empty vector -- these are legal

    if ( ( fParsingVector ) &&
         ( C_CLOSE_TOKEN == scanner.LookAhead() ) )
    {
        scanner.Accept();
        return;
    }

    BOOL fFinished = FALSE;
    do
    {
        XPtrST<WCHAR> wcsPhrase;

        if ( QUOTES_TOKEN == scanner.LookAhead() )
        {
            // this is a phrase in quotes
            scanner.AcceptQuote();
            wcsPhrase.Set( scanner.AcqPhraseInQuotes()  );
            if ( wcsPhrase.GetPointer() == 0 )
                THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );
        }
        else
        {
            wcsPhrase.Set( scanner.AcqPhrase()  );
            if ( wcsPhrase.GetPointer() == 0 )
                THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

        }
        scanner.Accept();

        switch ( PropType & ~DBTYPE_VECTOR  )
        {

            case DBTYPE_WSTR :
            case DBTYPE_WSTR | DBTYPE_BYREF :
            {
                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetLPWSTR( wcsPhrase.GetPointer(), cElements );
                else
                    _pStgVariant->SetLPWSTR( wcsPhrase.GetPointer() );

                break;
            }
            case DBTYPE_BSTR :
            {
                BSTR bstr = SysAllocString( wcsPhrase.GetPointer() );

                if ( 0 == bstr )
                    THROW( CException( E_OUTOFMEMORY ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetBSTR( bstr, cElements );
                else
                    _pStgVariant->SetBSTR( bstr );

                SysFreeString( bstr );
                break;
            }
            case DBTYPE_STR :
            case DBTYPE_STR | DBTYPE_BYREF :
            {
                // make sure there's enough room to translate

                unsigned cbBuffer = 1 + 3 * wcslen( wcsPhrase.GetPointer() );
                XArray<char> xBuf( cbBuffer );

                int cc = WideCharToMultiByte( CP_ACP,
                                              0,
                                              wcsPhrase.GetPointer(),
                                              -1,
                                              xBuf.Get(),
                                              cbBuffer,
                                              NULL,
                                              NULL );

                if ( 0 == cc )
                {
                    #if CIDBG
                    ULONG ul = GetLastError();
                    #endif
                    THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );
                }

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetLPSTR( xBuf.Get(), cElements );
                else
                    _pStgVariant->SetLPSTR( xBuf.Get() );

                break;
            }

            case DBTYPE_I1 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                LONG l = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( ( l > SCHAR_MAX ) ||
                     ( l < SCHAR_MIN ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetI1( (CHAR) l, cElements );
                else
                    _pStgVariant->SetI1( (CHAR) l );

                break;
            }
            case DBTYPE_UI1 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                ULONG ul = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( ul > UCHAR_MAX )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetUI1( (BYTE) ul, cElements );
                else
                    _pStgVariant->SetUI1( (BYTE) ul );

                break;
            }
            case DBTYPE_I2 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                LONG l = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( ( l > SHRT_MAX ) ||
                     ( l < SHRT_MIN ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetI2( (short) l, cElements );
                else
                    _pStgVariant->SetI2( (short) l );

                break;
            }
            case DBTYPE_UI2 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                ULONG ul = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( ul > USHRT_MAX )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetUI2( (USHORT) ul, cElements );
                else
                    _pStgVariant->SetUI2( (USHORT) ul );

                break;
            }
            case DBTYPE_I4 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                LONG l = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetI4( l, cElements );
                else
                    _pStgVariant->SetI4( l );

                break;
            }
            case DBTYPE_UI4 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                ULONG ul = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetUI4( ul, cElements );
                else
                    _pStgVariant->SetUI4( ul );

                break;
            }
            case DBTYPE_ERROR :
            {
                // SCODE/HRESULT are typedefed as long (signed)

                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                SCODE sc = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( sc, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetERROR( sc, cElements );
                else
                    _pStgVariant->SetERROR( sc );

                break;
            }
            case DBTYPE_I8 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                _int64 ll = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ll, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                LARGE_INTEGER LargeInt;
                LargeInt.QuadPart = ll;

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetI8( LargeInt, cElements );
                else
                    _pStgVariant->SetI8( LargeInt );

                break;
            }
            case DBTYPE_UI8 :
            {
                CQueryScanner scan( wcsPhrase.GetPointer(), FALSE, locale );
                unsigned _int64 ull = 0;
                BOOL fAtEndOfString;
                if ( ! ( scan.GetNumber( ull, fAtEndOfString ) &&
                         fAtEndOfString ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

                ULARGE_INTEGER LargeInt;
                LargeInt.QuadPart = ull;

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetUI8( LargeInt, cElements );
                else
                    _pStgVariant->SetUI8( LargeInt );

                break;
            }
            case DBTYPE_BOOL :
            {
                if( wcsPhrase.GetPointer()[0] == 'T' ||
                    wcsPhrase.GetPointer()[0] == 't' )
                    if ( PropType & DBTYPE_VECTOR )
                        _pStgVariant->SetBOOL( VARIANT_TRUE, cElements );
                    else
                        _pStgVariant->SetBOOL( VARIANT_TRUE );
                else
                    if ( PropType & DBTYPE_VECTOR )
                        _pStgVariant->SetBOOL( VARIANT_FALSE, cElements );
                    else
                        _pStgVariant->SetBOOL( VARIANT_FALSE );

                break;
            }
            case DBTYPE_R4 :
            {
                WCHAR *pwcEnd = 0;

                float Float = (float)( wcstod( wcsPhrase.GetPointer(), &pwcEnd ) );

                if( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetR4( Float, cElements );
                else
                    _pStgVariant->SetR4( Float );

                break;
            }
            case DBTYPE_R8 :
            {
                WCHAR *pwcEnd = 0;
                double Double = ( double )( wcstod( wcsPhrase.GetPointer(), &pwcEnd ) );

                if( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetR8( Double, cElements );
                else
                    _pStgVariant->SetR8( Double );

                break;
            }
            case DBTYPE_DECIMAL :
            {
                WCHAR *pwcEnd = 0;
                double Double = ( double )( wcstod( wcsPhrase.GetPointer(), &pwcEnd ) );

                if( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                    THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

                // Vectors are not supported by OLE for VT_DECIMAL (yet)

                Win4Assert( 0 == ( PropType & DBTYPE_VECTOR ) );

                PROPVARIANT * pPropVar = (PROPVARIANT *) _pStgVariant.GetPointer();
                VarDecFromR8( Double, &(pPropVar->decVal) );
                pPropVar->vt = VT_DECIMAL;
                break;
            }
            case DBTYPE_DATE :
            {
                FILETIME ftValue;
                ParseDateTime( wcsPhrase.GetPointer(), ftValue );

                SYSTEMTIME stValue;
                BOOL fOK = FileTimeToSystemTime( &ftValue, &stValue );

                if ( !fOK )
                    THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

                DATE dosDate;
                fOK = SystemTimeToVariantTime( &stValue, &dosDate );

                if ( !fOK )
                    THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetDATE( dosDate, cElements );
                else
                    _pStgVariant->SetDATE( dosDate );

                break;
            }
            case VT_FILETIME :
            {
                FILETIME ftValue;
                ParseDateTime( wcsPhrase.GetPointer(), ftValue );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetFILETIME( ftValue, cElements );
                else
                    _pStgVariant->SetFILETIME( ftValue );

                break;
            }
            case DBTYPE_CY :
            {
                double dbl;

                if( swscanf( wcsPhrase.GetPointer(),
                             L"%lf",
                             &dbl ) < 1 )
                    THROW( CParserException( QPARSE_E_EXPECTING_CURRENCY ) );

                CY cyCurrency;
                VarCyFromR8( dbl, &cyCurrency );

                if ( PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetCY( cyCurrency,  cElements );
                else
                    _pStgVariant->SetCY( cyCurrency );

                break;
            }
            case DBTYPE_GUID :
            case DBTYPE_GUID | DBTYPE_BYREF:
            {
                CLSID clsid;

                if( swscanf( wcsPhrase.GetPointer(),
                             L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
                             &clsid.Data1,
                             &clsid.Data2,
                             &clsid.Data3,
                             &clsid.Data4[0], &clsid.Data4[1],
                             &clsid.Data4[2], &clsid.Data4[3],
                             &clsid.Data4[4], &clsid.Data4[5],
                             &clsid.Data4[6], &clsid.Data4[7] ) < 11 )
                    THROW( CParserException( QPARSE_E_EXPECTING_GUID ) );

                    if ( PropType & DBTYPE_VECTOR )
                        _pStgVariant->SetCLSID( clsid, cElements );
                    else
                        _pStgVariant->SetCLSID( &clsid );
                break;
            }
            default:
            {
                THROW( CParserException( QPARSE_E_UNSUPPORTED_PROPERTY_TYPE ) );
            }
        } // switch

        // make sure memory allocations succeeded

        if ( !_pStgVariant->IsValid() )
            THROW( CException( E_OUTOFMEMORY ) );

        if ( fParsingVector )
        {
            cElements++;
            switch( scanner.LookAhead() )
            {
                case COMMA_TOKEN :
                    scanner.Accept();
                    break;
                case C_CLOSE_TOKEN :
                    scanner.Accept();
                    fFinished = TRUE;
                    break;
                default:
                    THROW( CParserException( QPARSE_E_EXPECTING_COMMA ) );
            }
        }
        else
        {
            fFinished = TRUE;
        }

    } while ( !fFinished );
} //CPropertyValueParser

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyValueParser::ParseDateTime, private
//
//  Synopsis:   Attempts to parse a date expression.
//
//  Arguments:  phrase -- pointer to the phrase to parse
//              ft     -- reference to the FILETIME structure to fill in
//                        with the result
//
//  History:    31-May-96   dlee       Created
//              23-Jan-97   KyleP      Better Year 2000 support
//              02-Sep-98   KLam       Use user settings for Y2K support
//
//----------------------------------------------------------------------------

void CPropertyValueParser::ParseDateTime(
    WCHAR const * phrase,
    FILETIME & ft )
{
    if( !CheckForRelativeDate( phrase, ft ) )
    {
        SYSTEMTIME stValue = { 0, 0, 0, 0, 0, 0, 0, 0 };

        int cItems = swscanf( phrase,
                              L"%4hd/%2hd/%2hd %2hd:%2hd:%2hd:%3hd",
                              &stValue.wYear,
                              &stValue.wMonth,
                              &stValue.wDay,
                              &stValue.wHour,
                              &stValue.wMinute,
                              &stValue.wSecond,
                              &stValue.wMilliseconds );

        if ( 1 == cItems )
            cItems = swscanf( phrase,
                              L"%4hd-%2hd-%2hd %2hd:%2hd:%2hd:%3hd",
                              &stValue.wYear,
                              &stValue.wMonth,
                              &stValue.wDay,
                              &stValue.wHour,
                              &stValue.wMinute,
                              &stValue.wSecond,
                              &stValue.wMilliseconds );

        if( cItems != 3 && cItems != 6 && cItems != 7)
            THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

        //
        // Make a sensible split for Year 2000 using the user's system settings
        //

        if ( stValue.wYear < 100 )
        {
            DWORD dwYearHigh = 0;
            if ( 0 == GetCalendarInfo ( _locale,
                                       CAL_GREGORIAN,
                                       CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                                       0,
                                       0,
                                       &dwYearHigh ) )
            {
                THROW ( CException ( ) );
            }

            if ( ( dwYearHigh < 99 ) || ( dwYearHigh > 9999 ) )
                dwYearHigh = 2029;

            WORD wMaxDecade = (WORD) dwYearHigh % 100;
            WORD wMaxCentury = (WORD) dwYearHigh - wMaxDecade;
            if ( stValue.wYear <= wMaxDecade )
                stValue.wYear += wMaxCentury;
            else
                stValue.wYear += ( wMaxCentury - 100 );
        }

        if( !SystemTimeToFileTime( &stValue, &ft ) )
            THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );
    }
} //ParseDateTime

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyValueParser::CheckForRelativeDate, static
//
//  Synopsis:   Attempts to parse a relative date expression.  If successful,
//              it fills in the FILETIME structure with the calculated
//              absolute date.
//
//  Notes:      Returns TRUE if the phrase is recognized as a relative
//              date (i.e., it begins with a '-').  Otherwise, returns FALSE.
//              The format of a relative date is
//              "-"{INTEGER("h"|"n"|"s"|"y"|"q"|"m"|"d"|"w")}*
//              Case is not significant.
//
//  Arguments:  phrase -- pointer to the phrase to parse
//              ft -- reference to the FILETIME structure to fill in
//                      with the result
//
//  History:    26-May-94   t-jeffc     Created
//              02-Mar-95   t-colinb    Moved from CQueryParser to
//                                      be more accessible
//              22-Jan-97   KyleP       Fix local/UTC discrepancy
//              25-Sep-98   sundarA     Removed dependency on 'c' runtime 
//                                      functions for time.
//----------------------------------------------------------------------------

BOOL CPropertyValueParser::CheckForRelativeDate(
    WCHAR const * phrase,
    FILETIME & ft )
{
    if( *phrase++ == L'-' )
    {
        SYSTEMTIME st;
        LARGE_INTEGER liLocal;
        LONGLONG llTicksInADay = ((LONGLONG)10000000) * ((LONGLONG)3600)
                                 * ((LONGLONG) 24);
        LONGLONG llTicksInAHour = ((LONGLONG) 10000000) * ((LONGLONG)3600);
        int iMonthDays[12]  = {1,-1,1,0,1,0,1,1,0,1,0,1};
        int iLoopValue, iPrevMonth, iPrevQuarter, iQuarterOffset;
        WORD wYear, wDayOfMonth, wStartDate;
        
        //
        //Obtain system time and convert it to file time
        //Copy the filetime to largeint data struct
        //

        GetSystemTime(&st);
        if(!SystemTimeToFileTime(&st, &ft))
            THROW( CParserException( QPARSE_E_INVALID_LITERAL ));
        liLocal.LowPart = ft.dwLowDateTime;
        liLocal.HighPart = ft.dwHighDateTime;
        LONGLONG llRelDate = (LONGLONG)0;
        for( ;; )
        {
            // eat white space
            while( iswspace( *phrase ) )
                phrase++;

            if( *phrase == 0 ) break;

            // parse the number
            WCHAR * pwcEnd;
            LONG lValue = wcstol( phrase, &pwcEnd, 10 );

            if( lValue < 0 )
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

            // eat white space
            phrase = pwcEnd;
            while( iswspace( *phrase ) )
                phrase++;

            // grab the unit char & subtract the appropriate amount
            WCHAR wcUnit = *phrase++;
            switch( wcUnit )
            {
            case L'y':
            case L'Y':
                lValue *= 4;
                // Fall through and handle year like 4 quarters 

            case L'q':
            case L'Q':
                lValue *= 3;
                // Fall through and handle quarters like 3 months
                
            case L'm':
            case L'M':
                 // Getting the System time to determine the day and month.

                if(!FileTimeToSystemTime(&ft, &st))
                {
                    THROW(CParserException(QPARSE_E_INVALID_LITERAL));
                }
                wStartDate = st.wDay;
                wDayOfMonth = st.wDay;
                iLoopValue = lValue;
                while(iLoopValue)
                {
                    // Subtracting to the end of previous month 
                    llRelDate = llTicksInADay * ((LONGLONG)(wDayOfMonth));
                    liLocal.QuadPart -= llRelDate;
                    ft.dwLowDateTime = liLocal.LowPart;
                    ft.dwHighDateTime = liLocal.HighPart;
                    SYSTEMTIME stTemp;
                    if(!FileTimeToSystemTime(&ft, &stTemp))
                    {
                         THROW(CParserException(QPARSE_E_INVALID_LITERAL));
                    }
                    //
                    // if the end of previous month is greated then start date then we subtract to back up to the 
                    // start date.  This will take care of 28/29 Feb(backing from 30/31 by 1 month).
                    //
                    if(stTemp.wDay > wStartDate)
                    {
                        llRelDate = llTicksInADay * ((LONGLONG)(stTemp.wDay - wStartDate));
                        liLocal.QuadPart -= llRelDate;
                        ft.dwLowDateTime = liLocal.LowPart;
                        ft.dwHighDateTime = liLocal.HighPart;
                        // Getting the date into stTemp for further iteration
                        if(!FileTimeToSystemTime(&ft, &stTemp))
                        {
                           THROW( CParserException( QPARSE_E_INVALID_LITERAL ));
                        }
                    } 
                    wDayOfMonth = stTemp.wDay;
                    iLoopValue--;
                } //End While
               
                break;

            case L'w':
            case L'W':
                lValue *= 7;

            case L'd':
            case L'D':
                llRelDate = llTicksInADay * ((LONGLONG)lValue) ;
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L'h':
            case L'H':
                llRelDate = llTicksInAHour * ((LONGLONG)lValue) ;
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L'n':
            case L'N':
                llRelDate = ((LONGLONG)10000000) * ((LONGLONG)60)
                            * ((LONGLONG)lValue) ;
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L's':
            case L'S':
                llRelDate = ((LONGLONG)10000000) * ((LONGLONG)lValue);               
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;                 
                break;

            default:
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );
            }

        } // for( ;; )
        FileTimeToSystemTime(&ft, &st);
        liLocal.LowPart = ft.dwLowDateTime;
        liLocal.HighPart = ft.dwHighDateTime;
        qutilDebugOut(( DEB_ERROR,
                            "Low part : %d ; High part ; %d \n",
                            liLocal.LowPart, liLocal.HighPart ));
        qutilDebugOut(( DEB_ERROR,
                            "64 bit number %I64d \n",
                            liLocal.QuadPart ));
        qutilDebugOut(( DEB_ERROR,
                            "st.Year  %d ; month %d ; day %d ; hour %d ; min %d ; sec %d ; msec %d \n",
                            st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds));

        return TRUE;
    }
    else
    {
        return FALSE;
    }
} //CheckForRelativeDate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\plist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994-2000.
//
//  File:       PLIST.CXX
//
//  Contents:   CPropertyList methods
//              Responsible for parsing and managing the friendly name file.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <shlguid.h>

#include <ciguid.hxx>
#include <nntpprop.hxx>

// regulates access to the global file prop list.
extern CStaticMutexSem g_mtxFilePropList;

// regulates access to prop list iterators.
CStaticMutexSem g_mtxPropListIter;

// The 'friendly name file' is parsed on a line by line basis.  The property
// specification are in the [Names] section of the file.
//
// Each line must have the following form:
//
// FriendlyName [ "(" [ TypeWidthSpec ] ")" ] ["="] PropertySetGuid PropertySpec
//
// where:
//      FriendlyName    - a whitespace delimited 'friendly' name for the property
//      TypeWidthSpec   - one of:
//                          DBTYPE_Type
//                          Width
//                          Type "," Width
//                        where Type is a string specifying the property type
//                        for comparison purposes, and Width is an integer
//                        specifying the display field width
//      PropertySetGuid - a guid in the standard form
//      PropertySpec    - either a property name or PropID
//
// Blank lines are allowed, and comments are recognized as any line with "#"
// as the first non-whitespace character.
//
// (also note that the "=" above is optional, but I think it looks nice...)

#ifndef PIDISI_FILETYPE

    #define PIDISI_FILETYPE                 0x00000002L  // VT_LPWSTR
    #define PIDISI_CX                       0x00000003L  // VT_UI4
    #define PIDISI_CY                       0x00000004L  // VT_UI4
    #define PIDISI_RESOLUTIONX              0x00000005L  // VT_UI4
    #define PIDISI_RESOLUTIONY              0x00000006L  // VT_UI4
    #define PIDISI_BITDEPTH                 0x00000007L  // VT_UI4
    #define PIDISI_COLORSPACE               0x00000008L  // VT_LPWSTR
    #define PIDISI_COMPRESSION              0x00000009L  // VT_LPWSTR
    #define PIDISI_TRANSPARENCY             0x0000000AL  // VT_UI4
    #define PIDISI_GAMMAVALUE               0x0000000BL  // VT_UI4
    #define PIDISI_FRAMECOUNT               0x0000000CL  // VT_UI4
    #define PIDISI_DIMENSIONS               0x0000000DL  // VT_LPWSTR

#endif

#ifndef PSGUID_FlashPix

    #define PSGUID_FlashPix { 0x56616500L, 0xC154, 0x11CE, 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B }

    #define PID_File_source                         0x21000000 // VT_UI4: File source
    #define PID_Scene_type                          0x21000001 // VT_UI4: Scene type
    #define PID_Creation_path_vector                0x21000002 // VT_UI4 | VT_VECTOR: Creation path vector
    #define PID_Software_Name_Manufacturer_Release  0x21000003 // VT_LPWSTR: Software Name/Manufacturer/Release
    #define PID_User_defined_ID                     0x21000004 // VT_LPWSTR: User defined ID
    #define PID_Sharpness_approximation             0x21000005 // VT_R4: Sharpness approximation
    
    #define PID_Copyright_message                   0x22000000 // VT_LPWSTR: Copyright message
    #define PID_Legal_broker_for_the_original_image 0x22000001 // VT_LPWSTR: Legal broker for the original image
    #define PID_Legal_broker_for_the_digital_image  0x22000002 // VT_LPWSTR: Legal broker for the digital image
    #define PID_Authorship                          0x22000003 // VT_LPWSTR: Authorship
    #define PID_Intellectual_property_notes         0x22000004 // VT_LPWSTR: Intellectual property notes
    
    #define PID_Test_target_in_the_image            0x23000000 // VT_UI4: Test target in the image
    #define PID_Group_caption                       0x23000002 // VT_LPWSTR: Group caption
    #define PID_Caption_text                        0x23000003 // VT_LPWSTR: Caption text
    #define PID_People_in_the_image                 0x23000004 // VT_LPWSTR | VT_VECTOR
    #define PID_Things_in_the_image                 0x23000007 // VT_LPWSTR | VT_VECTOR
    #define PID_Date_of_the_original_image          0x2300000A // VT_FILETIME
    #define PID_Events_in_the_image                 0x2300000B // VT_LPWSTR | VT_VECTOR
    #define PID_Places_in_the_image                 0x2300000C // VT_LPWSTR | VT_VECTOR
    #define PID_Content_description_notes           0x2300000F // VT_LPWSTR: Content description notes
    
    #define PID_Camera_manufacturer_name            0x24000000 // VT_LPWSTR: Camera manufacturer name
    #define PID_Camera_model_name                   0x24000001 // VT_LPWSTR: Camera model name
    #define PID_Camera_serial_number                0x24000002 // VT_LPWSTR: Camera serial number
    
    #define PID_Capture_date                        0x25000000  // VT_FILETIME: Capture date
    #define PID_Exposure_time                       0x25000001  // VT_R4: Exposure time
    #define PID_F_number                            0x25000002  // VT_R4: F-number
    #define PID_Exposure_program                    0x25000003  // VT_UI4: Exposure program
    #define PID_Brightness_value                    0x25000004  // VT_R4 | VT_VECTOR
    #define PID_Exposure_bias_value                 0x25000005  // VT_R4: Exposure bias value
    #define PID_Subject_distance                    0x25000006  // VT_R4 | VT_VECTOR
    #define PID_Metering_mode                       0x25000007  // VT_UI4: Metering mode
    #define PID_Scene_illuminant                    0x25000008  // VT_UI4: Scene illuminant
    #define PID_Focal_length                        0x25000009  // VT_R4: Focal length
    #define PID_Maximum_aperture_value              0x2500000A  // VT_R4: Maximum aperture value
    #define PID_Flash                               0x2500000B  // VT_UI4: Flash
    #define PID_Flash_energy                        0x2500000C  // VT_R4: Flash energy
    #define PID_Flash_return                        0x2500000D  // VT_UI4: Flash return
    #define PID_Back_light                          0x2500000E  // VT_UI4: Back light
    #define PID_Subject_location                    0x2500000F  // VT_R4 | VT_VECTOR
    #define PID_Exposure_index                      0x25000010  // VT_R4: Exposure index
    #define PID_Special_effects_optical_filter      0x25000011  // VT_UI4 | VT_VECTOR
    #define PID_Per_picture_notes                   0x25000012  // VT_LPWSTR: Per picture notes
    
    #define PID_Sensing_method                      0x26000000 // VT_UI4: Sensing method
    #define PID_Focal_plane_X_resolution            0x26000001 // VT_R4: Focal plane X resolution
    #define PID_Focal_plane_Y_resolution            0x26000002 // VT_R4: Focal plane Y resolution
    #define PID_Focal_plane_resolution_unit         0x26000003 // VT_UI4: Focal plane resolution unit
    #define PID_Spatial_frequency_response          0x26000004 // VT_VARIANT | VT_VECTOR
    #define PID_CFA_pattern                         0x26000005 // VT_VARIANT | VT_VECTOR
    #define PID_Spectral_sensitivity                0x26000006 // VT_LPWSTR: Spectral sensitivity
    #define PID_ISO_speed_ratings                   0x26000007 // VT_UI2 | VT_VECTOR
    #define PID_OECF                                0x26000008 // VT_VARIANT | VT_VECTOR: OECF
    
    #define PID_Film_brand                          0x27000000 // VT_LPWSTR: Film brand
    #define PID_Film_category                       0x27000001 // VT_UI4: Film category
    #define PID_Film_size                           0x27000002 // VT_VARIANT | VT_VECTOR: Film size
    #define PID_Film_roll_number                    0x27000003 // VT_UI4: Film roll number
    #define PID_Film_frame_number                   0x27000004 // VT_UI4: Film frame number
    
    #define PID_Original_scanned_image_size         0x29000000 // VT_VARIANT | VT_VECTOR: Original scanned image size
    #define PID_Original_document_size              0x29000001 // VT_VARIANT | VT_VECTOR: Original document size
    #define PID_Original_medium                     0x29000002 // VT_UI4: Original medium
    #define PID_Type_of_original                    0x29000003 // VT_UI4: Type of original
    
    #define PID_Scanner_manufacturer_name           0x28000000 // VT_LPWSTR: Scanner manufacturer name
    #define PID_Scanner_model_name                  0x28000001 // VT_LPWSTR: Scanner model name
    #define PID_Scanner_serial_number               0x28000002 // VT_LPWSTR: Scanner serial number
    #define PID_Scan_software                       0x28000003 // VT_LPWSTR: Scan software
    #define PID_Scan_software_revision_date         0x28000004 // VT_DATE: Scan software revision date
    #define PID_Service_bureau_organization_name    0x28000005 // VT_LPWSTR: Service bureau/organization name
    #define PID_Scan_operator_ID                    0x28000006 // VT_LPWSTR: Scan operator ID
    #define PID_Scan_date                           0x28000008 // VT_FILETIME: Scan date
    #define PID_Last_modified_date                  0x28000009 // VT_FILETIME: Last modified date
    #define PID_Scanner_pixel_size                  0x2800000A // VT_R4: Scanner pixel size

#endif // PIDISI_FILETYPE


//+-------------------------------------------------------------------------
//
//  Function:   HashFun
//
//  Arguments:  [pwcName]  -- string to hash
//
//  History:    26-Aug-97   KrishnaN     Added this nifty comment block.
//
//  Notes:      Hash function #1 from tplist.cxx
//
//--------------------------------------------------------------------------

ULONG HashFun( WCHAR const * pwcName )
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = 0;

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += CiPtrToUlong( pwcName - pwcStart );

    return ulHash;
} //HashFun

// strings corresponding to the property type enum in plist.hxx
struct PropertyTypeArrayEntry
{
    WCHAR  * wcsTypeName;
    DBTYPE dbType;
};

// Ordered by expected frequency

static const PropertyTypeArrayEntry parseTypes[] =
{
    { L"DBTYPE_WSTR",     DBTYPE_WSTR     },     //  wide null terminated string
    { L"DBTYPE_BYREF",    DBTYPE_BYREF    },     //  a pointer
    { L"VT_FILETIME",     VT_FILETIME     },     //  I8 filetime
    { L"DBTYPE_FILETIME", DBTYPE_FILETIME },     //  I8 filetime
    { L"DBTYPE_BSTR",     DBTYPE_BSTR     },     //  a BSTR
    { L"DBTYPE_STR",      DBTYPE_STR      },     //  null terminated string
    { L"DBTYPE_I4",       DBTYPE_I4       },     //  4 byte signed int
    { L"DBTYPE_UI4",      DBTYPE_UI4      },     //  4 byte unsigned int
    { L"DBTYPE_I8",       DBTYPE_I8       },     //  8 byte signed int
    { L"DBTYPE_UI8",      DBTYPE_UI8      },     //  8 byte unsigned int
    { L"DBTYPE_I1",       DBTYPE_I1       },     //  signed char
    { L"DBTYPE_UI1",      DBTYPE_UI1      },     //  unsigned char
    { L"DBTYPE_I2",       DBTYPE_I2       },     //  2 byte signed int
    { L"DBTYPE_UI2",      DBTYPE_UI2      },     //  2 byte unsigned int
    { L"DBTYPE_R4",       DBTYPE_R4       },     //  4 byte float
    { L"DBTYPE_R8",       DBTYPE_R8       },     //  8 byte float
    { L"DBTYPE_CY",       DBTYPE_CY       },     //  currency (LONG_LONG)
    { L"DBTYPE_DATE",     DBTYPE_DATE     },     //  date (double)
    { L"DBTYPE_BOOL",     DBTYPE_BOOL     },     //  BOOL (true=-1, false=0)
    { L"DBTYPE_GUID",     DBTYPE_GUID     },     //  a guid
    { L"DBTYPE_VECTOR",   DBTYPE_VECTOR   },     //  a vector
    { L"DBTYPE_ERROR",    DBTYPE_ERROR    },     //  an error
    { L"DBTYPE_DECIMAL",  DBTYPE_DECIMAL  },     //  decimal
//    { L"DBTYPE_ARRAY" ,   DBTYPE_ARRAY    },     //  an array
};

unsigned cParseTypes = sizeof parseTypes / sizeof parseTypes[0];

WCHAR const * CEmptyPropertyList::GetPropTypeName( unsigned i )
{
    Win4Assert( i < GetPropTypeCount() );
    return parseTypes[i].wcsTypeName;
}

DBTYPE CEmptyPropertyList::GetPropType( unsigned i )
{
    Win4Assert( i < GetPropTypeCount() );
    return parseTypes[i].dbType;
}

unsigned CEmptyPropertyList::GetPropTypeCount()
{
    return cParseTypes;
}

//+-------------------------------------------------------------------------
//
//  Function:   FindPropType
//
//  Arguments:  [wcsType]  -- string name to lookup.
//
//  Returns:    Index into the parseTypes array or ULONG_MAX if not found.
//
//  History:    26-Aug-97   KrishnaN     Added this nifty comment block.
//
//--------------------------------------------------------------------------

unsigned FindPropType( WCHAR const * wcsType )
{
    for ( unsigned i = 0; i < cParseTypes; i++ )
        if ( !wcscmp( parseTypes[i].wcsTypeName, wcsType ) )
            return i;

    return ULONG_MAX;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::QueryInterface, public
//
//  Arguments:  [ifid]  -- Interface id
//              [ppiuk] -- Interface return pointer
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEmptyPropertyList::QueryInterface( REFIID ifid, void ** ppiuk )
{
    if (0 == ppiuk)
        return E_INVALIDARG;

    if (IID_IColumnMapper == ifid )
    {
        *ppiuk = (void *)((IColumnMapper *)this);
    }
    else if ( IID_IUnknown == ifid )
    {
        *ppiuk = (void *)((IUnknown *)this);
    }
    else
    {
        *ppiuk = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::AddRef, public
//
//  Synopsis:   Reference the virtual table.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmptyPropertyList::AddRef(void)
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::Release, public
//
//  Synopsis:   De-Reference the virtual table.
//
//  Effects:    If the ref count goes to 0 then the table is deleted.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEmptyPropertyList::Release(void)
{
    unsigned long uTmp;

    //
    // We need to manage the global prop list file ptr to ensure that
    // concurrently running queries use the same instance, but the
    // ptr gets deleted when the last of the concurrent queries releases
    // the global ptr.
    //

    {
        CLock lock(g_mtxFilePropList);

        uTmp = InterlockedDecrement( &_cRefs );

        // At this point, no one else should be mucking with _cRefs. The AddRef
        // we do happens under g_mtxFilePropList, so we are fine!

        if (0 == uTmp && CLocalGlobalPropertyList::_pGlobalPropListFile == this)
        {
            //
            // If this is the last instance of the global prop list, set the
            // global pointer to 0 before deleting it.
            //
            CLocalGlobalPropertyList::_pGlobalPropListFile = 0;
        }
    }

    if (0 == uTmp)
    {
        Win4Assert(CLocalGlobalPropertyList::_pGlobalPropListFile != this);
        delete this;
    }

    return(uTmp);
}

//
// IColumnMapper methods
//

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::GetPropInfoFromName, public
//
//  Synopsis:   Get property info. from name.
//
//  Parameters: [wcsPropName] -- Property name to look up.
//              [ppPropId]    -- Ptr to return Id of the property.
//              [pPropType]   -- Ptr to return type of the property.
//              [puiWidth]    -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CEmptyPropertyList::GetPropInfoFromName(const WCHAR  *wcsPropName,
                                         DBID  * *ppPropId,
                                         DBTYPE  *pPropType,
                                         unsigned int  *puiWidth)
{
    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //

    if (0 == wcsPropName || 0 == ppPropId)
        return E_INVALIDARG;

    BOOL fSuccess = GetPropInfo(wcsPropName, (CDbColId **)ppPropId, pPropType, puiWidth);

    return fSuccess ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::GetPropInfoFromId, public
//
//  Synopsis:   Get property info. from dbid.
//
//  Parameters: [pPropId]    -- Ptr to prop to look up.
//              [pwcsName]   -- Ptr to return property name.
//              [pPropType]  -- Ptr to return type of the property.
//              [puiWidth]   -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CEmptyPropertyList::GetPropInfoFromId(const DBID  *pPropId,
                                           WCHAR  * *pwcsName,
                                           DBTYPE  *pPropType,
                                           unsigned int  *puiWidth)
{
    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //
    if (0 == pwcsName || 0 == pPropId)
        return E_INVALIDARG;

    BOOL fSuccess = GetPropInfo((CDbColId const &)*pPropId,
                                (WCHAR const **)pwcsName,
                                pPropType,
                                puiWidth);

    return fSuccess ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::EnumPropInfo, public
//
//  Synopsis:   Gets the i-th entry from the list of properties.
//
//  Parameters: [iEntry]    -- i-th entry to retrieve (0-based).
//              [pwcsName]  -- Ptr to return property name.
//              [ppPropId]  -- Ptr to return Id of the property.
//              [pPropType]  -- Ptr to return type of the property.
//              [puiWidth]   -- Ptr to return property width.
//
//  Notes:      A single global mutex is used for interlocking.  It's just not
//              worth it to have a CRITICAL_SECTION in each CEmptyPropertyList.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CEmptyPropertyList::EnumPropInfo(ULONG iEntry,
                                  const WCHAR  * *pwcsName,
                                  DBID  * *ppPropId,
                                  DBTYPE  *pPropType,
                                  unsigned int  *puiWidth)
{
    CLock lock(g_mtxPropListIter);

    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //

    if (0 == pwcsName || 0 == ppPropId)
        return E_INVALIDARG;

    // iEntry is 0-based.

    CPropEntry const *pPropEntry = 0;

    //
    // If iEntry is > what was last retrieved, walk to that item in the
    // iterator. If iEntry is <= what we have, we need to start from the
    // beginning, because we can only walk forward.
    //

    if (iEntry <= _iLastEntryPos)
    {
        delete _pPropIterator;
        _pPropIterator = new CPropEntryIter(*this);
        _iLastEntryPos = 0;
        pPropEntry = _pPropIterator->Next();
    }

    // Now move (iEntry - _iLastEntryPos) times to get to the desired entry.
    for (ULONG ulCurrentEntry = _iLastEntryPos;
         ulCurrentEntry < iEntry;
         ulCurrentEntry++)
    {
        pPropEntry = _pPropIterator->Next();
        if (0 != pPropEntry)
            _iLastEntryPos++;
        else    // Reached the end of the list!
            break;
    }

    if (0 == pPropEntry)
        return E_INVALIDARG;

    *pwcsName = pPropEntry->GetName();
    *ppPropId = (DBID *) (pPropEntry->PropSpec().CastToStruct());

    if (pPropType)
        *pPropType = pPropEntry->GetPropType();

    if (puiWidth)
        *puiWidth = pPropEntry->GetWidth();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::GetPropInfo, public
//
//  Synopsis:   Given a friendly property name, return information about
//              that property (including a CDbColId).
//
//  Arguments:  wcsPropName -- friendly property name
//              *ppprop -- if ppprop != 0, returns a pointer to the CDbColId
//              *pproptype -- if proptype != 0, returns the DBTYPE
//              *puWidth -- if pulWidth != 0, returns the output field width
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

BOOL CEmptyPropertyList::GetPropInfo(WCHAR const * wcsPropName,
                                     CDbColId ** ppprop,
                                     DBTYPE * pproptype,
                                     unsigned int * puWidth )
{
    WCHAR awc[MAX_PROPNAME_LENGTH + 1];

    unsigned cc = wcslen( wcsPropName );

    if ( cc > MAX_PROPNAME_LENGTH )
        cc = MAX_PROPNAME_LENGTH;

    RtlCopyMemory( awc, wcsPropName, cc * sizeof(WCHAR) );
    awc[cc] = 0;

    _wcsupr( awc );

    CPropEntry const * ppentry = Find( awc );

    if( 0 == ppentry )
        return FALSE;

    if( ppprop )
        *ppprop = &((CDbColId &) ppentry->PropSpec());

    if( pproptype )
        *pproptype = ppentry->GetPropType();

    if( puWidth )
        *puWidth = ppentry->GetWidth();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::GetPropInfo, public
//
//  Synopsis:   Given a CDbColId, return information about
//              that property.
//
//  Arguments:  prop -- property specifier
//              *ppprop -- if ppprop != 0, returns a pointer to the CDbColId
//              *pproptype -- if proptype != 0, returns the DBTYPE
//              *puWidth -- if pulWidth != 0, returns the output field width
//
//  Notes:      Overloaded the other GetPropInfo to help the column display
//              routines.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

BOOL CEmptyPropertyList::GetPropInfo(CDbColId const & prop,
                                     WCHAR const ** pwcsName,
                                     DBTYPE * pproptype,
                                     unsigned int * puWidth )
{
    CPropEntry const * ppentry = Find( prop );

    if( ppentry == 0 )
        return FALSE;

    if( pwcsName )
        *pwcsName = ppentry->GetName();

    if( pproptype )
        *pproptype = ppentry->GetPropType();

    if( puWidth )
        *puWidth = ppentry->GetWidth();

    return TRUE;
} //GetPropInfo


// StaticPropertyList methods

//+---------------------------------------------------------------------------
//
//  Member:     CStaticPropertyList::Find, public
//
//  Synopsis:   Attempt to find an entry in the list.
//
//  Arguments:  wcsName -- friendly property name to find
//
//  Returns a pointer to the CPropEntry if found, 0 otherwise.
//
//  History:    17-May-94   t-jeffc     Created.
//              28-Aug-97   KrishnaN    Static prop lookup only.
//
//----------------------------------------------------------------------------

CPropEntry const * CStaticPropertyList::Find( WCHAR const * wcsName )
{
    Win4Assert ( sizeof SPropEntry == sizeof CPropEntry );

    if( 0 == wcsName )
        return 0;

    CPropEntry const * ppentry = 0;
    unsigned iHash = HashFun( wcsName ) % cStaticPropHash;

    for( ppentry = _aStaticEntries[ iHash ];
         0 != ppentry;
         ppentry = ppentry->Next() )
    {
        if ( ppentry->NameMatch( wcsName ) )
            break;
    }

    return ppentry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CEmptyPropertyList::Find, public
//
//  Synopsis:   Attempt to find an entry in the list.
//
//  Arguments:  prop -- CDbColId of property to find
//
//  Notes:      Overloaded Find( WCHAR const * ) to help the column display
//              routines.
//
//  Returns a pointer to the CPropEntry if found, 0 otherwise.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

CPropEntry const * CEmptyPropertyList::Find( CDbColId const & prop )
{
    CPropEntryIter iter( *this );

    CPropEntry const * ppentry;

    while ( ppentry = iter.Next() )
    {
        CDbColId const & ps = ppentry->PropSpec();
        if ( ps == prop )
            break;
    }

    return ppentry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStaticPropertyList::Next, public
//
//  Synopsis:   Gets the next property during an enumeration
//
//  Returns:    The next property entry or 0 for end of enumeration
//
//  History:    21-Jul-97   dlee  Moved from .hxx and added header
//
//----------------------------------------------------------------------------

CPropEntry const * CStaticPropertyList::Next()
{
    ULONG cLimit = cStaticPropHash;

    if ( _icur < cLimit )
    {
        if ( 0 == _pcur )
        {
            do
            {
                _icur++;
                if ( _icur == cLimit )
                    break;

                _pcur = _aStaticEntries[ _icur ];
            } while ( 0 == _pcur );
        }

        if ( 0 != _pcur )
        {
            CPropEntry const *p = _pcur;
            _pcur = _pcur->Next();
            return p;
        }
    }

    return 0;
} //Next

//+---------------------------------------------------------------------------
//
//  Member:     CStaticPropertyList::InitIterator, public
//
//  Synopsis:   Initialize the iterator
//
//  History:    29-Aug-97  KrishnaN  Created
//
//----------------------------------------------------------------------------

void CStaticPropertyList::InitIterator()
{
    _icur = 0;
    _pcur = _aStaticEntries[0];
}

CPropertyList::~CPropertyList()
{
    ClearList();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::FindDynamic, private
//
//  Synopsis:   Attempt to find an entry in the list.
//
//  Arguments:  wcsName -- friendly property name to find
//
//  Returns a pointer to the CPropEntry if found, 0 otherwise.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

CPropEntry const * CPropertyList::Find( WCHAR const * wcsName )
{
    Win4Assert( sizeof SPropEntry == sizeof CPropEntry );

    if( wcsName == 0 )
        return 0;

    unsigned iHash = HashFun( wcsName ) % cPropHash;

    for( CPropEntry * ppentry = _aEntries[ iHash ];
         0 != ppentry;
         ppentry = ppentry->Next() )
    {
        if( ppentry->NameMatch( wcsName ) )
            break;
    }

    return ppentry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::AddEntry, private
//
//  Synopsis:   Adds a CPropEntry to the list.  Verifies that the name
//              isn't already in the list.
//
//  Arguments:  ppentryNew -- pointer to the CPropEntry to add
//              iLine      -- line number we're parsing
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

void CPropertyList::AddEntry( CPropEntry * ppentryNew, int iLine )
{
    if( Find( ppentryNew->GetName() ) )
        THROW( CPListException( QPLIST_E_DUPLICATE, iLine ) );

    CLock lock(_mtxList);

    unsigned iHash = HashFun( ppentryNew->GetName() ) % cPropHash;

    ppentryNew->SetNext( _aEntries[ iHash ] );
    _aEntries[ iHash ] = ppentryNew;
    InterlockedIncrement((LONG *)&_ulCount);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::ClearList, public
//
//  Synopsis:   Frees the memory used by the list.  Used in the destructor
//              and if the friendly name file is to be reparsed.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

void CPropertyList::ClearList()
{
    CLock lock(_mtxList);

    for ( unsigned i = 0; i < cPropHash; i++ )
    {
        CPropEntry * ppentryNext;

        for( CPropEntry *ppentryCurr = _aEntries[i];
             0 != ppentryCurr;
             ppentryCurr = ppentryNext )
        {
            ppentryNext = ppentryCurr->Next();
            delete ppentryCurr;
            InterlockedDecrement((LONG *)&_ulCount);
        }
    }

    RtlZeroMemory( _aEntries, sizeof _aEntries );
    Win4Assert(0 == _ulCount);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::Next, public
//
//  Synopsis:   Gets the next property during an enumeration
//
//  Returns:    The next property entry or 0 for end of enumeration
//
//  History:    29-Aug-97  KrishnaN  Created
//
//----------------------------------------------------------------------------

CPropEntry const * CPropertyList::Next()
{
    ULONG cLimit = cPropHash;

    if ( _icur < cLimit )
    {
        if ( 0 == _pcur )
        {
            do
            {
                _icur++;
                if ( _icur == cLimit )
                    break;

                _pcur = _aEntries[ _icur ];
            } while ( 0 == _pcur );
        }

        if ( 0 != _pcur )
        {
            CPropEntry const *p = _pcur;
            _pcur = _pcur->Next();
            return p;
        }
    }

    return 0;
} //Next

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::InitIterator, public
//
//  Synopsis:   Initialize the iterator
//
//  History:    29-Aug-97  KrishnaN  Created
//
//----------------------------------------------------------------------------

void CPropertyList::InitIterator()
{
    _icur = 0;
    _pcur = _aEntries[0];
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::ParseOneLine, public
//
//  Synopsis:   Parses one line of the friendly name file, creating a
//              CPropEntry node if necessary
//
//  Arguments:  scan   -- scanner initialized with the current line
//              line   -- The line to scan
//              pentry -- The cpropentry ptr.
//
//  Returns:    A pointer to the created prop entry. It could return 0 if no
//              property was created.
//
//  History:    17-May-94   t-jeffc     Created.
//
//----------------------------------------------------------------------------

void CPropertyList::ParseOneLine( CQueryScanner & scan, int iLine, XPtr<CPropEntry> & pentry )
{
    Win4Assert(0 == pentry.GetPointer());
    Token token = scan.LookAhead();

    // 1) is this a comment line (does it start with #)
    //    or an empty line?
    if( token == PROP_REGEX_TOKEN
     || token == EOS_TOKEN )
        return;

    // 2) get friendly property name & stuff it in smart pointer
    XPtrST<WCHAR> wcsName( scan.AcqColumn() );

    if( wcsName.GetPointer() == 0 )
        THROW( CPListException( QPLIST_E_EXPECTING_NAME, iLine ) );

    unsigned ccName = wcslen( wcsName.GetPointer() ) + 1;
    WCHAR *pwcDisplayName = new WCHAR[ ccName ];
    RtlCopyMemory( pwcDisplayName, wcsName.GetPointer(), ccName * sizeof WCHAR );
    XPtrST<WCHAR> wcsDisplayName( pwcDisplayName );

    // initialize a new CPropEntry
    // (name is _not_ copied, so we must relinquish the smart pointer)
    _wcsupr( wcsName.GetPointer() );
    pentry.Set( new CPropEntry( wcsDisplayName, wcsName ) );

    scan.AcceptColumn();

    token = scan.LookAhead();

    // 3) check for type & width spec
    if( token == OPEN_TOKEN )
    {
        scan.Accept();

        if( scan.LookAhead() == TEXT_TOKEN )
        {
            unsigned long ulWidth;
            BOOL fAtEnd;

            if( !scan.GetNumber( ulWidth, fAtEnd ) )
            {
                // 4) if it's not a number, try to recognize it as
                //    a type specifier
                //

                //  Scan for DB_TYPE | DB_TYPE | DBTYPE combinations
                //
                while ( scan.LookAhead() == TEXT_TOKEN )
                {
                    XPtrST<WCHAR> wcsType( scan.AcqWord() );

                    if( wcsType.GetPointer() == 0 )
                        THROW( CPListException( QPLIST_E_EXPECTING_TYPE, iLine ) );

                    _wcsupr( wcsType.GetPointer() );
                    unsigned cType = FindPropType( wcsType.GetPointer() );

                    if( cType >= GetPropTypeCount() )
                        THROW( CPListException( QPLIST_E_UNRECOGNIZED_TYPE, iLine ) );

                    scan.AcceptWord();
                    pentry->SetPropType( pentry->GetPropType() |
                                         parseTypes[cType].dbType );


                    if ( OR_TOKEN == scan.LookAhead()  )
                    {
                        scan.Accept();
                    }
                }

                //
                //  Verfy that we have some DBTYPE specified in addition
                //  to DBTYPE_VECTOR & DBTYPE_BYREF
                //
                DBTYPE dbBase = pentry->GetPropType() & ~(DBTYPE_VECTOR|DBTYPE_BYREF);
                if ( 0 == dbBase )
                {
                    THROW( CPListException( QPLIST_E_VECTORBYREF_USED_ALONE, iLine ) );
                }

                //
                // In NT 5, you can't mix and match types from VARIANT
                // and PROPVARIANT in VT_ARRAY and VT_VECTOR.  Certain
                // permutations like this one aren't supported
                //

                if ( pentry->GetPropType() == (DBTYPE_DECIMAL|DBTYPE_VECTOR) )
                    THROW( CPListException( QPLIST_E_UNRECOGNIZED_TYPE, iLine ) );

                //
                //  If they specified a DBTYPE_BYREF, it must be with a pointer
                //  type: WSTR or STR or UI1.
                //
                if ( (( pentry->GetPropType() & DBTYPE_BYREF ) != 0) &&
                     ( DBTYPE_WSTR != dbBase &&
                       DBTYPE_STR  != dbBase &&
                       DBTYPE_UI1  != dbBase &&
                       DBTYPE_GUID != dbBase) )
                {
                    THROW( CPListException( QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE, iLine ) );
                }

                if( scan.LookAhead() == COMMA_TOKEN )
                {
                    // 5) get the comma and width specifier
                    scan.Accept();

                    BOOL fAtEnd;

                    if( !scan.GetNumber( ulWidth, fAtEnd ) )
                        THROW( CPListException( QPLIST_E_EXPECTING_INTEGER, iLine ) );

                    scan.Accept();
                    pentry->SetWidth( ulWidth );
                }
            }
            else
            {
                scan.Accept();
                pentry->SetWidth( ulWidth );
            }
        }

        // 6) get the closing parenthesis
        if( scan.LookAhead() != CLOSE_TOKEN )
            THROW( CPListException( QPLIST_E_EXPECTING_CLOSE_PAREN, iLine ) );

        scan.Accept();

        token = scan.LookAhead();
    }

    //
    //  If a type was not specified, assume it is a WIDE string, BYREF
    //
    if ( pentry->GetPropType() == 0 )
    {
        pentry->SetPropType( DBTYPE_WSTR | DBTYPE_BYREF );
    }

    // 7) check for =
    if( token == EQUAL_TOKEN )
    {
        scan.Accept();
    }

    // 7.1) assign a default width if one wasn't specified
    if( pentry->GetWidth() == 0 )
    {
        pentry->SetWidth( PLIST_DEFAULT_WIDTH );
        pentry->SetDisplayed( FALSE );
    }

    // 8) get property set guid & stuff in smart pointer
    XPtrST<WCHAR> wcsUgly( scan.AcqWord() );

    if( wcsUgly.GetPointer() == 0 )
        THROW( CPListException( QPLIST_E_EXPECTING_GUID, iLine ) );

    GUID guid;
    WCHAR *pUgly = wcsUgly.GetPointer();

    if ( !ParseGuid( pUgly, guid ) )
        THROW( CPListException( QPLIST_E_BAD_GUID, iLine ) );

    pentry->PropSpec().SetPropSet( guid );

    scan.AcceptWord();
    token  = scan.LookAhead();

    ULONG ulDispId;
    // 9) get property name or dispid
    BOOL fAtEnd;
    if( !scan.GetNumber( ulDispId, fAtEnd ) )
    {
        XPtrST<WCHAR> wcsPropName;
        if ( QUOTES_TOKEN == token )
        {
            scan.Accept();
            wcsPropName.Set( scan.AcqPhraseInQuotes()  );
        }
        else
        {
            wcsPropName.Set( scan.AcqPhrase()  );
        }

        if( wcsPropName.GetPointer() == 0 )
            THROW( CPListException( QPLIST_E_EXPECTING_PROP_SPEC, iLine ) );

        if( !pentry->PropSpec().SetProperty( wcsPropName.GetPointer() ) )
            THROW( CPListException( QPLIST_E_CANT_SET_PROPERTY, iLine ) );

        scan.Accept();
    }
    else
    {
        pentry->PropSpec().SetProperty( ulDispId );
        scan.Accept();
    }
} //ParseOneLine

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyList::GetAllEntries, public
//
//  Synopsis:   Returns cardinality of list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

SCODE CPropertyList::GetAllEntries(CPropEntry **ppPropEntries,
                                   ULONG ulMaxCount)
{
    if (0 == ppPropEntries)
    {
        return E_INVALIDARG;
    }

    CLock lock(_mtxList);

    ULONG ulSize = min (ulMaxCount, GetCount());
    ULONG u = 0;

    for ( unsigned i = 0; i < cPropHash && u < ulSize; i++ )
    {
        CPropEntry * ppentryNext;

        for( CPropEntry *ppentryCurr = _aEntries[i];
             0 != ppentryCurr && u < ulSize;
             ppentryCurr = ppentryNext )
        {
            ppentryNext = ppentryCurr->Next();
            ppPropEntries[u++] = ppentryCurr;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Note:   all of the following names MUST BE IN UPPERCASE
//
//----------------------------------------------------------------------------

const SPropEntry aStaticList[] =
{
  // Storage Propset

  { 0, L"DIRECTORY",       L"Directory",       {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)2 },  50, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"CLASSID",         L"ClassId",         {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)3 },  36, TRUE,  TRUE, DBTYPE_GUID              },
  { 0, L"FILEINDEX",       L"FileIndex",       {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)8 },   8, TRUE,  TRUE, DBTYPE_UI8               },
  { 0, L"USN",             L"USN",             {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)9 },   8, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"FILENAME",        L"Filename",        {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)10 }, 15, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"PATH",            L"Path",            {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)11 }, 50, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"SIZE",            L"Size",            {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)12 }, 12, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"ATTRIB",          L"Attrib",          {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)13 },  7, TRUE,  TRUE, DBTYPE_UI4               },
  { 0, L"WRITE",           L"Write",           {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)14 }, 19, TRUE,  TRUE, VT_FILETIME              },
  { 0, L"CREATE",          L"Create",          {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)15 }, 19, TRUE,  TRUE, VT_FILETIME              },
  { 0, L"ACCESS",          L"Access",          {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)16 }, 19, TRUE,  TRUE, VT_FILETIME              },
  { 0, L"ALLOCSIZE",       L"AllocSize",       {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)18 }, 11, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"CONTENTS",        L"Contents",        {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)19 },  0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"SHORTFILENAME",   L"ShortFilename",   {StorageGuid, DBKIND_GUID_PROPID, (LPWSTR)20 }, 12, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Query Propset

  { 0, L"RANKVECTOR",      L"RankVector",      {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)2 }, 20, TRUE, TRUE, DBTYPE_UI4|DBTYPE_VECTOR },
  { 0, L"RANK",            L"Rank",            {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)3 },  7, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"HITCOUNT",        L"HitCount",        {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)4 }, 10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"WORKID",          L"WorkId",          {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)5 }, 10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"ALL",             L"All",             {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)6 },  0, FALSE,TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  // Don't export! { L"UNFILTERED", L"Unfiltered", {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)7 },  1, TRUE, TRUE, DBTYPE_BOOL            },
  { 0, L"VPATH",           L"VPath",           {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)9 }, 50, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Property Sets for Documents

  { 0, L"DOCTITLE",        L"DocTitle",        {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_TITLE },    10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCSUBJECT",      L"DocSubject",      {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_SUBJECT },  10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCAUTHOR",       L"DocAuthor",       {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_AUTHOR },   10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCKEYWORDS",     L"DocKeywords",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_KEYWORDS }, 25, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCCOMMENTS",     L"DocComments",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_COMMENTS }, 25, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCTEMPLATE",     L"DocTemplate",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_TEMPLATE },     10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCLASTAUTHOR",   L"DocLastAuthor",   {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_LASTAUTHOR },   10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCREVNUMBER",    L"DocRevNumber",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_REVNUMBER },    10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCEDITTIME",     L"DocEditTime",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_EDITTIME },     10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"DOCLASTPRINTED",  L"DocLastPrinted",  {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_LASTPRINTED },  10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"DOCCREATEDTM",    L"DocCreatedTm",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_CREATE_DTM },   10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"DOCLASTSAVEDTM",  L"DocLastSavedTm",  {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_LASTSAVE_DTM},  10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"DOCPAGECOUNT",    L"DocPageCount",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_PAGECOUNT },    10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCWORDCOUNT",    L"DocWordCount",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_WORDCOUNT },    10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCCHARCOUNT",    L"DocCharCount",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_CHARCOUNT },    10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCTHUMBNAIL",    L"DocThumbnail",    {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_THUMBNAIL },    10, TRUE, TRUE, VT_CF                    },
  { 0, L"DOCAPPNAME",      L"DocAppName",      {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_APPNAME },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF  },
  { 0, L"DOCSECURITY",     L"DocSecurity",     {DocPropSetGuid, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_DOC_SECURITY }, 10, TRUE, TRUE, DBTYPE_I4                },

  { 0, L"DOCCATEGORY",     L"DocCategory",     {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)2 },  10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DOCPRESENTATIONTARGET", L"DocPresentationTarget",  {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)3 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DOCBYTECOUNT",    L"DocByteCount",    {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)4 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCLINECOUNT",    L"DocLineCount",    {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)5 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCPARACOUNT",    L"DocParaCount",    {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)6 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCSLIDECOUNT",   L"DocSlideCount",   {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)7 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCNOTECOUNT",    L"DocNoteCount",    {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)8 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCHIDDENCOUNT",  L"DocHiddenCount",  {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)9 },  10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"DOCPARTTITLES",   L"DocPartTitles",   {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)13 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_VECTOR },
  { 0, L"DOCMANAGER",      L"DocManager",      {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)14 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DOCCOMPANY",      L"DocCompany",      {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)15 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },

  // HTML properities

  { 0, L"HTMLHREF",        L"HtmlHref",        {HTMLUrl, DBKIND_GUID_NAME, L"A.HREF" }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"A_HREF",          L"A_Href",          {HTMLUrl, DBKIND_GUID_NAME, L"A.HREF" }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"IMG_ALT",         L"Img_Alt",         {HTMLGuid, DBKIND_GUID_NAME, L"IMG.ALT" }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING1",    L"HtmlHeading1",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x3 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING2",    L"HtmlHeading2",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x4 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING3",    L"HtmlHeading3",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x5 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING4",    L"HtmlHeading4",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x6 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING5",    L"HtmlHeading5",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x7 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"HTMLHEADING6",    L"HtmlHeading6",    {HTMLGuid, DBKIND_GUID_PROPID, (LPWSTR)0x8 }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Document characterization

  { 0, L"CHARACTERIZATION",L"Characterization",  {DocCharacterGuid, DBKIND_GUID_PROPID, (LPWSTR)2}, 20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // NNTP Properties (obsolete now)

  { 0, L"NEWSGROUP",       L"NewsGroup",        {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsGroup) },         0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSGROUPS",      L"NewsGroups",       {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsGroups) },        0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSREFERENCES",  L"NewsReferences",   {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsReferences) },    0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSSUBJECT",     L"NewsSubject",      {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsSubject) },       0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSFROM",        L"NewsFrom",         {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsFrom) },          0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSMSGID",       L"NewsMsgId",        {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsMsgid) },         0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"NEWSDATE",        L"NewsDate",         {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsDate) },          0, FALSE, TRUE, VT_FILETIME              },
  { 0, L"NEWSRECEIVEDDATE",L"NewsReceivedDate", {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsReceivedDate) },  0, FALSE, TRUE, VT_FILETIME              },
  { 0, L"NEWSARTICLEID",   L"NewsArticleId",    {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsArticleid) },     0, FALSE, TRUE, DBTYPE_UI4               },

  // Mime properties (duplicates of NNTP properties).

  { 0, L"MSGNEWSGROUP",   L"MsgNewsgroup",      {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsGroup) },        10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGNEWSGROUPS",  L"MsgNewsgroups",     {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsGroups) },       10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGREFERENCES",  L"MsgReferences",     {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsReferences) },   10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGSUBJECT",     L"MsgSubject",        {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsSubject) },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGFROM",        L"MsgFrom",           {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsFrom) },         10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGMESSAGEID",   L"MsgMessageID",      {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsMsgid) },        10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MSGDATE",        L"MsgDate",           {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsDate) },         10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"MSGRECEIVEDDATE",L"MsgReceivedDate",   {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsReceivedDate) }, 10, TRUE, TRUE, VT_FILETIME              },
  { 0, L"MSGARTICLEID",   L"MsgArticleID",      {NNTPGuid, DBKIND_GUID_PROPID, (LPWSTR)((ULONG_PTR)propidNewsArticleid) },    10, TRUE, TRUE, DBTYPE_UI4               },

  // Media Summary Information property set

  { 0, L"MEDIAEDITOR",      L"MediaEditor",      {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_EDITOR },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIASUPPLIER",    L"MediaSupplier",    {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_SUPPLIER },    10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIASOURCE",      L"MediaSource",      {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_SOURCE },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIASEQUENCE_NO", L"MediaSequence_No", {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_SEQUENCE_NO }, 10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIAPROJECT",     L"MediaProject",     {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_PROJECT },     10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIASTATUS",      L"MediaStatus",      {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_STATUS },       6, TRUE, TRUE, DBTYPE_UI4                 },
  { 0, L"MEDIAOWNER",       L"MediaOwner",       {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_OWNER },       10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIARATING",      L"MediaRating",      {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_RATING },      10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF   },
  { 0, L"MEDIAPRODUCTION",  L"MediaProduction",  {MediaSummaryInfo, DBKIND_GUID_PROPID, (LPWSTR)PIDMSI_PRODUCTION },  19, TRUE, TRUE, VT_FILETIME                },

  // Music property set

  { 0, L"MUSICARTIST",    L"MusicArtist",    {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_ARTIST },      20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICSONGTITLE", L"MusicSongTitle", {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_SONGTITLE },   20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICALBUM",     L"MusicAlbum",     {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_ALBUM },       20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICYEAR",      L"MusicYear",      {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_YEAR },        10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICCOMMENT",   L"MusicComment",   {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_COMMENT },     10, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"MUSICTRACK",     L"MusicTrack",     {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_TRACK },       15, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"MUSICGENRE",     L"MusicGenre",     {PSGUID_MUSIC, DBKIND_GUID_PROPID, (LPWSTR) PIDSI_GENRE }, 20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Digital Rights Management

  { 0, L"DRMLICENSE",     L"DrmLicense",     {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_PROTECTED },   20, TRUE, TRUE, DBTYPE_BOOL },
  { 0, L"DRMDESCRIPTION", L"DrmDescription", {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_DESCRIPTION }, 20, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"DRMPLAYCOUNT",   L"DrmPlayCount",   {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_PLAYCOUNT },   20, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"DRMPLAYSTARTS",  L"DrmPlayStarts",  {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_PLAYSTARTS },  20, TRUE, TRUE, VT_FILETIME },
  { 0, L"DRMPLAYEXPIRES", L"DrmPlayExpires", {PSGUID_DRM, DBKIND_GUID_PROPID, (LPWSTR) PIDDRSI_PLAYEXPIRES }, 20, TRUE, TRUE, VT_FILETIME },

  // Image property set

  { 0, L"IMAGEFILETYPE",     L"ImageFileType",     {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_FILETYPE },     10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },
  { 0, L"IMAGECX",           L"ImageCx",           {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_CX },           10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGECY",           L"ImageCy",           {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_CY },           10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGERESOLUTIONX",  L"ImageResolutionX",  {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_RESOLUTIONX },  10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGERESOLUTIONY",  L"ImageResolutionY",  {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_RESOLUTIONY },  10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGEBITDEPTH",     L"ImageBitDepth",     {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_BITDEPTH },     10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGECOLORSPACE",   L"ImageColorSpace",   {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_COLORSPACE },   10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },  
  { 0, L"IMAGECOMPRESSION",  L"ImageCompression",  {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_COMPRESSION },  10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },   
  { 0, L"IMAGETRANSPARENCY", L"ImageTransparency", {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_TRANSPARENCY }, 10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGEGAMMAVALUE",   L"ImageGammaValue",   {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_GAMMAVALUE },  10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGEFRAMECOUNT",   L"ImageFrameCount",   {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_FRAMECOUNT },   10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"IMAGEDIMENSIONS",   L"ImageDimensions",   {PSGUID_IMAGESUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR) PIDISI_DIMENSIONS },   10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },

  // Audio property set

  { 0, L"AUDIOFORMAT",       L"AudioFormat",       {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_FORMAT },        10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },
  { 0, L"AUDIOTIMELENGTH",   L"AudioTimeLength",   {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_TIMELENGTH },    10, TRUE, TRUE, DBTYPE_UI8 },
  { 0, L"AUDIOAVGDATARATE",  L"AudioAvgDataRate",  {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_AVG_DATA_RATE }, 10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"AUDIOSAMPLERATE",   L"AudioSampleRate",   {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_SAMPLE_RATE },   10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"AUDIOSAMPLESIZE",   L"AudioSampleSize",   {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_SAMPLE_SIZE },   10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"AUDIOCHANNELCOUNT", L"AudioChannelCount", {PSGUID_AUDIO, DBKIND_GUID_PROPID, (LPWSTR) PIDASI_CHANNEL_COUNT }, 10, TRUE, TRUE, DBTYPE_UI4 },

  // Video property set

  { 0, L"VIDEOSTREAMNAME",   L"VideoStreamName",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_STREAM_NAME },    10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },
  { 0, L"VIDEOFRAMEWIDTH",   L"VideoFrameWidth",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_FRAME_WIDTH },    10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOFRAMEHEIGHT",  L"VideoFrameHeight", {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_FRAME_HEIGHT },   10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOTIMELENGTH",   L"VideoTimeLength",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_TIMELENGTH },     10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOFRAMECOUNT",   L"VideoFrameCount",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_FRAME_COUNT },    10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOFRAMERATE",    L"VideoFrameRate",   {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_FRAME_RATE },     10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEODATARATE",     L"VideoDataRate",    {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_DATA_RATE },      10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOSAMPLESIZE",   L"VideoSampleSize",  {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_SAMPLE_SIZE },    10, TRUE, TRUE, DBTYPE_UI4 },
  { 0, L"VIDEOCOMPRESSION",  L"VideoCompression", {PSGUID_VIDEO, DBKIND_GUID_PROPID, (LPWSTR) PIDVSI_COMPRESSION },    10, TRUE, TRUE, DBTYPE_WSTR | DBTYPE_BYREF },
};

const unsigned cCiGlobalTypes = sizeof(aStaticList) /
                                sizeof(aStaticList[0]);

const unsigned CStaticPropertyList::cStaticPropEntries = cCiGlobalTypes;

//+---------------------------------------------------------------------------
//
//  Member:     CStaticPropertyList::GetAllEntries, public
//
//  Synopsis:   Returns cardinality of list.
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------
SCODE CStaticPropertyList::GetAllEntries(CPropEntry **ppPropEntries,
                                         ULONG ulMaxCount)
{
    if (0 == ppPropEntries)
        return E_INVALIDARG;

    ULONG ulSize = min (ulMaxCount, GetCount());

    for ( unsigned i = 0; i < ulSize; i++ )
        ppPropEntries[i] = (CPropEntry *) & aStaticList[i];

    return S_OK;
} //GetAllEntries

//
// NOTE: Use tplist.cxx (build tplist) to generate the table below,
//       and be sure to update cStaticPropHash and the hash function
//       (if it changed)
//

const CPropEntry * CStaticPropertyList::_aStaticEntries[] =
{
    0,    // 0
    0,    // 1
    0,    // 2
    0,    // 3
    0,    // 4
    0,    // 5
    0,    // 6
    0,    // 7
    0,    // 8
    0,    // 9
    0,    // 10
    0,    // 11
    0,    // 12
    0,    // 13
    0,    // 14
    0,    // 15
    0,    // 16
    0,    // 17
    0,    // 18
    0,    // 19
    0,    // 20
    0,    // 21
    0,    // 22
    0,    // 23
    0,    // 24
    0,    // 25
    0,    // 26
    0,    // 27
    (CPropEntry *) &aStaticList[72],    // 28 'MSGFROM'
    0,    // 29
    0,    // 30
    0,    // 31
    0,    // 32
    0,    // 33
    0,    // 34
    0,    // 35
    0,    // 36
    0,    // 37
    0,    // 38
    0,    // 39
    0,    // 40
    0,    // 41
    0,    // 42
    0,    // 43
    0,    // 44
    0,    // 45
    0,    // 46
    0,    // 47
    0,    // 48
    0,    // 49
    0,    // 50
    0,    // 51
    0,    // 52
    0,    // 53
    0,    // 54
    0,    // 55
    0,    // 56
    0,    // 57
    0,    // 58
    0,    // 59
    0,    // 60
    0,    // 61
    0,    // 62
    0,    // 63
    0,    // 64
    0,    // 65
    0,    // 66
    (CPropEntry *) &aStaticList[123],    // 67 'VIDEOSAMPLESIZE'
    0,    // 68
    0,    // 69
    0,    // 70
    0,    // 71
    0,    // 72
    0,    // 73
    (CPropEntry *) &aStaticList[38],    // 74 'DOCCATEGORY'
    0,    // 75
    0,    // 76
    0,    // 77
    (CPropEntry *) &aStaticList[20],    // 78 'DOCTITLE'
    0,    // 79
    0,    // 80
    0,    // 81
    0,    // 82
    0,    // 83
    0,    // 84
    0,    // 85
    0,    // 86
    (CPropEntry *) &aStaticList[75],    // 87 'MSGRECEIVEDDATE'
    0,    // 88
    0,    // 89
    0,    // 90
    0,    // 91
    0,    // 92
    0,    // 93
    0,    // 94
    0,    // 95
    0,    // 96
    0,    // 97
    0,    // 98
    0,    // 99
    0,    // 100
    (CPropEntry *) &aStaticList[7],    // 101 'ATTRIB'
    0,    // 102
    0,    // 103
    0,    // 104
    0,    // 105
    0,    // 106
    (CPropEntry *) &aStaticList[48],    // 107 'DOCCOMPANY'
    0,    // 108
    0,    // 109
    0,    // 110
    0,    // 111
    0,    // 112
    (CPropEntry *) &aStaticList[59],    // 113 'NEWSGROUP'
    (CPropEntry *) &aStaticList[81],    // 114 'MEDIAPROJECT'
    0,    // 115
    0,    // 116
    0,    // 117
    0,    // 118
    0,    // 119
    0,    // 120
    0,    // 121
    0,    // 122
    0,    // 123
    0,    // 124
    0,    // 125
    0,    // 126
    0,    // 127
    0,    // 128
    0,    // 129
    0,    // 130
    0,    // 131
    0,    // 132
    0,    // 133
    0,    // 134
    0,    // 135
    0,    // 136
    (CPropEntry *) &aStaticList[99],    // 137 'IMAGECX'
    0,    // 138
    (CPropEntry *) &aStaticList[100],    // 139 'IMAGECY'
    0,    // 140
    0,    // 141
    0,    // 142
    0,    // 143
    0,    // 144
    0,    // 145
    0,    // 146
    0,    // 147
    0,    // 148
    0,    // 149
    0,    // 150
    0,    // 151
    0,    // 152
    0,    // 153
    0,    // 154
    0,    // 155
    0,    // 156
    0,    // 157
    0,    // 158
    0,    // 159
    0,    // 160
    0,    // 161
    (CPropEntry *) &aStaticList[31],    // 162 'DOCLASTSAVEDTM'
    0,    // 163
    0,    // 164
    0,    // 165
    0,    // 166
    0,    // 167
    0,    // 168
    0,    // 169
    0,    // 170
    0,    // 171
    0,    // 172
    0,    // 173
    0,    // 174
    0,    // 175
    0,    // 176
    0,    // 177
    0,    // 178
    0,    // 179
    0,    // 180
    0,    // 181
    0,    // 182
    0,    // 183
    0,    // 184
    (CPropEntry *) &aStaticList[64],    // 185 'NEWSMSGID'
    (CPropEntry *) &aStaticList[82],    // 186 'MEDIASTATUS'
    0,    // 187
    0,    // 188
    0,    // 189
    0,    // 190
    (CPropEntry *) &aStaticList[77],    // 191 'MEDIAEDITOR'
    0,    // 192
    (CPropEntry *) &aStaticList[104],    // 193 'IMAGECOLORSPACE'
    0,    // 194
    0,    // 195
    0,    // 196
    (CPropEntry *) &aStaticList[44],    // 197 'DOCNOTECOUNT'
    0,    // 198
    0,    // 199
    0,    // 200
    (CPropEntry *) &aStaticList[103],    // 201 'IMAGEBITDEPTH'
    0,    // 202
    0,    // 203
    0,    // 204
    0,    // 205
    0,    // 206
    0,    // 207
    0,    // 208
    0,    // 209
    0,    // 210
    0,    // 211
    0,    // 212
    0,    // 213
    (CPropEntry *) &aStaticList[45],    // 214 'DOCHIDDENCOUNT'
    0,    // 215
    0,    // 216
    0,    // 217
    0,    // 218
    0,    // 219
    0,    // 220
    0,    // 221
    0,    // 222
    0,    // 223
    (CPropEntry *) &aStaticList[112],    // 224 'AUDIOAVGDATARATE'
    0,    // 225
    (CPropEntry *) &aStaticList[76],    // 226 'MSGARTICLEID'
    0,    // 227
    0,    // 228
    0,    // 229
    (CPropEntry *) &aStaticList[79],    // 230 'MEDIASOURCE'
    0,    // 231
    0,    // 232
    (CPropEntry *) &aStaticList[70],    // 233 'MSGREFERENCES'
    0,    // 234
    0,    // 235
    0,    // 236
    0,    // 237
    0,    // 238
    0,    // 239
    0,    // 240
    0,    // 241
    0,    // 242
    0,    // 243
    0,    // 244
    0,    // 245
    0,    // 246
    0,    // 247
    0,    // 248
    0,    // 249
    0,    // 250
    0,    // 251
    0,    // 252
    (CPropEntry *) &aStaticList[50],    // 253 'A_HREF'
    0,    // 254
    0,    // 255
    0,    // 256
    (CPropEntry *) &aStaticList[67],    // 257 'NEWSARTICLEID'
    0,    // 258
    0,    // 259
    0,    // 260
    0,    // 261
    0,    // 262
    (CPropEntry *) &aStaticList[46],    // 263 'DOCPARTTITLES'
    0,    // 264
    0,    // 265
    0,    // 266
    0,    // 267
    0,    // 268
    0,    // 269
    0,    // 270
    0,    // 271
    0,    // 272
    0,    // 273
    0,    // 274
    0,    // 275
    0,    // 276
    0,    // 277
    0,    // 278
    0,    // 279
    0,    // 280
    (CPropEntry *) &aStaticList[47],    // 281 'DOCMANAGER'
    0,    // 282
    0,    // 283
    0,    // 284
    0,    // 285
    0,    // 286
    0,    // 287
    0,    // 288
    0,    // 289
    0,    // 290
    0,    // 291
    0,    // 292
    0,    // 293
    (CPropEntry *) &aStaticList[61],    // 294 'NEWSREFERENCES'
    0,    // 295
    0,    // 296
    0,    // 297
    0,    // 298
    0,    // 299
    0,    // 300
    0,    // 301
    0,    // 302
    0,    // 303
    0,    // 304
    0,    // 305
    0,    // 306
    0,    // 307
    0,    // 308
    (CPropEntry *) &aStaticList[37],    // 309 'DOCSECURITY'
    0,    // 310
    0,    // 311
    0,    // 312
    0,    // 313
    0,    // 314
    0,    // 315
    0,    // 316
    0,    // 317
    0,    // 318
    (CPropEntry *) &aStaticList[24],    // 319 'DOCCOMMENTS'
    0,    // 320
    0,    // 321
    0,    // 322
    (CPropEntry *) &aStaticList[88],    // 323 'MUSICALBUM'
    0,    // 324
    0,    // 325
    0,    // 326
    0,    // 327
    (CPropEntry *) &aStaticList[66],    // 328 'NEWSRECEIVEDDATE'
    0,    // 329
    0,    // 330
    0,    // 331
    0,    // 332
    0,    // 333
    0,    // 334
    0,    // 335
    0,    // 336
    0,    // 337
    0,    // 338
    0,    // 339
    0,    // 340
    0,    // 341
    0,    // 342
    0,    // 343
    0,    // 344
    0,    // 345
    0,    // 346
    0,    // 347
    0,    // 348
    0,    // 349
    (CPropEntry *) &aStaticList[34],    // 350 'DOCCHARCOUNT'
    0,    // 351
    0,    // 352
    0,    // 353
    0,    // 354
    0,    // 355
    0,    // 356
    0,    // 357
    0,    // 358
    0,    // 359
    0,    // 360
    0,    // 361
    0,    // 362
    0,    // 363
    0,    // 364
    0,    // 365
    0,    // 366
    0,    // 367
    0,    // 368
    0,    // 369
    0,    // 370
    0,    // 371
    0,    // 372
    0,    // 373
    0,    // 374
    0,    // 375
    0,    // 376
    0,    // 377
    0,    // 378
    0,    // 379
    0,    // 380
    0,    // 381
    0,    // 382
    0,    // 383
    (CPropEntry *) &aStaticList[60],    // 384 'NEWSGROUPS'
    0,    // 385
    0,    // 386
    (CPropEntry *) &aStaticList[52],    // 387 'HTMLHEADING1'
    0,    // 388
    (CPropEntry *) &aStaticList[53],    // 389 'HTMLHEADING2'
    0,    // 390
    (CPropEntry *) &aStaticList[54],    // 391 'HTMLHEADING3'
    0,    // 392
    (CPropEntry *) &aStaticList[55],    // 393 'HTMLHEADING4'
    0,    // 394
    (CPropEntry *) &aStaticList[56],    // 395 'HTMLHEADING5'
    0,    // 396
    (CPropEntry *) &aStaticList[57],    // 397 'HTMLHEADING6'
    0,    // 398
    0,    // 399
    0,    // 400
    0,    // 401
    0,    // 402
    0,    // 403
    0,    // 404
    0,    // 405
    0,    // 406
    0,    // 407
    0,    // 408
    0,    // 409
    0,    // 410
    0,    // 411
    0,    // 412
    0,    // 413
    0,    // 414
    0,    // 415
    0,    // 416
    0,    // 417
    0,    // 418
    0,    // 419
    0,    // 420
    0,    // 421
    0,    // 422
    0,    // 423
    0,    // 424
    0,    // 425
    0,    // 426
    0,    // 427
    0,    // 428
    0,    // 429
    0,    // 430
    0,    // 431
    0,    // 432
    0,    // 433
    0,    // 434
    0,    // 435
    0,    // 436
    0,    // 437
    0,    // 438
    0,    // 439
    0,    // 440
    0,    // 441
    0,    // 442
    0,    // 443
    0,    // 444
    0,    // 445
    0,    // 446
    0,    // 447
    0,    // 448
    0,    // 449
    0,    // 450
    0,    // 451
    0,    // 452
    0,    // 453
    0,    // 454
    0,    // 455
    0,    // 456
    0,    // 457
    0,    // 458
    0,    // 459
    0,    // 460
    0,    // 461
    0,    // 462
    0,    // 463
    0,    // 464
    0,    // 465
    0,    // 466
    0,    // 467
    0,    // 468
    0,    // 469
    0,    // 470
    (CPropEntry *) &aStaticList[92],    // 471 'MUSICGENRE'
    0,    // 472
    0,    // 473
    (CPropEntry *) &aStaticList[12],    // 474 'CONTENTS'
    0,    // 475
    0,    // 476
    0,    // 477
    0,    // 478
    0,    // 479
    0,    // 480
    0,    // 481
    0,    // 482
    0,    // 483
    0,    // 484
    0,    // 485
    0,    // 486
    0,    // 487
    0,    // 488
    (CPropEntry *) &aStaticList[111],    // 489 'AUDIOTIMELENGTH'
    0,    // 490
    0,    // 491
    0,    // 492
    0,    // 493
    0,    // 494
    0,    // 495
    (CPropEntry *) &aStaticList[106],    // 496 'IMAGETRANSPARENCY'
    0,    // 497
    0,    // 498
    0,    // 499
    0,    // 500
    0,    // 501
    0,    // 502
    0,    // 503
    0,    // 504
    0,    // 505
    0,    // 506
    0,    // 507
    0,    // 508
    0,    // 509
    0,    // 510
    0,    // 511
    0,    // 512
    0,    // 513
    0,    // 514
    0,    // 515
    0,    // 516
    0,    // 517
    0,    // 518
    0,    // 519
    0,    // 520
    0,    // 521
    0,    // 522
    0,    // 523
    0,    // 524
    0,    // 525
    0,    // 526
    0,    // 527
    0,    // 528
    0,    // 529
    0,    // 530
    0,    // 531
    0,    // 532
    0,    // 533
    0,    // 534
    0,    // 535
    0,    // 536
    0,    // 537
    0,    // 538
    0,    // 539
    0,    // 540
    0,    // 541
    0,    // 542
    0,    // 543
    0,    // 544
    0,    // 545
    (CPropEntry *) &aStaticList[40],    // 546 'DOCBYTECOUNT'
    0,    // 547
    0,    // 548
    0,    // 549
    0,    // 550
    0,    // 551
    (CPropEntry *) &aStaticList[33],    // 552 'DOCWORDCOUNT'
    0,    // 553
    0,    // 554
    0,    // 555
    0,    // 556
    0,    // 557
    0,    // 558
    0,    // 559
    0,    // 560
    0,    // 561
    (CPropEntry *) &aStaticList[35],    // 562 'DOCTHUMBNAIL'
    0,    // 563
    0,    // 564
    0,    // 565
    (CPropEntry *) &aStaticList[10],    // 566 'ACCESS'
    0,    // 567
    0,    // 568
    0,    // 569
    0,    // 570
    0,    // 571
    0,    // 572
    0,    // 573
    0,    // 574
    0,    // 575
    0,    // 576
    0,    // 577
    (CPropEntry *) &aStaticList[78],    // 578 'MEDIASUPPLIER'
    0,    // 579
    0,    // 580
    0,    // 581
    0,    // 582
    0,    // 583
    0,    // 584
    0,    // 585
    0,    // 586
    0,    // 587
    0,    // 588
    0,    // 589
    0,    // 590
    0,    // 591
    0,    // 592
    0,    // 593
    0,    // 594
    0,    // 595
    0,    // 596
    0,    // 597
    0,    // 598
    0,    // 599
    (CPropEntry *) &aStaticList[62],    // 600 'NEWSSUBJECT'
    0,    // 601
    0,    // 602
    (CPropEntry *) &aStaticList[108],    // 603 'IMAGEFRAMECOUNT'
    0,    // 604
    0,    // 605
    0,    // 606
    0,    // 607
    0,    // 608
    0,    // 609
    0,    // 610
    0,    // 611
    0,    // 612
    0,    // 613
    0,    // 614
    0,    // 615
    0,    // 616
    0,    // 617
    0,    // 618
    0,    // 619
    0,    // 620
    0,    // 621
    0,    // 622
    0,    // 623
    0,    // 624
    0,    // 625
    (CPropEntry *) &aStaticList[93],    // 626 'DRMLICENSE'
    0,    // 627
    (CPropEntry *) &aStaticList[83],    // 628 'MEDIAOWNER'
    0,    // 629
    0,    // 630
    0,    // 631
    0,    // 632
    0,    // 633
    0,    // 634
    0,    // 635
    0,    // 636
    0,    // 637
    0,    // 638
    0,    // 639
    0,    // 640
    0,    // 641
    0,    // 642
    0,    // 643
    (CPropEntry *) &aStaticList[29],    // 644 'DOCLASTPRINTED'
    0,    // 645
    0,    // 646
    0,    // 647
    0,    // 648
    0,    // 649
    0,    // 650
    0,    // 651
    0,    // 652
    0,    // 653
    0,    // 654
    0,    // 655
    0,    // 656
    0,    // 657
    0,    // 658
    0,    // 659
    0,    // 660
    0,    // 661
    (CPropEntry *) &aStaticList[115],    // 662 'AUDIOCHANNELCOUNT'
    0,    // 663
    0,    // 664
    0,    // 665
    0,    // 666
    0,    // 667
    0,    // 668
    0,    // 669
    0,    // 670
    0,    // 671
    0,    // 672
    0,    // 673
    0,    // 674
    0,    // 675
    0,    // 676
    0,    // 677
    (CPropEntry *) &aStaticList[122],    // 678 'VIDEODATARATE'
    0,    // 679
    0,    // 680
    0,    // 681
    (CPropEntry *) &aStaticList[120],    // 682 'VIDEOFRAMECOUNT'
    0,    // 683
    0,    // 684
    0,    // 685
    0,    // 686
    0,    // 687
    0,    // 688
    0,    // 689
    0,    // 690
    (CPropEntry *) &aStaticList[39],    // 691 'DOCPRESENTATIONTARGET'
    0,    // 692
    0,    // 693
    0,    // 694
    0,    // 695
    0,    // 696
    0,    // 697
    0,    // 698
    0,    // 699
    0,    // 700
    0,    // 701
    0,    // 702
    0,    // 703
    0,    // 704
    0,    // 705
    0,    // 706
    0,    // 707
    0,    // 708
    (CPropEntry *) &aStaticList[51],    // 709 'IMG_ALT'
    0,    // 710
    0,    // 711
    0,    // 712
    0,    // 713
    0,    // 714
    0,    // 715
    0,    // 716
    0,    // 717
    0,    // 718
    0,    // 719
    (CPropEntry *) &aStaticList[113],    // 720 'AUDIOSAMPLERATE'
    0,    // 721
    0,    // 722
    0,    // 723
    0,    // 724
    0,    // 725
    0,    // 726
    0,    // 727
    0,    // 728
    0,    // 729
    0,    // 730
    0,    // 731
    0,    // 732
    0,    // 733
    0,    // 734
    0,    // 735
    0,    // 736
    0,    // 737
    0,    // 738
    0,    // 739
    0,    // 740
    0,    // 741
    0,    // 742
    0,    // 743
    0,    // 744
    0,    // 745
    0,    // 746
    0,    // 747
    0,    // 748
    0,    // 749
    0,    // 750
    0,    // 751
    0,    // 752
    (CPropEntry *) &aStaticList[14],    // 753 'RANKVECTOR'
    0,    // 754
    0,    // 755
    0,    // 756
    (CPropEntry *) &aStaticList[49],    // 757 'HTMLHREF'
    (CPropEntry *) &aStaticList[21],    // 758 'DOCSUBJECT'
    0,    // 759
    0,    // 760
    0,    // 761
    (CPropEntry *) &aStaticList[101],    // 762 'IMAGERESOLUTIONX'
    0,    // 763
    (CPropEntry *) &aStaticList[102],    // 764 'IMAGERESOLUTIONY'
    0,    // 765
    0,    // 766
    0,    // 767
    0,    // 768
    0,    // 769
    0,    // 770
    0,    // 771
    0,    // 772
    0,    // 773
    0,    // 774
    0,    // 775
    0,    // 776
    0,    // 777
    0,    // 778
    0,    // 779
    0,    // 780
    0,    // 781
    0,    // 782
    0,    // 783
    0,    // 784
    0,    // 785
    0,    // 786
    0,    // 787
    (CPropEntry *) &aStaticList[73],    // 788 'MSGMESSAGEID'
    0,    // 789
    0,    // 790
    0,    // 791
    0,    // 792
    0,    // 793
    0,    // 794
    0,    // 795
    (CPropEntry *) &aStaticList[97],    // 796 'DRMPLAYEXPIRES'
    0,    // 797
    (CPropEntry *) &aStaticList[110],    // 798 'AUDIOFORMAT'
    0,    // 799
    (CPropEntry *) &aStaticList[22],    // 800 'DOCAUTHOR'
    0,    // 801
    (CPropEntry *) &aStaticList[41],    // 802 'DOCLINECOUNT'
    0,    // 803
    0,    // 804
    0,    // 805
    0,    // 806
    0,    // 807
    0,    // 808
    0,    // 809
    0,    // 810
    0,    // 811
    0,    // 812
    0,    // 813
    (CPropEntry *) &aStaticList[80],    // 814 'MEDIASEQUENCE_NO'
    0,    // 815
    0,    // 816
    0,    // 817
    0,    // 818
    0,    // 819
    0,    // 820
    0,    // 821
    0,    // 822
    0,    // 823
    (CPropEntry *) &aStaticList[114],    // 824 'AUDIOSAMPLESIZE'
    0,    // 825
    0,    // 826
    0,    // 827
    0,    // 828
    0,    // 829
    0,    // 830
    0,    // 831
    (CPropEntry *) &aStaticList[85],    // 832 'MEDIAPRODUCTION'
    0,    // 833
    0,    // 834
    0,    // 835
    0,    // 836
    0,    // 837
    0,    // 838
    0,    // 839
    0,    // 840
    (CPropEntry *) &aStaticList[26],    // 841 'DOCLASTAUTHOR'
    0,    // 842
    0,    // 843
    0,    // 844
    (CPropEntry *) &aStaticList[25],    // 845 'DOCTEMPLATE'
    (CPropEntry *) &aStaticList[28],    // 846 'DOCEDITTIME'
    0,    // 847
    0,    // 848
    0,    // 849
    0,    // 850
    0,    // 851
    0,    // 852
    0,    // 853
    0,    // 854
    0,    // 855
    0,    // 856
    0,    // 857
    0,    // 858
    0,    // 859
    0,    // 860
    0,    // 861
    0,    // 862
    0,    // 863
    0,    // 864
    0,    // 865
    0,    // 866
    0,    // 867
    0,    // 868
    (CPropEntry *) &aStaticList[27],    // 869 'DOCREVNUMBER'
    (CPropEntry *) &aStaticList[109],    // 870 'IMAGEDIMENSIONS'
    (CPropEntry *) &aStaticList[43],    // 871 'DOCSLIDECOUNT'
    (CPropEntry *) &aStaticList[105],    // 872 'IMAGECOMPRESSION'
    0,    // 873
    0,    // 874
    0,    // 875
    0,    // 876
    0,    // 877
    0,    // 878
    0,    // 879
    0,    // 880
    0,    // 881
    0,    // 882
    0,    // 883
    0,    // 884
    0,    // 885
    (CPropEntry *) &aStaticList[69],    // 886 'MSGNEWSGROUPS'
    0,    // 887
    0,    // 888
    0,    // 889
    0,    // 890
    0,    // 891
    0,    // 892
    0,    // 893
    0,    // 894
    0,    // 895
    0,    // 896
    0,    // 897
    0,    // 898
    0,    // 899
    0,    // 900
    0,    // 901
    0,    // 902
    0,    // 903
    (CPropEntry *) &aStaticList[1],    // 904 'CLASSID'
    0,    // 905
    0,    // 906
    0,    // 907
    0,    // 908
    0,    // 909
    0,    // 910
    0,    // 911
    0,    // 912
    0,    // 913
    0,    // 914
    0,    // 915
    0,    // 916
    0,    // 917
    0,    // 918
    0,    // 919
    0,    // 920
    0,    // 921
    0,    // 922
    0,    // 923
    0,    // 924
    0,    // 925
    0,    // 926
    0,    // 927
    0,    // 928
    0,    // 929
    0,    // 930
    0,    // 931
    0,    // 932
    0,    // 933
    0,    // 934
    0,    // 935
    0,    // 936
    0,    // 937
    0,    // 938
    0,    // 939
    0,    // 940
    0,    // 941
    0,    // 942
    (CPropEntry *) &aStaticList[91],    // 943 'MUSICTRACK'
    0,    // 944
    0,    // 945
    (CPropEntry *) &aStaticList[0],    // 946 'DIRECTORY'
    0,    // 947
    0,    // 948
    0,    // 949
    0,    // 950
    0,    // 951
    0,    // 952
    0,    // 953
    0,    // 954
    0,    // 955
    0,    // 956
    (CPropEntry *) &aStaticList[96],    // 957 'DRMPLAYSTARTS'
    0,    // 958
    0,    // 959
    0,    // 960
    0,    // 961
    0,    // 962
    0,    // 963
    0,    // 964
    0,    // 965
    0,    // 966
    0,    // 967
    0,    // 968
    0,    // 969
    0,    // 970
    0,    // 971
    0,    // 972
    (CPropEntry *) &aStaticList[5],    // 973 'PATH'
    0,    // 974
    0,    // 975
    0,    // 976
    0,    // 977
    (CPropEntry *) &aStaticList[13],    // 978 'SHORTFILENAME'
    (CPropEntry *) &aStaticList[18],    // 979 'ALL'
    0,    // 980
    0,    // 981
    0,    // 982
    0,    // 983
    0,    // 984
    0,    // 985
    0,    // 986
    (CPropEntry *) &aStaticList[15],    // 987 'RANK'
    0,    // 988
    (CPropEntry *) &aStaticList[84],    // 989 'MEDIARATING'
    0,    // 990
    0,    // 991
    (CPropEntry *) &aStaticList[23],    // 992 'DOCKEYWORDS'
    0,    // 993
    0,    // 994
    0,    // 995
    0,    // 996
    0,    // 997
    0,    // 998
    0,    // 999
    0,    // 1000
    0,    // 1001
    0,    // 1002
    0,    // 1003
    0,    // 1004
    (CPropEntry *) &aStaticList[94],    // 1005 'DRMDESCRIPTION'
    0,    // 1006
    0,    // 1007
    0,    // 1008
    0,    // 1009
    0,    // 1010
    0,    // 1011
    0,    // 1012
    0,    // 1013
    0,    // 1014
    0,    // 1015
    0,    // 1016
    0,    // 1017
    0,    // 1018
    0,    // 1019
    (CPropEntry *) &aStaticList[16],    // 1020 'HITCOUNT'
    (CPropEntry *) &aStaticList[68],    // 1021 'MSGNEWSGROUP'
    0,    // 1022
    0,    // 1023
    0,    // 1024
    (CPropEntry *) &aStaticList[121],    // 1025 'VIDEOFRAMERATE'
    0,    // 1026
    0,    // 1027
    0,    // 1028
    0,    // 1029
    (CPropEntry *) &aStaticList[124],    // 1030 'VIDEOCOMPRESSION'
    0,    // 1031
    0,    // 1032
    0,    // 1033
    0,    // 1034
    (CPropEntry *) &aStaticList[98],    // 1035 'IMAGEFILETYPE'
    0,    // 1036
    0,    // 1037
    0,    // 1038
    0,    // 1039
    0,    // 1040
    (CPropEntry *) &aStaticList[90],    // 1041 'MUSICCOMMENT'
    0,    // 1042
    (CPropEntry *) &aStaticList[119],    // 1043 'VIDEOTIMELENGTH'
    0,    // 1044
    0,    // 1045
    0,    // 1046
    0,    // 1047
    0,    // 1048
    0,    // 1049
    0,    // 1050
    0,    // 1051
    0,    // 1052
    0,    // 1053
    0,    // 1054
    0,    // 1055
    0,    // 1056
    0,    // 1057
    (CPropEntry *) &aStaticList[42],    // 1058 'DOCPARACOUNT'
    0,    // 1059
    0,    // 1060
    0,    // 1061
    (CPropEntry *) &aStaticList[89],    // 1062 'MUSICYEAR'
    0,    // 1063
    0,    // 1064
    0,    // 1065
    0,    // 1066
    0,    // 1067
    0,    // 1068
    0,    // 1069
    0,    // 1070
    0,    // 1071
    0,    // 1072
    0,    // 1073
    0,    // 1074
    0,    // 1075
    0,    // 1076
    0,    // 1077
    0,    // 1078
    0,    // 1079
    0,    // 1080
    0,    // 1081
    0,    // 1082
    0,    // 1083
    0,    // 1084
    0,    // 1085
    0,    // 1086
    0,    // 1087
    0,    // 1088
    0,    // 1089
    (CPropEntry *) &aStaticList[117],    // 1090 'VIDEOFRAMEWIDTH'
    0,    // 1091
    0,    // 1092
    0,    // 1093
    0,    // 1094
    (CPropEntry *) &aStaticList[65],    // 1095 'NEWSDATE'
    0,    // 1096
    0,    // 1097
    0,    // 1098
    0,    // 1099
    0,    // 1100
    0,    // 1101
    0,    // 1102
    (CPropEntry *) &aStaticList[6],    // 1103 'SIZE'
    (CPropEntry *) &aStaticList[19],    // 1104 'VPATH'
    0,    // 1105
    0,    // 1106
    0,    // 1107
    0,    // 1108
    (CPropEntry *) &aStaticList[87],    // 1109 'MUSICSONGTITLE'
    0,    // 1110
    0,    // 1111
    0,    // 1112
    0,    // 1113
    0,    // 1114
    0,    // 1115
    0,    // 1116
    0,    // 1117
    0,    // 1118
    0,    // 1119
    0,    // 1120
    0,    // 1121
    0,    // 1122
    0,    // 1123
    0,    // 1124
    0,    // 1125
    0,    // 1126
    0,    // 1127
    0,    // 1128
    0,    // 1129
    0,    // 1130
    0,    // 1131
    0,    // 1132
    0,    // 1133
    0,    // 1134
    0,    // 1135
    0,    // 1136
    0,    // 1137
    0,    // 1138
    0,    // 1139
    0,    // 1140
    0,    // 1141
    0,    // 1142
    0,    // 1143
    0,    // 1144
    0,    // 1145
    0,    // 1146
    0,    // 1147
    0,    // 1148
    0,    // 1149
    (CPropEntry *) &aStaticList[9],    // 1150 'CREATE'
    0,    // 1151
    0,    // 1152
    0,    // 1153
    0,    // 1154
    0,    // 1155
    (CPropEntry *) &aStaticList[2],    // 1156 'FILEINDEX'
    (CPropEntry *) &aStaticList[116],    // 1157 'VIDEOSTREAMNAME'
    0,    // 1158
    0,    // 1159
    (CPropEntry *) &aStaticList[58],    // 1160 'CHARACTERIZATION'
    (CPropEntry *) &aStaticList[4],    // 1161 'FILENAME'
    0,    // 1162
    0,    // 1163
    0,    // 1164
    0,    // 1165
    0,    // 1166
    0,    // 1167
    0,    // 1168
    0,    // 1169
    0,    // 1170
    (CPropEntry *) &aStaticList[3],    // 1171 'USN'
    0,    // 1172
    0,    // 1173
    0,    // 1174
    (CPropEntry *) &aStaticList[74],    // 1175 'MSGDATE'
    0,    // 1176
    0,    // 1177
    0,    // 1178
    0,    // 1179
    0,    // 1180
    0,    // 1181
    0,    // 1182
    0,    // 1183
    0,    // 1184
    0,    // 1185
    0,    // 1186
    0,    // 1187
    0,    // 1188
    0,    // 1189
    0,    // 1190
    0,    // 1191
    0,    // 1192
    0,    // 1193
    0,    // 1194
    0,    // 1195
    0,    // 1196
    0,    // 1197
    0,    // 1198
    0,    // 1199
    0,    // 1200
    0,    // 1201
    0,    // 1202
    0,    // 1203
    0,    // 1204
    0,    // 1205
    0,    // 1206
    0,    // 1207
    0,    // 1208
    0,    // 1209
    0,    // 1210
    0,    // 1211
    0,    // 1212
    (CPropEntry *) &aStaticList[86],    // 1213 'MUSICARTIST'
    0,    // 1214
    0,    // 1215
    0,    // 1216
    (CPropEntry *) &aStaticList[32],    // 1217 'DOCPAGECOUNT'
    0,    // 1218
    0,    // 1219
    0,    // 1220
    0,    // 1221
    (CPropEntry *) &aStaticList[118],    // 1222 'VIDEOFRAMEHEIGHT'
    0,    // 1223
    0,    // 1224
    0,    // 1225
    (CPropEntry *) &aStaticList[8],    // 1226 'WRITE'
    0,    // 1227
    0,    // 1228
    0,    // 1229
    0,    // 1230
    0,    // 1231
    0,    // 1232
    0,    // 1233
    0,    // 1234
    0,    // 1235
    0,    // 1236
    0,    // 1237
    0,    // 1238
    0,    // 1239
    0,    // 1240
    0,    // 1241
    0,    // 1242
    0,    // 1243
    0,    // 1244
    0,    // 1245
    (CPropEntry *) &aStaticList[36],    // 1246 'DOCAPPNAME'
    (CPropEntry *) &aStaticList[71],    // 1247 'MSGSUBJECT'
    0,    // 1248
    0,    // 1249
    0,    // 1250
    0,    // 1251
    0,    // 1252
    0,    // 1253
    0,    // 1254
    0,    // 1255
    0,    // 1256
    0,    // 1257
    0,    // 1258
    (CPropEntry *) &aStaticList[63],    // 1259 'NEWSFROM'
    0,    // 1260
    0,    // 1261
    0,    // 1262
    0,    // 1263
    (CPropEntry *) &aStaticList[95],    // 1264 'DRMPLAYCOUNT'
    (CPropEntry *) &aStaticList[17],    // 1265 'WORKID'
    0,    // 1266
    0,    // 1267
    0,    // 1268
    0,    // 1269
    0,    // 1270
    0,    // 1271
    0,    // 1272
    0,    // 1273
    0,    // 1274
    0,    // 1275
    0,    // 1276
    0,    // 1277
    0,    // 1278
    0,    // 1279
    0,    // 1280
    (CPropEntry *) &aStaticList[30],    // 1281 'DOCCREATEDTM'
    0,    // 1282
    0,    // 1283
    0,    // 1284
    0,    // 1285
    0,    // 1286
    0,    // 1287
    0,    // 1288
    (CPropEntry *) &aStaticList[11],    // 1289 'ALLOCSIZE'
    0,    // 1290
    0,    // 1291
    0,    // 1292
    (CPropEntry *) &aStaticList[107],    // 1293 'IMAGEGAMMAVALUE'
    0,    // 1294
    0,    // 1295
    0,    // 1296
    0,    // 1297
    0,    // 1298
    0,    // 1299
    0,    // 1300
    0,    // 1301
    0,    // 1302
    0,    // 1303
    0,    // 1304
    0,    // 1305
    0,    // 1306
    0,    // 1307
    0,    // 1308
    0,    // 1309
    0,    // 1310
};

BOOL ParseGuid( WCHAR * pUgly, GUID & guid )
{
    //
    // Convert classid string to guid.  Don't use wsscanf.  We're scanning
    // into *bytes*, but wsscanf assumes result locations are *dwords*.
    // Thus a write to the last few bytes of the guid writes over other
    // memory!
    //

    //
    // A GUID MUST be of the form:
    //     XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
    //
    //  The guid MUST be 36 characters in length
    //  There MUST be a '-' in the 8th, 13th, & 18th position.
    //  The 1st number MUST be 8 digits long
    //  The 2nd, 3rd & 4th numbers MUST be 4 digits long
    //  The 5th number must be 12 digits long

    if ( (36 != wcslen(pUgly) ) ||
         (L'-' != pUgly[8]) ||
         (L'-' != pUgly[13]) ||
         (L'-' != pUgly[18]) )
    {
        return FALSE;
    }

    WCHAR wc = pUgly[8];
    pUgly[8] = 0;
    WCHAR * pwcStart = &pUgly[0];
    WCHAR * pwcEnd;
    guid.Data1 = wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[8] = wc;
    if ( (pwcEnd-pwcStart) != 8 )   // The 1st number MUST be 8 digits long
        return FALSE;

    wc = pUgly[13];
    pUgly[13] = 0;
    pwcStart = &pUgly[9];
    guid.Data2 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[13] = wc;
    if ( (pwcEnd-pwcStart) != 4 ) //  The 2nd number MUST be 4 digits long
        return FALSE;

    wc = pUgly[18];
    pUgly[18] = 0;
    pwcStart = &pUgly[14];
    guid.Data3 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[18] = wc;
    if ( (pwcEnd-pwcStart) != 4 ) //  The 3rd number MUST be 4 digits long
        return FALSE;

    wc = pUgly[21];
    pUgly[21] = 0;
    pwcStart = &pUgly[19];
    guid.Data4[0] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[21] = wc;
    if ( (pwcEnd-pwcStart) != 2 ) //  The 4th number MUST be 4 digits long
        return FALSE;

    wc  = pUgly[23];
    pUgly[23] = 0;
    pwcStart = &pUgly[21];
    guid.Data4[1] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    pUgly[23] = wc;
    if ( (pwcEnd-pwcStart) != 2 ) //  The 4th number MUST be 4 digits long
        return FALSE;

    for ( unsigned i = 0; i < 6; i++ )
    {
        wc = pUgly[26+i*2];
        pUgly[26+i*2] = 0;
        pwcStart = &pUgly[24+i*2];
        guid.Data4[2+i] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
        pUgly[26+i*2] = wc;
        if ( pwcStart == pwcEnd )
            return FALSE;
    }

    return TRUE;
} //ParseGuid
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\scanner.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1994-1998, Microsoft Corporation.
//
//  File:   SCANNER.CXX
//
//  Contents:   Implementation of CQueryScanner
//
//  History:    22-May-92   AmyA        Created.
//              23-Jun-92   MikeHew     Added weight token recognition.
//              17-May-94   t-jeffc     Added error info and reg ex support.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::CQueryScanner, public
//
//  Synopsis:   Create a scanner from a string.
//
//  Arguments:  [buffer] -- the string to be scanned.
//              [fLookForTextualKeywords] -- TRUE if the scanner should
//                                           look for "and/or/not/near" in
//                                           text form.
//              [lcid]   -- language for and/or/not/near detection
//              [fTreatPlusAsToken] -- TRUE if the scanner should treat the
//                                           '+' character as a token (used
//                                           in GroupBy parsing)
//
//  Notes:      This string is not copied, so the scanner does not own it.
//              If the string is changed outside of the scanner, it will
//              affect the information that is returned.
//
//  History:    30-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

CQueryScanner::CQueryScanner(
    WCHAR const * buffer,
    BOOL fLookForTextualKeywords,
    LCID lcid,
    BOOL fTreatPlusAsToken )
    : _text( buffer ),
      _pBuf( buffer ),
      _pLookAhead( buffer ),
      _fLookForTextualKeywords( fLookForTextualKeywords ),
      _fTreatPlusAsToken( fTreatPlusAsToken ),
      _lcid( lcid )
{
    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcceptWord, public
//
//  Synopsis:   Consumes a single word out of a phrase
//
//  Requires:   Should be called after AcqWord
//
//  History:    15-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

void CQueryScanner::AcceptWord()
{
    _pLookAhead = _text;
    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcceptColumn, public
//
//  Synopsis:   Consumes a column name out of a phrase
//
//  Requires:   Should be called after AcqColumn
//
//  History:    15-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

void CQueryScanner::AcceptColumn()
{
    AcceptWord();
}


struct SStringToken
{
    WCHAR *  pwcToken;
    unsigned cwc;
    Token    token;
};

static SStringToken s_EnglishStringTokens[] =
{
    { L"AND",    (sizeof L"AND" / sizeof WCHAR) - 1,    AND_TOKEN },
    { L"OR",     (sizeof L"OR" / sizeof WCHAR) - 1,     OR_TOKEN },
    { L"NOT",    (sizeof L"NOT" / sizeof WCHAR) - 1,    NOT_TOKEN },
    { L"NEAR",   (sizeof L"NEAR" / sizeof WCHAR) - 1,   PROX_TOKEN },
};

static SStringToken s_GermanStringTokens[] =
{
    { L"UND",    (sizeof L"UND" / sizeof WCHAR) - 1,    AND_TOKEN },
    { L"ODER",   (sizeof L"ODER" / sizeof WCHAR) - 1,   OR_TOKEN },
    { L"NICHT",  (sizeof L"NICHT" / sizeof WCHAR) - 1,  NOT_TOKEN },
    { L"NAH",    (sizeof L"NAH" / sizeof WCHAR) - 1,    PROX_TOKEN },
};

static SStringToken s_FrenchStringTokens[] =
{
    { L"ET",     (sizeof L"ET" / sizeof WCHAR) - 1,     AND_TOKEN },
    { L"OU",     (sizeof L"OU" / sizeof WCHAR) - 1,     OR_TOKEN },
    { L"SANS",   (sizeof L"SANS" / sizeof WCHAR) - 1,   NOT_TOKEN },
    { L"PRES",   (sizeof L"PRES" / sizeof WCHAR) - 1,   PROX_TOKEN },
};

static SStringToken s_SpanishStringTokens[] =
{
    { L"Y",      (sizeof L"Y" / sizeof WCHAR) - 1,      AND_TOKEN },
    { L"O",      (sizeof L"O" / sizeof WCHAR) - 1,      OR_TOKEN },
    { L"NO",     (sizeof L"NO" / sizeof WCHAR) - 1,     NOT_TOKEN },
    { L"CERCA",  (sizeof L"CERCA" / sizeof WCHAR) - 1,  PROX_TOKEN },
};

static SStringToken s_DutchStringTokens[] =
{
    { L"EN",     (sizeof L"EN" / sizeof WCHAR) - 1,     AND_TOKEN },
    { L"OF",     (sizeof L"OF" / sizeof WCHAR) - 1,     OR_TOKEN },
    { L"NIET",   (sizeof L"NIET" / sizeof WCHAR) - 1,   NOT_TOKEN },
    { L"NABIJ",  (sizeof L"NABIJ" / sizeof WCHAR) - 1,  PROX_TOKEN },
};

static WCHAR aSwedishNear[] = { L'N', 0xc4, L'R', L'A', 0 };

static SStringToken s_SwedishStringTokens[] =
{
    { L"OCH",    (sizeof L"OCH" / sizeof WCHAR) - 1,    AND_TOKEN },
    { L"ELLER",  (sizeof L"ELLER" / sizeof WCHAR) - 1,  OR_TOKEN },
    { L"INTE",   (sizeof L"INTE" / sizeof WCHAR) - 1,   NOT_TOKEN },
    { aSwedishNear, 4,                                  PROX_TOKEN },
};

static SStringToken s_ItalianStringTokens[] =
{
    { L"E",      (sizeof L"E" / sizeof WCHAR) - 1,      AND_TOKEN },
    { L"O",      (sizeof L"O" / sizeof WCHAR) - 1,      OR_TOKEN },
    { L"NO",     (sizeof L"NO" / sizeof WCHAR) - 1,     NOT_TOKEN },
    { L"VICINO", (sizeof L"VICINO" / sizeof WCHAR) - 1, PROX_TOKEN },
};

const unsigned cStringTokens = sizeof(s_EnglishStringTokens) /
                               sizeof(s_EnglishStringTokens[0]);

#define WORD_STR  L"{}!&|~*@#()[],\t=<>\n\"^ "

//+---------------------------------------------------------------------------
//
//  Function:   InternalFindStringToken
//
//  Synopsis:   Looks for a textual token in plain text.
//
//  Arguments:  [pwcIn]   -- string to search
//              [token]   -- returns the token found
//              [cwc]     -- returns length of token found
//              [pTokens] -- token array to use
//
//  Returns:    Pointer to token or 0 if none was found
//
//  History:    08-Feb-96   dlee        created
//
//----------------------------------------------------------------------------

WCHAR * InternalFindStringToken(
    WCHAR *        pwcIn,
    Token &        token,
    unsigned &     cwc,
    SStringToken * pTokens )
{
    // for each of and/or/not/near

    WCHAR *pwcOut = 0;

    for ( unsigned i = 0; i < cStringTokens; i++ )
    {
        WCHAR *pwcStr = wcsstr( pwcIn, pTokens[i].pwcToken );

        while ( pwcStr )
        {
            // found a match -- does it have white space on either side?

            WCHAR wcBeyond = * (pwcStr + pTokens[i].cwc);
            if ( ( ( 0 == wcBeyond ) ||
                   ( wcschr( WORD_STR, wcBeyond ) ) ) &&
                 ( ( pwcStr == pwcIn ) ||
                   ( iswspace( * ( pwcStr - 1 ) ) ) ) )
            {
                // if the first match found or the match closest to the
                // beginning of the string, use it.

                if ( ( 0 == pwcOut ) ||
                     ( pwcStr < pwcOut ) )
                {
                    pwcOut = pwcStr;
                    token = pTokens[i].token;
                    cwc = pTokens[i].cwc;
                }

                break;
            }

            pwcStr = wcsstr( pwcStr + 1, pTokens[i].pwcToken );
        }
    }

    return pwcOut;
} //InternalFindStringToken

SStringToken * GetStringTokenArray(
    LCID lcid )
{
    SStringToken *pTokens;

    switch ( PRIMARYLANGID( LANGIDFROMLCID( lcid ) ) )
    {
        case LANG_GERMAN :
            pTokens = s_GermanStringTokens;
            break;
        case LANG_FRENCH :
            pTokens = s_FrenchStringTokens;
            break;
        case LANG_SPANISH :
            pTokens = s_SpanishStringTokens;
            break;
        case LANG_DUTCH :
            pTokens = s_DutchStringTokens;
            break;
        case LANG_SWEDISH :
            pTokens = s_SwedishStringTokens;
            break;
        case LANG_ITALIAN :
            pTokens = s_ItalianStringTokens;
            break;
        case LANG_NEUTRAL :
        case LANG_ENGLISH :
        default :
            pTokens = s_EnglishStringTokens;
            break;
    }

    Win4Assert( 0 != pTokens );

    return pTokens;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindStringToken
//
//  Synopsis:   Looks for a textual token in plain text.  Always tries
//              English, tries a different language depending on _lcid.
//
//  Arguments:  [pwcIn] -- string to search
//              [token] -- returns the token found
//              [cwc]   -- returns length of token found
//
//  Returns:    Pointer to token or 0 if none was found
//
//  History:    08-Feb-96   dlee        created
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::FindStringToken(
    WCHAR *    pwcIn,
    Token &    token,
    unsigned & cwc )
{
    SStringToken * pTokens = GetStringTokenArray( _lcid );

    WCHAR * pwcToken = InternalFindStringToken( pwcIn, token, cwc, pTokens );

    // if the search above wasn't in English, try English too.

    if ( pTokens != s_EnglishStringTokens )
    {
        unsigned cwcEnglish;
        Token tokenEnglish;
        WCHAR * pwcEnglish = InternalFindStringToken( pwcIn,
                                                      tokenEnglish,
                                                      cwcEnglish,
                                                      s_EnglishStringTokens );

        // If there is no language-specific match or the English match
        // occurs before the language-specific match, use the English
        // match.

        if ( ( 0 != pwcEnglish ) &&
             ( ( 0 == pwcToken ) || ( pwcEnglish < pwcToken ) ) )
        {
            pwcToken = pwcEnglish;
            token = tokenEnglish;
            cwc = cwcEnglish;
        }
    }

    return pwcToken;
} //FindStringToken

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::Accept, public
//
//  Synopsis:   Determines what the next token is.  Will advance _pLookAhead
//              over the next token and white space.
//
//  Notes:      There are five different types of TEXT_TOKENS, Phrase, Path,
//              Number, Column and Command.  Since the length of the token
//              depends on which token it is, _pLookAhead is forwarded to the
//              end of the longest, and _text is used to parse the token in the
//              various Acq and Get methods.
//
//  History:    30-Apr-92   AmyA        Created
//              19-May-92   AmyA        Added Guid hack
//              23-Jun-92   MikeHew     Added weight token recognition.
//              26-May-94   t-jeffc     Added more tokens; rearranged to
//                                      support parsing errors
//
//----------------------------------------------------------------------------

void CQueryScanner::Accept()
{
    EatWhiteSpace();

    _text = _pLookAhead;

    switch ( *_pLookAhead )
    {
    case '&':
        _pLookAhead++;
        _token = AND_TOKEN;
        break;

    case '*':
        _pLookAhead++;

        if ( *_pLookAhead == '*' )
        {
            _token = FUZ2_TOKEN;
            _pLookAhead++;
        }
        else
            _token = FUZZY_TOKEN;
        break;

    case '=':
        _pLookAhead++;
        _token = EQUAL_TOKEN;
        break;

    case '<':
        _pLookAhead++;
        if ( *_pLookAhead == '=' )
        {
            _token = LESS_EQUAL_TOKEN;
            _pLookAhead++;
        }
        else
            _token = LESS_TOKEN;
        break;

    case '>':
        _pLookAhead++;
        if ( *_pLookAhead == '=' )
        {
            _token = GREATER_EQUAL_TOKEN;
            _pLookAhead++;
        }
        else
            _token = GREATER_TOKEN;
        break;

    case '!':
        _pLookAhead++;
        if ( *_pLookAhead == '=' )
        {
            _token = NOT_EQUAL_TOKEN;
            _pLookAhead++;
        }
        else
        {
            _token = NOT_TOKEN;
        }
        break;

    case '|':
        _pLookAhead++;
        _token = OR_TOKEN;
        break;

    case '~':
        _pLookAhead++;
        _token = PROX_TOKEN;
        break;

    case '@':
        _pLookAhead++;
        _token = PROP_TOKEN;
        break;

    case '#':
        _pLookAhead++;
        _token = PROP_REGEX_TOKEN;
        break;

    case '(':
        _pLookAhead++;
        _token = OPEN_TOKEN;
        break;

    case ')':
        _pLookAhead++;
        _token = CLOSE_TOKEN;
        break;

    case '[':
        _pLookAhead++;
        _token = W_OPEN_TOKEN;
        break;

    case ']':
        _pLookAhead++;
        _token = W_CLOSE_TOKEN;
        break;

    case ',':
        _pLookAhead++;
        _token = COMMA_TOKEN;
        break;

    case '\0':
    case 0x1A:  // CTRL-Z
        _token = EOS_TOKEN;
        break;

    case '"':
        _pLookAhead++;
        _token = QUOTES_TOKEN;
        break;

    case '$':
        _pLookAhead++;
        _token = PROP_NATLANG_TOKEN;
        break;

    case '{':
       _pLookAhead++;
      _token = C_OPEN_TOKEN;
      break;

    case '}':
       _pLookAhead++;
      _token = C_CLOSE_TOKEN;
      break;

    case '^':
    {
        WCHAR wc = *(_pLookAhead + 1);

        BOOL fOk = TRUE;

        if (L'a' == wc) // all bits
            _token = ALLOF_TOKEN;
        else if (L's' == wc) // some bits
            _token = SOMEOF_TOKEN;
        else
            fOk = FALSE;

        if (fOk)
        {
            _pLookAhead += 2;
            break;
        }
    }
    // FALL THROUGH

    case '+':
        if (*_pLookAhead == L'+' && _fTreatPlusAsToken)
        {
            _pLookAhead++;
            _token = PLUS_TOKEN;
            break;
        }
    // FALL THROUGH

    default:
    {
        // forwards pwcEnd over anything that could be in a phrase,
        // which is the most inclusive of the TEXT_TOKENs.
        // (except, for regex's and phrases in quotes - but they're
        // handled separately)

        WCHAR const *pwcEnd = _text + wcscspn( _text, PHRASE_STR );

        if ( _fLookForTextualKeywords )
        {
            unsigned cwc = (unsigned) ( pwcEnd - _text );
            cwc = __min( cwc, MAX_PATH * 2 );

            // if a textual keyword is beyond 500 chars in the string,
            // blow it off -- the workaround is to use the '&|~' version.

            WCHAR awcBuf[ 1 + MAX_PATH * 2 ];
            RtlCopyMemory( awcBuf, _text, cwc * sizeof WCHAR );
            awcBuf[ cwc ] = 0;

            ULONG cwcOut = LCMapString( _lcid,
                                        LCMAP_UPPERCASE,
                                        awcBuf,
                                        cwc,
                                        awcBuf,
                                        cwc );
            if ( cwcOut != cwc )
                THROW( CException() );

            Token token;
            unsigned cwcToken;
            WCHAR *pwcTok = FindStringToken( awcBuf, token, cwcToken );

            if ( 0 != pwcTok )
            {
                // a textual token exists in the string

                if ( pwcTok == awcBuf )
                {
                    // textual token at the start of the string

                    _token = token;
                    _pLookAhead = _text + cwcToken;
                }
                else
                {
                    // textual token in the middle of the string, stop the
                    // current token at that point and get it next time
                    // Accept() is called.

                    _pLookAhead = _text + ( pwcTok - awcBuf );
                    _token = TEXT_TOKEN;
                }
            }
            else
            {
                _pLookAhead = pwcEnd;
                _token = TEXT_TOKEN;
            }
        }
        else
        {
            _pLookAhead = pwcEnd;
            _token = TEXT_TOKEN;
        }

        break;
    }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AllocReturnString, private inline
//
//  Synopsis:   Copies all of the relevant characters of the string that
//              _text is pointing to and returns the new string.
//
//  History:    17 Apr 97   AlanW       Created
//
//----------------------------------------------------------------------------

inline WCHAR * CQueryScanner::AllocReturnString( int cch )
{
    WCHAR * newBuf = new WCHAR [ cch + 1 ];
    RtlCopyMemory ( newBuf, _text, cch * sizeof(WCHAR));
    newBuf[cch] = L'\0';

    _text += cch;
    while ( iswspace(*_text) )
        _text++;

    return newBuf;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqPath, public
//
//  Synopsis:   Copies all of the relevant characters of the string that
//              _text is pointing to and returns the new string.  Will
//              return 0 if _text is at end of whole TEXT_TOKEN.
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//              This method can be called several times before calling
//              Accept(), so many paths can be acquired if they exist in the
//              scanner.
//
//  History:    30-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqPath()
{
    if ( IsEndOfTextToken() )
        return 0;

    // how many characters follow _text that are not in CMND_STR?

    int count = wcscspn( _text, CMND_STR );

    return AllocReturnString( count );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqWord, public
//
//  Synopsis:   Copies the word that _text is pointing to and returns the
//              new string. Positions _text after the word and whitespace.
//              Returns 0 if at the end of a TEXT_TOKEN.
//
//  History:    29-Jun-92    MikeHew    Created.
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqWord()
{
    if ( IsEndOfTextToken() )
        return 0;

    WCHAR const * pEnd = _text;

    while ( !iswspace(*pEnd) && pEnd < _pLookAhead )
        pEnd++;

    unsigned count = CiPtrToUint( pEnd - _text );

    return AllocReturnString( count );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqColumn, public
//
//  Synopsis:   Copies a column name and returns the new string.  A column
//              name is either a single word, or a quoted string.
//              Positions _text after the word and whitespace.
//
//  Returns:    WCHAR* pointer to column name.  0 if no column name found.
//
//  History:    17 Apr 97    AlanW      Created.
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqColumn()
{
    if ( QUOTES_TOKEN == _token)
    {
        Accept();
        WCHAR * pwszOut = AcqPhraseInQuotes();
        _text = _pLookAhead;
        return pwszOut;
    }

    if ( IsEndOfTextToken() )
        return 0;

    int count = wcscspn( _text, COLUMN_STR );
    return AllocReturnString( count );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqPhrase, public
//
//  Synopsis:   Copies all of the relevant characters of the string that
//              _text is pointing to and returns the new string.
//              Returns 0 if at the end of a text token.
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//              The difference between this function and AcqPath is that this
//              should only be called once before calling Accept().
//
//  History:    30-Apr-92   AmyA        Created
//              09-May-96   DwightKr    Strip trailing white space
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqPhrase()
{
    if( IsEndOfTextToken() )
        return 0;

    //
    //  Strip trailing white-space from the end of the phrase.  _pLookAhead
    //  points to the first character of the NEXT phrase.
    //
    WCHAR const * pEnd = _pLookAhead - 1;
    while ( (pEnd > _text) && iswspace(*pEnd) )
    {
        pEnd--;
    }

    unsigned count = CiPtrToUint( pEnd - _text ) + 1;

    WCHAR * newBuf = new WCHAR [ count + 1 ];
    RtlCopyMemory( newBuf, _text, count * sizeof( WCHAR ) );
    newBuf[count] = 0;

    return newBuf;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqRegEx, public
//
//  Synopsis:   Copies all of the relevant characters of the string that
//              _text is pointing to and returns the new string.  Matches
//              the longest string possible - the only restriction is that
//              the regex can not contain any of the characters in REGEX_STR
//              outside of <> braces (which may be nested).
//              Returns 0 if the regex is empty.
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//              Because some regex characters are duplicated in the query
//              language, _pLookAhead is ignored (and actually reset) in
//              this operation.  Like AcqPhrase(), this should be called only
//              once before Accept().
//
//  History:    10-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqRegEx()
{
    WCHAR const * pEnd = _text;
    BOOL fDone = FALSE;
    BOOL fQuoted = FALSE;

    if ( *pEnd == L'"' )
    {
        fQuoted = TRUE;
        pEnd++;
    }

    // scan the string - stop at \0 or if any REGEX_STR characters are
    // found outside of braces
    //
    for( ;; )
    {
        switch( *pEnd )
        {
        case '\0':
            if ( fQuoted )
                THROW( CException( QPARSE_E_UNEXPECTED_EOS ) );

            fDone = TRUE;
            break;

        case ' ':
            if ( !fQuoted )
                fDone = TRUE;
            break;

        case ')':
            if ( !fQuoted )
            {
                if ( ( pEnd != _text ) &&
                     ( '|' != (*(pEnd-1)) ) )
                    fDone = TRUE;
            }
            break;

        case '"':
            if ( fQuoted )
            {
                pEnd++;
                fDone = TRUE;
            }
            break;

        default:
            break;

        } // switch( *pEnd )

        if( fDone ) break;

        pEnd++;
    }

    if( _text == pEnd )
        return 0;

    // set _pLookAhead
    _pLookAhead = pEnd;

    // copy the string
    unsigned count = CiPtrToUint( _pLookAhead - _text );

    if ( fQuoted )
    {
        Win4Assert( count >= 2 );
        count -= 2;
    }
        
    WCHAR * newBuf = new WCHAR[ count + 1 ];

    RtlCopyMemory( newBuf, _text + (fQuoted ? 1 : 0), count * sizeof( WCHAR ) );
    newBuf[ count ] = 0;

    return newBuf;

}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqPhraseInQuotes, public
//
//  Synopsis:   Copies all characters until a matching " is found, or until
//              the end of string.  Embedded quotes are escaped with a quote:
//              "Bill ""the man"" Gates"
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//
//  History:    18-Jan-95   SitaramR        Created
//               3-Jul-96   dlee            added embedded quotes
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqPhraseInQuotes()
{
    WCHAR const * pEnd = _text;

    do
    {
        if ( 0 == *pEnd )
            break;

        if ( L'"' == *pEnd )
        {
            if ( L'"' == *(pEnd+1) )
                pEnd++;
            else
                break;
        }

        pEnd++;
    } while ( TRUE );

    unsigned count = CiPtrToUint( pEnd - _text );

    WCHAR * newBuf = new WCHAR [ count + 1 ];
    WCHAR * pwcNewBuf = newBuf;
    WCHAR const * pStart = _text;

    // copy the string, but remove the extra quote characters

    while ( pStart < pEnd )
    {
        *pwcNewBuf++ = *pStart++;
        if ( L'"' == *pStart )
            pStart++;
    }

    *pwcNewBuf = 0;

    if ( *pEnd == L'"' )
        _pLookAhead = pEnd + 1;
    else
        _pLookAhead = pEnd;

    return newBuf;
}



//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the ULONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the ULONG which will be changed and passed back
//                          out as the ULONG from the scanner.
//              [fAtEnd] -- returns TRUE if at the end of the scanned string
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    11-May-92   AmyA        Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( ULONG & number, BOOL & fAtEnd )
{
    if ( IsEndOfTextToken() || !iswdigit(*_text) || (*_text == L'-') )
        return FALSE;

    // is this a hex number?

    ULONG base = 10;

    if (_text[0] == L'0' && (_text[1] == L'x' || _text[1] == L'X'))
    {
        _text += 2;
        base = 16;
    }

    const WCHAR * pwcStart = _text;

    number = wcstoul( _text, (WCHAR **)(&_text), base );

    // looks like a real number?

    if ( ( pwcStart == _text ) ||
         ( L'.' == *_text ) )
        return FALSE;

    while ( iswspace(*_text) )
        _text++;

    fAtEnd = ( 0 == *_text );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the LONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the LONG which will be changed and passed back
//                          out as the LONG from the scanner.
//              [fAtEnd] -- returns TRUE if at the end of the scanned string
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Jan-15   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( LONG & number, BOOL & fAtEnd )
{
    WCHAR *text = (WCHAR *) _text;

    BOOL IsNegative = FALSE;

    ULONG ulMax = (ULONG) LONG_MAX;

    if ( L'-' == _text[0] )
    {
        IsNegative = TRUE;

        ulMax++; // can represent 1 more negative than positive.

        _text++;
    }

    ULONG ulNumber;
    if ( !GetNumber( ulNumber, fAtEnd ) )
    {
        _text = text;
        return FALSE;
    }

    //  Signed number overflow/underflow

    if ( ulNumber > ulMax )
    {
        _text = text;
        return FALSE;
    }

    if ( IsNegative )
    {
        if ( ulMax == ulNumber )
            number = LONG_MIN;
        else
            number = - (LONG) ulNumber;
    }
    else
    {
        number = (LONG) ulNumber;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the ULONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the ULONG which will be changed and passed back
//                          out as the ULONG from the scanner.
//              [fAtEnd] -- returns TRUE if at the end of the scanned string
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    27-Feb-96   dlee        Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( unsigned _int64 & number, BOOL & fAtEnd )
{
    if ( IsEndOfTextToken() || !iswdigit(*_text) || (*_text == L'-') )
        return FALSE;

    // is this a hex number?

    ULONG base = 10;

    if (_text[0] == L'0' && (_text[1] == L'x' || _text[1] == L'X'))
    {
        _text += 2;
        base = 16;
    }

    const WCHAR * pwcStart = _text;

    number = _wcstoui64( _text, (WCHAR **)(&_text), base );

    // looks like a real number?

    if ( ( pwcStart == _text ) ||
         ( L'.' == *_text ) )
        return FALSE;

    while ( iswspace(*_text) )
        _text++;

    fAtEnd = ( 0 == *_text );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the LONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the LONG which will be changed and passed back
//                          out as the LONG from the scanner.
//              [fAtEnd] -- returns TRUE if at the end of the scanned string
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    27-Feb-96   dlee        Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( _int64 & number, BOOL & fAtEnd )
{
    WCHAR *text = (WCHAR *) _text;

    BOOL IsNegative = FALSE;

    unsigned _int64 ullMax = (unsigned _int64) _I64_MAX;

    if ( L'-' == _text[0] )
    {
        IsNegative = TRUE;

        ullMax++; // can represent 1 more negative than positive.

        _text++;
    }

    unsigned _int64 ullNumber;
    if ( !GetNumber( ullNumber, fAtEnd ) )
    {
        _text = text;
        return FALSE;
    }

    //  Signed number overflow/underflow

    if ( ullNumber > ullMax )
    {
        _text = text;
        return FALSE;
    }

    if ( IsNegative )
    {
        if ( ullMax == ullNumber )
            number = _I64_MIN;
        else
            number = -((_int64) ullNumber);
    }
    else
    {
        number = (_int64) ullNumber;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the LONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the double which will be changed and passed back
//                          out as the double from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Jan-15   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CQueryScanner::GetNumber( double & number )
{
    if ( IsEndOfTextToken() || !iswdigit(*_text) )
        return FALSE;

    if ( swscanf( _text, L"%lf", &number ) != 1 )
    {
        return FALSE;
    }

    while ( iswspace(*_text) != 0 )
        _text++;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::GetCommandChar, public
//
//  Synopsis:   Returns the command character pointed to by _text and advances
//              _text.  If the command can't be uniquely determined by the
//              first character, each subsequent call will return the next
//              character in the word.  After the command has been determined,
//              AcceptCommand() should be called and then operand parsing may begin.
//
//  History:    14-May-92   AmyA        Created
//              16-May-94   t-jeffc     Returns one character at a time to
//                                      support more commands
//
//----------------------------------------------------------------------------

WCHAR CQueryScanner::GetCommandChar()
{
    if( IsEndOfTextToken() )
        return 0;

    WCHAR chCommand = _text[0];

    _text++;

    return towlower( chCommand );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcceptCommand, public
//
//  Synopsis:   Advances _text past any characters in the command.
//              Used when enough command characters have been
//              read to uniquely determine the command and begin parsing
//              the operands.
//
//  History:    16-May-94   t-jeffc         Created
//
//----------------------------------------------------------------------------

void  CQueryScanner::AcceptCommand()
{
    int cChars = wcscspn( _text, CMND_STR ); // how many characters follow
                                             // _text that are not in CMND_STR

    _text += cChars;

    _pLookAhead = _text;

    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::ResetBuffer, public
//
//  Synopsis:   Puts a new string into _pBuf and resets _pLookAhead
//              accordingly.
//
//  Arguments:  [buffer] -- the new string for _pBuf
//
//  History:    05-May-92   AmyA        Created
//
//----------------------------------------------------------------------------

void CQueryScanner::ResetBuffer( WCHAR const * buffer )
{
    _pBuf = buffer;
    _pLookAhead = _pBuf;
    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::EatWhiteSpace, private
//
//  Synopsis:   Advances _pLookAhead past any white space in the string.
//
//  History:    29-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

void CQueryScanner::EatWhiteSpace()
{
    while ( iswspace(*_pLookAhead) != 0 )
        _pLookAhead++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::IsEndOfTextToken, private
//
//  Synopsis:   Returns TRUE if the current token is not a TEXT_TOKEN or
//              if the string starting at _text to _pLookAhead contains
//              nothing but whitespace.
//
//  History:    27-May-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

BOOL CQueryScanner::IsEndOfTextToken()
{
    if( _token == TEXT_TOKEN && _text < _pLookAhead )
        return FALSE;
    else
        return TRUE;

}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryScanner::AcqLine, public
//
//  Synopsis:   Copies all of the remaining characters on the line;
//              return 0 if _text is at end of whole TEXT_TOKEN.
//
//  Arguments:  [fParseQuotes] -- if TRUE, initial and final quotes are removed
//
//  Notes:      Since the string is copied, the caller of this function is
//              responsible for freeing the memory occupied by the string.
//              This method can be called several times before calling
//              Accept(), so many paths can be acquired if they exist in the
//              scanner.
//
//  History:    96-Jan-03   DwightKr    Created
//              96-Feb-26   DwightKr    Allow lines to be quoted
//
//----------------------------------------------------------------------------

WCHAR * CQueryScanner::AcqLine( BOOL fParseQuotes )
{
    if ( *_text == L'\0' )
        return 0;

    unsigned cwcBuffer = wcslen(_text);

    //
    // If there are \r, \n, or other white space at the end of the string,
    // strip it off
    //

    while ( cwcBuffer > 0 && _text[cwcBuffer-1] <= L' ' )
        cwcBuffer--;

    if ( fParseQuotes )
    {
        //
        //  If there is a pair of quotes delimiting this line, strip them off
        //
    
        if ( (L'"' == _text[0]) && (cwcBuffer > 1) )
        {
            if ( L'"' == _text[cwcBuffer-1] )
                cwcBuffer--;
    
            _text++;
            cwcBuffer--;
        }
    }

    WCHAR *pText = new WCHAR [ cwcBuffer + 1 ];
    RtlCopyMemory( pText, _text, cwcBuffer * sizeof(WCHAR) );
    pText[cwcBuffer] = 0;

    _pLookAhead = _text + cwcBuffer - 1;

    return pText;
} //AcqLine
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\qcanon.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1998.
//
//  File:       qcanon.cxx
//
//  Contents:   CCiCanonicalOutput class
//
//  History:    6-06-95   srikants   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qcanon.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   CastToStorageVariant
//
//  Synopsis:   To treat a variant as a CStorageVariant. Because CStorageVariant
//              derives from PROPVARIANT in a "protected" fashion, we cannot
//              directly typecast a PROPVARIANT * to a CStorageVariant *
//
//  Arguments:  [varnt] - The variant that must be type casted.
//
//  Returns:    A pointer to varnt as a CStorageVariant.
//
//  History:    6-06-95   srikants   Created
//
//  Notes:      There are two overloaded implementations, one to convert
//              a reference to const to a pointer to const.
//
//----------------------------------------------------------------------------

inline
CStorageVariant * CastToStorageVariant( PROPVARIANT & varnt )
{
    return (CStorageVariant *) ((void *) &varnt);
}

inline
CStorageVariant const * CastToStorageVariant( PROPVARIANT const & varnt )
{
    return (CStorageVariant *) ((void *) &varnt);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCiCanonicalOutput::PutWString, static public
//
//  Synopsis:
//
//  Arguments:  [stm]     -
//              [pwszStr] -
//
//  Returns:
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCiCanonicalOutput::PutWString( PSerStream & stm, WCHAR const * pwszStr )
{
    ULONG cwc = (0 != pwszStr) ? wcslen( pwszStr ) : 0;

    stm.PutULong( cwc );
    if (cwc)
        stm.PutWChar( pwszStr, cwc );
}

//+---------------------------------------------------------------------------
//
//  Method:     CCiCanonicalOutput::GetWString, static public
//
//  Synopsis:
//
//  Arguments:  [stm]      -
//              [fSuccess] -
//
//  Returns:
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WCHAR * CCiCanonicalOutput::GetWString( PDeSerStream & stm, BOOL & fSuccess )
{
    ULONG cwc = stm.GetULong();
    fSuccess = TRUE;

    if ( 0 == cwc )
    {
        return 0;
    }

    ULONG cb = (cwc+1) * sizeof(WCHAR);
    WCHAR * pwszStr = (WCHAR *) CoTaskMemAlloc( cb  );
    if ( 0 == pwszStr )
    {
        fSuccess = FALSE;
        return 0;
    }

    stm.GetWChar( pwszStr, cwc );
    pwszStr[cwc] = L'\0';

    return pwszStr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCiCanonicalOutput::AllocAndCopyWString, static public
//
//  Synopsis:
//
//  Arguments:  [pSrc] -
//
//  Returns:
//
//  History:    6-22-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WCHAR * CCiCanonicalOutput::AllocAndCopyWString( const WCHAR * pSrc )
{
    WCHAR * pDst = 0;
    if ( 0 != pSrc )
    {
        const cb = ( wcslen( pSrc ) + 1 ) * sizeof(WCHAR);
        pDst = (WCHAR *) new WCHAR [ cb/sizeof(WCHAR) ];
        if ( 0 != pDst )
        {
            RtlCopyMemory( pDst, pSrc, cb );
        }
    }

    return pDst;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiCanonicalQueryRows::Init
//
//  Synopsis:   Initializes the query rows output structure for writing
//              results out.
//
//  History:    7-01-96   srikants   Created
//
//----------------------------------------------------------------------------

void CCiCanonicalQueryRows::Init()
{
    RtlZeroMemory( this, sizeof(CCiCanonicalQueryRows) );

    InitVersion();
    SetOutputType( CCiCanonicalOutput::eQueryRows );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQuadByteAlignedBuffer::CQuadByteAlignedBuffer
//
//  Synopsis:   Constructor for a quad aligned buffer class.
//
//  Arguments:  [cbBuffer] - Number of bytes in the buffer class.
//
//  History:    6-16-96   srikants   Created
//
//----------------------------------------------------------------------------

CQuadByteAlignedBuffer::CQuadByteAlignedBuffer( ULONG cbBuffer )
{
    // allocator guarantees 8-byte alignment

    _pbAlloc = new BYTE [ cbBuffer ];
    _cbAlloc = cbBuffer;

    Win4Assert( ( ((ULONG_PTR) _pbAlloc) & 0x7) == 0 );
    _pbAligned = _pbAlloc;
    _cbAligned = _cbAlloc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\string.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       string.cxx
//
//  Contents:   Yet another string class and support functions
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <locale.h>

//+---------------------------------------------------------------------------
//
//  Member:     CVirtualString::CVirtualString - public constructor
//
//  Synopsis:   Initializes the string by virtually allocating a buffer.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------

CVirtualString::CVirtualString( unsigned cwcBuffer )
                                   : _wcsString(0),
                                     _wcsEnd(0),
                                     _cwcBuffer(cwcBuffer),
                                     _pwcLastCommitted(0)
{
    _wcsString = new WCHAR[ _cwcBuffer ];
    _pwcLastCommitted = _wcsString + _cwcBuffer - 1;
    _wcsEnd = _wcsString;
    *_wcsEnd = 0;
} //CVirtualString

//+---------------------------------------------------------------------------
//
//  Member:     CVirtualString::~CVirtualString - public destructor
//
//  Synopsis:   Releases virtual memory assocated with this buffer
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CVirtualString::~CVirtualString()
{
    delete [] _wcsString;
} //~CVirtualString

//+---------------------------------------------------------------------------
//
//  Member:     CVirtualString::GrowBuffer, private
//
//  Synopsis:   Commits or re-allocates the string as needed
//
//  Arguments:  [cwcValue]  - # of WCHARs by which to grow the buffer
//
//  History:    96/Mar/25   dlee    Created from DwightKr's StrCat
//
//----------------------------------------------------------------------------

void CVirtualString::GrowBuffer( ULONG cwcValue )
{
    unsigned cwcNewString = cwcValue + 1;
    unsigned cwcOldString = CiPtrToUint( _wcsEnd - _wcsString );
    unsigned cwcRemaining = CiPtrToUint( _cwcBuffer - cwcOldString );

    Win4Assert( _cwcBuffer >= cwcOldString );

    if ( cwcRemaining < cwcNewString )
    {
        DWORD cwcOldBuffer = _cwcBuffer;
        DWORD cwcNewBuffer = _cwcBuffer;

        do
        {
            cwcNewBuffer *= 2;
            cwcRemaining = cwcNewBuffer - cwcOldString;
        }
        while ( cwcRemaining < cwcNewString );

        XArray<WCHAR> xTemp( cwcNewBuffer );

        RtlCopyMemory( xTemp.GetPointer(),
                       _wcsString,
                       _cwcBuffer * sizeof WCHAR );
        delete [] _wcsString;

        _wcsString = xTemp.Acquire();
        _cwcBuffer = cwcNewBuffer;
        _wcsEnd = _wcsString + cwcOldString;
        _pwcLastCommitted = _wcsString + _cwcBuffer - 1;
    }
} //GrowBuffer

// if TRUE, the character doesn't need to be URL escaped

static const BYTE g_afNoEscape[128] =
{
    FALSE,        // 00 (NUL) 
    FALSE,        // 01 (SOH) 
    FALSE,        // 02 (STX) 
    FALSE,        // 03 (ETX) 
    FALSE,        // 04 (EOT) 
    FALSE,        // 05 (ENQ) 
    FALSE,        // 06 (ACK) 
    FALSE,        // 07 (BEL) 
    FALSE,        // 08 (BS)  
    FALSE,        // 09 (HT)  
    FALSE,        // 0A (LF)  
    FALSE,        // 0B (VT)  
    FALSE,        // 0C (FF)  
    FALSE,        // 0D (CR)  
    FALSE,        // 0E (SI)  
    FALSE,        // 0F (SO)  
    FALSE,        // 10 (DLE) 
    FALSE,        // 11 (DC1) 
    FALSE,        // 12 (DC2) 
    FALSE,        // 13 (DC3) 
    FALSE,        // 14 (DC4) 
    FALSE,        // 15 (NAK) 
    FALSE,        // 16 (SYN) 
    FALSE,        // 17 (ETB) 
    FALSE,        // 18 (CAN) 
    FALSE,        // 19 (EM)  
    FALSE,        // 1A (SUB) 
    FALSE,        // 1B (ESC) 
    FALSE,        // 1C (FS)  
    FALSE,        // 1D (GS)  
    FALSE,        // 1E (RS)  
    FALSE,        // 1F (US)  
    FALSE,        // 20 SPACE 
    FALSE,        // 21 !     
    FALSE,        // 22 "     
    FALSE,        // 23 #     
    FALSE,        // 24 $     
    FALSE,        // 25 %     
    FALSE,        // 26 &     
    FALSE,        // 27 '     
    FALSE,        // 28 (     
    FALSE,        // 29 )     
    FALSE,        // 2A *     
    FALSE,        // 2B +     
    FALSE,        // 2C ,     
    FALSE,        // 2D -     
    TRUE,         // 2E .     
    TRUE,         // 2F /     
    TRUE,         // 30 0     
    TRUE,         // 31 1     
    TRUE,         // 32 2     
    TRUE,         // 33 3     
    TRUE,         // 34 4     
    TRUE,         // 35 5     
    TRUE,         // 36 6     
    TRUE,         // 37 7     
    TRUE,         // 38 8     
    TRUE,         // 39 9     
    TRUE,         // 3A :     
    FALSE,        // 3B ;     
    FALSE,        // 3C <     
    TRUE,         // 3D =     
    FALSE,        // 3E >     
    FALSE,        // 3F ?     
    FALSE,        // 40 @     
    TRUE,         // 41 A     
    TRUE,         // 42 B     
    TRUE,         // 43 C     
    TRUE,         // 44 D     
    TRUE,         // 45 E     
    TRUE,         // 46 F     
    TRUE,         // 47 G     
    TRUE,         // 48 H     
    TRUE,         // 49 I     
    TRUE,         // 4A J     
    TRUE,         // 4B K     
    TRUE,         // 4C L     
    TRUE,         // 4D M     
    TRUE,         // 4E N     
    TRUE,         // 4F O     
    TRUE,         // 50 P     
    TRUE,         // 51 Q     
    TRUE,         // 52 R     
    TRUE,         // 53 S     
    TRUE,         // 54 T     
    TRUE,         // 55 U     
    TRUE,         // 56 V     
    TRUE,         // 57 W     
    TRUE,         // 58 X     
    TRUE,         // 59 Y     
    TRUE,         // 5A Z     
    FALSE,        // 5B [     
    FALSE,        // 5C \     
    FALSE,        // 5D ]     
    FALSE,        // 5E ^     
    FALSE,        // 5F _     
    FALSE,        // 60 `     
    TRUE,         // 61 a     
    TRUE,         // 62 b     
    TRUE,         // 63 c     
    TRUE,         // 64 d     
    TRUE,         // 65 e     
    TRUE,         // 66 f     
    TRUE,         // 67 g     
    TRUE,         // 68 h     
    TRUE,         // 69 i     
    TRUE,         // 6A j     
    TRUE,         // 6B k     
    TRUE,         // 6C l     
    TRUE,         // 6D m     
    TRUE,         // 6E n     
    TRUE,         // 6F o     
    TRUE,         // 70 p     
    TRUE,         // 71 q     
    TRUE,         // 72 r     
    TRUE,         // 73 s     
    TRUE,         // 74 t     
    TRUE,         // 75 u     
    TRUE,         // 76 v     
    TRUE,         // 77 w     
    TRUE,         // 78 x     
    TRUE,         // 79 y     
    TRUE,         // 7A z     
    FALSE,        // 7B {     
    FALSE,        // 7C |     
    FALSE,        // 7D }     
    FALSE,        // 7E ~     
    FALSE,        // 7F (DEL) 
};

static const unsigned cNoEscape = sizeof g_afNoEscape / sizeof g_afNoEscape[0];

//+---------------------------------------------------------------------------
//
//  Function:   IsNoUrlEscape
//
//  Synopsis:   Determines if a character doesn't need URL escaping.
//
//  Arguments:  [c]  --  Character to test, T must be unsigned.
//
//  Returns:    TRUE if b doesn't need URL escaping.
//
//  History:    98/Apr/22   dlee    Created.
//
//----------------------------------------------------------------------------

template<class T> inline BOOL IsNoUrlEscape( T c )
{
    if ( c < cNoEscape )
        return g_afNoEscape[ c ];

    return FALSE;
} //IsNoUrlEscape

//+---------------------------------------------------------------------------
//
//  Function:   URLEscapeW
//
//  Synopsis:   Appends an escaped version of a string to a virtual string.
//
//  History:    96/Apr/03   dlee        Created from DwightKr's code
//              96/May/21   DwightKr    Escape spaces
//              97/Nov/19   AlanW       Allow %ummmm escape codes
//
//----------------------------------------------------------------------------

void URLEscapeW( WCHAR const * wcsString,
                 CVirtualString & StrResult,
                 ULONG ulCodepage,
                 BOOL fConvertSpaceToPlus )
{
    BOOL fTryConvertMB = TRUE;

    //
    //  All spaces are converted to plus signs (+), percents are doubled,
    //  Non alphanumeric characters are represented by their
    //  hexadecimal ASCII equivalents.
    //
    Win4Assert( wcsString != 0 );

    while ( *wcsString != 0 )
    {
        //
        //  Spaces can be treated differently on either size of the ?.
        //  Spaces before the ? (the URI) needs to have spaces escaped;
        //  those AFTER the ? can be EITHER escaped, or changed to a +.
        //  Use either '+' or the % escape depending upon fConverSpaceToPlus
        //

        if ( IsNoUrlEscape( *wcsString ) )
        {
            StrResult.CharCat( *wcsString );
        }
        else if ( L' ' == *wcsString )
        {
            if ( fConvertSpaceToPlus )
                StrResult.CharCat( L'+' );
            else
                StrResult.StrCat( L"%20", 3 );
        }
        else if ( L'%' == *wcsString )
        {
            StrResult.StrCat( L"%%", 2 );
        }
        else if ( *wcsString < 0x80 )
        {
            StrResult.CharCat( L'%' );
            unsigned hiNibble = ((*wcsString) & 0xf0) >> 4;
            unsigned loNibble = (*wcsString) & 0x0f;
            StrResult.CharCat( hiNibble > 9 ? (hiNibble-10 + L'A') : (hiNibble + L'0') );
            StrResult.CharCat( loNibble > 9 ? (loNibble-10 + L'A') : (loNibble + L'0') );
        }
        else
        {
            Win4Assert( *wcsString >= 0x80 );
            
            //
            // We encountered a character outside the ASCII range.
            // Try counverting the Unicode string to multi-byte.  If the
            // conversion succeeds, continue by converting to 8 bit characters.
            // Otherwise, convert this and any other Unicode characters to the
            // %ummmm escape.
            //
            if ( fTryConvertMB )
            {
                ULONG cchString = wcslen(wcsString);
                XArray<BYTE> pszString( cchString*2 );
                BOOL fUsedDefaultChar = FALSE;
                DWORD cbConvert;
                ULONG cbString = pszString.Count();

                do
                {
                    cbConvert = WideCharToMultiByte( ulCodepage,
#if (WINVER >= 0x0500)
                                                     WC_NO_BEST_FIT_CHARS |
#endif // (WINVER >= 0x0500)
                                                        WC_COMPOSITECHECK | 
                                                        WC_DEFAULTCHAR,
                                                     wcsString,
                                                     cchString,
                                            (CHAR *) pszString.Get(),
                                                     cbString,
                                                     0,
                                                     &fUsedDefaultChar );

                    if ( 0 == cbConvert )
                    {
                        Win4Assert( cbString > 0 );
                        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                        {
                             cbString += cbString;
                             delete pszString.Acquire();
                             pszString.Init(cbString);
                        }
                        else if ( GetLastError() == ERROR_INVALID_PARAMETER )
                        {
                            // Presumably unknown code page.
                            fUsedDefaultChar = TRUE;
                            break;
                        }
                        else
                        {
                            THROW( CException() );
                        }
                   }
                } while ( 0 == cbConvert );

                if ( ! fUsedDefaultChar )
                {
                    URLEscapeMToW(pszString.Get(), cbConvert, StrResult, fConvertSpaceToPlus );
                    return;
                }
                
                fTryConvertMB = FALSE;
            }

            // Convert to an escaped Unicode character
            StrResult.StrCat( L"%u", 2 );
            USHORT wch = *wcsString;

            unsigned iNibble = (wch & 0xf000) >> 12;
            StrResult.CharCat( iNibble > 9 ? (iNibble-10 + L'A') : (iNibble + L'0') );
            iNibble = (wch & 0x0f00) >> 8;
            StrResult.CharCat( iNibble > 9 ? (iNibble-10 + L'A') : (iNibble + L'0') );
            iNibble = (wch & 0x00f0) >> 4;
            StrResult.CharCat( iNibble > 9 ? (iNibble-10 + L'A') : (iNibble + L'0') );
            iNibble = wch & 0x000f;
            StrResult.CharCat( iNibble > 9 ? (iNibble-10 + L'A') : (iNibble + L'0') );
        }

        wcsString++;
    }
} //URLEscapeW


//+---------------------------------------------------------------------------
//
//  Function:   URLEscapeMToW
//
//  Synopsis:   Appends an escaped version of a string to a virtual string.
//              The string is 'pseudo-UniCode'.  A multi-byte input string
//              is converted to a UniCode URL, which is implicitly ASCII.
//
//  History:    96/Apr/03   dlee        Created from DwightKr's code
//              96/May/21   DwightKr    Escape spaces
//              96-Sep-17   KyleP       Modified URLEscapeW
//
//----------------------------------------------------------------------------

void URLEscapeMToW( BYTE const * psz,
                    unsigned cc,
                    CVirtualString & StrResult,
                    BOOL fConvertSpaceToPlus )
{
    //
    //  All spaces are converted to plus signs (+), percents are doubled,
    //  Non alphanumeric characters are represented by their
    //  hexadecimal ASCII equivalents.
    //

    Win4Assert( psz != 0 );

    for( unsigned i = 0; i < cc; i++ )
    {
        //
        //  Spaces can be treated differently on either size of the ?.
        //  Spaces before the ? (the URI) needs to have spaces escaped;
        //  those AFTER the ? can be EITHER escaped, or changed to a +.
        //  Use either '+' or the % escape depending upon fConverSpaceToPlus
        //

        if ( IsNoUrlEscape( psz[i] ) )
        {
            StrResult.CharCat( (WCHAR)psz[i] );
        }
        else if ( L' ' == psz[i] )
        {
            if ( fConvertSpaceToPlus )
                StrResult.CharCat( L'+' );
            else
                StrResult.StrCat( L"%20", 3 );
        }
        else if ( L'%' == psz[i] )
        {
            StrResult.StrCat( L"%%", 2 );
        }
        else
        {
            StrResult.CharCat( L'%' );
            unsigned hiNibble = ((psz[i]) & 0xf0) >> 4;
            unsigned loNibble = (psz[i]) & 0x0f;
            StrResult.CharCat( hiNibble > 9 ? (hiNibble-10 + L'A') : (hiNibble + L'0') );
            StrResult.CharCat( loNibble > 9 ? (loNibble-10 + L'A') : (loNibble + L'0') );
        }
    }
} //URLEscapeMToW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\strgroup.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:   strgroup.cxx
//
//  Contents:   Builds a nesting node object from a GroupBy string
//
//  History:    10 Apr 1997    AlanW     Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <strsort.hxx>

static GUID guidBmk = DBBMKGUID;
static CDbColId psBookmark( guidBmk, PROPID_DBBMK_BOOKMARK );


//+---------------------------------------------------------------------------
//
//  Function:   GetStringDbGroupNode - public
//
//  Synopsis:   Builds a CDbNestingNode from the string passed
//
//  Arguments:  [pwszGroup] - the string containing the grouping specification
//              [pList]     - the property list describing the column names
//
//  Notes:      CPListException is used instead of CParserException so the
//              error class will be IDQError, not RESError in idq.dll.
//
//  History:    10 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

CDbNestingNode * GetStringDbGroupNode( const WCHAR * pwszGroup,
                                       IColumnMapper * pList )
{
    Win4Assert( 0 != pwszGroup );
    CQueryScanner scanner( pwszGroup, FALSE, GetUserDefaultLCID(), TRUE );

    CParseGrouping ParseObj( scanner, pList, FALSE );
    ParseObj.Parse();

    return ParseObj.AcquireNode();
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseGrouping::Parse, public
//
//  Synopsis:   Parse a GroupBy string, construct the nesting node
//
//  Arguments:  -NONE- uses previously set member variables
//
//  Notes:      CPListException is used instead of CParserException so the
//              error class will be IDQError, not RESError in idq.dll.
//
//  History:    10 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

void CParseGrouping::Parse( )
{
    while (_Scanner.LookAhead() != EOS_TOKEN)
    {
        XPtr<CDbNestingNode> xNode( ParseGrouping() );
        if (_Scanner.LookAhead() == COMMA_TOKEN)
        {
            _Scanner.Accept();
        }
        else if (_Scanner.LookAhead() != EOS_TOKEN)
        {
            THROW( CPListException(QPARSE_E_EXPECTING_COMMA, 0) );
        }

        if (0 == _cNestings)
        {
            Win4Assert( _xNode.GetPointer() == 0 );
            _xNode.Set( xNode.Acquire() );
        }
        else
        {
            CDbNestingNode * pNode = _xNode.GetPointer();
            for (unsigned i=1; i < _cNestings; i++)
            {
                Win4Assert( pNode->GetCommandType() == DBOP_nesting );
                pNode = (CDbNestingNode *)pNode->GetFirstChild();
            }
  
            Win4Assert( pNode != 0 && pNode->GetFirstChild()->GetCommandType() == DBOP_project_list_anchor );
            pNode->AddTable( xNode.Acquire() );
        }
        _cNestings++;
    }
    if (_fNeedSortNode)
        AddSortList( _xSortNode );
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseGrouping::ParseGrouping, private
//
//  Synopsis:   Parse an individual grouping specification
//
//  Arguments:  -NONE- uses previously set member variables
//
//  Notes:      The scanner is advanced past the parsed grouping spec.
//
//  History:    10 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

CDbNestingNode * CParseGrouping::ParseGrouping( )
{
    CDbNestingNode * pDbNestingNode = new CDbNestingNode();
    if ( 0 == pDbNestingNode )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    XPtr<CDbNestingNode> xDbNestingNode(pDbNestingNode);

    //
    //  Parse any leading grouping type specification.
    //
    ULONG ulCatType = eUnique;    // Assume unique value categories

    if ( _Scanner.LookAhead() == W_OPEN_TOKEN )
        ulCatType = ParseGroupingType();

    //  NOTE:  only the unique categorization is implemented.
    if (ulCatType != eUnique)
        THROW( CPListException(QPARSE_E_INVALID_GROUPING, 0) );

    if ( 0 == _xSortNode.GetPointer() )
    {
        CDbSortNode * pDbSortNode = new CDbSortNode();
        if ( 0 == pDbSortNode )
        {
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        _xSortNode.Set(pDbSortNode);
    }

    BOOL fFirstGroupingColumn = TRUE;
    for ( XPtrST<WCHAR> pwszColumnName( _Scanner.AcqColumn() );
          pwszColumnName.GetPointer() != 0;
          pwszColumnName.Set( _Scanner.AcqColumn() )
        )
    {
        _Scanner.AcceptColumn();                // Remove the column name

        //
        //  Parse for the [a] or [d] parameters.
        //
        unsigned order = QUERY_SORTASCEND;      // Assume ascending sort order

        if ( _Scanner.LookAhead() == W_OPEN_TOKEN )
        {
            _Scanner.Accept();                  // Remove the '['

            WCHAR wchOrder = _Scanner.GetCommandChar();

            if ( wchOrder == L'a' )
            {
                order = QUERY_SORTASCEND;
            }
            else if ( wchOrder == L'd' )
            {
                order = QUERY_SORTDESCEND;
                _fNeedSortNode = TRUE;
            }
            else
            {
                // Report an error
                THROW( CPListException(QPARSE_E_INVALID_SORT_ORDER, 0) );
            }

            WCHAR wchNext = _Scanner.GetCommandChar();
            if (wchNext != 0 && !iswspace(wchNext))
                // some alphabetic character followed the '[a' or '[d'.
                THROW( CPListException(QPARSE_E_INVALID_SORT_ORDER, 0) );

            _Scanner.AcceptCommand();   // Remove the command character

            if ( _Scanner.LookAhead() != W_CLOSE_TOKEN )
            {
                // Report an error
                THROW( CPListException(QPARSE_E_EXPECTING_BRACE, 0) );
            }

            _Scanner.Accept();          // Remove the ']' character
        }

        //
        //  Add the new grouping column to the nesting node
        //
        CDbColId  *pDbColId = 0;
        DBID *pdbid = 0;
        if ( FAILED(_xPropList->GetPropInfoFromName( pwszColumnName.GetPointer(), &pdbid, 0, 0 )) )
        {
            //
            //  Column name not found.
            //
            THROW( CPListException(QPARSE_E_NO_SUCH_SORT_PROPERTY, 0) );
        }
        pDbColId = (CDbColId *)pdbid;

        if ( fFirstGroupingColumn )
        {
            fFirstGroupingColumn = FALSE;
            if ( !pDbNestingNode->AddParentColumn(psBookmark) )
            {
                //  Report a failure.
                THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
            }
        }

        if ( !pDbNestingNode->AddParentColumn(*pDbColId) )
        {
            //  Report a failure.
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        BOOL fFail = _fKeepFriendlyNames ? 
            !pDbNestingNode->AddGroupingColumn(*pDbColId, pwszColumnName.GetPointer()) :
            !pDbNestingNode->AddGroupingColumn(*pDbColId);

        if (fFail)
        {
            //  Report a failure.
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        //
        //  Add the column to the sort node in case we will need it.
        //
        CDbSortKey sortKey( *pDbColId, order == QUERY_SORTDESCEND );

        if ( !_xSortNode->AddSortColumn(sortKey) )
        {
            //  Report a failure.
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        pwszColumnName.Free();

        //
        //  Skip over +'s seperating grouping columns
        //

        if ( _Scanner.LookAhead() == PLUS_TOKEN )
        {
            // We don't support this syntax (or document it)

            //_Scanner.Accept();          // Remove the '+'

            THROW( CPListException(QPARSE_E_INVALID_GROUPING, 0) );
        }

        //
        //  Find a new grouping specification if a comma is found
        if ( _Scanner.LookAhead() == COMMA_TOKEN )
        {
            break;
        }
    }

    return xDbNestingNode.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseGrouping::ParseGroupingType, private
//
//  Synopsis:   Parses and returns the grouping type.
//
//  Arguments:  -NONE-
//
//  Returns:    ECategoryType - grouping type found if valid
//
//  Notes:      Upon return, the scanner is advanced past the grouping type.
//              Throws CPListException in case of syntax errors
//
//  History:    10 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

CParseGrouping::ECategoryType CParseGrouping::ParseGroupingType( )
{
    Win4Assert( _Scanner.LookAhead() == W_OPEN_TOKEN );
    _Scanner.Accept();                   // Remove the '['

    XPtrST<WCHAR> pwszCategoryName( _Scanner.AcqWord() );
    ECategoryType CatType = eInvalidCategory;

    if ( pwszCategoryName.IsNull() )
        THROW( CPListException(QPARSE_E_INVALID_GROUPING, 0) );

    if ( _wcsicmp( pwszCategoryName.GetPointer(), L"unique" ) == 0 )
    {
        CatType = eUnique;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"quantile" ) == 0 )
    {
        CatType = eBuckets;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"cluster" ) == 0 )
    {
        CatType = eCluster;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"range" ) == 0 )
    {
        CatType = eRange;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"time" ) == 0 )
    {
        CatType = eTime;
    }
    else if ( _wcsicmp( pwszCategoryName.GetPointer(), L"alpha" ) == 0 )
    {
        CatType = eAlpha;
    }
    else
    {
        // Report an error
        THROW( CPListException(QPARSE_E_INVALID_GROUPING, 0) );
    }
    _Scanner.AcceptWord();      // Remove the grouping type name

    if ( _Scanner.LookAhead() != W_CLOSE_TOKEN )
    {
        // Report an error
        THROW( CPListException(QPARSE_E_EXPECTING_BRACE, 0) );
    }
    _Scanner.Accept();          // Remove the ']' character

    return CatType;
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseGrouping::AddSortList, private
//
//  Synopsis:   Add sort columns.
//
//  Arguments:  [SortNode] - a smart pointer to the sort node to be added
//
//  Notes:      A sort list is added below the lowermost nesting node.
//              If there already is a sort node there, the sort columns are
//              appended to the list.
//
//  History:    21 Apr 1997    AlanW     Created.
//
//----------------------------------------------------------------------------

void CParseGrouping::AddSortList( XPtr<CDbSortNode> & SortNode )
{
    Win4Assert( _cNestings > 0 );

    CDbNestingNode * pNode = _xNode.GetPointer();
    for (unsigned i=1; i < _cNestings; i++)
    {
        Win4Assert( pNode->GetCommandType() == DBOP_nesting );
        pNode = (CDbNestingNode *)pNode->GetFirstChild();
    }

    Win4Assert( pNode != 0 &&
                (pNode->GetFirstChild()->GetCommandType() == DBOP_project_list_anchor ||
                 pNode->GetFirstChild()->GetCommandType() == DBOP_sort ));

    if (pNode->GetFirstChild()->GetCommandType() == DBOP_project_list_anchor)
    {
        // No sort node yet.  Add a node.
        if (_xSortNode.GetPointer())
        {
            pNode->AddTable( _xSortNode.Acquire() );
            if ( 0 == SortNode.GetPointer() )
            {
                //
                //  If called with _xSortNode, the Acquire above cleared the
                //  smart pointer.  We're done.
                //
                return;
            }
        }
        else
        {
            pNode->AddTable( SortNode.Acquire() );
            return;
        }
    }

    Win4Assert(pNode->GetFirstChild()->GetCommandType() == DBOP_sort);
    Win4Assert(pNode->GetFirstChild()->GetFirstChild()->GetCommandType() == DBOP_sort_list_anchor);
    Win4Assert(0 == _xSortNode.GetPointer());

    // The sort list elements from SortNode will be carved off and appended
    // to the list in pSLA.
    CDbSortListAnchor * pSLA = (CDbSortListAnchor *)pNode->GetFirstChild()->GetFirstChild();


    Win4Assert(SortNode.GetPointer() != 0);
    Win4Assert(SortNode->GetCommandType() == DBOP_sort);
    Win4Assert(SortNode->GetFirstChild()->GetCommandType() == DBOP_sort_list_anchor);
    XPtr<CDbSortListElement> xSLE ( (CDbSortListElement *) SortNode->GetFirstChild()->AcquireChildren() );
    

    if (xSLE.GetPointer())
    {
        pSLA->AppendList( xSLE.GetPointer() );
        xSLE.Acquire();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\strrest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       strrest.cxx
//
//  Contents:   Builds a restriction object from a string
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <parser.hxx>
#include <pvarset.hxx>
#include <strsort.hxx>
#include <cierror.h>

extern CDbContentRestriction * TreeFromText(
    WCHAR const *   wcsRestriction,
    IColumnMapper & ColumnMapper,
    LCID            lcid );

//+---------------------------------------------------------------------------
//
//  Function:   GetStringDbRestriction - public constructor
//
//  Synopsis:   Builds a CDbRestriction from the string passed
//
//  Arguments:  [wcsRestriction] - the string containing the restriction
//              [ulDialect]      - triplish dialect
//              [pList]          - property list describing the proptypes
//              [lcid]           - the locale of the query
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CDbRestriction * GetStringDbRestriction(
    const WCHAR *   wcsRestriction,
    ULONG           ulDialect,
    IColumnMapper * pList,
    LCID            lcid )
{
    Win4Assert( 0 != wcsRestriction );
    Win4Assert( ISQLANG_V1 == ulDialect || ISQLANG_V2 == ulDialect );

    XPtr<CDbRestriction> xRest;

    if ( ISQLANG_V1 == ulDialect )
    {
        CQueryScanner scanner( wcsRestriction, TRUE, lcid );

        CQueryParser query( scanner,
                            VECTOR_RANK_JACCARD,
                            lcid,
                            L"contents",
                            CONTENTS,
                            pList );

        xRest.Set( query.ParseQueryPhrase() );
    }
    else
    {
        xRest.Set( TreeFromText( wcsRestriction, *pList, lcid ) );
    }

    return xRest.Acquire();
} //GetStringDbRestriction

//+---------------------------------------------------------------------------
//
//  Function:   FormDbQueryTree
//
//  Synopsis:   Builds a CDbCmdTreeNode from the restriction, sort
//              specification, grouping specification and output columns.
//
//  Arguments:  [xDbRestriction] - the restriction
//              [xDbSortNode]    - the sort specification (optional)
//              [xDbProjectList] - the output columns
//              [xDbGroupNode]   - the grouping specification (optional)
//              [ulMaxRecords]   - max records to return
//              [ulFirstRows]    - only sort and display the first ulFirstRows 
//                                 rows
//
//  History:    1996/Jan/03   DwightKr    Created.
//              2000/Jul/01   KitmanH     Added ulFirstRows
//
//----------------------------------------------------------------------------
CDbCmdTreeNode * FormDbQueryTree( XPtr<CDbCmdTreeNode> & xDbCmdTreeNode,
                                  XPtr<CDbSortNode> & xDbSortNode,
                                  XPtr<CDbProjectListAnchor> & xDbProjectList,
                                  XPtr<CDbNestingNode> & xDbGroupNode,
                                  ULONG ulMaxRecords,
                                  ULONG ulFirstRows )
{
    XPtr<CDbCmdTreeNode> xDbCmdTree = 0;

    //
    // First create a selection node and append the restriction tree to it
    //
    CDbSelectNode * pSelect = new CDbSelectNode();
    if ( 0 == pSelect )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    xDbCmdTree.Set( pSelect );
    if ( !pSelect->IsValid() )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    //
    // Now make the restriction a child of the selection node.
    //

    pSelect->AddRestriction( xDbCmdTreeNode.GetPointer() );
    xDbCmdTreeNode.Acquire();

    //
    // If there is a nesting node, add the project list and the selection
    // node below the lowest nesting node.  Otherwise, create a projection
    // node and make the selection a child of the projection node.
    //
    if ( 0 != xDbGroupNode.GetPointer() )
    {
        CDbNestingNode * pBottomNestingNode = xDbGroupNode.GetPointer();
        CDbCmdTreeNode * pTree = pBottomNestingNode;

        while (pTree->GetFirstChild() != 0 &&
               (pTree->GetFirstChild()->GetCommandType() == DBOP_nesting ||
                pTree->GetFirstChild()->GetCommandType() == DBOP_sort))
        {
            pTree = pTree->GetFirstChild();
            if (pTree->GetCommandType() == DBOP_nesting)
                pBottomNestingNode = (CDbNestingNode *)pTree;
        }

        // Add the input projection list to the nesting node
        if (! pBottomNestingNode->SetChildList( *xDbProjectList.GetPointer() ))
            THROW( CException(E_INVALIDARG) );

        //
        // Make the selection a child of the lowest node.
        //
        if (pBottomNestingNode == pTree)
        {
            pBottomNestingNode->AddTable( xDbCmdTree.GetPointer() );
            xDbCmdTree.Acquire();
        }
        else
        {
            Win4Assert( pTree->IsSortNode() );
            ((CDbSortNode *)pTree)->AddTable( xDbCmdTree.GetPointer() );
            xDbCmdTree.Acquire();
        }

        xDbCmdTree.Set( xDbGroupNode.Acquire() );
    }
    else
    {
        //
        // Create the projection nodes
        //
        CDbProjectNode * pProject = new CDbProjectNode();
        if ( 0 == pProject )
        {
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        //
        // Make the selection a child of the projection node.
        //
        pProject->AddTable( xDbCmdTree.GetPointer() );
        xDbCmdTree.Acquire();

        xDbCmdTree.Set( pProject );

        //
        // Next add the column list to the project node
        //

        pProject->AddList( xDbProjectList.GetPointer() );
        xDbProjectList.Acquire();

        //
        // Next make the project node a child of the sort node
        //

        if ( !xDbSortNode.IsNull() && 0 != xDbSortNode->GetFirstChild() )
        {
            xDbSortNode->AddTable( xDbCmdTree.GetPointer() );
            xDbCmdTree.Acquire();

            xDbCmdTree.Set( xDbSortNode.Acquire() );
        }
    }

    CDbTopNode *pTop = 0;

    //
    //  If the user specified a max # of records to examine, then setup
    //  a node to reflect this.
    //
    if ( ulMaxRecords > 0 )
    {
        pTop = new CDbTopNode();
        if ( pTop == 0 )
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );

        pTop->SetChild( xDbCmdTree.Acquire() );
        pTop->SetValue(ulMaxRecords );
    }

    //
    //  Set FirstRows here
    //
    if ( ulFirstRows > 0 )
    {
        CDbFirstRowsNode *pFR = new CDbFirstRowsNode();
        if ( pFR == 0 )
            THROW( CException( STATUS_NO_MEMORY ) );

        CDbCmdTreeNode *pChild = pTop ? pTop : xDbCmdTree.Acquire();
        pFR->SetChild( pChild );
        pFR->SetValue( ulFirstRows );

        return pFR;
    }  

    if ( 0 != pTop )
        return pTop;

    return xDbCmdTree.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseStringColumns
//
//  Synopsis:   Parses the textual columns separated by commas into CDbColumns.
//              Also, adds the columns to a set of named variables if the
//              optional parameter pVariableSet is passed.
//
//  Arguments:  [wcsColumns]   -- List of columns, separated by commas
//              [pList]        -- Column mapper.
//              [lcid]         -- locale
//              [pVarSet]      -- [optional] Variable Set.
//              [pawcsColumns] -- [optional] Parsed columns
//
//  History:    3-03-97   srikants   Created
//              7-23-97   KyleP      Return parsed columns
//
//----------------------------------------------------------------------------

CDbColumns * ParseStringColumns( WCHAR const * wcsColumns,
                                 IColumnMapper * pList,
                                 LCID lcid,
                                 PVariableSet * pVarSet,
                                 CDynArray<WCHAR> * pawcsColumns )
{
    CDbColumns * pDbCols = new CDbColumns(0);
    if ( 0 == pDbCols )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    XPtr<CDbColumns> xDbCols( pDbCols );

    CQueryScanner scan( wcsColumns, FALSE, lcid );

    for ( XPtrST<WCHAR> wcsColumn( scan.AcqColumn() );
          wcsColumn.GetPointer() != 0;
          wcsColumn.Set( scan.AcqColumn() )
        )
    {
        CDbColId  *pDbColId = 0;
        DBID *pdbid = 0;
        _wcsupr( wcsColumn.GetPointer() );

        if ( FAILED(pList->GetPropInfoFromName( wcsColumn.GetPointer(), &pdbid, 0, 0 )) )
        {
            //
            //  This column was not defined.  Report an error.
            //
            qutilDebugOut(( DEB_IERROR, "Column name %ws not found\n", wcsColumn.GetPointer() ));
            THROW( CException( QUERY_E_INVALID_OUTPUT_COLUMN ) );
        }

        pDbColId = (CDbColId *)pdbid;

        unsigned colNum = pDbCols->Count();
        for (unsigned i=0; i<colNum; i++)
        {
            if (pDbCols->Get(i) == *pDbColId)
                break;
        }

        if (i != colNum)
        {
            //
            //  This column is a duplicate of another, possibly an alias.
            //
            qutilDebugOut(( DEB_IERROR, "Column name %ws is duplicated\n", wcsColumn.GetPointer() ));
            THROW( CException( QUERY_E_DUPLICATE_OUTPUT_COLUMN ) );
        }
        pDbCols->Add( *pDbColId, colNum );


        //
        //  Add the output column to the list of replaceable parameters if needed.
        //
        if ( pVarSet )
        {
            Win4Assert( 0 != pawcsColumns );

            pVarSet->SetVariable( wcsColumn.GetPointer(), 0, 0);
            pawcsColumns->Add( wcsColumn.GetPointer(), colNum );
            wcsColumn.Acquire();
        }

        wcsColumn.Free();
        scan.AcceptColumn();        // Remove the column name

        //
        //  Skip over commas seperating output columns
        //
        if ( scan.LookAhead() == COMMA_TOKEN )
        {
            scan.Accept();          // Remove the ','
        }
        else if ( scan.LookAhead() != EOS_TOKEN )
        {
            THROW( CException( QPARSE_E_EXPECTING_COMMA ) );
        }
    }

    qutilDebugOut(( DEB_ITRACE, "%d columns added to CDbColumns\n", pDbCols->Count() ));

    //
    //  We must have exhausted the CiColumns line.  If not, there was a syntax
    //  error we couldn't parse.
    //
    if ( scan.LookAhead() != EOS_TOKEN )
    {
        //
        //  Contains a syntax error.  Report an error.
        //
        qutilDebugOut(( DEB_IWARN, "Syntax error in CiColumns= line\n" ));
        THROW( CException( QUERY_E_INVALID_OUTPUT_COLUMN ) );
    }

    return xDbCols.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseColumnsWithFriendlyNames
//
//  Synopsis:   Parses the columns string and leaves the friendly names
//              in the project list.
//
//  Arguments:  [wcsColumns] -  Columns names
//              [pList]      -  Property List
//              [pVarSet]    -  (not used) Variable Set - Optional
//
//  Returns:    The project list anchor of the tree.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

CDbProjectListAnchor * ParseColumnsWithFriendlyNames(
                WCHAR const * wcsColumns,
                IColumnMapper * pList,
                PVariableSet * pVarSet )
{
    CDbColumns * pDbCols = new CDbColumns( 0 );
    XPtr<CDbColumns> xDbCols(  pDbCols );

    XPtr<CDbProjectListAnchor> xDbColList(  new CDbProjectListAnchor() );

    if ( 0 == xDbCols.GetPointer() ||
         0 == xDbColList.GetPointer() )
    {
        THROW( CException(E_OUTOFMEMORY) );
    }

    CQueryScanner scan( wcsColumns, FALSE );

    for ( XPtrST<WCHAR> wcsColumn( scan.AcqColumn() );
          wcsColumn.GetPointer() != 0;
          wcsColumn.Set( scan.AcqColumn() )
        )
    {
        CDbColId  *pDbColId = 0;
        DBID *pdbid = 0;

        _wcsupr( wcsColumn.GetPointer() );

        if ( FAILED(pList->GetPropInfoFromName( wcsColumn.GetPointer(), &pdbid, 0, 0 )) )
        {
            //
            //  This column was not defined.  Report an error.
            //
            qutilDebugOut(( DEB_IERROR, "Column name %ws not found\n",
                                         wcsColumn.GetPointer() ));
            THROW( CException(QUERY_E_INVALID_OUTPUT_COLUMN) );
        }

        pDbColId = (CDbColId *)pdbid;

        unsigned colNum = pDbCols->Count();
        for (unsigned i=0; i<colNum; i++)
        {
            if (pDbCols->Get(i) == *pDbColId)
                break;
        }

        if (i != colNum)
        {
            //
            //  This column is a duplicate of another, possibly an alias.
            //
            qutilDebugOut(( DEB_IERROR, "Column name %ws is duplicated\n",
                                         wcsColumn.GetPointer() ));
            THROW( CException(QUERY_E_DUPLICATE_OUTPUT_COLUMN) );
        }
        pDbCols->Add( *pDbColId, colNum );
        if (! xDbColList->AppendListElement( *pDbColId,
                                             wcsColumn.GetPointer() ))
            THROW( CException(E_OUTOFMEMORY) );

        delete wcsColumn.Acquire();
        scan.AcceptColumn();              // Remove the column name

        //
        //  Skip over commas seperating output columns
        //
        if ( scan.LookAhead() == COMMA_TOKEN )
        {
            scan.Accept();          // Remove the ','
        }
        else if ( scan.LookAhead() != EOS_TOKEN )
        {
            THROW( CException(QPARSE_E_EXPECTING_COMMA ) );
        }
    }

    qutilDebugOut(( DEB_TRACE, "%d columns added to project list\n", pDbCols->Count() ));

    //
    //  We must have exhausted the CiColumns line.  If not, there was a syntax
    //  error we couldn't parse.
    //
    if ( scan.LookAhead() != EOS_TOKEN )
    {
        //
        //  Contains a syntax error.  Report an error.
        //
        qutilDebugOut(( DEB_IERROR, "Syntax error in CiColumns= line\n" ));
        THROW( CException(QUERY_E_INVALID_OUTPUT_COLUMN) );
    }

    return xDbColList.Acquire();
}
//+---------------------------------------------------------------------------
//
//  Member:     CTextToTree::FormFullTree
//
//  Synopsis:   Creates a full tree from the parameters given to the
//              construtor.
//
//  History:    3-04-97   srikants   Created
//
//----------------------------------------------------------------------------

DBCOMMANDTREE * CTextToTree::FormFullTree()
{
    XPtr<CDbProjectListAnchor> xDbProjectList;

    if ( _fKeepFriendlyNames )
    {
        //
        // Get the Project List Anchor for the string columns retaining the
        // friendly names.
        //
        xDbProjectList.Set(
            ParseColumnsWithFriendlyNames( _wcsColumns,
                                           _xPropList.GetPointer(),
                                           _pVariableSet ) );
    }
    else
    {
        //
        // Convert the textual form of the columns into DBColumns.
        //
        XPtr<CDbColumns>  xDbColumns;
        CDbColumns * pDbColumns = _pDbColumns;

        if ( 0 == pDbColumns )
        {
            xDbColumns.Set( ParseStringColumns( _wcsColumns,
                                                _xPropList.GetPointer(),
                                                _locale,
                                                _pVariableSet ) );
            pDbColumns = xDbColumns.GetPointer();
        }

        //
        //  Build the projection list from the column list.
        //
        xDbProjectList.Set( new CDbProjectListAnchor );
        if ( 0 == xDbProjectList.GetPointer() )
        {
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        for (unsigned i=0; i < pDbColumns->Count(); i++)
        {
            if (! xDbProjectList->AppendListElement( pDbColumns->Get(i) ))
            {
                THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
            }
        }
    }

    //
    // Convert the textual form of the sort columns into CDbSortNode.
    //
    XPtr<CDbSortNode>  xDbSortNode;
    if ( 0 != _wcsSort )
        xDbSortNode.Set( GetStringDbSortNode( _wcsSort, _xPropList.GetPointer(), _locale ) );

    XPtr<CDbNestingNode>  xDbNestingNode;
    if ( 0 != _wcsGroup )
    {
        CQueryScanner scanner( _wcsGroup, FALSE, _locale, TRUE );
        CParseGrouping ParseGrouping( scanner, _xPropList.GetPointer(), _fKeepFriendlyNames );
        ParseGrouping.Parse();

        if ( 0 != _wcsSort )
            ParseGrouping.AddSortList( xDbSortNode );

        xDbNestingNode.Set( ParseGrouping.AcquireNode() );
    }

    qutilDebugOut(( DEB_TRACE, "ExecuteQuery:\n" ));
    qutilDebugOut(( DEB_TRACE, "\tCiRestriction = '%ws'\n", _wcsRestriction ));

    XPtr<CDbCmdTreeNode> xDbCmdTreeNode;

    // Use a restriction if one was already passed in
    if (0 != _pDbCmdTree)
    {
        Win4Assert(0 == _wcsRestriction);
        xDbCmdTreeNode.Set((CDbCmdTreeNode *)CDbCmdTreeNode::CastFromStruct(_pDbCmdTree));
    }
    else
    {
        Win4Assert(_wcsRestriction);

        xDbCmdTreeNode.Set( GetStringDbRestriction( _wcsRestriction,
                                                    _ulDialect,
                                                    _xPropList.GetPointer(),
                                                    _locale ) );
    }
    
    //
    //  Now form the query tree from the restriction, sort set, and
    //  projection list.
    //

    CDbCmdTreeNode *pDbCmdTree = FormDbQueryTree( xDbCmdTreeNode,
                                                  xDbSortNode,
                                                  xDbProjectList,
                                                  xDbNestingNode,
                                                  _maxRecs,
                                                  _cFirstRows );

    return pDbCmdTree->CastToStruct();
} //FormFullTree
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\strsort.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996-1997, Microsoft Corporation.
//
//  File:       strsort.cxx
//
//  Contents:   Builds a sort node from a string
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   GetStringDbSortNode - public
//
//  Synopsis:   Builds a CDbSortNode from the string passed
//
//  Arguments:  [wcsSort] - the string containing the sort specification
//              [pList]   - the property list describing the sort DBTYPES
//
//  Notes:      CPListException is used instead of CParserException so the
//              error class will be IDQError, not RESError in idq.dll.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CDbSortNode * GetStringDbSortNode( const WCHAR * wcsSort,
                                   IColumnMapper * pList,
                                   LCID locale)
{
    Win4Assert( 0 != wcsSort );

    unsigned cSortCol = 0;
    CDbSortNode * pDbSortNode = new CDbSortNode();
    if ( 0 == pDbSortNode )
    {
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    XPtr<CDbSortNode> xDbSortNode(pDbSortNode);

    CQueryScanner scanner( wcsSort, FALSE, locale );

    for ( XPtrST<WCHAR> wcsColumnName( scanner.AcqColumn() );
          wcsColumnName.GetPointer() != 0;
          wcsColumnName.Set( scanner.AcqColumn() )
        )
    {
        scanner.AcceptColumn();                 // Remove the column name

        //
        //  Parse for the [a] or [d] parameters.
        //
        unsigned order = QUERY_SORTASCEND;      // Assume ascending sort order

        if ( scanner.LookAhead() == W_OPEN_TOKEN )
        {
            scanner.Accept();                   // Remove the '['

            WCHAR wchOrder = scanner.GetCommandChar();

            if ( wchOrder == L'a' )
            {
                order = QUERY_SORTASCEND;
            }
            else if ( wchOrder == L'd' )
            {
                order = QUERY_SORTDESCEND;
            }
            else
            {
                // Report an error
                THROW( CPListException(QPARSE_E_INVALID_SORT_ORDER, 0) );
            }

            WCHAR wchNext = scanner.GetCommandChar();
            if (wchNext != 0 && !iswspace(wchNext))
                // some alphabetic character followed the '[a' or '[d'.
                THROW( CPListException(QPARSE_E_INVALID_SORT_ORDER, 0) );

            scanner.AcceptCommand();   // Remove the command character

            if ( scanner.LookAhead() != W_CLOSE_TOKEN )
            {
                // Report an error
                THROW( CPListException(QPARSE_E_EXPECTING_BRACE, 0) );
            }

            scanner.Accept();          // Remove the ']' character
        }

        //
        //  Build a CDbSortKey with the parameters obtained.
        //
        CDbColId  *pDbColId = 0;
        DBID *pdbid = 0;
        if ( FAILED(pList->GetPropInfoFromName( wcsColumnName.GetPointer(), &pdbid, 0, 0 )) )
        {
            //
            //  Column name not found.
            //
            THROW( CPListException(QPARSE_E_NO_SUCH_SORT_PROPERTY, 0) );
        }
        pDbColId = (CDbColId *)pdbid;

        CDbSortKey sortKey( *pDbColId, order, locale);

        //
        //  Add the new sort key to the tree of sort nodes.
        //
        if ( !pDbSortNode->AddSortColumn(sortKey) )
        {
            //  Report a failure.
            THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
        }

        delete wcsColumnName.Acquire();

        //
        //  Skip over commas seperating sort columns
        //
        if ( scanner.LookAhead() == COMMA_TOKEN )
        {
            scanner.Accept();          // Remove the ','
        }
        else if (scanner.LookAhead() != EOS_TOKEN)
        {
            THROW( CPListException(QPARSE_E_EXPECTING_COMMA, 0) );
        }

        cSortCol++;
    }

    if (scanner.LookAhead() != EOS_TOKEN)
    {
        if (cSortCol > 0)
        {
            THROW( CPListException(QPARSE_E_NO_SUCH_SORT_PROPERTY, 0) );
        }
        else
        {
            THROW( CPListException(QPARSE_E_EXPECTING_EOS, 0) );
        }
    }

    return xDbSortNode.Acquire();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\tplist.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       tplist.cxx
//
//  Contents:   Builds the perfect hash table in plist.cxx
//
//  History:    05-Sep-97 KyleP   Added header
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

WCHAR * apwc[] =
{
  L"DIRECTORY",
  L"CLASSID",
  L"FILEINDEX",
  L"USN",
  L"FILENAME",
  L"PATH",
  L"SIZE",
  L"ATTRIB",
  L"WRITE",
  L"CREATE",
  L"ACCESS",
  L"ALLOCSIZE",
  L"CONTENTS",
  L"SHORTFILENAME",
  L"RANKVECTOR",
  L"RANK",
  L"HITCOUNT",
  L"WORKID",
  L"ALL",
  L"VPATH",
  L"DOCTITLE",
  L"DOCSUBJECT",
  L"DOCAUTHOR",
  L"DOCKEYWORDS",
  L"DOCCOMMENTS",
  L"DOCTEMPLATE",
  L"DOCLASTAUTHOR",
  L"DOCREVNUMBER",
  L"DOCEDITTIME",
  L"DOCLASTPRINTED",
  L"DOCCREATEDTM",
  L"DOCLASTSAVEDTM",
  L"DOCPAGECOUNT",
  L"DOCWORDCOUNT",
  L"DOCCHARCOUNT",
  L"DOCTHUMBNAIL",
  L"DOCAPPNAME",
  L"DOCSECURITY",
  L"DOCCATEGORY",
  L"DOCPRESENTATIONTARGET",
  L"DOCBYTECOUNT",
  L"DOCLINECOUNT",
  L"DOCPARACOUNT",
  L"DOCSLIDECOUNT",
  L"DOCNOTECOUNT",
  L"DOCHIDDENCOUNT",
  L"DOCPARTTITLES",
  L"DOCMANAGER",
  L"DOCCOMPANY",
  L"HTMLHREF",
  L"A_HREF",
  L"IMG_ALT",
  L"HTMLHEADING1",
  L"HTMLHEADING2",
  L"HTMLHEADING3",
  L"HTMLHEADING4",
  L"HTMLHEADING5",
  L"HTMLHEADING6",
  L"CHARACTERIZATION",
  L"NEWSGROUP",
  L"NEWSGROUPS",
  L"NEWSREFERENCES",
  L"NEWSSUBJECT",
  L"NEWSFROM",
  L"NEWSMSGID",
  L"NEWSDATE",
  L"NEWSRECEIVEDDATE",
  L"NEWSARTICLEID",
  L"MSGNEWSGROUP",
  L"MSGNEWSGROUPS",
  L"MSGREFERENCES",
  L"MSGSUBJECT",
  L"MSGFROM",
  L"MSGMESSAGEID",
  L"MSGDATE",
  L"MSGRECEIVEDDATE",
  L"MSGARTICLEID",
  L"MEDIAEDITOR",
  L"MEDIASUPPLIER",
  L"MEDIASOURCE",
  L"MEDIASEQUENCE_NO",
  L"MEDIAPROJECT",
  L"MEDIASTATUS",
  L"MEDIAOWNER",
  L"MEDIARATING",
  L"MEDIAPRODUCTION",
  L"MUSICARTIST",
  L"MUSICSONGTITLE",
  L"MUSICALBUM",
  L"MUSICYEAR",
  L"MUSICCOMMENT",
  L"MUSICTRACK",
  L"MUSICGENRE",
  L"DRMLICENSE",  
  L"DRMDESCRIPTION",
  L"DRMPLAYCOUNT",
  L"DRMPLAYSTARTS",
  L"DRMPLAYEXPIRES",
  L"IMAGEFILETYPE",
  L"IMAGECX",
  L"IMAGECY",
  L"IMAGERESOLUTIONX",
  L"IMAGERESOLUTIONY",
  L"IMAGEBITDEPTH",
  L"IMAGECOLORSPACE",
  L"IMAGECOMPRESSION",
  L"IMAGETRANSPARENCY",
  L"IMAGEGAMMAVALUE",
  L"IMAGEFRAMECOUNT",
  L"IMAGEDIMENSIONS",
  L"AUDIOFORMAT",
  L"AUDIOTIMELENGTH",
  L"AUDIOAVGDATARATE",
  L"AUDIOSAMPLERATE",
  L"AUDIOSAMPLESIZE",
  L"AUDIOCHANNELCOUNT",
  L"VIDEOSTREAMNAME",
  L"VIDEOFRAMEWIDTH",
  L"VIDEOFRAMEHEIGHT",
  L"VIDEOTIMELENGTH",
  L"VIDEOFRAMECOUNT",
  L"VIDEOFRAMERATE",
  L"VIDEODATARATE",
  L"VIDEOSAMPLESIZE",
  L"VIDEOCOMPRESSION",
};

BOOL IsPrime( ULONG ul )
{
    unsigned ulStop = (ul + 1)/2;

    for ( unsigned i = 2; i <= ulStop && 0 != (ul % i); i++ )
        continue;

    return (i > ulStop);
}


ULONG Hash0( WCHAR const * pc ) //846
{
    unsigned ulH,ulG;

    for (ulH=0; *pc; pc++)
    {
        ulH = (ulH << 4) + (*pc);
        if (ulG = (ulH & 0xf0000000))
            ulH ^= ulG >> 24;
        ulH &= ~ulG;
    }

    return ulH;
}

ULONG Hash1( WCHAR const * pwcName ) //541
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = 0;

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

ULONG Hash2( WCHAR const * pwcName ) //443
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = *pwcName++;
    ulHash <<= 6;

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

ULONG Hash3( WCHAR const * pwcName ) //664
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = *pwcName++;
    ulHash <<= 7;

    if ( 0 != *pwcName )
    {
        ulHash += *pwcName++;
        ulHash <<= 7;
    }

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

ULONG Hash4( WCHAR const * pwcName ) //345
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = *pwcName++;
    ulHash <<= 5;

    while ( 0 != *pwcName )
    {
        ulHash <<= 2;
        ulHash += *pwcName++;
    }

    ulHash <<= 2;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

ULONG Hash5( WCHAR const * pwcName ) //645 with '4',  558 with '6'
{
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = *pwcName++;
    ulHash <<= 6;

    while ( 0 != *pwcName )
    {
        ulHash <<= 2;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 2;
    ulHash += ( pwcName - pwcStart );

    return ulHash;
}

typedef ULONG (* HFun)( WCHAR const * );

HFun aHashFun[] = { Hash0, Hash1, Hash2, Hash3, Hash4, Hash5 };

void __cdecl main()
{
    const cStrings = sizeof apwc / sizeof apwc[0];
    ULONG a[2000];

    ULONG ulSmallest = 0xFFFFFFFF;
    ULONG iHFSmallest = 0;

    for ( unsigned iHFun = 0; iHFun < sizeof(aHashFun)/sizeof(aHashFun[0]); iHFun++ )
    {
        HFun hf = aHashFun[iHFun];

        for ( ULONG size = cStrings; size < sizeof a / sizeof a[0]; size++ )
        {
            //if ( !IsPrime(size) )
            //      continue;

            BOOL fOK = TRUE;
            RtlZeroMemory( a, sizeof a );

            for ( ULONG x = 0; x < cStrings; x++ )
            {
                unsigned h = (*hf)( apwc[x] ) % size;
                //printf( "%d '%ws'\n", h, apwc[x] );
                if ( 0 != a[h] )
                {
                    //printf( " %d fail\n", size );
                    fOK = FALSE;

                    break;
                }

                a[h] = 1 + x;
            }

            if ( fOK )
            {

#if 0
                printf( "Hash Function %d: %d worked for %d strings\n", iHFun, size, cStrings );

                //
                // Print out
                //

                for ( ULONG i = 0; i < size; i++ )
                {
                    unsigned index = a[i] - 1;
                    if ( 0 == a[i] )
                        printf( "    0,    // %d\n", i );
                    else
                        printf( "    (CPropEntry *) &aStaticList[%d],    // %d '%ws'\n",
                        index, i, apwc[index] );
                }
#endif

                if ( size < ulSmallest )
                {
                    ulSmallest = size;
                    iHFSmallest = iHFun;
                }

                break;
            }
        }
    }

    if ( ulSmallest != 0xFFFFFFFF )
    {
        printf( "Hash Function #%d: %d worked for %d strings\n", iHFSmallest, ulSmallest, cStrings );

        //
        // Recompute hash
        //

        RtlZeroMemory( a, sizeof a );

        for ( ULONG x = 0; x < cStrings; x++ )
        {
            unsigned h = (*aHashFun[iHFSmallest])( apwc[x] ) % ulSmallest;

            a[h] = 1 + x;
        }

        //
        // Print out
        //

        for ( ULONG i = 0; i < ulSmallest; i++ )
        {
            unsigned index = a[i] - 1;
            if ( 0 == a[i] )
                printf( "    0,    // %d\n", i );
            else
                printf( "    (CPropEntry *) &aStaticList[%d],    // %d '%ws'\n",
                index, i, apwc[index] );
        }
    }
    else
        printf( "no perfect hash!\n" );
} //main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.
//
//  File:   util.cxx
//
//  Contents:   global utilities and data for Content Index Test 'Q'
//
//  History:    27-Dec-94   dlee       Created from pieces of Q
//              18-Jan-95   t-colinb   Added suppport for COMMAND_GETLASTQUERY_FAILED
//              02-Mar-95   t-colinb   Removed unnecessary IMPLEMENT_UNWIND
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <dberror.hxx> // for IsCIError function
#include <vqdebug.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   OpenFileFromPath
//
//  Synopsis:   Searches the current path for the specified file and
//              opens it for reading.
//
//  Arguments:  [wcsFile] -- filename to open
//
//  History:    17-Jun-94   t-jeffc     Created
//
//----------------------------------------------------------------------------

FILE * OpenFileFromPath( WCHAR const * wcsFile )
{
    unsigned int cwcPath = 256;

    XArray<WCHAR> wcsPath( cwcPath );
    WCHAR * wcsFilePart;

    for( ;; )
    {
        DWORD rc = SearchPath( NULL,
                               wcsFile,
                               NULL,
                               cwcPath,
                               wcsPath.GetPointer(),
                               &wcsFilePart );

        if( rc == 0 )
            return NULL;
        else if( rc >= cwcPath )
        {
            delete [] wcsPath.Acquire();
            cwcPath = rc + 1;
            wcsPath.Init( cwcPath );
        }
        else
            break;
    }

    return _wfopen( wcsPath.GetPointer(), L"r" );
}

//-----------------------------------------------------------------------------
//
//  Function:   GetOleDBErrorInfo
//
//  Synopsis:   Retrieves the secondary error from Ole DB error object
//
//  Arguments:  [pErrSrc]      - Pointer to object that posted the error.
//              [riid]         - Interface that posted the error.
//              [lcid]         - Locale in which the text is desired.
//              [pErrorInfo]   - Pointer to memory where ERRORINFO should be.
//              [ppIErrorInfo] - Holds the returning IErrorInfo. Caller should
//                               release this.
//
//  Notes: The caller should use the contents of *ppIErrorInfo only if the return
//         is >= 0 (SUCCEEDED(return value)) AND *ppIErrorInfo is not NULL.
//
//  History:    05 May 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------


SCODE GetOleDBErrorInfo(IUnknown *pErrSrc,
                        REFIID riid,
                        LCID lcid,
                        unsigned eDesiredDetail,
                        ERRORINFO *pErrorInfo,
                        IErrorInfo **ppIErrorInfo)
{
    if (0 == pErrSrc || 0 == pErrorInfo || 0 == ppIErrorInfo)
        return E_INVALIDARG;
    *ppIErrorInfo = 0;

    SCODE sc = S_OK;
    XInterface<ISupportErrorInfo> xSupportErrorInfo;

    sc = pErrSrc->QueryInterface(IID_ISupportErrorInfo, xSupportErrorInfo.GetQIPointer());
    if (FAILED(sc))
        return sc;

    sc = xSupportErrorInfo->InterfaceSupportsErrorInfo(riid);
    if (FAILED(sc))
        return sc;

    //
    // Get the current error object. Return if none exists.
    //

    XInterface<IErrorInfo> xErrorInfo;

    sc = GetErrorInfo(0, (IErrorInfo **)xErrorInfo.GetQIPointer());
    if ( 0 == xErrorInfo.GetPointer() )
        return sc;

    //
    // Get the IErrorRecord interface and get the count of errors.
    //

    XInterface<IErrorRecords> xErrorRecords;

    sc = xErrorInfo->QueryInterface(IID_IErrorRecords, xErrorRecords.GetQIPointer());
    if (FAILED(sc))
        return sc;

    ULONG cErrRecords;
    sc = xErrorRecords->GetRecordCount(&cErrRecords);
    if (0 == cErrRecords)
        return sc;

    //
    // We will first look for what the user desires.
    // If we can't find what they desire, then we
    // return the closest we can.
    //

    ULONG ulRecord = 0;
    long i; // This has to be signed to keep the loop test simple

    switch (eDesiredDetail)
    {
        case eMostGeneric:
            ulRecord = 0;
            break;


        case eDontCare:
        case eMostDetailed:
            ulRecord = cErrRecords - 1;
            break;

        case eMostDetailedOleDBError:
            // Find the last (starting from 0) non-CI error
            ulRecord = cErrRecords - 1;
            for (i = (long) cErrRecords - 1; i >= 0  ; i--)
            {
                xErrorRecords->GetBasicErrorInfo(i, pErrorInfo);
                // if it not a CI error, it is a Ole DB error
                if (!IsCIError(pErrorInfo->hrError))
                {
                    ulRecord = i;
                    break;
                }
            }
            break;

        case eMostDetailedCIError:
            // Find the last (starting from 0) non-CI error
            ulRecord = cErrRecords - 1;
            for (i = (long) cErrRecords - 1; i >= 0  ; i--)
            {
                xErrorRecords->GetBasicErrorInfo(i, pErrorInfo);
                if (IsCIError(pErrorInfo->hrError))
                {
                    ulRecord = i;
                    break;
                }
            }
            break;

        case eMostGenericOleDBError:
            // Find the first (starting from 0) non-CI error
            ulRecord = 0;
            for (i = 0; i < (long)cErrRecords; i++)
            {
                xErrorRecords->GetBasicErrorInfo(i, pErrorInfo);
                // if it not a CI error, it is a Ole DB error
                if (!IsCIError(pErrorInfo->hrError))
                {
                    ulRecord = i;
                    break;
                }
            }
            break;

        case eMostGenericCIError:
            // Find the first (starting from 0) non-CI error
            ulRecord = 0;
            for (i = 0; i < (long)cErrRecords; i++)
            {
                xErrorRecords->GetBasicErrorInfo(i, pErrorInfo);
                // if it not a CI error, it is a Ole DB error
                if (IsCIError(pErrorInfo->hrError))
                {
                    ulRecord = i;
                    break;
                }
            }
            break;

        default:
            Win4Assert(!"Unrecognized error detail option!");
            ulRecord = 0;
            break;
    }

    // Get basic error information
    Win4Assert( ulRecord < cErrRecords );
    sc = xErrorRecords->GetBasicErrorInfo(ulRecord, pErrorInfo);
    Win4Assert(sc != DB_E_BADRECORDNUM);
    sc = xErrorRecords->GetErrorInfo(ulRecord, lcid, ppIErrorInfo);
    Win4Assert(sc != DB_E_BADRECORDNUM);

#if CIDBG
    //
    // Get error description and source through the IErrorInfo
    // interface pointer on a particular record.
    //

    BSTR bstrErrorDescription = 0;
    BSTR bstrErrorSource = 0;

    (*ppIErrorInfo)->GetDescription(&bstrErrorDescription);
    (*ppIErrorInfo)->GetSource(&bstrErrorSource);

    //
    // At this point we could call GetCustomErrorObject and query for additional
    // interfaces to determine what else happened. Currently no custom errors are
    // supported, so nothing to do.
    //

    if (bstrErrorSource && bstrErrorDescription)
    {
        WCHAR wszBuff[1024];

        swprintf(wszBuff, L"HRESULT: %lx, Minor Code: %lu, Source: %ws\nDescription: %ws\n",
                 pErrorInfo->hrError, pErrorInfo->dwMinor, bstrErrorSource, bstrErrorDescription);
        vqDebugOut((DEB_IERROR, "%ws", wszBuff));
    }

    //
    // Free the resources
    //

    SysFreeString(bstrErrorDescription);
    SysFreeString(bstrErrorSource);
#endif // CIDBG

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\wcstoi64.cxx ===
/***
*wcstoi64.c - Contains C runtimes wcstoi64 and wcstoui64
*
*       Copyright (c) 1989-1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       wcstol - convert wchar_t string to long signed integer
*       wcstoul - convert wchar_t string to long unsigned integer
*
*Revision History:
*
*******************************************************************************/

#include <pch.cxx>
#pragma hdrstop

#include <errno.h>

/***
*wcstol, wcstoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 64-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*               (a) First char = '0', second char = 'x' or 'X',
*                   use base 16.
*               (b) First char = '0', use base 8
*               (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then wcstol/wcstoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               wcstol -- _I64_MAX or _I64_MIN
*               wcstoul -- _UI64_MAX
*               wcstol/wcstoul -- errno == ERANGE
*
*       No digits or bad base return:
*               0
*               endptr = nptr*
*
*Exceptions:
*       None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static
unsigned _int64
wcstoxi64 (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase,
        int flags
        )
{
        const wchar_t *p;
        wchar_t c;
        unsigned _int64 number;
        unsigned digval;
        unsigned _int64 maxval;

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while (iswspace(c))
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = (wchar_t *) nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != L'0')
                        ibase = 10;
                else if (*p == L'x' || *p == L'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == L'0' && (*p == L'x' || *p == L'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = _UI64_MAX / ibase;

        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if (iswdigit(c))
                        digval = c - L'0';
                else if (iswalpha(c))
                        digval = towupper(c) - L'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned _int64)digval <= _UI64_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -_I64_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > _I64_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                errno = ERANGE;
                if ( flags & FL_UNSIGNED )
                        number = _UI64_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned _int64)(-_I64_MIN);
                else
                        number = _I64_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = (wchar_t *) p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned _int64)(-(_int64)number);

        return number;                  /* done. */
}

_int64 __cdecl _wcstoi64 (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return (_int64) wcstoxi64(nptr, endptr, ibase, 0);
}

unsigned _int64 __cdecl _wcstoui64 (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return wcstoxi64(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\triplish\flexcpp.h ===
//----------------------------------------------------------------------------
// Flexcpp.h -- define interfaces for lexical analyzer classes generated
//                by flex
// Copyright (c) 1993 The Regents of the University of California.
// All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Kent Williams and Tom Epperly.
//
// Redistribution and use in source and binary forms are permitted provided
// that: (1) source distributions retain this entire copyright notice and
// comment, and (2) distributions including binaries display the following
// acknowledgement:  ``This product includes software developed by the
// University of California, Berkeley and its contributors'' in the
// documentation or other materials provided with the distribution and in
// all advertising materials mentioning features or use of this software.
// Neither the name of the University nor the names of its contributors may
// be used to endorse or promote products derived from this software without
// specific prior written permission.
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

// This file defines FlexLexer, an abstract class which specifies the
// external interface provided to flex C++ lexer objects, and YYLEXER,
// which defines a particular lexer class.
//
// If you want to create multiple lexer classes, you use the -P flag
// to rename each YYLEXER to some other xxFlexLexer.  You then
// include <FlexLexer.h> in your other sources once per lexer class:
//
//      #undef YYLEXER
//      #define YYLEXER xxFlexLexer
//      #include <FlexLexer.h>
//
//      #undef YYLEXER
//      #define YYLEXER zzFlexLexer
//      #include <FlexLexer.h>
//      ...
//
// History:    10-Oct-97   emilyb   ported from Monarch SQL code
//
//----------------------------------------------------------------------------

#ifndef __FLEX_LEXER_H
// Never included before - need to define base class.
#define __FLEX_LEXER_H

#ifndef YY_CHAR
#define YY_CHAR WCHAR
#endif

DECLARE_DEBUG(yacc)

#if CIDBG

#define yaccDebugOut(x) yaccInlineDebugOut x
#define yaccAssert(x)   Win4Assert x
#define yaccDebugStr(x) yaccInlineDebugOut x

#else // CIDBG

#define yaccDebugStr(x)
#define yaccDebugOut(x)
#define yaccAssert(x)

#endif // CIDBG

// extern "C++" {

struct yy_buffer_state;
typedef int yy_state_type;

class FlexLexer {
public:
   // virtual ~FlexLexer() = 0;

        const YY_CHAR* YYText() { return yytext; }
        int YYLeng()            { return yyleng; }

        virtual void
                yy_switch_to_buffer( struct yy_buffer_state* new_buffer ) = 0;
        virtual struct yy_buffer_state*
                yy_create_buffer( int size ) = 0;
        virtual void yy_delete_buffer( struct yy_buffer_state* b ) = 0;
        virtual void yyrestart( ) = 0;

        virtual int yylex(YYSTYPE *yylval) = 0;

        int lineno() const              { return yylineno; }

        int debug() const               { return yy_flex_debug; }
        void set_debug( int flag )      { yy_flex_debug = flag; }

protected:
        YY_CHAR* yytext;
        int yyleng;
        int yylineno;           // only maintained if you use %option yylineno
        int yy_flex_debug;      // only has effect with -d or "%option debug"
};

// }
#endif

#if defined(YYLEXER) || ! defined(yyFlexLexerOnce)
// Either this is the first time through (yyFlexLexerOnce not defined),
// or this is a repeated include to define a different flavor of
// YYLEXER, as discussed in the flex man page.
#define yyFlexLexerOnce

class YYPARSER; // forward declaration

class YYLEXER : public FlexLexer {
public:
        // arg_yyin and arg_yyout default to the cin and cout, but we
        // only make that assignment when initializing in yylex().
        YYLEXER();
        virtual ~YYLEXER();

        void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
        struct yy_buffer_state* yy_create_buffer(  int size );
        void yy_delete_buffer( struct yy_buffer_state* b );
        void yyrestart( );

        int yylex(YYSTYPE *yylval);

        void yyprimebuffer(const YY_CHAR *pszBuffer);
        int yybufferinput(YY_CHAR *pszBuffer, int cMax);
        CCountedDynArray<WCHAR> _allocations;

protected:
        virtual int LexerInput( YY_CHAR* buf, int max_size );
        virtual void LexerOutput( const YY_CHAR* buf, int size );
        virtual void LexerError( const YY_CHAR* msg );
#ifdef DEBUG
        virtual void LexerTrace(const YY_CHAR* buf, int size, int tknNum);
#endif

        void yyunput( int c, YY_CHAR* buf_ptr );
        int yyinput();

        void ResetLexer();
        short CreateTknValue(YYSTYPE *ppStg, short tknNum, BOOL fLong, BOOL fQuote);
        short DetermineTokenType();
        BOOL  IsTokenEmpty();
        BOOL  IsNotOperator();
        void yy_load_buffer_state();
        void yy_init_buffer( struct yy_buffer_state* b );
        void yy_flush_buffer( struct yy_buffer_state* b );

        int yy_start_stack_ptr;
        int yy_start_stack_depth;
        int* yy_start_stack;

        void yy_push_state( int new_state );
        void yy_pop_state();
        int yy_top_state();

        yy_state_type yy_get_previous_state();
        yy_state_type yy_try_NUL_trans( yy_state_type current_state );
        int yy_get_next_buffer();

        //istream* yyin;  // input source for default LexerInput
        //ostream* yyout; // output sink for default LexerOutput

        struct yy_buffer_state* yy_current_buffer;

        // yy_hold_char holds the character lost when yytext is formed.
        YY_CHAR yy_hold_char;

        // Number of characters read into yy_ch_buf.
        int yy_n_chars;

        // Points to current character in buffer.
        YY_CHAR* yy_c_buf_p;
        YY_CHAR *pCurBuffer, *pszInputBuffer;
        int cInputBuffer;

        int yy_init;            // whether we need to initialize
        int yy_start;           // start state number
        int yyprimetoken;       // priming token

        // Flag which is used to allow yywrap()'s to do buffer switches
        // instead of setting up a fresh yyin.  A bit of a hack ...
        int yy_did_buffer_switch_on_eof;

        // The following are not always needed, but may be depending
        // on use of certain flex features (like REJECT or yymore()).

        yy_state_type yy_last_accepting_state;
        YY_CHAR* yy_last_accepting_cpos;

        yy_state_type* yy_state_buf;
        yy_state_type* yy_state_ptr;

        YY_CHAR* yy_full_match;
        int* yy_full_state;
        int yy_full_lp;

        int yy_lp;
        int yy_looking_for_trail_begin;

        int yy_more_flag;
        int yy_more_len;
        int yy_more_offset;
        int yy_prev_more_offset;

        BOOL fContinueImplicitPhrase;
        BOOL fContinueRegex;
        BOOL fContinueMaybeRegex;
        BOOL fTreatFreetextAsPhrase;
#ifdef DEBUG
        int tkndebug;
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\triplish\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    makefile.inc.

!ENDIF

lex.cxx: parser.l parser.y flexcpp.h flexcpp.skl
    -attrib -r lex.cxx 2>nul
    -del lex.cxx 2>nul
    flex -Sflexcpp.skl -+ -B -L -olex.cxx parser.l

trparse.cxx parser.h: parser.y
    kbyacc -f triplish -d -l -b parser -p trip -c CTripYYBase "(IColumnMapper & ColumnMapper, LCID & locale, YYLEXER & yylex)" parser.y
    attrib -r trparse.cxx 2>nul
    attrib -r parser.h 2>nul
    -del trparse.cxx
    -del parser.h
    -ren parser.tab.c trparse.cxx
    -ren parser.tab.h parser.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\triplish\parsepl.h ===
#ifndef _STUFF_H_INC
#define _STUFF_H_INC

//package is in use
#define YYAPI_PACKAGE               1 						// package is in use
#define YYAPI_TOKENNAME             yychar                 	
#define YYAPI_TOKENTYPE             int                     
#define YYAPI_TOKENNONE             -2                       
#define YYAPI_VALUENAME             yylval   
#define YYAPI_VALUETYPE             YYSTYPE 
#define YYLEX       					   _yylex.yylex
#define YYPARSEPROTO  
#undef  YYPARSER
#define YYPARSER						   TripParser
#undef  YYLEXER
#define YYLEXER							TripLexer
#undef  YY_CHAR	
#define YY_CHAR							WCHAR


#ifndef YYERROR_VERBOSE
#define YYERROR_VERBOSE                        1
#endif


#endif /* _STUFF_H_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\triplish\lex.cxx ===
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#include <pch.cxx>
#pragma hdrstop

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5



/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifndef YY_CHAR
#define YY_CHAR WCHAR
#endif

#ifdef __cplusplus

#include <stdlib.h>
  //class istream;

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed YY_CHAR to an unsigned
 * integer for use as an array index.  If the signed YY_CHAR is negative,
 * we want to instead treat it as an 8-bit unsigned YY_CHAR, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (YY_CHAR) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 32767       // UNDONE:  Should really just take the input from the bstr passed in

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *      if ( condition_holds )
 *              yyless( 5 );
 *      else
 *              do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                *yy_cp = yy_hold_char; \
                YY_RESTORE_YY_MORE_OFFSET \
                yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
                YY_DO_BEFORE_ACTION; /* set up yytext again */ \
                } \
        while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
        {
        YY_CHAR *yy_ch_buf;             /* input buffer */
        YY_CHAR *yy_buf_pos;            /* current position in input buffer */

        /* Size of input buffer in bytes, not including room for EOB
         * characters.
         */
        yy_size_t yy_buf_size;

        /* Number of characters read into yy_ch_buf, not including EOB
         * characters.
         */
        int yy_n_chars;

        /* Whether we "own" the buffer - i.e., we know we created it,
         * and can realloc() it to grow it, and should free() it to
         * delete it.
         */
        int yy_is_our_buffer;

        /* Whether this is an "interactive" input source; if so, and
         * if we're using stdio for input, then we want to use getc()
         * instead of fread(), to make sure we stop fetching input after
         * each newline.
         */
        int yy_is_interactive;

        /* Whether we're considered to be at the beginning of a line.
         * If so, '^' rules will be active on the next match, otherwise
         * not.
         */
        int yy_at_bol;

        /* Whether to try to fill the input buffer when we reach the
         * end of it.
         */
        int yy_fill_buffer;

        int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
        /* When an EOF's been seen but there's still some text to process
         * then we mark the buffer as YY_EOF_PENDING, to indicate that we
         * shouldn't try reading from the input source any more.  We might
         * still have a bunch of tokens to match, though, because of
         * possible backing-up.
         *
         * When we actually see the EOF, we change the status to "new"
         * (via yyrestart()), so that the user can continue scanning by
         * just pointing yyin at a new input file.
         */
#define YY_BUFFER_EOF_PENDING 2
        };


/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer



static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( YY_BUF_SIZE ); \
        yy_current_buffer->yy_is_interactive = is_interactive; \
        }

#define yy_set_bol(at_bol) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( YY_BUF_SIZE ); \
        yy_current_buffer->yy_at_bol = at_bol; \
        }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

#define yytext_ptr yytext


/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
        yytext_ptr = yy_bp; \
	yytext_ptr -= yy_more_len; \
	yyleng = (int) (yy_cp - yytext_ptr); \
        yy_hold_char = *yy_cp; \
        *yy_cp = '\0'; \
        yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 172
#define YY_END_OF_BUFFER 173
static yyconst short int yy_accept[804] =
    {   0,
        0,    0,    0,    0,    0,    0,  138,  138,  151,  151,
        0,    0,    0,    0,    0,    0,  173,   87,    1,    1,
       20,  172,  172,  172,   18,    2,    3,  172,   24,   28,
       25,  172,   87,   87,   87,   87,  172,  172,   19,   23,
       90,   91,  172,  172,   97,  123,  138,  124,  132,  138,
      133,  130,  134,  135,  125,  138,  138,  138,  136,  131,
      151,  148,  144,  151,  152,  142,  145,  146,  151,  151,
      151,  147,  143,  171,  154,  162,  171,  168,  160,  164,
      165,  169,  171,  171,  171,  171,  166,  163,  161,  121,
      104,  172,  113,  116,  117,  121,  121,  121,  118,  114,

      115,  172,   98,   98,  172,  103,   99,   87,   86,    1,
        1,    1,   29,    0,   81,   75,    0,    7,    0,    0,
        0,    0,    0,   26,    0,    0,    0,    0,   27,    0,
        5,    0,   87,   87,   87,   87,   87,    0,   30,   31,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   90,
        0,    0,  122,  138,  137,    0,  124,  138,  137,    0,
      126,    0,  138,  138,  138,  138,  138,  151,  150,    0,
      148,  151,  150,    0,  149,    0,  151,  151,  151,  151,
      151,  171,  170,  154,  171,  170,    0,  153,  171,  171,
      171,  171,  171,  121,  120,  104,    0,  121,  121,  121,

        0,    0,  102,  101,   98,   98,    0,  100,    0,    0,
       80,    0,    0,   89,    0,    0,    0,   89,    0,    0,
       32,   54,   40,    0,    0,   48,   34,    0,   87,   87,
       87,   87,   14,   15,    0,    0,    0,    0,   47,   55,
       49,    0,    0,    0,   33,   41,   35,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,  126,  138,  138,  138,  138,  128,  138,  149,
      151,  151,  151,  151,  140,  151,  153,  171,  171,  171,
      171,  156,  119,  121,  121,  107,  108,    0,   56,   42,
       74,    6,    0,   88,    0,   50,   36,   52,   38,    4,

       12,   13,   87,   87,   16,   17,   14,   46,   57,   51,
       53,   58,   59,   43,   37,   39,   44,   45,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   62,
        0,    0,    0,  138,  127,  129,  151,  139,  141,  155,
      171,  171,  159,  105,  106,  121,    0,    0,   88,   12,
       87,   21,   22,   16,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
      171,  157,  158,  109,  110,    0,   87,   21,    0,    0,
        0,    0,    0,    0,   64,   65,    0,    0,    0,    0,
        0,    0,   92,    0,    0,    0,    0,    0,  171,  111,

      112,   87,    0,   10,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,  171,   87,    0,
        0,   67,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   95,    0,    0,  171,   11,    0,
       63,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       96,   94,   93,  167,   11,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   70,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    9,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    8,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   72,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   72,    0,    0,   72,    0,    0,    0,
        0,    0,    0,    0,    0,   72,    0,    0,    0,    0,
        0,    0,   66,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,   79,   71,    0,    0,    0,    0,    0,
       72,    0,    0,    0,   73,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   79,   78,
       71,    0,   72,    0,    0,   73,    0,   72,   73,    0,
        0,    0,    0,    0,    0,    0,   77,    0,   78,   71,
       72,   71,   73,    0,    0,    0,    0,    0,    0,    0,
        0,   76,   77,    0,    0,    0,   61,    0,    0,    0,
       85,    0,    0,   76,    0,    0,   61,    0,    0,   85,
       84,    0,    0,    0,   60,    0,    0,   83,    0,   84,
        0,    0,    0,   60,   82,   83,    0,    0,   68,   82,

        0,   69,    0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    2,
        1,    2,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    4,    5,    6,    7,    1,    8,    1,    9,
       10,   11,   12,   13,    1,   14,   15,   16,   17,   18,
       18,   18,   18,   18,   18,   18,   18,    1,   19,   20,
       21,   22,   12,   23,   24,    1,   25,   26,   27,   28,
       29,   30,   31,    1,   32,   33,   34,   35,   36,   37,
        1,   38,   39,   40,   41,   42,   43,   44,    1,    1,
       45,    1,   12,   46,    1,    1,   47,    1,   48,   49,

       50,   51,   29,   30,   52,    1,   32,   53,   34,   54,
       36,   55,    1,   56,   57,   58,   59,   42,   43,   60,
        1,    1,   61,   62,   63,   64,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[65] =
    {   0,
        1,    1,    2,    3,    4,    5,    5,    6,    7,    8,
        1,    1,    1,    1,    1,    1,    1,    1,    9,    3,
       10,    3,    5,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    3,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
       11,   12,   13,    6
    } ;

static yyconst short int yy_base[854] =
    {   0,
        0,   63,   30,   42, 2468, 2467,  125,  187,  249,  311,
      373,  435,  497,  559,  134,  149, 2477, 2473,   10,   12,
     2454, 2469, 2468, 2467, 2480,   13, 2480, 2480,   31,   14,
       35, 2466,   24,   27,  177,   38,   33,  609, 2480, 2480,
       26, 2480, 2418, 2415, 2480, 2457,   34, 2464, 2480,  663,
     2480, 2480, 2480, 2480, 2480,  103,   46,  120, 2480,  219,
       54, 2463, 2480,  725, 2480, 2480, 2480, 2480,  115,  104,
      164, 2480,  277, 2462, 2461, 2480,  787, 2480, 2480, 2480,
     2480, 2480,  170,   39,  211,  118, 2480, 2480, 2480, 2460,
     2459,    0, 2480, 2480, 2480,  181,   92,  161,    4, 2480,

     2480,   21,  260,   48, 2456, 2480, 2480, 2457, 2480,  100,
      110,  112,   97, 2454, 2447, 2452,    0, 2451,    0, 2436,
      241,  288,  117,  152, 2397,  172,  168,  175,  197,  218,
     2448,    0,  242,  271,  138,  236,  216,  237,  323,  346,
      299, 2416,   66,  156,  251,  299,  254,  273,  282,  234,
     2394, 2398, 2480,  289, 2480,  401, 2446,  849, 2443, 2135,
      299,  456,  423,  302,  327,  345,  353,  356, 2480,  464,
     2111,  911, 2096, 2057,  360,  525,  477,  450,  367,  368,
      385, 2053, 2480, 2052,  973, 2049, 2047, 2031,  336,  349,
      401,  483, 2030, 2029, 2480, 2028, 2024,  402,  507,  263,

      373,  193, 2480, 2480,  414,  384, 2007, 2480,  447,  344,
     2480, 2004, 2003, 2480,  537,  387, 2002, 2001,  449,  431,
     2480, 2480, 2480,  476,  437, 2480, 2480, 1999,  484,  508,
      515,  488, 1984, 2480,  511, 1939,  569, 1963, 1962, 2480,
     1961,  493,  581, 1960, 1958, 2480, 1954,  508,  465,  525,
      493,  502,  547,  542,  551,  544, 1937, 1940,  551,  556,
     1908, 1907, 2480,    0, 1913,  451,  577, 2480,  613, 2480,
        0, 1912,  614,  615, 2480,  616, 2480, 1954,  590,  602,
     1946, 2480, 2480,  575,  623, 2480, 2480,  585, 2480, 2480,
     2480, 2480,  609, 2480,  622, 2480, 2480, 2480, 2480, 2480,

     1944, 2480,  607,  589, 1940, 2480, 1937, 2480, 2480, 2480,
     2480, 2480, 2480, 2480, 2480, 2480, 2480, 2480,  608, 1903,
      608,  573,  632,  647,  597,  656,  644,  660,  648, 2480,
     1907,  686,  687,    0, 2480, 2480,    0, 2480, 2480, 2480,
      689,  639, 2480, 2480, 2480,  688,  655,  693, 2480, 1931,
      691, 1927, 2480, 1924,  668,  661,  661,  689,  662,  667,
      701,  682, 1923,  694, 1874, 1879,  737,  739,  738,  774,
      748, 2480, 2480, 2480, 2480,  712,  747, 1903,  708, 1841,
     1770,  717,  725,  729, 2480, 2480,  733,  767, 1742,  725,
      726,  802,  798,  836, 1772,  756,  777, 1765,  771, 2480,

     2480,  821,  788, 2480,  785, 1737,  725,  786, 1736,  816,
      825, 1791, 1790,  818,  808,  808,  829,  835, 1789,  836,
     1727, 2480,  840,  818,  829, 1755,  775,  878,  894, 1773,
     1035,  844,  863,  851, 2480,  849,  875, 1784, 1783,  875,
     2480, 1721, 1780,  874,  923,  924, 1767,  882,  900, 1766,
      938,  941,  905,  640, 1096,  866,  927,  944,  913,  918,
     2480, 2480, 2480, 2480, 1776, 1715,  946,  167,  893,  947,
      965,  950,  933,  908,  966,  948,  955, 1762, 1771,  961,
      985, 1007, 1010,  964,  968,  989, 1157,  994,  998, 1025,
     1760, 1218,  985,  471, 2480, 1006, 1028, 1049, 1758,  971,

     1015, 1757, 1766, 1021, 1037, 1740, 1037, 1059, 1016, 1019,
     1024, 1754, 1068, 1074, 1085, 1050, 1078, 1279, 1110, 1114,
     1062, 1117, 1079, 1340, 1739, 1067, 1088, 1124, 1076, 1101,
     1122, 1735, 1075, 1127, 1128, 1135, 1136, 1137, 1093, 1103,
     1127, 1142, 1751,  237, 1139, 1702, 1097, 1759, 1734, 1154,
     1142, 1182, 1145, 1747, 1185, 1151, 1211, 1188, 1746, 1205,
     1187, 1196, 1232, 1167, 1239, 1235, 1195, 1248, 1726, 1206,
     1237, 1744, 1753, 1241, 1234, 1196, 1725, 1724, 1199, 1265,
     1222, 1689, 2480, 1745, 1190, 1221, 1719, 1233, 1306, 1249,
     1307, 1310, 1261, 1303, 1309, 1317, 1215, 1320, 1327, 1641,

     1334, 1289, 1304, 1307, 1258, 1652, 1324, 1317, 1630, 1290,
     1632, 1363, 1335, 1202, 2480, 1316, 1336, 1571, 1364, 1348,
     1195, 1388, 1356, 1394, 1385, 1402, 1462, 1397, 1409, 1367,
     1406, 1364, 1410, 1416, 1378, 1390, 1415, 1396, 1399, 1404,
     1389, 1434, 1410, 1420, 1417, 1416, 1263, 1425, 1435, 1469,
     1418, 1473, 1452, 1477, 2480, 1486, 1433, 1437, 1496, 1381,
     1487, 1470, 1497, 1502, 1457, 1437, 1487, 1468, 1506, 1471,
     1494, 1516, 1268, 2480, 1264, 1480, 1313, 1492, 1507, 1547,
     1495, 1550, 1510, 1556, 1529, 1517, 1213, 1541, 1238, 1559,
     1275, 1577, 2480, 1553, 1522, 1536, 1524, 1554, 1584, 1593,

     1557, 1553, 1563, 1154, 2480, 1090, 1555, 1566, 1616, 1570,
     1620, 1583, 1628, 1624, 2480, 1631, 1594, 1621, 1633, 1592,
     1601, 1630, 1598, 1649, 1072, 1022,  998, 1614, 1204, 2480,
     2480,  986, 1027, 1650,  873,  918, 1656, 1641, 1644, 1653,
     1641, 1625, 1664, 1639,  747,  722,  757,  702,  756, 2480,
     1668, 2480, 1695, 1704, 1711, 1655, 1682, 1670,  654,  596,
      556, 2480,  593,  516, 1717, 1658, 2480, 1683, 1682, 1690,
      517,  466,  411, 2480, 1722, 1728,  427,  339, 1693, 1729,
     2480,  305,  248, 1732, 2480,  294, 1733,  170,   63,   92,
       34, 1734, 1735, 2480, 2480,    8, 1740, 1741, 2480, 2480,

     1744, 2480, 2480, 1807, 1820, 1833, 1846, 1859, 1872, 1885,
     1898, 1911, 1924, 1937, 1950, 1963, 1976, 1988, 2001, 2013,
     2026, 2035, 2048, 2058, 2071, 2084, 2097, 2110, 2123, 2136,
     2149, 2162, 2175, 2188, 2201, 2214, 2227, 2240, 2253, 2266,
     2279, 2292, 2305, 2318, 2331, 2344, 2357, 2369, 2382, 2395,
     2408, 2421, 2434
    } ;

static yyconst short int yy_def[854] =
    {   0,
      804,  804,  805,  805,  805,  805,  806,  806,  807,  807,
      808,  808,  809,  809,  810,  810,  803,  811,  811,  803,
      803,  812,  813,  814,  803,  815,  803,  803,  803,  803,
      803,  816,  811,  811,  811,  811,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  817,  803,  803,  818,
      803,  803,  803,  803,  803,  817,  817,  817,  803,  803,
      819,  803,  803,  820,  803,  803,  803,  803,  819,  819,
      819,  803,  803,  821,  803,  803,  822,  803,  803,  803,
      803,  803,  821,  821,  821,  821,  803,  803,  803,  823,
      803,  824,  803,  803,  803,  823,  823,  823,  803,  803,

      803,  825,  825,  803,  826,  803,  803,  811,  803,  811,
      803,  803,  803,  812,  803,  813,  827,  814,  828,  815,
      815,  829,  803,  803,  803,  803,  803,  803,  803,  803,
      816,  830,  811,  811,  811,  811,  811,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  817,  803,  803,  803,  818,  831,  831,
      817,  831,  817,  817,  817,  817,  817,  819,  803,  803,
      803,  820,  832,  832,  819,  832,  819,  819,  819,  819,
      819,  821,  803,  803,  822,  833,  833,  821,  821,  821,
      821,  821,  821,  823,  803,  803,  824,  823,  823,  823,

      803,  825,  803,  803,  825,  803,  826,  803,  803,  803,
      803,  827,  828,  803,  829,  815,  834,  834,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  830,  811,  811,
      811,  811,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  158,  158,  817,  817,  803,  817,  803,
      172,  172,  819,  819,  803,  819,  803,  821,  821,  821,
      821,  803,  803,  823,  823,  803,  803,  803,  803,  803,
      803,  803,  815,  803,  803,  803,  803,  803,  803,  803,

      803,  803,  811,  811,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  158,  803,  803,  172,  803,  803,  803,
      821,  821,  803,  803,  803,  823,  803,  803,  803,  803,
      811,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      821,  803,  803,  803,  803,  803,  811,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  821,  803,

      803,  811,  803,  803,  803,  803,  803,  803,  803,  803,
      835,  803,  803,  803,  803,  803,  803,  821,  811,  803,
      803,  803,  803,  803,  836,  803,  835,  835,  837,  803,
      835,  803,  803,  803,  803,  803,  803,  821,  803,  803,
      803,  803,  803,  836,  836,  838,  803,  803,  835,  803,
      837,  837,  835,  839,  837,  803,  840,  841,  803,  803,
      803,  803,  803,  803,  803,  803,  842,  803,  836,  838,
      838,  836,  843,  803,  803,  803,  835,  803,  839,  803,
      839,  844,  845,  803,  840,  840,  840,  841,  841,  841,
      803,  841,  803,  803,  803,  842,  842,  846,  803,  803,

      836,  803,  843,  803,  843,  803,  803,  847,  803,  803,
      803,  803,  839,  844,  844,  840,  839,  844,  845,  845,
      841,  845,  839,  845,  803,  840,  841,  841,  803,  841,
      841,  803,  803,  842,  846,  846,  842,  848,  803,  803,
      803,  803,  803,  843,  803,  849,  847,  850,  803,  803,
      803,  839,  840,  803,  839,  844,  845,  841,  803,  845,
      839,  845,  845,  803,  841,  841,  803,  841,  803,  803,
      842,  803,  848,  803,  848,  803,  803,  803,  803,  843,
      803,  849,  803,  850,  803,  803,  803,  803,  839,  803,
      839,  845,  803,  845,  839,  845,  803,  841,  841,  803,

      841,  803,  803,  803,  803,  803,  848,  803,  803,  803,
      803,  843,  803,  803,  803,  803,  803,  803,  839,  803,
      839,  845,  803,  845,  839,  845,  803,  841,  841,  803,
      841,  803,  803,  803,  803,  803,  848,  803,  803,  803,
      803,  843,  803,  803,  803,  803,  839,  803,  839,  845,
      803,  845,  839,  845,  803,  841,  841,  803,  841,  803,
      803,  803,  803,  803,  803,  803,  848,  803,  803,  803,
      803,  843,  803,  803,  803,  803,  839,  803,  839,  845,
      803,  845,  839,  845,  841,  841,  803,  841,  803,  803,
      803,  803,  803,  803,  803,  803,  848,  803,  803,  803,

      803,  803,  843,  803,  803,  803,  803,  839,  845,  803,
      845,  839,  845,  841,  803,  841,  803,  803,  803,  803,
      803,  848,  803,  803,  803,  803,  803,  803,  843,  803,
      803,  803,  839,  845,  803,  839,  845,  841,  841,  803,
      803,  803,  848,  803,  803,  803,  803,  803,  843,  803,
      845,  803,  845,  803,  851,  803,  803,  848,  803,  803,
      803,  803,  803,  851,  851,  852,  803,  803,  803,  848,
      803,  803,  803,  803,  852,  851,  853,  803,  803,  848,
      803,  803,  803,  851,  803,  853,  803,  803,  803,  848,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,

      803,  803,    0,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803
    } ;

static yyconst short int yy_nxt[2545] =
    {   0,
      803,   19,   20,   21,   22,   23,   24,   25,   26,   27,
       28,  110,  111,  112,  112,  121,  126,  122,  800,   29,
       30,   31,   32,   33,   34,  803,  109,  150,  150,  109,
      203,   41,   41,  123,   35,   36,  155,  128,  201,  204,
      109,  183,   42,   41,   41,   37,   33,   34,  155,  206,
      206,  124,  138,   35,   42,  129,  169,  201,  133,  127,
       38,   39,  134,   40,   19,   20,   21,   22,   23,   24,
       25,   26,   27,   28,  190,  137,  125,  133,   43,  139,
      130,  164,   29,   30,   31,   32,   33,   34,   44,  140,
       43,  797,   45,  137,  195,  156,  574,   35,   36,  209,

       44,  110,  111,  253,   45,  155,  169,  156,   37,   33,
       34,  112,  112,  112,  112,  170,   35,  169,  199,  123,
      183,  253,  155,   38,   39,  796,   40,   48,   49,   50,
       51,   51,   52,   53,   54,  103,  104,  163,  105,  178,
      109,  199,  210,  106,   51,   55,   51,   51,   56,  177,
      103,  104,  107,  105,  219,  193,  163,  165,  106,   57,
       58,  231,  125,  195,  156,  170,  169,  107,  177,  468,
       51,   56,  183,  193,  126,  165,  170,  128,   57,  109,
      795,  156,  254,  195,  231,   59,   60,   28,   28,   48,
       49,   50,   51,   51,   52,   53,   54,  220,  200,  224,

      500,  179,  203,  135,  189,  254,   51,   55,   51,   51,
       56,  204,  136,  183,  222,  198,  200,  127,  233,  179,
      130,   57,   58,  189,  223,  170,  135,  166,  166,  166,
      166,  166,   51,   56,  198,  150,  150,  191,  109,  235,
       57,  504,  225,  121,  109,  122,  192,   59,   60,   28,
       28,   62,   63,   64,   65,   65,   66,   67,   68,  214,
      191,  205,  205,  167,  226,  286,  580,  229,   65,  203,
       65,   65,   69,  109,  227,  232,  234,  255,  204,  166,
      258,  166,  236,   70,   71,  180,  180,  180,  180,  180,
      229,  155,  216,  232,   65,   69,  217,  217,  787,  259,

      255,  155,   70,  258,  155,  230,  218,  792,  260,   72,
       73,   28,   28,   62,   63,   64,   65,   65,   66,   67,
       68,  181,  259,  287,  230,  237,  238,  249,  256,  268,
       65,  260,   65,   65,   69,  250,  257,  180,  183,  180,
      251,  267,  239,  240,  241,   70,   71,  155,  243,  244,
      156,  183,  791,  250,  257,  155,   65,   69,  169,  267,
      156,  278,  169,  156,   70,  245,  246,  247,  242,  275,
      169,   72,   73,   28,   28,   75,   76,   77,   78,   78,
       79,   80,   81,  279,  278,  206,  206,  169,  156,  293,
      289,  248,   78,   82,   78,   78,   83,   84,  269,  288,

      290,  788,  279,  183,  195,  294,  156,   85,   86,  166,
      166,  166,  166,  166,  156,  205,  205,  170,   78,   83,
       84,  170,  288,  203,  280,  155,   85,  284,  170,  170,
      276,  787,  204,   87,   88,   28,   89,   75,   76,   77,
       78,   78,   79,   80,   81,  167,  170,  280,  266,  209,
      284,  219,  169,  335,   78,   82,   78,   78,   83,   84,
      263,  166,  783,  166,  264,  264,  264,  264,  264,   85,
       86,  266,  180,  180,  180,  180,  180,  296,  224,  169,
       78,   83,   84,  298,  156,  183,  301,  297,   85,  274,
      305,  319,  210,  299,  220,   87,   88,   28,   89,   91,

      265,   92,  273,  533,   93,   94,   95,  274,  181,  195,
      109,  170,  156,  235,  319,  782,  264,  109,  264,  321,
       96,  225,  281,  533,  180,  273,  180,  781,  322,  270,
      285,   97,   98,  271,  271,  271,  271,  271,  170,  312,
      281,  216,  321,   96,  302,  217,  217,  303,  306,  313,
       97,  322,  304,  285,  317,  218,  236,   99,  100,   28,
      101,   91,  320,   92,  318,  303,   93,   94,   95,  272,
      304,  237,  238,  323,  325,  329,  324,  344,  767,  336,
      320,  326,   96,  243,  244,  271,  331,  271,  239,  240,
      241,  352,  183,   97,   98,  324,  323,  325,  329,  326,

      245,  246,  247,  774,  183,   96,  773,  331,  347,  109,
      358,  293,   97,  330,  242,  155,  338,  339,  169,   99,
      100,   28,  101,  141,  348,  195,  248,  294,  358,  341,
      351,  347,  357,  142,  361,  345,  143,  144,  156,  342,
      349,  372,  355,  145,  480,  146,  147,  341,  772,  353,
      148,  149,  361,  351,  481,  357,  142,  342,  359,  143,
      346,  355,  145,  146,  147,  159,  160,  161,  160,  160,
      160,  160,  160,  360,  156,  170,  170,  170,  346,  362,
      363,  359,  160,  160,  160,  160,  364,  365,  367,  369,
      374,  183,  376,  109,  379,  348,  360,  380,  363,  373,

      381,  383,  362,  385,  384,  365,  368,  370,  160,  364,
      376,  349,  371,  382,  400,  380,  771,  379,  381,  383,
      387,  377,  384,  160,  162,  160,  160,  173,  174,  175,
      174,  174,  174,  174,  174,  371,  382,  389,  387,  367,
      369,  392,  377,  406,  174,  403,  174,  174,  375,  109,
      183,  407,  408,  389,  393,  393,  393,  368,  370,  409,
      504,  386,  412,  403,  763,  413,  406,  762,  423,  388,
      174,  761,  401,  183,  407,  408,  394,  449,  399,  415,
      412,  402,  409,  413,  423,  174,  176,  174,  174,  186,
      187,  188,  187,  187,  187,  187,  187,  760,  395,  399,

      402,  410,  415,  416,  392,  418,  187,  187,  187,  187,
      396,  420,  397,  393,  393,  393,  398,  393,  393,  393,
      410,  395,  421,  109,  418,  424,  416,  428,  396,  429,
      397,  445,  187,  446,  420,  450,  431,  183,  394,  426,
      421,  434,  436,  424,  443,  435,  432,  187,  187,  187,
      187,  159,  160,  161,  160,  160,  160,  160,  160,  419,
      395,  436,  426,  435,  434,  433,  437,  443,  160,  160,
      160,  160,  396,  438,  397,  440,  469,  419,  398,  442,
      428,  459,  429,  395,  437,  430,  431,  461,  462,  447,
      396,  438,  397,  440,  160,  469,  452,  442,  453,  459,

      463,  466,  449,  484,  460,  461,  462,  477,  475,  160,
      162,  160,  160,  173,  174,  175,  174,  174,  174,  174,
      174,  484,  480,  463,  466,  445,  471,  446,  472,  486,
      174,  475,  174,  174,  447,  752,  493,  504,  430,  431,
      452,  494,  453,  452,  506,  453,  489,  505,  497,  471,
      498,  472,  501,  447,  454,  455,  174,  477,  490,  493,
      450,  431,  506,  511,  494,  478,  431,  471,  507,  472,
      486,  174,  176,  174,  174,  186,  187,  188,  187,  187,
      187,  187,  187,  447,  473,  509,  508,  430,  487,  480,
      525,  486,  187,  187,  187,  187,  489,  540,  454,  455,

      489,  454,  455,  509,  491,  492,  499,  473,  534,  515,
      502,  516,  520,  525,  521,  478,  431,  501,  187,  532,
      540,  512,  513,  542,  522,  473,  511,  489,  430,  487,
      497,  480,  498,  187,  187,  187,  187,  449,  532,  507,
      513,  504,  549,  457,  457,  457,  457,  457,  750,  430,
      487,  536,  553,  537,  491,  492,  550,  508,  491,  492,
      747,  547,  528,  548,  558,  549,  499,  517,  518,  486,
      523,  524,  480,  544,  550,  502,  515,  746,  516,  457,
      528,  543,  480,  480,  512,  491,  492,  515,  499,  516,
      489,  544,  555,  561,  552,  458,  431,  457,  452,  547,

      453,  548,  565,  489,  482,  482,  482,  482,  482,  538,
      554,  487,  520,  567,  521,  570,  520,  552,  521,  520,
      576,  521,  559,  492,  489,  745,  489,  430,  487,  534,
      536,  567,  537,  570,  517,  518,  568,  536,  571,  537,
      482,  574,  577,  576,  542,  517,  518,  553,  491,  492,
      566,  575,  731,  515,  560,  516,  483,  455,  482,  486,
      577,  491,  492,  578,  730,  526,  526,  526,  526,  526,
      523,  524,  560,  566,  523,  524,  581,  523,  524,  588,
      587,  578,  491,  492,  491,  492,  480,  499,  538,  480,
      558,  480,  614,  597,  581,  538,  572,  588,  520,  480,

      521,  526,  543,  587,  614,  554,  487,  520,  504,  521,
      589,  517,  518,  520,  749,  521,  597,  527,  487,  526,
      489,  600,  591,  649,  595,  592,  530,  530,  530,  530,
      530,  594,  603,  608,  520,  611,  521,  489,  574,  571,
      591,  489,  595,  605,  600,  613,  596,  616,  559,  492,
      489,  608,  615,  611,  594,  603,  523,  524,  627,  618,
      605,  607,  530,  599,  615,  523,  524,  480,  613,  504,
      616,  523,  524,  717,  627,  715,  598,  691,  531,  492,
      530,  515,  618,  516,  607,  601,  620,  556,  556,  556,
      556,  556,  523,  524,  598,  491,  492,  572,  623,  491,

      492,  606,  612,  601,  620,  520,  633,  521,  491,  492,
      480,  480,  520,  480,  521,  632,  623,  480,  606,  520,
      612,  521,  489,  556,  634,  677,  705,  640,  574,  489,
      704,  624,  619,  621,  635,  625,  489,  693,  632,  557,
      518,  556,  520,  638,  521,  640,  628,  622,  562,  562,
      562,  562,  562,  629,  626,  619,  621,  635,  625,  644,
      631,  637,  645,  523,  524,  622,  638,  504,  480,  628,
      523,  524,  626,  643,  648,  644,  629,  523,  524,  637,
      491,  492,  651,  631,  562,  645,  642,  491,  492,  480,
      520,  643,  521,  658,  491,  492,  520,  648,  521,  489,

      563,  524,  562,  660,  520,  651,  521,  647,  489,  642,
      689,  489,  633,  653,  650,  665,  658,  666,  661,  574,
      652,  660,  668,  647,  669,  656,  671,  670,  654,  662,
      634,  663,  664,  665,  659,  489,  673,  650,  504,  480,
      666,  667,  676,  652,  671,  668,  681,  669,  523,  524,
      670,  654,  657,  678,  523,  524,  480,  491,  492,  673,
      675,  679,  523,  524,  667,  676,  491,  492,  657,  491,
      492,  520,  672,  521,  696,  520,  675,  521,  683,  520,
      687,  521,  674,  695,  679,  690,  690,  690,  489,  661,
      672,  574,  696,  491,  492,  686,  687,  680,  489,  691,

      662,  683,  663,  664,  691,  684,  695,  698,  699,  701,
      692,  480,  685,  697,  480,  694,  682,  702,  707,  489,
      504,  710,  688,  706,  655,  698,  700,  701,  574,  523,
      524,  489,  682,  523,  524,  685,  697,  523,  524,  706,
      702,  707,  703,  489,  710,  688,  491,  492,  720,  520,
      708,  521,  520,  712,  521,  691,  491,  492,  520,  693,
      521,  691,  721,  722,  693,  703,  708,  504,  719,  712,
      480,  720,  714,  709,  690,  690,  690,  491,  492,  691,
      723,  722,  713,  727,  716,  721,  699,  480,  714,  491,
      492,  728,  718,  718,  718,  724,  709,  724,  732,  646,

      716,  491,  492,  723,  700,  713,  727,  523,  524,  728,
      523,  524,  711,  735,  732,  693,  523,  524,  520,  740,
      521,  693,  520,  691,  521,  729,  489,  742,  733,  735,
      520,  741,  521,  489,  574,  691,  718,  718,  718,  693,
      748,  744,  740,  489,  725,  736,  489,  726,  719,  741,
      742,  724,  520,  724,  521,  754,  743,  744,  520,  734,
      521,  641,  776,  748,  757,  639,  636,  756,  574,  630,
      520,  737,  521,  755,  574,  734,  523,  524,  759,  743,
      523,  524,  757,  693,  491,  492,  738,  737,  523,  524,
      756,  491,  492,  739,  574,  693,  759,  520,  768,  521,

      725,  491,  492,  726,  491,  492,  754,  758,  769,  770,
      523,  524,  751,  765,  768,  766,  523,  524,  753,  765,
      777,  766,  778,  758,  755,  779,  776,  770,  523,  524,
      784,  769,  789,  574,  784,  793,  798,  793,  798,  790,
      778,  779,  801,  798,  801,  798,  801,  617,  801,  585,
      789,  583,  780,  610,  609,  523,  524,  574,  604,  602,
      593,  590,  586,  585,  583,  579,  569,  564,  551,  545,
      504,  541,  539,  767,  529,  480,  510,  495,  465,  767,
      476,  474,  468,  467,  777,  465,  464,  456,  448,  441,
      785,  439,  433,  432,  785,  794,  799,  794,  425,  422,

      417,  414,  802,  799,  411,  405,  802,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
       28,   28,   28,   47,   47,   47,   47,   47,   47,   47,
       47,   47,   47,   47,   47,   47,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   90,   90,   90,   90,   90,   90,   90,   90,
       90,   90,   90,   90,   90,  102,  102,  102,  102,  102,
      102,  102,  102,  102,  102,  102,  102,  102,  108,  108,

      108,  108,  108,  404,  108,  378,  108,  108,  391,  390,
      108,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  116,  388,  354,  116,  116,  378,
      116,  116,  116,  350,  116,  366,  116,  118,  356,  307,
      118,  118,  354,  118,  118,  118,  350,  118,  343,  118,
      120,  120,  120,  120,  120,  120,  340,  337,  334,  120,
      120,  120,  120,  131,  333,  332,  131,  131,  328,  131,
      131,  131,  327,  131,  316,  131,  154,  154,  315,  154,
      314,  311,  310,  309,  154,  308,  307,  154,  158,  158,
      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,

      158,  168,  168,  300,  168,  295,  295,  292,  291,  168,
      168,  208,  168,  172,  172,  172,  172,  172,  172,  172,
      172,  172,  172,  172,  172,  172,  182,  182,  283,  182,
      196,  195,  282,  183,  182,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  194,  194,
      194,  277,  194,  277,  184,  183,  194,  194,  197,  197,
      197,  270,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  202,  202,  202,  202,  202,  202,  202,  202,  202,
      202,  202,  202,  202,  207,  207,  207,  207,  207,  207,
      207,  207,  207,  207,  207,  207,  207,  212,  212,  212,

      270,  212,  212,  212,  212,  212,  212,  212,  212,  212,
      213,  213,  213,  171,  213,  213,  213,  213,  213,  213,
      213,  213,  213,  215,  215,  215,  215,  215,  215,  215,
      215,  215,  215,  215,  215,  215,  228,  228,  228,  263,
      228,  228,  228,  228,  228,  228,  228,  228,  228,  160,
      160,  160,  160,  160,  160,  160,  160,  160,  160,  160,
      160,  160,  174,  174,  174,  174,  174,  174,  174,  174,
      174,  174,  174,  174,  174,  187,  187,  187,  187,  187,
      187,  187,  187,  187,  187,  187,  187,  187,  217,  217,
      217,  217,  217,  217,  217,  217,  217,  217,  217,  217,

      217,  427,  427,  427,  427,  427,  427,  427,  427,  427,
      427,  427,  427,  427,  444,  444,  444,  444,  444,  444,
      444,  444,  444,  444,  444,  444,  444,  451,  451,  451,
      451,  451,  451,  451,  451,  451,  451,  451,  451,  451,
      470,  470,  470,  470,  470,  470,  470,  470,  470,  470,
      470,  470,  470,  479,  479,  479,  479,  479,  479,  479,
      479,  479,  479,  479,  479,  479,  485,  485,  485,  485,
      485,  485,  485,  485,  485,  485,  485,  485,  485,  488,
      488,  488,  488,  488,  488,  488,  488,  488,  488,  488,
      488,  488,  496,  496,  496,  496,  496,  496,  496,  496,

      496,  496,  496,  496,  496,  503,  503,  503,  503,  503,
      503,  503,  503,  503,  503,  503,  503,  503,  514,  514,
      514,  514,  514,  514,  514,  514,  514,  514,  514,  514,
      514,  519,  519,  519,  519,  519,  519,  519,  519,  519,
      519,  519,  519,  519,  535,  535,  535,  535,  535,  535,
      535,  535,  535,  535,  535,  535,  535,  546,  546,  546,
      546,  546,  546,  546,  546,  546,  546,  546,  546,  573,
      573,  573,  573,  573,  573,  573,  573,  573,  573,  573,
      573,  573,  582,  582,  582,  582,  582,  582,  582,  582,
      582,  582,  582,  582,  582,  584,  584,  584,  584,  584,

      584,  584,  584,  584,  584,  584,  584,  584,  764,  764,
      764,  764,  764,  764,  764,  764,  764,  764,  764,  764,
      764,  775,  775,  775,  775,  775,  775,  775,  775,  775,
      775,  775,  775,  775,  786,  786,  786,  786,  786,  786,
      786,  786,  786,  786,  786,  786,  786,  263,  157,  262,
      261,  252,  803,  221,  214,  803,  803,  211,  115,  109,
      208,  196,  195,  184,  183,  171,  157,  153,  152,  151,
      132,  119,  117,  115,  113,  109,  803,   46,   46,   17,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,

      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803
    } ;

static yyconst short int yy_chk[2545] =
    {   0,
        0,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,   19,   19,   20,   20,   26,   30,   26,  796,    1,
        1,    1,    1,    1,    1,    0,   33,   41,   41,   34,
      102,    3,    3,   29,    1,    1,   47,   31,   99,  102,
       36,   84,    3,    4,    4,    1,    1,    1,   57,  104,
      104,   29,   37,    1,    4,   31,   61,   99,   33,   30,
        1,    1,   34,    1,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,   84,   36,   29,   33,    3,   37,
       31,   57,    2,    2,    2,    2,    2,    2,    3,   37,
        4,  791,    3,   36,   97,   47,  790,    2,    2,  113,

        4,  110,  110,  143,    4,   56,   70,   57,    2,    2,
        2,  111,  111,  112,  112,   61,    2,   69,   97,  123,
       86,  143,   58,    2,    2,  789,    2,    7,    7,    7,
        7,    7,    7,    7,    7,   15,   15,   56,   15,   70,
      135,   97,  113,   15,    7,    7,    7,    7,    7,   69,
       16,   16,   15,   16,  124,   86,   56,   58,   16,    7,
        7,  135,  123,   98,   56,   70,   71,   16,   69,  468,
        7,    7,   83,   86,  126,   58,   69,  128,    7,   35,
      788,   58,  144,   96,  135,    7,    7,    7,    7,    8,
        8,    8,    8,    8,    8,    8,    8,  124,   98,  129,

      468,   71,  202,   35,   83,  144,    8,    8,    8,    8,
        8,  202,   35,   85,  127,   96,   98,  126,  137,   71,
      128,    8,    8,   83,  127,   71,   35,   60,   60,   60,
       60,   60,    8,    8,   96,  150,  150,   85,  136,  138,
        8,  544,  129,  121,  133,  121,   85,    8,    8,    8,
        8,    9,    9,    9,    9,    9,    9,    9,    9,  121,
       85,  103,  103,   60,  130,  200,  544,  133,    9,  103,
        9,    9,    9,  134,  130,  136,  137,  145,  103,   60,
      147,   60,  138,    9,    9,   73,   73,   73,   73,   73,
      133,  154,  122,  136,    9,    9,  122,  122,  786,  148,

      145,  161,    9,  147,  164,  134,  122,  783,  149,    9,
        9,    9,    9,   10,   10,   10,   10,   10,   10,   10,
       10,   73,  148,  200,  134,  139,  139,  141,  146,  165,
       10,  149,   10,   10,   10,  141,  146,   73,  189,   73,
      141,  164,  139,  139,  139,   10,   10,  166,  140,  140,
      154,  190,  782,  141,  146,  167,   10,   10,  168,  164,
      161,  189,  175,  164,   10,  140,  140,  140,  139,  179,
      180,   10,   10,   10,   10,   11,   11,   11,   11,   11,
       11,   11,   11,  190,  189,  206,  206,  181,  165,  216,
      210,  140,   11,   11,   11,   11,   11,   11,  167,  201,

      210,  778,  190,  191,  198,  216,  166,   11,   11,  156,
      156,  156,  156,  156,  167,  205,  205,  168,   11,   11,
       11,  175,  201,  205,  191,  163,   11,  198,  179,  180,
      181,  777,  205,   11,   11,   11,   11,   12,   12,   12,
       12,   12,   12,   12,   12,  156,  181,  191,  163,  209,
      198,  219,  178,  266,   12,   12,   12,   12,   12,   12,
      162,  156,  773,  156,  162,  162,  162,  162,  162,   12,
       12,  163,  170,  170,  170,  170,  170,  220,  224,  177,
       12,   12,   12,  225,  163,  192,  229,  220,   12,  178,
      232,  249,  209,  225,  219,   12,   12,   12,   12,   13,

      162,   13,  177,  494,   13,   13,   13,  178,  170,  199,
      230,  178,  266,  235,  249,  772,  162,  231,  162,  251,
       13,  224,  192,  494,  170,  177,  170,  771,  252,  176,
      199,   13,   13,  176,  176,  176,  176,  176,  177,  242,
      192,  215,  251,   13,  229,  215,  215,  230,  232,  242,
       13,  252,  231,  199,  248,  215,  235,   13,   13,   13,
       13,   14,  250,   14,  248,  230,   14,   14,   14,  176,
      231,  237,  237,  253,  255,  259,  254,  284,  764,  267,
      250,  256,   14,  243,  243,  176,  260,  176,  237,  237,
      237,  304,  279,   14,   14,  254,  253,  255,  259,  256,

      243,  243,  243,  763,  280,   14,  761,  260,  288,  303,
      322,  293,   14,  259,  237,  269,  273,  274,  276,   14,
       14,   14,   14,   38,  295,  285,  243,  293,  322,  279,
      303,  288,  321,   38,  325,  284,   38,   38,  267,  280,
      295,  342,  319,   38,  454,   38,   38,  279,  760,  304,
       38,   38,  325,  303,  454,  321,   38,  280,  323,   38,
      285,  319,   38,   38,   38,   50,   50,   50,   50,   50,
       50,   50,   50,  324,  269,  273,  274,  276,  285,  326,
      327,  323,   50,   50,   50,   50,  328,  329,  332,  333,
      346,  341,  347,  351,  355,  348,  324,  356,  327,  342,

      357,  359,  326,  361,  360,  329,  332,  333,   50,  328,
      347,  348,  341,  358,  376,  356,  759,  355,  357,  359,
      362,  351,  360,   50,   50,   50,   50,   64,   64,   64,
       64,   64,   64,   64,   64,  341,  358,  364,  362,  367,
      369,  368,  351,  382,   64,  379,   64,   64,  346,  377,
      371,  383,  384,  364,  368,  368,  368,  367,  369,  387,
      749,  361,  390,  379,  748,  391,  382,  747,  407,  388,
       64,  746,  376,  399,  383,  384,  370,  427,  371,  396,
      390,  377,  387,  391,  407,   64,   64,   64,   64,   77,
       77,   77,   77,   77,   77,   77,   77,  745,  370,  371,

      377,  388,  396,  397,  392,  399,   77,   77,   77,   77,
      370,  403,  370,  393,  393,  393,  370,  392,  392,  392,
      388,  370,  405,  402,  399,  408,  397,  411,  370,  411,
      370,  425,   77,  425,  403,  427,  427,  418,  394,  410,
      405,  414,  416,  408,  424,  415,  432,   77,   77,   77,
       77,  158,  158,  158,  158,  158,  158,  158,  158,  402,
      394,  416,  410,  415,  414,  433,  417,  424,  158,  158,
      158,  158,  394,  418,  394,  420,  444,  402,  394,  423,
      428,  432,  428,  394,  417,  411,  411,  434,  436,  425,
      394,  418,  394,  420,  158,  469,  429,  423,  429,  432,

      437,  440,  449,  456,  433,  434,  436,  453,  448,  158,
      158,  158,  158,  172,  172,  172,  172,  172,  172,  172,
      172,  456,  736,  437,  440,  445,  446,  445,  446,  457,
      172,  448,  172,  172,  444,  735,  459,  473,  428,  428,
      451,  460,  451,  452,  474,  452,  458,  473,  467,  470,
      467,  470,  472,  469,  429,  429,  172,  477,  458,  459,
      449,  449,  474,  480,  460,  453,  453,  471,  475,  471,
      485,  172,  172,  172,  172,  185,  185,  185,  185,  185,
      185,  185,  185,  445,  446,  476,  475,  457,  457,  481,
      484,  486,  185,  185,  185,  185,  488,  500,  451,  451,

      489,  452,  452,  476,  458,  458,  467,  470,  496,  482,
      472,  482,  483,  484,  483,  477,  477,  501,  185,  493,
      500,  480,  481,  504,  483,  471,  511,  490,  485,  485,
      497,  733,  497,  185,  185,  185,  185,  431,  493,  507,
      481,  505,  509,  431,  431,  431,  431,  431,  732,  486,
      486,  498,  516,  498,  488,  488,  510,  507,  489,  489,
      727,  508,  490,  508,  521,  509,  496,  482,  482,  526,
      483,  483,  513,  505,  510,  501,  514,  726,  514,  431,
      490,  504,  517,  523,  511,  490,  490,  515,  497,  515,
      527,  505,  517,  523,  513,  431,  431,  431,  455,  547,

      455,  547,  527,  530,  455,  455,  455,  455,  455,  498,
      516,  516,  519,  529,  519,  533,  520,  513,  520,  522,
      539,  522,  521,  521,  531,  725,  528,  526,  526,  534,
      535,  529,  535,  533,  514,  514,  531,  536,  537,  536,
      455,  538,  540,  539,  542,  515,  515,  553,  527,  527,
      528,  538,  706,  556,  522,  556,  455,  455,  455,  487,
      540,  530,  530,  541,  704,  487,  487,  487,  487,  487,
      519,  519,  522,  528,  520,  520,  545,  522,  522,  551,
      550,  541,  531,  531,  528,  528,  552,  534,  535,  555,
      558,  561,  585,  564,  545,  536,  537,  551,  562,  621,

      562,  487,  542,  550,  614,  553,  553,  560,  729,  560,
      552,  556,  556,  557,  729,  557,  564,  487,  487,  487,
      492,  567,  555,  621,  561,  557,  492,  492,  492,  492,
      492,  560,  570,  576,  563,  579,  563,  566,  575,  571,
      555,  565,  561,  574,  567,  581,  563,  586,  558,  558,
      568,  576,  585,  579,  560,  570,  562,  562,  597,  588,
      605,  575,  492,  566,  614,  560,  560,  647,  581,  580,
      586,  557,  557,  689,  597,  687,  565,  691,  492,  492,
      492,  518,  588,  518,  575,  568,  590,  518,  518,  518,
      518,  518,  563,  563,  565,  566,  566,  571,  593,  565,

      565,  574,  580,  568,  590,  594,  603,  594,  568,  568,
      589,  591,  592,  595,  592,  602,  593,  677,  605,  596,
      580,  596,  598,  518,  603,  647,  675,  610,  607,  599,
      673,  594,  589,  591,  604,  595,  601,  691,  602,  518,
      518,  518,  524,  608,  524,  610,  598,  592,  524,  524,
      524,  524,  524,  599,  596,  589,  591,  604,  595,  616,
      601,  607,  617,  594,  594,  592,  608,  612,  619,  598,
      592,  592,  596,  613,  620,  616,  599,  596,  596,  607,
      598,  598,  623,  601,  524,  617,  612,  599,  599,  625,
      622,  613,  622,  630,  601,  601,  624,  620,  624,  628,

      524,  524,  524,  632,  626,  623,  626,  619,  631,  612,
      660,  629,  633,  625,  622,  635,  630,  636,  634,  637,
      624,  632,  638,  619,  639,  628,  641,  640,  626,  634,
      633,  634,  634,  635,  631,  657,  643,  622,  642,  649,
      636,  637,  646,  624,  641,  638,  651,  639,  622,  622,
      640,  626,  629,  648,  624,  624,  653,  628,  628,  643,
      645,  649,  626,  626,  637,  646,  631,  631,  629,  629,
      629,  650,  642,  650,  666,  652,  645,  652,  653,  654,
      658,  654,  644,  665,  649,  662,  662,  662,  656,  661,
      642,  667,  666,  657,  657,  657,  658,  650,  659,  663,

      661,  653,  661,  661,  664,  654,  665,  668,  669,  670,
      663,  679,  656,  667,  683,  664,  652,  671,  678,  686,
      672,  681,  659,  676,  627,  668,  669,  670,  697,  650,
      650,  685,  652,  652,  652,  656,  667,  654,  654,  676,
      671,  678,  672,  688,  681,  659,  656,  656,  695,  680,
      679,  680,  682,  683,  682,  694,  659,  659,  684,  663,
      684,  690,  696,  697,  664,  672,  679,  703,  694,  683,
      708,  695,  685,  680,  690,  690,  690,  686,  686,  692,
      698,  697,  684,  701,  688,  696,  699,  712,  685,  685,
      685,  702,  692,  692,  692,  700,  680,  700,  707,  618,

      688,  688,  688,  698,  699,  684,  701,  680,  680,  702,
      682,  682,  682,  710,  707,  694,  684,  684,  709,  717,
      709,  690,  711,  718,  711,  703,  714,  721,  708,  710,
      713,  720,  713,  716,  722,  719,  718,  718,  718,  692,
      728,  723,  717,  738,  700,  712,  739,  700,  719,  720,
      721,  724,  734,  724,  734,  740,  722,  723,  737,  709,
      737,  611,  766,  728,  742,  609,  606,  741,  743,  600,
      751,  713,  751,  740,  758,  709,  709,  709,  744,  722,
      711,  711,  742,  718,  714,  714,  714,  713,  713,  713,
      741,  716,  716,  716,  770,  719,  744,  753,  756,  753,

      724,  738,  738,  724,  739,  739,  754,  743,  757,  758,
      734,  734,  734,  755,  756,  755,  737,  737,  737,  765,
      766,  765,  768,  743,  754,  769,  775,  758,  751,  751,
      776,  757,  779,  780,  784,  787,  792,  793,  792,  780,
      768,  769,  797,  798,  797,  798,  801,  587,  801,  584,
      779,  582,  770,  578,  577,  753,  753,  573,  572,  569,
      559,  554,  549,  548,  546,  543,  532,  525,  512,  506,
      503,  502,  499,  755,  491,  479,  478,  466,  465,  765,
      450,  447,  443,  442,  775,  439,  438,  430,  426,  421,
      776,  419,  413,  412,  784,  787,  792,  793,  409,  406,

      398,  395,  797,  798,  389,  381,  801,  804,  804,  804,
      804,  804,  804,  804,  804,  804,  804,  804,  804,  804,
      805,  805,  805,  805,  805,  805,  805,  805,  805,  805,
      805,  805,  805,  806,  806,  806,  806,  806,  806,  806,
      806,  806,  806,  806,  806,  806,  807,  807,  807,  807,
      807,  807,  807,  807,  807,  807,  807,  807,  807,  808,
      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
      808,  808,  809,  809,  809,  809,  809,  809,  809,  809,
      809,  809,  809,  809,  809,  810,  810,  810,  810,  810,
      810,  810,  810,  810,  810,  810,  810,  810,  811,  811,

      811,  811,  811,  380,  811,  378,  811,  811,  366,  365,
      811,  812,  812,  812,  812,  812,  812,  812,  812,  812,
      812,  812,  812,  812,  813,  363,  354,  813,  813,  352,
      813,  813,  813,  350,  813,  331,  813,  814,  320,  307,
      814,  814,  305,  814,  814,  814,  301,  814,  281,  814,
      815,  815,  815,  815,  815,  815,  278,  272,  265,  815,
      815,  815,  815,  816,  262,  261,  816,  816,  258,  816,
      816,  816,  257,  816,  247,  816,  817,  817,  245,  817,
      244,  241,  239,  238,  817,  236,  233,  817,  818,  818,
      818,  818,  818,  818,  818,  818,  818,  818,  818,  818,

      818,  819,  819,  228,  819,  218,  217,  213,  212,  819,
      819,  207,  819,  820,  820,  820,  820,  820,  820,  820,
      820,  820,  820,  820,  820,  820,  821,  821,  197,  821,
      196,  194,  193,  188,  821,  822,  822,  822,  822,  822,
      822,  822,  822,  822,  822,  822,  822,  822,  823,  823,
      823,  187,  823,  186,  184,  182,  823,  823,  824,  824,
      824,  174,  824,  824,  824,  824,  824,  824,  824,  824,
      824,  825,  825,  825,  825,  825,  825,  825,  825,  825,
      825,  825,  825,  825,  826,  826,  826,  826,  826,  826,
      826,  826,  826,  826,  826,  826,  826,  827,  827,  827,

      173,  827,  827,  827,  827,  827,  827,  827,  827,  827,
      828,  828,  828,  171,  828,  828,  828,  828,  828,  828,
      828,  828,  828,  829,  829,  829,  829,  829,  829,  829,
      829,  829,  829,  829,  829,  829,  830,  830,  830,  160,
      830,  830,  830,  830,  830,  830,  830,  830,  830,  831,
      831,  831,  831,  831,  831,  831,  831,  831,  831,  831,
      831,  831,  832,  832,  832,  832,  832,  832,  832,  832,
      832,  832,  832,  832,  832,  833,  833,  833,  833,  833,
      833,  833,  833,  833,  833,  833,  833,  833,  834,  834,
      834,  834,  834,  834,  834,  834,  834,  834,  834,  834,

      834,  835,  835,  835,  835,  835,  835,  835,  835,  835,
      835,  835,  835,  835,  836,  836,  836,  836,  836,  836,
      836,  836,  836,  836,  836,  836,  836,  837,  837,  837,
      837,  837,  837,  837,  837,  837,  837,  837,  837,  837,
      838,  838,  838,  838,  838,  838,  838,  838,  838,  838,
      838,  838,  838,  839,  839,  839,  839,  839,  839,  839,
      839,  839,  839,  839,  839,  839,  840,  840,  840,  840,
      840,  840,  840,  840,  840,  840,  840,  840,  840,  841,
      841,  841,  841,  841,  841,  841,  841,  841,  841,  841,
      841,  841,  842,  842,  842,  842,  842,  842,  842,  842,

      842,  842,  842,  842,  842,  843,  843,  843,  843,  843,
      843,  843,  843,  843,  843,  843,  843,  843,  844,  844,
      844,  844,  844,  844,  844,  844,  844,  844,  844,  844,
      844,  845,  845,  845,  845,  845,  845,  845,  845,  845,
      845,  845,  845,  845,  846,  846,  846,  846,  846,  846,
      846,  846,  846,  846,  846,  846,  846,  847,  847,  847,
      847,  847,  847,  847,  847,  847,  847,  847,  847,  848,
      848,  848,  848,  848,  848,  848,  848,  848,  848,  848,
      848,  848,  849,  849,  849,  849,  849,  849,  849,  849,
      849,  849,  849,  849,  849,  850,  850,  850,  850,  850,

      850,  850,  850,  850,  850,  850,  850,  850,  851,  851,
      851,  851,  851,  851,  851,  851,  851,  851,  851,  851,
      851,  852,  852,  852,  852,  852,  852,  852,  852,  852,
      852,  852,  852,  852,  853,  853,  853,  853,  853,  853,
      853,  853,  853,  853,  853,  853,  853,  159,  157,  152,
      151,  142,  131,  125,  120,  118,  116,  115,  114,  108,
      105,   91,   90,   75,   74,   62,   48,   46,   44,   43,
       32,   24,   23,   22,   21,   18,   17,    6,    5,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,

      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803,  803,  803,  803,  803,  803,  803,
      803,  803,  803,  803
    } ;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() (yy_more_flag = 1)
#define YY_MORE_ADJ yy_more_len
#define YY_RESTORE_YY_MORE_OFFSET
#define INITIAL 0
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       parser.l
//
//  Contents:   Lex rules for parser
//
//  Notes:      Written for flex version 2.5.4
//
//  History:    10-01-97        emilyb  created
//
//----------------------------------------------------------------------------

class CValueParser;

#include "yybase.hxx"
#include "parser.h" 
#include "parsepl.h"
#include "flexcpp.h"

#define TOKEN(tknNum)  return (tknNum);
#define STRING_VALUE(tknNum, fLong, fQuote)     \
        {       \
            if (!IsTokenEmpty())        \
                return CreateTknValue(yylval, tknNum, fLong, fQuote);   \
        }

/*
** Make Lex read from a block of data
**    buffer is the character buffer,
**    result is a variable to store the number of chars read
**    ms is the size of the buffer
*/
#undef YY_INPUT
#define YY_INPUT(b, r, ms) (r = yybufferinput(b, ms))

DECLARE_INFOLEVEL(yacc)

//+---------------------------------------------------------------------------
//
//  Function:   YYLEXER::IsTokenEmpty 
//
//  Synopsis:   Determines if a token is empty. An empty token only has 
//              whitespace or has nothing in it.
//
//  Arguments:  None.
//
//  Returns:    Boolean value.
//
//  History:    08-APR-98        KrishnaN  created
//
//----------------------------------------------------------------------------

BOOL YYLEXER::IsTokenEmpty()
{
    LPWSTR pwsz = yytext;
    
    Win4Assert(pwsz);
    
    while (*pwsz != 0)
    {
        if (*pwsz != L' ' && *pwsz != L'\t')
            return FALSE;
        pwsz++;
    }
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   YYLEXER::IsNotOperator 
//
//  Synopsis:   Determines if we have a not operator.
//
//  Arguments:  None.
//
//  Returns:    Boolean value.
//
//  History:    08-DEC-98        KrishnaN  created
//
//----------------------------------------------------------------------------

BOOL YYLEXER::IsNotOperator()
{
    LPWSTR pwsz = yytext;
    
    Win4Assert(pwsz);
    
    // skip past leading spaces
    int i = 0;
    while (*pwsz != 0 && (*pwsz == L' ' || *pwsz == L'\t'))
    {
        pwsz++;
        i++;
    }
    
    // If we don't have at least four chars to consider, we don't have a 
    // not operator.
    if (yyleng < i+4)
        return FALSE;
    
    if ( (*pwsz == L'n' || *pwsz == L'N') &&
         (*(pwsz+1) == L'o' || *(pwsz+1) == L'O') &&
         (*(pwsz+2) == L't' || *(pwsz+2) == L'T') &&
         (*(pwsz+3) == L'@' || *(pwsz+3) == L'#' || *(pwsz+3) == L'$')
       )
        return TRUE;
    else
        return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   YYLEXER::CreateTknValue 
//
//  Synopsis:   Allocs a WCHAR string which is passed to the YACC value stack.  
//
//  Arguments:  [ppStg]  -- set to pointer to alloc'd memory
//              [tknNum] -- token id
//              [fLong]  -- true if token is in longhand version
//              [fQuote] -- true if token is quoted
//
//  Returns:    Updated token id
//
//  History:    10-01-97        emilyb  created
//
//----------------------------------------------------------------------------

short YYLEXER::CreateTknValue(YYSTYPE *ppStg, short tknNum, BOOL fLong, BOOL fQuote )
{
    HRESULT hr = S_OK;
    short retTkn = tknNum;
    LPWSTR pwsz = yytext;
    
    if (!fQuote)    
    {
        // If we see a double quote, consider the string quoted.
        while (L' ' == *pwsz)
            pwsz++;
        if (*pwsz == L'"')
        {
            // strip trailing blanks and check if we see a trailing "
            
            LPWSTR pLast = pwsz + wcslen(pwsz) - 1;

            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast = L'\0';
                pLast--;
            }
            
            if (*pLast == L'"' && pLast > pwsz )
                fQuote = TRUE;
        }
    }
    
    // start parsing from the beginning of the string
    pwsz = yytext;
    
    if (_PHRASEORREGEX == tknNum)
    {
        // A quoted string is always a phrase.
        if (fQuote)
            retTkn = _PHRASE;
        else
            retTkn = DetermineTokenType();
    }

    switch (retTkn)
    {
    case _PHRASE:

        {    
            LPWSTR pLast;

            pLast = pwsz + wcslen(pwsz) - 1;

            // if long version, find the phrase
            if (fLong)
            {
                pwsz = pwsz + wcslen(L"{phrase}");
                pLast = pLast - wcslen(L"{/phrase}"+1);
                Win4Assert(*pLast == L'{');
                *pLast = L'\0';
            }

            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;

            pLast = pwsz + wcslen(pwsz) - 1;

            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast = L'\0';
                pLast--;
            }    
            // NOTE: Don't strip double quotes here, they will be stripped later
            
            yaccDebugOut((DEB_ITRACE, "Phrase %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;
    case _PROPNAME:

        {
            LPWSTR pLast;
            
            if (fLong)  // looks like: { prop name = "prop name"  }
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++; 

                pLast = pwsz + wcslen(pwsz) - 1;
                Win4Assert( *pLast == L'}');
                *pLast-- = L'\0';
            }
            else
            {
                // Strip @ or # or $ token
                Win4Assert(*pwsz == L'@' || *pwsz == L'#' || *pwsz == L'$');
                pwsz = pwsz + 1;
            }

            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;

            pLast = pwsz + wcslen(pwsz) - 1;

            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast--= L'\0';
            }    

            if (fQuote)
            {
                pwsz++;
                *pLast = L'\0';                              
            }

            yaccDebugOut((DEB_ITRACE, "Propname %ws in %ws format and %ws\n", 
                          pwsz, fLong ? L"Long" : L"Short", fQuote ? L"quoted" : L"unquoted"));
        }
        break;                
    case _FREETEXT:
        {    
            LPWSTR pLast;

            // if long version, find the FREETEXT
            if (fLong)
            {
                pwsz = pwsz + wcslen(L"{freetext}");
                pLast = pwsz + wcslen(pwsz) - 1;                
                pLast = pLast - wcslen(L"{/freetext}")+1;
                Win4Assert(*pLast == L'{');
                *pLast = L'\0';
            }

            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;

            pLast = pwsz + wcslen(pwsz) - 1;

            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast = L'\0';
                pLast--;
            }    

            if (fQuote)
            {
                Win4Assert(pLast >= pwsz+1);
                // Strip quotes
                pwsz = pwsz + 1;
                *pLast = L'\0';               
            }
            
            yaccDebugOut((DEB_ITRACE, "Freetext %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;

    case _REGEX:
        {
            LPWSTR pLast;

            // if long version, find the regex
            if (fLong)
            {
                pwsz = pwsz + wcslen(L"{regex}");
                pLast = pwsz + wcslen(pwsz);                
                pLast = pLast - wcslen(L"{/regex}");
                Win4Assert(*pLast == L'{');
                *pLast = L'\0';
            }
            
            // strip leading blanks
            while (L' ' == *pwsz)
                pwsz++;
                
            // If the first char is =, ignore it. We only ignore the first
            // = character. This is backward compatible with Triplish1
            if (L'=' == *pwsz)
                pwsz++;

            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;
                
            pLast = pwsz + wcslen(pwsz) - 1;
            
            while (pLast >= pwsz && L' ' == *pLast )
            {
                *pLast = L'\0';
                pLast--;
            }    
                
            // After we strip a leading =, we might have a quoted phrase
            // Check only if fQuote is false.
            // We don't want to deal with an unpaired double quote.
            if (!fQuote && *pwsz == L'"' && *pLast == L'"' && pLast > pwsz )
                fQuote = TRUE;
                
            if (fQuote)
            {
                Win4Assert(pLast >= pwsz+1);
                // Strip quotes
                pwsz = pwsz + 1;
                *pLast = L'\0';               
            }
            
            yaccDebugOut((DEB_ITRACE, "RegEx %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;                

    case _WEIGHT:
        {  
            Assert (fLong);
            Assert(!fQuote);
            if (fLong)  // looks like: {weight value = number }
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++;

                // step past leading blanks
                while (L' ' == *pwsz)
                    pwsz++;

                // remove trailing } and blanks
                LPWSTR pLast = pwsz + wcslen(pwsz) - 1;
                Win4Assert(*pLast == L'}');
                *(pLast--) = L'\0';

                while (pLast >= pwsz && L' ' == *pLast )
                {
                    *(pLast--) = L'\0';
                }    
            }
        }
        break;                

    case _NEARDIST:
        {  
            Assert (fLong);
            Assert(!fQuote);
            if (fLong)  // looks like: dist = number
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++;

                // step past leading blanks
                while (L' ' == *pwsz)
                    pwsz++;
            }
            
            yaccDebugOut((DEB_ITRACE, "NearDist string: %ws in %s format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;                
    case _NEARUNIT:
        {  
            Assert (fLong);
            Assert(!fQuote);
            if (fLong)  // looks like: unit = blah
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++;

                // step past leading blanks
                while (L' ' == *pwsz)
                    pwsz++;
            }
            
            yaccDebugOut((DEB_ITRACE, "NearUnit string: %ws in %s format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break; 
    case _VECTORELEMENT:
        {              
            // strip leading and trailing blanks            
            while (L' ' == *pwsz)
                pwsz++;

            LPWSTR pTemp = pwsz + wcslen(pwsz) - 1;

            if (fLong)  // strip trailing ; 
            {
                Win4Assert(L';' == *pTemp);
                *pTemp--='\0';
            }

            while (L' ' == *pTemp && pTemp > pwsz)
                *pTemp-- = L'\0';

            if (fQuote)
            {
                // Strip quotes
                pwsz = pwsz + 1;
                pwsz[wcslen(pwsz)-1] = L'\0';               
            }

            yaccDebugOut((DEB_ITRACE, "VectorElem %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break;                        
    case _VEMETHOD:
        { 
            Assert (fLong);

            LPWSTR pTemp;

            if (fLong)  // looks like: {vector rankmethod= blah}
            {
                // find =
                while (L'=' != *pwsz)
                    pwsz++;
                pwsz++;

                // strip trailing }
                pTemp = pwsz + wcslen(pwsz) - 1;               
                Win4Assert(L'}' == *pTemp);
                *pTemp-- = L'\0';

            }

            // strip leading and trailing blanks and quotes          
            while (L' ' == *pwsz)
                pwsz++;

            pTemp = pwsz + wcslen(pwsz) - 1;

            while (L' ' == *pTemp && pTemp > pwsz)
                *pTemp-- = L'\0';

            if (fQuote)
            {
                // Strip quotes
                pwsz = pwsz + 1;
                pwsz[wcslen(pwsz)-1] = L'\0';               
            }
            
            yaccDebugOut((DEB_ITRACE, "VectorMethod %ws in %ws format\n",  pwsz, fLong ? L"Long" : L"Short"));
        }
        break; 


    }

    int len = wcslen(pwsz);
    XPtrST<WCHAR> xwszRet(new WCHAR[len + 1]);
    
    _allocations.Add(xwszRet.GetPointer(), _allocations.Count());
    
    RtlCopyMemory(xwszRet.GetPointer(), pwsz, (len+1) * sizeof(WCHAR));
    (*ppStg).pwszChar = xwszRet.Acquire();
    
    return retTkn;
}        


//+---------------------------------------------------------------------------
//
//  Function:   YYLEXER::DetermineTokenType 
//
//  Synopsis:   Determines if we have a regular expression or a regular string.  
//              A  regular expression is a string that contains atleast one of
//              *, ?, or | characters.
//
//  Returns:    Token id
//
//  History:    Jun-05-98        KrishnaN  created
//
//----------------------------------------------------------------------------

short YYLEXER::DetermineTokenType()
{
    LPWSTR pwsz = yytext;
    
    LPWSTR pLast = pwsz + wcslen(pwsz) - 1;

    while (pLast >= pwsz)
    {
        if (L'|' == *pwsz || L'*' == *pwsz || L'?' == *pwsz)
            return _REGEX;
            
        pwsz++;
    }    
    
    // None of the regular expression defining characters have been found
    return _PHRASE;
}        


        //
        // 
        //    RULES       
        // 
        // Notes:  Any characters which are not matched, cause yylexer to throw.
        //         We can also throw if E_OUTOFMEMORY.
        //         Tokens which need 2 return more than 1 value (e.g. {near}
        //         use start states to return each pice of the value. The start
        //         states also emit a "token end" token so that the parser can
        //         check that they are syntactically complete.
        //         Lex matches to the longest match in the rules.  If 2 matches
        //         are the same, it matches to the 1st match. 
#define innear 1

#define shortgen 2

#define shortregex 3

#define mayberegex 4

#define implicitphrase 5

#define infreefreetext 6

#define invector 7


/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
 int yywrap YY_PROTO(( void )) {return 1;}
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif


#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( YY_CHAR *, yyconst YY_CHAR *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst YY_CHAR * ));
#endif

#ifndef YY_NO_INPUT
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE (8192 / sizeof(WCHAR))
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
#define ECHO LexerOutput( yytext, yyleng )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( (result = LexerInput( (YY_CHAR *) buf, max_size )) < 0 ) \
                YY_FATAL_ERROR( L"input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) LexerError( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int YYLEXER::yylex(YYSTYPE *yylval)
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
        {
        register yy_state_type yy_current_state;
        register YY_CHAR *yy_cp, *yy_bp;
        register int yy_act;




        if ( yy_init )
                {
                yy_init = 0;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yy_start )
                        yy_start = 1;   /* first start state */

                if ( ! yy_current_buffer )
                        yy_current_buffer =
                                yy_create_buffer( (cInputBuffer * sizeof(YY_CHAR)) + sizeof(YY_CHAR) );

                yy_load_buffer_state();

                if (yyprimetoken)
                        {
                        int yysavetoken = yyprimetoken;
                        yyprimetoken = 0;
                        return yysavetoken;
                        } 
                }

        while ( 1 )             /* loops until end-of-file is reached */
                {
		yy_more_len = 0;
		if ( yy_more_flag )
			{
			yy_more_len = (int) (yy_c_buf_p - yytext_ptr);
			yy_more_flag = 0;
			}
                yy_cp = yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = 1; if (256 > *yy_cp) yy_c = (YY_CHAR) yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 804 )
					yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 803 );
		yy_cp = yy_last_accepting_cpos;
		yy_current_state = yy_last_accepting_state;

yy_find_action:
		yy_act = yy_accept[yy_current_state];

                YY_DO_BEFORE_ACTION;


do_action:      /* This label is used only to access EOF actions. */


                switch ( yy_act )
        { /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
{ /* do nothing */ }
	YY_BREAK
case 2:
YY_RULE_SETUP
{    fContinueImplicitPhrase = FALSE;
                        fContinueRegex = FALSE;
                        fContinueMaybeRegex = FALSE;
                        TOKEN (_OPEN);
                   }
	YY_BREAK
case 3:
YY_RULE_SETUP
{
                        fContinueImplicitPhrase = FALSE;
                        fContinueRegex = FALSE;
                        fContinueMaybeRegex = FALSE;
                        TOKEN (_CLOSE); 
                   }
	YY_BREAK
// ************
      // PROPNAME
      // ************
 // If something was treated as a phrase in Tripolish 1, it should
       // be treated as such even now. That applies here. For e.g. @propname
       // caused the following text to be treated as a phrase. The same should
       // apply to {prop name = propname}
       // 

// shorthand, quoted
case 4:
YY_RULE_SETUP
{ 
                                            // treat value as a phrase
                                            BEGIN implicitphrase;
                                            STRING_VALUE(_PROPNAME, FALSE, TRUE);
                                        }     
	YY_BREAK
// shorthand, not quoted
case 5:
YY_RULE_SETUP
{ 
                                            // treat value as a phrase
                                            BEGIN implicitphrase;
                                            STRING_VALUE(_PROPNAME, FALSE, FALSE);
                                        }
	YY_BREAK
// shorthand, quoted
case 6:
YY_RULE_SETUP
{ 
                                            // treat value as freetext
                                            BEGIN infreefreetext;
                                            STRING_VALUE(_PROPNAME, FALSE, TRUE);
                                        }     
	YY_BREAK
// shorthand, not quoted
case 7:
YY_RULE_SETUP
{ 
                                            // treat value as freetext
                                            BEGIN infreefreetext;
                                            STRING_VALUE(_PROPNAME, FALSE, FALSE);
                                        }    
	YY_BREAK
// longhand, quoted
case 8:
YY_RULE_SETUP
{ 
                                            // treat value as a phrase
                                            BEGIN implicitphrase;
                                            STRING_VALUE(_PROPNAME, TRUE, TRUE);
                                        }
	YY_BREAK
// longhand, not quoted
case 9:
YY_RULE_SETUP
{ 
                                            // treat value as a phrase
                                            BEGIN implicitphrase;
                                            STRING_VALUE(_PROPNAME, TRUE, FALSE);
                                        }
	YY_BREAK
// closing token
case 10:
YY_RULE_SETUP
{ TOKEN (_PROPEND); }
	YY_BREAK
// *********
     // OPERATORS
     // *********
case 11:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_CONTAINS); 
                 }
	YY_BREAK
case 12:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_AND);
                 }
	YY_BREAK
case 13:
YY_RULE_SETUP
{ 
		   yyless(yyleng-1);
		   if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_AND);
                 }		 
	YY_BREAK
case 14:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
		       yaccDebugOut(( DEB_ITRACE, "fContinueImplicitPhrase\n" )); 
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
		       yaccDebugOut(( DEB_ITRACE, "fContinueRegex\n" ));  
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
		       yaccDebugOut(( DEB_ITRACE, "fContinueMaybeRegex\n" ));  
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
		   yaccDebugOut(( DEB_ITRACE, "OR TOKEN found !!!\n" ));
                   TOKEN (_OR); }
	YY_BREAK
case 15:
YY_RULE_SETUP
{ 
		   yyless(yyleng-1);
		   if (fContinueImplicitPhrase)
                   {
		       yaccDebugOut(( DEB_ITRACE, "OR{ fContinueImplicitPhrase\n" )); 
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
		       yaccDebugOut(( DEB_ITRACE, "OR{ fContinueRegex\n" ));  
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
		       yaccDebugOut(( DEB_ITRACE, "OR{ fContinueMaybeRegex\n" ));  
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
		   yaccDebugOut(( DEB_ITRACE, "OR{ TOKEN found !!!\n" ));
                   TOKEN (_OR); }     	   
	YY_BREAK
case 16:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_NOT);}
	YY_BREAK
case 17:
YY_RULE_SETUP
{ 
		   yyless(yyleng-1);
		   if (fContinueImplicitPhrase)
		   {
		       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_NOT);}		   
	YY_BREAK
case 18:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_AND);}
	YY_BREAK
case 19:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_OR);}
	YY_BREAK
case 20:
YY_RULE_SETUP
{ if (fContinueImplicitPhrase)
                   {
                       BEGIN implicitphrase;
                       fContinueImplicitPhrase = FALSE;
                   }
                   else if (fContinueRegex)
                   {
                       BEGIN shortregex;
                       fContinueRegex = FALSE;
                   }
                   else if (fContinueMaybeRegex)
                   {
                       BEGIN mayberegex;
                       fContinueMaybeRegex = FALSE;
                   }
                   TOKEN (_NOT);}
	YY_BREAK
case 21:
YY_RULE_SETUP
{ yaccDebugOut(( DEB_ITRACE, "near[ ]+ _NEAR token, begin implicitphrase\n" ));
		   BEGIN implicitphrase;
                   TOKEN (_NEAR);}
	YY_BREAK
case 22:
YY_RULE_SETUP
{ yaccDebugOut(( DEB_ITRACE, "near{ _NEAR token, begin implicitphrase\n" ));
		   yyless(yyleng-1);
		   BEGIN implicitphrase;
                   TOKEN (_NEAR);}			   
	YY_BREAK
case 23:
YY_RULE_SETUP
{ BEGIN implicitphrase;
                   TOKEN (_NEAR);}
	YY_BREAK
case 24:
YY_RULE_SETUP
{ TOKEN (_LT);}
	YY_BREAK
case 25:
YY_RULE_SETUP
{ TOKEN (_GT);}
	YY_BREAK
case 26:
YY_RULE_SETUP
{ TOKEN (_LTE);}
	YY_BREAK
case 27:
YY_RULE_SETUP
{ TOKEN (_GTE);}
	YY_BREAK
case 28:
YY_RULE_SETUP
{ if (fContinueMaybeRegex) 
                      {
                          // We are not sure if we are going to find a
                          // regular expression or a phrase.
                          
                          BEGIN mayberegex;
                          fContinueMaybeRegex = FALSE;
                      }
                      TOKEN (_EQ);
                    }
	YY_BREAK
case 29:
YY_RULE_SETUP
{ TOKEN (_NE); }
	YY_BREAK
case 30:
YY_RULE_SETUP
{ TOKEN (_ALLOF); }
	YY_BREAK
case 31:
YY_RULE_SETUP
{ TOKEN (_SOMEOF); }
	YY_BREAK
case 32:
case 33:
YY_RULE_SETUP
{ TOKEN (_LTSOME); }
	YY_BREAK
case 34:
case 35:
YY_RULE_SETUP
{ TOKEN (_GTSOME); }
	YY_BREAK
case 36:
case 37:
YY_RULE_SETUP
{ TOKEN (_LTESOME); }
	YY_BREAK
case 38:
case 39:
YY_RULE_SETUP
{ TOKEN (_GTESOME); }
	YY_BREAK
case 40:
case 41:
YY_RULE_SETUP
{ TOKEN (_EQSOME); }
	YY_BREAK
case 42:
case 43:
YY_RULE_SETUP
{ TOKEN (_NESOME); }
	YY_BREAK
case 44:
YY_RULE_SETUP
{ TOKEN (_ALLOFSOME); }
	YY_BREAK
case 45:
YY_RULE_SETUP
{ TOKEN (_SOMEOFSOME); }
	YY_BREAK
case 46:
case 47:
YY_RULE_SETUP
{ TOKEN (_LTALL); }
	YY_BREAK
case 48:
case 49:
YY_RULE_SETUP
{ TOKEN (_GTALL); }
	YY_BREAK
case 50:
case 51:
YY_RULE_SETUP
{ TOKEN (_LTEALL); }
	YY_BREAK
case 52:
case 53:
YY_RULE_SETUP
{ TOKEN (_GTEALL); }
	YY_BREAK
case 54:
case 55:
YY_RULE_SETUP
{ TOKEN (_EQALL); }
	YY_BREAK
case 56:
case 57:
YY_RULE_SETUP
{ TOKEN (_NEALL); }
	YY_BREAK
case 58:
YY_RULE_SETUP
{ TOKEN (_ALLOFALL); }
	YY_BREAK
case 59:
YY_RULE_SETUP
{ TOKEN (_SOMEOFALL); }
	YY_BREAK
// *************
     // VECTOR SPACE TOKENS
     // *************
case 60:
YY_RULE_SETUP
{ STRING_VALUE(_VEMETHOD, TRUE, TRUE); }
	YY_BREAK
case 61:
YY_RULE_SETUP
{ STRING_VALUE(_VEMETHOD, TRUE, FALSE); }
	YY_BREAK
case 62:
YY_RULE_SETUP
{
                                                    // makes more sense to enter phrase mode
                                                    // rather than freetext mode.
                                                    fContinueImplicitPhrase = TRUE;
                                                    BEGIN implicitphrase;
                                                    TOKEN (_VE);
                                                }
	YY_BREAK
case 63:
YY_RULE_SETUP
{ TOKEN (_VECTOR_END); }
	YY_BREAK
// *************
      // longhand NEAR
      // *************
// must return both unit and distance, so use start state to pull them out, and 
      // return _NEAR_END so parser knows we hit the closing }  

case 64:
YY_RULE_SETUP
{ yaccDebugOut(( DEB_ITRACE, "Longhand _NEAR token, begin innear\n" ));
		  BEGIN innear; }
	YY_BREAK
case 65:
YY_RULE_SETUP
{ yaccDebugOut(( DEB_ITRACE, "Longhand _NEAR{ token, begin innear\n" ));
		  yyless(yyleng-1);
		  BEGIN innear; }
	YY_BREAK
// ************
     // WEIGHT
     // ************
case 66:
YY_RULE_SETUP
{ 
							  if (fContinueImplicitPhrase)
							  {
							      BEGIN implicitphrase;
							      fContinueImplicitPhrase = FALSE;
							  }
						
							  yaccDebugOut(( DEB_ITRACE, "_WEIGHT TOKEN FOUND!!\n" ));
							  STRING_VALUE(_WEIGHT,TRUE,FALSE);
						      }
	YY_BREAK
case 67:
YY_RULE_SETUP
{
                        if (fContinueImplicitPhrase)
                        {
                            BEGIN implicitphrase;
                            fContinueImplicitPhrase = FALSE;
                        }
                        TOKEN (_COERCE); }
	YY_BREAK
// ****************
     // longhand GENERATE
     // ****************
case 68:
YY_RULE_SETUP
{
                                                    if (fContinueImplicitPhrase)
                                                    {
                                                        BEGIN implicitphrase;
                                                        fContinueImplicitPhrase = FALSE;
                                                    }
                                                    yaccDebugOut((DEB_ITRACE, "Prefix recognized.\n"));
                                                    TOKEN(_GENPREFIX);
                                                }
	YY_BREAK
case 69:
YY_RULE_SETUP
{
                                                    if (fContinueImplicitPhrase)
                                                    {
                                                        BEGIN implicitphrase;
                                                        fContinueImplicitPhrase = FALSE;
                                                    }
                                                    yaccDebugOut((DEB_ITRACE, "Inflect recognized.\n"));
                                                    TOKEN(_GENINFLECT);
                                                }
	YY_BREAK
case 70:
YY_RULE_SETUP
{ TOKEN (_GENNORMAL); }
	YY_BREAK
// ****************
      // longhand REGEX
      // ****************
case 71:
YY_RULE_SETUP
{ STRING_VALUE(_REGEX,TRUE,TRUE);}
	YY_BREAK
case 72:
YY_RULE_SETUP
{ STRING_VALUE(_REGEX,TRUE,FALSE);}
	YY_BREAK
case 73:
YY_RULE_SETUP
{ STRING_VALUE(_REGEX,TRUE,FALSE);}
	YY_BREAK
// ****************
      // shorthand REGEX
      // ****************
// shorthand, quoted
case 74:
YY_RULE_SETUP
{ 
                                            // Get into short form of reg expression
                                            BEGIN shortregex;
                                            STRING_VALUE(_PROPNAME, FALSE, TRUE);
                                        }     
	YY_BREAK
// shorthand, not quoted
case 75:
YY_RULE_SETUP
{
                                            // Get into short form of reg expression
                                            BEGIN shortregex;
                                            STRING_VALUE(_PROPNAME, FALSE, FALSE);
                                        }    
	YY_BREAK
// ***************
      // longhand PHRASE                                            
      // ***************
// quoted, with trailing * or **
case 76:
YY_RULE_SETUP
{
                                                // trailing * has to be for inflection - 
                                                // process it in shortgen on next pass.  
                                                // Grab phrase now.
                                                yyless(yyleng-1); 
                                                BEGIN shortgen; 
                                                STRING_VALUE(_PHRASE,TRUE,TRUE); 
                                            }
	YY_BREAK
// quoted, without trailing * or **
case 77:
YY_RULE_SETUP
{   
                                                // no trailing * -- phrase only
                                                STRING_VALUE(_PHRASE,TRUE,TRUE);
                                            }
	YY_BREAK
// unquoted, with trailing * or **
case 78:
YY_RULE_SETUP
{  
                                                // trailing * has to be for inflection - 
                                                // process it in shortgen on next pass.  
                                                // Grab phrase now.
                                                yyless(yyleng-1); 
                                                BEGIN shortgen; 
                                                STRING_VALUE(_PHRASE,TRUE,FALSE); 
                                            }
	YY_BREAK
// unquoted, without trailing * or **
case 79:
YY_RULE_SETUP
{   
                                                // no trailing * -- phrase only
                                                STRING_VALUE(_PHRASE,TRUE,FALSE); 
                                            }
	YY_BREAK
// *************                                        
      // shorthand PHRASE                                            
      // *************
// with trailing * or **
case 80:
YY_RULE_SETUP
{
                                                // trailing * has to be for inflection -        
                                                // process it in shortgen on next pass.  
                                                // Grab phrase now.
                                                yyless(yyleng-1); 
                                                BEGIN shortgen;
                                                STRING_VALUE(_PHRASE, FALSE, TRUE); 
                                            } 
	YY_BREAK
 // without trailing * or **
case 81:
YY_RULE_SETUP
{
                                                // no trailing * -- phrase only 
                                                STRING_VALUE(_PHRASE, FALSE, TRUE); 
                                            }
	YY_BREAK
// *****************
    // longhand FREETEXT
    // *****************
// quoted, with trailing * or **
case 82:
YY_RULE_SETUP
{
                                                    // trailing * has to be for inflection - 
                                                    // process it in shortgen on next pass.  
                                                    // Grab freetext now.
                                                    yyless(yyleng-1); 
                                                    BEGIN shortgen;
                                                    STRING_VALUE(_FREETEXT,TRUE,TRUE); 
                                                }
	YY_BREAK
// quoted, without trailing * or **
case 83:
YY_RULE_SETUP
{
                                                    // no trailing * -- freetext  only
                                                    STRING_VALUE(_FREETEXT,TRUE,TRUE); 
                                                }
	YY_BREAK
// unquoted, with trailing * or **
case 84:
YY_RULE_SETUP
{
                                                    // trailing * has to be for inflection - 
                                                    // process it in shortgen on next pass.  
                                                    // Grab freetext now.
                                                    yyless(yyleng-1); 
                                                    BEGIN shortgen;
                                                    STRING_VALUE(_FREETEXT,TRUE,FALSE); 
                                                }
	YY_BREAK
// unquoted, without trailing * or **
case 85:
YY_RULE_SETUP
{
                                                    // no trailing * -- freetext  only
                                                    STRING_VALUE(_FREETEXT,TRUE,FALSE); 
                                                }
	YY_BREAK
// ******************
      // shorthand FREETEXT 
      // ******************
case 86:
YY_RULE_SETUP
{
                                            // For backward compatibility, we want to special
                                            // case and recognize the "not" operator when it
                                            // is immediately followed by a mode specifier character
                                            // (@, $, #). For e.g. "not@size > 2" should be treated
                                            // as if we have a "not" operator followed by "@size > 2".
                                            // Without this special case, "not@size > 2" gets recognized
                                            // as free text.
                                            
                                            if (IsNotOperator())
                                            {
                                                yyless(3);
                                                BEGIN INITIAL;
                                                TOKEN(_NOT);
                                            }
                                            
                                            yaccDebugOut(( DEB_ITRACE, "fTreatFreetextAsPhrase is %d\n", fTreatFreetextAsPhrase ));
                                            if (fTreatFreetextAsPhrase)
                                                BEGIN implicitphrase;
                                            else
                                                BEGIN infreefreetext;
                                        
                                            fTreatFreetextAsPhrase = FALSE;    
                                            yymore();
                                        }  
	YY_BREAK
case 87:
YY_RULE_SETUP
{
                                            // IsNotOperator is used here for the same reason as the
                                            // use above, except that this rule covers situations where
                                            // we have no spaces in the query. E.g. "not@size>2". 
                                            // This should be equivalent to 
                                            // "not@size > 2", which in turn should be equivalent to
                                            // "not @size > 2"
                                            
                                            if (IsNotOperator())
                                            {
                                                yyless(3);
                                                BEGIN INITIAL;
                                                TOKEN(_NOT);
                                            }
                                            
                                            if (fTreatFreetextAsPhrase)
                                            {
                                                STRING_VALUE(_PHRASE,FALSE,FALSE);
                                            }
                                            else
                                            {
                                                STRING_VALUE(_FREETEXT,FALSE,FALSE);
                                            }
                                            
                                            fTreatFreetextAsPhrase = FALSE;
                                        }  
	YY_BREAK
// *************
      // VECTOR VALUES
      // *************
// quoted multi-value vector - has ; separator.  Singlets caught in parser
case 88:
YY_RULE_SETUP
{ BEGIN invector; yyless(1);}
	YY_BREAK
// unquoted multi-value vector - has ; separator.  Singlets caught in parser
case 89:
YY_RULE_SETUP
{ BEGIN invector; yyless(1);}
	YY_BREAK
// 
    // INNEAR: longhand NEAR processing
    // 

case 90:
YY_RULE_SETUP
{}
	YY_BREAK
case 91:
YY_RULE_SETUP
{}
	YY_BREAK
case 92:
YY_RULE_SETUP
{ STRING_VALUE(_NEARDIST,TRUE,FALSE);}
	YY_BREAK
case 93:
YY_RULE_SETUP
{ STRING_VALUE(_NEARUNIT,TRUE,FALSE);}  
	YY_BREAK
case 94:
YY_RULE_SETUP
{ STRING_VALUE(_NEARUNIT,TRUE,FALSE);} 
	YY_BREAK
case 95:
YY_RULE_SETUP
{ STRING_VALUE(_NEARUNIT,TRUE,FALSE);}
	YY_BREAK
case 96:
YY_RULE_SETUP
{ STRING_VALUE(_NEARUNIT,TRUE,FALSE);}
	YY_BREAK
case 97:
YY_RULE_SETUP
{ BEGIN implicitphrase; TOKEN (_NEAR_END);} 
	YY_BREAK
// 
      // INVECTOR: multi value vector processing
      // 

case 98:
YY_RULE_SETUP
{}
	YY_BREAK
case 99:
YY_RULE_SETUP
{}
	YY_BREAK
case 100:
YY_RULE_SETUP
{ STRING_VALUE(_VECTORELEMENT, FALSE, TRUE);}
	YY_BREAK
case 101:
YY_RULE_SETUP
{ STRING_VALUE(_VECTORELEMENT, TRUE, FALSE);}
	YY_BREAK
case 102:
YY_RULE_SETUP
{
                                //  Need to emit _VECTORELEMENT and _VE_END -- so backup 1
                                //  so we can emit _VE_END on next pass                               
                                yyless(yyleng-1);
                                STRING_VALUE(_VECTORELEMENT, FALSE, FALSE);
                            }
	YY_BREAK
case 103:
YY_RULE_SETUP
{ BEGIN INITIAL; TOKEN (_VE_END); } 
	YY_BREAK
// 
      // INFREEFREETEXT: shorthand FREETEXT processing
      //
      // NOTE:  and, or, near need to be localized
case 104:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 105:
YY_RULE_SETUP
{
                                yyless(yyleng-4); 
                                BEGIN INITIAL;                        
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }  
	YY_BREAK
case 106:
YY_RULE_SETUP
{
                                yyless(yyleng-4); 
                                BEGIN INITIAL;                        
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }  			    
	YY_BREAK
case 107:
YY_RULE_SETUP
{ 
                                yyless(yyleng-3); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }
	YY_BREAK
case 108:
YY_RULE_SETUP
{ 
                                yyless(yyleng-3); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }			    
	YY_BREAK
case 109:
YY_RULE_SETUP
{ 
				yaccDebugOut(( DEB_ITRACE, "{infreefreetext}{near}[ ]\n" ));
                                yyless(yyleng-5); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 110:
YY_RULE_SETUP
{ 
				yaccDebugOut(( DEB_ITRACE, "{infreefreetext}{near}{\n" ));
                                yyless(yyleng-5); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 111:
YY_RULE_SETUP
{ 
				yaccDebugOut(( DEB_ITRACE, "{infreefreetext}{{near}\n" ));
                                yyless(yyleng-6); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 112:
YY_RULE_SETUP
{ 
				yaccDebugOut(( DEB_ITRACE, "{infreefreetext}{{near}{\n" ));
                                yyless(yyleng-6); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }			    
	YY_BREAK
case 113:
YY_RULE_SETUP
{
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }  
	YY_BREAK
case 114:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }
	YY_BREAK
case 115:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                fTreatFreetextAsPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 116:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }                             
	YY_BREAK
case 117:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE); 
                            }                             
	YY_BREAK
case 118:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE);
                            }
	YY_BREAK
case 119:
YY_RULE_SETUP
{ 
                                BEGIN INITIAL;
                                STRING_VALUE(_FREETEXT,FALSE,FALSE);
                            }
	YY_BREAK
case 120:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 121:
YY_RULE_SETUP
{
				      BEGIN INITIAL;
				      STRING_VALUE(_FREETEXT,FALSE,FALSE); 
				  }   
	YY_BREAK
// 
      // SHORTGEN:  * or ** processing
      //
      // can only get here by backing up over *, 
      // so we will always find a match
case 122:
YY_RULE_SETUP
{  
                   BEGIN INITIAL; 
                   TOKEN(_SHGENINFLECT);
                }
	YY_BREAK
case 123:
YY_RULE_SETUP
{   
                   BEGIN INITIAL; 
                   TOKEN(_SHGENPREFIX); 
                }
	YY_BREAK
//
      // SHORTREGEX: #propname processing
      //
      // can only get here when #"propname" or #propname
      // (quoted or unquoted) version is detected.
      // NOTE:  and, or need to be localized
      // NOTE:  It doesn't make sense to have the near operator following 
      //        a regular expression. A regex is Boolean and doesn't evaluate
      //        to a position value. 
      //
      //
      

case 124:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 125:
YY_RULE_SETUP
{
                          // ignore equal operators...
                          BEGIN shortregex;
                        }
	YY_BREAK
case 126:
YY_RULE_SETUP
{ STRING_VALUE(_REGEX, FALSE, TRUE);}
	YY_BREAK
case 127:
YY_RULE_SETUP
{
                            fContinueRegex = TRUE;
                            yyless(yyleng-4); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }  
	YY_BREAK
case 128:
YY_RULE_SETUP
{ 
                            fContinueRegex = TRUE;
                            yyless(yyleng-3); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 129:
YY_RULE_SETUP
{ 
                                yyless(yyleng-4); 
                                // The only valid way to get here is to
                                // have had seen "and" before. Don't recognize
                                // a regex. Back off and let the lexer takes its
                                // normal course.
                                fContinueRegex = TRUE;
                                BEGIN INITIAL;
                        }                           
	YY_BREAK
case 130:
YY_RULE_SETUP
{
                            fContinueRegex = TRUE;
                            yyless(yyleng-1); 
                            BEGIN INITIAL;                        
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }  
	YY_BREAK
case 131:
YY_RULE_SETUP
{ 
                            fContinueRegex = TRUE;
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 132:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            // The only valid way to get here is to
                            // have had seen "and" before. Don't recognize
                            // a phrase. Back off and let the lexer takes its
                            // normal course.
                            fContinueRegex = TRUE;
                            BEGIN INITIAL;
                        }                           
	YY_BREAK

    // When we find an operator we should treat it as one. 
    // So backup and get out if you see one.
    // Normally '^' is treated as part of an operator (e.g. ^a), but it also 
    // has a special meaning in regular expression syntax. So we will have to
    // let it through when it is part of a regular expression. As an alternative,
    // we can allow '^' in regular expression in a limited manner (i.e. only the use
    // in square brackets to exclude the set of chars "[^abc]" where abc are excluded).
    // This alternative will let the common case use of '^' in a regular expression
    // while allowing it to be treated as part of an operator when it doesn't 
    // occur immediately after a '['.
    // We are implementing the alternative here because our regex capability
    // only allows for the "[^" construct.

case 133:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1);
                            fContinueRegex = FALSE;
                            BEGIN INITIAL;
                        }
	YY_BREAK
case 134:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }                             
	YY_BREAK
case 135:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }                             
	YY_BREAK
case 136:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }                     
	YY_BREAK
case 137:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 138:
YY_RULE_SETUP
{
                            fContinueRegex = TRUE;
                            BEGIN INITIAL;
                            STRING_VALUE(_REGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 139:
YY_RULE_SETUP
{
                            yyless(yyleng-4); 
                            fContinueMaybeRegex = TRUE;
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }  
	YY_BREAK
case 140:
YY_RULE_SETUP
{ 
                            yyless(yyleng-3); 
                            fContinueMaybeRegex = TRUE;
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 141:
YY_RULE_SETUP
{ 
                            yyless(yyleng-4); 
                            // The only valid way to get here is to
                            // have had seen "and" before. Don't recognize
                            // a regex. Back off and let the lexer takes its
                            // normal course.
                            fContinueMaybeRegex = TRUE;
                            BEGIN INITIAL;
                        }                           
	YY_BREAK
case 142:
YY_RULE_SETUP
{
                            fContinueMaybeRegex = TRUE;
                            yyless(yyleng-1); 
                            BEGIN INITIAL;                        
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }  
	YY_BREAK
case 143:
YY_RULE_SETUP
{ 
                            fContinueMaybeRegex = TRUE;
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 144:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            // The only valid way to get here is to
                            // have had seen "and" before. Don't recognize
                            // a phrase. Back off and let the lexer takes its
                            // normal course.
                            fContinueMaybeRegex = TRUE;
                            BEGIN INITIAL;
                        }                           
	YY_BREAK
case 145:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }                             
	YY_BREAK
case 146:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }                             
	YY_BREAK
case 147:
YY_RULE_SETUP
{ 
                            yyless(yyleng-1); 
                            BEGIN INITIAL;
                            STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                        }
	YY_BREAK
case 148:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 149:
YY_RULE_SETUP
{ STRING_VALUE(_PHRASE, FALSE, TRUE);}
	YY_BREAK
case 150:
YY_RULE_SETUP
{   yymore(); }
	YY_BREAK
case 151:
YY_RULE_SETUP
{
                                 fContinueMaybeRegex = TRUE;
                                 BEGIN INITIAL;
                                 STRING_VALUE(_PHRASEORREGEX,FALSE,FALSE); 
                            }
	YY_BREAK

    // When we find an operator at the start of a phrase, 
    // we should treat it as one. So backup and get out if you see one.

case 152:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1);
                                fContinueMaybeRegex = FALSE;
                                BEGIN INITIAL;
                            }
	YY_BREAK
//
      // IMPLICITPHRASE: Where phrase is implied.
      //
      // can only get here when @propname or {prop name = propname} is detected.
      // NOTE:  and, or, not need to be localized when time permits.
      //
      // NTRAID#DB-NTBUG9-84571-2000/07/31-dlee Indexing Service tripolish2 query expressions misinterpreted as strings
      // if expression has trailing blanks, we'll emit a string value

case 153:
YY_RULE_SETUP
{   
				fContinueImplicitPhrase = FALSE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE, FALSE, TRUE);
                            }    
	YY_BREAK
case 154:
YY_RULE_SETUP
{   yymore(); }
	YY_BREAK
case 155:
YY_RULE_SETUP
{
				yyless(yyleng-4);
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }  
	YY_BREAK
case 156:
YY_RULE_SETUP
{ 
                                yyless(yyleng-3);
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 157:
YY_RULE_SETUP
{ 
                                yyless(yyleng-5); 
                                // We want to treat the following token as a phrase
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 158:
YY_RULE_SETUP
{ 
                                yyless(yyleng-5); 
                                // We want to treat the following token as a phrase
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }			    
	YY_BREAK
case 159:
YY_RULE_SETUP
{ 
                                yyless(yyleng-4); 
                                // The only valid way to get here is to
                                // have had seen "and" before. Don't recognize
                                // a phrase. Back off and let the lexer takes its
                                // normal course.
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                            }                           
	YY_BREAK
case 160:
YY_RULE_SETUP
{
                                yyless(yyleng-1);
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }  
	YY_BREAK
case 161:
YY_RULE_SETUP
{
                                yyless(yyleng-1); 
                                // We want to treat the following token as a phrase
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;                        
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }  
	YY_BREAK
case 162:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                // The only valid way to get here is to
                                // have had seen "and" before. Don't recognize
                                // a phrase. Back off and let the lexer takes its
                                // normal course.
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                            }                           
	YY_BREAK
case 163:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1); 
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 164:
YY_RULE_SETUP
{
                                yyless(yyleng-1); 
                                fContinueImplicitPhrase = FALSE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 165:
YY_RULE_SETUP
{
                                yyless(yyleng-1); 
                                fContinueImplicitPhrase = FALSE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }                             
	YY_BREAK
case 166:
YY_RULE_SETUP
{
                                yyless(yyleng-1);
                                fContinueImplicitPhrase = TRUE; 
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE); 
                            }
	YY_BREAK
case 167:
YY_RULE_SETUP
{
                                yyless(yyleng-9);
                                fContinueImplicitPhrase = TRUE;
                                BEGIN INITIAL;
                                STRING_VALUE(_PHRASE,FALSE,FALSE);
                              }                           
	YY_BREAK

    // When we find an operator at the start of an implicit phrase, 
    // we should treat it as one. So backup and get out if you see one.

case 168:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1);
                                fContinueImplicitPhrase = FALSE;
                                BEGIN INITIAL;
                            }
	YY_BREAK

    // Triplish2 uses = to indicate that whatever appears after it may 
    // be using wildcards. Implement that here.

case 169:
YY_RULE_SETUP
{ 
                                yyless(yyleng-1);
                                fContinueMaybeRegex = TRUE;
                                BEGIN INITIAL;
                            }                            
	YY_BREAK
case 170:
YY_RULE_SETUP
{ yymore(); }
	YY_BREAK
case 171:
YY_RULE_SETUP
{
					    fContinueImplicitPhrase = TRUE;
                                            BEGIN INITIAL;
                                            STRING_VALUE(_PHRASE,FALSE,FALSE); 
                                         }   
	YY_BREAK
case 172:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(innear):
case YY_STATE_EOF(shortgen):
case YY_STATE_EOF(shortregex):
case YY_STATE_EOF(mayberegex):
case YY_STATE_EOF(implicitphrase):
case YY_STATE_EOF(infreefreetext):
case YY_STATE_EOF(invector):
	yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB YY_CHAR. */
                int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between yy_current_buffer and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yy_n_chars = yy_current_buffer->yy_n_chars;
                        yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p "<=" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state();

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state );

                        yy_bp = yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
				yy_cp = yy_last_accepting_cpos;
				yy_current_state = yy_last_accepting_state;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer() )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yy_did_buffer_switch_on_eof = 0;

                                if ( yywrap() )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yy_c_buf_p =
                                        yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yy_c_buf_p =
                                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        L"fatal flex scanner internal error--no action found" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of yylex */

YYLEXER::YYLEXER()
        {
        yy_c_buf_p = 0;
        yy_init = 1;
        yy_start = 0;
        yyprimetoken = 0;
        yy_flex_debug = 0;
        yylineno = 1;   // this will only get updated if %option yylineno

        yy_did_buffer_switch_on_eof = 0;

        yy_looking_for_trail_begin = 0;
        yy_more_flag = 0;
        yy_more_len = 0;
        yy_more_offset = yy_prev_more_offset = 0;

        yy_start_stack_ptr = yy_start_stack_depth = 0;
        yy_start_stack = 0;

        yy_current_buffer = 0;

#ifdef YY_USES_REJECT
        yy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];
#else
        yy_state_buf = 0;
#endif

        pszInputBuffer = pCurBuffer = (YY_CHAR *)NULL;
        cInputBuffer = 0;
        
        // Initialize these flags for this lexical session. They will be
        // set/reset within the lexer to control flow.
        fContinueImplicitPhrase = FALSE;
        fContinueMaybeRegex = FALSE;
        fContinueRegex = FALSE;
        fTreatFreetextAsPhrase = FALSE;
#ifdef DEBUG
        tkndebug = getenv("TKNDEBUG") ? 1 : 0;
#endif
        }


YYLEXER::~YYLEXER()
        {
        delete yy_state_buf;
        yy_delete_buffer( yy_current_buffer );
        yy_flex_free(pszInputBuffer);
        }

#ifdef YY_INTERACTIVE
int YYLEXER::LexerInput( YY_CHAR* buf, int /* max_size */ )
#else
int YYLEXER::LexerInput( YY_CHAR* buf, int max_size )
#endif
        {
        return 0;
        }

void YYLEXER::LexerOutput( const YY_CHAR* buf, int size )
        {
        // everthing should match
        THROW( CException( QPARSE_E_INVALID_QUERY  ) );
        return;
        }


#ifdef DEBUG
void YYLEXER::LexerTrace(const YY_CHAR* buf, int size, int tknNum)
        {
        if (tkndebug > 0)
                {
                cout << ">> Lexing Token : ";
                for (int i=0; i<size; i++)
                        cout << char(buf[i]);
                cout << " (" << tknNum << ")"<< endl;
                }
        }
#endif


void YYLEXER::ResetLexer()
        {
        yy_init = 1;
        yy_start = 0;
#ifdef DEBUG
        tkndebug = getenv("TKNTRACE") ? 1 : 0;
#endif
        }

int YYLEXER::yybufferinput(YY_CHAR *pszBuffer, int cMax)
        {
        int n = min(cMax, cInputBuffer - (int) (pCurBuffer - pszInputBuffer));

        if (n > 0)
                {
                memcpy(pszBuffer, pCurBuffer, n * sizeof(WCHAR));
                pCurBuffer += n;
                }
        return n;
        }

void YYLEXER::yyprimebuffer(const YY_CHAR *pszBuffer)
        {
//      if (NULL != pszInputBuffer)
//              CoTaskMemFree(pszInputBuffer);

        Win4Assert(0 == pszInputBuffer);
        
        cInputBuffer = wcslen(pszBuffer) + 1;
        pszInputBuffer = pCurBuffer = new WCHAR[cInputBuffer];
        RtlCopyMemory(pszInputBuffer, pszBuffer, cInputBuffer*sizeof(WCHAR));

        cInputBuffer--; // get the real length

        ResetLexer();
        }

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */

int YYLEXER::yy_get_next_buffer()
        {
        register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
        register YY_CHAR *source = yytext_ptr;
        register int number_to_move, i;
        int ret_val;

        if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
                YY_FATAL_ERROR(
                L"fatal flex scanner internal error--end of buffer missed" );

        if ( yy_current_buffer->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                yy_current_buffer->yy_n_chars = yy_n_chars = 0;

        else
                {
                int num_to_read =
                        yy_current_buffer->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
                        YY_FATAL_ERROR(
L"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = yy_current_buffer;

                        int yy_c_buf_p_offset =
                                (int) (yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (YY_CHAR *)
                                        /* Include room in for 2 EOB chars. */
                                        yy_flex_realloc( (void *) b->yy_ch_buf,
                                                         b->yy_buf_size,
                                                         b->yy_buf_size + 2 );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;
                        
                        yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = yy_current_buffer->yy_buf_size -
                                                number_to_move - 1;
#endif
                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
                        yy_n_chars, num_to_read );

                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        if ( yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        yyrestart( );
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        yy_current_buffer->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        yy_n_chars += number_to_move;
        yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

        return ret_val;
        }


/* yy_get_previous_state - get the state just before the EOB YY_CHAR was reached */

yy_state_type YYLEXER::yy_get_previous_state()
        {
        register yy_state_type yy_current_state;
        register YY_CHAR *yy_cp;

	yy_current_state = yy_start;

        for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
                {
		register YY_CHAR yy_c = 1; if (0!= *yy_cp && 256 > *yy_cp) yy_c = (YY_CHAR) yy_ec[YY_SC_TO_UI(*yy_cp)];
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 804 )
				yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
        }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */

yy_state_type YYLEXER::yy_try_NUL_trans( yy_state_type yy_current_state )
        {
        register int yy_is_jam;
	register YY_CHAR *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 804 )
			yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 803);

        return yy_is_jam ? 0 : yy_current_state;
        }


void YYLEXER::yyunput( int c, register YY_CHAR* yy_bp )
        {
        register YY_CHAR *yy_cp = yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yy_hold_char;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                { /* need to shift things up to make room */
                /* +2 for EOB chars. */
                register int number_to_move = yy_n_chars + 2;
                register YY_CHAR *dest = &yy_current_buffer->yy_ch_buf[
                                        yy_current_buffer->yy_buf_size + 2];
                register YY_CHAR *source =
                                &yy_current_buffer->yy_ch_buf[number_to_move];

                while ( source > yy_current_buffer->yy_ch_buf )
                        *--dest = *--source;

                yy_cp += (int) (dest - source);
                yy_bp += (int) (dest - source);
                yy_current_buffer->yy_n_chars =
                        yy_n_chars = yy_current_buffer->yy_buf_size;

                if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                        YY_FATAL_ERROR( L"flex scanner push-back overflow" );
                }

        *--yy_cp = (YY_CHAR) c;


        yytext_ptr = yy_bp;
        yy_hold_char = *yy_cp;
        yy_c_buf_p = yy_cp;
        }


int YYLEXER::yyinput()
        {
        int c;

        *yy_c_buf_p = yy_hold_char;

        if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
                {
                /* yy_c_buf_p now points to the character we want to return.
                 * If this occurs *before* the EOB characters, then it's a
                 * valid NUL; if not, then we've hit the end of the buffer.
                 */
                if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        /* This was really a NUL. */
                        *yy_c_buf_p = '\0';

                else
                        { /* need more input */
                        int offset = (int)(yy_c_buf_p - yytext_ptr);
                        ++yy_c_buf_p;

                        switch ( yy_get_next_buffer() )
                                {
                                case EOB_ACT_LAST_MATCH:
                                        /* This happens because yy_g_n_b()
                                         * sees that we've accumulated a
                                         * token and flags that we need to
                                         * try matching the token before
                                         * proceeding.  But for input(),
                                         * there's no matching to consider.
                                         * So convert the EOB_ACT_LAST_MATCH
                                         * to EOB_ACT_END_OF_FILE.
                                         */

                                        /* Reset buffer status. */
                                        yyrestart( );

                                        /* fall through */

                                case EOB_ACT_END_OF_FILE:
                                        {
                                        if ( yywrap() )
                                                return EOF;

                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
#ifdef __cplusplus
                                        return yyinput();
#else
                                        return input();
#endif
                                        }

                                case EOB_ACT_CONTINUE_SCAN:
                                        yy_c_buf_p = yytext_ptr + offset;
                                        break;
                                }
                        }
                }

        c = *(YY_CHAR *) yy_c_buf_p;    /* cast for 8-bit YY_CHAR's */
        *yy_c_buf_p = '\0';     /* preserve yytext */
        yy_hold_char = *++yy_c_buf_p;


        return c;
        }


void YYLEXER::yyrestart( )
        {
        if ( ! yy_current_buffer )
                yy_current_buffer = yy_create_buffer( (cInputBuffer * sizeof (YY_CHAR)) + sizeof (YY_CHAR) );

        yy_init_buffer( yy_current_buffer );
        yy_load_buffer_state();
        }


void YYLEXER::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
        {
        if ( yy_current_buffer == new_buffer )
                return;

        if ( yy_current_buffer )
                {
                /* Flush out information for old buffer. */
                *yy_c_buf_p = yy_hold_char;
                yy_current_buffer->yy_buf_pos = yy_c_buf_p;
                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        yy_current_buffer = new_buffer;
        yy_load_buffer_state();

        /* We don't actually know whether we did this switch during
         * EOF (yywrap()) processing, but the only time this flag
         * is looked at is after yywrap() is called, so it's safe
         * to go ahead and always set it.
         */
        yy_did_buffer_switch_on_eof = 1;
        }


void YYLEXER::yy_load_buffer_state()
        {
        yy_n_chars = yy_current_buffer->yy_n_chars;
        yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
        yy_hold_char = *yy_c_buf_p;
        }


YY_BUFFER_STATE YYLEXER::yy_create_buffer( int size )
        {
        YY_BUFFER_STATE b;
        
        XPtrST<BYTE> xBuf((BYTE *)yy_flex_alloc( sizeof( struct yy_buffer_state ) ));

        ((YY_BUFFER_STATE)xBuf.GetPointer())->yy_buf_size = size;
        
        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        ((YY_BUFFER_STATE)xBuf.GetPointer())->yy_ch_buf = 
                (YY_CHAR *) yy_flex_alloc( ((YY_BUFFER_STATE)xBuf.GetPointer())->yy_buf_size + 2 );
                
        // if the second alloc succeeds, we acquire into b. Else, xBuf will be automatically
        // freed.
        
        b = (YY_BUFFER_STATE) xBuf.Acquire();

        b->yy_is_our_buffer = 1;

        yy_init_buffer( b );

        return b;
        }


void YYLEXER::yy_delete_buffer( YY_BUFFER_STATE b )
        {
        if ( ! b )
                return;

        if ( b == yy_current_buffer )
                yy_current_buffer = (YY_BUFFER_STATE) 0;

        if ( b->yy_is_our_buffer )
                yy_flex_free( (void *) b->yy_ch_buf );

        yy_flex_free( (void *) b );
        }


 /* extern "C" int isatty YY_PROTO(( int )); */
void YYLEXER::yy_init_buffer( YY_BUFFER_STATE b )

        {
        yy_flush_buffer( b );

        b->yy_fill_buffer = 1;

        b->yy_is_interactive = 0;
        }


void YYLEXER::yy_flush_buffer( YY_BUFFER_STATE b )
        {
        if ( ! b )
                return;

        b->yy_n_chars = 0;

        /* We always need two end-of-buffer characters.  The first causes
         * a transition to the end-of-buffer state.  The second causes
         * a jam in that state.
         */
        b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
        b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

        b->yy_buf_pos = &b->yy_ch_buf[0];

        b->yy_at_bol = 1;
        b->yy_buffer_status = YY_BUFFER_NEW;

        if ( b == yy_current_buffer )
                yy_load_buffer_state();
        }


#ifndef YY_NO_SCAN_BUFFER
#endif


#ifndef YY_NO_SCAN_STRING
#endif


#ifndef YY_NO_SCAN_BYTES
#endif


#ifndef YY_NO_PUSH_STATE
void YYLEXER::yy_push_state( int new_state )
        {
        if ( yy_start_stack_ptr >= yy_start_stack_depth )
                {
                yy_size_t new_size, old_size;
                
                old_size = yy_start_stack_depth * sizeof( int );
                yy_start_stack_depth += YY_START_STACK_INCR;
                new_size = yy_start_stack_depth * sizeof( int );

                if ( ! yy_start_stack )
                        yy_start_stack = (int *) yy_flex_alloc( new_size );

                else
                        yy_start_stack = (int *) yy_flex_realloc(
                                        (void *) yy_start_stack, old_size, new_size );

                }

        yy_start_stack[yy_start_stack_ptr++] = YY_START;

        BEGIN(new_state);
        }
#endif


#ifndef YY_NO_POP_STATE
void YYLEXER::yy_pop_state()
        {
        if ( --yy_start_stack_ptr < 0 )
                YY_FATAL_ERROR( L"start-condition stack underflow" );

        BEGIN(yy_start_stack[yy_start_stack_ptr]);
        }
#endif


#ifndef YY_NO_TOP_STATE
int YYLEXER::yy_top_state()
        {
        return yy_start_stack[yy_start_stack_ptr - 1];
        }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif


void YYLEXER::LexerError( yyconst YY_CHAR msg[] )
        {
        yaccDebugOut(( DEB_WARN, "%s\n", msg ));
        THROW( CException( E_UNEXPECTED  ) );
        }


/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                yytext[yyleng] = yy_hold_char; \
                yy_c_buf_p = yytext + n; \
                yy_hold_char = *yy_c_buf_p; \
                *yy_c_buf_p = '\0'; \
                yyleng = n; \
                } \
        while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( YY_CHAR *s1, yyconst YY_CHAR *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
YY_CHAR *s1;
yyconst YY_CHAR *s2;
int n;
#endif
        {
        register int i;
        for ( i = 0; i < n; ++i )
                s1[i] = s2[i];
        }
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst YY_CHAR *s )
#else
static int yy_flex_strlen( s )
yyconst YY_CHAR *s;
#endif
        {
        register int n;
        for ( n = 0; s[n]; ++n )
                ;

        return n;
        }
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
        {
            void *p = (void *)new BYTE[size];
            
            return p;
        }

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t old_size, yy_size_t new_size )
#else
static void *yy_flex_realloc( ptr, old_size, new_size )
void *ptr;
yy_size_t size;
#endif
        {
         
        /* The cast to (YY_CHAR *) in the following accommodates both
         * implementations that use YY_CHAR* generic pointers, and those
         * that use void* generic pointers.  It works with the latter
         * because both ANSI C and C++ allow castless assignment from
         * any pointer type to void*, and deal with argument conversions
         * as though doing an assignment.
         */
            void *p = (void *) new BYTE[new_size];
            
            RtlCopyMemory(p, ptr, min(old_size, new_size));
            
            yy_flex_free(ptr);
            
            return p;
        }

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
        {
        delete[] (BYTE *)ptr;
        }


#if YY_MAIN
int main()
        {
        yylex();
        return 0;
        }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\triplish\parser.h ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar     1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define _OR 257
#define _AND 258
#define _NEAR 259
#define _NEARDIST 260
#define _NOT 261
#define _CONTAINS 262
#define _LT 263
#define _GT 264
#define _LTE 265
#define _GTE 266
#define _EQ 267
#define _NE 268
#define _ALLOF 269
#define _SOMEOF 270
#define _OPEN 271
#define _CLOSE 272
#define _VECTOR_END 273
#define _VE 274
#define _VE_END 275
#define _PROPEND 276
#define _NEAR_END 277
#define _LTSOME 278
#define _GTSOME 279
#define _LTESOME 280
#define _GTESOME 281
#define _EQSOME 282
#define _NESOME 283
#define _ALLOFSOME 284
#define _SOMEOFSOME 285
#define _LTALL 286
#define _GTALL 287
#define _LTEALL 288
#define _GTEALL 289
#define _EQALL 290
#define _NEALL 291
#define _ALLOFALL 292
#define _SOMEOFALL 293
#define _COERCE 294
#define _SHGENPREFIX 295
#define _SHGENINFLECT 296
#define _GENPREFIX 297
#define _GENINFLECT 298
#define _GENNORMAL 299
#define _PHRASE 300
#define _PROPNAME 301
#define _NEARUNIT 302
#define _WEIGHT 303
#define _REGEX 304
#define _FREETEXT 305
#define _VECTORELEMENT 306
#define _VEMETHOD 307
#define _PHRASEORREGEX 308
typedef union
{
    WCHAR * pwszChar;
    DBCOMMANDOP dbop;
    CDbRestriction * pRest;
    CStorageVariant * pStorageVar;
    CValueParser  *pPropValueParser;
    int iInt;
    int iEmpty;
} YYSTYPE;
extern YYSTYPE triplval;
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
#define INITSTACKSIZE 30
class YYPARSER : public CTripYYBase
{
    friend class YYLEXER;
public:

    YYPARSER(IColumnMapper & ColumnMapper, LCID & locale, YYLEXER & yylex);

    ~YYPARSER() {}

    int  Parse();

#ifdef YYAPI_VALUETYPE
    CDbRestriction* GetParseTree()          // Get result of parse
    {
        CDbRestriction* pRst = ((YYAPI_VALUETYPE)yyval).pRest;
        _setRst.Remove( pRst );
        Win4Assert( 0 == _setRst.Count() );
        Win4Assert( 0 == _setStgVar.Count() );
        Win4Assert( 0 == _setValueParser.Count() );
        return pRst;
    };
#endif

    void SetDebug() { yydebug = 1; }
    void EmptyValueStack(YYAPI_VALUETYPE yylval) {}
    void PopVs() { yyvsp--; }

private:

    int yydebug;
    int yynerrs;
    int yyerrflag;
    int yychar;
    short *yyssp;
    YYSTYPE *yyvsp;
    YYSTYPE yyval;
    YYSTYPE yylval;
    XGrowable<short, INITSTACKSIZE> xyyss;
    CDynArrayInPlace<YYSTYPE> xyyvs;
};
#define yystacksize YYSTACKSIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\triplish\yybase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       YYBase.cxx
//
//  Contents:   Custom base class for YYPARSER
//
//  History:    18-Apr-2000   KitmanH       Created
//
//----------------------------------------------------------------------------

#pragma hdrstop

#include "yybase.hxx"
#include "parser.h"
#include "flexcpp.h"
#include "parsepl.h"

void StripQuotes(WCHAR *wcsPhrase);

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::CTripYYBase, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [ColumnMapper] -- Column Mapper
//              [locale]       -- locale
//              [yylex]        -- Lexer
//
//  History:    18-Apr-2000   KitmanH       Created
//
//--------------------------------------------------------------------------

CTripYYBase::CTripYYBase( IColumnMapper & ColumnMapper, 
                          LCID & locale,
                          YYLEXER & yylex )
        : _yylex( yylex ),
          _ColumnMapper(ColumnMapper), 
          _lcid(locale)
{
    InitState();
    fDeferredPop = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::~CTripYYBase, public
//
//  Synopsis:   Destructor
//
//  History:    18-Apr-2000   KitmanH      Created
//
//--------------------------------------------------------------------------

CTripYYBase::~CTripYYBase()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::yyprimebuffer, public
//
//  Synopsis:   Prime lexer with text (passthrough to lexer)
//
//  Arguments:  [pszBuffer] -- Buffer
//
//  History:    18-Apr-2000   KitmanH       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CTripYYBase::yyprimebuffer(const YY_CHAR *pszBuffer)
{
    _yylex.yyprimebuffer(pszBuffer);
}

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::triperror, protected
//
//  Synopsis:   Report parsing errors
//
//  Arguments:  [szError] -- Error string
//
//  History:    18-Apr-2000   KitmanH       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CTripYYBase::triperror( char const * szError )
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CTripYYBase::InitState, public
//
//  Synopsis:   Initialize property and generate method
//
//  History:    01-Oct-1997   emilyb        created
//              18-Apr-2000   KitmanH       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CTripYYBase::InitState(void)
{
    // Push makes a copy of what is passed in.
    PushProperty(L"contents");
    _currentState.iGenerateMethod = GENERATE_METHOD_EXACT;
    // We don't use xwszPropName field of _currentState. Instead,
    // we use the prop name stack to get the appropriate propname.
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::GetCurrentProperty, public
//
//  Synopsis:  Return info on current prop
//
//  Arguments: [pp_ps] -- filled with CDbColId * for current prop
//             [dbType] -- set to DBTYPE for current prop
//
//  History:   01-Oct-1997   emilyb        created
//             10-Apr-1999   KrishnaN      Modified to use stack
//             18-Apr-2000   KitmanH       Moved from YYPARSER 
//
//----------------------------------------------------------------------------

void  CTripYYBase::GetCurrentProperty(CDbColId ** pp_ps, DBTYPE *dbType)
{
    // Get the top most property off of the stack and use it

    if ( S_OK != _ColumnMapper.GetPropInfoFromName(
                                                   _propNameStack.Get(_propNameStack.Count() - 1),
                                                   (DBID **) pp_ps,
                                                   dbType,
                                                   0 ) )
        THROW( CParserException( QPARSE_E_NO_SUCH_PROPERTY ) );
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::PushProperty, public
//
//  Synopsis:  Pushes current property onto stack.
//
//  Arguments: [pwszProperty] - property
//
//  History:   01-Apr-1998   KrishnaN      created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::PushProperty( WCHAR const * wszProperty)
{
    // Make a copy and save it. The copy will be automatically deleted
    // when the stack self destructs.

    int iLen = wcslen(wszProperty) + 1;
    XPtrST<WCHAR> xwszPropertyCopy(new WCHAR[iLen]);
    RtlCopyMemory(xwszPropertyCopy.GetPointer(), wszProperty, sizeof(WCHAR) * iLen);
    _propNameStack.Push(xwszPropertyCopy.GetPointer());
    xwszPropertyCopy.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::PopProperty, public
//
//  Synopsis:  Pops the current property off the stack
//
//  History:   10-Apr-1998   KrishnaN      created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::PopProperty(void)
{
    // pop the property name off of the stack and delete it

    delete _propNameStack.Pop();
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::SetCurrentGenerate, public
//
//  Synopsis:  Sets current generate method
//
//  Arguments: [iGenerateMethod] - generate method
//
//  History:    01-Oct-1997   emilyb        created
//              18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::SetCurrentGenerate(int iGenerateMethod)
{
    _currentState.iGenerateMethod = iGenerateMethod;
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::GetCurrentGenerate, public
//
//  Synopsis:  Return info on current generate method
//
//  Arguments: [iGenerateMethod] -- set to current generate method
//
//  History:   01-Oct-1997   emilyb        created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void  CTripYYBase::GetCurrentGenerate(int *iGenerateMethod)
{
    *iGenerateMethod = _currentState.iGenerateMethod;
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::SaveState, public
//
//  Synopsis:  Saves current state on state stack, and inits new state
//
//  History:   01-Oct-1997   emilyb        created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::SaveState(void)
{
    XPtr <STATE> xState( new STATE );

    xState.GetPointer()->iGenerateMethod = _currentState.iGenerateMethod;

    // When you save the state, pop the propname off of the
    // stack and save the ptr.
    xState.GetPointer()->xwszPropName.Set( _propNameStack.Pop() );

    _savedStates.Push( xState.GetPointer() );
    xState.Acquire();
    InitState();
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::RestoreState, public
//
//  Synopsis:  Restores state from state stack
//
//  History:   01-Oct-1997   emilyb        created
//             18-Apr-2000   KitmanH       Moved from YYPARSER
//
//----------------------------------------------------------------------------
void CTripYYBase::RestoreState(void)
{
    XPtr <STATE> xState (_savedStates.Pop());

    _currentState.iGenerateMethod = xState.GetPointer()->iGenerateMethod;

    Win4Assert(xState.GetPointer()->xwszPropName.GetPointer());

    // Push the saved state onto the stack
    _propNameStack.Push(xState.GetPointer()->xwszPropName.GetPointer());
    xState.GetPointer()->xwszPropName.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:    CTripYYBase::BuildPhrase
//
//  Synopsis:  Builds a phrase node.
//
//  Arguments: [wcsPhrase]  - The phrase
//             [iGenMethod] - The generation method
//
//  History:   01-Apr-1998   KrishnaN      created
//             18-Apr-2000   KitmanH       Moved from YYPARSER 
//
//----------------------------------------------------------------------------

CDbContentRestriction * CTripYYBase::BuildPhrase(WCHAR *wcsPhrase, int iGenMethod)
{
    Win4Assert(wcsPhrase);

    if (0 == *wcsPhrase)
        THROW( CException( QPARSE_E_EXPECTING_PHRASE ) );

    CDbColId *pps;
    DBTYPE dbType;
    GetCurrentProperty(&pps, &dbType);

    // We used the property. Now pop it off if need be
    if (fDeferredPop)
        PopProperty();

    // generation method stripped in some cases, but not all.
    // if it's there, use it

    LPWSTR pLast = wcsPhrase + wcslen(wcsPhrase) - 1;

    if (L'"' == *wcsPhrase && L'"' == *pLast)
    {
        StripQuotes(wcsPhrase);
        if (0 == *wcsPhrase)
            THROW( CException( QPARSE_E_EXPECTING_PHRASE ) );
    }
    else
    {
        if ( L'*' == *pLast) // prefix
        {
            *pLast-- = L'\0';
            SetCurrentGenerate(GENERATE_METHOD_PREFIX);
        }
        if ( L'*' == *pLast) // inflect
        {
            *pLast-- = L'\0';
            SetCurrentGenerate(GENERATE_METHOD_INFLECT);
        }
    }

    int fuzzy;
    GetCurrentGenerate(&fuzzy);
    if (0 != iGenMethod)
        fuzzy = iGenMethod;

    // Clear generation method so it won't rub off on the following phrase
    SetCurrentGenerate(GENERATE_METHOD_EXACT);

    XDbContentRestriction pRest( new CDbContentRestriction (wcsPhrase, *pps, fuzzy, _lcid));
    if( pRest.IsNull() || !pRest->IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    return pRest.Acquire();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\querylib\weblcid.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       weblcid.hxx
//
//  Contents:   WEB CGI escape & unescape classes
//
//  History:    96/Jan/3    DwightKr    Created
//              97/Jan/7    AlanW       Split from cgiesc.cxx,
//                                      made non-destructive
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mlang.h>
#include <weblcid.hxx>

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------

struct tagHTTPLocale
{
    WCHAR * wcsHttpAcceptLanguage;
    DWORD   dwLocaleCode;                       // encoded form for searching
    LCID    lcid;
};

const struct tagHTTPLocale aHTTPLocale[] =
{
   L"EN",    'EN',   MAKELCID( MAKELANGID(LANG_ENGLISH,         // English
                                  SUBLANG_ENGLISH_US),
                       SORT_DEFAULT ),

   L"EN-US", 'ENUS', MAKELCID( MAKELANGID(LANG_ENGLISH,         // English-United States
                                  SUBLANG_ENGLISH_US),
                       SORT_DEFAULT ),

   L"ZH",    'ZH',   MAKELCID( MAKELANGID(LANG_CHINESE,         // Chinese
                                  SUBLANG_CHINESE_SIMPLIFIED),
                       SORT_CHINESE_UNICODE ),

   L"ZH-CN", 'ZHCN', MAKELCID( MAKELANGID(LANG_CHINESE,         // Chinese/china
                                  SUBLANG_CHINESE_SIMPLIFIED),
                       SORT_CHINESE_UNICODE ),

   L"ZH-TW", 'ZHTW', MAKELCID( MAKELANGID(LANG_CHINESE,         // Chinese/taiwan
                                  SUBLANG_CHINESE_TRADITIONAL),
                       SORT_CHINESE_UNICODE ),

   L"NL",    'NL',   MAKELCID( MAKELANGID(LANG_DUTCH,           // Dutch
                                  SUBLANG_DUTCH),
                       SORT_DEFAULT ),

//
//  Alphabetical from here
//

   L"BG",    'BG',   MAKELCID( MAKELANGID(LANG_BULGARIAN,       // Bulgarian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"HR",    'HR',   MAKELCID( MAKELANGID(LANG_CROATIAN,        // Croatian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"CS",    'CS',   MAKELCID( MAKELANGID(LANG_CZECH,           // Czech
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"DA",    'DA',   MAKELCID( MAKELANGID(LANG_DANISH,          // Danish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"FI",    'FI',   MAKELCID( MAKELANGID(LANG_FINNISH,         // Finnish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"EL",    'EL',   MAKELCID( MAKELANGID(LANG_GREEK,           // Greek
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"EN-GB", 'ENGB', MAKELCID( MAKELANGID(LANG_ENGLISH,         // English-United kingdom
                                  SUBLANG_ENGLISH_UK),
                       SORT_DEFAULT ),

   L"FR",    'FR',   MAKELCID( MAKELANGID(LANG_FRENCH,          // French
                                  SUBLANG_FRENCH),
                       SORT_DEFAULT ),

   L"FR-CA", 'FRCA', MAKELCID( MAKELANGID(LANG_FRENCH,          // French-Canadian
                                  SUBLANG_FRENCH_CANADIAN),
                       SORT_DEFAULT ),

   L"FR-FR", 'FRFR', MAKELCID( MAKELANGID(LANG_FRENCH,          // French-France
                                  SUBLANG_FRENCH),
                       SORT_DEFAULT ),

   L"DE",    'DE',   MAKELCID( MAKELANGID(LANG_GERMAN,          // German
                                  SUBLANG_GERMAN),
                       SORT_DEFAULT ),

   L"HU",    'HU',   MAKELCID( MAKELANGID(LANG_HUNGARIAN,       // Hungarian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"IS",    'IS',   MAKELCID( MAKELANGID(LANG_ICELANDIC,       // Icelandic
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"IT",    'IT',   MAKELCID( MAKELANGID(LANG_ITALIAN,         // Italian
                                  SUBLANG_ITALIAN),
                       SORT_DEFAULT ),

   L"JA",    'JA',   MAKELCID( MAKELANGID(LANG_JAPANESE,        // Japanese
                                  SUBLANG_DEFAULT),
                       SORT_JAPANESE_UNICODE ),

   L"KO",    'KO',   MAKELCID( MAKELANGID(LANG_KOREAN,          // Korean
                                  SUBLANG_DEFAULT),
                       SORT_KOREAN_UNICODE ),

   L"NO",    'NO',   MAKELCID( MAKELANGID(LANG_NORWEGIAN,       // Norwegian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"PL",    'PL',   MAKELCID( MAKELANGID(LANG_POLISH,          // Polish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"PT",    'PT',   MAKELCID( MAKELANGID(LANG_PORTUGUESE,      // Portuguese
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"PT-BR", 'PTBR', MAKELCID( MAKELANGID(LANG_PORTUGUESE,      // Portuguese-Brazil
                                  SUBLANG_PORTUGUESE_BRAZILIAN),
                       SORT_DEFAULT ),

   L"RO",    'RO',   MAKELCID( MAKELANGID(LANG_ROMANIAN,        // Romanian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"RU",    'RU',   MAKELCID( MAKELANGID(LANG_RUSSIAN,         // Russian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"SK",    'SK',   MAKELCID( MAKELANGID(LANG_SLOVAK,          // Slovak
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"SL",    'SL',   MAKELCID( MAKELANGID(LANG_SLOVENIAN,       // Slovenian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"ES",    'ES',   MAKELCID( MAKELANGID(LANG_SPANISH,         // Spanish
                                  SUBLANG_SPANISH_MODERN),
                       SORT_DEFAULT ),

   L"ES-ES", 'ESES', MAKELCID( MAKELANGID(LANG_SPANISH,         // Spanish-Spain
                                  SUBLANG_SPANISH),
                       SORT_DEFAULT ),

   L"ES-MX", 'ESES', MAKELCID( MAKELANGID(LANG_SPANISH,         // Spanish-Mexican
                                  SUBLANG_SPANISH_MEXICAN),
                       SORT_DEFAULT ),

   L"SV",    'SV',   MAKELCID( MAKELANGID(LANG_SWEDISH,         // Swedish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"TR",    'TR',   MAKELCID( MAKELANGID(LANG_TURKISH,         // Turkish
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   //  Less common languages

   L"AF",   'AF',    MAKELCID( MAKELANGID(LANG_AFRIKAANS,       // Afrikaans
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"AR",   'AR',    MAKELCID( MAKELANGID(LANG_ARABIC,          // Arabic
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"EU",   'EU',    MAKELCID( MAKELANGID(LANG_BASQUE,          // Basque
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"BE",   'BE',    MAKELCID( MAKELANGID(LANG_BELARUSIAN,      // Byelorussian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"CA",   'CA',    MAKELCID( MAKELANGID(LANG_CATALAN,         // Catalan
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"HR",   'HR',    MAKELCID( MAKELANGID(LANG_CROATIAN,        // Croatian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"ET",   'ET',    MAKELCID( MAKELANGID(LANG_ESTONIAN,        // Estonian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"FO",   'FO',    MAKELCID( MAKELANGID(LANG_FAEROESE,        // Faeroese
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

// L"??",   '??',    MAKELCID( MAKELANGID(LANG_FARSI,           // Farsi
//                                SUBLANG_DEFAULT),
//                     SORT_DEFAULT ),

   L"HE",   'HE',    MAKELCID( MAKELANGID(LANG_HEBREW,         // Hebrew
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"IW",   'IW',    MAKELCID( MAKELANGID(LANG_HEBREW,         // Hebrew (ISO 639:1988)
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"ID",   'ID',    MAKELCID( MAKELANGID(LANG_INDONESIAN,     // Indonesian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"IN",   'IN',    MAKELCID( MAKELANGID(LANG_INDONESIAN,     // Indonesian (ISO 639:1988)
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"LV",   'LV',    MAKELCID( MAKELANGID(LANG_LATVIAN,        // Latvian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"LT",   'LT',    MAKELCID( MAKELANGID(LANG_LITHUANIAN,     // Lithuanian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"SR",   'SR',    MAKELCID( MAKELANGID(LANG_SERBIAN,        // Serbian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"TH",   'TH',    MAKELCID( MAKELANGID(LANG_THAI,           // Thai
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"UK",   'UK',    MAKELCID( MAKELANGID(LANG_UKRAINIAN,      // Ukrainian
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   L"VI",   'VI',    MAKELCID( MAKELANGID(LANG_VIETNAMESE,     // Vietnamese
                                  SUBLANG_DEFAULT),
                       SORT_DEFAULT ),

   // NOTE:  Neutral must be last!
   L"NEUTRAL", 'N',  MAKELCID( MAKELANGID(LANG_NEUTRAL,        // Neutral
                                  SUBLANG_NEUTRAL),
                       SORT_DEFAULT ),
};

const unsigned cHTTPLocale = sizeof(aHTTPLocale) / sizeof(aHTTPLocale[0]);

//+-------------------------------------------------------------------------
//
//  Function:   GetLocaleString
//
//  Synopsis:   Looks up a locale string given an LCID
//
//  Arguments:  [lcid]     -- The LCID to lookup
//              [pwcLocale -- The resulting string
//
//--------------------------------------------------------------------------

void GetLocaleString( LCID lcid, WCHAR * pwcLocale )
{
    wcscpy( pwcLocale, L"Neutral" );

    XInterface<IMultiLanguage> xMultiLang;

    SCODE sc = CoCreateInstance( CLSID_CMultiLanguage,
                                 0,
                                 CLSCTX_INPROC_SERVER,
                                 IID_IMultiLanguage,
                                 xMultiLang.GetQIPointer() );

    if ( SUCCEEDED( sc ) )
    {
        BSTR bstrLocale;

        sc = xMultiLang->GetRfc1766FromLcid( lcid, &bstrLocale );
        if ( SUCCEEDED( sc ) )
        {
            wcscpy( pwcLocale, bstrLocale );
            SysFreeString( bstrLocale );
        }
    }
} //GetLocaleString

//+---------------------------------------------------------------------------
//
//  Function:   GetStringFromLCID - public
//
//  Synposis:   Determines the string representation of an LCID
//
//  Arguments:  [lcid]     -- The LCID to lookup
//              [pwcLocale -- The resulting string
//
//  History:    96-Apr-24   DwightKr    Created
//
//----------------------------------------------------------------------------

void GetStringFromLCID( LCID lcid, WCHAR * pwcLocale )
{
    //
    // Be careful to compare only the language ID, and not the sort ID.
    //

    lcid = LANGIDFROMLCID(lcid);

    for (ULONG i=0; i<cHTTPLocale; i++)
    {
        if ( lcid == LANGIDFROMLCID( aHTTPLocale[i].lcid ) )
        {
            qutilDebugOut(( DEB_ITRACE, "GetStringFromLCID: browser locale is %ws; lcid=0x%x\n",
                            aHTTPLocale[i].wcsHttpAcceptLanguage,
                            lcid ));

            wcscpy( pwcLocale, aHTTPLocale[i].wcsHttpAcceptLanguage );
            return;
        }
    }

    // Give up and go for Neutral if the below call fails

    qutilDebugOut(( DEB_ITRACE, "GetStringFromLCID: browser locale not found, lcid=0x%x\n",
                    lcid ));

    wcscpy( pwcLocale, L"NEUTRAL" );

    //
    //  This LCID was not found in the table, look one up.
    //

    GetLocaleString( lcid, pwcLocale );
} //GetStringFromLCID

//+---------------------------------------------------------------------------
//
//  Function:   EncodeLocale - public
//
//  Synopsis:   Compact a locale string for easier lookup.
//
//  Arguments:  [pwszLocale] - locale string
//              [dwPrimaryLang] - set to the primary language encoding if
//                   there is a sublangage ID.
//
//  Returns:    DWORD - the significant characters in the locale or zero if
//                      ill-formed
//
//+---------------------------------------------------------------------------

inline DWORD EncodeLocale( WCHAR * pwszLocale, DWORD & dwPrimaryLang )
{
    DWORD dwResult = 0;
    dwPrimaryLang = 0;

    if ( isalpha( pwszLocale[0] ) && isalpha( pwszLocale[1] ) )
    {
        dwResult = towupper(pwszLocale[0]) << 8;
        dwResult |= towupper(pwszLocale[1]) << 0;
        pwszLocale += 2;
        if (*pwszLocale == L'-')
        {
            dwPrimaryLang = dwResult;
            dwResult <<= 16;
            pwszLocale++;
            if ( isalpha( pwszLocale[0] ) && isalpha( pwszLocale[1] ) )
            {
                dwResult |= towupper(pwszLocale[0]) << 8;
                dwResult |= towupper(pwszLocale[1]) << 0;
                pwszLocale += 2;
            }
        }
        else if (isalpha( *pwszLocale ))
        {
            // Treat the NEUTRAL locale as a special case
            if (_wcsnicmp( pwszLocale-2,
                           aHTTPLocale[cHTTPLocale-1].wcsHttpAcceptLanguage,
                           wcslen(aHTTPLocale[cHTTPLocale-1].wcsHttpAcceptLanguage) ) == 0)
            {
                pwszLocale += wcslen(aHTTPLocale[cHTTPLocale-1].wcsHttpAcceptLanguage) - 2;
                dwResult = aHTTPLocale[cHTTPLocale-1].dwLocaleCode;
            }
        }
    }
    if ( *pwszLocale != L'\0' &&
         ! iswspace( *pwszLocale ) &&
         *pwszLocale != L',' && *pwszLocale != L';' )
        dwResult = 0;

    return dwResult;
} //EncodeLocale

//+---------------------------------------------------------------------------
//
//  Function:   LcidFromHttpAcceptLanguage
//
//  Synposis:   Determines the locale from the string passed in.
//
//  Arguments:  [pwc] the string representation of the locale
//
//  History:    00-Oct-04   dlee    Created
//
//----------------------------------------------------------------------------

LCID LcidFromHttpAcceptLanguage( WCHAR const * pwc )
{
    // Default to an invalid lcid

    LCID lcid = InvalidLCID;

    if ( 0 != pwc )
    {
        XInterface<IMultiLanguage> xMultiLang;

        SCODE sc = CoCreateInstance( CLSID_CMultiLanguage,
                                     0,
                                     CLSCTX_INPROC_SERVER,
                                     IID_IMultiLanguage,
                                     xMultiLang.GetQIPointer() );

        if ( SUCCEEDED( sc ) )
        {
            BSTR bstr = SysAllocString( pwc );

            if ( 0 != bstr )
            {
                sc = xMultiLang->GetLcidFromRfc1766( &lcid, bstr );

                SysFreeString( bstr );
            }
        }
    }

    return lcid;
} //LcidFromHttpAcceptLanguage

//+---------------------------------------------------------------------------
//
//  Function:   GetLCIDFromString - public
//
//  Synposis:   Determines the locale from the string passed in.
//
//  Arguments:  [wcsLocale] the string representation of the locale
//
//  History:    96-Apr-20   DwightKr    Created
//              97-Jan-07   AlanW       Made non-destructive
//
//  Notes:      The input string is assumed to be a language list as
//              formatted for the Accept-Language header.  This is a
//              command separated list of language codes.
//              The code here doesn't evaluate the quality parameter,
//              it returns the first available language found.
//
//----------------------------------------------------------------------------

LCID GetLCIDFromString( WCHAR * wcsLocale )
{
    unsigned iPrimaryLangEntry = 0xFFFFFFFF;
    const WCHAR * wcsDelim = L" \t,;=";
    WCHAR * wcsToken = wcsLocale;

    while ( 0 != wcsToken )
    {
        wcsToken += wcsspn( wcsToken, wcsDelim );
        DWORD dwPrimaryCode = 0;
        DWORD dwLocaleCode = EncodeLocale(wcsToken, dwPrimaryCode);

        if (dwLocaleCode != 0 || dwPrimaryCode != 0)
        {
            for (ULONG i=0; i<cHTTPLocale; i++)
            {
                if ( dwLocaleCode == aHTTPLocale[i].dwLocaleCode )
                {
                    qutilDebugOut(( DEB_ITRACE,
                                    "GetLCIDFromString is %ws; lcid=0x%x\n",
                                     wcsToken,
                                     aHTTPLocale[i].lcid ));

                    return LANGIDFROMLCID( aHTTPLocale[i].lcid );
                }
                if ( dwPrimaryCode == aHTTPLocale[i].dwLocaleCode &&
                     iPrimaryLangEntry == 0xFFFFFFFF )
                    iPrimaryLangEntry = i;
            }
        }

        wcsToken = wcschr( wcsToken, L',' );
    }

    if (iPrimaryLangEntry != 0xFFFFFFFF)
        return aHTTPLocale[iPrimaryLangEntry].lcid;

    // Fall back to the slow approach.

    return LcidFromHttpAcceptLanguage( wcsLocale );
} //GetLCIDFromString

WCHAR const * __stdcall GetStringFromLCID( LCID lcid );

//+---------------------------------------------------------------------------
//
//  Function:   GetStringFromLCID - public
//
//  Synposis:   Determines the string representation of an LCID
//
//  Arguments:  [lcid]  - the LCID to lookup
//
//  History:    96-Apr-24   DwightKr    Created
//
//  Note:       This must be exported since SQL 7 calls this undocumented API
//              It's otherwise unused by Indexing Service.
//
//----------------------------------------------------------------------------

WCHAR const * GetStringFromLCID( LCID lcid )
{
    //
    // Be careful to compare only the language ID, and not the sort ID.
    //

    lcid = LANGIDFROMLCID(lcid);

    for (ULONG i=0; i<cHTTPLocale; i++)
    {
        if ( lcid ==  LANGIDFROMLCID( aHTTPLocale[i].lcid ) )
        {
            qutilDebugOut(( DEB_ITRACE, "GetStringFromLCID: browser locale is %ws; lcid=0x%x\n",
                         aHTTPLocale[i].wcsHttpAcceptLanguage,
                         lcid ));

            return aHTTPLocale[i].wcsHttpAcceptLanguage;
        }
    }

    //
    //  This LCID was not found in the table, report an error.
    //

    qutilDebugOut(( DEB_ITRACE, "GetStringFromLCID: browser locale not found, lcid=0x%x\n",
                    lcid ));

    return L"NEUTRAL";
} //GetStringFromLCID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qutil\triplish\trparse.cxx ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar     1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#include <pch.cxx>
#pragma hdrstop
#define yyparse tripparse
#define yylex triplex
#define yyerror triperror
#define yychar tripchar
#define yyval tripval
#define yylval triplval
#define yydebug tripdebug
#define yynerrs tripnerrs
#define yyerrflag triperrflag
#define yyss tripss
#define yyssp tripssp
#define yyvs tripvs
#define yyvsp tripvsp
#define yylhs triplhs
#define yylen triplen
#define yydefred tripdefred
#define yydgoto tripdgoto
#define yysindex tripsindex
#define yyrindex triprindex
#define yygindex tripgindex
#define yytable triptable
#define yycheck tripcheck
#define yyname tripname
#define yyrule triprule
#define YYPREFIX "trip"

class CValueParser;

#if 0

typedef union
{
    WCHAR * pwszChar;
    DBCOMMANDOP dbop;
    CDbRestriction * pRest;
    CStorageVariant * pStorageVar;
    CValueParser  *pPropValueParser;
    int iInt;
    int iEmpty;
} YYSTYPE;

#endif

#define YYDEBUG CIDBG

#include <malloc.h>
#include "yybase.hxx"
#include "parser.h" // defines yystype
#include "parsepl.h"
#include "flexcpp.h"

#if CIDBG == 1
#define AssertReq(x)    Assert(x != NULL)
#else
#define AssertReq(x)
#endif

const GUID guidSystem = PSGUID_STORAGE;
static CDbColId psContents( guidSystem, PID_STG_CONTENTS );

//+---------------------------------------------------------------------------
//
//  Function:  TreeFromText, public
//
//  Synopsis:  Create a CDbRestriction from a restriction string
//
//  Arguments: [wcsRestriction] -- restriction
//             [ColumnMapper]   -- property list
//             [lcid]           -- locale id of the query
//
//  History:   01-Oct-97 emilyb    created
//             26-Aug-98 KLam      No longer need to lower case
//
//----------------------------------------------------------------------------


CDbContentRestriction * TreeFromText(
    WCHAR const *   wcsRestriction,
    IColumnMapper & ColumnMapper,
    LCID            lcid )
{
    unsigned cwc = 1 + wcslen( wcsRestriction );
    XGrowable<WCHAR> xRestriction( cwc );
    WCHAR * pwc = xRestriction.Get();
    RtlCopyMemory( pwc, wcsRestriction, cwc * sizeof WCHAR );

    cwc--;

    // The parser can't deal with trailing space so strip it off

    while ( cwc > 0 && L' ' == pwc[cwc-1] )
        cwc--;
    pwc[cwc] = 0;

    TripLexer Lexer;
    XPtr<YYPARSER> xParser( new TripParser( ColumnMapper, lcid, Lexer ) );

    xParser->yyprimebuffer( pwc );

    #if 0 // YYDEBUG == 1
        // Set this to 1 if you want command line output. to 0 otherwise.
        xParser->SetDebug();
    #endif

    // Actually parse the text producing a tree

    SCODE hr = xParser->Parse();

    if (FAILED(hr))
        THROW( CException( hr ) );

    // return the DBCOMMANDTREE
    return  (CDbContentRestriction *)( xParser->GetParseTree() );

} //TextFromTree

void StripQuotes(WCHAR *wcsPhrase)
{
    ULONG cChars = wcslen(wcsPhrase);
    LPWSTR pLast = wcsPhrase + cChars - 1;
    if (L'"' == *wcsPhrase && L'"' == *pLast)
    {
        *pLast = L'\0';
        MoveMemory(wcsPhrase, wcsPhrase+1, sizeof(WCHAR) * (cChars-1) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueParser::CValueParser, public
//
//  Synopsis:  Allocs CStorageVariant of correct type
//
//  History:   01-Oct-97 emilyb    created
//             02-Sep-98 KLam      Added locale
//
//----------------------------------------------------------------------------

CValueParser::CValueParser(
    BOOL fVectorElement,
    DBTYPE PropType,
    LCID locale ) :
        _pStgVariant( 0 ),
        _fVector(fVectorElement),
        _PropType (PropType),
        _cElements ( 0 ),
        _locale ( locale )
{

    if ( _fVector )
    {
        // this is a vector
        if ( DBTYPE_VECTOR != ( _PropType & DBTYPE_VECTOR ) )
            THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

        VARENUM ve = (VARENUM ) _PropType;
        if ( _PropType == ( DBTYPE_VECTOR | DBTYPE_WSTR ) )
            ve = (VARENUM) (VT_VECTOR | VT_LPWSTR);
        else if ( _PropType == ( DBTYPE_VECTOR | DBTYPE_STR ) )
            ve = (VARENUM) (VT_VECTOR | VT_LPSTR);

        _pStgVariant.Set( new CStorageVariant( ve, _cElements ) );
    }
    else
    {
        _pStgVariant.Set( new CStorageVariant() );
    }
    if ( _pStgVariant.IsNull() )
        THROW( CException( E_OUTOFMEMORY ) );
}

//+---------------------------------------------------------------------------
//
//  Member:    CValueParser::AddValue, public
//
//  Synopsis:  Adds value to CStorageVariant
//
//  Arguments: [pwszValue] -- value
//
//  History:   01-Oct-97 emilyb    code moved here from CPropertyValueParser
//
//----------------------------------------------------------------------------

void CValueParser::AddValue(WCHAR const * pwszValue)
{
    if ( _pStgVariant.IsNull() )
        THROW( CException( E_OUTOFMEMORY ) );

    switch ( _PropType & ~DBTYPE_VECTOR  )
    {

    case DBTYPE_WSTR :
    case DBTYPE_WSTR | DBTYPE_BYREF :
        {
            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetLPWSTR( pwszValue, _cElements );
            else
                _pStgVariant->SetLPWSTR( pwszValue );
            break;
        }
    case DBTYPE_BSTR :
        {
            BSTR bstr = SysAllocString( pwszValue );

            if ( 0 == bstr )
                THROW( CException( E_OUTOFMEMORY ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetBSTR( bstr, _cElements );
            else
                _pStgVariant->SetBSTR( bstr );

            SysFreeString( bstr );
            break;
        }
    case DBTYPE_STR :
    case DBTYPE_STR | DBTYPE_BYREF :
        {
            // make sure there's enough room to translate

            unsigned cbBuffer = 1 + 3 * wcslen( pwszValue );
            XArray<char> xBuf( cbBuffer );

            int cc = WideCharToMultiByte( CP_ACP,
                                          0,
                                          pwszValue,
                                          -1,
                                          xBuf.Get(),
                                          cbBuffer,
                                          NULL,
                                          NULL );

            if ( 0 == cc )
            {
                #if CIDBG
                ULONG ul = GetLastError();
                #endif
                THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );
            }

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetLPSTR( xBuf.Get(), _cElements );
            else
                _pStgVariant->SetLPSTR( xBuf.Get() );
            break;
        }

    case DBTYPE_I1 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            LONG l = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( ( l > SCHAR_MAX ) ||
                 ( l < SCHAR_MIN ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetI1( (CHAR) l, _cElements );
            else
                _pStgVariant->SetI1( (CHAR) l );

            break;
        }
    case DBTYPE_UI1 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            ULONG ul = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( ul > UCHAR_MAX )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetUI1( (BYTE) ul, _cElements );
            else
                _pStgVariant->SetUI1( (BYTE) ul );

            break;
        }
    case DBTYPE_I2 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            LONG l = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( ( l > SHRT_MAX ) ||
                 ( l < SHRT_MIN ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetI2( (short) l, _cElements );
            else
                _pStgVariant->SetI2( (short) l );

            break;
        }
    case DBTYPE_UI2 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            ULONG ul = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( ul > USHRT_MAX )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetUI2( (USHORT) ul, _cElements );
            else
                _pStgVariant->SetUI2( (USHORT) ul );
            break;
        }
    case DBTYPE_I4 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            LONG l = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( l, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetI4( l, _cElements );
            else
                _pStgVariant->SetI4( l );
            break;
        }
    case DBTYPE_UI4 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            ULONG ul = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ul, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetUI4( ul, _cElements );
            else
                _pStgVariant->SetUI4( ul );
            break;
        }
    case DBTYPE_ERROR :
        {
            // SCODE/HRESULT are typedefed as long (signed)

            CQueryScanner scan( pwszValue, FALSE, _locale );
            SCODE sc = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( sc, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetERROR( sc, _cElements );
            else
                _pStgVariant->SetERROR( sc );
            break;
        }
    case DBTYPE_I8 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            _int64 ll = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ll, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            LARGE_INTEGER LargeInt;
            LargeInt.QuadPart = ll;

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetI8(  LargeInt , _cElements );
            else
                _pStgVariant->SetI8(  LargeInt  );

            break;
        }
    case DBTYPE_UI8 :
        {
            CQueryScanner scan( pwszValue, FALSE, _locale );
            unsigned _int64 ull = 0;
            BOOL fAtEndOfString;
            if ( ! ( scan.GetNumber( ull, fAtEndOfString ) &&
                     fAtEndOfString ) )
                THROW( CParserException( QPARSE_E_EXPECTING_INTEGER ) );

            ULARGE_INTEGER LargeInt;
            LargeInt.QuadPart = ull;

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetUI8(  LargeInt , _cElements );
            else
                _pStgVariant->SetUI8(  LargeInt  );

            break;
        }
    case DBTYPE_BOOL :
        {
            if ( pwszValue[0] == 'T' ||
                 pwszValue[0] == 't' )
                if ( _PropType & DBTYPE_VECTOR )
                    _pStgVariant->SetBOOL( VARIANT_TRUE, _cElements );
                else
                    _pStgVariant->SetBOOL( VARIANT_TRUE );
            else
                if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetBOOL( VARIANT_FALSE, _cElements );
            else
                _pStgVariant->SetBOOL( VARIANT_FALSE );

            break;
        }
    case DBTYPE_R4 :
        {
            WCHAR *pwcEnd = 0;

            float Float = (float)( wcstod( pwszValue, &pwcEnd ) );

            if ( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetR4( Float, _cElements );
            else
                _pStgVariant->SetR4( Float );

            break;
        }
    case DBTYPE_R8 :
        {
            WCHAR *pwcEnd = 0;
            double Double = ( double )( wcstod( pwszValue, &pwcEnd ) );

            if ( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetR8( Double, _cElements );
            else
                _pStgVariant->SetR8( Double );

            break;
        }
    case DBTYPE_DECIMAL :
        {
            WCHAR *pwcEnd = 0;
            double Double = ( double )( wcstod( pwszValue, &pwcEnd ) );
     
            if( *pwcEnd != 0 && !iswspace( *pwcEnd ) )
                THROW( CParserException( QPARSE_E_EXPECTING_REAL ) );
     
            // Vectors are not supported by OLE for VT_DECIMAL (yet)
     
            Win4Assert( 0 == ( _PropType & DBTYPE_VECTOR ) );
     
            PROPVARIANT * pPropVar = (PROPVARIANT *) _pStgVariant.GetPointer();
            VarDecFromR8( Double, &(pPropVar->decVal) );
            pPropVar->vt = VT_DECIMAL;
            break;
        }
    case DBTYPE_DATE :
        {
            FILETIME ftValue;
            ParseDateTime( pwszValue, ftValue );

            SYSTEMTIME stValue;
            BOOL fOK = FileTimeToSystemTime( &ftValue, &stValue );

            if ( !fOK )
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

            DATE dosDate;
            fOK = SystemTimeToVariantTime( &stValue, &dosDate );

            if ( !fOK )
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetDATE( dosDate, _cElements );
            else
                _pStgVariant->SetDATE( dosDate );

            break;
        }
    case VT_FILETIME :
        {
            FILETIME ftValue;
            ParseDateTime( pwszValue, ftValue );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetFILETIME( ftValue, _cElements );
            else
                _pStgVariant->SetFILETIME( ftValue );

            break;
        }
    case DBTYPE_CY :
        {
            double dbl;

            if ( swscanf( pwszValue,
                          L"%lf",
                          &dbl ) < 1 )
                THROW( CParserException( QPARSE_E_EXPECTING_CURRENCY ) );

            CY cyCurrency;
            VarCyFromR8( dbl, &cyCurrency );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetCY( cyCurrency,  _cElements );
            else
                _pStgVariant->SetCY( cyCurrency );

            break;
        }
    case DBTYPE_GUID :
    case DBTYPE_GUID | DBTYPE_BYREF:
        {
            CLSID clsid;

            if ( swscanf( pwszValue,
                          L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
                          &clsid.Data1,
                          &clsid.Data2,
                          &clsid.Data3,
                          &clsid.Data4[0], &clsid.Data4[1],
                          &clsid.Data4[2], &clsid.Data4[3],
                          &clsid.Data4[4], &clsid.Data4[5],
                          &clsid.Data4[6], &clsid.Data4[7] ) < 11 )
                THROW( CParserException( QPARSE_E_EXPECTING_GUID ) );

            if ( _PropType & DBTYPE_VECTOR )
                _pStgVariant->SetCLSID( clsid, _cElements );
            else
                _pStgVariant->SetCLSID( &clsid );
            break;
        }
    default:
        {
            THROW( CParserException( QPARSE_E_UNSUPPORTED_PROPERTY_TYPE ) );
        }
    } // switch

    // make sure memory allocations succeeded

    if ( !_pStgVariant->IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    if ( _fVector )
    {
        _cElements++;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueParser::ParseDateTime, private
//
//  Synopsis:   Attempts to parse a date expression.
//
//  Arguments:  phrase -- pointer to the phrase to parse
//              ft     -- reference to the FILETIME structure to fill in
//                        with the result
//
//  History:    31-May-96   dlee       Created
//              23-Jan-97   KyleP      Better Year 2000 support
//              02-Sep-98   KLam       Use user settings for Y2K support
//
//----------------------------------------------------------------------------

void CValueParser::ParseDateTime(
    WCHAR const *    phrase,
    FILETIME & ft )
{
    if( !CheckForRelativeDate( phrase, ft ) )
    {
        SYSTEMTIME stValue = { 0, 0, 0, 0, 0, 0, 0, 0 };

        int cItems = swscanf( phrase,
                              L"%4hd/%2hd/%2hd %2hd:%2hd:%2hd:%3hd",
                              &stValue.wYear,
                              &stValue.wMonth,
                              &stValue.wDay,
                              &stValue.wHour,
                              &stValue.wMinute,
                              &stValue.wSecond,
                              &stValue.wMilliseconds );

        if ( 1 == cItems )
            cItems = swscanf( phrase,
                              L"%4hd-%2hd-%2hd %2hd:%2hd:%2hd:%3hd",
                              &stValue.wYear,
                              &stValue.wMonth,
                              &stValue.wDay,
                              &stValue.wHour,
                              &stValue.wMinute,
                              &stValue.wSecond,
                              &stValue.wMilliseconds );

        if( cItems != 3 && cItems != 6 && cItems != 7)
            THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

        //
        // Make a sensible split for Year 2000 using the user's system settings
        //

        if ( stValue.wYear < 100 )
        {
            DWORD dwYearHigh = 0;
            if ( 0 == GetCalendarInfo ( _locale,
                                        CAL_GREGORIAN,
                                        CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                                        0,
                                        0,
                                        &dwYearHigh ) )
            {
                THROW ( CException () );
            }

            if ( ( dwYearHigh < 99 ) || ( dwYearHigh > 9999 ) )
                dwYearHigh = 2029;

            WORD wMaxDecade = (WORD) dwYearHigh % 100;
            WORD wMaxCentury = (WORD) dwYearHigh - wMaxDecade;
            if ( stValue.wYear <= wMaxDecade )
                stValue.wYear += wMaxCentury;
            else
                stValue.wYear += ( wMaxCentury - 100 );
        }

        if( !SystemTimeToFileTime( &stValue, &ft ) )
            THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );
    }
} //ParseDateTime

//+---------------------------------------------------------------------------
//
//  Member:     CValueParser::CheckForRelativeDate, private
//
//  Synopsis:   Attempts to parse a relative date expression.  If successful,
//              it fills in the FILETIME structure with the calculated
//              absolute date.
//
//  Notes:      Returns TRUE if the phrase is recognized as a relative
//              date (i.e., it begins with a '-').  Otherwise, returns FALSE.
//              The format of a relative date is
//              "-"{INTEGER("h"|"n"|"s"|"y"|"q"|"m"|"d"|"w")}*
//              Case is not significant.
//
//  Arguments:  phrase -- pointer to the phrase to parse
//              ft -- reference to the FILETIME structure to fill in
//                      with the result
//
//  History:    26-May-94   t-jeffc     Created
//              02-Mar-95   t-colinb    Moved from CQueryParser to
//                                      be more accessible
//              22-Jan-97   KyleP       Fix local/UTC discrepancy
//
//----------------------------------------------------------------------------

BOOL CValueParser::CheckForRelativeDate(
    WCHAR const *    phrase,
    FILETIME & ft )
{
    if( *phrase++ == L'-' )
    {
        SYSTEMTIME st;
        LARGE_INTEGER liLocal;
        LONGLONG llTicksInADay = ((LONGLONG)10000000) * ((LONGLONG)3600)
                                 * ((LONGLONG) 24);
        LONGLONG llTicksInAHour = ((LONGLONG) 10000000) * ((LONGLONG)3600);
        int iMonthDays[12]  = {1,-1,1,0,1,0,1,1,0,1,0,1};
        int iLoopValue, iPrevMonth, iPrevQuarter, iQuarterOffset;
        WORD wYear, wDayOfMonth, wStartDate;

        //
        //Obtain local time and convert it to file time
        //Copy the filetime to largeint data struct
        //

        GetSystemTime(&st);
        if(!SystemTimeToFileTime(&st, &ft))
            THROW( CParserException( QPARSE_E_INVALID_LITERAL ));
        liLocal.LowPart = ft.dwLowDateTime;
        liLocal.HighPart = ft.dwHighDateTime;
        LONGLONG llRelDate = (LONGLONG)0;
        for( ;; )
        {
            // eat white space
            while( iswspace( *phrase ) )
                phrase++;

            if( *phrase == 0 ) break;

            // parse the number
            WCHAR * pwcEnd;
            LONG lValue = wcstol( phrase, &pwcEnd, 10 );

            if( lValue < 0 )
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );

            // eat white space
            phrase = pwcEnd;
            while( iswspace( *phrase ) )
                phrase++;

            // grab the unit char & subtract the appropriate amount
            WCHAR wcUnit = *phrase++;
            switch( wcUnit )
            {
            case L'y':
            case L'Y':
                lValue *= 4;
                // Fall through and handle year like 4 quarters

            case L'q':
            case L'Q':
                lValue *= 3;
                // Fall through and handle quarters like 3 months

            case L'm':
            case L'M':
                 // Getting the System time to determine the day and month.

                if(!FileTimeToSystemTime(&ft, &st))
                {
                    THROW(CParserException(QPARSE_E_INVALID_LITERAL));
                }
                wStartDate = st.wDay;
                wDayOfMonth = st.wDay;
                iLoopValue = lValue;
                while(iLoopValue)
                {
                    // Subtracting to the end of previous month
                    llRelDate = llTicksInADay * ((LONGLONG)(wDayOfMonth));
                    liLocal.QuadPart -= llRelDate;
                    ft.dwLowDateTime = liLocal.LowPart;
                    ft.dwHighDateTime = liLocal.HighPart;
                    SYSTEMTIME stTemp;
                    if(!FileTimeToSystemTime(&ft, &stTemp))
                    {
                         THROW(CParserException(QPARSE_E_INVALID_LITERAL));
                    }
                    //
                    // if the end of previous month is greated then start date then we subtract to back up to the
                    // start date.  This will take care of 28/29 Feb(backing from 30/31 by 1 month).
                    //
                    if(stTemp.wDay > wStartDate)
                    {
                        llRelDate = llTicksInADay * ((LONGLONG)(stTemp.wDay - wStartDate));
                        liLocal.QuadPart -= llRelDate;
                        ft.dwLowDateTime = liLocal.LowPart;
                        ft.dwHighDateTime = liLocal.HighPart;
                        // Getting the date into stTemp for further iteration
                        if(!FileTimeToSystemTime(&ft, &stTemp))
                        {
                           THROW( CParserException( QPARSE_E_INVALID_LITERAL ));
                        }
                    }
                    wDayOfMonth = stTemp.wDay;
                    iLoopValue--;
                } //End While

                break;

            case L'w':
            case L'W':
                lValue *= 7;

            case L'd':
            case L'D':
                llRelDate = llTicksInADay * ((LONGLONG)lValue);
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L'h':
            case L'H':
                llRelDate = llTicksInAHour * ((LONGLONG)lValue);
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L'n':
            case L'N':
                llRelDate = ((LONGLONG)10000000) * ((LONGLONG)60) * ((LONGLONG)lValue) ;
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            case L's':
            case L'S':
                llRelDate = ((LONGLONG)10000000) * ((LONGLONG)lValue);
                liLocal.QuadPart -= llRelDate;
                ft.dwLowDateTime = liLocal.LowPart;
                ft.dwHighDateTime = liLocal.HighPart;
                break;

            default:
                THROW( CParserException( QPARSE_E_EXPECTING_DATE ) );
            }

        } // for( ;; )

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


#define _OR 257
#define _AND 258
#define _NEAR 259
#define _NEARDIST 260
#define _NOT 261
#define _CONTAINS 262
#define _LT 263
#define _GT 264
#define _LTE 265
#define _GTE 266
#define _EQ 267
#define _NE 268
#define _ALLOF 269
#define _SOMEOF 270
#define _OPEN 271
#define _CLOSE 272
#define _VECTOR_END 273
#define _VE 274
#define _VE_END 275
#define _PROPEND 276
#define _NEAR_END 277
#define _LTSOME 278
#define _GTSOME 279
#define _LTESOME 280
#define _GTESOME 281
#define _EQSOME 282
#define _NESOME 283
#define _ALLOFSOME 284
#define _SOMEOFSOME 285
#define _LTALL 286
#define _GTALL 287
#define _LTEALL 288
#define _GTEALL 289
#define _EQALL 290
#define _NEALL 291
#define _ALLOFALL 292
#define _SOMEOFALL 293
#define _COERCE 294
#define _SHGENPREFIX 295
#define _SHGENINFLECT 296
#define _GENPREFIX 297
#define _GENINFLECT 298
#define _GENNORMAL 299
#define _PHRASE 300
#define _PROPNAME 301
#define _NEARUNIT 302
#define _WEIGHT 303
#define _REGEX 304
#define _FREETEXT 305
#define _VECTORELEMENT 306
#define _VEMETHOD 307
#define _PHRASEORREGEX 308
#define YYERRCODE 256
short triplhs[] = {                                        -1,
    0,    0,    0,   21,   21,   21,   21,   20,   20,   20,
   19,   19,   19,   12,   12,   12,   13,   13,   18,   18,
   18,   22,   23,   23,   10,   11,   16,   16,   16,   16,
   16,   16,   17,   17,    8,    8,   14,   14,    6,    6,
    6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
    6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
    6,    6,    7,    7,    1,    1,    1,    2,    2,    2,
    4,    3,    3,    5,    5,    9,    9,   15,   15,   15,
};
short triplen[] = {                                         2,
    1,    3,    2,    1,    2,    3,    4,    1,    3,    5,
    3,    5,    5,    0,    1,    1,    0,    1,    1,    1,
    3,    2,    3,    3,    1,    1,    1,    5,    4,    6,
    3,    5,    4,    4,    0,    1,    0,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    0,    1,    1,    1,    1,    1,    1,    2,
    2,    3,    3,    2,    2,    0,    1,    0,    1,    1,
};
short tripdefred[] = {                                      0,
    0,   15,   16,    0,    0,    8,    0,    0,   36,    3,
    0,    5,    0,   25,    0,    0,    0,    0,    0,   20,
   27,    0,   19,    0,    0,    0,    0,   43,   41,   44,
   42,    0,   40,   45,   46,   51,   49,   52,   50,   47,
   48,   53,   54,   59,   57,   60,   58,   55,   56,   61,
   62,    0,    0,    0,    0,    0,    0,    0,   77,    0,
    0,   18,   11,   22,    0,    9,    0,    0,    6,    0,
   65,   66,    0,    0,   67,   69,   68,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   26,   21,    0,    0,
    7,   71,    0,    0,   74,   38,   34,   70,   75,   33,
   12,   13,   79,   80,   29,    0,    0,    0,   10,   72,
   73,   28,   32,    0,   30,
};
short tripdgoto[] = {                                       4,
   74,   75,   76,   77,   78,   52,   53,   18,   60,   19,
   88,    5,   63,   97,  106,   20,   21,   22,    6,    7,
    8,   23,   24,
};
short tripsindex[] = {                                   -234,
 -256,    0,    0, -243,  218,    0, -241, -249,    0,    0,
  312,    0, -148,    0, -275, -275, -258,  281, -234,    0,
    0, -279,    0, -248, -275, -274, -102,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  -15, -265, -253, -249,  -54,  -54, -234,    0,  -43,
 -242,    0,    0,    0, -234,    0, -225, -275,    0, -100,
    0,    0, -247, -172,    0,    0,    0, -251, -172, -279,
 -279, -243, -170, -263, -243,  215,    0,    0, -243, -275,
    0,    0, -167, -163,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0, -172, -172, -279,    0,    0,
    0,    0,    0, -172,    0,
};
short triprindex[] = {                                   -147,
 -101,    0,    0,    0,  125,    0,   38,   10,    0,    0,
 -177,    0, -147,    0, -193, -193,    0, -254, -147,    0,
    0,   66,    0,    0, -193,    0, -147,    0,    0,    0,
    0, -269,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  213,   29,   80,   80, -147,    0,  -55,
    0,    0,    0,    0, -147,    0,    0, -193,    0,    0,
    0,    0,    0,    6,    0,    0,    0,    0,    6,   66,
   66, -194,    6,    1,   34,  170,    0,    0, -192, -193,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    6,    6,   58,    0,    0,
    0,    0,    0,    6,    0,
};
short tripgindex[] = {                                      2,
    0,    0,    0,    0,    0,    0,    0,    3,    0,    0,
    0,   -4,   22,  428,   44,    0,    7,   27,  -25,  -14,
  116,    0,    0,
};
#define YYTABLESIZE 605
short triptable[] = {                                      66,
   78,   39,   10,   11,    1,   37,   76,   12,   27,    1,
   56,   57,   69,   13,   13,   58,   76,   25,   26,   62,
   61,    2,    3,   98,   64,   65,    1,   67,    2,   87,
   39,  103,  104,   31,   64,   39,   39,    4,   79,   76,
    2,    3,   76,   76,    9,   76,   76,    9,   76,   63,
   76,   90,   76,   91,   99,   86,   11,   17,   95,   82,
   12,   85,    2,    3,  109,   17,   89,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   23,   23,
   24,   24,   80,   81,   14,   14,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
   14,  101,  102,   96,  110,   96,   14,   14,  111,   14,
   14,   14,   54,   14,   14,   14,   14,   14,   14,   14,
   14,   14,   14,   14,  103,  104,   63,  107,   55,  114,
   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,    0,    2,    3,
    0,    0,   14,   14,    0,   14,   14,   14,   68,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
    0,   92,    0,    0,    0,    0,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
   14,   14,   14,    0,    2,    3,    0,    0,   14,   93,
    0,   14,   14,   14,   94,   14,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,    1,    0,    0,
    0,    0,   14,   14,   14,   14,   14,   14,   14,   14,
   14,   14,   14,   14,   14,   14,   14,   14,   14,    0,
    0,    0,    0,    0,    0,   14,    9,   14,   14,    0,
    0,   14,   17,    2,    3,   70,   83,   78,   78,   78,
   78,   84,   37,   37,   37,   37,    1,    0,    1,    1,
    0,    0,   78,   78,   78,    0,   78,   37,   37,   37,
    0,    1,    1,    1,   71,    2,    0,    2,    2,   72,
   73,   31,   31,   31,    4,    4,    0,    0,    0,   78,
    2,    2,    2,    0,   37,   31,   31,   31,    1,    4,
    4,    4,    0,    0,   17,   17,   17,   17,    0,    0,
    0,    0,   17,   17,   17,   17,    0,    2,    0,   17,
   17,   17,   31,   17,    0,    0,    4,   17,   17,   17,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
    0,    0,    0,    0,    0,    0,    0,   35,   35,   35,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,   35,    0,    0,   35,   35,    0,   35,
    0,    0,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,   35,   35,    0,    0,    0,    0,    0,
    0,    0,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,   35,   35,   35,   35,   35,    0,    0,
    0,   35,   35,    0,   35,    0,    0,    0,   35,   35,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
    0,    0,    0,    0,    0,    0,    0,   35,   35,   35,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,    0,    0,    0,   35,   35,    0,    0,
    0,    0,    0,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,    0,    0,   14,    0,    0,   14,    0,
   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
   35,   35,   35,   35,   35,   35,  100,    0,   15,    0,
  105,   15,    0,    0,  108,    9,   35,   16,    9,    0,
   16,   17,    0,    0,   17,    0,    0,    0,    0,    0,
    0,    0,    0,  112,  113,    0,    0,    0,    0,    0,
    0,  115,   59,   28,   29,   30,   31,   32,   33,   34,
   35,    0,    0,    0,    0,    0,    0,    0,   36,   37,
   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,
   48,   49,   50,   51,   28,   29,   30,   31,   32,   33,
   34,   35,    0,    0,    0,    0,    0,    0,    0,   36,
   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,
   47,   48,   49,   50,   51,
};
short tripcheck[] = {                                      25,
    0,  271,    1,    1,  261,    0,  261,    1,  258,    0,
   15,   16,   27,  257,  257,  274,  271,  259,  260,  299,
   19,  297,  298,  275,  273,  274,  261,  302,    0,  272,
  300,  295,  296,    0,  304,  305,  306,    0,  304,  294,
  297,  298,  297,  298,  301,  300,  301,  301,  303,  304,
  305,  277,  307,   68,  306,   60,   54,    0,  306,   58,
   54,   60,  297,  298,   90,    0,   65,  261,  262,  263,
  264,  265,  266,  267,  268,  269,  270,  271,  273,  274,
  273,  274,   56,   57,  278,  279,  280,  281,  282,  283,
  284,  285,  286,  287,  288,  289,  290,  291,  292,  293,
  294,   80,   81,  276,  272,  276,  300,  301,  272,  303,
  304,  305,  261,  307,  262,  263,  264,  265,  266,  267,
  268,  269,  270,  271,  295,  296,  304,   84,   13,  108,
  278,  279,  280,  281,  282,  283,  284,  285,  286,  287,
  288,  289,  290,  291,  292,  293,  294,   -1,  297,  298,
   -1,   -1,  300,  301,   -1,  303,  304,  305,  261,  307,
  262,  263,  264,  265,  266,  267,  268,  269,  270,  271,
   -1,  272,   -1,   -1,   -1,   -1,  278,  279,  280,  281,
  282,  283,  284,  285,  286,  287,  288,  289,  290,  291,
  292,  293,  294,   -1,  297,  298,   -1,   -1,  300,  300,
   -1,  303,  304,  305,  305,  307,  262,  263,  264,  265,
  266,  267,  268,  269,  270,  271,  271,  261,   -1,   -1,
   -1,   -1,  278,  279,  280,  281,  282,  283,  284,  285,
  286,  287,  288,  289,  290,  291,  292,  293,  294,   -1,
   -1,   -1,   -1,   -1,   -1,  301,  301,  303,  304,   -1,
   -1,  307,  307,  297,  298,  271,  300,  257,  258,  259,
  260,  305,  257,  258,  259,  260,  257,   -1,  259,  260,
   -1,   -1,  272,  273,  274,   -1,  276,  272,  273,  274,
   -1,  272,  273,  274,  300,  257,   -1,  259,  260,  305,
  306,  258,  259,  260,  257,  258,   -1,   -1,   -1,  299,
  272,  273,  274,   -1,  299,  272,  273,  274,  299,  272,
  273,  274,   -1,   -1,  257,  258,  259,  260,   -1,   -1,
   -1,   -1,  257,  258,  259,  260,   -1,  299,   -1,  272,
  273,  274,  299,  276,   -1,   -1,  299,  272,  273,  274,
  261,  262,  263,  264,  265,  266,  267,  268,  269,  270,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,  279,  280,
  281,  282,  283,  284,  285,  286,  287,  288,  289,  290,
  291,  292,  293,  294,   -1,   -1,  297,  298,   -1,  300,
   -1,   -1,  303,  304,  305,  261,  262,  263,  264,  265,
  266,  267,  268,  269,  270,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  278,  279,  280,  281,  282,  283,  284,  285,
  286,  287,  288,  289,  290,  291,  292,  293,   -1,   -1,
   -1,  297,  298,   -1,  300,   -1,   -1,   -1,  304,  305,
  261,  262,  263,  264,  265,  266,  267,  268,  269,  270,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,  279,  280,
  281,  282,  283,  284,  285,  286,  287,  288,  289,  290,
  291,  292,  293,   -1,   -1,   -1,  297,  298,   -1,   -1,
   -1,   -1,   -1,  304,  305,  263,  264,  265,  266,  267,
  268,  269,  270,   -1,   -1,  271,   -1,   -1,  271,   -1,
  278,  279,  280,  281,  282,  283,  284,  285,  286,  287,
  288,  289,  290,  291,  292,  293,   79,   -1,  294,   -1,
   83,  294,   -1,   -1,  300,  301,  304,  303,  301,   -1,
  303,  307,   -1,   -1,  307,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  106,  107,   -1,   -1,   -1,   -1,   -1,
   -1,  114,  262,  263,  264,  265,  266,  267,  268,  269,
  270,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,  279,
  280,  281,  282,  283,  284,  285,  286,  287,  288,  289,
  290,  291,  292,  293,  263,  264,  265,  266,  267,  268,
  269,  270,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,
  279,  280,  281,  282,  283,  284,  285,  286,  287,  288,
  289,  290,  291,  292,  293,
};
#define YYFINAL 4
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 308
#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
char *tripname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'('","')'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_OR","_AND","_NEAR",
"_NEARDIST","_NOT","_CONTAINS","_LT","_GT","_LTE","_GTE","_EQ","_NE","_ALLOF",
"_SOMEOF","_OPEN","_CLOSE","_VECTOR_END","_VE","_VE_END","_PROPEND","_NEAR_END",
"_LTSOME","_GTSOME","_LTESOME","_GTESOME","_EQSOME","_NESOME","_ALLOFSOME",
"_SOMEOFSOME","_LTALL","_GTALL","_LTEALL","_GTEALL","_EQALL","_NEALL",
"_ALLOFALL","_SOMEOFALL","_COERCE","_SHGENPREFIX","_SHGENINFLECT","_GENPREFIX",
"_GENINFLECT","_GENNORMAL","_PHRASE","_PROPNAME","_NEARUNIT","_WEIGHT","_REGEX",
"_FREETEXT","_VECTORELEMENT","_VEMETHOD","_PHRASEORREGEX",
};
char *triprule[] = {
"$accept : query",
"query : AndTerm",
"query : query _OR AndTerm",
"query : _NOT query",
"AndTerm : NearTerm",
"AndTerm : _NOT PropTerm",
"AndTerm : AndTerm _AND NearTerm",
"AndTerm : AndTerm _AND _NOT NearTerm",
"NearTerm : CoerceTerm",
"NearTerm : NearTerm _NEAR CoerceTerm",
"NearTerm : NearTerm _NEARDIST _NEARUNIT _NEAR_END CoerceTerm",
"CoerceTerm : Gen NestTerm GenEnd",
"CoerceTerm : Gen _COERCE Gen NestTerm GenEnd",
"CoerceTerm : Gen _WEIGHT Gen NestTerm GenEnd",
"Gen :",
"Gen : _GENPREFIX",
"Gen : _GENINFLECT",
"GenEnd :",
"GenEnd : _GENNORMAL",
"NestTerm : VectorTerm",
"NestTerm : Term",
"NestTerm : Open query Close",
"VectorTerm : VectorSpec _VECTOR_END",
"VectorSpec : _VEMETHOD _VE query",
"VectorSpec : VectorSpec _VE query",
"Open : _OPEN",
"Close : _CLOSE",
"Term : PropTerm",
"Term : Property Contains _PHRASE ShortGen PropEnd",
"Term : Property Contains _PHRASE PropEnd",
"Term : Property Contains Gen _PHRASE GenEnd PropEnd",
"Term : Property Contains query",
"Term : Property Contains _FREETEXT ShortGen PropEnd",
"PropTerm : Property Matches _REGEX PropEnd",
"PropTerm : Property Op Value PropEnd",
"Property :",
"Property : _PROPNAME",
"PropEnd :",
"PropEnd : _PROPEND",
"Op : _EQ",
"Op : _NE",
"Op : _GT",
"Op : _GTE",
"Op : _LT",
"Op : _LTE",
"Op : _ALLOF",
"Op : _SOMEOF",
"Op : _EQSOME",
"Op : _NESOME",
"Op : _GTSOME",
"Op : _GTESOME",
"Op : _LTSOME",
"Op : _LTESOME",
"Op : _ALLOFSOME",
"Op : _SOMEOFSOME",
"Op : _EQALL",
"Op : _NEALL",
"Op : _GTALL",
"Op : _GTEALL",
"Op : _LTALL",
"Op : _LTEALL",
"Op : _ALLOFALL",
"Op : _SOMEOFALL",
"Matches :",
"Matches : _EQ",
"Value : _PHRASE",
"Value : _FREETEXT",
"Value : VectorValue",
"VectorValue : EmptyVector",
"VectorValue : SingletVector",
"VectorValue : MultiVector _VE_END",
"EmptyVector : _OPEN _CLOSE",
"SingletVector : _OPEN _PHRASE _CLOSE",
"SingletVector : _OPEN _FREETEXT _CLOSE",
"MultiVector : _VECTORELEMENT _VECTORELEMENT",
"MultiVector : MultiVector _VECTORELEMENT",
"Contains :",
"Contains : _CONTAINS",
"ShortGen :",
"ShortGen : _SHGENPREFIX",
"ShortGen : _SHGENINFLECT",
};
#endif
YYPARSER::YYPARSER(IColumnMapper & ColumnMapper, LCID & locale, YYLEXER & yylex)
        : CTripYYBase( ColumnMapper, locale, yylex ) {
    xyyvs.SetSize(INITSTACKSIZE);
    yydebug = 0;
}
#define YYABORT(sc) { return ResultFromScode(sc); }
#define YYFATAL   E_FAIL
#define YYSUCCESS S_OK
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
int YYPARSER::Parse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

yyssp = xyyss.Get();
yyvsp = xyyvs.Get();
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        try
        {
            if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) 
                yychar = 0;
        }
        catch (HRESULT hr)
        {
            switch(hr)
            {
            case E_OUTOFMEMORY:
                YYABORT(E_OUTOFMEMORY);
                break;

            default:
                YYABORT(E_FAIL);
                break;
            }
        }
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
        {
            int yysspLoc = (int) ( yyssp - xyyss.Get() );
            xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);
            yyssp = xyyss.Get() + yysspLoc;
        }
        if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
        {
            int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
            xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2);
            yyvsp = xyyvs.Get() + yyvspLoc;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
    yyerror("syntax error");
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
                {
                    int yysspLoc = (int) ( yyssp - xyyss.Get() );
                    xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);
                    yyssp = xyyss.Get() + yysspLoc;
                }
                if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
                {
                    int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
                    xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2);
                    yyvsp = xyyvs.Get() + yyvspLoc;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= xyyss.Get()) goto yyabort;
                --yyssp;
                PopVs();
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{
                   yyval.pRest = yyvsp[0].pRest;
                   }
break;
case 2:
{
                    AssertReq(yyvsp[-2].pRest);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstQuery(yyvsp[-2].pRest);
                    XDbRestriction prstTerm(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[-2].pRest );
                    _setRst.Remove( yyvsp[0].pRest );

                    BOOL fAcquireQuery = FALSE;

                    XDbBooleanNodeRestriction prstNew;
                    if (DBOP_or == yyvsp[-2].pRest->GetCommandType())
                    {
                        /* add right term & release its smart pointer*/
                        ((CDbBooleanNodeRestriction *)(yyvsp[-2].pRest))->AppendChild( prstTerm.GetPointer() );
                        prstTerm.Acquire();
                        fAcquireQuery = TRUE;
                        yyval.pRest = prstQuery.GetPointer();
                    }
                    else
                    {
                        /* create smart Or node*/
                        prstNew.Set( new CDbBooleanNodeRestriction( DBOP_or ) );
                        if( 0 == prstNew.GetPointer() )
                            THROW( CException( E_OUTOFMEMORY ) );

                        prstNew->SetWeight(MAX_QUERY_RANK);

                        /* add left term & release its smart pointer*/
                        prstNew->AppendChild( prstQuery.GetPointer() );
                        prstQuery.Acquire();

                        /* add right term & release its smart pointer*/
                        prstNew->AppendChild( prstTerm.GetPointer() );
                        prstTerm.Acquire();

                        yyval.pRest = prstNew.GetPointer();
                    }

                    _setRst.Add( yyval.pRest );

                    if ( fAcquireQuery )
                        prstQuery.Acquire();
                    else
                        prstNew.Acquire();

                }
break;
case 3:
{

                        AssertReq(yyvsp[0].pRest);

                        XDbRestriction prstQuery(yyvsp[0].pRest);
                        _setRst.Remove( yyvsp[0].pRest );

                        /* Create not node*/

                        XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_not ) );
                        if( 0 == prstNew.GetPointer() )
                            THROW( CException( E_OUTOFMEMORY ) );


                        prstNew->SetWeight(MAX_QUERY_RANK);

                        /* add right term and release its smart pointer*/
                        prstNew->AppendChild( prstQuery.GetPointer() );
                        prstQuery.Acquire();

                        yyval.pRest = prstNew.GetPointer();
                        _setRst.Add( yyval.pRest );
                        prstNew.Acquire();
                }
break;
case 4:
{ yyval.pRest = yyvsp[0].pRest;}
break;
case 5:
{
                        AssertReq(yyvsp[0].pRest);

                        XDbRestriction prstTerm(yyvsp[0].pRest);
                        _setRst.Remove( yyvsp[0].pRest );

                        /* Create not node*/

                        XDbBooleanNodeRestriction prstNew( new CDbBooleanNodeRestriction( DBOP_not ) );
                        if( 0 == prstNew.GetPointer() )
                            THROW( CException( E_OUTOFMEMORY ) );

                        prstNew->SetWeight(MAX_QUERY_RANK);

                        /* add right term and release its smart pointer*/
                        prstNew->AppendChild( prstTerm.GetPointer() );
                        prstTerm.Acquire();

                        yyval.pRest = prstNew.GetPointer();
                        _setRst.Add( yyval.pRest );
                        prstNew.Acquire();
                    }
break;
case 6:
{
                        AssertReq(yyvsp[-2].pRest);
                        AssertReq(yyvsp[0].pRest);

                        XDbRestriction prstQuery(yyvsp[-2].pRest);
                        XDbRestriction prstTerm(yyvsp[0].pRest);
                        _setRst.Remove( yyvsp[-2].pRest );
                        _setRst.Remove( yyvsp[0].pRest );

                        BOOL fAcquireQuery = FALSE;
      
                        XDbBooleanNodeRestriction prstNew;
                        if (DBOP_and == yyvsp[-2].pRest->GetCommandType())
                        {
                            /* add right term & release its smart pointer*/
                            ((CDbBooleanNodeRestriction *)(yyvsp[-2].pRest))->AppendChild( prstTerm.GetPointer() );
                            prstTerm.Acquire();
                            fAcquireQuery = TRUE;
                            yyval.pRest = prstQuery.GetPointer();
                        }
                        else
                        {
                            /* create smart And node*/
                            prstNew.Set( new CDbBooleanNodeRestriction( DBOP_and ) );
                            if( prstNew.GetPointer() == 0 )
                                THROW( CException( E_OUTOFMEMORY ) );

                            prstNew->SetWeight(MAX_QUERY_RANK);

                            /* add left term & release its smart pointer*/
                            prstNew->AppendChild( prstQuery.GetPointer() );
                            prstQuery.Acquire();

                            /* add right term & release its smart pointer*/
                            prstNew->AppendChild( prstTerm.GetPointer() );
                            prstTerm.Acquire();

                            yyval.pRest = prstNew.GetPointer();
                        }

                        _setRst.Add( yyval.pRest );

                        if ( fAcquireQuery )
                            prstQuery.Acquire();
                        else
                            prstNew.Acquire();
                    }
break;
case 7:
{
                        AssertReq(yyvsp[-3].pRest);
                        AssertReq(yyvsp[0].pRest);

                        XDbRestriction prstQuery(yyvsp[-3].pRest);
                        XDbRestriction prstTerm(yyvsp[0].pRest);
                        _setRst.Remove( yyvsp[-3].pRest );
                        _setRst.Remove( yyvsp[0].pRest );

                        /* create smart Not node*/
                        XDbNotRestriction prstNot( new CDbNotRestriction );
                        if( prstNot.GetPointer() == 0 )
                            THROW( CException( E_OUTOFMEMORY ) );

                        prstNot->SetWeight(MAX_QUERY_RANK);

                        /* set child of Not node & release smart factor pointer*/
                        prstNot->SetChild( prstTerm.GetPointer() );
                        prstTerm.Acquire();

                        BOOL fAcquireQuery = FALSE;

                        XDbBooleanNodeRestriction prstNew;
                        if (DBOP_and == yyvsp[-3].pRest->GetCommandType())
                        {
                            /* add right term & release its smart pointer*/
                            ((CDbBooleanNodeRestriction *)(yyvsp[-3].pRest))->AppendChild( prstNot.GetPointer() );
                            prstNot.Acquire();

                            yyval.pRest = prstQuery.GetPointer();
                            fAcquireQuery = TRUE;
                        }
                        else
                        {
                            /* create smart And node*/
                            prstNew.Set( new CDbBooleanNodeRestriction( DBOP_and ) );
                            if( prstNew.GetPointer() == 0 )
                                THROW( CException( E_OUTOFMEMORY ) );

                            prstNew->SetWeight(MAX_QUERY_RANK);

                            /* add left term & release its smart pointer*/
                            prstNew->AppendChild( prstQuery.GetPointer() );
                            prstQuery.Acquire();

                            /* add right term & release its smart pointer*/
                            prstNew->AppendChild( prstNot.GetPointer() );
                            prstNot.Acquire();

                            yyval.pRest = prstNew.GetPointer();
                        }

                        _setRst.Add( yyval.pRest );

                        if ( fAcquireQuery )
                            prstQuery.Acquire();
                        else
                            prstNew.Acquire();
                    }
break;
case 8:
{ yyval.pRest = yyvsp[0].pRest; }
break;
case 9:
{
                    /* uses defaults*/

                    AssertReq(yyvsp[-2].pRest);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstLeft(yyvsp[-2].pRest);
                    XDbRestriction prstRight(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[-2].pRest );
                    _setRst.Remove( yyvsp[0].pRest );

                    BOOL fAcquireLeft = FALSE;

                    XDbProximityNodeRestriction prstNew;

                    if (DBOP_content_proximity == yyvsp[-2].pRest->GetCommandType() &&
                        50 == ((CDbProximityNodeRestriction *)yyvsp[-2].pRest)->GetProximityDistance() &&
                        PROXIMITY_UNIT_WORD == ((CDbProximityNodeRestriction *)yyvsp[-2].pRest)->GetProximityUnit())
                    {
                        /* add right term & release its smart pointer*/
                        ((CDbProximityNodeRestriction *)yyvsp[-2].pRest)->AppendChild( prstRight.GetPointer() );
                        prstRight.Acquire();

                        yyval.pRest = prstLeft.GetPointer();
                        fAcquireLeft = TRUE;
                    }
                    else
                    {
                        /* create smart Prox node*/
                        prstNew.Set(new CDbProximityNodeRestriction()); /* uses defaults*/

                        if ( prstNew.IsNull() || !prstNew->IsValid() )
                            THROW( CException( E_OUTOFMEMORY ) );

                        /* add left phrase & release its smart pointer*/
                        prstNew->AppendChild( prstLeft.GetPointer() );
                        prstLeft.Acquire();

                        /* add right term & release its smart pointer*/
                        prstNew->AppendChild( prstRight.GetPointer() );
                        prstRight.Acquire();

                        yyval.pRest = prstNew.GetPointer();
                    }

                    _setRst.Add( yyval.pRest );

                    if ( fAcquireLeft )
                        prstLeft.Acquire();
                    else
                        prstNew.Acquire();
                }
break;
case 10:
{
                    AssertReq(yyvsp[-4].pRest);
                    AssertReq(yyvsp[-3].pwszChar);
                    AssertReq(yyvsp[-2].pwszChar);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstLeft(yyvsp[-4].pRest);
                    XDbRestriction prstRight(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[-4].pRest );
                    _setRst.Remove( yyvsp[0].pRest );

                    WCHAR * pwcEnd;
                    ULONG ulValue = wcstol( yyvsp[-3].pwszChar, &pwcEnd, 10 );
                    ULONG ulUnit;

                    if (L'w' == *yyvsp[-2].pwszChar)
                        ulUnit = PROXIMITY_UNIT_WORD;
                    else if (L's' == *yyvsp[-2].pwszChar)
                        ulUnit = PROXIMITY_UNIT_SENTENCE;
                    else if (L'p' == *yyvsp[-2].pwszChar)
                        ulUnit = PROXIMITY_UNIT_PARAGRAPH;
                    else if (L'c' == *yyvsp[-2].pwszChar)
                        ulUnit = PROXIMITY_UNIT_CHAPTER;

                    BOOL fAcquireLeft = FALSE;
                    XDbProximityNodeRestriction prstNew;

                    if (DBOP_content_proximity == yyvsp[-4].pRest->GetCommandType() &&
                        ulValue == ((CDbProximityNodeRestriction *)yyvsp[-4].pRest)->GetProximityDistance() &&
                        ulUnit == ((CDbProximityNodeRestriction *)yyvsp[-4].pRest)->GetProximityUnit())
                    {
                        /* add right term & release its smart pointer*/
                        ((CDbProximityNodeRestriction *)yyvsp[-4].pRest)->AppendChild( prstRight.GetPointer() );
                        prstRight.Acquire();

                        yyval.pRest = prstLeft.GetPointer();
                        fAcquireLeft = TRUE;
                    }
                    else
                    {
                        /* create smart Prox node*/
                        prstNew.Set(new CDbProximityNodeRestriction(ulUnit, ulValue));

                        if( prstNew.IsNull() || !prstNew->IsValid() )
                            THROW( CException( E_OUTOFMEMORY ) );

                        /* add left phrase & release its smart pointer*/
                        prstNew->AppendChild( prstLeft.GetPointer() );
                        prstLeft.Acquire();

                        /* add right term & release its smart pointer*/
                        prstNew->AppendChild( prstRight.GetPointer() );
                        prstRight.Acquire();

                        yyval.pRest = prstNew.GetPointer();
                    }

                    _setRst.Add( yyval.pRest );

                    if ( fAcquireLeft )
                        prstLeft.Acquire();
                    else
                        prstNew.Acquire();
                }
break;
case 11:
{
                    yyval.pRest = yyvsp[-1].pRest;
                }
break;
case 12:
{
                    AssertReq(yyvsp[-1].pRest);
                    XDbRestriction prstQuery(yyvsp[-1].pRest);

                    yyvsp[-1].pRest->SetWeight(MAX_QUERY_RANK);
                    yyval.pRest = prstQuery.Acquire();
                }
break;
case 13:
{
                    AssertReq(yyvsp[-3].pwszChar);
                    AssertReq(yyvsp[-1].pRest);
                    XDbRestriction prstQuery(yyvsp[-1].pRest);

                    WCHAR * pwcEnd;
                    double dWeight = wcstod( yyvsp[-3].pwszChar, &pwcEnd );
                    if ( dWeight > 1.0 )
                       THROW( CParserException( QPARSE_E_WEIGHT_OUT_OF_RANGE ) );
                    LONG lWeight = (LONG)(dWeight * MAX_QUERY_RANK);
                    yyvsp[-1].pRest->SetWeight(lWeight);
                    yyval.pRest = prstQuery.Acquire();
                }
break;
case 14:
{
                    yyval.iInt = 0;
                }
break;
case 15:
{
                    SetCurrentGenerate(GENERATE_METHOD_PREFIX);
                    yyval.iInt = GENERATE_METHOD_PREFIX;
                }
break;
case 16:
{
                    SetCurrentGenerate(GENERATE_METHOD_INFLECT);
                    yyval.iInt = GENERATE_METHOD_INFLECT;
                }
break;
case 17:
{
                    yyval.iEmpty = GENERATE_METHOD_EXACT;
                }
break;
case 18:
{
                    /* don't set the generate method to 0 here. Doing so will*/
                    /* reset the method before it gets used.*/
                    yyval.iEmpty = GENERATE_METHOD_EXACT;
                }
break;
case 19:
{
                    yyval.pRest = yyvsp[0].pRest;
                }
break;
case 20:
{
                    yyval.pRest = yyvsp[0].pRest;
                }
break;
case 21:
{
                    yyval.pRest = yyvsp[-1].pRest;
                }
break;
case 22:
{
                    yyval.pRest = yyvsp[-1].pRest;
                }
break;
case 23:
{
                    AssertReq(yyvsp[-2].pwszChar);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstQuery(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[0].pRest );

                    ULONG rankMethod = VECTOR_RANK_JACCARD; /* default if nothing else matches*/

                    if ( 0 == _wcsicmp( L"jaccard", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_JACCARD;
                    }
                    else if ( 0 == _wcsicmp( L"dice", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_DICE;
                    }
                    else if ( 0 == _wcsicmp( L"inner", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_INNER;
                    }
                    else if ( 0 == _wcsicmp( L"max", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_MAX;
                    }
                    else if ( 0 == _wcsicmp( L"min", yyvsp[-2].pwszChar) )
                    {
                        rankMethod = VECTOR_RANK_MIN;
                    }
                    else
                    {
                        THROW( CException( QPARSE_E_INVALID_RANKMETHOD ) );
                    }

                    /* create smart Vector node*/
                    XDbVectorRestriction prstNew( new CDbVectorRestriction( rankMethod ) );

                    if ( prstNew.IsNull() || !prstNew->IsValid() )
                    {
                        THROW( CException( E_OUTOFMEMORY ) );
                    }

                    /* add expression & release its smart pointer*/
                    prstNew->AppendChild( prstQuery.GetPointer() );
                    prstQuery.Acquire();

                    /* Let the next vector element start off with a clean slate...*/
                    /* We don't want the current element's property and genmethod*/
                    /* to rub off on it.*/
                    InitState();


                    yyval.pRest = prstNew.GetPointer();
                    _setRst.Add( yyval.pRest );
                    prstNew.Acquire();
                }
break;
case 24:
{
                    AssertReq(yyvsp[-2].pRest);
                    AssertReq(yyvsp[0].pRest);

                    XDbRestriction prstLeft(yyvsp[-2].pRest);
                    XDbRestriction prstRight(yyvsp[0].pRest);
                    _setRst.Remove( yyvsp[-2].pRest );
                    _setRst.Remove( yyvsp[0].pRest );

                    /* add right term & release its smart pointer*/
                    ((CDbVectorRestriction *)(yyvsp[-2].pRest))->AppendChild( prstRight.GetPointer() );
                    prstRight.Acquire();

                    /* Let the next vector element start off with a clean slate...*/
                    /* We don't want the current element's property and genmethod*/
                    /* to rub off on it.*/
                    InitState();

                    yyval.pRest = prstLeft.GetPointer();
                    _setRst.Add( yyval.pRest );
                    prstLeft.Acquire();
                }
break;
case 25:
{
                    SaveState();
                    yyval.iEmpty = 0;
                }
break;
case 26:
{
                    RestoreState();
                    yyval.iEmpty = 0;
                }
break;
case 27:
{
                    yyval.pRest = yyvsp[0].pRest;
                }
break;
case 28:
{
                    yyval.pRest = BuildPhrase(yyvsp[-2].pwszChar, yyvsp[-1].iInt);
                    _setRst.Add( yyval.pRest );
                }
break;
case 29:
{
                    yyval.pRest = BuildPhrase(yyvsp[-1].pwszChar, 0);
                    _setRst.Add( yyval.pRest );
                }
break;
case 30:
{
                    yyval.pRest = BuildPhrase(yyvsp[-2].pwszChar, yyvsp[-3].iInt);
                    _setRst.Add( yyval.pRest );
                }
break;
case 31:
{
                    yyval.pRest = yyvsp[0].pRest;
                }
break;
case 32:
{
                    AssertReq(yyvsp[-2].pwszChar);
                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    /* We used the property. Now pop it off if need be*/
                    if (fDeferredPop)
                        PopProperty();

                    /* Clear generation method so it won't rub off on the following phrase*/
                    SetCurrentGenerate(GENERATE_METHOD_EXACT);

                    /* generation method not used - if it's there, ignore it*/
                    /* (already stripped from longhand version, but not from*/
                    /* shorthand version*/
                    LPWSTR pLast = yyvsp[-2].pwszChar + wcslen(yyvsp[-2].pwszChar) -1;
                    if ( L'*' == *pLast) /* prefix*/
                        *pLast-- = L'\0';
                    if ( L'*' == *pLast) /* inflect*/
                        *pLast-- = L'\0';

                    XDbNatLangRestriction pRest ( new CDbNatLangRestriction (yyvsp[-2].pwszChar, *pps, _lcid));
                    if ( pRest.IsNull() || !pRest->IsValid() )
                        THROW( CException( E_OUTOFMEMORY ) );

                    yyval.pRest = pRest.GetPointer();
                    _setRst.Add( yyval.pRest );
                    pRest.Acquire();
                }
break;
case 33:
{
                    AssertReq(yyvsp[-1].pwszChar);

                    CDbColId *pps;
                    DBTYPE dbType;

                    GetCurrentProperty(&pps, &dbType);

                    /* We used the property. Now pop it off if need be*/
                    if (fDeferredPop)
                        PopProperty();

                    if ( ( ( DBTYPE_WSTR|DBTYPE_BYREF ) != dbType ) &&
                        ( ( DBTYPE_STR|DBTYPE_BYREF ) != dbType ) &&
                        ( VT_BSTR != dbType ) &&
                        ( VT_LPWSTR != dbType ) &&
                        ( VT_LPSTR != dbType ) )
                        THROW( CParserException( QPARSE_E_EXPECTING_REGEX_PROPERTY ) );

                    if( yyvsp[-1].pwszChar == 0 )
                        THROW( CParserException( QPARSE_E_EXPECTING_REGEX ) );

                    /* create smart Property node*/
                    XDbPropertyRestriction prstProp( new CDbPropertyRestriction );
                    if( prstProp.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    prstProp->SetRelation(DBOP_like);      /* LIKE relation*/

                    if ( ( ! prstProp->SetProperty( *pps ) ) ||
                        ( ! prstProp->SetValue( yyvsp[-1].pwszChar ) ) ||
                        ( ! prstProp->IsValid() ) )
                        THROW( CException( E_OUTOFMEMORY ) );

                    /* release & return smart Property node*/
                    yyval.pRest = prstProp.GetPointer();
                    _setRst.Add( yyval.pRest );
                    prstProp.Acquire();
                }
break;
case 34:
{
                    AssertReq(yyvsp[-2].dbop);
                    AssertReq(yyvsp[-1].pStorageVar);
                    XPtr<CStorageVariant> pStorageVar( yyvsp[-1].pStorageVar );
                    _setStgVar.Remove( yyvsp[-1].pStorageVar );

                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    /* We used the property. Now pop it off if need be*/
                    if (fDeferredPop)
                        PopProperty();

                    /* create smart Property node*/
                    XDbPropertyRestriction prstProp( new CDbPropertyRestriction );
                    if( prstProp.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    if (! prstProp->SetProperty( *pps ) )
                        THROW( CException( E_OUTOFMEMORY ) );

                    /* don't allow @contents <relop> X -- it's too expensive and we'll*/
                    /* never find any hits anyway (until we implement this feature)*/

                    if ( *pps == psContents )
                        THROW( CParserException( QPARSE_E_EXPECTING_PHRASE ) );

                    prstProp->SetRelation( yyvsp[-2].dbop );

                    if ( 0 != pStorageVar.GetPointer() )
                    {
                        /* This should always be the case  - else PropValueParser would have thrown*/

                        if ( ! ( ( prstProp->SetValue( pStorageVar.GetReference() ) ) &&
                            ( prstProp->IsValid() ) ) )
                            THROW( CException( E_OUTOFMEMORY ) );
                    }
                    yyval.pRest = prstProp.GetPointer();
                    _setRst.Add( yyval.pRest );
                    prstProp.Acquire();
                }
break;
case 35:
{
                    yyval.iEmpty = 0;
                }
break;
case 36:
{
                    PushProperty(yyvsp[0].pwszChar);
                    yyval.iEmpty = 0;
                }
break;
case 37:
{
                    fDeferredPop = FALSE;
                    yyval.iEmpty = 0;
                }
break;
case 38:
{
                    /* When PropEnd is matched, the action of using the property*/
                    /* hasn't yet taken place. So popping the property right now*/
                    /* will cause the property to be unavailable when the action*/
                    /* is performed. Instead, pop it off after it has been used.*/
                    fDeferredPop = TRUE;
                    yyval.iEmpty = 0;
                }
break;
case 39:
{ yyval.dbop = DBOP_equal;}
break;
case 40:
{ yyval.dbop = DBOP_not_equal;}
break;
case 41:
{ yyval.dbop = DBOP_greater;}
break;
case 42:
{ yyval.dbop = DBOP_greater_equal;}
break;
case 43:
{ yyval.dbop = DBOP_less;}
break;
case 44:
{ yyval.dbop = DBOP_less_equal;}
break;
case 45:
{ yyval.dbop = DBOP_allbits;}
break;
case 46:
{ yyval.dbop = DBOP_anybits;}
break;
case 47:
{ yyval.dbop = DBOP_equal_any;}
break;
case 48:
{ yyval.dbop = DBOP_not_equal_any;}
break;
case 49:
{ yyval.dbop = DBOP_greater_any;}
break;
case 50:
{ yyval.dbop = DBOP_greater_equal_any;}
break;
case 51:
{ yyval.dbop = DBOP_less_any;}
break;
case 52:
{ yyval.dbop = DBOP_less_equal_any;}
break;
case 53:
{ yyval.dbop = DBOP_allbits_any;}
break;
case 54:
{ yyval.dbop = DBOP_anybits_any;}
break;
case 55:
{ yyval.dbop = DBOP_equal_all;}
break;
case 56:
{ yyval.dbop = DBOP_not_equal_all;}
break;
case 57:
{ yyval.dbop = DBOP_greater_all;}
break;
case 58:
{ yyval.dbop = DBOP_greater_equal_all;}
break;
case 59:
{ yyval.dbop = DBOP_less_all;}
break;
case 60:
{ yyval.dbop = DBOP_less_equal_all;}
break;
case 61:
{ yyval.dbop = DBOP_allbits_all;}
break;
case 62:
{ yyval.dbop = DBOP_anybits_all;}
break;
case 63:
{ yyval.dbop = 0; }
break;
case 64:
{ yyval.dbop = DBOP_equal; }
break;
case 65:
{
                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    CValueParser PropValueParser( FALSE, dbType, _lcid );
                    StripQuotes(yyvsp[0].pwszChar);
                    PropValueParser.AddValue( yyvsp[0].pwszChar );

                    yyval.pStorageVar = PropValueParser.GetStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                    PropValueParser.AcquireStgVariant();
                 }
break;
case 66:
{
                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    CValueParser PropValueParser( FALSE, dbType, _lcid );
                    PropValueParser.AddValue( yyvsp[0].pwszChar );

                    yyval.pStorageVar = PropValueParser.GetStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                    PropValueParser.AcquireStgVariant();
                }
break;
case 67:
{
                    yyval.pStorageVar = yyvsp[0].pStorageVar;
                }
break;
case 68:
{
                    XPtr <CValueParser> pPropValueParser ( yyvsp[0].pPropValueParser );
                    _setValueParser.Remove( yyvsp[0].pPropValueParser );
                    yyval.pStorageVar = yyvsp[0].pPropValueParser->GetStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                    yyvsp[0].pPropValueParser->AcquireStgVariant();
                }
break;
case 69:
{
                    XPtr <CValueParser> pPropValueParser ( yyvsp[0].pPropValueParser );
                    _setValueParser.Remove( yyvsp[0].pPropValueParser );
                    yyval.pStorageVar = yyvsp[0].pPropValueParser->GetStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                    yyvsp[0].pPropValueParser->AcquireStgVariant();
                }
break;
case 70:
{
                    XPtr <CValueParser> pPropValueParser ( yyvsp[-1].pPropValueParser );
                    _setValueParser.Remove( yyvsp[-1].pPropValueParser );
                    yyval.pStorageVar = yyvsp[-1].pPropValueParser->GetStgVariant();
                    _setStgVar.Add( yyval.pStorageVar );
                    yyvsp[-1].pPropValueParser->AcquireStgVariant();
                }
break;
case 71:
{
                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    XPtr <CValueParser> pPropValueParser ( new CValueParser( TRUE, dbType, _lcid ) );
                    if( pPropValueParser.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    yyval.pPropValueParser = pPropValueParser.GetPointer();
                    _setValueParser.Add( yyval.pPropValueParser );
                    pPropValueParser.Acquire();
               }
break;
case 72:
{
                    AssertReq(yyvsp[-1].pwszChar);

                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    XPtr <CValueParser> pPropValueParser ( new CValueParser( TRUE, dbType, _lcid ) );
                    if( pPropValueParser.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    StripQuotes(yyvsp[-1].pwszChar);
                    pPropValueParser->AddValue( yyvsp[-1].pwszChar );

                    yyval.pPropValueParser = pPropValueParser.GetPointer();
                    _setValueParser.Add( yyval.pPropValueParser );
                    pPropValueParser.Acquire();
                }
break;
case 73:
{
                    AssertReq(yyvsp[-1].pwszChar);

                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    XPtr <CValueParser> pPropValueParser ( new CValueParser( TRUE, dbType, _lcid ) );
                    if( pPropValueParser.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    pPropValueParser->AddValue( yyvsp[-1].pwszChar );

                    yyval.pPropValueParser = pPropValueParser.GetPointer();
                    _setValueParser.Add( yyval.pPropValueParser );
                    pPropValueParser.Acquire();
                }
break;
case 74:
{
                    AssertReq(yyvsp[-1].pwszChar);
                    AssertReq(yyvsp[0].pwszChar);

                    CDbColId *pps;
                    DBTYPE dbType;
                    GetCurrentProperty(&pps, &dbType);

                    XPtr <CValueParser> pPropValueParser ( new CValueParser( TRUE, dbType, _lcid ) );
                    if( pPropValueParser.GetPointer() == 0 )
                        THROW( CException( E_OUTOFMEMORY ) );

                    pPropValueParser->AddValue( yyvsp[-1].pwszChar );
                    pPropValueParser->AddValue( yyvsp[0].pwszChar );

                    yyval.pPropValueParser = pPropValueParser.GetPointer();
                    _setValueParser.Add( yyval.pPropValueParser );
                    pPropValueParser.Acquire();
                }
break;
case 75:
{
                    AssertReq(yyvsp[-1].pPropValueParser);
                    AssertReq(yyvsp[0].pwszChar);

                    yyvsp[-1].pPropValueParser->AddValue(yyvsp[0].pwszChar);

                    yyval.pPropValueParser = yyvsp[-1].pPropValueParser;
                }
break;
case 76:
{
                   yyval.iEmpty = 0;
               }
break;
case 77:
{
                   yyval.iEmpty = 0;
               }
break;
case 78:
{
                   yyval.iInt = 0;
               }
break;
case 79:
{
                   yyval.iInt = 1;
               }
break;
case 80:
{
                   yyval.iInt = 2;
               }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            try
            {
                if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) 
                    yychar = 0;
            }
            catch (HRESULT hr)
            {
                switch(hr)
                {
                case E_OUTOFMEMORY:
                    YYABORT(E_OUTOFMEMORY);
                    break;

                default:
                    YYABORT(E_FAIL);
                    break;
                }
            }
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
    {
        int yysspLoc = (int) ( yyssp - xyyss.Get() );
        xyyss.SetSize((unsigned) ( yyssp-xyyss.Get())+2);
        yyssp = xyyss.Get() + yysspLoc;
    }
    if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
    {
        int yyvspLoc = (int) ( yyssp - xyyss.Get() );
        xyyvs.SetSize((unsigned) ( yyvsp-xyyvs.Get())+2);
        yyvsp = xyyvs.Get() + yyvspLoc;
    }
    *++yyssp = (short) yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyabort:
   EmptyValueStack(yylval);
    return YYFATAL;
yyaccept:
    return YYSUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\coldesc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       ColDesc.cxx
//
//  Contents:   Output column and sort column descriptors
//
//  History:    22-Jun-93 KyleP     Created
//              08 Mar 94 AlanW     Adapted for large tables
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <pidmap.hxx>
#include <coldesc.hxx>

//+-------------------------------------------------------------------------
//
//  Synopsis:   Marshalling routines for CColumnSet 
//
//  Obsolete, bug can't delete without changing on-the-wire protocol.
//
//+-------------------------------------------------------------------------

inline void ReadOutputColumn(
    PROPID & Prop,
    PDeSerStream & stm,
    BOOL fAllBindingData
) {
    Prop = stm.GetULong();

    if (fAllBindingData)
    {
        //
        // The input stream has data for an obsolete CColumnOutputDesc.
        // Discard it.
        //

        ULONG dummy = stm.GetULong();
        dummy = stm.GetULong();
        dummy = stm.GetULong();
        dummy = stm.GetULong();
        dummy = stm.GetULong();
        dummy = (VARTYPE)stm.GetULong();
    }
}

//+-------------------------------------------------------------------------
//
//  Synopsis:   Marshalling routines for CColumnSet and CSortSet
//
//+-------------------------------------------------------------------------

IMPL_DYNARRAY_INPLACE( CColumnSetBase, PROPID );

CColumnSet::CColumnSet(unsigned size)
        : CColumnSetBase( size )
{
}

void CColumnSet::Marshall( PSerStream & stm ) const
{
    stm.PutULong( Count() );

    for ( unsigned i = 0; i < Count(); i++ )
    {
        stm.PutULong( Get(i) );
    }
}

CColumnSet::CColumnSet( PDeSerStream & stm, BOOL fAllBindingData )
        : CColumnSetBase( 0 )
{
    // Validate the count looks realistic.

    ULONG cInSet = stm.GetULong();

    if ( cInSet >= 1000 )
        THROW( CException( E_INVALIDARG ) );

    SetExactSize( cInSet );

    for ( unsigned i = 0; i < cInSet; i++ )
    {
        PROPID Prop;

        ReadOutputColumn( Prop, stm, fAllBindingData );

        Add( Prop, i);
    }
}

IMPL_DYNARRAY_INPLACE( CSortSetBase, SSortKey );

CSortSet::CSortSet(unsigned size)
        : CSortSetBase( size )
{
}

void CSortSet::Marshall( PSerStream & stm ) const
{
    stm.PutULong( Count() );

    for ( unsigned i = 0; i < Count(); i++ )
    {
        stm.PutULong( Get(i).pidColumn );
        stm.PutULong( Get(i).dwOrder );
        stm.PutULong( Get(i).locale );
    }
}

CSortSet::CSortSet( PDeSerStream & stm )
        : CSortSetBase( 0 )
{
    ULONG cInSet = stm.GetULong();

    // Validate the count looks realistic.

    if ( cInSet >= 1000 )
        THROW( CException( E_INVALIDARG ) );

    SetExactSize( cInSet );

    for ( unsigned i = 0; i < cInSet; i++ )
    {
        SSortKey sk;
        sk.pidColumn = stm.GetULong();
        sk.dwOrder = stm.GetULong();

        Win4Assert( QUERY_SORTDESCEND == sk.dwOrder ||
                    QUERY_SORTASCEND == sk.dwOrder );

        if ( QUERY_SORTDESCEND != sk.dwOrder &&
             QUERY_SORTASCEND != sk.dwOrder )
            THROW( CException( E_ABORT ) );

        sk.locale = stm.GetULong();

        Add( sk, i);
    }
}

//+-------------------------------------------------------------------------
//
//  Synopsis:   Marshalling routines for CCategorizationSet
//
//+-------------------------------------------------------------------------

IMPL_DYNARRAY( CCategorizationSetBase, CCategorizationSpec );

CCategorizationSet::CCategorizationSet(unsigned size)
        : CCategorizationSetBase( size ),
          _cCat( 0 )
{
}

void CCategorizationSet::Marshall( PSerStream & stm ) const
{
    stm.PutULong( Count() );

    for ( unsigned i = 0; i < Count(); i++ )
        Get(i)->Marshall( stm );
}

CCategorizationSet::CCategorizationSet( PDeSerStream & stm )
        : CCategorizationSetBase( 0 ),
          _cCat( 0 )
{
    ULONG cInSet = stm.GetULong();

    // Validate the count looks realistic.

    if ( cInSet >= 1000 )
        THROW( CException( E_INVALIDARG ) );

    SetExactSize( cInSet );

    for ( unsigned i = 0; i < cInSet; i++ )
        Add( new CCategorizationSpec( stm ), i);
}

CCategorizationSet::CCategorizationSet( CCategorizationSet const & rCateg )
        : CCategorizationSetBase( rCateg.Count() ),
          _cCat( 0 )
{
    // Validate the count looks realistic.

    if ( Size() >= 65536 )
        THROW( CException( E_INVALIDARG ) );

    for ( unsigned i = 0; i < Size(); i++ )
        Add( new CCategorizationSpec( *(rCateg.Get(i)) ), i);
}


void CCategorizationSpec::Marshall( PSerStream & stm ) const
{
    _csColumns.Marshall( stm );
    _xSpec->Marshall( stm );
} //Marshall

CCategorizationSpec::CCategorizationSpec( PDeSerStream &stm )
    : _csColumns( stm )
{
    unsigned type = stm.GetULong();

    if (CATEGORIZE_UNIQUE == type)
        _xSpec.Set( new CUniqueCategSpec( stm ) );
    else if (CATEGORIZE_BUCKETS == type)
        _xSpec.Set( new CBucketCategSpec( stm ) );
    else if (CATEGORIZE_RANGE == type)
        _xSpec.Set( new CRangeCategSpec( stm ) );
    else
        THROW( CException( E_INVALIDARG ) );
} //CCategorizationSpec

CCategorizationSpec::CCategorizationSpec( CCategorizationSpec const & rCatSpec )
    : _csColumns( rCatSpec.GetColumnSet().Count() )
{
    for ( unsigned i = 0; i < _csColumns.Size(); i++ )
        _csColumns.Add( rCatSpec._csColumns.Get(i), i);

    unsigned type = rCatSpec.Type();

    if (CATEGORIZE_UNIQUE == type)
        _xSpec.Set( new CUniqueCategSpec( rCatSpec.GetCategSpec() ) );
    else if (CATEGORIZE_BUCKETS == type)
        _xSpec.Set( new CBucketCategSpec( rCatSpec.GetCategSpec() ) );
    else if (CATEGORIZE_RANGE == type)
        _xSpec.Set( new CRangeCategSpec( rCatSpec.GetCategSpec() ) );
    else
        THROW( CException( E_INVALIDARG ) );
} //CCategorizationSpec
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\memdeser.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       MemDeSer.cxx
//
//  History:    29-Jul-94 KyleP     Created
//
//
// The CMemSerStream and CDeMemSerStream have different requirements for
// handling buffer overflow conditions. In the case of the driver this
// is indicative of a corrupted stream and we would like to raise an
// exception. On the other hand in Query implementation we deal with
// streams whose sizes are precomputed in the user mode. Therefore we
// do not wish to incur any additional penalty in handling such situations.
// In debug builds this condition is asserted while in retail builds it is
// ignored. The CMemSerStream and CMemDeSerStream implementation are
// implemented using a macro HANDLE_OVERFLOW(fOverflow) which take the
// appropriate action.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "serover.hxx"

#if DBGPROP
BOOLEAN IsUnicodeString(WCHAR const *pwszname, ULONG cb);
BOOLEAN IsAnsiString(CHAR const *pszname, ULONG cb);
#endif

BYTE CMemDeSerStream::GetByte()
{
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    BYTE b = *_pbCurrent;
    _pbCurrent += 1;
    return(b);
}

void CMemDeSerStream::SkipByte()
{
    _pbCurrent += 1;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

void CMemDeSerStream::GetChar( char * pc, ULONG cc )
{
    BYTE *pb = _pbCurrent;
    _pbCurrent += cc;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pc, pb, cc );
}

void CMemDeSerStream::SkipChar( ULONG cc )
{
    _pbCurrent += cc;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

void CMemDeSerStream::GetWChar( WCHAR * pwc, ULONG cc )
{
    WCHAR * pwcTemp = AlignWCHAR(_pbCurrent);
    _pbCurrent = (BYTE *)(pwcTemp + cc);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pwc, pwcTemp, cc * sizeof(WCHAR) );
}

void CMemDeSerStream::SkipWChar( ULONG cc )
{
    WCHAR * pwcTemp = AlignWCHAR(_pbCurrent);
    _pbCurrent = (BYTE *)(pwcTemp + cc);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

USHORT CMemDeSerStream::GetUShort()
{
    USHORT * pus = AlignUSHORT(_pbCurrent);
    _pbCurrent = (BYTE *)(pus + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pus );
}

void CMemDeSerStream::SkipUShort()
{
    USHORT * pus = AlignUSHORT(_pbCurrent);
    _pbCurrent = (BYTE *)(pus + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

ULONG CMemDeSerStream::GetULong()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pul );
}

void CMemDeSerStream::SkipULong()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

long CMemDeSerStream::GetLong()
{
    long * pl = AlignLong(_pbCurrent);
    _pbCurrent = (BYTE *)(pl + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pl );
}

void CMemDeSerStream::SkipLong()
{
    long * pl = AlignLong(_pbCurrent);
    _pbCurrent = (BYTE *)(pl + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

#if defined(KERNEL)     // Can not return floats in the kernel

ULONG CMemDeSerStream::GetFloat()
{
    ASSERT( sizeof(ULONG) == sizeof(float) );
    ULONG * pf = (ULONG *) AlignFloat(_pbCurrent);

#else

float CMemDeSerStream::GetFloat()
{
    float * pf = AlignFloat(_pbCurrent);

#endif

    _pbCurrent = (BYTE *)(pf + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pf );
}

void CMemDeSerStream::SkipFloat()
{
    float * pf = AlignFloat(_pbCurrent);
    _pbCurrent = (BYTE *)(pf + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

#if defined(KERNEL)     // Can not return doubles in the kernel

LONGLONG CMemDeSerStream::GetDouble()
{
    ASSERT( sizeof(LONGLONG) == sizeof(double) );
    LONGLONG * pd = (LONGLONG *) AlignDouble(_pbCurrent);

#else

double CMemDeSerStream::GetDouble()
{
    double * pd = AlignDouble(_pbCurrent);

#endif

    _pbCurrent = (BYTE *)(pd + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    return( *pd );
}

void CMemDeSerStream::SkipDouble()
{
    double * pd = AlignDouble(_pbCurrent);
    _pbCurrent = (BYTE *)(pd + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

ULONG CMemDeSerStream::PeekULong()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    HANDLE_OVERFLOW(((BYTE *)pul + sizeof(ULONG)) > _pbEnd);
    return( *pul );
}

char * CMemDeSerStream::GetString()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);

    ULONG len = *pul;
    CHAR *pszTemp = (CHAR *)_pbCurrent;
    _pbCurrent += len;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);

    char * psz = new char[len+1];
    if (psz != NULL) {
        memcpy(psz, pszTemp, len);
        psz[len] = '\0';
        ASSERT(IsAnsiString(psz, len + 1));
    }

    return(psz);
}

WCHAR * CMemDeSerStream::GetWString()
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);

    ULONG len = *pul;
    WCHAR *pwszTemp = (WCHAR *)_pbCurrent;
    _pbCurrent += len * sizeof(WCHAR);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);

    WCHAR * pwsz = new WCHAR[len + 1];
    if (pwsz != NULL) {
        memcpy(pwsz, pwszTemp, len * sizeof(WCHAR) );
        pwsz[len] = L'\0';
        ASSERT(IsUnicodeString(pwsz, (len + 1) * sizeof(WCHAR)));
    }

    return(pwsz);
}

void CMemDeSerStream::GetBlob( BYTE * pb, ULONG cb )
{
    BYTE *pbTemp = _pbCurrent;
    _pbCurrent += cb;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    memcpy( pb, pbTemp, cb );
}

void CMemDeSerStream::SkipBlob( ULONG cb )
{
    _pbCurrent += cb;
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}

void CMemDeSerStream::GetGUID( GUID & guid )
{
    GUID * pguid = (GUID *)AlignGUID(_pbCurrent);
    _pbCurrent = (BYTE *)(pguid + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
    guid = *pguid;
}

void CMemDeSerStream::SkipGUID()
{
    GUID * pguid = (GUID *)AlignGUID(_pbCurrent);
    _pbCurrent = (BYTE *)(pguid + 1);
    HANDLE_OVERFLOW(_pbCurrent > _pbEnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\memser.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       MemSer.cxx
//
//  History:    29-Jul-94 KyleP     Created
//
//
// The CMemSerStream and CDeMemSerStream have different requirements for
// handling buffer overflow conditions. In the case of the driver this
// is indicative of a corrupted stream and we would like to raise an
// exception. On the other hand in Query implementation we deal with
// streams whose sizes are precomputed in the user mode. Therefore we
// do not wish to incur any additional penalty in handling such situations.
// In debug builds this condition is asserted while in retail builds it is
// ignored. The CMemSerStream and CMemDeSerStream implementation are
// implemented using a macro HANDLE_OVERFLOW(fOverflow) which take the
// appropriate action.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "serover.hxx"

#if DBGPROP
BOOLEAN IsUnicodeString(WCHAR const *pwszname, ULONG cb);
BOOLEAN IsAnsiString(CHAR const *pszname, ULONG cb);
#endif

CMemSerStream::CMemSerStream( unsigned cb )
        : _cb( cb )
{
    _pb = new BYTE[cb];
    if (_pb != NULL) {
        _pbCurrent = _pb;
        _pbEnd = _pb + _cb;
    }
}

CMemSerStream::CMemSerStream( BYTE * pb, ULONG cb )
        : _cb( 0 ),
          _pb( pb ),
          _pbCurrent( _pb ),
          _pbEnd(_pb + cb)
{
}

CMemSerStream::~CMemSerStream()
{
    if ( _cb > 0 )
        delete [] _pb;
}

void CMemSerStream::PutByte( BYTE b )
{
    HANDLE_OVERFLOW((_pbCurrent + 1) > _pbEnd);

    *_pbCurrent++ = b;
}

void CMemSerStream::PutChar( char const * pc, ULONG cc )
{
    BYTE *pb = _pbCurrent;
    _pbCurrent += cc;

    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    memcpy( pb, pc, cc );
}

void CMemSerStream::PutWChar( WCHAR const * pwc, ULONG cc )
{
    WCHAR * pwcTemp = AlignWCHAR(_pbCurrent);
    _pbCurrent = (BYTE *)(pwcTemp + cc);
    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    memcpy( pwcTemp, pwc, cc * sizeof(WCHAR) );
}

void CMemSerStream::PutUShort( USHORT us )
{
    USHORT * pus = AlignUSHORT(_pbCurrent);
    _pbCurrent = (BYTE *)(pus + 1);
    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    *pus = us;
}

void CMemSerStream::PutULong( ULONG ul )
{
    ULONG * pul = AlignULONG(_pbCurrent);
    _pbCurrent = (BYTE *)(pul + 1);
    HANDLE_OVERFLOW(_pbCurrent  > _pbEnd);
    *pul = ul;
}

void CMemSerStream::PutLong( long l )
{
    long * pl = AlignLong(_pbCurrent);
    _pbCurrent = (BYTE *)(pl + 1);
    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    *pl = l;
}

void CMemSerStream::PutFloat( float f )
{
    float * pf = AlignFloat(_pbCurrent);
    _pbCurrent = (BYTE *)(pf + 1);
    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    *pf = f;
}

void CMemSerStream::PutDouble( double d )
{
    double * pd = AlignDouble(_pbCurrent);
    _pbCurrent = (BYTE *)(pd + 1);
    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    *pd = d;
}

void CMemSerStream::PutString( char const * psz )
{
    ASSERT(IsAnsiString(psz, MAXULONG));
    ULONG len = strlen(psz);
    ULONG * pul = AlignULONG(_pbCurrent);
    BYTE *pb = (BYTE *)(pul + 1);
    _pbCurrent = pb + len;
    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    *pul = len;
    memcpy(pb, psz, len);
}

void CMemSerStream::PutWString( WCHAR const * pwsz )
{
    ASSERT(IsUnicodeString(pwsz, MAXULONG));
    ULONG len = wcslen(pwsz);
    ULONG * pul = AlignULONG(_pbCurrent);
    BYTE *pb = (BYTE *)(pul + 1);

    _pbCurrent = pb + len * sizeof(WCHAR);
    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    *pul = len;
    memcpy(pb, pwsz, (len * sizeof(WCHAR)));
}

void CMemSerStream::PutBlob( BYTE const * pbBlob, ULONG cb )
{
    BYTE *pb = _pbCurrent;
    _pbCurrent += cb;
    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    memcpy( pb, pbBlob, cb );
}

void CMemSerStream::PutGUID( GUID const & guid )
{
    GUID * pguid = (GUID *)AlignGUID(_pbCurrent);
    _pbCurrent = (BYTE *)(pguid + 1);
    HANDLE_OVERFLOW(!_pbCurrent || _pbCurrent > _pbEnd);
    memcpy( pguid, &guid, sizeof(guid) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\irest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       IRest.cxx
//
//  Contents:   Internal (non-public) restrictions.
//
//  Classes:    CInternalPropertyRestriction
//              COccRestriction
//              CWordRestriction
//              CSynRestriction
//              CRangeRestriction
//              CUnfilteredRestriction
//              CScopeRestriction
//              CPhraseRestriction
//
//  History:    19-Sep-91   BartoszM    Implemented.
//              29-Aug-92   MikeHew     Added serialization routines
//              30-Nov-92   KyleP       Removed CPhraseXpr
//              14-Jan-93   KyleP       Converted from expressions
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <vkrep.hxx>
#include <norm.hxx>
#include <compare.hxx>

//+-------------------------------------------------------------------------
//
//  Function:   UnMarshallWideString
//
//  Synopsis:   Unmarshalls a wide string into a CoTaskMemAlloc'ed buffer.
//              This can't be in memdeser since it calls CoTaskMemAlloc,
//              which isn't available in ntdll.dll.
//
//  Arguments:  [stm]   -- stream from which string is deserialized
//
//  History:    22-Nov-95 dlee     Created from a few copies
//
//--------------------------------------------------------------------------

WCHAR * UnMarshallWideString( PDeSerStream & stm )
{
    ULONG cc = stm.GetULong();

    // Protect against attack.  We know our named pipes are < 64k

    if ( cc >= ( 65536 / sizeof WCHAR ) )
        return 0;

    XCoMem<WCHAR> xString( (WCHAR *) CoTaskMemAlloc( (cc + 1) * sizeof WCHAR ) );

    if ( xString.IsNull() )
    {
        // just eat the string

        WCHAR wc[10];

        while ( cc > 0 )
        {
            if ( cc >= 10 )
            {
                stm.GetWChar( wc, 10 );
                cc -= 10;
            }
            else
            {
                stm.GetWChar( wc, cc );
                cc = 0;
            }
        }
    }
    else
    {
        WCHAR * pwc = xString.GetPointer();
        stm.GetWChar( pwc, cc );
        pwc[cc] = 0;
    }

    return xString.Acquire();
} //UnMarshallWideString

WCHAR * UnMarshallWideStringNew( PDeSerStream & stm )
{
    ULONG cc = stm.GetULong();

    // Protect against attack.  We know our named pipes are < 64k

    if ( cc >= ( 65536 / sizeof WCHAR ) )
        THROW( CException( E_INVALIDARG ) );

    XArray<WCHAR> xString( cc + 1 );

    stm.GetWChar( xString.GetPointer(), cc );
    xString[cc] = 0;

    return xString.Acquire();
} //UnMarshallWideStringNew

//+-------------------------------------------------------------------------
//
//  Member:     CInternalPropertyRestriction::CInternalPropertyRestriction
//
//  Synopsis:   Creates property restriction
//
//  Arguments:  [relop] -- Relational operator (<, >, etc.)
//              [pid]   -- Property id
//              [prval] -- Property value
//              [pcrst] -- 'Helper' content restriction
//
//  History:    07-Mar-93 KyleP     Created
//
//--------------------------------------------------------------------------

CInternalPropertyRestriction::CInternalPropertyRestriction( ULONG relop,
                                                            PROPID pid,
                                                            CStorageVariant const & prval,
                                                            CRestriction * pcrst )
        : CRestriction( RTInternalProp, MAX_QUERY_RANK ),
          _relop( relop ),
          _pid( pid ),
          _prval( prval ),
          _pcrst( pcrst )
{
    if ( !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CInternalPropertyRestriction::CInternalPropertyRestriction
//
//  Synopsis:   Copy constructor
//
//  History:    30-May-95   SitaramR    Created.
//
//----------------------------------------------------------------------------

CInternalPropertyRestriction::CInternalPropertyRestriction(
    CInternalPropertyRestriction const & intPropRst )
    : CRestriction( RTInternalProp, intPropRst.Weight() ),
      _relop( intPropRst.Relation() ),
      _pid( intPropRst.Pid() ),
      _prval( intPropRst.Value() ),
      _pcrst( 0 )
{
    if ( !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    CRestriction *pHelperRst = intPropRst.GetContentHelper();

    if ( pHelperRst )
        _pcrst  = pHelperRst->Clone();
}




//+-------------------------------------------------------------------------
//
//  Member:     CInternalPropertyRestriction::~CInternalPropertyRestriction
//
//  Synopsis:   Cleanup restriction
//
//  History:    01-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CInternalPropertyRestriction::~CInternalPropertyRestriction()
{
    delete _pcrst;

    SetType( RTNone );                  // Avoid recursion.
}

void CInternalPropertyRestriction::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _relop );
    stm.PutULong( _pid );
    _prval.Marshall( stm );

    if ( 0 == _pcrst )
        stm.PutByte( 0 );
    else
    {
        stm.PutByte( 1 );
        _pcrst->Marshall( stm );
    }
}

CInternalPropertyRestriction::CInternalPropertyRestriction( ULONG ulWeight,
                                                            PDeSerStream & stm )
        : CRestriction( RTInternalProp, ulWeight ),
          _relop( stm.GetULong() ),
          _pid( stm.GetULong() ),
          _prval( stm )
{
    if ( !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    BYTE fRst = stm.GetByte();

    if ( fRst )
        _pcrst = CRestriction::UnMarshall( stm );
    else
        _pcrst = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CInternalPropertyRestriction::Clone, public
//
//  Synopsis:   Clones an internal property restriction
//
//  History:    30-May-95   SitaramR    Created.
//
//----------------------------------------------------------------------------

CInternalPropertyRestriction *CInternalPropertyRestriction::Clone() const
{
    return new CInternalPropertyRestriction( *this );
}

//+---------------------------------------------------------------------------
//
//  Member:     COccRestriction::COccRestriction, public
//
//  Synopsis:   Creates occurrence restriction
//
//  Arguments:  [ulType]  -- type of restriction
//              [ulWeight] -- weight
//              [occ] -- occurrence
//              [cPrevNoiseWords] -- count of previous noise words skipped
//              [cPostNoiseWords] -- count of post noise words skipped
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

COccRestriction::COccRestriction( ULONG ulType, ULONG ulWeight, OCCURRENCE occ,
                                  ULONG cPrevNoiseWords, ULONG cPostNoiseWords )
            : CRestriction( ulType, ulWeight ),
              _occ( occ ),
              _cPrevNoiseWords( cPrevNoiseWords),
              _cPostNoiseWords( cPostNoiseWords )
{
}


//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::~COccRestriction, public
//
//  Synopsis:   Cleanup occurrence restriction
//
//  Notes:      This destructor simulates virtual destruction.
//
//              Classes derived from COccRestriction must be sure to set their
//              restriction type to RTNone in their destructor, so when the
//              base destructor below is called the derived destructor is
//              not called a second time.
//
//  History:    29-Nov-94    SitaramR     Created
//
//--------------------------------------------------------------------------

COccRestriction::~COccRestriction()
{
    switch ( Type() )
    {
    case RTNone:
        break;

    case RTWord:
        ((CWordRestriction *)this)->CWordRestriction::~CWordRestriction();
        break;

    case RTSynonym:
        ((CSynRestriction *)this)->CSynRestriction::~CSynRestriction();
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class COccRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class COccRestriction" );
        break;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::IsValid(), public
//
//  History:    14-Nov-95 KyleP     Created
//
//  Returns:    TRUE if all memory allocations, etc. succeeded.
//
//--------------------------------------------------------------------------

BOOL COccRestriction::IsValid() const
{
    BOOL fValid = TRUE;

    switch ( Type() )
    {
    case RTWord:
        fValid = ((CWordRestriction *)this)->CWordRestriction::IsValid();
        break;

    case RTSynonym:
        fValid = ((CSynRestriction *)this)->CSynRestriction::IsValid();
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class COccRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class COccRestriction" );
        fValid = FALSE;
        break;
    }

    return fValid;
}


//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::Marshall, public
//
//  Synopsis:   Serialize occurrence restriction
//
//  Arguments:  [stm] -- stream to serialize to
//
//  History:    29-Nov-94    SitaramR     Created
//
//--------------------------------------------------------------------------

void COccRestriction::Marshall( PSerStream& stm ) const
{
    stm.PutULong( _occ );
    stm.PutULong( _cPrevNoiseWords );
    stm.PutULong( _cPostNoiseWords );
    switch ( Type() )
    {
    case RTWord:
        ((CWordRestriction *)this)->Marshall( stm );
        break;

    case RTSynonym:
        ((CSynRestriction *)this)->Marshall( stm );
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class COccRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class COccRestriction" );
        break;

    }
}


//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::COccRestriction, public
//
//  Synopsis:   De-serialize occurrence restriction
//
//  Arguments:  [ulType] -- type of occurrence restriction
//              [ulWeight] -- weight of occurrence restriction
//              [stm] -- stream to serialize from
//
//  History:    29-Nov-94    SitaramR     Created
//
//--------------------------------------------------------------------------

COccRestriction::COccRestriction( ULONG ulType, ULONG ulWeight, PDeSerStream& stm )
        : CRestriction( ulType, ulWeight )
{
    _occ = stm.GetULong();
    _cPrevNoiseWords = stm.GetULong();
    _cPostNoiseWords = stm.GetULong();
}




//+-------------------------------------------------------------------------
//
//  Member:     COccRestriction::Clone, public
//
//  Synopsis:   Clone occurrence restriction
//
//  History:    29-Nov-94    SitaramR     Created
//
//--------------------------------------------------------------------------

COccRestriction *COccRestriction::Clone() const
{
    switch ( Type() )
    {
    case RTWord:
        return ((CWordRestriction *)this)->Clone();
        break;

    case RTSynonym:
        return ((CSynRestriction *)this)->Clone();
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class COccRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class COccRestriction" );
        return 0;
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CWordRestriction::CWordRestriction, public
//
//  Synopsis:   Creates word expression
//
//  Arguments:  [keyBuf]  -- key to be matched
//              [occ]     -- occurrence (if in phrase)
//              [isRange] -- TRUE if key is a prefix
//
//  History:    19-Sep-91   BartoszM    Created.
//
//----------------------------------------------------------------------------

CWordRestriction::CWordRestriction ( const CKeyBuf& keyBuf,
                                     OCCURRENCE occ,
                                     ULONG cPrevNoiseWords,
                                     ULONG cPostNoiseWords,
                                     BOOL isRange )
        : COccRestriction( RTWord, MAX_QUERY_RANK, occ, cPrevNoiseWords, cPostNoiseWords ),
          _isRange(isRange)
{
    // copy after init to 0 in case new fails and ~CWordRestriction is
    // called from ~CRestriction

    _key = keyBuf;
}



//+---------------------------------------------------------------------------
//
//  Member:     CWordRestriction::CWordRestriction, public
//
//  Synopsis:   Copy constuctor
//
//  Arguments:  [wordRst]  -- word restriction to be copied
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

CWordRestriction::CWordRestriction( const CWordRestriction& wordRst )
    : COccRestriction( RTWord, wordRst.Weight(), wordRst.Occurrence(),
                       wordRst.CountPrevNoiseWords(), wordRst.CountPostNoiseWords() ),
      _isRange( wordRst.IsRange() )
{
    // copy after init to 0 in case new fails and ~CWordRestriction is
    // called from ~CRestriction

    _key = *wordRst.GetKey();
}




//+-------------------------------------------------------------------------
//
//  Member:     CWordRestriction::~CWordRestriction, public
//
//  Synopsis:   Cleanup restriction
//
//  History:    01-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CWordRestriction::~CWordRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CWordRestriction::Marshall( PSerStream & stm ) const
{
    _key.Marshall( stm );
    stm.PutByte( (BYTE)_isRange );
}

CWordRestriction::CWordRestriction( ULONG ulWeight, PDeSerStream & stm )
        : COccRestriction( RTWord, ulWeight, stm ),
          _key( stm ),
          _isRange( stm.GetByte() )
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CWordRestriction::Clone, public
//
//  Synopsis:   Clone restriction
//
//  History:    29-Nov-94   SitaramR   Created.
//
//----------------------------------------------------------------------------

CWordRestriction *CWordRestriction::Clone()  const
{
    return new CWordRestriction( *this );
}



//+---------------------------------------------------------------------------
//
//  Member:     CSynRestriction::CSynRestriction, public
//
//  Synopsis:   Creates Syn expression
//
//  Arguments:  [occ] -- occurrence (if in phrase)
//              [isRange] -- is it range?
//
//  History:    07-Feb-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

const int cSynonyms = 2; // default initial count of synonyms

CSynRestriction::CSynRestriction ( const CKey& key,
                                   OCCURRENCE occ,
                                   ULONG cPrevNoiseWords,
                                   ULONG cPostNoiseWords,
                                   BOOL isRange )
        : COccRestriction( RTNone, MAX_QUERY_RANK, occ, cPrevNoiseWords, cPostNoiseWords ),
          _keyArray( cSynonyms, TRUE ),
          _isRange(isRange)
{
    _keyArray.Add ( key );
    SetType( RTSynonym );
}




//+---------------------------------------------------------------------------
//
//  Member:     CSynRestriction::CSynRestriction, public
//
//  Synopsis:   Copy constuctor
//
//  Arguments:  [synRst]  -- synonym restriction to be copied
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

CSynRestriction::CSynRestriction( CSynRestriction& synRst )
    : COccRestriction( RTNone, synRst.Weight(), synRst.Occurrence(),
                       synRst.CountPrevNoiseWords(), synRst.CountPostNoiseWords() ),
      _keyArray( synRst.GetKeys(), TRUE ),
      _isRange( synRst.IsRange() )
{
    SetType( RTSynonym );
}



//+-------------------------------------------------------------------------
//
//  Member:     CSynRestriction::~CSynRestriction, public
//
//  Synopsis:   Cleanup restriction
//
//  History:    01-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CSynRestriction::~CSynRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CSynRestriction::Marshall( PSerStream & stm ) const
{
    _keyArray.Marshall( stm );
    stm.PutByte( (BYTE)_isRange );
}

CSynRestriction::CSynRestriction( ULONG ulWeight, PDeSerStream & stm )
        : COccRestriction( RTNone, ulWeight, stm),
          _keyArray( stm, TRUE ),
          _isRange( stm.GetByte() )
{
    SetType( RTSynonym );
}



//+---------------------------------------------------------------------------
//
//  Member:     CSynRestriction::Clone, public
//
//  Synopsis:   Clone restriction
//
//  History:    29-Nov-94   SitaramR   Created.
//
//----------------------------------------------------------------------------

CSynRestriction *CSynRestriction::Clone() const
{
    return new CSynRestriction( *(CSynRestriction *)this );
}




//+---------------------------------------------------------------------------
//
//  Member:     CSynRestriction::AddKey, public
//
//  Synopsis:   Adds synonym key
//
//  Arguments:  [keyBuf] -- key
//
//  History:    07-Feb-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CSynRestriction::AddKey ( const CKeyBuf& Key )
{
    _keyArray.Add ( Key );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::CRangeRestriction, public
//
//  Synopsis:   Creates word expression
//
//  Arguments:  [pid] -- property id
//              [keyStart] -- starting key
//              [keyEnd] -- ending key
//
//  History:    24-Sep-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

CRangeRestriction::CRangeRestriction()
        : CRestriction( RTRange, MAX_QUERY_RANK )
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::CRangeRestriction
//
//  Synopsis:   Copy constructor
//
//  History:    30-May-95   SitaramR    Created
//
//----------------------------------------------------------------------------

CRangeRestriction::CRangeRestriction( const CRangeRestriction& rangeRst )
    : CRestriction( RTNone, rangeRst.Weight() )
{
    const CKey *pKeyStart = rangeRst.GetStartKey();

    if ( pKeyStart )
        _keyStart = *pKeyStart;

    const CKey *pKeyEnd = rangeRst.GetEndKey();

    if ( pKeyEnd )
        _keyEnd = *pKeyEnd;

    SetType( RTRange );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::~CRangeRestriction, public
//
//  Synopsis:   Cleanup restriction
//
//  History:    01-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CRangeRestriction::~CRangeRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CRangeRestriction::Marshall( PSerStream & stm ) const
{
    _keyStart.Marshall( stm );
    _keyEnd.Marshall( stm );
}

CRangeRestriction::CRangeRestriction( ULONG ulWeight, PDeSerStream & stm )
        : CRestriction( RTNone, ulWeight ),
          _keyStart( stm ),
          _keyEnd( stm )
{
    SetType( RTRange );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::SetStartKey, public
//
//  Arguments:  [keyStart] -- starting key
//
//  History:    24-Sep-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CRangeRestriction::SetStartKey ( const CKeyBuf& keyStart )
{
    _keyStart = keyStart;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::SetEndKey, public
//
//  Arguments:  [keyEnd] -- Ending key
//
//  History:    24-Sep-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CRangeRestriction::SetEndKey ( const CKeyBuf& keyEnd )
{
    _keyEnd = keyEnd;
}



//+---------------------------------------------------------------------------
//
//  Member:     CRangeRestriction::Clone
//
//  Synopsis:   Clones a range restriction
//
//  History:    30-May-95   SitaramR    Created
//
//----------------------------------------------------------------------------

CRangeRestriction *CRangeRestriction::Clone() const
{
    return new CRangeRestriction( *this );
}




//+---------------------------------------------------------------------------
//
//  Member:     CUnfilteredRestriction::CUnfilteredRestriction, public
//
//  History:    10-Nov-94   KyleP       Created.
//
//  Notes:      This restriction is just a very special case of range
//              restriction that searches only for a particular value.
//              Standard procedure to create a range restriction is
//              sidetracked to save code.
//
//----------------------------------------------------------------------------

CUnfilteredRestriction::CUnfilteredRestriction()
{
    static const BYTE abUnfiltered[] = { VT_UI1,
                                  (BYTE)(pidUnfiltered >> 24),
                                  (BYTE)(pidUnfiltered >> 16),
                                  (BYTE)(pidUnfiltered >> 8),
                                  (BYTE) pidUnfiltered,
                                  0,
                                  1 };

    static CKeyBuf keyUnfilteredRange( pidUnfiltered, abUnfiltered, sizeof(abUnfiltered) );

    SetStartKey( keyUnfilteredRange );
    SetEndKey( keyUnfilteredRange );

#if DBG == 1 && CIDBG == 1
    CRangeKeyRepository krep;
    CValueNormalizer norm( krep );
    OCCURRENCE occ = 1;
    CStorageVariant var;
    var.SetBOOL( (VARIANT_BOOL)0xFFFF );

    norm.PutValue( pidUnfiltered, occ, var );
    norm.PutValue( pidUnfiltered, occ, var );

    CRestriction * prst = krep.AcqRst();

    Win4Assert( prst->Type() == RTRange );

    CRangeRestriction * pRange = (CRangeRestriction *)prst;

    Win4Assert( pRange->GetStartKey()->Compare( *GetStartKey() ) == 0 );
    Win4Assert( pRange->GetEndKey()->Compare( *GetEndKey() ) == 0 );

    delete prst;
#endif
}



//+---------------------------------------------------------------------------
//
//  Member:     CPhraseRestriction::CPhraseRestriction, public
//
//  Synopsis:   Deserializes phrase restriction
//
//  Arguments:  [ulWeight]  -- restriction weight
//              [stm] -- stream to deserialize from
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

CPhraseRestriction::CPhraseRestriction( ULONG ulWeight, PDeSerStream& stm )
        : CNodeRestriction( RTPhrase, ulWeight, stm  )
{
#if CIDBG == 1
    for ( unsigned i = 0; i < _cNode; i++ )
        Win4Assert( _paNode[i]->Type() == RTWord || _paNode[i]->Type() == RTSynonym );
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseRestriction::~CPhraseRestriction, public
//
//  History:    29-Nov-94   SitaramR    Created.
//
//----------------------------------------------------------------------------

CPhraseRestriction::~CPhraseRestriction()
{
    if ( 0 != _paNode )
    {
        for ( unsigned i = 0; i < _cNode; i++ )
        {
            #if CIDBG == 1
                if ( 0 != _paNode[i] )
                {
                    Win4Assert( _paNode[i]->Type() == RTWord ||
                                _paNode[i]->Type() == RTSynonym );
                }
            #endif // CIDBG

            delete (COccRestriction *) _paNode[i];
        }

        delete [] _paNode;
    }

    SetType( RTNone );                  // Avoid recursion.
}


CScopeRestriction::CScopeRestriction( WCHAR const * pwcsPath, BOOL fRecursive, BOOL fVirtual )
        : CRestriction( RTScope, MAX_QUERY_RANK ),
          _fValid( FALSE ),
          _fRecursive( fRecursive ),
          _fVirtual( fVirtual )
{
    SetPath( pwcsPath );
}

CScopeRestriction * CScopeRestriction::Clone() const
{
    return( new CScopeRestriction( _lowerFunnyPath.GetActualPath(), _fRecursive, _fVirtual ) );
}

CScopeRestriction::~CScopeRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CScopeRestriction::Marshall( PSerStream & stm ) const
{
    stm.PutWString( _lowerFunnyPath.GetActualPath() );
    stm.PutULong( _lowerFunnyPath.GetActualLength() );
    stm.PutULong( _fRecursive );
    stm.PutULong( _fVirtual );
}

CScopeRestriction::CScopeRestriction( ULONG ulWeight, PDeSerStream & stm )
        : CRestriction( RTScope, ulWeight ),
          _fValid( FALSE )
{
    XCoMem<WCHAR> xString( UnMarshallWideString( stm ) );

    //
    // Simple validity checks; not all-inclusive.  Just
    // return with _fValid set to FALSE and the query
    // will fail with an out of memory error.
    //

    // We don't support long paths for scopes.

    if ( wcslen( xString.GetPointer() ) >= MAX_PATH )
        return;

    // We don't support the NTFS special stream syntax

    if ( 0 != wcsstr( xString.GetPointer(), L"::$" ) )
        return;

    stm.GetULong(); // length not needed

    _fRecursive = stm.GetULong();
    _fVirtual = stm.GetULong();
    _lowerFunnyPath.SetPath( xString.Acquire() );
    _fValid = TRUE; // since we have a valid path
}

CScopeRestriction & CScopeRestriction::operator =(
    CScopeRestriction const & source )
{
    _lowerFunnyPath = source._lowerFunnyPath;
    _fRecursive = source._fRecursive;
    _fVirtual = source._fVirtual;
    _fValid = source._fValid;

    return *this;
}

//+---------------------------------------------------------------------------
//
//  Method:     CScopeRestriction::SetPath
//
//  Synopsis:   Validates and sets a path in a scope restriction
//
//  History:    24-Oct-96   dlee    Created.
//
//----------------------------------------------------------------------------

void CScopeRestriction::SetPath( WCHAR const * pwcsPath )
{
    _fValid = FALSE;

    //
    // Simple validity checks; not all-inclusive.  Just
    // return with _fValid set to FALSE and the query
    // wil fail with an out of memory error.
    //

    // We don't support long paths for scopes.

    if ( wcslen( pwcsPath ) >= MAX_PATH )
        return;

    // We don't support the NTFS special stream syntax

    if ( 0 != wcsstr( pwcsPath, L"::$" ) )
        return;

    _lowerFunnyPath.Truncate(0);
    if ( pwcsPath)
    {
        _lowerFunnyPath.SetPath( pwcsPath );
        _fValid = TRUE;
    }
} //SetPath

//+---------------------------------------------------------------------------
//
//  Function:   ValidateScopeRestriction
//
//  Synopsis:   Verifies a scope restriction looks ok.  Can't use
//              CRestriction::IsValid since this needs to make sure there
//              aren't any odd nodes in the tree (like proximity, etc.)
//
//  Returns:    TRUE if it is ok, FALSE otherwise
//
//  History:    24-Oct-96   dlee    Created.
//
//----------------------------------------------------------------------------

BOOL ValidateScopeRestriction( CRestriction * pRst )
{
    if ( 0 == pRst )
        return FALSE;

    switch ( pRst->Type() )
    {
#if 0 // someday we might support exclusion scopes
        case RTNot:
        {
            CRestriction *p = ((CNotRestriction *)pRst)->GetChild();
            return ValidateScopeRestriction( p );
            break;
        }
        case RTAnd:
#endif // 0 // exclusion scopes
        case RTOr:
        {
            CNodeRestriction * p = pRst->CastToNode();
            for ( ULONG x = 0; x < p->Count(); x++ )
            {
                if ( !ValidateScopeRestriction( p->GetChild( x ) ) )
                    return FALSE;
            }
            break;
        }
        case RTScope:
        {
            CScopeRestriction *p = (CScopeRestriction *) pRst;
            if ( !p->IsValid() )
                return FALSE;
            break;
        }
        default :
        {
            return FALSE;
        }
    }

    return TRUE;
} //ValidateScopeRestriction

#if CIDBG == 1

//+-------------------------------------------------------------------------
//
//  Function:   DisplayChar
//
//  Synopsis:   Debug print the non-ascii text buffer
//
//  Arguments:  [pwString] -- Pointer to string (not null terminated)
//              [cString]  -- len of the string in char
//              [infolevel] --
//
//  History:    22-Apr-98   KitmanH      Created
//
//--------------------------------------------------------------------------

void DisplayChar( WCHAR * pwString, DWORD cString, ULONG infolevel )
{

    BOOL fOk = TRUE;
    for ( unsigned i = 0; i < cString; i++ )
    {
        if ( pwString[i] > 0xFF )
        {
            fOk = FALSE;
            break;
        }
    }

    if ( fOk )
    {
        unsigned j = 0;
        WCHAR awcTemp[71];

        for ( unsigned i = 0; i < cString; i++ )
        {
            awcTemp[j] = pwString[i];
            j++;

            if ( j == sizeof(awcTemp)/sizeof(awcTemp[0]) - 1 )
            {
                awcTemp[j] = 0;
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\"%ws\"", awcTemp ));
                j = 0;
            }
        }

        awcTemp[j] = 0;
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\"%ws\"", awcTemp ));
    }
    else
    {
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "0x" ));

        unsigned j = 0;

        for ( unsigned i = 0; i < cString; i++ )
        {
            if ( 0 == j )
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "%04X", pwString[i] ));
            else if ( 14 == j )
            {
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, " %04X\n", pwString[i] ));
            }
            else
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, " %04X", pwString[i] ));

            j++;

            if ( j > 14 )
                j = 0;
        }

    }

}

void Display( CRestriction * pRst, int indent, ULONG infolevel )
{
    vqDebugOut(( infolevel, "    " ));

    for ( int i = 0; i < indent; i++ )
    {
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "    " ));
    }

    switch ( pRst->Type() )
    {
    case RTContent:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME,
                     "CONTENT: \"%ws\", LOCALE: %lu\n",
                     ((CContentRestriction *)pRst)->GetPhrase(),
                     ((CContentRestriction *)pRst)->GetLocale() ));
        break;

    case RTNatLanguage:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME,
                     "NATURAL LANGUAGE: \"%ws\", LOCALE: %lu\n",
                     ((CNatLanguageRestriction *)pRst)->GetPhrase(),
                     ((CNatLanguageRestriction *)pRst)->GetLocale() ));
        break;

    case RTWord:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "WORD%s: ",
                     ((CWordRestriction *)pRst)->IsRange() ? " PREFIX" : "" ));
        DisplayChar( ((CWordRestriction *)pRst)->GetKey()->GetStr(),
                     ((CWordRestriction *)pRst)->GetKey()->StrLen(),
                     infolevel
                   );

        vqDebugOut(( infolevel | DEB_NOCOMPNAME,
                     " PID %d OCC %d, WEIGHT %d\n",
                     ((CWordRestriction *)pRst)->Pid(),
                     ((CWordRestriction *)pRst)->Occurrence(),
                     ((CWordRestriction *)pRst)->Weight() ));
        break;

    case RTSynonym:
    {
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "SYNONYM: OCC %d ",
                     ((CSynRestriction *)pRst)->Occurrence() ));
        CKeyArray & keys = ((CSynRestriction *)pRst)->GetKeys();

        for ( int i = 0; i < keys.Count(); i++ )
        {
            DisplayChar( keys.Get(i).GetStr(), keys.Get(i).StrLen(),
                         infolevel );
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, " " ));
        }
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\n" ));
        break;
    }

    case RTRange:
    {
        CRangeRestriction * pr = (CRangeRestriction *)pRst;

        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "RANGE: " ));

        char * pc = new char[pr->GetStartKey()->Count() * 2 +
                                            1 +
                                            pr->GetEndKey()->Count() * 2 +
                                            2];

        for ( unsigned i = 0; i < pr->GetStartKey()->Count(); i++ )
            sprintf( pc + i*2, "%02x", pr->GetStartKey()->GetBuf()[i] );

        pc[i*2] = '-';

        for ( unsigned j = 0; j < pr->GetEndKey()->Count(); j++ )
            sprintf( pc + i*2 + 1 + j*2, "%02x", pr->GetEndKey()->GetBuf()[j] );

        pc[i*2 + 1 + j*2] = '\n';
        pc[i*2 + 1 + j*2 + 1] = 0;
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, pc ));
        delete [] pc;
        break;
    }

    case RTProperty:
        if ( ((CPropertyRestriction *)pRst)->Relation() == PRRE )
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "REGEX " ));
        else
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "PROPERTY " ));

        ((CPropertyRestriction *) pRst)->Value().DisplayVariant(
                                                    infolevel | DEB_NOCOMPNAME,
                                                    0);
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\n" ));
        break;

    case RTInternalProp:
    {
        CInternalPropertyRestriction * pir = (CInternalPropertyRestriction *)pRst;

        if ( pir->Relation() == PRRE )
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "REGEX pid(0x%lx) ",
                         pir->Pid() ));
        else
        {
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "PROPERTY pid(0x%lx) ", pir->Pid() ));
            switch ( getBaseRelop( pir->Relation() ) )
            {
            case PRLT:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "< " ));
                break;

            case PRLE:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "<= " ));
                break;

            case PRGT:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "> " ));
                break;

            case PRGE:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, ">= " ));
                break;

            case PREQ:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "== " ));
                break;

            case PRNE:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "!= " ));
                break;

            case PRAllBits:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "All bits " ));
                break;

            case PRSomeBits:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "Some bits " ));
                break;

            default:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "??? " ));
                break;
            }

            if ( pir->Relation() & PRAll )
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "All " ));
            else if ( pir->Relation() & PRAny )
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "Any " ));

        }

        pir->Value().DisplayVariant(infolevel | DEB_NOCOMPNAME, 0);

        if ( pir->GetContentHelper() )
        {
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\n" ));

            for ( int i = 0; i < indent+5; i++ )
            {
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "    " ));
            }
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "HELPER:\n" ));
            Display( pir->GetContentHelper(), indent+3, infolevel );
        }
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "\n" ));
        break;
    }

    case RTNot:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "NOT\n" ));
        Display( ((CNotRestriction *)pRst)->GetChild(), indent + 1, infolevel );
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    case RTPhrase:
    {
        switch( pRst->Type() )
        {
        case RTAnd:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "AND\n" ));
            break;

        case RTOr:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "OR\n" ));
            break;

        case RTNot:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "NOT\n" ));
            break;

        case RTProximity:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "PROXIMITY\n" ));
            break;

        case RTVector:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "VECTOR " ));
            switch ( ((CVectorRestriction *)pRst)->RankMethod() )
            {
            case VECTOR_RANK_MIN:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Min)\n" ));
                break;

            case VECTOR_RANK_MAX:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Max)\n" ));
                break;

            case VECTOR_RANK_INNER:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Inner Product)\n" ));
                break;

            case VECTOR_RANK_DICE:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Dice Coefficient)\n" ));
                break;

            case VECTOR_RANK_JACCARD:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(Jaccard Coefficient)\n" ));
                break;

            default:
                vqDebugOut(( infolevel | DEB_NOCOMPNAME, "(???)\n" ));
                break;
            }
            break;

        case RTPhrase:
            vqDebugOut(( infolevel | DEB_NOCOMPNAME, "PHRASE\n" ));
            break;
        }

        CNodeRestriction * pNodeRst = pRst->CastToNode();

        for ( UINT i = 0; i < pNodeRst->Count(); i++ )
        {
            Display( pNodeRst->GetChild( i ), indent + 1, infolevel );
        }
        break;
    }

    case RTNone:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "NONE -- empty\n" ));
        break;

    default:
        vqDebugOut(( infolevel | DEB_NOCOMPNAME, "UNKNOWN\n" ));
        break;

    }
}

#endif // CIDBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\sizeser.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       SizeSer.cxx
//
//  Contents:   Class to compute size of serialized structure.
//
//  History:    28-Jul-94 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <sizeser.hxx>

CSizeSerStream::CSizeSerStream()
        : _cb( 0 )
{
}

CSizeSerStream::~CSizeSerStream()
{
}

void CSizeSerStream::PutByte( BYTE b )
{
    Win4Assert( sizeof(BYTE) == 1 );
    _cb += 1;
}

void CSizeSerStream::PutChar( char const * pc, ULONG cc )
{
    Win4Assert( sizeof(char) == 1 );
    _cb += cc;
}

void CSizeSerStream::PutWChar( WCHAR const * pwc, ULONG cc )
{
    Win4Assert( sizeof(WCHAR) == 2 );
    _cb = (unsigned)((ULONG_PTR)AlignWCHAR((BYTE *) UIntToPtr( _cb ) )) + sizeof(WCHAR) * cc;
}

void CSizeSerStream::PutUShort( USHORT us )
{
    Win4Assert( sizeof(USHORT) == 2 );
    _cb = (unsigned)((ULONG_PTR)AlignUSHORT((BYTE *) UIntToPtr( _cb ) )) + sizeof(USHORT);
}

void CSizeSerStream::PutULong( ULONG ul )
{
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG);
}

void CSizeSerStream::PutLong( long l )
{
    Win4Assert( sizeof(long) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignLong((BYTE *) UIntToPtr( _cb ) )) + sizeof(long);
}

void CSizeSerStream::PutFloat( float f )
{
    Win4Assert( sizeof(float) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignFloat((BYTE *) UIntToPtr( _cb ) )) + sizeof(float);
}

void CSizeSerStream::PutDouble( double d )
{
    Win4Assert( sizeof(double) == 8 );
    _cb = (unsigned)((ULONG_PTR)AlignDouble((BYTE *) UIntToPtr( _cb ) )) + sizeof(double);
}

void CSizeSerStream::PutString( char const * psz )
{
    Win4Assert( sizeof(char) == 1 );
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG) + strlen(psz);
}

void CSizeSerStream::PutWString( WCHAR const * pwsz )
{
    Win4Assert( sizeof(WCHAR) == 2 );
    Win4Assert( sizeof(ULONG) == 4 );
    _cb = (unsigned)((ULONG_PTR)AlignULONG((BYTE *) UIntToPtr( _cb ) )) + sizeof(ULONG) +
        wcslen(pwsz) * sizeof(WCHAR);
}

void CSizeSerStream::PutBlob( BYTE const * pb, ULONG cb )
{
    Win4Assert( sizeof(BYTE) == 1 );
    _cb += cb;
}

void CSizeSerStream::PutGUID( GUID const & guid )
{
    Win4Assert( sizeof(GUID) == 16 );
    _cb = (unsigned)((ULONG_PTR)AlignGUID((BYTE *) UIntToPtr( _cb ) )) + sizeof(GUID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\norm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       NORM.CXX
//
//  Contents:   Normalizer
//
//  Classes:    CNormalizer
//
//  History:    28-May-91   t-WadeR     added CNormalizer
//              31-Jan-92   BartoszM    Created from lang.cxx
//              07-Oct-93   DwightKr    Added new methods to normalize
//                                      different data types
//
//  Notes:      The filtering pipeline is hidden in the Data Repository
//              object which serves as a sink for the filter.
//              The sink for the Data Repository is the Key Repository.
//              The language dependent part of the pipeline
//              is obtained from the Language List object and is called
//              Key Maker. It consists of:
//
//                  Word Breaker
//                  Stemmer (optional)
//                  Normalizer
//                  Noise List
//
//              Each object serves as a sink for its predecessor,
//              Key Repository is the final sink.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <plang.hxx>
#include <misc.hxx>
#include <norm.hxx>

//+---------------------------------------------------------------------------
//
//  Function    GetExpAndSign
//
//  Synopsis:   Finds the exponent and sign of a number
//
//  Arguments:  [d]          -- the input number to examine
//              [fPositive]  -- returns TRUE if positive, FALSE if negative
//
//  Returns:    The exponent
//
//  History:    21-Nov-94   KyleP        Created.
//
//----------------------------------------------------------------------------

int GetExpAndSign( double d, BOOL & fPositive )
{
    //
    // bit 63       = sign
    // bits 52 - 62 = exponent
    // bits 0 - 51  = mantissa
    //

    Win4Assert( sizeof(LARGE_INTEGER) == sizeof(double) );

    LARGE_INTEGER * pli = (LARGE_INTEGER *)&d;

    fPositive = (pli->HighPart & 0x80000000) == 0;

    int const bias = 0x3ff;

    return ( ( pli->HighPart & 0x7ff00000 ) >> 20 ) - bias;
} //GetExpAndSign

//+---------------------------------------------------------------------------
//
//  Function    NormDouble
//
//  Synopsis:   Normalizes doubles by taking log2 of the number
//
//  Notes:      This func converts doubles into one of 5 different categories
//
//              x < -1x2**32                 is in bin 0
//              -1x2**32  <= x <= -1x2**-32  are in bins 1 to 65
//              -1x2**-32 <= x <=  1x2**-32  is in bin 66
//               1x2**-32 <= x <=  1x2**32   are in bins 67 to 131
//               x > 1x2**32                 is bin bin 132
//
//  History:    21-Nov-94   KyleP        Created.
//
//----------------------------------------------------------------------------

static unsigned NormDouble(double dValue)
{
    const int SignificantExponent = 32;
    const int SignificantRange = SignificantExponent * 2;

    const unsigned LowestBin  = 0;                                // 0
    const unsigned LowerBin   = LowestBin + 1;                    // 1
    const unsigned MiddleBin  = LowerBin + SignificantRange + 1;  // 66
    const unsigned UpperBin   = MiddleBin + 1;                    // 67
    const unsigned HighestBin = UpperBin+ SignificantRange + 1;   // 132


    BOOL fPositive;

    int exp = GetExpAndSign( dValue, fPositive );

    unsigned bin;

    if ( exp < -SignificantExponent )
    {
        //
        // All numbers close to zero in middle bin
        //

        bin = MiddleBin;
    }
    else if ( exp > SignificantExponent )
    {
        if ( fPositive )
        {
            //
            // Very large positive numbers in top bin
            //

            bin = HighestBin;
        }
        else
        {
            //
            // Very large negative numbers in bottom bin
            //

            bin = LowestBin;
        }
    }
    else
    {
        if ( fPositive )
        {
            //
            // medium size positive numbers
            //

            bin = UpperBin + exp + SignificantExponent;
        }
        else
        {
            //
            // medium size negative numbers
            //

            bin = LowerBin - exp + SignificantExponent;
        }
    }
    return bin;
}

#ifdef  TEST_NORM
//
// a test to verify the validity of the NormDouble function.
//
void TestNormDouble()
{
    float fVal0 = 0.;
    float fVal1 = 1.;
    unsigned nZero = NormDouble( fVal0 );
    unsigned nOne = NormDouble( fVal1 );

    printf(" Value:Bin %f : 0x%4X (%d)\n", fVal0, nZero, nZero );
    printf(" Value:Bin %f : 0x%4X (%d)\n", fVal1, nOne, nOne );

    BOOL fPos;
    float f = fVal1;
    unsigned nPrev = nOne;
    while ( f > fVal0 )
    {
        unsigned nVal = NormDouble( f );
        if (nVal > nPrev || nVal < nZero || nVal > nOne)
        {
            printf(" Value:Bin %f : 0x%4X (%d)\tExp %d\n", f, nVal, nVal, GetExpAndSign(f, fPos) );
        }

        nPrev = nVal;
        f = f/3;
    }

    f = fVal1;
    nPrev = nOne;
    while ( f < 1e+32 )
    {
        unsigned nVal = NormDouble( f );
        if (nVal < nPrev)
            printf(" Value:Bin %f : 0x%4X (%d)\n", f, nVal, nVal );

        nPrev = nVal;
        f = f * (float)1.5;
    }

    float fValm1 = -1.;
    unsigned nMinusOne = NormDouble( fValm1 );

    printf(" Value:Bin %f : 0x%4X (%d)\n", fValm1, nMinusOne, nMinusOne );

    f = fValm1;
    nPrev = nMinusOne;
    while ( f < fVal0 )
    {
        unsigned nVal = NormDouble( f );
        if (nVal < nPrev || nVal > nZero || nVal < nMinusOne)
            printf(" Value:Bin %f : 0x%4X (%d)\tExp %d\n", f, nVal, nVal, GetExpAndSign(f, fPos) );

        nPrev = nVal;
        f = f/3;
    }

    f = fValm1;
    nPrev = nMinusOne;
    while ( f > -1e+32 )
    {
        unsigned nVal = NormDouble( f );
        if (nVal > nPrev)
            printf(" Value:Bin %f : 0x%4X (%d)\n", f, nVal, nVal );

        nPrev = nVal;
        f = f * (float)1.5;
    }
}
#endif  // 0


// ------------------------------------------------------------------------
// | Upper Limit  |  Divisor (2^x) | # of Bins        | (in hex)          |
// ------------------------------------------------------------------------
// | 2^10 - 1     |   2^0          | 2^10  - 0        | 0400 - 0000       |
// | 2^16 - 1     |   2^3          | 2^12  - 2^7      | 2000 - 0080       |
// | 2^20 - 1     |   2^6          | 2^14  - 2^10     | 4000 - 0400       |
// | 2^26 - 1     |   2^13         | 2^13  - 2^7      | 2000 - 0080       |
// | 2^30 - 1     |   2^23         | 2^7   - 2^3      | 0080 - 0008       |
// | 2^31 - 1     |   2^25         | 2^6   - 2^5      | 0040 - 0020       |
// ------------------------------------------------------------------------
// | Total        |                |                  | 84C0 - 04D8       |
// |              |                |                  |     7FE8          |
// ------------------------------------------------------------------------

const long limit1 = 0x400;
const long shift1 = 0;
const long cbins1 = 0x400;

const long limit2 = 0x10000;        // 2^16
const long shift2 = 3;
const long cSkip1 = limit1 >> shift2;
const long cbins2 = (limit2 >> shift2)-cSkip1;

const long limit3 = 0x100000;       // 2^20
const long shift3 = 6;
const long cSkip2 = limit2 >> shift3;
const long cbins3 = (limit3 >> shift3) - cSkip2;

const long limit4 = 0x4000000;      // 2^26
const long shift4 = 13;
const long cSkip3 = limit3 >> shift4;
const long cbins4 = (limit4 >> shift4) - cSkip3;

const long limit5 = 0x40000000;     // 2^30
const long shift5 = 23;
const long cSkip4 = limit4 >> shift5;
const long cbins5 = (limit5 >> shift5) - cSkip4;

const long limit6 = MINLONG;     // 2^31
const long shift6 = 25;
const long cSkip5 = limit5 >> shift6;
const long cbins6 = ((long) ((unsigned) limit6 >> shift6)) - cSkip5;

static unsigned MapLong( LONG lValue )
{

    Win4Assert( !(lValue & MINLONG) || ( MINLONG == lValue ) );

#if CIDBG==1
    const long cTotal = cbins1 + cbins2 + cbins3 + cbins4 + cbins5 + cbins6;
    Win4Assert( cTotal <= MINSHORT );
#endif  // CIDBG == 1

    unsigned ulValue = (unsigned) lValue;

    unsigned binNum = (unsigned) lValue;;

    if ( ulValue < limit1 )
    {
        //
        // Nothing to do.
        //
    }
    else if ( ulValue < limit2 )
    {
        binNum = cbins1 - cSkip1 + (ulValue >> shift2);
    }
    else if ( ulValue < limit3 )
    {
        binNum = cbins1 + cbins2 - cSkip2 + (binNum >> shift3);
    }
    else if ( ulValue < limit4 )
    {
        binNum = cbins1 + cbins2 + cbins3 - cSkip3 + (binNum >> shift4);
    }
    else if ( ulValue < limit5 )
    {
        binNum = cbins1 + cbins2 + cbins3 + cbins4 - cSkip4 + (binNum >> shift5);
    }
    else
    {
        binNum = cbins1 + cbins2 + cbins3 + cbins4 + cbins5 - cSkip5 + (binNum >> shift6);
    }

    return binNum;
}

//+---------------------------------------------------------------------------
//
//  Function:   NormLong
//
//  Synopsis:   Normalizes the given "signed" long value to a value between
//              0x0000 - 0xFFFF. The negative numbers occupy 0x0000-0x8000.
//              Positive numbers occupy 0x8000-0xFFFF
//
//  Arguments:  [lValue] - The value to be normalized.
//
//  History:    10-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned NormLong(LONG lValue)
{
    if (lValue >= 0)
    {
        return MapLong(lValue) + MINSHORT;
    }
    else
    {
        return MINSHORT - MapLong(-lValue);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   NormULong
//
//  Synopsis:   Normalizes an "unsigned" long value to a value between
//              0x0000-0xFFFF.  Numbers from 0-2^31 - 1 are mapped in the
//              range 0x0000-0x7FFF.  Numbers 2^31 to 2^32 - 1 are mapped
//              in the range 0x8000 - 0xFFFF
//
//  Arguments:  [lValue] -  The value to be mapped.
//
//  History:    10-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned NormULong( ULONG lValue )
{
    unsigned val = MapLong( lValue & ~MINLONG );    // turn off the high bit

    Win4Assert( !(val & MINSHORT) );

    if ( lValue & MINLONG )
        val |= MINSHORT;

    return val;
}

//+---------------------------------------------------------------------------
//
//  Function:   MapLargeInteger
//
//  Synopsis:   Maps a LargeInteger to a number between 0x0000-0x7FFF.
//
//              Numbers with the "HighPart" = 0 are mapped in the range
//              0x0000-0x3FFF.  When the HighPart !=0, the values are
//              mapped to 0x4000 - 0x7FFF
//
//  Arguments:  [liValue] - The value to be mapped.
//
//  History:    10-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned MapLargeInteger( LARGE_INTEGER & liValue )
{
    Win4Assert( !(liValue.HighPart & MINLONG) || ( MINLONG == liValue.HighPart ) );

    unsigned normVal;

    if ( 0 == liValue.HighPart )
    {
        normVal = NormULong( liValue.LowPart );
        normVal >>= 2;
    }
    else
    {
        normVal = MapLong( liValue.HighPart );  // 0x0000-0x7FFF
        normVal >>= 1;
        normVal |= 0x4000;
    }

    Win4Assert( normVal < 0x8000 );

    return normVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   NormULargeInteger
//
//  Synopsis:   Normalizes an unsigned LargeInteger to a number between
//              0x0000-0xFFFF.
//
//              Numbers with the "HighPart" = 0 are mapped in the range
//              0x0000-0x7FFF.  When the HighPart !=0, the values are
//              mapped to 0x8000 - 0xFFFF.
//
//  Arguments:  [uliValue] - The value to be mapped.
//
//  History:    02-09-96   Alanw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned NormULargeInteger( ULARGE_INTEGER & uliValue )
{
    unsigned normVal;

    if ( 0 == uliValue.HighPart )
    {
        normVal = NormULong( uliValue.LowPart );
        normVal >>= 1;
    }
    else
    {
        normVal = NormULong( uliValue.HighPart );  // 0x0000-0x7FFF
        normVal |= 0x8000;
    }

    Win4Assert( normVal < 0x10000 );

    return normVal;
}


//+---------------------------------------------------------------------------
//
//  Function:   NormLargeInteger
//
//  Synopsis:   Normalizes a large integer to a value between 0x0000-0xFFFF.
//
//              -ve Numbers are mapped in the range 0x0000-0x8000.
//              +ve numbers are mapped in the range 0x8000-0xFFFF.
//
//  Arguments:  [liValue] -  The value to be normalized. Note that the
//              argument is NOT passed by reference. The value is changed
//              in this method and so should not be passed by reference.
//
//  History:    10-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

static unsigned NormLargeInteger( LARGE_INTEGER liValue )
{
    unsigned normVal;

    if ( liValue.QuadPart < 0 )
    {
        liValue.QuadPart = -liValue.QuadPart;
        normVal = MINSHORT - MapLargeInteger( liValue );
    }
    else
    {
        normVal = MINSHORT + MapLargeInteger( liValue );
    }

    Win4Assert( normVal < 0x10000 );

    return normVal;
}

#ifdef  TEST_NORM
//
// a test to verify the validity of the NormLong function.
//
void TestNormLong()
{
    long lVal1 = 0;
    unsigned nVal1 = NormLong( lVal1 );

    printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", lVal1, nVal1, lVal1, nVal1 );

    lVal1 = 2;
    long lVal2 = 0;
    unsigned nVal2 = NormLong(1);

    while ( !(lVal1 & 0x80000000) )
    {
        nVal1 = NormLong( lVal1 );
        //printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", lVal1, nVal1, lVal1, nVal1 );

        Win4Assert( nVal1 == nVal2+1 );

        lVal2 = lVal1 + lVal1-1;
        nVal2 = NormLong( lVal2 );
        //printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", lVal2, nVal2, lVal2, nVal2 );

        lVal1 <<= 1;
    }

    lVal1 = 2;
    nVal2 = NormLong(-1);
    printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", -1, nVal2, -1, nVal2 );

    while ( !(lVal1 & 0x80000000) )
    {
        nVal1 = NormLong( -lVal1 );
        //printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", -lVal1, nVal1, -lVal1, nVal1 );

        Win4Assert( nVal1 == nVal2-1 );

        lVal2 = lVal1 + lVal1-1;
        lVal2 = -lVal2;

        nVal2 = NormLong( lVal2 );
        //printf(" Value:Bin 0x%8X : 0x%4X  \t(%10d : %10d)\n", lVal2, nVal2, lVal2, nVal2 );

        lVal1 <<= 1;
    }
}
#endif  // 0

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::CNormalizer
//
//  Synopsis:   constructor for normalizer
//
//  Effects:    gets buffers from noiselist
//
//  Arguments:  [nl] -- Noise list object to pass data on to.
//
//  History:    05-June-91   t-WadeR     Created.
//
//  Notes:
//
//----------------------------------------------------------------------------
CNormalizer::CNormalizer( PNoiseList& nl )
    : _noiseList(nl)
{
    SetWordBuffer();

    // check that input size + prefix fits in the output buffer
    Win4Assert( cwcMaxKey * sizeof( WCHAR ) + cbKeyPrefix <= *_pcbOutBuf );
}



//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::GetFlags
//
//  Synopsis:   Returns address of ranking and range flags
//
//  Arguments:  [ppRange] -- range flag
//              [ppRank] -- rank flag
//
//  History:    11-Fab-92   BartoszM     Created.
//
//----------------------------------------------------------------------------
void CNormalizer::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    _noiseList.GetFlags ( ppRange, ppRank );
}



//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::ProcessAltWord, public
//
//  Synopsis:   Normalizes a UniCode string, passes it to NoiseList.
//
//  Effects:    Deposits a normalized version [pwcInBuf] in [_pbOutBuf]
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of chars in pwcInBuf
//
//  History:    03-May-95     SitaramR     Created.
//
//----------------------------------------------------------------------------

void CNormalizer::ProcessAltWord( WCHAR const *pwcInBuf,  ULONG cwc )
{
    SetNextAltBuffer();

    unsigned hash = NormalizeWord( pwcInBuf, cwc );
    SetAltHash( hash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::ProcessWord, public
//
//  Synopsis:   Normalizes a UniCode string, passes it to NoiseList.
//
//  Effects:    Deposits a normalized version of [pwcInBuf] in [_pbOutBuf].
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of chars in pwcInBuf
//
//  History:    05-June-91  t-WadeR     Created.
//              13-Oct-92   AmyA        Added unicode support
//
//----------------------------------------------------------------------------

void CNormalizer::ProcessWord( WCHAR const *pwcInBuf,  ULONG cwc )
{
    if ( UsingAltBuffers() )
        SetNextAltBuffer();

    unsigned hash = NormalizeWord( pwcInBuf, cwc );

    if ( UsingAltBuffers() )
    {
        SetAltHash( hash );
        ProcessAllWords();
    }
    else
        _noiseList.PutWord( hash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::ProcessAllWords, private
//
//  Synopsis:   Removes duplicate alternate words and emits remainder.
//
//  History:    17-Sep-1999    KyleP     Created.
//
//----------------------------------------------------------------------------

void CNormalizer::ProcessAllWords()
{
    //
    // Check for duplicate keys.  Since the number of alternate forms will always be
    // quite small it's ok to use a O(n^2) algorithm here.
    //

    unsigned iFinal = 0;

    for ( unsigned i = 0; i < _cAltKey; i++ )
    {
        //
        // Already marked duplicate?
        //

        if ( 0 == _aAltKey[i].Count() )
            continue;

        iFinal = i;

        for ( unsigned j = i+1; j < _cAltKey; j++ )
        {
            //
            // Remember, Pid is really the hash here.
            //

            if ( _aAltKey[i].Pid() == _aAltKey[j].Pid() &&
                 _aAltKey[i].Count() == _aAltKey[j].Count() &&
                 RtlEqualMemory( _aAltKey[i].GetBuf(), _aAltKey[j].GetBuf(), _aAltKey[j].Count() ) )
            {
                ciDebugOut(( DEB_TRACE, "Duplicate keys: %u and %u\n", i, j ));
                _aAltKey[j].SetCount( 0 );
            }
        }
    }

    //
    // Now transfer any remaining key(s).
    //

    SetWordBuffer();
    unsigned hash;

    for ( i = 0; i <= iFinal; i++ )
    {
        //
        // Ignore duplicates
        //

        if ( 0 == _aAltKey[i].Count() )
            continue;

        //
        // Copy to the transfer buffer.
        //

        *_pcbOutBuf = _aAltKey[i].Count();
        RtlCopyMemory( _pbOutBuf, _aAltKey[i].GetBuf(), *_pcbOutBuf );
        hash = _aAltKey[i].Pid();

        //
        // If this is not the final "PutWord" call, send the data along.
        //

        if ( i != iFinal )
            _noiseList.PutAltWord( hash );
    }

    //
    // Put the final word
    //

    _noiseList.PutWord( hash );
} //ProcessAllWords

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::NormalizeWord
//
//  Synopsis:   Normalizes a UniCode string
//              Calculates the hash function for normalized string.
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of chars in pwcInBuf
//
//  Returns:    unsigned hash value of string
//
//  History:    03-May-95    SitaramR     Created.
//
//----------------------------------------------------------------------------

unsigned CNormalizer::NormalizeWord( WCHAR const *pwcInBuf, ULONG cwc )
{
    return NormalizeWord( pwcInBuf, cwc, _pbOutBuf, _pcbOutBuf );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::NormalizeWord
//
//  Synopsis:   Normalizes a UniCode string
//              Calculates the hash function for normalized string. This 
//              function is identical to the other NormalizeWord funtion,
//              except that it puts the outputs int he output parameters
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of chars in pwcInBuf
//              [pbOutBuf] -- output buffer.
//              [pcbOutBuf] - pointer to output count of bytes.
//
//  Returns:    unsigned hash value of string
//
//  History:    03-May-1995    SitaramR     Created.
//              03-Oct-2000    KitmanH      Added output parameters              
//
//----------------------------------------------------------------------------

unsigned CNormalizer::NormalizeWord( WCHAR const *pwcInBuf, 
                                     ULONG cwc, 
                                     BYTE *pbOutBuf, 
                                     unsigned *pcbOutBuf )
{
    // count of bytes needs to take into account STRING_KEY

    *pcbOutBuf = cwc * sizeof(WCHAR) + cbKeyPrefix;

    // prefix with the string key identifier

    *pbOutBuf++ = STRING_KEY;

    unsigned hash = 0;

    Win4Assert ( cwc != 0 && cwc <= cwcMaxKey );
    for ( unsigned i = 0; i < cwc; i++ )
    {
        WCHAR c = *pwcInBuf++;

        // normalize the character to upcase.

        c = ( c < 'a' ) ? c : ( c <= 'z' ) ? ( c - ('a' - 'A') ) :
            RtlUpcaseUnicodeChar( c );

        //
        // Store.  Do it one byte at a time because the normalized string
        // must be byte compared.
        //

        *pbOutBuf++ = (BYTE)(c >> 8);
        *pbOutBuf++ = (BYTE)c;

        // hash
        hash = ( hash << 2 ) + c;
    }

    return hash;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNormalizer::NormalizeWstr - Public
//
//  Synopsis:   Normalizes a UniCode string
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwcInBuf] -- count of chars in pwcInBuf
//              [pbOutBuf] -- output buffer.
//              [pcbOutBuf] - pointer to output count of bytes.
//
//  History:    10-Feb-2000     KitmanH    Created
//
//----------------------------------------------------------------------------

void CNormalizer::NormalizeWStr( WCHAR const *pwcInBuf, 
                                 ULONG cwcInBuf,
                                 BYTE *pbOutBuf, 
                                 unsigned *pcbOutBuf )
{
    NormalizeWord( pwcInBuf, 
                   cwcInBuf,
                   pbOutBuf, 
                   pcbOutBuf );
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::CValueNormalizer
//
//  Synopsis:   Constructor
//
//  Arguments:  [krep] -- key repository sink for keys
//
//  History:    21-Sep-92   BartoszM     Created.
//
//----------------------------------------------------------------------------

CValueNormalizer::CValueNormalizer( PKeyRepository& krep )
  : _krep(krep)
{
    _krep.GetBuffers( &_pcbOutBuf, &_pbOutBuf, &_pOcc );
    _cbMaxOutBuf = *_pcbOutBuf;
    *_pOcc = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue, public
//
//  Synopsis:   Store a variant
//
//  Arguments:  [pid] -- property id
//              [occ] -- On input:  starting occurrence.
//                       On output: next starting occurrence.
//              [var] -- value
//
//  History:    04-Nov-94   KyleP        Created.
//
//----------------------------------------------------------------------------

void CValueNormalizer::PutValue( PROPID pid,
                                 OCCURRENCE & occ,
                                 CStorageVariant const & var )
{
    *_pOcc = occ;

    switch ( var.Type() )
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_UI1:
        PutValue( pid, var.GetUI1() );
        break;

    case VT_I1:
        PutValue( pid, var.GetI1() );
        break;

    case VT_UI2:
        PutValue( pid, (USHORT) var.GetUI2() );
        break;

    case VT_I2:
        PutValue( pid, var.GetI2() );
        break;

    case VT_I4:
    case VT_INT:
        PutValue( pid, var.GetI4() );
        break;

    case VT_R4:
        PutValue( pid, var.GetR4() );
        break;

    case VT_R8:
        PutValue( pid, var.GetR8() );
        break;

    case VT_UI4:
    case VT_UINT:
        PutValue( pid, var.GetUI4() );
        break;

    case VT_I8:
        PutValue( pid, var.GetI8() );
        break;

    case VT_UI8:
        PutValue( pid, var.GetUI8() );
        break;

    case VT_BOOL:
        PutValue( pid, (BYTE) (FALSE != var.GetBOOL()) );
        break;

    case VT_ERROR:
        PutValue( pid, var.GetERROR() );
        break;

    case VT_CY:
        PutValue( pid, var.GetCY() );
        break;

    case VT_DATE:
        PutDate( pid, var.GetDATE() );
        break;

    case VT_FILETIME:
        PutValue( pid, var.GetFILETIME() );
        break;

    case VT_CLSID:
        PutValue( pid, *var.GetCLSID() );
        break;

    // NTRAID#DB-NTBUG9-84589-2000/07/31-dlee Indexing Service data type normalization doesn't handle VT_DECIMAL, VT_VECTOR, or VT_ARRAY.

    default:
        ciDebugOut(( DEB_IWARN, "Unhandled type %d (%x) sent to normalization\n",
                     var.Type(), var.Type() ));
        break;
    }

    occ = *_pOcc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  private
//
//  Synopsis:   Store a unsigned 2 byte value without altering it
//
//  Arguments:  [pid]    -- property id
//              [uValue] -- value
//              [bType]  -- value type
//
//  History:    07-Oct-93   DwightKr     Created.
//
//  Notes:      This is the principal PutValue method that other PutValue()s
//              will call.  Each of the OTHER PutValue()'s sole purpose is
//              to normalize their input data into a 2-byte unsigned value.
//              This version of PutValue() will store the value together
//              with its WID, PID, size, etc. in the CDataRepository object.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, unsigned uValue, BYTE bType )
{
    BYTE* pb = _pbOutBuf;

    // Store size of entry
    *_pcbOutBuf = sizeof(USHORT) + sizeof(PROPID) + 1;

    // Store key type
    *pb++ = bType;

    // store property id
    *pb++ = (BYTE)(pid >> 24);
    *pb++ = (BYTE)(pid >> 16);
    *pb++ = (BYTE)(pid >> 8);
    *pb++ = (BYTE) pid;

    // Store key
    Win4Assert( uValue < 0x10000 );
    *pb++ = BYTE (uValue >> 8);
    *pb++ = BYTE (uValue);

#if CIDBG == 1
    for (unsigned i =  0; i < *_pcbOutBuf; i++ )
    {
        ciDebugOut (( DEB_USER1 | DEB_NOCOMPNAME, "%02x ", _pbOutBuf[i] ));
    }
    ciDebugOut (( DEB_USER1 | DEB_NOCOMPNAME, "\n" ));
#endif

    _krep.PutPropId(pid);
    _krep.PutKey();
    (*_pOcc)++;
}

void CValueNormalizer::PutMinValue( PROPID pid, OCCURRENCE & occ, VARENUM Type )
{
    *_pOcc = occ;
    PutValue( pid, 0, Type );
    occ = *_pOcc;
}

void CValueNormalizer::PutMaxValue( PROPID pid, OCCURRENCE & occ, VARENUM Type )
{
    *_pOcc = occ;
    PutValue( pid, 0xFFFF, Type );
    occ = *_pOcc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  public
//
//  Synopsis:   Store a 1 byte value without altering it
//
//  Arguments:  [pid]  -- property id
//              [byte] -- value
//
//  History:    25-Oct-93   DwightKr     Created.
//
//  Notes:      One byte values are NOT normalized, they are stored as is.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, BYTE byte )
{
    PutValue(pid, (unsigned) byte, VT_UI1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  public
//
//  Synopsis:   Store a 1 byte signed value without altering it
//
//  Arguments:  [pid]  -- property id
//              [ch]   -- value
//
//  History:    25-Oct-1993   DwightKr     Created.
//              29-Sep-2000   KitmanH      Normalize VT_I1 values
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, CHAR ch )
{
    PutValue(pid, ( ((BYTE) ch) + 0x80 ) & 0xFF, VT_I1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the high byte of an unsigned 2 byte value
//
//  Arguments:  [pid]     -- property id
//              [usValue] -- value
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, USHORT usValue )
{
    PutValue(pid, (usValue >> 8) & 0xFF, VT_UI2);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  public
//
//  Synopsis:   Store the high byte of a signed 2 byte value.
//
//  Arguments:  [pid]     -- property id
//              [sValue]  -- value
//
//  Notes:      Add the smallest BYTE to this so that we translate numbers
//              into the range above 0.  i.e. -32768 maps into 0x00, and 32767
//              maps into 0xFF.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, SHORT sValue )
{
    PutValue(pid, ((sValue >> 8) + 0x80) & 0xFF, VT_I2);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue  public
//
//  Synopsis:   Store the base-2 log of the ULONG value.
//
//  Arguments:  [pid]     -- property id
//              [ulValue] -- value
//
//  Notes:      This convert ULONGs into the range 0 - 31 by taking the Log2
//              of the number.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, ULONG  ulValue )
{
    PutValue(pid, NormULong ( ulValue ), VT_UI4);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the base-2 log of the signed LONG value.
//
//  Arguments:  [pid]     -- property id
//              [lValue]  -- value
//
//  Notes:      This converts LONGs into numbers larger than 0.  This
//              translates into 64 bins; 32 bins for #'s < 0 & 32 bins for
//              #'s >= 0.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, LONG lValue )
{
     PutValue(pid, NormLong(lValue), VT_I4);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the base-10 log of the FLOAT value.
//
//  Arguments:  [pid]     -- property id
//              [rValue]  -- value
//
//  Notes:      floats fit into a total of 41 bins.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, float rValue )
{
    PutValue(pid, NormDouble(rValue), VT_R4);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the base-10 log of the DOUBLE value.
//
//  Arguments:  [pid]     -- property id
//              [dValue]  -- value
//
//  Notes:      doubles fit into a total of 41 bins.
//
//  History:    07-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, double dValue )
{
    PutValue(pid, NormDouble(dValue), VT_R8);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the exponent of a large integer
//
//  Arguments:  [pid] -- property id
//              [li]  -- value
//
//  History:    21-Sep-92   BartoszM    Created.
//              04-Feb-93   KyleP       Use LARGE_INTEGER
//              25-Oct-92   DwightKr    Copied here & removed extra code &
//                                      accounted for negative numbers
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, LARGE_INTEGER liValue )
{
    unsigned uExponent = NormLargeInteger(liValue);

    PutValue( pid, uExponent, VT_I8);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store a compressed large integer
//
//  Arguments:  [pid] -- property id
//              [uli] -- value
//
//  History:    09 Feb 96   AlanW      Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, ULARGE_INTEGER uliValue )
{
    unsigned uExponent = NormULargeInteger(uliValue);

    PutValue( pid, uExponent, VT_UI8);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the least byte of a GUID
//
//  Arguments:  [pid]   -- property id
//              [guid]  -- value
//
//  Notes:      The GUID generators are guaranteed to modify the TOP DWORD
//              of the 32-byte GUID each time a new GUID is generated.
//              The lower bytes of the GUID is the network address of the
//              card which generated the UUID.
//
//              We would like to cluster together together objects of a single
//              class (all MS-Word objects together for example).  Since it
//              is possible that someone could generate UUIDs for more than
//              one application on a single machine, the lower portion of
//              the UUID will perhaps remain constant between class IDs.  The
//              only part of the UUID which is guaranteed to be unique between
//              multiple objects is the field which represents time.  It is
//              unlikely that two classes were generated the same second on
//              two different machines.
//
//  History:    25-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------
void CValueNormalizer::PutValue( PROPID pid, GUID const & Guid )
{
    PutValue(pid, Guid.Data1 & 0xFFFF, VT_CLSID);
}

long CastToLong( double d )
{
    //
    // bit 63       = sign
    // bits 52 - 62 = exponent
    // bits 0 - 51  = mantissa
    //

    LARGE_INTEGER * pli = (LARGE_INTEGER *)&d;

    int exp  = (pli->HighPart & 0x7ff00000) >> 20;

    if ( exp == 0 )
    {
        //
        // Special case: Zero, NaNs, etc.
        //

        return( 0 );
    }

    //
    // Subtract off bias
    //

    exp -= 0x3ff;

    if ( exp < 0 )
    {
        // Cast of very small number to unsigned long.  Loss of precision
        return( 0 );
    }
    else if ( exp > 30 )
    {
        // Cast of very large number to unsigned long.  Overflow
        if ( pli->HighPart & 0x80000000 )
            return( LONG_MIN );
        else
            return( LONG_MAX );
    }
    else
    {
        //
        // We need to get the top 32 bits of the mantissa
        // into a dword.
        //

        unsigned long temp = pli->LowPart >> (32 - 12);
        temp |= pli->HighPart << (32 - 20);

        //
        // Add the 'hidden' bit of the mantissa. (Since all doubles
        // are normalized to 1.?????? the highest 1 bit isn't stored)
        //

        temp = temp >> 1;
        temp |= 0x80000000;

        //
        // Thow away digits to the right of decimal
        //

        temp = temp >> (31 - exp);

        //
        // Adjust for sign
        //

        Win4Assert( (temp & 0x80000000) == 0 );
        long temp2;

        if ( pli->HighPart & 0x80000000 )
            temp2 = temp * -1;
        else
            temp2 = temp;

        return( temp2 );
    }
} //CastToLong

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutDate
//
//  Synopsis:   Dates are passed in as the number of days (and fractional days)
//              since Jan. 1, 1900.  We'll crunch this down to the number of
//              weeks.  Dates are passed in a doubles.  We'll assume that
//              negative numbers represent dates before Jan. 1, 1900.
//
//  Arguments:  [pid]     -- property id
//              [DATE]    -- value (double)
//
//  Notes:      Since dates before Jan 1, 1900 are passed as negative numbers
//              we'll need to normalize them to something >= 0.
//
//              time period                    resolution            # bins
//              ===========================    ===============       ======
//              year < 10Bil BC                -- bin = 0               1
//              10Bil BC <= year <=    1 BC    -- log10 (year)         11
//                 1 BC  <  year <= 1900       -- year               1902
//              1901 AD  <= year <= 2050 AD    -- daily             54787
//              2051 AD  <= year <= 10Bil AD   -- log10 (year)          8
//              year > 10Bil AD                -- bin = 0xFFFF          1
//
//
//              I choose the daily range from 1901 - 2050 since there is a lot
//              of events in the 20th century (WW I, WW II, landing on the
//              moon, my wife's birthday, etc.) that are interesting, and
//              imporant.  It is likely that dates outside of this range will
//              be rounded to the nearest year (1492, 1776, 1812, 1867, etc).
//
//              Also by breaking the log10(year) at 1 BC rather than some other
//              date (such as 0000 AD, or 1 AD) we avoid values in the range
//              1 BC < year < 1 AD, calculating log10(year) resulting in
//              large negative numbers.  Everything in this range should be in
//              bin #12.  It also avoids taking log10(0).
//
//
//  History:    25-Oct-93   DwightKr     Created.
//              07-Dec-94   KyleP        Remove use of floating point
//
//----------------------------------------------------------------------------

void CValueNormalizer::PutDate( PROPID pid, DATE const & Date )
{
    const int MinDate = 42;     // 2^42 --> ~4.4E12 days --> ~12E9 years  --> 12 billion B.C.
    const int MinByYear = 20;   // 2^20 --> ~1.0E6  days --> ~2.9E3 years --> 970 B.C.
    const int cMinByYear = (1 << MinByYear) / 365 + 1;   // 2873
    const int MaxDaily = (2051 - 1900) * 365;            // 55115
    const int MinByYearAD = 15; // 2^15 --> ~32768 days  --> ...
    const int MaxDate = 42;     // 2^42 --> ~4.4E12 days --> ~12E9 years  --> 12 billion A.D.

    const unsigned FirstBC            = 0;
    const unsigned FirstLogBC         = FirstBC + 1;
    const unsigned LastLogBC          = FirstLogBC + MinDate - MinByYear;
    const unsigned FirstYearBC        = LastLogBC + 1;
    const unsigned LastYearBC         = FirstYearBC + cMinByYear;
    const unsigned FirstDaily         = LastYearBC + 1;
    const unsigned LastDaily          = FirstDaily + MaxDaily;
    const unsigned FirstLogAD         = LastDaily + 1;
    const unsigned LastLogAD          = FirstLogAD + MaxDate - MinByYearAD;
    const unsigned LastAD             = 0xFFFF;

    Win4Assert( LastLogAD < 0xFFFF );

    unsigned bin;
    BOOL fPositive;

    int exp = GetExpAndSign( Date, fPositive );

    if ( !fPositive )
    {
        //
        // Very large negative dates go in first bin
        //

        if ( exp >= MinDate )
            bin = FirstBC;

        //
        // Medium size negative dates get 1 bin / power of 2
        //

        else if ( exp >= MinByYear )
            bin = FirstLogBC - exp + MinByYear;

        //
        // All other dates before 1900 get 1 bucket per 365 days.
        //

        else
        {
            long cYears = CastToLong( Date ) / 365;

            Win4Assert( cYears >= -cMinByYear && cYears <= 0 );

            bin = FirstYearBC + cYears + cMinByYear;
        }
    }
    else
    {
        //
        // Very large positive dates go in last bin
        //

        if ( exp >= MaxDate )
            bin = LastAD;
        else
        {
            long cDays = CastToLong( Date );

            //
            // Dates rather far in the future get 1 bucket / power of 2
            //

            if ( cDays >= MaxDaily )
                bin = FirstLogAD + exp - MinByYearAD;

            //
            // Days close to today get 1 bucket per day
            //

            else
                bin = FirstDaily + cDays;
        }
    }

    PutValue(pid, bin, VT_DATE);
} //PutDate

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the hashed value of an 8-byte currency.
//
//  Arguments:  [pid]     -- property id
//              [cyValue]  -- value
//
//  Notes:      Currency values are stored as a ULONG cents, and a LONG $.
//              We'll ignore the cents portion and store the $ part using
//              the standard LONG storage method.
//
//  History:    26-Oct-93   DwightKr     Created.
//
//----------------------------------------------------------------------------

void CValueNormalizer::PutValue( PROPID pid, CURRENCY const & cyValue)
{
    PutValue(pid, NormLong(cyValue.Hi), VT_CY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CValueNormalizer::PutValue
//
//  Synopsis:   Store the number of days since Jan 1, 1980;
//
//  Arguments:  [pid]     -- property id
//              [ulValue] -- value
//
//  History:    07-Oct-93   DwightKr     Created.
//
//  Notes:      This algorithym calculates the number of days since Jan 1,
//              1980; and stores it into a unsigned.  FileTimes are divided
//              into the following ranges:
//
//              FileTime < 1980                              => bin  0
//              1980 <= FileTime <= 1993    week granularity => bins 1 - 729
//              1994 <= FileTime <= 2160    day granularity  => bins 730+
//              FileTime > 2160                              => bin 0xFFFF
//
//----------------------------------------------------------------------------

void CValueNormalizer::PutValue( PROPID pid, FILETIME const & ftValue )
{
    //
    //  Determine the number of days since Jan 1, 1601 by dividing by
    //  the number of 100 nanosecond intervals in a day.  The result
    //  will fit into a ULONG.
    //
    //  Then map the result into one of the ranges: before 1980, between
    //  1980 and 1994, between 1994 and 2160, and after 2160.  To make
    //  the computation easier, we use precomputed values of the number
    //  of days from 1601 and the breakpoints of our range.
    //

    // 100s of nanosecs per day
    const ULONGLONG uliTicsPerDay = 24 * 60 * 60 * (ULONGLONG)10000000;

    const ULONG ulStart = 138426;       // number of days from 1601 to 1980
    const ULONG ulMiddle= 143542;       // number of days from 1601 to 1/2/1994
    const ULONG ulEnd   = 204535;       // number of days from 1601 to 2161

    ULARGE_INTEGER liValue = {ftValue.dwLowDateTime, ftValue.dwHighDateTime};

    ULONG ulDays = (ULONG) (liValue.QuadPart / uliTicsPerDay);

    //
    //  We now have the number of days since Jan. 01, 1601 in ulDays.
    //  Map into buckets.
    //

    if (ulDays < ulStart)                  // Store in bin 0
    {
        PutValue(pid, 0, VT_FILETIME);
    }
    else if (ulDays <= ulMiddle)           // Store week granularity
    {
        PutValue(pid, (ulDays + 1 - ulStart) / 7, VT_FILETIME);
    }
    else if (ulDays <= ulEnd)             // Store day granularity
    {
        //
        // Bins 0 - 730 are used by the two clauses above.  It doesn't
        // really matter if we reuse bin 730 for the start of the next
        // range (this might happen because of the division we do).
        //

        PutValue(pid, (ulDays + 1 - ulMiddle) + ((ulMiddle - ulStart) / 7),
                 VT_FILETIME);
    }
    else                                            // FileTime > 2160
    {
        PutValue(pid, 0xFFFF, VT_FILETIME);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\pickle.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       Pickle.cxx
//
//  Contents:   Pickling/Unpickling routines for restrictions.
//
//  History:    22-Dec-92 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <coldesc.hxx>
#include <pidmap.hxx>
#include <rstprop.hxx>
#include <sizeser.hxx>
#include <memser.hxx>
#include <memdeser.hxx>
#include <pickle.hxx>

//+-------------------------------------------------------------------------
//
//  Function:   DoPickle
//
//  Synopsis:   Pickles a query into a stream
//
//  Arguments:  [sver]    -- version of the server we are targeting
//              [ss]      -- Stream into which query is pickled
//              [cb]      -- Size of pickled query
//              [pcol]    -- Columns in table
//              [prst]    -- Restriction
//              [pso]     -- Sort order
//              [pcateg]  -- Categorization specification
//              [ulFlags] -- Flags
//              [pidmap]  -- Pid Mapper
//
//  History:    18-Apr-95 dlee  From duplicate code in Pickle & PickledSize
//
//--------------------------------------------------------------------------

void DoPickle( int sver,
               PSerStream &ss,
               ULONG cb,
               CColumnSet const * pcol,
               CRestriction const * prst,
               CSortSet const * pso,
               CCategorizationSet const *pcateg,
               CRowsetProperties const *pProps,
               CPidMapper const * pidmap )
{
    // must be 8-byte aligned

    ss.PutULong( cb );         // Size

    if ( 0 == pcol )
        ss.PutByte( PickleColNone );
    else
    {
        ss.PutByte( PickleColSet );
        pcol->Marshall( ss );
    }

    if ( 0 == prst )
        ss.PutByte( FALSE );
    else
    {
        if ( !prst->IsValid() )
        {
            vqDebugOut(( DEB_ERROR, "Marshalling invalid restriction!\n" ));
            THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
        }

        ss.PutByte( TRUE );
        prst->Marshall( ss );
    }

    if ( 0 == pso )
        ss.PutByte( FALSE );
    else
    {
        ss.PutByte( TRUE );
        pso->Marshall( ss );
    }

    if ( 0 == pcateg )
        ss.PutByte( FALSE );
    else
    {
        ss.PutByte( TRUE );
        pcateg->Marshall( ss );
    }

    pProps->Marshall(ss);

    Win4Assert( 0 != pidmap );
    pidmap->Marshall( ss );
} //DoPickle

//+-------------------------------------------------------------------------
//
//  Function:   PickledSize, public
//
//  Synopsis:   Computes size of buffer required to pickle query.
//
//  Arguments:  [sver]    -- version of the server we are targeting
//              [pcol]    -- Columns in table
//              [prst]    -- Restriction
//              [pso]     -- Sort order
//              [pcateg]  -- Categorization specification
//              [ulFlags] -- Flags
//              [pidmap]  -- Pid Mapper
//
//  Returns:    Size (in bytes) of buffer needed to serialize query.
//
//  History:    22-Dec-92 KyleP     Added header
//
//--------------------------------------------------------------------------

ULONG PickledSize( int sver,
                   CColumnSet const * pcol,
                   CRestriction const * prst,
                   CSortSet const * pso,
                   CCategorizationSet const *pcateg,
                   CRowsetProperties const *pProps,
                   CPidMapper const * pidmap )
{
    CSizeSerStream ss;

    DoPickle( sver, ss, 0, pcol, prst, pso, pcateg, pProps, pidmap );

    vqDebugOut(( DEB_ITRACE, "Marshalled size = %d bytes\n", ss.Size() ));

    return ss.Size();
} //PickledSize

//+-------------------------------------------------------------------------
//
//  Function:   Pickle, public
//
//  Synopsis:   Pickles query
//
//  Arguments:  [sver]    -- version of the server we are targeting
//              [pcol]    -- Columns in table
//              [prst]    -- Restriction
//              [pso]     -- Sort order
//              [pcateg]  -- Categorization specification
//              [ulFlags] -- Flags
//              [pidmap]  -- Pid Mapper
//              [pb]      -- Buffer to serialize query into
//              [cb]      -- Size (in bytes) of pb.
//
//  History:    22-Dec-92 KyleP     Added header
//
//--------------------------------------------------------------------------

void Pickle( int sver,
             CColumnSet const * pcol,
             CRestriction const * prst,
             CSortSet const * pso,
             CCategorizationSet const *pcateg,
             CRowsetProperties const *pProps,
             CPidMapper const * pidmap,
             BYTE * pb,
             ULONG cb )
{
    CMemSerStream ss( pb, cb );

    DoPickle( sver, ss, cb, pcol, prst,  pso, pcateg, pProps, pidmap );
} //Pickle

//+-------------------------------------------------------------------------
//
//  Function:   UnPickle, public
//
//  Synopsis:   Deserializes pickled query into buffer.
//
//  Arguments:  [cver]     -- version of the client that pickled the query
//              [col]      -- Columns in table here on exit
//              [rst]      -- Restriction here on exit
//              [sort]     -- Sort order here on exit
//              [categ]    -- Categorization specification here on exit
//              [RstProp]  -- Rowset properties initialized here on exit
//              [pidmap]   -- Pidmap here on exit
//              [pbInput]  -- Buffer containing pickled query
//              [cbInput]  -- Size (in bytes) of pbInput.
//
//  History:    22-Dec-92 KyleP     Added header
//
//--------------------------------------------------------------------------

void UnPickle( int cver,
               XColumnSet & col,
               XRestriction & rst,
               XSortSet & sort,
               XCategorizationSet & categ,
               CRowsetProperties & RstProps,
               XPidMapper & pidmap,
               BYTE * pbInput,
               ULONG cbInput )
{
    CMemDeSerStream ss( pbInput, cbInput );

    ULONG cbPickleBuf = 0;

    cbPickleBuf = ss.GetULong();    // length of buffer

    if (cbPickleBuf > cbInput)
    {
        vqDebugOut(( DEB_ERROR, "cbPickleBuf %d, cbInput %d\n",
                     cbPickleBuf, cbInput ));
        Win4Assert(cbPickleBuf <= cbInput);
        THROW(CException(STATUS_INVALID_PARAMETER_MIX));
    }

    BYTE bColType = ss.GetByte();
    switch (bColType)
    {
    case PickleColSet:
        col.Set( new CColumnSet(ss) );
        break;

    default:
        Win4Assert(bColType <= PickleColSet);

    case PickleColNone:
        break;
    }

    BOOL fNonZero = ss.GetByte();
    if ( fNonZero )
    {
        rst.Set( CRestriction::UnMarshall(ss) );

        // would have thrown on out of memory, so rst must be valid

        Win4Assert( !rst.IsNull() );
        Win4Assert( rst->IsValid() );
    }

    fNonZero = ss.GetByte();
    if ( fNonZero )
        sort.Set( new CSortSet(ss) );

    fNonZero = ss.GetByte();
    if ( fNonZero )
        categ.Set( new CCategorizationSet(ss) );

    RstProps.Unmarshall(ss);

    pidmap.Set( new CPidMapper(ss) );
} //UnPickle

void CRowsetProperties::Marshall( PSerStream & ss ) const
{
    ss.PutULong( _uBooleanOptions );
    ss.PutULong( _ulMaxOpenRows );
    ss.PutULong( _ulMemoryUsage );
    ss.PutULong( _cMaxResults );
    ss.PutULong( _cCmdTimeout );
} //Marshall

void CRowsetProperties::Unmarshall( PDeSerStream & ss )
{
    _uBooleanOptions = ss.GetULong();
    _ulMaxOpenRows = ss.GetULong();
    _ulMemoryUsage = ss.GetULong();
    _cMaxResults = ss.GetULong();
    _cCmdTimeout = ss.GetULong();
} //Unmarshall
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\pidcvt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       PidCvt.cxx
//
//  Contents:   CPidConverter -- Convert FULLPROPSPEC to PROPID
//
//  History:    29-Dec-97 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidcvt.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CPidConverter::FPSToPROPID, public
//
//  Synopsis:   Converts FULLPROPSPEC to PROPID
//
//  Arguments:  [fps] -- FULLPROPSPEC property specification
//              [pid] -- PROPID written here on successful execution
//
//  Returns:    Status code (from framework client)
//
//  History:    29-Dec-1997    KyleP     Created
//
//--------------------------------------------------------------------------

SCODE CPidConverter::FPSToPROPID( CFullPropSpec const & fps, PROPID & pid )
{
    return _xPropMapper->PropertyToPropid( fps.CastToStruct(), // FULLPROPSPEC
                                           TRUE,               // create
                                           &pid );             // Pid returned here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\pidmap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002.
//
//  File:       pidmap.cxx
//
//  Contents:   Maps pid <--> property name.
//
//  History:    31-Jan-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidmap.hxx>
#include <coldesc.hxx>

IMPL_DYNARRAY( CPropNameArrayBase, CFullPropSpec );

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
CPropNameArray::CPropNameArray(unsigned size)
        : CPropNameArrayBase( size )
{
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
void CPropNameArray::Marshall( PSerStream & stm ) const
{
    //
    // Compute # non-zero items
    //

    for ( unsigned len = 0; len < Size(); len++ )
    {
        if ( 0 == Get(len) )
            break;
    }

    stm.PutULong( len );

    for ( unsigned i = 0; i < len; i++ )
    {
        Get(i)->Marshall( stm );
    }
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
CPropNameArray::CPropNameArray( PDeSerStream & stm )
        : CPropNameArrayBase( 0 )
{
    ULONG cItems = stm.GetULong();

    // Guard against attack

    if ( 0 == cItems || cItems > 1000 )
        THROW( CException( E_INVALIDARG ) );

    SetExactSize( cItems );

    for ( unsigned i = 0; i < cItems; i++ )
    {
        CFullPropSpec * pps = new CFullPropSpec( stm );

        XPtr<CFullPropSpec> xpps(pps);

        if ( xpps.IsNull() || !xpps->IsValid() )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        Add( pps, i);
        xpps.Acquire();
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidMapper::NameToPid, public
//
//  Arguments:  [wcsProperty] -- Property name
//
//  Returns:    'fake' (pid) for [wcsProperty].
//
//  History:    31-Jan-93   KyleP       Created
//
//--------------------------------------------------------------------------

PROPID CPidMapper::NameToPid( CFullPropSpec const & Property )
{
    if ( !Property.IsValid() )
        return pidInvalid;

    //
    // Just linear search the array.  It should be small.
    //

    for ( int i = Count() - 1; i >= 0; i-- )
    {
        Win4Assert( Get(i) != 0 );
        if ( *Get( i ) == Property )
        {
            return( i );
        }
    }

    //
    // Wasn't in array. Add.
    //

    CFullPropSpec * ppsFull = new CFullPropSpec( Property );

    XPtr<CFullPropSpec> xpps(ppsFull);

    if ( xpps.IsNull() || !xpps->IsValid() )
    {
        THROW( CException( STATUS_NO_MEMORY ) );
    }

    PROPID pidNew = Count();

    Add( ppsFull, pidNew );
    xpps.Acquire();

    _apidReal[pidNew] = pidInvalid;

    return pidNew;
}

//+-------------------------------------------------------------------------
//
//  Member:     CPidMapper::PidToRealPid, public
//
//  Synopsis:   Converts a fake (index) pid to real pid.
//
//  Arguments:  [pidFake] -- Fake (index) pid
//
//  Returns:    Real pid
//
//  History:    30-Dec-1997   KyleP       Created
//
//--------------------------------------------------------------------------

PROPID CPidMapper::PidToRealPid( PROPID pidFake )
{
    if ( pidInvalid == _apidReal[pidFake] )
    {
         Win4Assert( 0 != _pPidConverter );

         SCODE sc = _pPidConverter->FPSToPROPID( *Get(pidFake), _apidReal[pidFake] );

         if ( FAILED(sc) )
         {
             THROW( CException( sc ) );
         }

         #if CIDBG == 1
         if ( vqInfoLevel & DEB_ITRACE )
         {
             CFullPropSpec const & ps = *Get(pidFake);

             GUID const & guid = ps.GetPropSet();

             char szGuid[50];

             sprintf( szGuid,
                      "%08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\\",
                      guid.Data1,
                      guid.Data2,
                      guid.Data3,
                      guid.Data4[0], guid.Data4[1],
                      guid.Data4[2], guid.Data4[3],
                      guid.Data4[4], guid.Data4[5],
                      guid.Data4[6], guid.Data4[7] );

             vqDebugOut(( DEB_ITRACE, szGuid ));

             if ( ps.IsPropertyName() )
                 vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME,
                              "%ws ",
                              ps.GetPropertyName() ));
             else
                 vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME,
                              "0x%x ",
                              ps.GetPropertyPropid() ));

             vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, " --> pid 0x%x\n",
                          _apidReal[pidFake] ));

         }
         #endif // CIDBG == 1
    }

    return _apidReal[pidFake];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\restrict.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       Restrict.cxx
//
//  Contents:   C++ wrappers for restrictions.
//
//  History:    31-Dec-92 KyleP     Created
//              28-Jul-94 KyleP     Hand marshalling
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidmap.hxx>
#include <coldesc.hxx>
#include <pickle.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CFullPropSpec::CFullPropSpec, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source property spec
//
//  History:    17-Jul-93 KyleP     Created
//
//--------------------------------------------------------------------------

CFullPropSpec::CFullPropSpec( CFullPropSpec const & src )
        : _guidPropSet( src._guidPropSet )
{
    _psProperty.ulKind = src._psProperty.ulKind;

    if ( _psProperty.ulKind == PRSPEC_LPWSTR )
    {
        if ( src._psProperty.lpwstr )
        {
            _psProperty.ulKind = PRSPEC_PROPID;
            SetProperty( src._psProperty.lpwstr );
        }
        else
            _psProperty.lpwstr = 0;
    }
    else
    {
        _psProperty.propid = src._psProperty.propid;
    }
}

void CFullPropSpec::Marshall( PSerStream & stm ) const
{
    stm.PutGUID( _guidPropSet );
    stm.PutULong( _psProperty.ulKind );

    switch( _psProperty.ulKind )
    {
    case PRSPEC_PROPID:
        stm.PutULong( _psProperty.propid );
        break;

    case PRSPEC_LPWSTR:
    {
        ULONG cc = wcslen( _psProperty.lpwstr );
        stm.PutULong( cc );
        stm.PutWChar( _psProperty.lpwstr, cc );
        break;
    }

    default:
        Win4Assert( !"Invalid PROPSPEC" );
        break;
    }
}

CFullPropSpec::CFullPropSpec( PDeSerStream & stm )
{
    stm.GetGUID( _guidPropSet );
    _psProperty.ulKind = stm.GetULong();

    switch( _psProperty.ulKind )
    {
    case PRSPEC_PROPID:
        _psProperty.propid = stm.GetULong();
        break;

    case PRSPEC_LPWSTR:
    {
        _psProperty.lpwstr = UnMarshallWideString( stm );
        break;
    }

    default:
        Win4Assert( !"Invalid PROPSPEC" );

        // Make the fullpropspec look invalid, so the later check fails.

        _psProperty.ulKind = PRSPEC_LPWSTR;
        _psProperty.lpwstr = 0;
        break;
    }
}

void CFullPropSpec::SetProperty( PROPID pidProperty )
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         0 != _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
    }

    _psProperty.ulKind = PRSPEC_PROPID;
    _psProperty.propid = pidProperty;
}

BOOL CFullPropSpec::SetProperty( WCHAR const * wcsProperty )
{
    if ( _psProperty.ulKind == PRSPEC_LPWSTR &&
         0 != _psProperty.lpwstr )
    {
        CoTaskMemFree( _psProperty.lpwstr );
    }

    _psProperty.ulKind = PRSPEC_LPWSTR;

    int len = (wcslen( wcsProperty ) + 1) * sizeof( WCHAR );

    _psProperty.lpwstr = (WCHAR *)CoTaskMemAlloc( len );

    if ( 0 != _psProperty.lpwstr )
    {
        memcpy( _psProperty.lpwstr,
                wcsProperty,
                len );
        return( TRUE );
    }
    else
    {
        _psProperty.lpwstr = 0;
        return( FALSE );
    }
}


//
// Methods for CColumns
//

CColumns::CColumns( unsigned size )
        : _size( size ),
          _cCol( 0 ),
          _aCol( 0 )
{
    Win4Assert( OFFSETS_MATCH( COLUMNSET, cCol, CColumns, _cCol ) );
    Win4Assert( OFFSETS_MATCH( COLUMNSET, aCol, CColumns, _aCol ) );

    //
    // Avoid nasty boundary condition for ::IsValid
    //

    if ( _size == 0 )
        _size = 8;

    _aCol = new CFullPropSpec [ _size ];

    memset( _aCol, PRSPEC_PROPID, _size * sizeof( CFullPropSpec ) );
}

CColumns::CColumns( CColumns const & src )
       : _size( src._cCol ),
         _cCol( 0 )
{
    Win4Assert( OFFSETS_MATCH( COLUMNSET, cCol, CColumns, _cCol ) );
    Win4Assert( OFFSETS_MATCH( COLUMNSET, aCol, CColumns, _aCol ) );

    //
    // Avoid nasty boundary condition for ::IsValid
    //

    if ( _size == 0 )
        _size = 1;

    _aCol = new CFullPropSpec [ _size ];

    if ( 0 == _aCol )
        THROW( CException( E_OUTOFMEMORY ) );

    memset( _aCol, PRSPEC_PROPID, _size * sizeof( CFullPropSpec ) );

    // Add does not throw since the array has been sized already

    while ( _cCol < src._cCol )
    {
        Add( src.Get( _cCol ), _cCol );
        if ( !Get( _cCol-1 ).IsValid() )
        {
            delete [] _aCol;
            _aCol = 0;
            THROW( CException( E_OUTOFMEMORY ) );
        }
    }
}

CColumns::~CColumns()
{
    delete [] _aCol;
}

void CColumns::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _cCol );

    for ( unsigned i = 0; i < _cCol; i++ )
    {
        _aCol[i].Marshall( stm );
    }
}

CColumns::CColumns( PDeSerStream & stm )
{
    _size = stm.GetULong();

    //
    // Avoid nasty boundary condition for ::IsValid
    //

    // Guard against attack

    if ( _size == 0 )
        _size = 1;
    else if ( _size > 1000 )
        THROW( CException( E_INVALIDARG ) );

    XArray< CFullPropSpec > xCol( _size );

    _aCol = xCol.GetPointer();

    for( _cCol = 0; _cCol < _size; _cCol++ )
    {
        CFullPropSpec ps(stm);
        Add( ps, _cCol );
    }

    xCol.Acquire();
}

void CColumns::Add( CFullPropSpec const & Property, unsigned pos )
{
    if ( pos >= _size )
    {
        unsigned cNew = (_size > 0) ? (_size * 2) : 8;
        while ( pos >= cNew )
            cNew = cNew * 2;

        CFullPropSpec * aNew = new CFullPropSpec[cNew];

        if ( _aCol )
        {
            memcpy( aNew, _aCol, _cCol * sizeof( CFullPropSpec ) );
            memset( _aCol, PRSPEC_PROPID, _size * sizeof CFullPropSpec );
            delete [] _aCol;
        }

        memset( aNew + _cCol, PRSPEC_PROPID, (cNew - _cCol) * sizeof( CFullPropSpec ) );

        _aCol = aNew;
        _size = cNew;
    }

    _aCol[pos] = Property;

    if ( pos >= _cCol )
        _cCol = pos + 1;
}

void CColumns::Remove( unsigned pos )
{
    if ( pos < _cCol )
    {
        _aCol[pos].CFullPropSpec::~CFullPropSpec();

        _cCol--;
        RtlMoveMemory( _aCol + pos,
                 _aCol + pos + 1,
                 (_cCol - pos) * sizeof( CFullPropSpec ) );
    }
}

//
// Methods for CSort
//

CSort::CSort( unsigned size )
        : _size( size ),
          _csk( 0 ),
          _ask( 0 )
{
    Win4Assert( OFFSETS_MATCH( SORTSET, cCol, CSort, _csk ) );
    Win4Assert( OFFSETS_MATCH( SORTSET, aCol, CSort, _ask ) );

    if ( _size > 0 )
    {
        _ask = new CSortKey[_size];

        memset( _ask, PRSPEC_PROPID, _size * sizeof( CSortKey ) );
    }
}

CSort::CSort( CSort const & src )
       : _size( src._csk ),
         _csk( 0 ),
         _ask( 0 )
{
    Win4Assert( OFFSETS_MATCH( SORTSET, cCol, CSort, _csk ) );
    Win4Assert( OFFSETS_MATCH( SORTSET, aCol, CSort, _ask ) );

    if ( _size > 0 )
    {
        _ask = new CSortKey[ _size ];

        memset( _ask, PRSPEC_PROPID, _size * sizeof( CSortKey ) );
        while( _csk < src._csk )
        {
            Add( src.Get( _csk ), _csk );
        }
    }
}

void CSortKey::Marshall( PSerStream & stm ) const
{
    //
    // NOTE: Order is important!
    //

    _property.Marshall( stm );
    stm.PutULong( _dwOrder );
}

CSortKey::CSortKey( PDeSerStream & stm )
        : _property( stm ),
          _dwOrder( stm.GetULong() )
{
    if ( !_property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}

CSort::~CSort()
{
    delete [] _ask;
}

void CSort::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _csk );

    for ( unsigned i = 0; i < _csk; i++ )
    {
        _ask[i].Marshall( stm );
    }
}

CSort::CSort( PDeSerStream & stm )
        : _csk( stm.GetULong() ),
          _size( _csk )
{
    XPtr<CSortKey> xSortKey( new CSortKey[ _csk ] );

    _ask = xSortKey.GetPointer();

    for ( unsigned i = 0; i < _csk; i++ )
    {
        CSortKey sk( stm );

        Add( sk, i );
    }

    xSortKey.Acquire();
}

void CSort::Add( CSortKey const & sk, unsigned pos )
{
    if ( pos >= _size )
    {
        unsigned cNew = (_size > 0) ? (_size * 2) : 4;
        while ( pos >= cNew )
        {
            cNew = cNew * 2;    
        }

        CSortKey * aNew = new CSortKey[ cNew ];

        if ( _ask )
        {
            memcpy( aNew, _ask, _csk * sizeof( CSortKey ) );
            memset( _ask, PRSPEC_PROPID, _size * sizeof CSortKey );
            delete [] _ask;
        }

        memset( aNew + _csk, PRSPEC_PROPID, (cNew - _csk) * sizeof( CSortKey ) );

        _ask = aNew;
        _size = cNew;
    }

    _ask[pos] = sk;

    if ( !_ask[pos].IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    if ( pos >= _csk )
    {
        _csk = pos + 1;
    }
}


void CSort::Add( CFullPropSpec const & property, ULONG dwOrder, unsigned pos )
{
    CSortKey sk( property, dwOrder );

    Add(sk, pos);
}

void CSort::Remove( unsigned pos )
{
    if ( pos < _csk )
    {
        _ask[pos].GetProperty().CFullPropSpec::~CFullPropSpec();
        _csk--;
        RtlMoveMemory( _ask + pos,
                       _ask + pos + 1,
                       (_csk - pos) * sizeof( CSortKey ) );
    }
}

//
// Methods for CRestriction
//

//+-------------------------------------------------------------------------
//
//  Member:     CRestriction::~CRestriction(), public
//
//  Synopsis:   Destroy restriction.  See Notes below.
//
//  History:    31-Dec-92 KyleP     Created
//
//  Notes:      This destructor simulates virtual destruction.  A
//              virtual destructor is not possible in CRestriction
//              because it maps directly to the C structure SRestriction.
//
//              Classes derived from CRestriction must be sure to set their
//              restriction type to RTNone in their destructor, so when the
//              base destructor below is called the derived destructor is
//              not called a second time.
//
//--------------------------------------------------------------------------

CRestriction::~CRestriction()
{
    //
    // It would be nice to assert in constructor but it's inline and
    // Win4Assert is not a public export.
    //

    Win4Assert( OFFSETS_MATCH( RESTRICTION, rt, CRestriction, _ulType ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, weight,
                               CRestriction, _lWeight ) );

    switch ( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    case RTPhrase:

        CastToNode()->CNodeRestriction::~CNodeRestriction();
        break;

    case RTNot:
        ((CNotRestriction *)this)->
            CNotRestriction::~CNotRestriction();
        break;

    case RTProperty:
        ((CPropertyRestriction *)this)->
            CPropertyRestriction::~CPropertyRestriction();
        break;

    case RTContent:
        ((CContentRestriction *)this)->
            CContentRestriction::~CContentRestriction();
        break;

    case RTNatLanguage:
        ((CNatLanguageRestriction *)this)->
            CNatLanguageRestriction::~CNatLanguageRestriction();
        break;

    case RTScope:
        ((CScopeRestriction *)this)->CScopeRestriction::~CScopeRestriction();
        break;

    case RTWord:
        ((CWordRestriction *)this)->CWordRestriction::~CWordRestriction();
        break;

    case RTSynonym:
        ((CSynRestriction *)this)->CSynRestriction::~CSynRestriction();
        break;

    case RTRange:
        ((CRangeRestriction *)this)->CRangeRestriction::~CRangeRestriction();
        break;

    case RTInternalProp:
        ((CInternalPropertyRestriction *)this)->
            CInternalPropertyRestriction::~CInternalPropertyRestriction();
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction\n", Type() ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        break;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRestriction::TreeCount(), public
//
//  Synopsis:   Returns the number of items in the tree
//
//  History:    15-Jul-96 dlee     Created
//
//--------------------------------------------------------------------------

ULONG CRestriction::TreeCount() const
{
    ULONG cItems = 1;

    switch ( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    case RTPhrase:
    {
        CNodeRestriction * p = CastToNode();
        for ( ULONG x = 0; x < p->Count(); x++ )
        {
            cItems += p->GetChild( x )->TreeCount();
        }
        break;
    }
    case RTNot:
    {
        CNotRestriction * p = (CNotRestriction *) this;

        cItems += p->GetChild()->TreeCount();
        break;
    }

    case RTProperty:
    case RTContent:
    case RTNatLanguage:
    case RTScope:
    case RTWord:
    case RTSynonym:
    case RTRange:
    case RTInternalProp:
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction\n", Type() ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        break;
    }

    return cItems;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRestriction::IsValid(), public
//
//  History:    14-Nov-95 KyleP     Created
//
//  Returns:    TRUE if all memory allocations, etc. succeeded.
//
//--------------------------------------------------------------------------

BOOL CRestriction::IsValid() const
{
    BOOL fValid = TRUE;

    switch ( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    case RTPhrase:

        fValid = CastToNode()->CNodeRestriction::IsValid();
        break;

    case RTNot:
        fValid = ((CNotRestriction *)this)->
            CNotRestriction::IsValid();
        break;

    case RTProperty:
        fValid = ((CPropertyRestriction *)this)->
            CPropertyRestriction::IsValid();
        break;

    case RTContent:
        fValid = ((CContentRestriction *)this)->
            CContentRestriction::IsValid();
        break;

    case RTNatLanguage:
        fValid = ((CNatLanguageRestriction *)this)->
            CNatLanguageRestriction::IsValid();
        break;

    case RTScope:
        fValid = ((CScopeRestriction *)this)->
            CScopeRestriction::IsValid();
        break;

    case RTWord:
        fValid = ((CWordRestriction *)this)->
            CWordRestriction::IsValid();
        break;

    case RTSynonym:
        fValid = ((CSynRestriction *)this)->
            CSynRestriction::IsValid();
        break;

    case RTRange:
        fValid = ((CRangeRestriction *)this)->
            CRangeRestriction::IsValid();
        break;

    case RTInternalProp:
        fValid = ((CInternalPropertyRestriction *)this)->
            CInternalPropertyRestriction::IsValid();
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction\n", Type() ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        fValid = FALSE;
        break;
    }

    return fValid;
}

void CRestriction::Marshall( PSerStream & stm ) const
{
    stm.PutULong( Type() );
    stm.PutLong( Weight() );

    switch ( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTPhrase:
        ((CNodeRestriction *)this)->Marshall( stm );
        break;

    case RTVector:
        ((CVectorRestriction *)this)->Marshall( stm );
        break;

    case RTNot:
        ((CNotRestriction *)this)->Marshall( stm );
        break;

    case RTProperty:
        ((CPropertyRestriction *)this)->Marshall( stm );
        break;

    case RTContent:
        ((CContentRestriction *)this)->Marshall( stm );
        break;

    case RTNatLanguage:
        ((CNatLanguageRestriction *)this)->Marshall( stm );
        break;

    case RTScope:
        ((CScopeRestriction *)this)->Marshall( stm );
        break;

    case RTWord:
    case RTSynonym:
        ((COccRestriction *)this)->Marshall( stm );
        break;

    case RTRange:
        ((CRangeRestriction *)this)->Marshall( stm );
        break;

    case RTInternalProp:
        ((CInternalPropertyRestriction *)this)->Marshall( stm );
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction\n", Type() ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        break;
    }
}

CRestriction * CRestriction::UnMarshall( PDeSerStream & stm )
{
    ULONG ulType = stm.GetULong();
    LONG  lWeight = stm.GetLong();

    switch ( ulType )
    {
    case RTNone:
        return new CRestriction( ulType, lWeight );

    case RTAnd:
    case RTOr:
    case RTProximity:
        return new CNodeRestriction( ulType, lWeight, stm );
        break;

    case RTPhrase:
        return new CPhraseRestriction( lWeight, stm );
        break;

    case RTVector:
        return new CVectorRestriction( lWeight, stm );
        break;

    case RTNot:
        return new CNotRestriction( lWeight, stm );
        break;

    case RTProperty:
        return new CPropertyRestriction( lWeight, stm );
        break;

    case RTContent:
        return new CContentRestriction( lWeight, stm );
        break;

    case RTNatLanguage:
        return new CNatLanguageRestriction( lWeight, stm );
        break;

    case RTScope:
        return new CScopeRestriction( lWeight, stm );
        break;

    case RTWord:
        return new CWordRestriction( lWeight, stm );
        break;

    case RTSynonym:
        return new CSynRestriction( lWeight, stm );
        break;

    case RTRange:
        return new CRangeRestriction( lWeight, stm );
        break;

    case RTInternalProp:
        return new CInternalPropertyRestriction( lWeight, stm );
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "Unhandled child (%d) of class CRestriction during unmarshalling\n",
                     ulType ));
        Win4Assert( !"Unhandled child class of CRestriction" );
        THROW( CException( E_INVALIDARG ) );
        break;
    }

    return( 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRestriction::IsLeaf, public
//
//  Returns:    TRUE if node is a leaf node
//
//  History:    12-Feb-93 KyleP     Moved from .hxx
//
//--------------------------------------------------------------------------

BOOL CRestriction::IsLeaf() const
{
    switch( Type() )
    {
    case RTAnd:
    case RTOr:
    case RTNot:
    case RTProximity:
    case RTVector:
    case RTPhrase:
        return( FALSE );

    default:
        return( TRUE );
    }
}


CRestriction *CRestriction::Clone() const
{
    switch ( Type() )
    {
    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTPhrase:
        return ( (CNodeRestriction *) this)->Clone();

    case RTVector:
        return ( (CVectorRestriction *) this)->Clone();

    case RTNot:
        return ( (CNotRestriction *) this)->Clone();

    case RTInternalProp:
        return ( (CInternalPropertyRestriction *) this)->Clone();

    case RTContent:
        return ( (CContentRestriction *) this)->Clone();

    case RTWord:
        return ( (CWordRestriction *) this)->Clone();

    case RTSynonym:
        return ( (CSynRestriction *) this)->Clone();

    case RTRange:
        return( (CRangeRestriction *) this)->Clone();

    case RTScope:
        return ((CScopeRestriction *) this)->Clone();

    case RTNone:
        return new CRestriction;

    default:
        ciDebugOut(( DEB_ERROR, "No clone method for restriction type - %d\n", Type() ));
        Win4Assert( !"CRestriction: Clone method should be overridden in child class" );

        return 0;
    }
}

CNodeRestriction::CNodeRestriction( ULONG NodeType,
                                    unsigned cInitAllocated )
        : CRestriction( NodeType, MAX_QUERY_RANK ),
          _cNode( 0 ),
          _paNode( 0 ),
          _cNodeAllocated( cInitAllocated )
{
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.ar.cRes,
                               CNodeRestriction, _cNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.ar.paRes,
                               CNodeRestriction, _paNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.ar.reserved,
                               CNodeRestriction, _cNodeAllocated ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.or.cRes,
                               CNodeRestriction, _cNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.or.paRes,
                               CNodeRestriction, _paNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.or.reserved,
                               CNodeRestriction, _cNodeAllocated ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pxr.cRes,
                               CNodeRestriction, _cNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pxr.paRes,
                               CNodeRestriction, _paNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pxr.reserved,
                               CNodeRestriction, _cNodeAllocated ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.vr.Node.cRes,
                               CNodeRestriction, _cNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.vr.Node.paRes,
                               CNodeRestriction, _paNode ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.vr.Node.reserved,
                               CNodeRestriction, _cNodeAllocated ) );

    if ( _cNodeAllocated > 0 )
    {
        _paNode = new CRestriction * [ _cNodeAllocated ];
    }
}

CNodeRestriction::CNodeRestriction( const CNodeRestriction& nodeRst )
    : CRestriction( nodeRst.Type(), nodeRst.Weight() ),
      _cNode( nodeRst.Count() ),
      _cNodeAllocated( nodeRst.Count() ),
      _paNode( 0 )
{
    if ( _cNodeAllocated > 0 )
    {
        _paNode = new CRestriction * [ _cNodeAllocated ];
        RtlZeroMemory( _paNode, _cNodeAllocated * sizeof( CRestriction * ) );

        for ( unsigned i=0; i<_cNode; i++ )
            _paNode[i] = nodeRst.GetChild( i )->Clone();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNodeRestriction::~CNodeRestriction(), public
//
//  Synopsis:   Destroy node restriction.  See Notes below.
//
//  History:    31-Dec-92 KyleP     Created
//
//  Notes:      This destructor simulates virtual destruction.  A
//              virtual destructor is not possible in CNodeRestriction
//              because it maps directly to a C structure.
//
//              Classes derived from CNodeRestriction must be sure to set their
//              restriction type to RTNone in their destructor, so when the
//              base destructor below is called the derived destructor is
//              not called a second time.
//
//--------------------------------------------------------------------------

CNodeRestriction::~CNodeRestriction()
{
    switch( Type() )
    {
    case RTNone:
        break;

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    {
        if ( 0 != _paNode )
        {
            for ( unsigned i = 0; i < _cNode; i++ )
                delete _paNode[i];

            delete [] _paNode;
        }

        SetType( RTNone );                  // Avoid recursion.
        break;
    }

    case RTPhrase:
        (( CPhraseRestriction *)this)->CPhraseRestriction::~CPhraseRestriction();
        break;

    case RTScope:
        (( CScopeRestriction *)this)->CScopeRestriction::~CScopeRestriction();
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unhandled child (%d) of class CNodeRestriction\n",
                     Type() ));
        Win4Assert( !"Unhandled child of class CNodeRestriction" );
        break;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNodeRestriction::IsValid(), public
//
//  History:    14-Nov-95 KyleP     Created
//
//  Returns:    TRUE if all memory allocations, etc. succeeded.
//
//--------------------------------------------------------------------------

BOOL CNodeRestriction::IsValid() const
{
    if ( 0 == _paNode )
        return FALSE;

    for ( unsigned i = 0; i < _cNode; i++ )
    {
        if ( 0 == _paNode[i] || !_paNode[i]->IsValid() )
            return FALSE;
    }

    return TRUE;
}

void CNodeRestriction::Marshall( PSerStream & stm ) const
{
#if CIDBG == 1
    if ( Type() == RTPhrase )
    {
        for ( unsigned i = 0; i < _cNode; i++ )
            Win4Assert( _paNode[i]->Type() == RTWord || _paNode[i]->Type() == RTSynonym );
    }
#endif

    stm.PutULong( _cNode );
    for ( unsigned i = 0; i < _cNode; i++ )
    {
        _paNode[i]->Marshall( stm );
    }
}

CNodeRestriction::CNodeRestriction( ULONG ulType, LONG lWeight, PDeSerStream & stm )
        : CRestriction( ulType, lWeight ),
          _cNode( 0 ),
          _paNode( 0 ),
          _cNodeAllocated( 0 )
{
    ULONG cNodeAllocated = stm.GetULong();

    // Note: this is an arbitrary limit intended to protect against attack

    if ( cNodeAllocated > 65536 )
        THROW( CException( E_INVALIDARG ) );

    _cNodeAllocated = cNodeAllocated;

    //
    // Note: the destructor will be called if the constructor doesn't finish,
    // from ~CRestriction.  So _paNode will be freed if AddChild fails.
    //

    _paNode = new CRestriction * [ _cNodeAllocated ];

    RtlZeroMemory( _paNode, _cNodeAllocated * sizeof( CRestriction * ) );

    for ( unsigned i = 0; i < _cNodeAllocated; i++ )
        AddChild( CRestriction::UnMarshall( stm ) );
}

void CNodeRestriction::AddChild( CRestriction * presChild, unsigned & pos )
{
    if ( _cNode == _cNodeAllocated )
        Grow();

    _paNode[_cNode] = presChild;
    pos = _cNode;
    _cNode++;
}

CRestriction * CNodeRestriction::RemoveChild( unsigned pos )
{
    if ( pos < _cNode )
    {
        CRestriction * prstRemoved = _paNode[pos];

        //
        // A memcpy would be nice, but is dangerous with overlapping
        // regions.
        //

        for ( pos++; pos < _cNode; pos++ )
        {
            _paNode[pos-1] = _paNode[pos];
        }

        _cNode--;

        return( prstRemoved );
    }
    else
    {
        return( 0 );
    }
}

void CNodeRestriction::Grow()
{
    int count = (_cNodeAllocated != 0) ? _cNodeAllocated * 2 : 2;

    CRestriction ** paNew= new CRestriction * [ count ];
    RtlZeroMemory( paNew, count * sizeof( CRestriction * ) );

    memcpy( paNew, _paNode, _cNode * sizeof( CRestriction * ) );

    delete (BYTE *) _paNode;

    _paNode = paNew;
    _cNodeAllocated = count;
}

CNodeRestriction *CNodeRestriction::Clone() const
{
    return new CNodeRestriction( *this );
}

CNotRestriction::CNotRestriction( CNotRestriction const & notRst )
    : CRestriction( RTNot, notRst.Weight() ),
      _pres( 0 )
{
    CRestriction *pChildRst = notRst.GetChild();

    if ( pChildRst )
        _pres = pChildRst->Clone();
}


CNotRestriction::~CNotRestriction()
{
    delete _pres;
    SetType( RTNone );                  // Avoid recursion.
}

void CNotRestriction::Marshall( PSerStream & stm ) const
{
    _pres->Marshall( stm );
}

CNotRestriction::CNotRestriction( LONG lWeight, PDeSerStream & stm )
        : CRestriction( RTNot, lWeight ),
          _pres( 0 )
{
    _pres = CRestriction::UnMarshall( stm );
}

CNotRestriction *CNotRestriction::Clone() const
{
    return new CNotRestriction( *this );
}


void CVectorRestriction::Marshall( PSerStream & stm ) const
{
    CNodeRestriction::Marshall( stm );
    stm.PutULong( _ulRankMethod );
}

CVectorRestriction::CVectorRestriction( LONG lWeight, PDeSerStream & stm )
        : CNodeRestriction( RTVector, lWeight, stm ),
          _ulRankMethod( stm.GetULong() )
{
}


CVectorRestriction *CVectorRestriction::Clone() const
{
    return new CVectorRestriction( *this );
}

CContentRestriction::CContentRestriction( WCHAR const * pwcsPhrase,
                                          CFullPropSpec const & Property,
                                          ULONG ulGenerateMethod,
                                          LCID lcid )

    : CRestriction( RTContent, MAX_QUERY_RANK ),
      _pwcsPhrase( 0 ),
      _Property( Property ),
      _lcid( lcid ),
      _ulGenerateMethod( ulGenerateMethod )
{
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.cr.prop,
                               CContentRestriction, _Property ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.cr.pwcsPhrase,
                               CContentRestriction, _pwcsPhrase ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.cr.lcid,
                               CContentRestriction, _lcid ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.cr.ulGenerateMethod,
                               CContentRestriction, _ulGenerateMethod ) );

    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    SetPhrase( pwcsPhrase );
}

CContentRestriction::CContentRestriction( CContentRestriction const & contentRst )
    : CRestriction( RTContent, contentRst.Weight() ),
      _pwcsPhrase( 0 ),
      _Property( contentRst.GetProperty() ),
      _lcid( contentRst.GetLocale() ),
      _ulGenerateMethod( contentRst.GenerateMethod() )
{
    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
    SetPhrase( contentRst.GetPhrase() );
}

CContentRestriction::~CContentRestriction()
{
    delete [] _pwcsPhrase;

    SetType( RTNone );                  // Avoid recursion.
}

void CContentRestriction::Marshall( PSerStream & stm ) const
{
    _Property.Marshall( stm );
    ULONG cc = wcslen( _pwcsPhrase );
    stm.PutULong( cc );
    stm.PutWChar( _pwcsPhrase, cc );
    stm.PutULong( _lcid );
    stm.PutULong( _ulGenerateMethod );
}

CContentRestriction::CContentRestriction( LONG lWeight, PDeSerStream & stm )
    : CRestriction( RTContent, lWeight ),
      _Property( stm )
{
    // set to 0 in case allocation fails, since ~CRestriction will call
    // ~CNatLanguageRestriction

    _pwcsPhrase = 0;

    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    XPtrST<WCHAR> xPhrase( UnMarshallWideStringNew( stm ) );

    _lcid = stm.GetULong();
    _ulGenerateMethod = stm.GetULong();

    _pwcsPhrase = xPhrase.Acquire();
}

void CContentRestriction::SetPhrase( WCHAR const * pwcsPhrase )
{
    delete [] _pwcsPhrase;
    _pwcsPhrase = 0;

    int len = ( wcslen( pwcsPhrase ) + 1 ) * sizeof( WCHAR );

    _pwcsPhrase = new WCHAR[len];
    memcpy( _pwcsPhrase, pwcsPhrase, len );
}


CContentRestriction *CContentRestriction::Clone() const
{
    return new CContentRestriction( *this );
}

CNatLanguageRestriction::CNatLanguageRestriction( WCHAR const * pwcsPhrase,
                                                  CFullPropSpec const & Property,
                                                  LCID lcid )
    : CRestriction( RTNatLanguage, MAX_QUERY_RANK ),
      _pwcsPhrase( 0 ),
      _Property( Property ),
      _lcid( lcid )
{
    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.nlr.prop,
                               CNatLanguageRestriction, _Property ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.nlr.pwcsPhrase,
                               CNatLanguageRestriction, _pwcsPhrase ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.nlr.lcid,
                               CNatLanguageRestriction, _lcid ) );

    SetPhrase( pwcsPhrase );
}

CNatLanguageRestriction::~CNatLanguageRestriction()
{
    delete [] _pwcsPhrase;

    SetType( RTNone );                  // Avoid recursion.
}

void CNatLanguageRestriction::Marshall( PSerStream & stm ) const
{
    _Property.Marshall( stm );
    ULONG cc = wcslen( _pwcsPhrase );
    stm.PutULong( cc );
    stm.PutWChar( _pwcsPhrase, cc );
    stm.PutULong( _lcid );
}

CNatLanguageRestriction::CNatLanguageRestriction( LONG lWeight, PDeSerStream & stm )
    : CRestriction( RTNatLanguage, lWeight ),
      _Property( stm )
{
    // set to 0 in case allocation fails, since ~CRestriction will call
    // ~CNatLanguageRestriction

    _pwcsPhrase = 0;

    if ( !_Property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    XPtrST<WCHAR> xPhrase( UnMarshallWideStringNew( stm ) );

    _lcid = stm.GetULong();

    _pwcsPhrase = xPhrase.Acquire();
}

void CNatLanguageRestriction::SetPhrase( WCHAR const * pwcsPhrase )
{
    delete [] _pwcsPhrase;
    _pwcsPhrase = 0;

    int len = ( wcslen( pwcsPhrase ) + 1 ) * sizeof( WCHAR );

    _pwcsPhrase = new WCHAR[len];

    RtlCopyMemory( _pwcsPhrase, pwcsPhrase, len );
}


CPropertyRestriction::CPropertyRestriction()
        : CRestriction( RTProperty, MAX_QUERY_RANK )
{
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.rel,
                               CPropertyRestriction, _relop ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.prop,
                               CPropertyRestriction, _Property ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.prval,
                               CPropertyRestriction, _prval ) );
}

CPropertyRestriction::CPropertyRestriction( ULONG relop,
                                            CFullPropSpec const & Property,
                                            CStorageVariant const & prval )
        : CRestriction( RTProperty, MAX_QUERY_RANK ),
          _relop( relop ),
          _Property( Property ),
          _prval( prval )
{
    if ( !_Property.IsValid() ||
         !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );

    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.rel,
                               CPropertyRestriction, _relop ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.prop,
                               CPropertyRestriction, _Property ) );
    Win4Assert( OFFSETS_MATCH( RESTRICTION, res.pr.prval,
                               CPropertyRestriction, _prval ) );

}

CPropertyRestriction::~CPropertyRestriction()
{
    SetType( RTNone );                  // Avoid recursion.
}

void CPropertyRestriction::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _relop );
    _Property.Marshall( stm );
    _prval.Marshall( stm );
}

CPropertyRestriction::CPropertyRestriction( LONG lWeight, PDeSerStream & stm )
        : CRestriction( RTProperty, lWeight ),
          _relop( stm.GetULong() ),
          _Property( stm ),
          _prval( stm )
{
    if ( !_Property.IsValid() ||
         !_prval.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}

void CPropertyRestriction::SetValue( WCHAR * pwcsValue )
{
    _prval = pwcsValue;
}

void CPropertyRestriction::SetValue( BLOB & bValue )
{
    _prval = bValue;
}

void CPropertyRestriction::SetValue( GUID * pguidValue )
{
    _prval = pguidValue;
}

CSortKey::CSortKey( CFullPropSpec const & ps, ULONG dwOrder )
        : _property( ps ),
          _dwOrder( dwOrder )
{
    if ( !_property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}

CSortKey::CSortKey( CFullPropSpec const & ps, ULONG dwOrder, LCID locale )
        : _property( ps ),
          _dwOrder( dwOrder ),
          _locale ( locale )
{
    if ( !_property.IsValid() )
        THROW( CException( E_OUTOFMEMORY ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\stgvarb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       StgVarB.cxx
//
//  Contents:   C++ Base wrapper for PROPVARIANT.
//
//  History:    01-Aug-94 KyleP     Created
//              31-Jul-96 MikeHill  - Relaxed assert in IsUnicodeString.
//                                  - Allow NULL strings.
//              14-May-97 mohamedn  - Allow marshalling of VT_ARRAY
//              28 Apr 98 AlanW     - Added all permitted VARIANT types
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <propset.h>
#include <propvar.h>

#include "debtrace.hxx"

#undef PROPASSERT
#define PROPASSERT Win4Assert

#if DBGPROP

BOOLEAN
IsUnicodeString(WCHAR const *pwszname, ULONG cb)
{
    if (cb != 0)
    {
        ULONG i, cchDoubleAnsi, cchNull;

        cchNull = cchDoubleAnsi = 0;
        for (i = 0; pwszname[i] != L'\0'; i++)
        {
            if ((char) pwszname[i] == '\0' || (char) (pwszname[i] >> 8) == '\0')
            {
                cchNull++;
                if (i > 8 && cchDoubleAnsi > (3*i)/4)
                {
                    return(TRUE);
                }
            }
            else
            if (isprint((char) pwszname[i]) && isprint((char) (pwszname[i] >> 8)))
            {
                cchDoubleAnsi++;
            }
        }

        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.

        PROPASSERT(cb == MAXULONG || (i + 1) * sizeof(WCHAR) <= cb);
    }
    return(TRUE);
}


BOOLEAN
IsAnsiString(CHAR const *pszname, ULONG cb)
{
    if (cb != 0)
    {
        ULONG i;

        // If the string is NULL, then it's not not an Ansi string,
        // so we'll call it an Ansi string.

        if( NULL == pszname )
            return( TRUE );

        for (i = 0; pszname[i] != '\0'; i++)
        {
        }
        if (i == 1 && isprint(pszname[0]) &&
            ((ULONG_PTR) &pszname[8] & 0xfff) == ((ULONG_PTR) pszname & 0xfff) &&
            isprint(pszname[2]) && pszname[3] == '\0' &&
            isprint(pszname[4]) && pszname[5] == '\0' &&
            isprint(pszname[6]) && pszname[7] == '\0')
        {
            PROPASSERT(!"IsAnsiString: Suspicious string: looks like Unicode");
            return(FALSE);
        }

        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.

        PROPASSERT(cb == MAXULONG || i + 1 <= cb);
    }
    return(TRUE);
}
#endif


//+-------------------------------------------------------------------
//  Member:    CBaseStorageVariant::UnmarshalledSize, public
//
//  Synopsis:  Unmarshalls a PROPVARIANT value serialized in a PDeSerStream.
//
//  Arguments: [stm] -- serialized stream
//             [cb]  -- size of *additional* data goes here.  Size of
//                      base PROPVARIANT not included.
//
//  Returns:   one of the following NTSTATUS values
//             STATUS_SUCCESS -- the call was successful.
//             STATUS_INVALID_PARAMETER -- unsupported type for unmarshalling.
//
//  Notes:     The size is computed assuming 4-byte granular allocations.
//
//--------------------------------------------------------------------

#if defined(WINNT) && !defined(IPROPERTY_DLL)

//+-------------------------------------------------------------------
//  Member:    CBaseStorageVariant::Unmarshall, public
//
//  Synopsis:  Unmarshalls a PROPVARIANT value serialized in a PDeSerStream.
//
//  Arguments: [stm] -- serialized stream
//             [var] -- unmarshalled PROPVARIANT instance
//             [MemAlloc] -- memory allocator for unmarshalling
//
//  Returns:   one of the following NTSTATUS values
//             STATUS_SUCCESS -- the call was successful.
//             STATUS_INSUFFICIENT_RESOURCES -- out of memory.
//             STATUS_INVALID_PARAMETER -- unsupported type for unmarshalling.
//
//--------------------------------------------------------------------

NTSTATUS
CBaseStorageVariant::Unmarshall(
    PDeSerStream& stm,
    PROPVARIANT& var,
    PMemoryAllocator &MemAlloc)
{
#if DBG
    switch (stm.PeekULong())
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
    case VT_CLSID:
    case VT_BLOB:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_VERSIONED_STREAM:
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
    case VT_VECTOR | VT_CLSID:
    case VT_VECTOR | VT_CF:
    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
    case VT_VECTOR | VT_LPWSTR:
    case VT_VECTOR | VT_VARIANT:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_VARIANT:
        break;

    default:
        PROPASSERT(!"Invalid type (peek) for PROPVARIANT unmarshalling");
        break;
    }
#endif

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbAlloc = 0;
    VOID **ppv = NULL;
    BOOLEAN fZero = FALSE;

    // Zero the entire variant data structure before assembling it together.
    RtlZeroMemory(&var, sizeof(PROPVARIANT));

    var.vt = (VARTYPE) stm.GetULong();

    switch (var.vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_I1:
    case VT_UI1:
        var.bVal = stm.GetByte();
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        var.iVal = stm.GetUShort();
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_INT:
    case VT_UINT:
        var.lVal = stm.GetULong();
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        stm.GetBlob((BYTE *)&var.hVal, sizeof(LARGE_INTEGER));
        break;

    case VT_DECIMAL:
        stm.GetBlob((BYTE *)&var, sizeof(DECIMAL));
        var.vt = VT_DECIMAL;
        break;

    case VT_CLSID:
        cbAlloc = sizeof(GUID);
        ppv = (void **)&var.puuid;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        var.blob.cbSize = stm.GetULong();
        cbAlloc = var.blob.cbSize;
        ppv = (void **)&var.blob.pBlobData;
        break;

    case VT_CF:
        var.pclipdata = (CLIPDATA *) MemAlloc.Allocate(sizeof(*var.pclipdata));
        if (var.pclipdata == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        var.pclipdata->cbSize = stm.GetULong();
        cbAlloc = CBPCLIPDATA(*var.pclipdata);
        var.pclipdata->ulClipFmt = stm.GetULong();
        ppv = (void **) &var.pclipdata->pClipData;
        break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_VERSIONED_STREAM:
        // NTRAID#DB-NTBUG9-84615-2000/07/31-dlee Some VT types not supported by Indexing Service

        var.vt = VT_EMPTY;
        break;

    case VT_BSTR:
        cbAlloc = stm.GetULong();
        ppv = (void **)&var.bstrVal;
        break;

    case VT_LPSTR:
        cbAlloc = stm.GetULong();
        ppv = (void **)&var.pszVal;
        break;

    case VT_LPWSTR:
        cbAlloc = stm.GetULong() * sizeof(WCHAR);
        ppv = (void **)&var.pwszVal;
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        var.caub.cElems = stm.GetULong();
        cbAlloc = var.caub.cElems * sizeof(BYTE);
        ppv = (void **)&var.caub.pElems;
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        var.cai.cElems = stm.GetULong();
        cbAlloc = var.cai.cElems * sizeof(SHORT);
        ppv = (void **)&var.cai.pElems;
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        var.cal.cElems = stm.GetULong();
        cbAlloc = var.cal.cElems * sizeof(LONG);
        ppv = (void **)&var.cal.pElems;
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        var.cah.cElems = stm.GetULong();
        cbAlloc = var.cah.cElems * sizeof(LARGE_INTEGER);
        ppv = (void **)&var.cah.pElems;
        break;

    case VT_VECTOR | VT_CLSID:
        var.cauuid.cElems = stm.GetULong();
        cbAlloc = var.cauuid.cElems * sizeof(GUID);
        ppv = (void **)&var.cauuid.pElems;
        break;

    case VT_VECTOR | VT_CF:
        var.caclipdata.cElems = stm.GetULong();
        cbAlloc = var.caclipdata.cElems * sizeof(CLIPDATA);
        ppv = (void **)&var.caclipdata.pElems;
        fZero = TRUE;   // set all pClipData pointers to NULL
        break;

    case VT_VECTOR | VT_BSTR:
        var.cabstr.cElems = stm.GetULong();
        cbAlloc = var.cabstr.cElems * sizeof(BSTR);
        ppv = (void **)&var.cabstr.pElems;
        fZero = TRUE;   // set all BSTR pointers to NULL
        break;

    case VT_VECTOR | VT_LPSTR:
        var.calpstr.cElems = stm.GetULong();
        cbAlloc = var.calpstr.cElems * sizeof(LPSTR);
        ppv = (void **)&var.calpstr.pElems;
        fZero = TRUE;   // set all LPSTR pointers to NULL
        break;

    case VT_VECTOR | VT_LPWSTR:
        var.calpwstr.cElems = stm.GetULong();
        cbAlloc = var.calpwstr.cElems * sizeof(LPWSTR);
        ppv = (void **)&var.calpwstr.pElems;
        fZero = TRUE;   // set all LPWSTR pointers to NULL
        break;

    case VT_VECTOR | VT_VARIANT:
        var.capropvar.cElems = stm.GetULong();
        cbAlloc = var.capropvar.cElems * sizeof(PROPVARIANT);
        ppv = (void **)&var.capropvar.pElems;
        fZero = TRUE;   // set all vt pointers to VT_EMPTY
        PROPASSERT(VT_EMPTY == 0);
        break;

    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_VARIANT:
    {
        unsigned short cDims = stm.GetUShort();

        // Guard against attack

        if ( cDims >= 50 )
            return E_INVALIDARG;

        USHORT fFeatures = stm.GetUShort();
        ULONG cbElements = stm.GetULong();

        if ( cbElements > 64 )
            return E_INVALIDARG;

        if ( 0 != ( FADF_RESERVED & fFeatures ) )
            return E_INVALIDARG;

        SAFEARRAY * psaDest;
        HRESULT hr = SafeArrayAllocDescriptorEx( var.vt & (~VT_ARRAY),
                                                 cDims,
                                                 &psaDest );
        if ( FAILED( hr ) )
            return hr;

        psaDest->pvData = 0;

        // Figure out features on our own -- it could be hacked.

        fFeatures = 0;

        // Ignore the cbElements in the stream -- it could be hacked.

        switch ( var.vt )
        {
            case VT_ARRAY | VT_UI1:
            case VT_ARRAY | VT_I1:
                cbElements = sizeof( BYTE );
                break;
            case VT_ARRAY | VT_BOOL:
            case VT_ARRAY | VT_I2:
            case VT_ARRAY | VT_UI2:
                cbElements = sizeof( SHORT );
                break;
            case VT_ARRAY | VT_ERROR:
            case VT_ARRAY | VT_R4:
            case VT_ARRAY | VT_I4:
            case VT_ARRAY | VT_UI4:
            case VT_ARRAY | VT_INT:
            case VT_ARRAY | VT_UINT:
                cbElements = sizeof( ULONG );
                break;
            case VT_ARRAY | VT_CY:
            case VT_ARRAY | VT_DATE:
            case VT_ARRAY | VT_R8:
                cbElements = sizeof( double );
                break;
            case VT_ARRAY | VT_BSTR:
                cbElements = sizeof( void * );
                fFeatures |= FADF_BSTR;
                break;
            case VT_ARRAY | VT_DECIMAL:
                cbElements = sizeof DECIMAL;
                break;
            case VT_ARRAY | VT_VARIANT:
                cbElements = sizeof PROPVARIANT;
                fFeatures |= FADF_VARIANT;
                break;
            default:
                Win4Assert( !"impossible" );
                break;
        }

        psaDest->fFeatures = fFeatures;
        psaDest->cbElements = cbElements;

        psaDest->cLocks = 0; // no one has this locked, and if it's
                             // locked, it can't be freed

        for ( unsigned i = 0; i < cDims; i++ )
        {
            ULONG cElem = stm.GetULong();

            // Guard against attack

            if ( cElem >= 65536 )
            {
                SafeArrayDestroyDescriptor( psaDest );
                RtlZeroMemory( &var, sizeof PROPVARIANT );
                return E_INVALIDARG;
            }

            psaDest->rgsabound[i].cElements = cElem;
            psaDest->rgsabound[i].lLbound   = stm.GetLong();
        }

        var.parray = psaDest;
        ppv = (void **) &(psaDest->pvData);
        break;
    }

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT unmarshalling");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if ( FAILED( Status ) )
        return Status;

    if ( ( 0 == ( var.vt & VT_ARRAY ) ) &&
         ( cbAlloc == 0 || Status != STATUS_SUCCESS ) )
    {
        // No further work need be done. The Ummarshalling is complete,
        // i.e., fixed size variant or no variable length data.

        if (ppv != NULL)
            *ppv = NULL;

        return(Status);
    }

    // Guard against attack

    if ( cbAlloc >= 65536 )
        return E_INVALIDARG;

    // Allocate the desired amount of memory and continue unmarshalling
    // if allocation was successfull.

    PROPASSERT(ppv != NULL);

    if ( var.vt == VT_BSTR )
    {
        *ppv = (void *)SysAllocStringLen(NULL, (cbAlloc - sizeof(OLECHAR))/sizeof(OLECHAR) );
    }
    else if ( 0 != ( VT_ARRAY & var.vt ) )
    {
        HRESULT hr = SafeArrayAllocData( var.parray );

        if ( FAILED( hr ) )
        {
            SafeArrayDestroyDescriptor( var.parray );
            RtlZeroMemory( &var, sizeof PROPVARIANT );
            return hr;
        }

        Win4Assert( 0 != *ppv );
    }
    else
    {
        *ppv = MemAlloc.Allocate(cbAlloc);
    }

    if (0 == *ppv )
        return STATUS_INSUFFICIENT_RESOURCES;

    if (fZero)
        RtlZeroMemory( *ppv, cbAlloc );

    ULONG i;

    // We have a variant with variable sized data which requires
    // further unmarshalling.
    switch(var.vt)
    {
    case VT_CLSID:
        stm.GetBlob((BYTE *)var.puuid, sizeof(CLSID));
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        stm.GetBlob(var.blob.pBlobData, var.blob.cbSize);
        break;

    case VT_CF:
        stm.GetBlob(var.pclipdata->pClipData, CBPCLIPDATA(*var.pclipdata));
        break;

    case VT_BSTR:
        stm.GetChar((char *) var.bstrVal, cbAlloc );
        break;

    case VT_LPSTR:
        stm.GetChar(var.pszVal, cbAlloc);
        break;

    case VT_LPWSTR:
        stm.GetWChar(var.pwszVal, cbAlloc / sizeof(WCHAR));
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        for (i = 0; i < var.caub.cElems; i++)
        {
            var.caub.pElems[i] = stm.GetByte();
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        for (i = 0; i < var.cai.cElems; i++)
        {
            var.cai.pElems[i] = stm.GetUShort();
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        for (i = 0; i < var.cal.cElems; i++)
        {
            var.cal.pElems[i] = stm.GetULong();
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        for (i = 0; i < var.cah.cElems; i++)
        {
            stm.GetBlob((BYTE *)&var.cah.pElems[i], sizeof(LARGE_INTEGER));
        }
        break;

    case VT_VECTOR | VT_CLSID:
        for (i = 0; i < var.cauuid.cElems; i++)
        {
            stm.GetBlob((BYTE *)&var.cauuid.pElems[i], sizeof(CLSID));
        }
        break;

    case VT_VECTOR | VT_CF:
        for (i = 0; i < var.caclipdata.cElems; i++)
        {
            PROPASSERT(var.caclipdata.pElems[i].pClipData == NULL);
            var.caclipdata.pElems[i].cbSize = stm.GetULong();
            cbAlloc = CBPCLIPDATA(var.caclipdata.pElems[i]);
            var.caclipdata.pElems[i].ulClipFmt = stm.GetULong();
            if (cbAlloc == 0)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.caclipdata.pElems[i].pClipData =
                (BYTE *) MemAlloc.Allocate(cbAlloc);
            if (var.caclipdata.pElems[i].pClipData == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetBlob(var.caclipdata.pElems[i].pClipData, cbAlloc);
        }
        break;

    case VT_VECTOR | VT_BSTR:
        for (i = 0; i < var.cabstr.cElems; i++)
        {
            PROPASSERT(var.cabstr.pElems[i] == NULL);
            cbAlloc = stm.GetULong();

            // guard against attack

            if ( cbAlloc == 0 || cbAlloc >= 65536 )
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            // cbAlloc includes sizeof(OLECHAR)
            var.cabstr.pElems[i] = SysAllocStringLen(NULL, (cbAlloc - sizeof(OLECHAR)) / sizeof(OLECHAR) );
            if (var.cabstr.pElems[i] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetChar((char *) var.cabstr.pElems[i], cbAlloc);
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        for (i = 0; i < var.calpstr.cElems; i++)
        {
            PROPASSERT(var.calpstr.pElems[i] == NULL);
            cbAlloc = stm.GetULong();

            // guard against attack

            if ( cbAlloc == 0 || cbAlloc >= 65536 )
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.calpstr.pElems[i] = (LPSTR) MemAlloc.Allocate(cbAlloc);
            if (var.calpstr.pElems[i] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetChar(var.calpstr.pElems[i], cbAlloc);
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        for (i = 0; i < var.calpwstr.cElems; i++)
        {
            PROPASSERT(var.calpwstr.pElems[i] == NULL);
            cbAlloc = stm.GetULong();   // actually, a count of WCHARs

            // guard against attack

            if ( cbAlloc == 0 || cbAlloc >= 65536 )
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            var.calpwstr.pElems[i] = (WCHAR *) MemAlloc.Allocate(cbAlloc * sizeof(WCHAR));
            if (var.calpwstr.pElems[i] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            stm.GetWChar(var.calpwstr.pElems[i], cbAlloc);
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        for (i = 0; i < var.capropvar.cElems; i++)
        {
            PROPASSERT(var.capropvar.pElems[i].vt == VT_EMPTY);
            Status = CBaseStorageVariant::Unmarshall(
                                            stm,
                                            var.capropvar.pElems[i],
                                            MemAlloc);
            if (Status != STATUS_SUCCESS)
            {
               break;
            }
        }
        break;


    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_VARIANT:
        {
            SAFEARRAY *pSaDest       = var.parray;
            unsigned  cDataElements  = 1;

            //
            // get total # of data elements to be unmarshalled.
            //
            for ( i = 0; i < pSaDest->cDims; i++)
            {
                cDataElements *= pSaDest->rgsabound[i].cElements;
            }

            //
            // unmarshall data elements
            //
            switch (var.vt)
            {
            case VT_ARRAY | VT_I1:
            case VT_ARRAY | VT_UI1:
                 {
                     BYTE * pByte = (BYTE *)pSaDest->pvData;

                     for ( i = 0; i < cDataElements ; i++ )
                         pByte[i] = stm.GetByte();
                 }
                 break;

            case VT_ARRAY | VT_I2:
            case VT_ARRAY | VT_UI2:
            case VT_ARRAY | VT_BOOL:
                 {
                     Win4Assert( sizeof VARIANT_BOOL == sizeof USHORT );

                     USHORT * pUShort = (USHORT *)pSaDest->pvData;

                     for ( i = 0; i < cDataElements ; i++ )
                         pUShort[i] = stm.GetUShort();
                 }
                 break;

            case VT_ARRAY | VT_I4:
            case VT_ARRAY | VT_UI4:
            case VT_ARRAY | VT_INT:
            case VT_ARRAY | VT_UINT:
            case VT_ARRAY | VT_R4:
            case VT_ARRAY | VT_ERROR:
                 {
                    Win4Assert( sizeof(ULONG) == sizeof (INT) );
                    Win4Assert( sizeof(ULONG) == sizeof (UINT) );
                    Win4Assert( sizeof(ULONG) == sizeof (SCODE) ); // VT_ERROR

                    ULONG * pULong = (ULONG *)pSaDest->pvData;

                    for ( unsigned i = 0; i < cDataElements; i++ )
                    {
                          pULong[i] = stm.GetULong();
                    }
                 }
                 break;

            case VT_ARRAY | VT_R8:
            case VT_ARRAY | VT_CY:
            case VT_ARRAY | VT_DATE:
                 {
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (CY)  );
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (DATE));
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (double));

                    LARGE_INTEGER * pLargInt = (LARGE_INTEGER *)pSaDest->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                    {
                        stm.GetBlob( (BYTE *) &pLargInt[i], sizeof(LARGE_INTEGER) );
                    }
                 }
                 break;

            case VT_ARRAY | VT_DECIMAL:
                 {
                    Win4Assert( sizeof (DECIMAL) == pSaDest->cbElements );

                    DECIMAL * pDecVal = (DECIMAL *)pSaDest->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                    {
                        stm.GetBlob( (BYTE *) &pDecVal[i], sizeof(DECIMAL) );
                    }
                 }
                 break;

            case VT_ARRAY|VT_BSTR:
                 {
                    BSTR *pBstrDest = (BSTR *) pSaDest->pvData;

                    for ( i = 0; i < cDataElements; i++ )
                    {
                        PROPASSERT( pBstrDest[i] == NULL );

                        cbAlloc = stm.GetULong();   // actually, a count of WCHARs + NULL terminator
                        if ( cbAlloc == 0 || cbAlloc >= 65536 )
                        {
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }

                        // cbAlloc already contains sizeof(OLECHAR), ie null terminator.
                        pBstrDest[i] = (BSTR) SysAllocStringLen(NULL, (cbAlloc - sizeof(OLECHAR)) / sizeof(OLECHAR) );
                        if ( !pBstrDest[i] )
                        {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }

                        stm.GetChar( (char *) pBstrDest[i], cbAlloc );
                    }
                 }
                 break;

            case VT_ARRAY | VT_VARIANT:
                {
                    Win4Assert( sizeof (PROPVARIANT) == pSaDest->cbElements );
                    PROPVARIANT *pVarDest = (PROPVARIANT *) pSaDest->pvData;
                    for (i = 0; i < cDataElements; i++)
                    {
                        PROPASSERT(pVarDest[i].vt == VT_EMPTY);
                        Status = CBaseStorageVariant::Unmarshall(
                                                        stm,
                                                        pVarDest[i],
                                                        MemAlloc);
                        if (Status != STATUS_SUCCESS)
                        {
                           break;
                        }
                    }
                }
                break;

            default:
                Win4Assert( !"Unexpected SAFEARRAY type" );
            }

        }
        break;

    default:
        PROPASSERT(!"Invalid type (peek) for PROPVARIANT unmarshalling");
        break;
    }
    return(Status);
}


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_CF(CLIPDATA *pclipdata, PSerStream &stm)
{
    CLIPDATA clipdata;

    clipdata.cbSize = 0;
    clipdata.ulClipFmt = 0;

    if (pclipdata != NULL)
    {
        clipdata.cbSize = pclipdata->cbSize;
        clipdata.ulClipFmt = pclipdata->ulClipFmt;
        if (pclipdata->pClipData == NULL)
        {
            clipdata.cbSize = 0;
        }
    }
    stm.PutULong(clipdata.cbSize);
    stm.PutULong(clipdata.ulClipFmt);
    if (clipdata.cbSize)
    {
        stm.PutBlob((BYTE *) pclipdata->pClipData, CBPCLIPDATA(clipdata));
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_BSTR(BSTR bstrVal, PSerStream &stm)
{
    if (bstrVal != NULL)
    {
        ULONG cc = BSTRLEN(bstrVal) + sizeof(OLECHAR);

        stm.PutULong(cc);
        stm.PutChar((char *) bstrVal, cc);
    }
    else
    {
        stm.PutULong(0);
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_LPSTR(CHAR *pszVal, PSerStream &stm)
{
    if (pszVal != NULL)
    {
        // Include NULL because OLE 2.0 spec says so.
        ULONG cc = strlen(pszVal) + 1;

        stm.PutULong(cc);
        stm.PutChar(pszVal, cc);
        PROPASSERT(IsAnsiString(pszVal, cc));
    }
    else
    {
        stm.PutULong(0);
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
inline void
_Marshall_VT_LPWSTR(LPWSTR pwszVal, PSerStream &stm)
{
    if (pwszVal != NULL)
    {
        // Include NULL because OLE 2.0 spec says so.

        ULONG cc = Prop_wcslen(pwszVal) + 1;

        PROPASSERT(IsUnicodeString(pwszVal, cc * sizeof(WCHAR)));
        stm.PutULong(cc);
        stm.PutWChar(pwszVal, cc);
    }
    else
    {
        stm.PutULong(0);
    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef ENABLE_MARSHAL_VARIANT
void
CBaseStorageVariant::Marshall(PSerStream & stm) const
{
    ULONG i;

    if ((VT_BYREF|VT_VARIANT) == vt)
    {
        PROPASSERT(pvarVal->vt != (VT_BYREF|VT_VARIANT));
        ((CBaseStorageVariant*)pvarVal)->Marshall(stm);
        return;
    }

    stm.PutULong(vt & ~VT_BYREF);

    switch (vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_I1:
    case VT_UI1:
        stm.PutByte(bVal);
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        stm.PutUShort(iVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
        stm.PutULong(lVal);
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        stm.PutBlob((BYTE *) &hVal, sizeof(hVal));
        break;

    case VT_DECIMAL:
        stm.PutBlob((BYTE *) &decVal, sizeof(DECIMAL));
        break;

    case VT_CLSID:
        stm.PutBlob((BYTE *)puuid, sizeof(CLSID));
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        stm.PutULong(blob.cbSize);
        stm.PutBlob(blob.pBlobData, blob.cbSize);
        break;

    case VT_CF:
        _Marshall_VT_CF(pclipdata, stm);
        break;

    case VT_STREAM:
    case VT_VERSIONED_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
        // NTRAID#DB-NTBUG9-84615-2000/07/31-dlee Some VT types not supported by Indexing Service
        break;

    case VT_BSTR:
        _Marshall_VT_BSTR(bstrVal, stm);
        break;

    case VT_LPSTR:
        _Marshall_VT_LPSTR(pszVal, stm);
        break;

    case VT_LPWSTR:
        _Marshall_VT_LPWSTR(pwszVal, stm);
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        stm.PutULong(caub.cElems);
        for (i = 0; i < caub.cElems; i++)
        {
            stm.PutByte(caub.pElems[i]);
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        stm.PutULong(cai.cElems);
        for (i = 0; i < cai.cElems; i++)
        {
            stm.PutUShort(cai.pElems[i]);
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        stm.PutULong(cal.cElems);
        for (i = 0; i < cal.cElems; i++)
        {
            stm.PutULong(cal.pElems[i]);
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        stm.PutULong(cah.cElems);
        for (i = 0; i < cah.cElems; i++)
        {
            stm.PutBlob((BYTE *) &cah.pElems[i], sizeof(LARGE_INTEGER));
        }
        break;

    case VT_VECTOR | VT_CLSID:
        stm.PutULong(cauuid.cElems);
        for (i = 0; i < cauuid.cElems; i++)
        {
            stm.PutBlob((BYTE *)&cauuid.pElems[i], sizeof(CLSID));
        }
        break;

    case VT_VECTOR | VT_CF:
        stm.PutULong(caclipdata.cElems);
        for (i = 0; i < caclipdata.cElems; i++)
        {
            _Marshall_VT_CF(&caclipdata.pElems[i], stm);
        }
        break;
        break;

    case VT_VECTOR | VT_BSTR:
        stm.PutULong(cabstr.cElems);
        for (i = 0; i < cabstr.cElems; i++)
        {
            _Marshall_VT_BSTR(cabstr.pElems[i], stm);
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        stm.PutULong(calpstr.cElems);
        for (i = 0; i < calpstr.cElems; i++)
        {
            _Marshall_VT_LPSTR(calpstr.pElems[i], stm);
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        stm.PutULong(calpwstr.cElems);
        for (i = 0; i < calpwstr.cElems; i++)
        {
            _Marshall_VT_LPWSTR(calpwstr.pElems[i], stm);
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        stm.PutULong(capropvar.cElems);
        for (i = 0; i < capropvar.cElems; i++)
        {
            ((CBaseStorageVariant &) capropvar.pElems[i]).Marshall(stm);
        }
        break;

    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_VARIANT:
         {
            SAFEARRAY *pSa = parray;
            unsigned   cDataElements = 1;

            stm.PutUShort(pSa->cDims);
            stm.PutUShort(pSa->fFeatures);
            stm.PutULong(pSa->cbElements);
            // don't marshall cLocks member, set to 1 upon unmarshalling

            //
            // marshall rgsabound
            //
            for ( i = 0; i < pSa->cDims; i++ )
            {
                stm.PutULong(pSa->rgsabound[i].cElements);
                stm.PutLong(pSa->rgsabound[i].lLbound);
                cDataElements *= pSa->rgsabound[i].cElements;
            }

            //
            // marshall pvData
            //
            switch ( vt )
            {

            case VT_ARRAY | VT_I1:
            case VT_ARRAY | VT_UI1:
                 {
                    BYTE * pByte = (BYTE *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutByte(pByte[i]);
                 }
                 break;

            case VT_ARRAY | VT_I2:
            case VT_ARRAY | VT_UI2:
            case VT_ARRAY | VT_BOOL:
                 {
                    Win4Assert( sizeof VARIANT_BOOL == sizeof USHORT );

                    USHORT * pUShort = (USHORT *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutUShort(pUShort[i]);
                 }
                 break;

            case VT_ARRAY | VT_I4:
            case VT_ARRAY | VT_UI4:
            case VT_ARRAY | VT_INT:
            case VT_ARRAY | VT_UINT:
            case VT_ARRAY | VT_R4:
            case VT_ARRAY | VT_ERROR:
                 {
                    Win4Assert( sizeof(ULONG) == sizeof (INT) );
                    Win4Assert( sizeof(ULONG) == sizeof (UINT) );
                    Win4Assert( sizeof(ULONG) == sizeof (SCODE) ); // VT_ERROR

                    ULONG * pULong = (ULONG *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutULong(pULong[i]);
                 }
                 break;

            case VT_ARRAY | VT_R8:
            case VT_ARRAY | VT_CY:
            case VT_ARRAY | VT_DATE:
                 {
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (CY)  );
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (DATE));
                    Win4Assert( sizeof (LARGE_INTEGER) == sizeof (double));

                    LARGE_INTEGER * pLargInt = (LARGE_INTEGER *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutBlob( (BYTE *) &pLargInt[i], sizeof(LARGE_INTEGER) );
                 }
                 break;

            case VT_ARRAY | VT_DECIMAL:
                 {
                    Win4Assert( sizeof (DECIMAL) == pSa->cbElements );

                    DECIMAL * pDecVal = (DECIMAL *)pSa->pvData;

                    for ( i = 0; i < cDataElements ; i++ )
                        stm.PutBlob( (BYTE *) &pDecVal[i], sizeof(DECIMAL) );
                 }
                 break;

            case VT_ARRAY | VT_BSTR:
                 {
                    for ( i = 0 ; i < cDataElements; i++ )
                        _Marshall_VT_BSTR( ((BSTR *)pSa->pvData)[i], stm );
                 }
                 break;

            case VT_ARRAY | VT_VARIANT:
                 {
                    PROPVARIANT *pVarnt = (PROPVARIANT *) pSa->pvData;
                    for ( i = 0 ; i < cDataElements; i++ )
                        ((CBaseStorageVariant &) pVarnt[i]).Marshall(stm);
                 }
                 break;

            default:
                Win4Assert( !"Invalid SAFEARRAY type" );

            }
         }

         break;

    case VT_BYREF | VT_I1:
    case VT_BYREF | VT_UI1:
        stm.PutByte(*pbVal);
        break;

    case VT_BYREF | VT_I2:
    case VT_BYREF | VT_UI2:
    case VT_BYREF | VT_BOOL:
        stm.PutUShort(*piVal);
        break;

    case VT_BYREF | VT_I4:
    case VT_BYREF | VT_UI4:
    case VT_BYREF | VT_INT:
    case VT_BYREF | VT_UINT:
    case VT_BYREF | VT_R4:
    case VT_BYREF | VT_ERROR:
        stm.PutULong(*plVal);
        break;

    case VT_BYREF | VT_R8:
    case VT_BYREF | VT_CY:
    case VT_BYREF | VT_DATE:
        stm.PutBlob((BYTE *) pdblVal, sizeof(double));
        break;

    case VT_BYREF | VT_DECIMAL:
        stm.PutBlob((BYTE *) pdecVal, sizeof(DECIMAL));
        break;

    case VT_BYREF | VT_BSTR:
        _Marshall_VT_BSTR( *pbstrVal, stm );
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT marshalling");
        break;

    }
}
#endif //ifdef ENABLE_MARSHAL_VARIANT


#ifdef OLDSUMCATAPI
void
MarshallVariant(PSerStream &stm, PROPVARIANT &stgvar)
{
    CBaseStorageVariant *pstgvar = (CBaseStorageVariant *)&stgvar;
    pstgvar->Marshall(stm);
}
#endif //ifdef OLDSUMCATAPI


#ifdef ENABLE_DISPLAY_VARIANT
VOID
CBaseStorageVariant::DisplayVariant(
    ULONG ulLevel,
    USHORT CodePage) const
{
    char *psz;

    switch (vt)
    {
    case VT_ILLEGAL: psz = "ILLEGAL"; goto EmptyType;
    case VT_EMPTY:   psz = "EMPTY";   goto EmptyType;
    case VT_NULL:    psz = "NULL";    goto EmptyType;

BlobType:
EmptyType:
        DEBTRACE((DBGFLAG "%s", psz));
        break;

    case VT_UI1:
        AssertByteField(bVal);          // VT_UI1
        DEBTRACE((DBGFLAG "UI1=%hx", bVal));
        break;

    case VT_I2:  psz = "I2";  goto ShortType;
    case VT_UI2: psz = "UI2"; goto ShortType;

ShortType:
        AssertShortField(iVal);                 // VT_I2
        AssertShortField(uiVal);                // VT_UI2
        DEBTRACE((DBGFLAG "%s=%hx", psz, iVal));
        break;

    case VT_BOOL:
        switch (boolVal)
        {
            case VARIANT_TRUE:
                DEBTRACE((DBGFLAG "BOOL=TRUE"));
                break;

            case FALSE:
                DEBTRACE((DBGFLAG "BOOL=FALSE"));
                break;

            default:
                DEBTRACE((DBGFLAG "BOOL=%hx???", boolVal));
                break;
        }
        break;

    case VT_I4:    psz = "I4";    goto LongType;
    case VT_UI4:   psz = "UI4";   goto LongType;
    case VT_R4:    psz = "R4";    goto LongType;
    case VT_ERROR: psz = "ERROR"; goto LongType;

LongType:
        AssertLongField(lVal);                  // VT_I4
        AssertLongField(ulVal);                 // VT_UI4
        AssertLongField(fltVal);                // VT_R4
        AssertLongField(scode);                 // VT_ERROR
        DEBTRACE((DBGFLAG "%s=%x", psz, lVal));
        break;

    case VT_I8:       psz = "I8";       goto LongLongType;
    case VT_UI8:      psz = "UI8";      goto LongLongType;
    case VT_R8:       psz = "R8";       goto LongLongType;
    case VT_CY:       psz = "CY";       goto LongLongType;
    case VT_DATE:     psz = "DATE";     goto LongLongType;
    case VT_FILETIME: psz = "FILETIME"; goto LongLongType;

LongLongType:
        AssertLongLongField(hVal);              // VT_I8
        AssertLongLongField(uhVal);             // VT_UI8
        AssertLongLongField(dblVal);            // VT_R8
        AssertLongLongField(cyVal);             // VT_CY
        AssertLongLongField(date);              // VT_DATE
        AssertLongLongField(filetime);          // VT_FILETIME
        DEBTRACE((DBGFLAG "%s=%x:%x", psz, hVal.HighPart, hVal.LowPart));
        break;

    case VT_CLSID: psz = "CLSID"; goto EmptyType;

    case VT_BLOB:        psz = "BLOB";        goto BlobType;
    case VT_BLOB_OBJECT: psz = "BLOB_OBJECT"; goto BlobType;
    case VT_CF:          psz = "CF";          goto BlobType;

    case VT_STREAM:          psz = "STREAM";          goto TestUnicode;
    case VT_STREAMED_OBJECT: psz = "STREAMED_OBJECT"; goto TestUnicode;
    case VT_STORAGE:         psz = "STORAGE";         goto TestUnicode;
    case VT_STORED_OBJECT:   psz = "STORED_OBJECT";   goto TestUnicode;
    case VT_VERSIONED_STREAM:  psz = "VERSIONED_STREAM";   goto TestUnicode;
    case VT_LPSTR:           psz = "LPSTR";           goto TestUnicode;

TestUnicode:
        AssertStringField(pszVal);              // VT_STREAM, VT_STREAMED_OBJECT
        AssertStringField(pszVal);              // VT_STORAGE, VT_STORED_OBJECT
        AssertStringField(pszVal);              // VT_LPSTR
        DEBTRACE((
            DBGFLAG
            CodePage == CP_WINUNICODE? "%s=L'%ws'" : "%s='%s'",
            psz,
            pszVal));
        break;

    case VT_BSTR:            psz = "BSTR";            goto PrintUnicode;
    case VT_LPWSTR:          psz = "LPWSTR";          goto PrintUnicode;

PrintUnicode:
        AssertStringField(pwszVal);             // VT_LPWSTR
        AssertStringField(bstrVal);             // VT_BSTR
        DEBTRACE((DBGFLAG "%s=L'%ws'", psz, pwszVal));
        break;

    default:
        if (vt & VT_VECTOR)
        {
            DEBTRACE((DBGFLAG "UNPRINTABLE VECTOR TYPE=%x(%u)", vt, vt));
        }
        else
        {
            DEBTRACE((DBGFLAG "UNKNOWN TYPE=%x(%u)", vt, vt));
        }
        break;

    }
}
#endif //ifdef ENABLE_DISPLAY_VARIANT

#endif //ifdef WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\pidremap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       pidmap.cxx
//
//  Contents:   Maps pid <--> property name.
//
//  History:    31-Jan-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidremap.hxx>
#include <coldesc.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::CPidRemapper, public
//
//  Synopsis:   Creates a prop id remapper.  Translates input arguments
//              'fake' propids to real propids.
//
//  Arguments:  [pidmap]      - input prop ID mapping array
//              [xPropMapper] - property mapper for real pid lookup
//              [prst]        - optional restriction, pids will be mapped
//              [pcol]        - optional output columns, pids will be mapped
//              [pso]         - optional sort specification, pids will be mapped
//
//  History:    31-Jan-93 KyleP     Created
//
//--------------------------------------------------------------------------

CPidRemapper::CPidRemapper( const CPidMapper & pidmap,
                            XInterface<IPropertyMapper> & xPropMapper,
                            CRestriction * prst,
                            CColumnSet * pcol,
                            CSortSet * pso )
        : _xPropMapper( xPropMapper.Acquire() ),
          _fAnyStatProps( FALSE ),
          _fContentProp ( FALSE ),
          _fRankVectorProp( FALSE ),
          _cRefs( 1 )
{
    _cpidReal = pidmap.Count();
    _xaPidReal.Set( _cpidReal, new PROPID[ _cpidReal ] );

    //
    // Iterate through the list
    //

    for ( unsigned i = 0; i < _cpidReal; i++ )
    {
        PROPID pid;
        FULLPROPSPEC const * pFullPropSpec =  pidmap.Get(i)->CastToStruct();
        SCODE sc = _xPropMapper->PropertyToPropid( pFullPropSpec, TRUE, &pid );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        _xaPidReal[i] = pid;

        if ( IsUserDefinedPid( _xaPidReal[i] ) )
        {
            //
            // Any user-defined property is a content property.
            // Note that the document characterization is a user-defined prop.
            //
            _fContentProp = TRUE;
        }
        else
        {
            if ( _xaPidReal[i] == pidContents )
                _fContentProp = TRUE;
            else
                _fAnyStatProps = TRUE;

            if ( _xaPidReal[i] == pidRankVector )
                _fRankVectorProp = TRUE;
        }

#if CIDBG == 1
        if ( vqInfoLevel & DEB_ITRACE )
        {
            CFullPropSpec const & ps = *pidmap.Get(i);

            GUID const & guid = ps.GetPropSet();

            char szGuid[50];

            sprintf( szGuid,
                     "%08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\\",
                     guid.Data1,
                     guid.Data2,
                     guid.Data3,
                     guid.Data4[0], guid.Data4[1],
                     guid.Data4[2], guid.Data4[3],
                     guid.Data4[4], guid.Data4[5],
                     guid.Data4[6], guid.Data4[7] );

            vqDebugOut(( DEB_ITRACE, szGuid ));

            if ( ps.IsPropertyName() )
                vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME,
                             "%ws ",
                             ps.GetPropertyName() ));
            else
                vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME,
                             "0x%x ",
                             ps.GetPropertyPropid() ));

            vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, " --> pid 0x%x\n",
                         _xaPidReal[i] ));

        }
#endif // CIDBG == 1

        CFullPropSpec * ppsFull = new CFullPropSpec( *pidmap.Get(i) );

        XPtr<CFullPropSpec> xpps(ppsFull);

        if ( xpps.IsNull() || !xpps->IsValid() )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        _propNames.Add( ppsFull, i );
        xpps.Acquire();

        Win4Assert( _xaPidReal[i] != pidInvalid );
    }

    if ( prst )
        RemapPropid( prst );

    if ( pcol )
        RemapPropid( pcol );

    if ( pso )
        RemapPropid( pso );
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::CPidRemapper, public
//
//  Synopsis:   Creates a prop id remapper.
//
//  Arguments:  [xPropMapper] - Property mapper for real pid lookup
//
//  History:    12-Mar-95   DwightKr    Created
//
//--------------------------------------------------------------------------
CPidRemapper::CPidRemapper( XInterface<IPropertyMapper> & xPropMapper )
        : _xPropMapper( xPropMapper.Acquire() ),
          _cpidReal( 0 ),
          _cRefs( 1 )
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::~CPidRemapper, public
//
//  History:    15-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

CPidRemapper::~CPidRemapper()
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::RealToName, public
//
//  Effects:    Convert a PROPID to a propspec
//
//  Arguments:  [pid] - Given pid
//
//  History:    22-Jan-97     SitaramR         Added header
//
//--------------------------------------------------------------------------

CFullPropSpec const * CPidRemapper::RealToName( PROPID pid ) const
{
    Win4Assert( ! _xaPidReal.IsNull() );

    //
    // Just linear search
    //
    for ( unsigned i = 0;
          i < _cpidReal && _xaPidReal[i] != pid;
          i++
        )
    {
        continue;
    }

    Win4Assert( i < _cpidReal );

    //
    // This can happen if a hacker tries to munge query requests
    //

    if ( i == _cpidReal )
        THROW( CException( E_ABORT ) );

    return( _propNames.Get( i ) );
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::NameToReal, public
//
//  Effects:    Convert a property which is not necessarily in the pid map
//              to a PROPID.
//
//  Arguments:  [pProperty] - pointer to the propspec.
//
//  Returns:    PROPID - the mapped property ID or pidInvalid.
//
//  History:    28 Jun 94       AlanW   Created
//
//--------------------------------------------------------------------------

PROPID CPidRemapper::NameToReal( CFullPropSpec const * pProperty )
{
    for (unsigned i = 0; i < _cpidReal; i++)
    {
        if (*pProperty == *_propNames.Get(i))
        {
            return _xaPidReal[ i ];
        }
    }

    //
    //  Property is not in the mapping array.  Add it.
    //
    PROPID Prop;
    FULLPROPSPEC const * pFullPropSpec =  pProperty->CastToStruct();
    SCODE sc = _xPropMapper->PropertyToPropid( pFullPropSpec, TRUE, &Prop );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    if (Prop != pidInvalid)
    {
        PROPID *ppidReal = new PROPID[ _cpidReal+1 ];
        memcpy(ppidReal, _xaPidReal.GetPointer(), _cpidReal * sizeof (PROPID));

        //
        // No lock is needed here to prevent races with RealToName since in current
        // usage everything is added in the query path by a single thread before
        // reads happen from multiple threads.
        //

        PROPID *ppidTemp = _xaPidReal.Acquire();
        _xaPidReal.Set( _cpidReal+1, ppidReal );
        delete [] ppidTemp;

        CFullPropSpec * ppsFull = new CFullPropSpec( *pProperty );

        XPtr<CFullPropSpec> xpps(ppsFull);

        if ( xpps.IsNull() || !xpps->IsValid() )
        {
            THROW( CException( STATUS_NO_MEMORY ) );
        }

        _propNames.Add( ppsFull, _cpidReal );
        xpps.Acquire();

        Win4Assert(*_propNames.Get(_cpidReal) == *pProperty);
        _xaPidReal[_cpidReal] = Prop;

        _cpidReal++;
    }

    return Prop;
}

//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::RemapPropid, public
//
//  Effects:    Traverses [pRst], converting 'fake' propid to 'real'
//
//  Arguments:  [pRst] -- Restriction
//
//  History:    15-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CPidRemapper::RemapPropid( CRestriction * pRst )
{
    Win4Assert ( pRst != 0 );

    switch( pRst->Type() )
    {
    case RTInternalProp:
    {
        CInternalPropertyRestriction * pPropRst =
            (CInternalPropertyRestriction *)pRst;

        pPropRst->SetPid( FakeToReal( pPropRst->Pid() ) );
        if ( 0 != pPropRst->GetContentHelper() )
            RemapPropid( pPropRst->GetContentHelper() );
        break;
    }

    case RTWord:
    {
        CWordRestriction * pWordRst = (CWordRestriction *)pRst;
        pWordRst->SetPid( FakeToReal( pWordRst->Pid() ) );
        break;
    }

    case RTSynonym:
    {
        CSynRestriction * pSynRst = (CSynRestriction *)pRst;
        CKeyArray & keys = pSynRst->GetKeys();

        for ( int i = keys.Count() - 1; i >= 0; i-- )
        {
            CKey & key = keys.Get(i);
            key.SetPid( FakeToReal( key.Pid() ) );
        }
        break;
    }

    case RTNot:
    {
        CNotRestriction * pnrst = (CNotRestriction *)pRst;

        RemapPropid( pnrst->GetChild() );
        break;
    }

    case RTAnd:
    case RTOr:
    case RTVector:
    case RTProximity:
    case RTPhrase:
    {
        CNodeRestriction * pNodeRst = pRst->CastToNode();

        for ( int i = pNodeRst->Count() - 1; i >= 0; i-- )
        {
            RemapPropid( pNodeRst->GetChild( i ) );
        }
        break;
    }
    case RTRange:
    case RTNone:   // probably a noise word in a vector query
        break;

    default:
        Win4Assert( !"RemapPropid: Unknown type." );
        break;

    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::RemapPropid, public
//
//  Effects:    Traverses [pColumns], converting 'fake' propid to 'real'
//
//  Arguments:  [pColumns] -- Output columns
//
//  History:    22-Jun-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CPidRemapper::RemapPropid( CColumnSet * pColumns )
{
    for ( unsigned i = 0; i < pColumns->Count(); i++ )
    {
        pColumns->Get(i) = FakeToReal( pColumns->Get(i) );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CPidRemapper::RemapPropid, public
//
//  Effects:    Traverses [pSort], converting 'fake' propid to 'real'
//
//  Arguments:  [pSort] -- Restriction
//
//  History:    15-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CPidRemapper::RemapPropid( CSortSet * pSort )
{
    for ( unsigned i = 0; i < pSort->Count(); i++ )
    {
        pSort->Get(i).pidColumn = FakeToReal( pSort->Get(i).pidColumn );
    }
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
void CPidRemapper::ReBuild( const CPidMapper & pidmap )
{
    if ( _cpidReal < pidmap.Count() )
    {
        delete [] _xaPidReal.Acquire();

        _cpidReal = 0;

        _xaPidReal.Set( pidmap.Count(), new PROPID[ pidmap.Count() ] );
    }

    _cpidReal = pidmap.Count();

    //
    // Iterate through the list
    //

    for ( unsigned i = 0; i < _cpidReal; i++ )
    {
        PROPID pid;
        FULLPROPSPEC const * pFullPropSpec =  pidmap.Get(i)->CastToStruct();
        SCODE sc = _xPropMapper->PropertyToPropid( pFullPropSpec, TRUE, &pid );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        _xaPidReal[i] = pid;

        Win4Assert( _xaPidReal[i] != pidInvalid );
    }
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
void CPidRemapper::Set( XArray<PROPID> & aPids )
{
    delete [] _xaPidReal.Acquire();

    _cpidReal = aPids.Count();
    _xaPidReal.Set( _cpidReal, aPids.Acquire() );
}

//
// This has to go somewhere...
//

UNICODECALLOUTS UnicodeCallouts = { WIN32_UNICODECALLOUTS };



//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    22-Jan-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CPidRemapper::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    22-Jan-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CPidRemapper::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}



//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    22-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CPidRemapper::QueryInterface(
    REFIID riid,
    void ** ppvObject)
{
    if ( IID_ICiQueryPropertyMapper == riid )
        *ppvObject = (ICiQueryPropertyMapper *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::PropertyToPropid
//
//  Synopsis:   Convert propspec to pid
//
//  Arguments:  [pFullPropSpec] -- propspec to convert
//              [pPropId]       -- pid returned here
//
//  History:    22-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CPidRemapper::PropertyToPropid( const FULLPROPSPEC *pFullPropSpec,
                                                        PROPID *pPropId)
{
    SCODE sc = S_OK;

    TRY
    {
        CFullPropSpec const * pProperty = (CFullPropSpec const *) pFullPropSpec;
        *pPropId = NameToReal( pProperty );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CPidRemapper:PropertyToPropid - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CPidRemapper::PropidToProperty
//
//  Synopsis:   Convert pid to propspec
//
//  Arguments:  [pPropId]       -- pid to convert
//              [pFullPropSpec] -- propspec returned here
//
//  Notes:      *ppFullPropSpec is owned by CPidRemapper
//
//  History:    22-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CPidRemapper::PropidToProperty( PROPID propId,
                                                        FULLPROPSPEC const **ppFullPropSpec )
{
    SCODE sc = S_OK;

    TRY
    {
        *ppFullPropSpec = RealToName( propId )->CastToStruct();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CPidRemapper:PropidToProperty - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\stgvar.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       StgVar.cxx
//
//  Contents:   C++ wrapper for PROPVARIANT.
//
//  History:    01-Aug-94 KyleP     Created
//              01-Apr-95 t-ColinB  Added definitions for vector related
//                                  SetValue() members
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

CCoTaskAllocator CoTaskAllocator; // exported data definition

void *
CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return(CoTaskMemAlloc(cbSize));
}

void
CCoTaskAllocator::Free(void *pv)
{
    CoTaskMemFree(pv);
}

#define VECTOR_SET_BODY( type, vtype )                                    \
                                                                          \
void CStorageVariant::Set##vtype (                                        \
    type val,                                                             \
    unsigned pos )                                                        \
{                                                                         \
    CAllocStorageVariant::Set##vtype( val, pos, CoTaskAllocator );        \
}

VECTOR_SET_BODY( CHAR, I1 );
VECTOR_SET_BODY( BYTE, UI1 );
VECTOR_SET_BODY( short, I2 );
VECTOR_SET_BODY( USHORT, UI2 );
VECTOR_SET_BODY( long,  I4 );
VECTOR_SET_BODY( ULONG,  UI4 );
VECTOR_SET_BODY( SCODE,  ERROR );
VECTOR_SET_BODY( LARGE_INTEGER, I8 );
VECTOR_SET_BODY( ULARGE_INTEGER, UI8 );
VECTOR_SET_BODY( float,  R4 );
VECTOR_SET_BODY( double, R8 );
VECTOR_SET_BODY( VARIANT_BOOL, BOOL );
VECTOR_SET_BODY( CY, CY );
VECTOR_SET_BODY( DATE, DATE );
VECTOR_SET_BODY( char const *, LPSTR );
VECTOR_SET_BODY( WCHAR const *, LPWSTR );
VECTOR_SET_BODY( BSTR, BSTR );
VECTOR_SET_BODY( FILETIME, FILETIME );
VECTOR_SET_BODY( CLSID, CLSID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\restrict\stgvara.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       StgVarA.cxx
//
//  Contents:   C++ wrapper for PROPVARIANT.
//
//  History:    01-Aug-94 KyleP     Created
//              14-May-97 mohamedn  allocate/deallocate SafeArrays (VT_ARRAY)
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#ifndef _NTDLLBUILD_

#include <propset.h>
#include <propvar.h>
#include <pmalloc.hxx>

CAllocStorageVariant::CAllocStorageVariant(
    BYTE *pb,
    ULONG cb,
    PMemoryAllocator &ma)
{
    vt = VT_BLOB;

    if ( 0 == pb )
    {
        blob.cbSize = 0;
        blob.pBlobData = 0;
    }
    else
    {
        blob.cbSize = cb;
        blob.pBlobData = (BYTE *) ma.Allocate(cb);

        if (blob.pBlobData != NULL)
        {
            memcpy(blob.pBlobData, pb, cb);
        }
    }
}


CAllocStorageVariant::CAllocStorageVariant(
    char const *psz,
    PMemoryAllocator &ma)
{
    vt = VT_LPSTR;

    if ( 0 == psz )
    {
        pszVal = 0;
    }
    else
    {
        int cb = strlen(psz) + 1;

        pszVal = (char *) ma.Allocate(cb);

        if (pszVal != NULL)
        {
            memcpy(pszVal, psz, cb);
        }
    }
}


CAllocStorageVariant::CAllocStorageVariant(
    WCHAR const *pwsz,
    PMemoryAllocator &ma)
{
    vt = VT_LPWSTR;

    if ( 0 == pwsz )
    {
        pwszVal = 0;
    }
    else
    {
        int cb = (wcslen(pwsz) + 1) * sizeof(WCHAR);

        pwszVal = (WCHAR *) ma.Allocate(cb);

        if (pszVal != NULL)
        {
            memcpy(pwszVal, pwsz, cb);
        }
    }
}


CAllocStorageVariant::CAllocStorageVariant(
    CLSID const *pcid,
    PMemoryAllocator &ma)
{
    vt = VT_CLSID;
    puuid = (CLSID *) ma.Allocate(sizeof(CLSID));

    if (puuid != NULL)
    {
        memcpy(puuid, pcid, sizeof(CLSID));
    }
}


CAllocStorageVariant::CAllocStorageVariant(
    VARENUM v,
    ULONG cElements,
    PMemoryAllocator &ma)
{
    ULONG cbElement;
    BOOLEAN fZero = FALSE;

    // Ignore vector flag.  This constructor is always for vectors only.

    vt = v | VT_VECTOR;

    switch (vt)
    {
    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        AssertByteVector(cac);                  // VT_I1
        AssertByteVector(caub);                 // VT_UI1
        cbElement = sizeof(caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        AssertShortVector(cai);                 // VT_I2
        AssertShortVector(caui);                // VT_UI2
        AssertShortVector(cabool);              // VT_BOOL
        cbElement = sizeof(cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        AssertLongVector(cal);                  // VT_I4
        AssertLongVector(caul);                 // VT_UI4
        AssertLongVector(caflt);                // VT_R4
        AssertLongVector(cascode);              // VT_ERROR
        cbElement = sizeof(cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        AssertLongLongVector(cah);              // VT_I8
        AssertLongLongVector(cauh);             // VT_UI8
        AssertLongLongVector(cadbl);            // VT_R8
        AssertLongLongVector(cacy);             // VT_CY
        AssertLongLongVector(cadate);           // VT_DATE
        AssertLongLongVector(cafiletime);       // VT_FILETIME
        cbElement = sizeof(cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        AssertVarVector(cauuid, sizeof(GUID));
        cbElement = sizeof(GUID);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_CF:
        AssertVarVector(caclipdata, sizeof(CLIPDATA));  // VT_CF
        cbElement = sizeof(CLIPDATA);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
    case VT_VECTOR | VT_LPWSTR:
        AssertStringVector(calpwstr);                   // VT_LPWSTR
        AssertStringVector(cabstr);                     // VT_BSTR
        AssertStringVector(calpstr);                    // VT_LPSTR
        cbElement = sizeof(VOID *);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_VARIANT:
        AssertVarVector(capropvar, sizeof(PROPVARIANT)); // VT_VARIANT
        cbElement = sizeof(PROPVARIANT);
        ASSERT(VT_EMPTY == 0);
        fZero = TRUE;
        break;

    default:
        ASSERT(!"CAllocStorageVariant -- Invalid vector type");
        vt = VT_EMPTY;
        break;
    }
    if (vt != VT_EMPTY)
    {
        caub.cElems = 0;
        caub.pElems = (BYTE *) ma.Allocate(cElements * cbElement);
        if (caub.pElems != NULL)
        {
            if (fZero)
            {
                memset(caub.pElems, 0, cElements * cbElement);
            }
            caub.cElems = cElements;
        }
    }
}


#define POINTER_FIXUP(type, field)                 \
  field.pElems = (type *) ma.Allocate(field.cElems * sizeof(field.pElems[0]));\
  if (field.pElems != NULL)                        \
  {                                                \
      memcpy(                                      \
          field.pElems,                            \
          var.field.pElems,                        \
          field.cElems * sizeof(field.pElems[0])); \
  }


CAllocStorageVariant::CAllocStorageVariant(
    PROPVARIANT& var,
    PMemoryAllocator &ma): CBaseStorageVariant(var)
{
    BOOLEAN fNoMemory = FALSE;
    ULONG i;

    //
    // Fixup any pointers
    //

    switch (vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        break;

    case VT_CLSID:
        vt = VT_EMPTY;
        SetCLSID(var.puuid, ma);
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        blob.pBlobData = (BYTE *) ma.Allocate(blob.cbSize);
        if (blob.pBlobData == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memcpy(blob.pBlobData, var.blob.pBlobData, blob.cbSize);
        break;

    case VT_CF:
        pclipdata = (CLIPDATA *) ma.Allocate(sizeof(*pclipdata));
        if (pclipdata == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        *pclipdata = *var.pclipdata;
        pclipdata->pClipData = (BYTE *) ma.Allocate(CBPCLIPDATA(*pclipdata));
        if (pclipdata->pClipData == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memcpy(pclipdata->pClipData, var.pclipdata->pClipData, CBPCLIPDATA(*pclipdata));
        break;

    case VT_STREAM:
    case VT_VERSIONED_STREAM:
    case VT_STREAMED_OBJECT:
        pStream->AddRef();
        break;

    case VT_STORAGE:
    case VT_STORED_OBJECT:
        pStorage->AddRef();
        break;

    case VT_BSTR:
        vt = VT_EMPTY;
        SetBSTR(var.bstrVal, ma);
        break;

    case VT_LPSTR:
        vt = VT_EMPTY;
        SetLPSTR(var.pszVal, ma);
        break;

    case VT_LPWSTR:
        vt = VT_EMPTY;
        SetLPWSTR(var.pwszVal, ma);
        break;

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
        POINTER_FIXUP(BYTE, caub);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        AssertShortVector(cai);                 // VT_I2
        AssertShortVector(caui);                // VT_UI2
        AssertShortVector(cabool);              // VT_BOOL
        POINTER_FIXUP(short, cai);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        AssertLongVector(cal);                  // VT_I4
        AssertLongVector(caul);                 // VT_UI4
        AssertLongVector(caflt);                // VT_R4
        AssertLongVector(cascode);              // VT_ERROR
        POINTER_FIXUP(long, cal);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        AssertLongLongVector(cah);              // VT_I8
        AssertLongLongVector(cauh);             // VT_UI8
        AssertLongLongVector(cadbl);            // VT_R8
        AssertLongLongVector(cacy);             // VT_CY
        AssertLongLongVector(cadate);           // VT_DATE
        AssertLongLongVector(cafiletime);       // VT_FILETIME
        POINTER_FIXUP(LARGE_INTEGER, cah);
        break;

    case VT_VECTOR | VT_CLSID:
        POINTER_FIXUP(CLSID, cauuid);
        break;

    case VT_VECTOR | VT_CF:
    {
        caclipdata.pElems = (CLIPDATA *)
            ma.Allocate(caclipdata.cElems * sizeof(caclipdata.pElems[0]));
        if (caclipdata.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memset(
            caclipdata.pElems,
            0,
            caclipdata.cElems * sizeof(caclipdata.pElems[0]));
        for (i = 0; i < caclipdata.cElems; i++)
        {
            caclipdata.pElems[i] = var.caclipdata.pElems[i];
            caclipdata.pElems[i].pClipData = (BYTE *)
                ma.Allocate(CBPCLIPDATA(caclipdata.pElems[i]));

            if (caclipdata.pElems[i].pClipData == NULL)
            {
                fNoMemory = TRUE;
                break;
            }
            memcpy(
                caclipdata.pElems[i].pClipData,
                var.caclipdata.pElems[i].pClipData,
                CBPCLIPDATA(caclipdata.pElems[i]));
        }
        break;
    }

    case VT_VECTOR | VT_BSTR:
    {
        cabstr.pElems = (BSTR *)
        ma.Allocate(cabstr.cElems * sizeof(cabstr.pElems[0]));
        if (cabstr.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memset(cabstr.pElems, 0, cabstr.cElems * sizeof(cabstr.pElems[0]));
        for (i = 0; i < cabstr.cElems; i++)
        {
            cabstr.pElems[i] = SysAllocString(var.cabstr.pElems[i]);
            if (cabstr.pElems[i] == NULL)
            {
                fNoMemory = TRUE;
                break;
            }
        }
        break;
    }

    case VT_VECTOR | VT_LPSTR:
    {
        calpstr.pElems = (LPSTR *)
            ma.Allocate(calpstr.cElems * sizeof(calpstr.pElems[0]));
        if (calpstr.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memset(calpstr.pElems, 0, calpstr.cElems * sizeof(calpstr.pElems[0]));
        for (i = 0; i < calpstr.cElems; i++)
        {
            unsigned cb = strlen(var.calpstr.pElems[i]) + 1;
            calpstr.pElems[i] = (char *) ma.Allocate(cb);
            if (calpstr.pElems[i] == NULL)
            {
                fNoMemory = TRUE;
                break;
            }
            memcpy(calpstr.pElems[i], var.calpstr.pElems[i], cb);
        }
        break;
    }

    case VT_VECTOR | VT_LPWSTR:
    {
        calpwstr.pElems = (LPWSTR *)
            ma.Allocate(calpwstr.cElems * sizeof(calpwstr.pElems[0]));
        if (calpwstr.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        memset(calpwstr.pElems, 0, calpwstr.cElems * sizeof(calpwstr.pElems[0]));
        for (i = 0; i < calpwstr.cElems; i++)
        {
            unsigned cb = (wcslen(var.calpwstr.pElems[i]) + 1) * sizeof(WCHAR);
            calpwstr.pElems[i] = (WCHAR *) ma.Allocate(cb);
            if (calpwstr.pElems[i] == NULL)
            {
                fNoMemory = TRUE;
                break;
            }
            memcpy(calpwstr.pElems[i], var.calpwstr.pElems[i], cb);
        }
        break;
    }

    case VT_VECTOR | VT_VARIANT:
        capropvar.pElems = (PROPVARIANT *)
            ma.Allocate(capropvar.cElems * sizeof(capropvar.pElems[0]));
        if (capropvar.pElems == NULL)
        {
            fNoMemory = TRUE;
            break;
        }
        ASSERT(VT_EMPTY == 0);
        memset(
            capropvar.pElems,
            0,
            capropvar.cElems * sizeof(capropvar.pElems[0]));

        for (i = 0; i < capropvar.cElems; i++)
        {
            new (&capropvar.pElems[i]) CAllocStorageVariant(
                                                var.capropvar.pElems[i],
                                                ma);

            if (!((CAllocStorageVariant *) &capropvar.pElems[i])->IsValid())
            {
                fNoMemory = TRUE;
                break;
            }
        }
        break;

    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_VARIANT:
        {
            //
            // avoid double delete of the source variant
            //

            parray = 0;

            SAFEARRAY * pSaDst = 0;

            if ( FAILED( SafeArrayCopy( var.parray, &pSaDst ) ) )
            {
                fNoMemory = TRUE;
                break;
            }

            parray = pSaDst;
        }
        break;

    default:
        {
            Win4Assert( !"Unexpected vt type" );
            return;
        }
    }
    if (fNoMemory || !IsValid())
    {
        ResetType(ma);

        // We cannot raise in a non-unwindable constructor.
        // Just return a PROPVARIANT guaranteed to look invalid.

        vt = VT_LPSTR;
        pszVal = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SaCreateAndCopy
//
//  Synopsis:   Creates a safearray & initializes it with source safearray.
//
//  Arguments:  [ma]       - memory allocator to use
//              [psaSrc]   - source safearry
//              [ppsaDst] - safearray to be created.
//
//  Returns:    TRUE    - upon success
//              FALSE   - upon failure
//
//  History:    5-10-97     mohamedn    created
//
//----------------------------------------------------------------------------

BOOL SaCreateAndCopy( PMemoryAllocator &ma,
                      SAFEARRAY * psaSrc,
                      SAFEARRAY **ppsaDst )
{
    ULONG cb  = sizeof SAFEARRAY + ( ( 0 != psaSrc->cDims ?
                (psaSrc->cDims-1) : 0) * sizeof SAFEARRAYBOUND );

    Win4Assert( psaSrc->cDims > 0);

    SAFEARRAY * psaDst = (SAFEARRAY *) ma.Allocate( cb );
    if ( 0 == psaDst )
    {
        *ppsaDst = 0;
        return FALSE;
    }

    RtlCopyMemory(psaDst, psaSrc, cb);

    // reset fields and values
    psaDst->fFeatures &= ~( FADF_AUTO | FADF_STATIC );
    psaDst->cLocks     = 1;        // new safearray has lockcount of 1
    psaDst->pvData     = 0;

    *ppsaDst = psaDst;

    return TRUE;
} //SaCreateAndCopy

//+---------------------------------------------------------------------------
//
//  Function:   SaCreateData
//
//  Synopsis:   Creates/initializes SafeArray's data area
//
//  Arguments:  [ma]       - memory allocator to use
//              [vt]       - variant type (VT_ARRAY assumed)
//              [saSrc]    - source safearry
//              [saDst]    - destination safearray.
//              [fUseAllocatorOnly] - if TRUE, BSTRs are allocated using [ma]
//
//  Returns:    TRUE    - upon success
//              FALSE   - upon failure
//
//  History:    5-10-97     mohamedn    created
//
//----------------------------------------------------------------------------

BOOL SaCreateData(
    PVarAllocator & ma,
    VARTYPE         vt,
    SAFEARRAY &     saSrc,
    SAFEARRAY &     saDst,
    BOOL            fUseAllocatorOnly )
{
    //
    // Find out how much memory is needed for the array and allocate it.
    //
    unsigned cDataElements = SaCountElements(saSrc);
    ULONG cb = cDataElements * saSrc.cbElements;
    void * pv = ma.Allocate( cb );

    if ( !pv )
        return FALSE;

    RtlZeroMemory( pv, cb );

    switch (vt)
    {
    case VT_I4:
    case VT_UI1:
    case VT_I2:
    case VT_R4:
    case VT_R8:
    case VT_BOOL:
    case VT_ERROR:
    case VT_CY:
    case VT_DATE:
    case VT_I1:
    case VT_UI2:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
        {
            RtlCopyMemory( pv, saSrc.pvData, cb);
            saDst.pvData = pv;
        }
        break;

    case VT_BSTR:
        {
            BSTR *pBstrSrc  = (BSTR *) saSrc.pvData;
            BSTR *pBstrDst = (BSTR *) pv;

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                Win4Assert( pBstrSrc[i]  != 0 );
                Win4Assert( pBstrDst[i] == 0 );

                if ( fUseAllocatorOnly )
                {
                    ULONG cbBstr = SysStringByteLen(pBstrSrc[i]) +
                                   sizeof (ULONG) +
                                   sizeof (WCHAR);
                    void * pv = ma.Allocate( cbBstr );
                    if ( 0 != pv )
                    {
                        BYTE * pbSrc = (BYTE *) pBstrSrc[i];
                        pbSrc -= sizeof ULONG;
                        RtlCopyMemory( pv, pbSrc, cbBstr);
                        pBstrDst[i] = (BSTR) ( (BYTE *) pv + sizeof ULONG );
                        pBstrDst[i] = (BSTR) ma.PointerToOffset( pBstrDst[i] );
                    }
                }
                else
                {
                    pBstrDst[i] = SysAllocString(pBstrSrc[i]);
                }

                if ( 0 == pBstrDst[i] )
                    return FALSE;
            }

            saDst.pvData = pv;
        }
        break;

    case VT_VARIANT:
        {
            CAllocStorageVariant *pVarntSrc = (CAllocStorageVariant *)saSrc.pvData;
            CAllocStorageVariant *pVarntDst = (CAllocStorageVariant *)pv;

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                Win4Assert( pVarntDst[i].vt == 0 );

                if ( VT_BSTR == pVarntSrc[i].vt )
                {
                    if ( fUseAllocatorOnly )
                    {
                        ULONG cbBstr = SysStringByteLen(pVarntSrc[i].bstrVal) +
                                       sizeof (ULONG) +
                                       sizeof (WCHAR);
                        void * pv = ma.Allocate( cbBstr );
                        if ( 0 != pv )
                        {
                            BYTE * pbSrc = (BYTE *) pVarntSrc[i].bstrVal;
                            pbSrc -= sizeof ULONG;
                            RtlCopyMemory( pv, pbSrc, cbBstr);
                            pVarntDst[i].bstrVal = (BSTR) ((BYTE *) pv + sizeof ULONG);
                            pVarntDst[i].bstrVal = (BSTR) ma.PointerToOffset( pVarntDst[i].bstrVal );
                        }
                    }
                    else
                    {
                        pVarntDst[i].bstrVal = SysAllocString(pVarntSrc[i].bstrVal);
                    }

                    if (  0 == pVarntDst[i].bstrVal )
                        return FALSE;

                    pVarntDst[i].vt = VT_BSTR;
                }
                else if ( 0 != (pVarntSrc[i].vt & VT_ARRAY) )
                {
                    SAFEARRAY * pSaSrc = pVarntSrc[i].parray;
                    SAFEARRAY * pSaDst = 0;

                    if ( !SaCreateAndCopy( ma, pSaSrc, &pSaDst ) )
                        return FALSE;

                    if ( !SaCreateData( ma,
                                        pVarntSrc[i].vt & ~VT_ARRAY,
                                        *pSaSrc,
                                        *pSaDst,
                                        fUseAllocatorOnly ) )
                        return FALSE;

                    pVarntDst[i].parray = (SAFEARRAY *) ma.PointerToOffset( pSaDst );
                    pVarntDst[i].vt = pVarntSrc[i].vt;
                }
                else
                {
                    Win4Assert( pVarntSrc[i].vt != VT_VARIANT );
                    Win4Assert( pVarntSrc[i].vt != VT_LPWSTR );
                    Win4Assert( pVarntSrc[i].vt != VT_LPSTR );
                    Win4Assert( pVarntSrc[i].vt != VT_CLSID );

                    pVarntDst[i] = pVarntSrc[i];
                }
            }

            saDst.pvData = pv;
        }
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unexpected SafeArray type: vt=%x\n", vt ) );
        Win4Assert( !"Unexpected SafeArray Type" );
        return FALSE;
    }

    saDst.pvData = (void *) ma.PointerToOffset( saDst.pvData );

    return TRUE;
} //SaCreateData

//+---------------------------------------------------------------------------
//
//  Function:   SaComputeSize
//
//  Synopsis:   Computes the size of a safearray.
//
//  Arguments:  [vt]       - variant type (VT_ARRAY assumed)
//              [saSrc]    - source safearry
//
//  Returns:    ULONG - number of bytes of memory needed to store safearray
//
//  History:    5-01-98     AlanW       Created
//
//----------------------------------------------------------------------------

ULONG SaComputeSize( VARTYPE vt,
                     SAFEARRAY & saSrc )
{
    //
    // get number of data elements in array and size of the header.
    //
    unsigned cDataElements = SaCountElements(saSrc);

    Win4Assert( 0 != saSrc.cDims );

    ULONG    cb = sizeof (SAFEARRAY) +
                  (saSrc.cDims-1) * sizeof (SAFEARRAYBOUND) +
                  cDataElements * saSrc.cbElements;

    cb = AlignBlock( cb, sizeof LONGLONG );

    switch (vt)
    {
    case VT_I4:
    case VT_UI1:
    case VT_I2:
    case VT_R4:
    case VT_R8:
    case VT_BOOL:
    case VT_ERROR:
    case VT_CY:
    case VT_DATE:
    case VT_I1:
    case VT_UI2:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
        break;

    case VT_BSTR:
        {
            BSTR *pBstrSrc  = (BSTR *) saSrc.pvData;

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                Win4Assert( pBstrSrc[i]  != 0 );

                cb += AlignBlock( SysStringByteLen(pBstrSrc[i]) +
                                  sizeof ULONG + sizeof WCHAR,
                                  sizeof LONGLONG );
            }
        }
        break;

    case VT_VARIANT:
        {
            CAllocStorageVariant *pVarnt = (CAllocStorageVariant *)saSrc.pvData;

            for ( unsigned i = 0; i < cDataElements; i++ )
            {
                if ( VT_BSTR == pVarnt[i].vt )
                {
                    cb += AlignBlock( SysStringByteLen(pVarnt[i].bstrVal) +
                                      sizeof ULONG + sizeof WCHAR,
                                      sizeof LONGLONG );
                }
                else if ( 0 != (pVarnt[i].vt & VT_ARRAY) )
                {
                    cb += AlignBlock( SaComputeSize( (pVarnt[i].vt & ~VT_ARRAY),
                                                     *pVarnt[i].parray),
                                      sizeof LONGLONG );
                }
                else
                {
                    Win4Assert( pVarnt[i].vt != VT_VARIANT );
                }
            }
        }
        break;

    default:
        ciDebugOut(( DEB_ERROR, "Unexpected SafeArray type: vt=%x\n", vt ) );
        Win4Assert( !"Unexpected SafeArray Type" );
        return 1;
    }

    return cb;
}



CAllocStorageVariant::~CAllocStorageVariant()
{
    switch (vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        break;

    default:
        ciDebugOut(( DEB_ERROR, "~CAllocStorageVariant -- Memory Leak: vt=%x\n", vt ) );
    }
}


void
CAllocStorageVariant::ResetType(PMemoryAllocator &ma)
{
    // The most typical case

    if ( VT_EMPTY == vt )
        return;

    ULONG i;

    if ((vt & VT_BYREF) == 0)
    {
        switch (vt)
        {
        case VT_EMPTY:
        case VT_NULL:
        case VT_I1:
        case VT_UI1:
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_ERROR:
        case VT_I8:
        case VT_UI8:
        case VT_R8:
        case VT_INT:
        case VT_UINT:
        case VT_DECIMAL:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            break;

        case VT_CLSID:
            ma.Free(puuid);
            break;

        case VT_BLOB:
        case VT_BLOB_OBJECT:
            ma.Free(blob.pBlobData);
            break;

        case VT_CF:
            if (pclipdata != NULL)
            {
                ma.Free(pclipdata->pClipData);
                ma.Free(pclipdata);
            }
            break;

        case VT_STREAM:
        case VT_VERSIONED_STREAM:
        case VT_STREAMED_OBJECT:
            pStream->Release();
            break;

        case VT_STORAGE:
        case VT_STORED_OBJECT:
            pStorage->Release();
            break;

        case VT_BSTR:
            SysFreeString(bstrVal);
            break;

        case VT_LPSTR:
        case VT_LPWSTR:
            AssertStringField(pszVal);              // VT_LPSTR
            AssertStringField(pwszVal);             // VT_LPWSTR
            ma.Free(pwszVal);
            break;

        case VT_VECTOR | VT_I1:
        case VT_VECTOR | VT_UI1:
        case VT_VECTOR | VT_I2:
        case VT_VECTOR | VT_UI2:
        case VT_VECTOR | VT_BOOL:
        case VT_VECTOR | VT_I4:
        case VT_VECTOR | VT_UI4:
        case VT_VECTOR | VT_R4:
        case VT_VECTOR | VT_ERROR:
        case VT_VECTOR | VT_I8:
        case VT_VECTOR | VT_UI8:
        case VT_VECTOR | VT_R8:
        case VT_VECTOR | VT_CY:
        case VT_VECTOR | VT_DATE:
        case VT_VECTOR | VT_FILETIME:
        case VT_VECTOR | VT_CLSID:
            AssertByteVector(cac);                  // VT_I1
            AssertByteVector(caub);                 // VT_UI1
            AssertShortVector(cai);                 // VT_I2
            AssertShortVector(caui);                // VT_UI2
            AssertShortVector(cabool);              // VT_BOOL
            AssertLongVector(cal);                  // VT_I4
            AssertLongVector(caul);                 // VT_UI4
            AssertLongVector(caflt);                // VT_R4
            AssertLongVector(cascode);              // VT_ERROR
            AssertLongLongVector(cah);              // VT_I8
            AssertLongLongVector(cauh);             // VT_UI8
            AssertLongLongVector(cadbl);            // VT_R8
            AssertLongLongVector(cacy);             // VT_CY
            AssertLongLongVector(cadate);           // VT_DATE
            AssertLongLongVector(cafiletime);       // VT_FILETIME
            AssertVarVector(cauuid, sizeof(GUID));  // VT_CLSID
            ma.Free(cal.pElems);
            break;

        case VT_VECTOR | VT_CF:
            if (caclipdata.pElems != NULL)
            {
                for (i = 0; i < caclipdata.cElems; i++)
                {
                    ma.Free(caclipdata.pElems[i].pClipData);
                }
                ma.Free(caclipdata.pElems);
            }
            break;


        case VT_VECTOR | VT_LPSTR:
        case VT_VECTOR | VT_LPWSTR:
            AssertStringVector(calpwstr);                   // VT_LPWSTR
            AssertStringVector(calpstr);                    // VT_LPSTR
            if (calpwstr.pElems != NULL)
            {
                for (i = 0; i < calpwstr.cElems; i++)
                {
                    if (calpstr.pElems[i] != NULL)  // don't free (NULL - cbbstr)
                    {
                        ma.Free((BYTE *) calpstr.pElems[i] );
                    }
                }
                ma.Free(calpwstr.pElems);
            }
            break;

        case VT_VECTOR | VT_BSTR:

            AssertStringVector(cabstr);                     // VT_BSTR

            if (cabstr.pElems != NULL )
            {
                for (i = 0; i < cabstr.cElems; i++)
                {
                     SysFreeString(cabstr.pElems[i]);
                }
                ma.Free(cabstr.pElems);
            }
            break;

        case VT_VECTOR | VT_VARIANT:
            if (capropvar.pElems != NULL)
            {
                for (i = 0; i < calpstr.cElems; i++)
                {
                    ((CAllocStorageVariant *) &capropvar.pElems[i])->ResetType(ma);
                }
                ma.Free(capropvar.pElems);
            }
            break;

        case VT_ARRAY | VT_I4:
        case VT_ARRAY | VT_UI1:
        case VT_ARRAY | VT_I2:
        case VT_ARRAY | VT_R4:
        case VT_ARRAY | VT_R8:
        case VT_ARRAY | VT_BOOL:
        case VT_ARRAY | VT_ERROR:
        case VT_ARRAY | VT_CY:
        case VT_ARRAY | VT_DATE:
        case VT_ARRAY | VT_I1:
        case VT_ARRAY | VT_UI2:
        case VT_ARRAY | VT_UI4:
        case VT_ARRAY | VT_INT:
        case VT_ARRAY | VT_UINT:
        case VT_ARRAY | VT_DECIMAL:
        case VT_ARRAY | VT_BSTR:
        case VT_ARRAY | VT_VARIANT:
            {
                //
                // What should we do if the array is locked?
                // Perhaps just set cLocks to 0 so it can be freed.
                // Note that we never hit the assert below because
                // we deal with SafeArrays under our control so we
                // know they won't be locked.
                //

                if ( 0 != parray )
                {
                    Win4Assert( 0 == parray->cLocks );
                    HRESULT hr = SafeArrayDestroy( parray );
                    Win4Assert( S_OK == hr );
                }
                break;
            }

        default:
                Win4Assert( !" Unexpected VT type" );
        }
    }

    vt = VT_EMPTY;
}


// Invalid variants have a pointer type but a NULL pointer.
// Some are valid in this form in general, but not for many uses.

BOOL
CAllocStorageVariant::IsValid() const
{
    ULONG i;

    if ((VT_VECTOR & vt) && cal.cElems != 0 && cal.pElems == NULL)
    {
        return(FALSE);
    }
    switch (vt)
    {
        case VT_EMPTY:
        case VT_NULL:
        case VT_I1:
        case VT_UI1:
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_ERROR:
        case VT_I8:
        case VT_UI8:
        case VT_INT:
        case VT_UINT:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            break;

        case VT_DECIMAL:
            return ( 0 == decVal.sign || DECIMAL_NEG == decVal.sign );

        case VT_CLSID:
            return(puuid != NULL);

        case VT_BLOB:
        case VT_BLOB_OBJECT:
            return(blob.cbSize == 0 || blob.pBlobData != NULL);

        case VT_CF:
            return(pclipdata != NULL && pclipdata->pClipData != NULL);

        case VT_STREAM:
        case VT_VERSIONED_STREAM:
        case VT_STREAMED_OBJECT:
            return(pStream != NULL);

        case VT_STORAGE:
        case VT_STORED_OBJECT:
            return(pStorage != NULL);

        case VT_BSTR:
        case VT_LPSTR:
        case VT_LPWSTR:
            AssertStringField(bstrVal);         // VT_BSTR
            AssertStringField(pszVal);          // VT_LPSTR
            AssertStringField(pwszVal);         // VT_LPWSTR
            return(pszVal != NULL);

        case VT_VECTOR | VT_I1:
        case VT_VECTOR | VT_UI1:
        case VT_VECTOR | VT_I2:
        case VT_VECTOR | VT_UI2:
        case VT_VECTOR | VT_BOOL:
        case VT_VECTOR | VT_I4:
        case VT_VECTOR | VT_UI4:
        case VT_VECTOR | VT_R4:
        case VT_VECTOR | VT_ERROR:
        case VT_VECTOR | VT_I8:
        case VT_VECTOR | VT_UI8:
        case VT_VECTOR | VT_R8:
        case VT_VECTOR | VT_CY:
        case VT_VECTOR | VT_DATE:
        case VT_VECTOR | VT_FILETIME:
        case VT_VECTOR | VT_CLSID:
            AssertByteVector(cac);              // VT_I1
            AssertByteVector(caub);             // VT_UI1
            AssertShortVector(cai);             // VT_I2
            AssertShortVector(caui);            // VT_UI2
            AssertShortVector(cabool);          // VT_BOOL
            AssertLongVector(cal);              // VT_I4
            AssertLongVector(caul);             // VT_UI4
            AssertLongVector(caflt);            // VT_R4
            AssertLongVector(cascode);          // VT_ERROR
            AssertLongLongVector(cah);          // VT_I8
            AssertLongLongVector(cauh);         // VT_UI8
            AssertLongLongVector(cadbl);        // VT_R8
            AssertLongLongVector(cacy);         // VT_CY
            AssertLongLongVector(cadate);       // VT_DATE
            AssertLongLongVector(cafiletime);   // VT_FILETIME
            AssertVarVector(cauuid, sizeof(GUID)); // VT_CLSID
            break;

        case VT_VECTOR | VT_CF:
            for (i = 0; i < caclipdata.cElems; i++)
            {
                if (caclipdata.pElems[i].pClipData == NULL)
                {
                    return(FALSE);
                }
            }

        case VT_VECTOR | VT_BSTR:
        case VT_VECTOR | VT_LPSTR:
        case VT_VECTOR | VT_LPWSTR:
            AssertStringVector(calpwstr);               // VT_LPWSTR
            AssertStringVector(cabstr);                 // VT_BSTR
            AssertStringVector(calpstr);                // VT_LPSTR
            for (i = 0; i < calpstr.cElems; i++)
            {
                if (calpstr.pElems[i] == NULL)
                {
                    return(FALSE);
                }
            }
            break;

        case VT_VECTOR | VT_VARIANT:
            for (i = 0; i < capropvar.cElems; i++)
            {
                if (!((CAllocStorageVariant *) &capropvar.pElems[i])->IsValid())
                {
                    return(FALSE);
                }
            }
            break;

        case VT_ARRAY | VT_I4:
        case VT_ARRAY | VT_UI1:
        case VT_ARRAY | VT_I2:
        case VT_ARRAY | VT_R4:
        case VT_ARRAY | VT_R8:
        case VT_ARRAY | VT_BOOL:
        case VT_ARRAY | VT_ERROR:
        case VT_ARRAY | VT_CY:
        case VT_ARRAY | VT_DATE:
        case VT_ARRAY | VT_I1:
        case VT_ARRAY | VT_UI2:
        case VT_ARRAY | VT_UI4:
        case VT_ARRAY | VT_INT:
        case VT_ARRAY | VT_UINT:
        case VT_ARRAY | VT_BSTR:
        case VT_ARRAY | VT_DECIMAL:
        case VT_ARRAY | VT_VARIANT:
             {
                SAFEARRAY *pSa = parray;

                if ( 0 == pSa )
                    return FALSE;

                if ( !(pSa->cDims && pSa->pvData) )
                    return FALSE;

                // validate all the bstrs are allocated

                if ( ( VT_BSTR | VT_ARRAY ) == vt )
                {
                    unsigned cDataElements = SaCountElements(*pSa);
                    BSTR *pBstr = (BSTR *)pSa->pvData;

                    for ( i = 0; i < cDataElements; i++ )
                        if ( 0 == pBstr[i] )
                            return FALSE;
                }
                if ( ( VT_VARIANT | VT_ARRAY ) == vt )
                {
                    unsigned cDataElements = SaCountElements(*pSa);
                    CAllocStorageVariant *pVarnt = (CAllocStorageVariant *)pSa->pvData;

                    for ( i = 0; i < cDataElements; i++ )
                        if ( ! pVarnt[i].IsValid() )
                            return FALSE;
                }
             }
             break;

        case VT_BYREF | VT_I2:
        case VT_BYREF | VT_I4:
        case VT_BYREF | VT_R4:
        case VT_BYREF | VT_R8:
        case VT_BYREF | VT_CY:
        case VT_BYREF | VT_DATE:
        case VT_BYREF | VT_ERROR:
        case VT_BYREF | VT_BOOL:
        case VT_BYREF | VT_I1:
        case VT_BYREF | VT_UI1:
        case VT_BYREF | VT_UI2:
        case VT_BYREF | VT_UI4:
        case VT_BYREF | VT_INT:
        case VT_BYREF | VT_UINT:
            return (piVal != 0);

        case VT_BYREF | VT_BSTR:
            return ( pbstrVal != 0 && *pbstrVal != 0 );

        case VT_BYREF | VT_DECIMAL:
            return ( pdecVal != 0 &&
                     ( 0 == pdecVal->sign || DECIMAL_NEG == pdecVal->sign ) );

        case VT_BYREF | VT_VARIANT:
            return ( pvarVal != 0 && pvarVal->vt != (VT_BYREF|VT_VARIANT) &&
                    ((CAllocStorageVariant*)pvarVal)->IsValid() );

        default:
            ASSERT(!"CAllocStorageVariant::IsValid -- Invalid variant type");
            return FALSE;
    }
    return TRUE;
}


CAllocStorageVariant::CAllocStorageVariant(
    PDeSerStream& stm,
    PMemoryAllocator &ma)
{
    Unmarshall(stm, *((PROPVARIANT *)this), ma);
}


#define VECTOR_SET_BODY(type, vtype, val, aval)                               \
                                                                              \
void CAllocStorageVariant::Set##vtype(                                        \
    type val,                                                                 \
    unsigned pos,                                                             \
    PMemoryAllocator &ma)                                                     \
{                                                                             \
    if (vt != ( VT_##vtype | VT_VECTOR ) )                                    \
    {                                                                         \
        ResetType(ma);                                                        \
        new (this) CAllocStorageVariant(VT_##vtype, pos, ma);                 \
    }                                                                         \
                                                                              \
    if (pos >= cai.cElems)                                                    \
    {                                                                         \
        type *pTemp = aval.pElems;                                            \
        aval.pElems = (type *) ma.Allocate( (pos+1) * sizeof(aval.pElems[0]));\
        if (aval.pElems != NULL)                                              \
        {                                                                     \
            memcpy(aval.pElems, pTemp, aval.cElems * sizeof(aval.pElems[0])); \
            memset(                                                           \
                &aval.pElems[aval.cElems],                                    \
                0,                                                            \
                (( pos+1 ) - aval.cElems) * sizeof(aval.pElems[0]));          \
            aval.pElems[pos] = val;                                           \
            aval.cElems = pos+1;                                              \
            ma.Free(pTemp);                                                   \
        }                                                                     \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        aval.pElems[pos] = val;                                               \
    }                                                                         \
}


#define VECTOR_GET_BODY(type, vtype, aval, nullval)              \
                                                                 \
type CAllocStorageVariant::Get##vtype(unsigned pos) const        \
{                                                                \
    if (vt == (VT_##vtype | VT_VECTOR) && pos < aval.cElems)     \
    {                                                            \
        return(aval.pElems[pos]);                                \
    }                                                            \
    return(nullval);                                             \
}


VECTOR_SET_BODY(CHAR, I1, i, cac)
VECTOR_GET_BODY(CHAR, I1, cac, 0)

VECTOR_SET_BODY(BYTE, UI1, ui, caub)
VECTOR_GET_BODY(BYTE, UI1, caub, 0)

VECTOR_SET_BODY(short, I2, i, cai)
VECTOR_GET_BODY(short, I2, cai, 0)

VECTOR_SET_BODY(USHORT, UI2, ui, caui)
VECTOR_GET_BODY(USHORT, UI2, caui, 0)

VECTOR_SET_BODY(long, I4, l, cal)
VECTOR_GET_BODY(long, I4, cal, 0)

VECTOR_SET_BODY(ULONG, UI4, ul, caul)
VECTOR_GET_BODY(ULONG, UI4, caul, 0)

VECTOR_SET_BODY(SCODE, ERROR, scode, cascode)
VECTOR_GET_BODY(SCODE, ERROR, cascode, 0)

static LARGE_INTEGER const liZero = { 0, 0 };
VECTOR_SET_BODY(LARGE_INTEGER, I8, li, cah)
VECTOR_GET_BODY(LARGE_INTEGER, I8, cah, liZero)

static ULARGE_INTEGER const uliZero = { 0, 0 };
VECTOR_SET_BODY(ULARGE_INTEGER, UI8, uli, cauh)
VECTOR_GET_BODY(ULARGE_INTEGER, UI8, cauh, uliZero)

VECTOR_SET_BODY(float, R4, f, caflt)
VECTOR_GET_BODY(float, R4, caflt, (float)0.0)

VECTOR_SET_BODY(double, R8, d, cadbl)
VECTOR_GET_BODY(double, R8, cadbl, 0.0)

VECTOR_SET_BODY(VARIANT_BOOL, BOOL, b, cabool)
VECTOR_GET_BODY(VARIANT_BOOL, BOOL, cabool, FALSE)

static CY const cyZero = { 0, 0 };
VECTOR_SET_BODY(CY, CY, cy, cacy)
VECTOR_GET_BODY(CY, CY, cacy, cyZero)

VECTOR_SET_BODY(DATE, DATE, d, cadate)
VECTOR_GET_BODY(DATE, DATE, cadate, 0.0)


BOOLEAN
CAllocStorageVariant::_AddStringToVector(
    unsigned pos,
    VOID *pv,
    ULONG cb,
    PMemoryAllocator &ma)
{
    ASSERT(vt == (VT_VECTOR | VT_BSTR) ||
           vt == (VT_VECTOR | VT_LPSTR) ||
           vt == (VT_VECTOR | VT_LPWSTR));
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) ma.Allocate((pos + 1) * sizeof(calpstr.pElems[0]));
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(FALSE);
        }
        memcpy(calpstr.pElems, ppsz, calpstr.cElems * sizeof(calpstr.pElems[0]));
        memset(
            &calpstr.pElems[calpstr.cElems],
            0,
            ((pos + 1) - calpstr.cElems) * sizeof(calpstr.pElems[0]));
        calpstr.cElems = pos + 1;
        ma.Free(ppsz);
    }

    if ( vt == (VT_VECTOR|VT_BSTR) )
    {
        BSTR bstrVal = SysAllocString( (OLECHAR *)pv );

        if (bstrVal == NULL)
        {
            return (FALSE);
        }

        if ( cabstr.pElems[pos] != NULL )
        {
            SysFreeString(cabstr.pElems[pos]);
        }

        cabstr.pElems[pos] = bstrVal;
    }
    else
    {
        char *psz = (char *) ma.Allocate(cb);

        if (psz == NULL)
        {
            return(FALSE);
        }

        memcpy(psz, pv, cb);

        if (calpstr.pElems[pos] != NULL)
        {
            ma.Free(calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }

    return(TRUE);
}

void
CAllocStorageVariant::SetBSTR(BSTR b, PMemoryAllocator &ma)
{
    ResetType(ma);
    vt = VT_BSTR;

    bstrVal = SysAllocString(b);
}


void
CAllocStorageVariant::SetBSTR(
    BSTR b,
    unsigned pos,
    PMemoryAllocator &ma)
{
    if (vt != (VT_VECTOR | VT_BSTR))
    {
        ResetType(ma);
        new (this) CAllocStorageVariant(VT_BSTR, pos, ma);
    }

    _AddStringToVector(
                pos,
                b,
                -1,    // not used, pass an invalid value to detect failure.
                ma);
}


void
CAllocStorageVariant::SetLPSTR(
    char const *psz,
    unsigned pos,
    PMemoryAllocator &ma)
{
    if (vt != (VT_VECTOR | VT_LPSTR))
    {
        ResetType(ma);
        new (this) CAllocStorageVariant(VT_LPSTR, pos, ma);
    }
    _AddStringToVector(pos, (VOID *) psz, strlen(psz) + 1, ma);
}


void
CAllocStorageVariant::SetLPWSTR(
    WCHAR const *pwsz,
    unsigned pos,
    PMemoryAllocator &ma)
{
    if (vt != (VT_VECTOR | VT_LPWSTR))
    {
        ResetType(ma);
        new (this) CAllocStorageVariant(VT_LPWSTR, pos, ma);
    }
    _AddStringToVector(
                pos,
                (VOID *) pwsz,
                (wcslen(pwsz) + 1) * sizeof(WCHAR),
                ma);
}


VECTOR_GET_BODY(char *, LPSTR, calpstr, 0);
VECTOR_GET_BODY(WCHAR *, LPWSTR, calpwstr, 0);

static FILETIME const fiZero = { 0, 0 };
VECTOR_SET_BODY(FILETIME, FILETIME, ft, cafiletime)
VECTOR_GET_BODY(FILETIME, FILETIME, cafiletime, fiZero)

static CLSID const guidZero =
{
    0x00000000,
    0x0000,
    0x0000,
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
};

VECTOR_SET_BODY(CLSID, CLSID, c, cauuid)
VECTOR_GET_BODY(CLSID, CLSID, cauuid, guidZero)
#endif //ifndef _NTDLLBUILD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\setupqry\cimbmgr_stub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include "cimbmgr.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\setupqry\isreg_stub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include "isreg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sdk\genlib\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF

NTQUERYDEF = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\ntquery.def

NTQUERYLIB = $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\ntquery.lib

$(NTQUERYDEF): ntquery.def ..\..\query\query.org

$(NTQUERYLIB): $(NTQUERYDEF)
   -lib -out:$(NTQUERYLIB) $(LIBRARIAN_FLAGS) -def:$(NTQUERYDEF) $(UMLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\setupqry\catcnfg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       CatCnfg.cxx
//
//  Contents:   Support for adding catalogs during setup.
//
//  History:    13-May-1998   KyleP   Added copyright
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <ciregkey.hxx>
#include "catcnfg.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::CCatalogConfig
//
//  Synopsis:   Constructor
//
//  History:    9-10-97  mohamedn
//
//--------------------------------------------------------------------------

CCatalogConfig::CCatalogConfig(CError & Err) :
    _Err( Err ),
    _cDrive( 0 ),
    _pwszCatalogDrive( 0 ),
    _cIncludedScopes( 0 ), _xaIncludedScopes( 10 ),
    _cExcludedScopes( 0 ), _xaExcludedScopes( 10 )
{
    RtlZeroMemory( _DriveList, sizeof _DriveList );
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::InitDriveList, public
//
//  Synopsis:   Initialize drive list with local drive names, types, and
//              available/free space.
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS upon sucess,
//              none zero upon failure.
//
//  History:    6-27-97     mohamedn  created
//              9/10/97     mohamedn  rewritten catalog configuration
//
//--------------------------------------------------------------------------

BOOL CCatalogConfig::InitDriveList()
{
    // 26 drive letters * 4 characters per drive + terminating NULL.
    const DWORD dwSize = MAX_DRIVES * CHARS_PER_DRIVE + 1;
    WCHAR       wszListOfAllDrives[ dwSize ];
    unsigned    iDriveNumber   = 0;
    DWORD       dwRetVal       = 0;

    RtlZeroMemory( wszListOfAllDrives, sizeof wszListOfAllDrives );

    dwRetVal = GetLogicalDriveStrings(dwSize, wszListOfAllDrives);
    if ( dwRetVal == 0 ||  dwRetVal > dwSize )
    {
        DWORD dwErr = GetLastError();
        isDebugOut(( "GetLogicalDriveStrings Failed: dwRetVal: %d, GetLastError(): %d\n",
                     dwRetVal, dwErr ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dwErr );

        return FALSE;
    }

    for ( WCHAR *pwszTmp = wszListOfAllDrives;
          *pwszTmp;
          pwszTmp += CHARS_PER_DRIVE )
    {
        switch (GetDriveType(pwszTmp))
        {
        case DRIVE_FIXED:         // The disk cannot be removed from the drive.
            break;

        default:
            isDebugOut(( "InitDriveList: Unexpected drive type %d\n",
                         GetDriveType(pwszTmp) ));

        case 0:                 // The drive type cannot be determined.
        case 1:                 // The root directory does not exist.
        case DRIVE_REMOVABLE:   // The media can be removed from the drive.
        case DRIVE_REMOTE:      // The drive is a remote (network) drive.
        case DRIVE_CDROM:       // drive is a CD-ROM drive.
        case DRIVE_RAMDISK:     // The drive is a RAM disk.
            continue;
        }

        _DriveList[iDriveNumber].SetDriveName(pwszTmp);

        if ( ! _DriveList[iDriveNumber].SetDriveInfo( ) )
        {
            continue;
        }
        else
        {
            iDriveNumber++;
        }
    }

    _cDrive = iDriveNumber;

    ReservePageFileData();

    return ( _cDrive > 0 ? TRUE : FALSE );
}


//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::ReservePageFileData, private
//
//  Synopsis:   Reserve unallocated space for page files.
//
//  Arguments:  none
//
//  Returns:    TRUE upon sucess, FALSE upon failure.
//
//  History:    26 Oct 1998    AlanwW    Created
//
//--------------------------------------------------------------------------

const WCHAR wszPagingFileKey[] =
    L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management";
const WCHAR wszPagingFileValueName[] = L"PagingFiles";

BOOL CCatalogConfig::ReservePageFileData()
{
    WCHAR awcPagingFiles[2000];
    awcPagingFiles[0] = L'\0';

    //
    //  Get the original page file info from
    //  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessonManager
    //
    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wszPagingFileKey );

    if ( ! reg.Get( wszPagingFileValueName,
                    awcPagingFiles,
                    sizeof awcPagingFiles/sizeof awcPagingFiles[0] ) )
        return FALSE;

    //
    // Iterate through all paging files, reserve any difference between
    // the max size and currently allocated size.
    //
    WCHAR * pwsz = &awcPagingFiles[0];
    while ( *pwsz )
    {
        WCHAR *pwszPageFile = pwsz;
        pwsz = wcschr(pwsz, L' ');
        if ( ! pwsz )
            break;

        *pwsz++ = L'\0';
        ULONG ulMinAlloc = _wtoi( pwsz );

        WCHAR *pwsz2 = wcschr(pwsz, L' ');

        ULONG ulMaxAlloc = ulMinAlloc + MAXOVERMINFACTOR;
        if ( pwsz2 )
            ulMaxAlloc = _wtoi( pwsz2 );

        while ( *pwsz )
            pwsz++;
        pwsz++;

        CDriveInformation * pDriveInfo = GetDriveInfo( pwszPageFile );
        if ( !pDriveInfo )
            continue;

        //
        //  For some reason, GetFileAttributesEx will get a sharing violation
        //  on an open paging file.  FindFirstFile will work to get the very
        //  same information.
        //
        HANDLE hFind;
        WIN32_FIND_DATA FindData;

        if ( (hFind = FindFirstFile(pwszPageFile, &FindData)) ==
             INVALID_HANDLE_VALUE )
        {
            isDebugOut(( "ReservePageFileData: FindFirstFile %ws failed: %x\n",
                         pwszPageFile,
                         GetLastError() ));
            continue;
        }
        FindClose(hFind);

        ULARGE_INTEGER ullFileSize;
        ullFileSize.LowPart =  FindData.nFileSizeLow;
        ullFileSize.HighPart = FindData.nFileSizeHigh;

        pDriveInfo->ReservePagingData( ulMaxAlloc * ONE_MB,
                                       ullFileSize.QuadPart );
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDriveInformation::GetDriveInfo, public
//
//  Synopsis:   Returns pointer to drive information structure.
//
//  Arguments:  [pwszPath] - path name to be looked up
//
//  Returns:    CDriveInformation* - pointer to drive information; 0 if not found
//
//  History:    29 Oct 1998     AlanW     Created
//
//--------------------------------------------------------------------------

CDriveInformation * CCatalogConfig::GetDriveInfo(WCHAR const * pwszPath)
{
    WCHAR       wcDriveLetter = (WCHAR)toupper( *pwszPath );

    for (unsigned i = 0; i < _cDrive; i++ )
    {
        if (toupper( _DriveList[i].GetDriveLetter() ) == wcDriveLetter )
            return &_DriveList[i];
    }

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDriveInformation::SetDriveInfo, public
//
//  Synopsis:   Obtains drive info
//
//  Arguments:  [none]
//
//  Returns:    TRUE upon success, False upon failure.
//
//  History:    6-27-97        mohamedn  created
//              26 Oct 1998    AlanwW    Enhanced and made a CDriveInfo method.
//
//--------------------------------------------------------------------------

static WCHAR pwszBootFile1[] = L"x:\\NTLDR";                      // x86
static WCHAR pwszBootFile2[] = L"x:\\OS\\WINNT50\\OSLOADER.EXE";  // risc

static WCHAR * apwszBootFiles[] = {
    pwszBootFile1,
    pwszBootFile2,
};


BOOL CDriveInformation::SetDriveInfo()
{
    Win4Assert( 0 != GetDriveLetter() );
    _cbFreeSpace = _cbTotalSpace = _cbReservedSpace = 0;

    ULARGE_INTEGER  cbFreeBytesToCaller;
    ULARGE_INTEGER  cbTotalNumberOfBytes;
    ULARGE_INTEGER  cbTotalNumberOfFreeBytes;

    cbFreeBytesToCaller.QuadPart        = 0;
    cbTotalNumberOfBytes.QuadPart       = 0;
    cbTotalNumberOfFreeBytes.QuadPart   = 0;

    //
    // returns 0 upon failure, none-zero upon success.
    //
    BOOL fSuccess = GetDiskFreeSpaceEx( _wszDriveName,
                                        &cbFreeBytesToCaller,
                                        &cbTotalNumberOfBytes,
                                        &cbTotalNumberOfFreeBytes );
    if (!fSuccess)
    {
         isDebugOut(( "SetDriveInfo: GetDiskFreeSapceEx %ws failed: %x\n",
                      _wszDriveName,
                      GetLastError() ));
         return fSuccess;
    }

    _cbFreeSpace= cbTotalNumberOfFreeBytes.QuadPart;
    _cbTotalSpace= cbTotalNumberOfBytes.QuadPart;

    //
    // Determine if the volume supports security (i.e., if it's NTFS)
    //
    fSuccess = GetVolumeInformationW( _wszDriveName,
                                      0, 0,           // volume name
                                      0,              // volume serial number
                                      0,              // max filename length
                                      &_dwFileSystemFlags,
                                      0, 0 );         // file system name

    if (!fSuccess)
    {
         isDebugOut(( "SetDriveInfo: GetFileSystemInfo failed: %x\n",GetLastError() ));
         return fSuccess;
    }

    for (unsigned i=0; i < NUMELEM( apwszBootFiles ); i++)
    {
        if (Exists(apwszBootFiles[i]))
        {
            _fIsBootDrive = TRUE;
            break;
        }
    }

    return fSuccess;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDriveInformation::Exists, public
//
//  Synopsis:   Determines if a file or directory exists
//
//  Arguments:  [pwszPath]   - path name of the file to check
//
//  Notes:      The [pwszPath] must be a full path name starting with a
//              drive letter.  The drive letter is overwritten by this
//              method.
//
//  Returns:    TRUE if the file exists, FALSE upon failure or non-existance.
//
//  History:    26 Oct 1998     AlanW     Created
//
//--------------------------------------------------------------------------

BOOL CDriveInformation::Exists(WCHAR * pwszPath)
{
    *pwszPath = GetDriveLetter();

    DWORD attr = GetFileAttributes( pwszPath );

    // If we couldn't determine file's attributes, don't consider it found
    // unless the error code indirectly indicates that it exists.

    if ( 0xffffffff == attr )
    {
        isDebugOut(( DEB_TRACE, "Exists: GetFileAttributes( %ws ) Failed: %d\n",
                      pwszPath, GetLastError() ));

        if (GetLastError() == ERROR_SHARING_VIOLATION)
            return TRUE;        // It must exist

        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::ConfigureDefaultCatalog
//
//  Synopsis:   Creates a single default catalog if sufficient disk space
//              exists on one drive.
//
//  Arguments:  [wszPrimaryScope] -- Path name of primary indexed directory
//
//  Returns:    TRUE upon success, FALSE upon Failure,
//
//  History:    9-10-97  mohamedn
//
//--------------------------------------------------------------------------

static WCHAR wszUpgradeDir[] = L"x:\\$WIN_NT$.~LS";

BOOL CCatalogConfig::ConfigureDefaultCatalog(
    WCHAR const * pwszPrimaryScope )
{
    {
        //
        // Reserve space for a net upgrade of the OS if we're not currently
        // doing one (in which case the space for it will already be in use).
        // Because we will preferably use an NTFS drive for the catalog, try
        // using a FAT drive for the upgrade files.
        //
        int       iUpgradeFiles = -1;
        int       iBestFitForUpgrade = -1;
        ULONGLONG cbBestFitForUpgrade = 0;
        BOOL      fBestFitOnNtfs = FALSE;

        for ( unsigned i = 0 ; i < _cDrive; i++ )
        {
            if ( iUpgradeFiles == -1 && _DriveList[i].Exists( wszUpgradeDir ) )
            {
                iUpgradeFiles = i;
                break;
            }

            ULONGLONG cbAvail = _DriveList[i].GetAvailableSpace();
            if ( cbAvail < MIN_UPGRADE_SPACE )
                continue;

            if ( iBestFitForUpgrade == -1 ||
                 ( cbAvail < cbBestFitForUpgrade && fBestFitOnNtfs ) ||
                 ( ! _DriveList[i].IsNtfs() && fBestFitOnNtfs ) )
            {
                cbBestFitForUpgrade = cbAvail;
                iBestFitForUpgrade = i;
                fBestFitOnNtfs = _DriveList[i].IsNtfs();
            }
        }
        if ( iUpgradeFiles == -1 && iBestFitForUpgrade != -1 )
            _DriveList[iBestFitForUpgrade].AddReservedSpace( MIN_UPGRADE_SPACE );
        else  if ( iUpgradeFiles == -1 )
        {
            isDebugOut(( DEB_TRACE, "Not enough room for net upgrade!\n" ));
            return FALSE;
        }
    }

    //
    //  Determine which drive to put the catalog on.
    //
    int          iBiggestFreeNTFS = -1;
    int          iBiggestFreeFAT  = -1;
    ULONGLONG    cbMaxFreeSpaceOnNTFS = 0;
    ULONGLONG    cbMaxFreeSpaceOnFAT  = 0;

    for ( unsigned i = 0 ; i < _cDrive; i++ )
    {
        if ( _DriveList[i].IsSmallBootPartition() )
            continue;

        int *       piBiggestFree = &iBiggestFreeFAT;
        ULONGLONG * pcbMaxFree = &cbMaxFreeSpaceOnFAT;
        if ( _DriveList[i].IsNtfs() )
        {
            piBiggestFree = &iBiggestFreeNTFS;
            pcbMaxFree = &cbMaxFreeSpaceOnNTFS;
        }

        if ( *pcbMaxFree < _DriveList[i].GetAvailableSpace() )
        {
            *pcbMaxFree = _DriveList[i].GetAvailableSpace();
            *piBiggestFree = i;
        }
    }


    BOOL fAddNtfsDrives = FALSE;
    CDriveInformation * pCatalogDrive = 0;
    double dblCatalogSizeRatio;

    if ( iBiggestFreeNTFS != -1 )
    {
        //
        // There is an NTFS drive on the system; need to put the catalog
        // there.
        //

        pCatalogDrive = &_DriveList[iBiggestFreeNTFS];
        dblCatalogSizeRatio = CATALOG_SIZE_RATIO_NTFS;
        fAddNtfsDrives = TRUE;
    }
    else if ( iBiggestFreeFAT != -1 )
    {
        pCatalogDrive = &_DriveList[iBiggestFreeFAT];
        dblCatalogSizeRatio = CATALOG_SIZE_RATIO_FAT;
        fAddNtfsDrives = FALSE;
    }

    if ( 0 == pCatalogDrive ||
         pCatalogDrive->GetAvailableSpace() < MIN_CATALOG_SPACE )
    {
        isDebugOut(( DEB_TRACE, "Not enough room for minimal catalog!\n" ));
        return FALSE;
    }

    _pwszCatalogDrive = pCatalogDrive->GetDriveName();
    pCatalogDrive->AddReservedSpace( MIN_CATALOG_SPACE );

    //  Add the primary scope directory for the catalog.
    if ( pwszPrimaryScope && *pwszPrimaryScope )
        AddIncludedDir( pwszPrimaryScope );

    //
    // Iterate through the list of drives once or twice, depending on
    // whether all drives are FAT.
    //
    unsigned maxLoop = _cDrive * ( (fAddNtfsDrives == TRUE) + 1);
    for ( i = 0 ; i < maxLoop; i++ )
    {
        // If end of NTFS enumeration, go back around the loop for FAT drives.
        if (i == _cDrive)
            fAddNtfsDrives = FALSE;

        CDriveInformation & DriveToCheck = _DriveList[i % _cDrive];

        if ( DriveToCheck.IsSmallBootPartition() )
            continue;

        if ( DriveToCheck.IsNtfs() != fAddNtfsDrives )
            continue;

        ULONGLONG cbUsed = DriveToCheck.GetUsedSpace();

        cbUsed = (ULONGLONG) ((LONGLONG)cbUsed * dblCatalogSizeRatio);
        if ( cbUsed < pCatalogDrive->GetAvailableSpace() )
        {
            AddIncludedDir( DriveToCheck.GetDriveName() );
            pCatalogDrive->AddReservedSpace( cbUsed );
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::SaveState
//
//  Synopsis:   Saves the state of the catalog configuration in the registry.
//
//  Arguments:  - NONE -
//
//  Returns:    TRUE upon success, FALSE upon Failure,
//
//  History:    19 Nov 1998   AlanW   Created
//
//--------------------------------------------------------------------------

BOOL CCatalogConfig::SaveState( )
{
    Win4Assert( 0 != GetName() && 0 != GetLocation() );

    CCatReg  catReg(_Err);

    if ( !catReg.Init( GetName(), GetLocation() ) )
        return FALSE;

    //
    // Add all the included scopes
    //
    WCHAR const * pwszScope;
    for (unsigned i = 0;  pwszScope = GetIncludedScope( i ); i++)
    {
        if ( !catReg.AddScope( pwszScope, L",,5" ) )
        {
            return FALSE;
        }
    }

    //
    // Now add the excluded scopes
    //
    for (i = 0;  pwszScope = GetExcludedScope( i ); i++)
    {
        if ( !catReg.AddScope( pwszScope, L",,4" ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CCatalogConfig::AddStringToArray, private static
//
//  Synopsis:   Adds a string to an XArray
//
//  Arguments:  [c]    - current count of strings in array
//              [xa]   - the XArray of strings
//              [pwsz] - string to be added
//
//  Returns:    BOOL - FALSE if any problems, TRUE otherwise
//
//  Notes:      Can throw on allocation failures.
//
//  History:    04 Nov 1998   AlanW   Created
//
//--------------------------------------------------------------------------

BOOL CCatalogConfig::AddStringToArray(
    ULONG & c,
    XArray<WCHAR const *> & xa,
    WCHAR const * pwsz )
{
    XPtrST<WCHAR> xpwsz;
    if (pwsz)
    {
        WCHAR * pwszCopy = new WCHAR[ wcslen(pwsz) + 1 ];
        xpwsz.Set(pwszCopy);
        wcscpy( pwszCopy, pwsz );
        pwsz = pwszCopy;
    }

    if ( c >= xa.Count() )
        xa.ReSize( c*2 );

    xa[c] = pwsz;
    c++;
    xpwsz.Acquire();
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CCatReg::Init
//
//  Synopsis:   Initializes catalog registry key configurator
//
//  Arguments:  [ pwszCatName ] -   catalog name
//              [ pwszLocation] -   catalog location
//
//  Returns:    none - throws upon fatal errors.
//
//  History:    9-10-97  mohamedn
//
//--------------------------------------------------------------------------

BOOL CCatReg::Init( WCHAR const *pwszCatName, WCHAR const *pwszLocation)
{

    ISAssert( pwszCatName );

    // create a catalog for the drive
    BOOL fExisted = FALSE;
    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegCatalogsSubKey );

    if ( !reg.CreateKey( pwszCatName, fExisted ) )
    {
        DWORD dwErr = GetLastError();
        isDebugOut(( "created catalogs\\%ws subkey Failed: %d\n",
                      pwszCatName, dwErr ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dwErr );

        return FALSE;
    }

    isDebugOut(( DEB_TRACE, "created catalogs\\%ws subkey\n", pwszCatName ));

    wcscpy( _wszCatRegSubKey, wcsRegCatalogsSubKey );
    wcscat( _wszCatRegSubKey, L"\\" );
    wcscat( _wszCatRegSubKey, pwszCatName );

    CWin32RegAccess regSystem( reg.GetHKey(), pwszCatName );
    if ( !regSystem.Set( L"Location", pwszLocation ) )
    {
        DWORD dw = GetLastError();

        isDebugOut(( "Failed to set Cat Location valued:%ws,  %d\n",
                      pwszLocation, dw ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dw );

        return FALSE;
    }

    if ( !regSystem.Set( wcsIsIndexingW3Roots,        (DWORD) 0 )  ||
         !regSystem.Set( wcsIsIndexingNNTPRoots,      (DWORD) 0 )
       )
    {
        DWORD dw = GetLastError();

        isDebugOut(( "Failed to set Cat values: %d\n", dw ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dw );

        return FALSE;
    }

    // Create a "Scopes" key so a watch can be established in cicat
    // It needs no entries.

    if ( !regSystem.CreateKey( wcsCatalogScopes, fExisted ) )
    {
        DWORD dw = GetLastError();
        isDebugOut(( "created scopes subkey Failed: %d\n", dw ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dw );

        return FALSE;
    }

    //
    // initialize the reg scopes subkey name
    //
    wcscpy( _wszCatScopeRegSubKey, _wszCatRegSubKey );
    wcscat( _wszCatScopeRegSubKey, L"\\" );
    wcscat( _wszCatScopeRegSubKey, wcsCatalogScopes );

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatReg::AddScope
//
//  Synopsis:   Adds a scope for the current catalog
//
//  Arguments:  [ pwszScopeName ]   -  scope name
//              [ pwszScopeAttrib]  -  scope attributes
//
//  Returns:    none - throws upon fatal errors.
//
//  History:    9-10-97  mohamedn
//
//--------------------------------------------------------------------------

BOOL CCatReg::AddScope( WCHAR const * pwszScopeName,
                        WCHAR const * pwszScopeAttrib )
{
    CWin32RegAccess regScopes( HKEY_LOCAL_MACHINE, _wszCatScopeRegSubKey );

    if ( !regScopes.Set( pwszScopeName, pwszScopeAttrib ) )
    {
        DWORD dwRetVal = GetLastError();

        isDebugOut(( "Failed to set scope value:\\%ws,  %d\n",
                          pwszScopeName, dwRetVal ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dwRetVal );

        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CCatReg::TrackW3Svc, public
//
//  Synopsis:   Configures catalog to be a 'web' catalog.
//
//  Arguments:  [dwInstance] -- WWW Virtual Server instance number
//
//  Returns:    TRUE if setup succeeded.
//
//  History:    13-May-1998   KyleP   Created
//
//--------------------------------------------------------------------------

BOOL CCatReg::TrackW3Svc( DWORD dwInstance )
{
    CWin32RegAccess regSystem( HKEY_LOCAL_MACHINE, _wszCatRegSubKey );

    // Fix for 249655. For a web catalog, wcsGenerateCharacterization and 
    // wcsFilterFilesWithUnknownExtensions should be set as follows.

    if ( !regSystem.Set( wcsIsIndexingW3Roots, 1 ) ||
         !regSystem.Set( wcsW3SvcInstance, dwInstance ) ||
         !regSystem.Set( wcsGenerateCharacterization, 1 ) ||
         !regSystem.Set( wcsFilterFilesWithUnknownExtensions, (DWORD)0 ) ||
         !regSystem.Set( wcsMaxCharacterization, 320 ) )
    {
        DWORD dw = GetLastError();

        isDebugOut(( "Failed to set Cat values: %d\n", dw ));

        ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, _Err, LogSevFatalError, dw );

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\setupqry\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       cnfgreg.hxx
//
//  Contents:   Precompiled header
//
//  History:    09 Jul 1997     mohamedn    Created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <loadperf.h>
#include <stdlib.h>
#include <stdio.h>
#include <direct.h>
#include <eh.h>

#include "isdebug.hxx"

#include "setupqry.hxx"

#include "isreg.hxx"
#include "res.h"

#include <tgrow.hxx>
#include <filtreg.hxx>
#include <tsmem.hxx>
#include <dynstack.hxx>
#include <dynarray.hxx>
#include <cimbmgr.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\autobloc.h ===
//-----------------------------------------------------------------------------
// Microsoft OLE DB Implementation For ODBC Providers 
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module AUTOBLOC.H | CAutoBlock object implementation.
//
// @rev 1 | 02-27-95 | EricJ    | Created
// @rev 2 | 06-30-95 | EricJ    | Added autoduck comments (maybe too many?)
// @rev 3 | 07-02-96 | EricJ    | Removed debug code; doesn't work on WIN95 or RISC.
//-----------------------------------------------------------------------------

#ifndef __AUTOBLOC_H_
#define __AUTOBLOC_H_

//-----------------------------------------------------------------------------
// @class CAutoBlock | Auto blocking / synchronization.
//
// This C++ object allows blocking of critical sections.
// The constructor/destructor automatically Enter and Leave
// correctly, to ensure that each call is correctly paired.
// This ensures correct operation for exception handling
// and for multiple returns.
//
// @ex Here's example usage. |
//
//  void test2()
//  {
//      CAutoBlock ab( &g_Crit1 );
//  
//      // Do some work here...
//      // Destructor cleans up
//  }
//  
//  void test3()
//  {
//      CAutoBlock ab( &g_Crit2 );
//  
//      //...do some work -- we are blocked here...
//  
//      ab.UnBlock();
//  
//      //...do some work -- we are not blocked here...
//      //...destructor does nothing...
//  }
//
// @devnote
// If you want to enter the same critical section again,
// just use another CAutoBlock.  
//
// Note that since the storage is auto (not static or dynamic 
// via `new`), this goes onto the stack.  Thus the overhead of 
// this class is almost exactly the same as explictly calling 
// EnterCriticalSection / LeaveCriticalSection.
//-----------------------------------------------------------------------------

class DBEXPORT CAutoBlock {
public:     //@access public functions
    CAutoBlock( CRITICAL_SECTION *pCrit );  //@cmember CTOR.  Begins blocking.
    ~CAutoBlock();                          //@cmember DTOR.  Ends blocking.
    void UnBlock();                         //@cmember Ends blocking.
private:    //@access private data
    CRITICAL_SECTION *m_pCrit;              //@cmember The critical section.
};


//-----------------------------------------------------------------------------
// Inline functions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// @mfunc Constructor.
// Begins blocking.  Does EnterCriticalSection, so you can put at 
// beginning of function, or in the middle of the function, 
// or inside some scoped {}.
//-----------------------------------------------------------------------------------

inline CAutoBlock::CAutoBlock( 
    CRITICAL_SECTION *pCrit )   //@parm IN | The critical section.
{
    // It is OK to pass a NULL ptr to this routine.  It is a NOOP.
    // Note that passing NULL to EnterCriticalSection blows up.

    if (0 != pCrit )
        ::EnterCriticalSection( pCrit );
    m_pCrit = pCrit;
}


//-----------------------------------------------------------------------------
// @mfunc Destructor.
// Ends blocking.  Does LeaveCriticalSection, unless you called UnBlock(),
// in which case it's a NOOP.
//-----------------------------------------------------------------------------------

inline CAutoBlock::~CAutoBlock()
{
    if ( 0 != m_pCrit )
        ::LeaveCriticalSection( m_pCrit );
}


//-----------------------------------------------------------------------------
// @mfunc
// Ends blocking explicitly.  Thereafter, the destructor does nothing.
//-----------------------------------------------------------------------------------

inline void CAutoBlock::UnBlock()
{
    // Clear the critical-section member,
    // so that the destructor doesn't do anything.

    if ( 0 != m_pCrit )
        ::LeaveCriticalSection( m_pCrit );
    m_pCrit = 0;
}


//-----------------------------------------------------------------------------
// @class CAutoBlock2 | Auto blocking / synchronization.
// This class requires each critical section to be assigned a level.
// Critical Sections can be called only in a low-to-high order, within a thread.
// Otherwise the chance for deadlock exists.
//-----------------------------------------------------------------------------

// ifdef this out for now, so it doesn't introduce another global var.
#ifdef NOTREADY

class DBEXPORT CAutoBlock2 {
public:     //@access public functions
    CAutoBlock2( CRITICAL_SECTION *pCrit, DWORD dwLevel );  //@cmember CTOR.  Begins blocking.
    ~CAutoBlock2();                         //@cmember DTOR.  Ends blocking.
    void UnBlock();                         //@cmember Ends blocking.
private:    //@access private data
    CRITICAL_SECTION *m_pCriticalSection;   //@cmember The critical section.
    DEBUGCODE( DWORD m_dwLevel; )           //@cmember Level of this critical section.
};

// There can be 32 levels, 0...31.
// They can only be used in low --> high order.
enum CritLevels {
    CRITLEV_DATASOURCE,
    CRITLEV_SESSION,
    CRITLEV_COMMAND,
    CRITLEV_ROWSET,
};


// We need a global var for the TLS index.
// @todo EJ 2-jun-96: Fake it for now; until this is integrated.
static DWORD g_dwTlsIndexCS = TLS_OUT_OF_INDEXES;


inline CAutoBlock2::CAutoBlock2( CRITICAL_SECTION *pCriticalSection, DWORD dwLevel )
{
#ifdef DEBUG
    DWORD dwExistLevel;
    assert( 0 <= dwLevel && dwLevel <= 31);
    assert(g_dwTlsIndexCS != TLS_OUT_OF_INDEXES);
    dwExistLevel = (DWORD) TlsGetValue(g_dwTlsIndexCS);
    // Disallow calls to lower levels than we currently have.
    // Allow calls to same level.
    assert(dwExistLevel > (DWORD) (1<<(dwLevel+1)) - 1);
    dwExistLevel |= 1<<dwLevel;
    TlsSetValue(g_dwTlsIndexCS, (LPVOID) dwExistLevel);
    m_dwLevel = dwLevel;
#endif

    m_pCriticalSection = pCriticalSection;
    if ( 0 != pCriticalSection )
        ::EnterCriticalSection( pCriticalSection );
}


inline CAutoBlock2::~CAutoBlock2()
{
#ifdef DEBUG
    DWORD dwExistLevel;
    dwExistLevel = (DWORD) TlsGetValue(g_dwTlsIndexCS);
    dwExistLevel &= ~ (1<<m_dwLevel);
    TlsSetValue(g_dwTlsIndexCS, (LPVOID) dwExistLevel);
#endif

    if ( 0 != m_pCriticalSection )
        ::LeaveCriticalSection( m_pCriticalSection );
}


inline void CAutoBlock2::UnBlock()
{
    // Clear the critical-section member,
    // so that the destructor doesn't do anything.

    if ( 0 != m_pCriticalSection )
        ::LeaveCriticalSection( m_pCriticalSection );
    m_pCriticalSection = 0;
}

#endif  // NOTREADY

#endif // __AUTOBLOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\bison.cpp ===
/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#pragma hdrstop
#include <malloc.h>

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */


#ifdef YYDEBUG
# ifndef YYDBFLG
#  define YYDBFLG                               (yydebug)
# endif
# define yyprintf                               if (YYDBFLG) YYPRINT
#else
# define yyprintf
#endif

#ifndef YYPRINT
#ifdef UNICODE
# define YYPRINT                                wprintf
#else
# define YYPRINT                                printf
#endif
#endif

#ifndef YYERROR_VERBOSE
#define YYERROR_VERBOSE                        1
#endif

#define YYEMPTY         -2
#define YYEOF           0
#define YYACCEPT        return(ResultFromScode(S_OK))
#define YYABORT(sc)     {EmptyValueStack(); return(ResultFromScode(sc));}
#define YYERROR         goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL          goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)

#define YYTERROR        1
#define YYERRCODE       256


/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

//turn off warning about 'this' in base member initialization
#pragma warning (disable : 4355)
YYPARSER::YYPARSER(
        CImpIParserSession* pParserSession, 
        CImpIParserTreeProperties* pParserTreeProperties
        ) : m_yylex(this)
#pragma warning (default : 4355)
        {
                //Allocate yys, yyv if necessary
                ResetParser();
                m_pIPSession = pParserSession;
                m_pIPTProperties = pParserTreeProperties;
        }

YYPARSER::~YYPARSER()
        {
        //Deallocate yys, yyv if allocated
        }


void YYPARSER::ResetParser()
        {
        yystate = 0;
        yyerrstatus = 0;
        yynerrs = 0;

        /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

        yyssp = yyss-1;
        yyvsp = yyvs;

        YYAPI_TOKENNAME = YYEMPTY;      // Cause a token to be read.
        }


#pragma warning(disable:102)
HRESULT YYPARSER::Parse(YYPARSEPROTO)
        {
        yychar1 = 0;            /*  lookahead token as an internal (translated) token number */

        yyss = yyssa;           /*  refer to the stacks thru separate pointers */
        yyvs = yyvsa;           /*  to allow yyoverflow to reallocate them elsewhere */

        yystacksize = YYINITDEPTH;



#ifdef YYDEBUG
        if (yydebug)
                Trace(TEXT("Starting parse\n"));
#endif

        yystate = 0;
        yyerrstatus = 0;
        yynerrs = 0;
        YYAPI_TOKENNAME = YYEMPTY;              /* Cause a token to be read.  */

        /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

        yyssp = yyss-1;
        yyvsp = yyvs;

        // Push a new state, which is found in  yystate  . 
        // In all cases, when you get here, the value and location stacks
        // have just been pushed. so pushing a state here evens the stacks.
yynewstate:
        *++yyssp = yystate;

        if (yyssp >= yyss + yystacksize - 1)
                {
                // Give user a chance to reallocate the stack
                // Use copies of these so that the &'s don't force the real ones into memory. */
                YYSTYPE *yyvs1 = yyvs;
                short *yyss1 = yyss;

                // Get the current used size of the three stacks, in elements.  */
                int size = (int)(yyssp - yyss + 1);

#ifdef yyoverflow
                // Each stack pointer address is followed by the size of
                // the data in use in that stack, in bytes.
                yyoverflow("parser stack overflow",
                                        &yyss1, size * sizeof (*yyssp),
                                        &yyvs1, size * sizeof (*yyvsp),
                                        &yystacksize);

                yyss = yyss1; yyvs = yyvs1;
#else // no yyoverflow
      // Extend the stack our own way.
                if (yystacksize >= YYMAXDEPTH)
                        {
                        m_pIPTProperties->SetErrorHResult(E_FAIL, MONSQL_PARSE_STACK_OVERFLOW);
                        return ResultFromScode(E_FAIL);
                        }
                yystacksize *= 2;
                if (yystacksize > YYMAXDEPTH)
                        yystacksize = YYMAXDEPTH;
                yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
                memcpy ((TCHAR *)yyss, (TCHAR *)yyss1, size * sizeof (*yyssp));
                yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
                memcpy ((TCHAR *)yyvs, (TCHAR *)yyvs1, size * sizeof (*yyvsp));
#endif /* no yyoverflow */

                yyssp = yyss + size - 1;
                yyvsp = yyvs + size - 1;

#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Stack size increased to %d\n"), yystacksize);
#endif

                if (yyssp >= yyss + yystacksize - 1)
                        YYABORT(E_FAIL);
                }

#ifdef YYDEBUG
        if (yydebug)
                Trace(TEXT("Entering state %d\n"), yystate);
#endif

        goto yybackup;



yybackup:

        // Do appropriate processing given the current state.
        // Read a lookahead token if we need one and don't already have one.

        // First try to decide what to do without reference to lookahead token.

        yyn = yypact[yystate];
        if (yyn == YYFLAG)
                goto yydefault;

        // Not known => get a lookahead token if don't already have one.

        // YYAPI_TOKENNAME is either YYEMPTY or YYEOF or a valid token in external form.

        if (YYAPI_TOKENNAME == YYEMPTY)
                {
#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Reading a token\n"));
#endif
                YYAPI_VALUENAME = NULL; 
                try
                        {
                        YYAPI_TOKENNAME = YYLEX(&YYAPI_VALUENAME);
                        }
                catch (HRESULT hr)
                        {
                        switch(hr)
                                {
                        case E_OUTOFMEMORY:
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT(E_OUTOFMEMORY);
                        
                        default:
                                YYABORT(E_FAIL);
                                }
                        }
                }

        // Convert token to internal form (in yychar1) for indexing tables with

        if (YYAPI_TOKENNAME <= 0)               /* This means end of input. */
                {
                yychar1 = 0;
                YYAPI_TOKENNAME = YYEOF;                /* Don't call YYLEX any more */

#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Now at end of input: state %2d\n"), yystate);
#endif
                }
        else
                {
                yychar1 = YYTRANSLATE(YYAPI_TOKENNAME);

#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Next token is %s (%d)\n"), yytname[yychar1], YYAPI_TOKENNAME);
#endif
                }

        yyn += yychar1;
        if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
                goto yydefault;

        yyn = yytable[yyn];

        // yyn is what to do for this token type in this state.
        // Negative => reduce, -yyn is rule number.
        // Positive => shift, yyn is new state.
        // New state is final state => don't bother to shift,
        // just return success.
        // 0, or most negative number => error.  */

        if (yyn < 0)
                {
                if (yyn == YYFLAG)
                        goto yyerrlab;
                yyn = -yyn;
                goto yyreduce;
                }
        else if (yyn == 0)
                goto yyerrlab;

        if (yyn == YYFINAL)
                YYACCEPT;

        // Shift the lookahead token.

#ifdef YYDEBUG
        if (yydebug)
                Trace(TEXT("Shifting token %s (%d), "), yytname[yychar1], YYAPI_TOKENNAME);
#endif

        // Discard the token being shifted unless it is eof.
        if (YYAPI_TOKENNAME != YYEOF)
                YYAPI_TOKENNAME = YYEMPTY;

        *++yyvsp = yylval;
        yylval = NULL;

        // count tokens shifted since error; after three, turn off error status.
        if (yyerrstatus)
                yyerrstatus--;

        yystate = (short)yyn;
        goto yynewstate;


        // Do the default action for the current state.
yydefault:
        yyn = yydefact[yystate];
        if (yyn == 0)
                goto yyerrlab;

        // Do a reduction.  yyn is the number of a rule to reduce with.
yyreduce:
        yylen = yyr2[yyn];
        if (yylen > 0)
                yyval = yyvsp[1-yylen]; // implement default value of the action

#ifdef YYDEBUG
        if (yydebug)
                {
                int i;
                Trace(TEXT("Reducing via rule %d (line %d), "), yyn, yyrline[yyn]);

                // Print the symbols being reduced, and their result.
                for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
                        Trace(TEXT("%s "), yytname[yyrhs[i]]);
                Trace(TEXT(" -> %s\n"), yytname[yyr1[yyn]]);
                }
#endif

$   /* the action file gets copied in in place of this dollarsign */
#line 498 "bison.simple"

        yyvsp -= yylen;
        yyssp -= yylen;

#ifdef YYDEBUG
        if (yydebug)
                {
                short *ssp1 = yyss - 1;
                Trace(TEXT("state stack now"));
                while (ssp1 != yyssp)
                        Trace(TEXT(" %d"), *++ssp1);
                Trace(TEXT("\n"), *++ssp1);
                }
#endif

        *++yyvsp = yyval;


        // Now "shift" the result of the reduction.
        // Determine what state that goes to,
        // based on the state we popped back to
        // and the rule number reduced by.

        yyn = yyr1[yyn];

        yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
        if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
                yystate = yytable[yystate];
        else
                yystate = yydefgoto[yyn - YYNTBASE];

        goto yynewstate;


yyerrlab:   // here on detecting error
        if (yylval)
                {
                DeleteDBQT(yylval);
                yylval = NULL;
                }

        if (!yyerrstatus) // If not already recovering from an error, report this error.
                {
                    ++yynerrs;

#ifdef YYERROR_VERBOSE
                    yyn = yypact[yystate];

                    if ( yyn > YYFLAG && yyn < YYLAST )
                    {
                        int size = 0;
                        int x, count;

                        count = 0;
                        // Start X at -yyn if nec to avoid negative indexes in yycheck.
                        for ( x = (yyn < 0 ? -yyn : 0); 
                              x < (sizeof(yytname) / sizeof(TCHAR *)) &&  ( (x + yyn) < sizeof(yycheck) / sizeof(short)); 
                              x++ )
                        {
                            if ( yycheck[x + yyn] == x ) 
                            {
                                size += (wcslen(yytname[x]) + 3) * sizeof(TCHAR);
                                count++;
                            }
                        }

                        XPtrST<WCHAR> xMsg( new WCHAR[size] );
                        
                        wcscpy(xMsg.GetPointer(), L"");

                        m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                        if ( wcslen((YY_CHAR*)m_yylex.YYText()) )
                            m_pIPTProperties->SetErrorToken( (YY_CHAR*)m_yylex.YYText() );
                        else
                            m_pIPTProperties->SetErrorToken(L"<end of input>");

                        if (count < 10)
                        {
                            count = 0;
                            for ( x = (yyn < 0 ? -yyn : 0);
                                  x < (sizeof(yytname) / sizeof(TCHAR *)) &&  ( (x + yyn) < sizeof(yycheck) / sizeof(short)); 
                                  x++ )
                            {    
                                if (yycheck[x + yyn] == x)
                                {
                                    if (count > 0)
                                        wcscat( xMsg.GetPointer(), L", " );
                                    wcscat(xMsg.GetPointer(), yytname[x]);
                                    count++;
                                }
                            }
                            m_pIPTProperties->SetErrorToken( xMsg.GetPointer() );
                        }

                xMsg.Free();
                }
      else
#endif /* YYERROR_VERBOSE */
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
        }
        goto yyerrlab1;



yyerrlab1:   // here on error raised explicitly by an action 

        if (yyerrstatus == 3)
                {       // if just tried and failed to reuse lookahead token after an error, discard it.
                        // return failure if at end of input
                if (YYAPI_TOKENNAME == YYEOF)
                        YYABORT(DB_E_ERRORSINCOMMAND);

#ifdef YYDEBUG
                if (yydebug)
                        Trace(TEXT("Discarding token %s (%d).\n"), yytname[yychar1], YYAPI_TOKENNAME);
#endif
                YYAPI_TOKENNAME = YYEMPTY;
                }

        // Else will try to reuse lookahead token after shifting the error token.
        yyerrstatus = 3;                // Each real token shifted decrements this
        goto yyerrhandle;


yyerrdefault:   // current state does not do anything special for the error token.
yyerrpop:               // pop the current state because it cannot handle the error token 

        if (yyssp == yyss)
                YYABORT(E_FAIL);

        if (NULL != *yyvsp)
                {
                DeleteDBQT(*yyvsp);
                }
        yyvsp--;
        yystate = *--yyssp;

#ifdef YYDEBUG
        if (yydebug)
                {
                short *ssp1 = yyss - 1;
                Trace(TEXT("Error: state stack now"));
                while (ssp1 != yyssp)
                        Trace(TEXT(" %d"), *++ssp1);
                Trace(TEXT("\n"));
                }
#endif


yyerrhandle:
        yyn = yypact[yystate];
        if (yyn == YYFLAG)
                goto yyerrdefault;

        yyn += YYTERROR;
        if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
                goto yyerrdefault;

        yyn = yytable[yyn];
        if (yyn < 0)
                {
                if (yyn == YYFLAG)
                        goto yyerrpop;
                yyn = -yyn;
                goto yyreduce;
                }
        else if (yyn == 0)
                goto yyerrpop;

        if (yyn == YYFINAL)
                YYACCEPT;

#ifdef YYDEBUG
        if (yydebug)
                Trace(TEXT("Shifting error token, "));
#endif

        *++yyvsp = yylval;

        yystate = (short)yyn;
        goto yynewstate;
        }


#pragma warning(default:102)


#ifdef YYDUMP
void YYPARSER::DumpYYS()
        {
        short stackindex;

        yyprintf(TEXT("short yys[%d] {\n"), YYMAXDEPTH);
        for (stackindex = 0; stackindex < YYMAXDEPTH; stackindex++)
                {
                if (stackindex)
                        yyprintf(TEXT(", %s"), stackindex % 10 ? TEXT("\0") : TEXT("\n"));
                yyprintf(TEXT("%6d"), yys[stackindex]);
                }
        yyprintf(TEXT("\n};\n"));
        }

void YYPARSER::DumpYYV()
        {
        short valindex;

        yyprintf(TEXT("YYSTYPE yyv[%d] {\n"), YYMAXDEPTH);
        for (valindex = 0; valindex < YYMAXDEPTH; valindex++)
                {
                if (valindex)
                        yyprintf(TEXT(", %s"), valindex % 5 ? TEXT("\0") : TEXT("\n"));
                yyprintf(TEXT("%#*x"), 3+sizeof(YYSTYPE), yyv[valindex]);
                }
        yyprintf(TEXT("\n};\n"));
        }
#endif


int YYPARSER::NoOfErrors()
        {
        return yynerrs;
        }


int YYPARSER::ErrRecoveryState()
        {
        return yyerrflag;
        }


void YYPARSER::ClearErrRecoveryState()
        {
        yyerrflag = 0;
        }


YYAPI_TOKENTYPE YYPARSER::GetCurrentToken()
        {
        return YYAPI_TOKENNAME;
        }


void YYPARSER::SetCurrentToken(YYAPI_TOKENTYPE newToken)
        {
        YYAPI_TOKENNAME = newToken;
        }



void YYPARSER::Trace(TCHAR *message)
        {
#ifdef YYDEBUG
        yyprintf(message);
#endif
        }

void YYPARSER::Trace(TCHAR *message, const TCHAR *tokname, short state /*= 0*/)
        {
#ifdef YYDEBUG
        yyprintf(message, tokname, state);
#endif
        }

void YYPARSER::Trace(TCHAR *message, int state, short tostate /*= 0*/, short token /*= 0*/)
        {
#ifdef YYDEBUG
        yyprintf(message, state, tostate, token);
#endif
        }


void YYPARSER::yySetBuffer(short iBuffer, YY_CHAR *szValue)
        {
        if (iBuffer >= 0 && iBuffer < maxYYBuffer)
                rgpszYYBuffer[iBuffer] = szValue;
        }


YY_CHAR *YYPARSER::yyGetBuffer(short iBuffer)
        {
        if (iBuffer >= 0 && iBuffer < maxYYBuffer)
                return rgpszYYBuffer[iBuffer];
        else
                return (YY_CHAR *)NULL;
        }


void YYPARSER::yyprimebuffer(YY_CHAR *pszBuffer)
        {
        m_yylex.yyprimebuffer(pszBuffer);
        }


void YYPARSER::yyprimelexer(int eToken)
        {
        m_yylex.yyprimelexer(eToken);
        }

void YYPARSER::EmptyValueStack()
        {
        if ((*yyvsp != yylval) && (NULL != yylval))
                DeleteDBQT(yylval);

        while (yyvsp != yyvsa)
                {
                if (NULL != *yyvsp)
                        DeleteDBQT(*yyvsp);
                yyvsp--;
                }
//@TODO RE-ACTIVATE
// note:  This was only done to empty any scope arrays
//      m_pIPSession->SetScopeProperties(m_pICommand);
        if (m_pIPTProperties->GetContainsColumn())
                DeleteDBQT(m_pIPTProperties->GetContainsColumn());

        m_pIPTProperties->SetContainsColumn(NULL);
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\setupqry\res.h ===
#define IDD_WIZPAGE                     111
#define IDT_COMPONENT                   1000
#define IDT_PAGETYPE                    1001
#define IDT_COUNT                       1002
#define IDC_STATIC                      -1


#define IDT_CAT_DIR                     1010
#define IDT_HOME_DIR                    1011
#define IDT_SCRIPT_DIR                  1012
#define IDC_CAT_BROWSE                  1013
#define IDC_FRAME_BANNER                1014

#define IDD_DIRPAGE_V1                  112
#define IDD_DIRPAGE_V2                  113
#define IDD_BROWSEDIRECTORY             114


#define IS_MSG_COULD_NOT_SET_SECURITY       503
#define IS_MSG_INDEX_SERVER                 505
#define IS_MSG_COULD_NOT_CREATE_DIR         507
#define IS_MSG_COULD_NOT_MODIFY_REGISTRY    508
#define IS_MSG_COULD_NOT_CONFIGURE_CATALOGS 516
#define IS_MSG_INVALID_INF_HANDLE           518
#define IS_MSG_INVALID_OCM_VERSION          519 
#define IS_MSG_ABORT                        520
#define IS_MSG_CALC_DISK_SPACE_FAILED       521
#define IS_MSG_QUEUE_FILE_OPS_FAILED        522
#define IS_MSG_QUEUE_CONFIG_PARAMS_FAILED   523
#define IS_MSG_SetRegBasedOnMachine_FAILED  524
#define IS_MSG_COMPLETE_INSTALLATION_FAILED 525
#define IS_MSG_EXCEPTION_CAUGHT             526
#define IS_MSG_SETUP_INSTALL_FROM_INFSECTION_FAILED 527
#define IS_MSG_SetDllsToRegister_FAILED     528
#define IS_MSG_SetFilterRegistryInfo_FAILED 529
#define IS_MSG_SetDefaultCatalog_FAILED     531
#define IS_MSG_BAD_MACHINE                  532
#define IS_MSG_NEEDED_HARDWARE              533
#define IS_MSG_DRIVE_ENUMERATION_FAILED     534
#define IS_MSG_LoadPerfCounterTextStrings_FAILED 535
#define IS_MSG_UNEXPECTED_PROCESSOR_TYPE    536
#define IS_MSG_CreateService_FAILED         537
#define IS_MSG_DllRegisterServer_FAILED     538
#define IS_MSG_DLL_REGISTRATION_FAILED      539

#define IS_MSG_LINK_SAMPLE_NAME  540
#define IS_MSG_LINK_ADMIN_NAME   541
#define IS_MSG_LINK_MMC_NAME     542
#define IS_MSG_START_MENU_NAME   543
#define IS_MSG_NTOP              544

#define IS_SERVICE_NAME          600
#define IS_SERVICE_DESCRIPTION   601
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\colname.cpp ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module colname.cpp |
//
//  Contains utility functions for maintaining property lists (symbol table?)
//
// @rev   0 | 12-Feb-97 | v-charca      | Created
//        1 | 24-Oct-98 | danleg        | cleanup
//
#pragma hdrstop
#include "msidxtr.h"

const BYTE randomNumbers[] =
    {   // Pseudorandom Permutation of the Integers 0 through 255: CACM 33 6 p678
      1,  87,  49,  12, 176, 178, 102, 166, 121, 193,   6,  84, 249, 230,  44, 163,
     14, 197, 213, 181, 161,  85, 218,  80,  64, 239,  24, 226, 236, 142,  38, 200,
    110, 177, 104, 103, 141, 253, 255,  50,  77, 101,  81,  18,  45,  96,  31, 222,
     25, 107, 190,  70,  86, 237, 240,  34,  72, 242,  20, 214, 244, 227, 149, 235,
     97, 234,  57,  22,  60, 250,  82, 175, 208,   5, 127, 199, 111,  62, 135, 248,
    174, 169, 211,  58,  66, 154, 106, 195, 245, 171,  17, 187, 182, 179,   0, 243,
    132,  56, 148,  75, 128, 133, 158, 100, 130, 126,  91,  13, 153, 246, 216, 219,
    119,  68, 223,  78,  83,  88, 201,  99, 122,  11,  92,  32, 136, 114,  52,  10,
    138,  30,  48, 183, 156,  35,  61,  26, 143,  74, 251,  94, 129, 162,  63, 152,
    170,   7, 115, 167, 241, 206,   3, 150,  55,  59, 151, 220,  90,  53,  23, 131,
    125, 173,  15, 238,  79,  95,  89,  16, 105, 137, 225, 224, 217, 160,  37, 123,
    118,  73,   2, 157,  46, 116,   9, 145, 134, 228, 207, 212, 202, 215,  69, 229,
     27, 188,  67, 124, 168, 252,  42,   4,  29, 108,  21, 247,  19, 205,  39, 203,
    233,  40, 186, 147, 198, 192, 155,  33, 164, 191,  98, 204, 165, 180, 117,  76,
    140,  36, 210, 172,  41,  54, 159,   8, 185, 232, 113, 196, 231,  47, 146, 120,
     51,  65,  28, 144, 254, 221,  93, 189, 194, 139, 112,  43,  71, 109, 184, 209
    };



//-----------------------------------------------------------------------------
//  @mfunc Constructor
//
//  @side No designed side effects.
//
//-----------------------------------------------------------------------------
CPropertyList::CPropertyList(
    CPropertyList** ppGlobalPropertyList    // in | caller's property list
    ) : m_aBucket( 47 ),                    // number of hash buckets (PRIME!)
        m_cMaxBucket( 47 ),
        m_ppGlobalPropertyList( ppGlobalPropertyList )
{
    RtlZeroMemory( m_aBucket.Get(), m_aBucket.SizeOf() );
}

//-----------------------------------------------------------------------------
// @mfunc Constructor
//
// @side No designed side effects.
//
//-----------------------------------------------------------------------------
CPropertyList::~CPropertyList()
{
    // delete the hash table
    for (int i=0; i<m_cMaxBucket; i++)
    {
        tagHASHENTRY*   pHashEntry = m_aBucket[i];
        tagHASHENTRY*   pNextHashEntry = NULL;
        while (NULL != pHashEntry)
        {
            delete [] pHashEntry->wcsFriendlyName;
            if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
                delete [] pHashEntry->dbCol.uName.pwszName;
            pNextHashEntry = pHashEntry->pNextHashEntry;
            delete [] pHashEntry;
            pHashEntry = pNextHashEntry;
        }
    }
}


/* Hashing function described in                   */
/* "Fast Hashing of Variable-Length Text Strings," */
/* by Peter K. Pearson, CACM, June 1990.           */


inline UINT CPropertyList::GetHashValue(
    LPWSTR wszPropertyName          //@parm IN | character string to hash
    )
{
    int iHash  = 0;
    char *szPropertyName = (char*) wszPropertyName;
    int cwch = wcslen(wszPropertyName)*2;
    for (int i=0; i<cwch; i++)
        iHash ^= randomNumbers[*szPropertyName++];
    return iHash % m_cMaxBucket;
}

//-----------------------------------------------------------------------------
// @mfunc
//
// Method to create a property table to be used in a CITextToSelectTree call
// (passthrough query).  The global and local properties need to be stuffed
// into a nice contiguous array.
//
// @side None
// @rdesc CIPROPERTYDEF*
//-----------------------------------------------------------------------------
CIPROPERTYDEF* CPropertyList::GetPropertyTable(
    UINT *  pcSize      // @parm out | size of property table
    )
{
    *pcSize = 0;
    for (int i=0; i<m_cMaxBucket; i++)
    {
        tagHASHENTRY*   pHashEntry = (*m_ppGlobalPropertyList)->m_aBucket[i];
        while (NULL != pHashEntry)
        {
            pHashEntry = pHashEntry->pNextHashEntry;
            (*pcSize)++;
        }
    }

    for (i=0; i<m_cMaxBucket; i++)
    {
        tagHASHENTRY*   pHashEntry = m_aBucket[i];
        while (NULL != pHashEntry)
        {
            pHashEntry = pHashEntry->pNextHashEntry;
            (*pcSize)++;
        }
    }

    XArray<CIPROPERTYDEF> xCiPropTable( *pcSize );

    TRY
    {
        RtlZeroMemory( xCiPropTable.Get(), xCiPropTable.SizeOf() );

        *pcSize = 0;
        for ( i=0; i<m_cMaxBucket; i++ )
        {
            tagHASHENTRY*   pHashEntry = (*m_ppGlobalPropertyList)->m_aBucket[i];
            while ( NULL != pHashEntry )
            {
                xCiPropTable[*pcSize].wcsFriendlyName = CopyString( pHashEntry->wcsFriendlyName );
                xCiPropTable[*pcSize].dbType          = pHashEntry->dbType;
                xCiPropTable[*pcSize].dbCol           = pHashEntry->dbCol;

                if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
                    xCiPropTable[*pcSize].dbCol.uName.pwszName = CopyString( pHashEntry->dbCol.uName.pwszName );
                else
                    xCiPropTable[*pcSize].dbCol.uName.pwszName = pHashEntry->dbCol.uName.pwszName;

                pHashEntry = pHashEntry->pNextHashEntry;
                (*pcSize)++;
            }
        }

        for (i=0; i<m_cMaxBucket; i++)
        {
            tagHASHENTRY*   pHashEntry = m_aBucket[i];
            while (NULL != pHashEntry)
            {
                xCiPropTable[*pcSize].wcsFriendlyName = CopyString( pHashEntry->wcsFriendlyName );
                xCiPropTable[*pcSize].dbType          = pHashEntry->dbType;
                xCiPropTable[*pcSize].dbCol           = pHashEntry->dbCol;

                if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
                    xCiPropTable[*pcSize].dbCol.uName.pwszName = CopyString( pHashEntry->dbCol.uName.pwszName );
                else
                    xCiPropTable[*pcSize].dbCol.uName.pwszName = pHashEntry->dbCol.uName.pwszName;

                pHashEntry = pHashEntry->pNextHashEntry;
                (*pcSize)++;
            }
        }
    }
    CATCH( CException, e )
    {
        // free the table
        
        for ( unsigned i=0; i<xCiPropTable.Count(); i++ )
        {
            delete [] xCiPropTable[i].wcsFriendlyName;
            if ( DBKIND_GUID_NAME == xCiPropTable[i].dbCol.eKind )
                delete [] xCiPropTable[i].dbCol.uName.pwszName;
        }

        RETHROW();
    }
    END_CATCH

    return xCiPropTable.Acquire();
}


//-----------------------------------------------------------------------------
// @mfunc
//
// Method to delete a property table used in a CITextToSelectTree call
// (passthrough query).  
//
// @side None
// @rdesc HRESULT
//-----------------------------------------------------------------------------
void CPropertyList::DeletePropertyTable(
    CIPROPERTYDEF*  pCiPropTable,       // @parm in | property table to be deleted
    UINT            cSize               // @parm in | size of property table
    )
{
    for ( UINT i=0; i<cSize; i++ )
    {
        delete [] pCiPropTable[i].wcsFriendlyName;
        if ( DBKIND_GUID_NAME == pCiPropTable[i].dbCol.eKind )
            delete [] pCiPropTable[i].dbCol.uName.pwszName;
    }
    delete pCiPropTable;
}

//-----------------------------------------------------------------------------
// @mfunc
//
// Method to retrieve the pointer to the CIPROPERTYDEF element
// associated with this wszPropertyName, or NULL if name is
// not in the table
//
// @side None
// @rdesc CIPROPERDEF*
//-----------------------------------------------------------------------------
HASHENTRY *CPropertyList::FindPropertyEntry(
    LPWSTR  wszPropertyName,
    UINT    *puHashValue
    )
{
    HASHENTRY *pHashEntry = NULL;

    *puHashValue = GetHashValue(wszPropertyName);
    for (pHashEntry = m_aBucket[*puHashValue]; pHashEntry; pHashEntry = pHashEntry->pNextHashEntry)
    {
        if ( (*puHashValue==pHashEntry->wHashValue) &&
             (_wcsicmp(wszPropertyName, pHashEntry->wcsFriendlyName)==0) )
            return pHashEntry;
    }
    return NULL;
}

//-----------------------------------------------------------------------------
// @mfunc
//
// Method to retrieve the pointer to the CIPROPERTYDEF element
// associated with this wszPropertyName, or NULL if name is
// not in the table
//
// @side None
// @rdesc CIPROPERDEF*
//-----------------------------------------------------------------------------
HASHENTRY *CPropertyList::GetPropertyEntry(
    LPWSTR  wszPropertyName,
    UINT    *puHashValue
    )
{
    HASHENTRY *pHashEntry = NULL;

    if ( 0 != m_ppGlobalPropertyList && 0 != *m_ppGlobalPropertyList )
    {
        pHashEntry = (*m_ppGlobalPropertyList)->FindPropertyEntry( wszPropertyName, puHashValue );
        if ( 0 != pHashEntry )
            return pHashEntry;
    }

    pHashEntry = FindPropertyEntry( wszPropertyName, puHashValue );
    return pHashEntry;
}


//--------------------------------------------------------------------
// @mfunc
//
// Method to retrieve the pointer to the CIPROPERTYDEF element
// associated with this wszPropertyName, or NULL if name is
// not in the table
//
// @side None
// @rdesc HRESULT
//      S_OK            successfull operation
//      E_FAIL          property isn't defined
//      E_INVALIDARG    ppct or pdbType was null
//      E_OUTOFMEMORY   just what it says
//--------------------------------------------------------------------
HRESULT CPropertyList::LookUpPropertyName(
    LPWSTR          wszPropertyName,    // @parm IN
    DBCOMMANDTREE** ppct,               // @parm OUT
    DBTYPE*         pdbType             // @parm OUT
    )
{
    UINT        uHashValue;
    if ( 0 == ppct || 0 == pdbType)
        return E_INVALIDARG;

    HASHENTRY   *pHashEntry = GetPropertyEntry(wszPropertyName, &uHashValue);
    if ( 0 != pHashEntry )
    {
            *pdbType = (DBTYPE)pHashEntry->dbType;
            *ppct = PctCreateNode(DBOP_column_name, DBVALUEKIND_ID, NULL);
            if ( 0 != *ppct )
            {
                (*ppct)->value.pdbidValue->eKind = pHashEntry->dbCol.eKind;
                (*ppct)->value.pdbidValue->uGuid.guid = pHashEntry->dbCol.uGuid.guid;
                if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
                {
                    WCHAR * pwcName = CoTaskStrDup( pHashEntry->dbCol.uName.pwszName );

                    if ( 0 == pwcName )
                    {
                        (*ppct)->value.pdbidValue->eKind = DBKIND_GUID_PROPID;
                        DeleteDBQT( *ppct );
                        *ppct = 0;
                        return E_OUTOFMEMORY;
                    }

                    (*ppct)->value.pdbidValue->uName.pwszName = pwcName;
                }
                else
                {
                    Assert( DBKIND_GUID_PROPID == pHashEntry->dbCol.eKind );
                    (*ppct)->value.pdbidValue->uName.pwszName = pHashEntry->dbCol.uName.pwszName;
                }
                return S_OK;
            }
            else
                return E_OUTOFMEMORY;
    }
    else
        return E_FAIL;
}


//-----------------------------------------------------------------------------
// @func SetPropertyEntry
//
// Insert the specified property into the symbol table.
// If it is already there, redefine its value.
//
// @rdesc HRESULT
// @flag  S_OK          | ok
// @flag  E_OUTOFMEMORY | out of memory
//-----------------------------------------------------------------------------
HRESULT CPropertyList::SetPropertyEntry(
    LPWSTR  wcsFriendlyName,        // @parm IN | name of property
    DWORD   dbType,                 // @parm IN | dbtype of property
    GUID    guid,                   // @parm IN | GUID defining the property
    DBKIND  eKind,                  // @parm IN | type of PropId (currently GUID_NAME or GUID_PROPID)
    LPWSTR  pwszPropName,           // @parm IN | either a name or propid
    BOOL    fGlobal )               // @parm IN | TRUE if global definition; FALSE if local
{
    SCODE sc = S_OK;

    TRY
    {
        UINT uhash=0;
        HASHENTRY* pHashEntry = GetPropertyEntry(wcsFriendlyName, &uhash);

        if ( 0 != pHashEntry )
        {
            // Redefining a user defined property.
            // Delete the old property definition.
            if ( DBKIND_GUID_NAME == pHashEntry->dbCol.eKind )
            {
                XPtrST<WCHAR> xName( CopyString(pwszPropName) );
                delete [] pHashEntry->dbCol.uName.pwszName;
                pHashEntry->dbCol.uName.pwszName = xName.Acquire();
            }

            pHashEntry->dbType           = dbType;
            pHashEntry->dbCol.uGuid.guid = guid;
            pHashEntry->dbCol.eKind      = eKind;
        }
        else
        {
            XPtr<HASHENTRY> xHashEntry( new HASHENTRY );
            xHashEntry->wHashValue = uhash;
            XPtrST<WCHAR> xName( CopyString(wcsFriendlyName) );
            xHashEntry->dbType           = dbType;
            xHashEntry->dbCol.uGuid.guid = guid;
            xHashEntry->dbCol.eKind      = eKind;

            if ( DBKIND_GUID_NAME == eKind )
                xHashEntry->dbCol.uName.pwszName = CopyString( pwszPropName );
            else
                xHashEntry->dbCol.uName.pwszName = pwszPropName;

            xHashEntry->wcsFriendlyName = xName.Acquire();

            xHashEntry->pNextHashEntry = m_aBucket[uhash];  // Add to head of singly-linked list
            m_aBucket[uhash] = xHashEntry.Acquire();
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
} // SetPropertyEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\setupqry\shlink.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       shlink.cxx
//
//  Contents:   Utility stuff for shell links
//
//  History:    10-Sep-97 dlee     Created mostly from IIS setup code
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <tchar.h>
#include <shlobj.h>
#include <oleguid.h>

BOOL DoesFileExist(LPCTSTR szFile)
{
    return (GetFileAttributes(szFile) != 0xFFFFFFFF);
}

BOOL IsDirEmpty( WCHAR const * pwcDir )
{
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
    BOOL              fReturn = TRUE;

    WCHAR awc[ MAX_PATH ];

    unsigned cwc = wcslen( pwcDir ) + 4;

    if ( cwc >= MAX_PATH )
        return TRUE;

    wcscpy( awc, pwcDir );
    wcscat( awc, L"\\*.*" );

    hFind = FindFirstFile( awc, &FindData );
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
           fReturn = FALSE;
           break;
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }

    FindClose (hFind );

    return fReturn;
} //IsDirEmpty


//+-------------------------------------------------------------------------
//
//  Function:   CreateShellDirectoryTree
//
//  Synopsis:   Creates as many directories as is necessary
//
//  Arguments:  pwc -- the directory to create
//
//  Returns:    Win32 Error Code
//
//  Notes:      Directories are created up to the last backslash
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD CreateShellDirectoryTree( WCHAR const *pwcIn )
{
    WCHAR awc[MAX_PATH];
    WCHAR * pwc = awc;

    if ( wcslen( pwcIn ) >= ( MAX_PATH - 5 ) )
        return ERROR_INVALID_PARAMETER;

    wcscpy( pwc, pwcIn );

    unsigned cwc = wcslen( pwc );
    if ( (cwc > 0) &&
         (cwc < ((sizeof awc / sizeof WCHAR) - 1)) &&
         (pwc[cwc-1] != L'\\') ) {

        wcscat( pwc, L"\\" );
    }

    WCHAR *pwcStart = pwc;

    if ( *pwc == L'\\' && *(pwc+1) == L'\\' )
    {
        pwc += 2;

        // get past machine name

        while ( *pwc && *pwc != '\\' )
            pwc++;

        // get past slash

        if ( *pwc )
            pwc++;

        // get past share name

        while ( *pwc && *pwc != '\\' )
            pwc++;
    }
    else if ( *(pwc+1) == L':' )
        pwc += 2;

    // get to the first directory name

    while ( *pwc == L'\\' )
        pwc++;

    while ( *pwc )
    {
        if ( *pwc == L'\\' )
        {
            *pwc = 0;

            if (! CreateDirectory( pwcStart, 0 ) )

            {
                DWORD dw = GetLastError();
                if ( ERROR_ALREADY_EXISTS != dw )
                    return dw;
            }

            *pwc = L'\\';
        }

        pwc++;
    }

    return NO_ERROR;
} //CreateShellDirectoryTree

HRESULT MyCreateLink(LPCTSTR lpszProgram, LPCTSTR lpszArgs, LPCTSTR lpszLink, LPCTSTR lpszDir, LPCTSTR lpszIconPath, int iIconIndex)
{
    HRESULT hres;
    IShellLink* pShellLink;

    //CoInitialize must be called before this
    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance( CLSID_ShellLink,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IShellLink,
                             (LPVOID*)&pShellLink );
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile;

       // Set the path to the shortcut target, and add the description.
       pShellLink->SetPath(lpszProgram);
       pShellLink->SetArguments(lpszArgs);
       pShellLink->SetWorkingDirectory(lpszDir);
       pShellLink->SetIconLocation(lpszIconPath, iIconIndex);

       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);

       if (SUCCEEDED(hres))
       {
          WCHAR wsz[MAX_PATH];

          lstrcpyn(wsz, lpszLink, sizeof wsz / sizeof WCHAR);

          // Save the link by calling IPersistFile::Save.
          hres = pPersistFile->Save(wsz, TRUE);

          pPersistFile->Release();
       }

       pShellLink->Release();
    }
    else
    {
        isDebugOut(( "createlink can't create instance: 0x%x\n", hres ));
        isDebugOut(( "!!!likely some k2 partner component left OLE "
                     "initialized in an incompatible state!!!\n" ));
    }
    return hres;
}

BOOL MyDeleteLink(LPTSTR lpszShortcut)
{
    //
    // Don't try to delete what doesn't exist
    //

    if ( !DoesFileExist( lpszShortcut ) )
    {
        isDebugOut(( "deletelink: '%ws' doesn't exist\n", lpszShortcut ));
        return TRUE;
    }

    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory(szFile, sizeof(szFile));
    lstrcpyn(szFile, lpszShortcut, sizeof szFile / sizeof TCHAR);

    ZeroMemory(&fos, sizeof(fos));
    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.pFrom = szFile;
    fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
    SHFileOperation(&fos);

    return TRUE;
}

void AddShellLink(
    WCHAR const * pwcGroupPath,
    WCHAR const * pwcName,
    WCHAR const * pwcProgram,
    WCHAR const * pwcArgs )
{
    if ( !DoesFileExist( pwcGroupPath ) )
    {
        CreateShellDirectoryTree( pwcGroupPath );
        SHChangeNotify( SHCNE_MKDIR, SHCNF_PATH, pwcGroupPath, 0 );
    }

    unsigned cwc = wcslen( pwcGroupPath ) + 1 + wcslen( pwcName ) + wcslen( L".lnk" );

    if ( cwc >= MAX_PATH )
        return;

    WCHAR awcPath[ MAX_PATH ];
    wcscpy( awcPath, pwcGroupPath );
    wcscat( awcPath, L"\\" );
    wcscat( awcPath, pwcName );
    wcscat( awcPath, L".lnk" );

    MyCreateLink( pwcProgram, pwcArgs, awcPath, 0, 0, 0 );
} //AddShellLink

void DeleteShellLink(
    WCHAR const * pwcGroupPath,
    WCHAR const * pwcName )
{
    unsigned cwc = wcslen( pwcGroupPath ) + 1 + wcslen( pwcName ) + wcslen( L".lnk" );

    if ( cwc >= MAX_PATH )
        return;

    WCHAR awcPath[ MAX_PATH ];
    wcscpy( awcPath, pwcGroupPath );
    wcscat( awcPath, L"\\" );
    wcscat( awcPath, pwcName );
    wcscat( awcPath, L".lnk" );

    MyDeleteLink( awcPath );

    if ( IsDirEmpty( pwcGroupPath ) )
    {
        RemoveDirectory( pwcGroupPath );
        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pwcGroupPath, 0);
    }
} //DeleteShellLink
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\setupqry\setupqry.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       setupqry.cxx
//
//  Contents:   Indexing Service ocmgr installation routines
//
//  Wish-list:  Seek and destroy old webhits.exe files
//              Migrate all existing catalogs + virtual server catalogs
//
//  History:    8-Jan-97 dlee     Created
//              7-7-97   mohamedn changed to work with NT setup.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <xolemem.hxx>
#include "catcnfg.hxx"

DECLARE_INFOLEVEL( is )

#define COPY_FILES_EVEN_IF_INSTALLED

extern "C" ULONG DbgPrint( LPSTR Format, ... );

//
// external exported routines.
//
extern "C"
{
    BOOL WINAPI DllMain( IN HANDLE DllHandle,
                         IN DWORD  Reason,
                         IN LPVOID Reserved );

    DWORD IndexSrv(   IN     LPCWSTR ComponentId,
                      IN     LPCWSTR SubcomponentId,
                      IN     UINT    Function,
                      IN     UINT    Param1,
                      IN OUT PVOID   Param2 );
}

//
// DLL module instance handle
//
HINSTANCE MyModuleHandle;

//
// Utility routines
//
void    GetPreviousISSetupVersion(void);
DWORD   CompleteInstallation(CError &Err);
DWORD   QueueConfigurationParams( HINF hInf,
                                  HSPFILEQ Param2,
                                  WCHAR const * pwszSectionName,
                                  CError &Err );
DWORD   SetDefaultCatalog(CError &Err);
void    UpgradeIS1toIS3(CError & Err);

DWORD   SetFilterRegistryInfo( BOOL fUnRegister,CError &Err );
DWORD   SetDLLsToRegister(CError & Err);
void    ExcludeSpecialLocations( CCatalogConfig & Cat );
void    OcCleanup( CError & Err );
void    SetupW3Svc(CError &Err);
void DeleteNTOPStartMenu();

DWORD   AddPerfData( CError &Err );
DWORD   RemovePerfData(void);
DWORD   LoadCounterAndDelete( WCHAR const * pwcINI,
                              WCHAR const * pwcH,
                              CError &Err );

void    CreateSharedDllRegSubKey(void);
DWORD   AddRefSharedDll( WCHAR const * pwszDllName );
WCHAR * AppendMultiSZString(WCHAR * pwcTo, WCHAR const * pwcFrom );
DWORD   RegisterDll(WCHAR const * pwcDLL, CError &Err );

BOOL    IsSufficientMemory(void);
void    AddCiSvc(CError &Err);
DWORD   RenameCiSvc( SC_HANDLE hSC, CError &Err );
void    StopService( WCHAR const * pwszServiceName );
void    StartService( WCHAR const * pwszServiceName );
void    MyStartService( CServiceHandle & xSC,
                        WCHAR const    * pwcSVC );
BOOL    MyStopService( CServiceHandle & xSC,
                       WCHAR const *    pwcSVC,
                       BOOL  &          fStopped );
void    DeleteService( WCHAR const * pwszServiceName );


DWORD   SetRegBasedOnMachine(CError &Err);
DWORD   SetRegBasedOnArchitecture(CError &Err);
void    GetMachineInfo(BOOL & fLotsOfMem, DWORD & cCPU );

void DeleteShellLink( WCHAR const * pwcGroup,
                      WCHAR const * pwcName );

//
// hardcoded globals, obtained from is30.INF file
//
// [indexsrv]
INT     g_MajorVersion = 3;
INT     g_dwPrevISVersion = 0;
BOOL    g_fNT4_To_NT5_Upgrade = FALSE;
BOOL    g_fIS1x_To_NT5_Upgrade = FALSE;
BOOL    g_fCiSvcWasRunning = FALSE;
BOOL    g_fCiSvcIsRequested = FALSE;
WCHAR   g_awcSystemDir[MAX_PATH];          // system32 directory
WCHAR   g_awcSourcePath[MAX_PATH * 2];     // inf source location.
WCHAR   g_awcIS1Path[MAX_PATH+1];

OCMANAGER_ROUTINES g_HelperRoutines;

//
// globals needed for OCM
//
SETUP_INIT_COMPONENT     gSetupInitComponent;
BOOL    g_fBatchInstall    = FALSE;
BOOL    g_fInstallCancelled = TRUE;  // Similar to aborted, but caused by user cancel, not internal exception
BOOL    g_fInstallAborted  = FALSE;
BOOL    g_fComponentInitialized = FALSE;
BOOL    g_fUnattended      = FALSE;
BOOL    g_fUpgrade         = FALSE;
BOOL    g_fNtGuiMode       = TRUE;
DWORD   g_NtType           = -1;
BOOL    g_fLocallyOpened   = FALSE;

WCHAR   g_awcProfilePath[MAX_PATH];

WCHAR const * pwcIISAppKey = L"IndexingService";

//
// keep track if we're selected or not selected
//
BOOL        g_fFalseAlready = FALSE;
unsigned    g_cChangeSelection = 0;

//
// frequently used constants
//
const WCHAR wcsIndexsrvSystem[] = L"indexsrv_system";

//
// frequently used registry keys.
//
const WCHAR wcsRegAdminSubKey[] =
    L"System\\CurrentControlSet\\Control\\ContentIndex";
const WCHAR wcsRegCatalogsSubKey[] =
    L"System\\CurrentControlSet\\Control\\ContentIndex\\Catalogs";
const WCHAR wcsRegCatalogsWebSubKey[] =
    L"System\\CurrentControlSet\\Control\\ContentIndex\\Catalogs\\web";
const WCHAR wcsRegCatalogsWebPropertiesSubKey[] =
    L"System\\CurrentControlSet\\Control\\ContentIndex\\Catalogs\\web\\properties";
const WCHAR wcsAllowedPaths[] =
    L"System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg\\AllowedPaths";
const WCHAR wcsPreventCisvcParam[] = L"DonotStartCiSvc";
const WCHAR wcsISDefaultCatalogDirectory[] = L"IsapiDefaultCatalogDirectory";

const WCHAR wszRegProfileKey[] =
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
const WCHAR wszRegProfileValue[] = L"ProfilesDirectory";
const WCHAR wszProperties[] = L"properties";

//
// Directory name where system catalog will be placed
//

const WCHAR wszSysVolInfoDirectory[] = L"x:\\System Volume Information";

//
// Array of Dlls to register
//
static WCHAR * apwcDlls[] = {
    L"query.dll",
    L"ciadmin.dll",
    L"ixsso.dll",
    L"nlhtml.dll",
    L"offfilt.dll",
    L"ciodm.dll",
    L"infosoft.dll",
    L"mimefilt.dll",
    L"LangWrbk.dll",
};
const int cDlls = NUMELEM( apwcDlls );

static WCHAR * apwcOldDlls[] = {
    L"cifrmwrk.dll",
    L"fsci.dll",
};
const int cOldDlls = NUMELEM( apwcOldDlls );

//
// utility routines
//
BOOL          OpenInfFile(CError & Err);

CError::CError( )
{
    SetupOpenLog(FALSE); /* don't overwrite existing log file */
}

CError::~CError( )
{
    SetupCloseLog();
}

//+-------------------------------------------------------------------------
//
//  Member:    CError::Report
//
//  Synopsis:  reports a message to various destinations
//
//  Arguments: [LogSeverity]  -- message severity
//             [dwErr]        -- The error code
//             [MessageString]-- printf format string for message
//             [...]          -- variable arguments for message params
//
//  Returns:   none. don't throw.
//
//  History:   2-9-98  mohamedn
//
//--------------------------------------------------------------------------

void CError::Report(
    LogSeverity Severity,
    DWORD dwErr,
    WCHAR const * MessageString,
    ...)
{
    WCHAR awcMsgTemp[MAX_PATH * 2];

    awcMsgTemp[0] = _awcMsg[0] = L'\0';

    va_list va;
    va_start(va, MessageString);

    wvsprintf(awcMsgTemp, MessageString, va);

    va_end(va);

    // prepend on Our modules information.
    wsprintf(_awcMsg, L"setupqry: (%#x) %s\r\n", dwErr, awcMsgTemp);

    if ( !SetupLogError(_awcMsg, Severity) )
    {
        isDebugOut(( DEB_ERROR, "SetupLogError Failed: %d\n", GetLastError() ));
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   The usual suspect
//
//  Return:     TRUE        - Initialization succeeded
//              FALSE       - Initialization failed
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL WINAPI DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved )
{
    UNREFERENCED_PARAMETER(Reserved);

    switch( Reason )
    {
        WCHAR DllName[MAX_PATH];

        case DLL_PROCESS_ATTACH:

            MyModuleHandle = (HINSTANCE)DllHandle;

            DisableThreadLibraryCalls( MyModuleHandle );

            if (!GetModuleFileName(MyModuleHandle, DllName, MAX_PATH) ||
                !LoadLibrary( DllName ))
            {
                return FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
} //DllMain

//+-------------------------------------------------------------------------
//
//  Function:   IndexSrv
//
//  Synopsis:   Called by the ocmgr when things happen
//
//  Arguments:  ComponentId    -- "indexsrv_system"
//              SubcomponentId -- the .inf section being operated on
//              Function       -- the operation
//              Param1         -- operation paramater
//              Param2         -- operation paramater
//
//  Returns:    Win32 error code (usually), depends on Function
//
//
//--------------------------------------------------------------------------

DWORD IndexSrv(
    IN     LPCWSTR ComponentId,
    IN     LPCWSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2 )
{
    DWORD   dwRetVal = NO_ERROR;

    isDebugOut(( "IndexSrv, Function %d\n", Function ));

    //
    // if we're aborted, do nothing.
    //
    if ( g_fInstallAborted )
        return dwRetVal;

    CError  Err;

    CSmartException xSmartException;

    TRY
    {

        switch(Function)
        {

        case OC_PREINITIALIZE:
            isDebugOut(( "OC_PREINITIALIZE\n" ));

            GetSystemDirectory( g_awcSystemDir,
                                sizeof g_awcSystemDir / sizeof WCHAR );

            return OCFLAG_UNICODE;

            break;

        case OC_SET_LANGUAGE:
            isDebugOut(( "OC_SET_LANGUAGE\n" ));

            //
            // Param1 = low 16 bits specify Win32 LANG
            // Param2 = unused
            //
            // Return code is a boolean indicating whether we think we
            // support the requested language. We remember the language id
            // and say we support the language. A more exact check might involve
            // looking through our resources via EnumResourcesLnguages() for
            // example, or checking our inf to see whether there is a matching
            // or closely matching [strings] section. We don't bother with
            // any of that here.
            //
            // Locate the component and remember the language id for later use.
            //

            return TRUE;


        case OC_INIT_COMPONENT:
            isDebugOut(( "OC_INIT_COMPONENT\n" ));

            isDebugOut(( DEB_TRACE, "init_component: '%ws'\n", ComponentId ));

            if (OCMANAGER_VERSION <= ((PSETUP_INIT_COMPONENT)Param2)->OCManagerVersion)
            {
                ((PSETUP_INIT_COMPONENT)Param2)->ComponentVersion = OCMANAGER_VERSION;
            }
            else
            {
                ISError( IS_MSG_INVALID_OCM_VERSION, Err, LogSevFatalError );

                isDebugOut(( "wrong ocmgr version!\n" ));

                return ERROR_CALL_NOT_IMPLEMENTED;
            }

            if ( g_fInstallAborted )
            {
                ISError( IS_MSG_ABORT, Err, LogSevFatalError );

                dwRetVal = ERROR_CANCELLED;

                break;
            }

            //
            // Param1 = unused
            // Param2 = points to SETUP_INIT_COMPONENT structure
            //
            // Return code is Win32 error indicating outcome.
            // ERROR_CANCELLED means this component's install will be aborted.
            //
            // Even though this call happens once for each component that this
            // dll installs, we really only need to do our thing once.  This is
            // because the data that OCM passes is the same for all calls.
            //

             if (!g_fComponentInitialized)
             {
                 PSETUP_INIT_COMPONENT InitComponent = (PSETUP_INIT_COMPONENT)Param2;
                 g_HelperRoutines = InitComponent->HelperRoutines;

                 CopyMemory( &gSetupInitComponent, (LPVOID)Param2, sizeof(SETUP_INIT_COMPONENT) );

                 g_fUnattended = (gSetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) != 0;
                 g_fUpgrade    = (gSetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) != 0;
                 g_fNtGuiMode  = (gSetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE) == 0;
                 g_NtType      = gSetupInitComponent.SetupData.ProductType;

                 isDebugOut(( DEB_TRACE, "g_fUnattended: %d\n", g_fUnattended ));
                 isDebugOut(( DEB_TRACE, "g_fUpgrade:    %d\n", g_fUpgrade ));
                 isDebugOut(( DEB_TRACE, "g_fNtGuiMode:  %d\n", g_fNtGuiMode ));
                 isDebugOut(( DEB_TRACE, "g_NtType:      %d\n", g_NtType ));

                 if (gSetupInitComponent.ComponentInfHandle == NULL)
                 {
                     if ( !OpenInfFile(Err) )
                     {
                         ISError(IS_MSG_INVALID_INF_HANDLE, Err, LogSevFatalError);
                         dwRetVal = ERROR_CANCELLED;
                     }
                     else
                     {
                         g_fComponentInitialized = TRUE;
                         dwRetVal = NO_ERROR;
                     }
                 }

                 //
                 // determine if this an NT4-->NT5 upgrade
                 //

                 GetPreviousISSetupVersion();

                 if ( g_dwPrevISVersion > 0 && g_dwPrevISVersion < g_MajorVersion )
                 {
                     g_fNT4_To_NT5_Upgrade = TRUE;

                     // g_dwPrevIsVersion is 0 if the ContentIndex key doesn't exist

                     if ( 1 == g_dwPrevISVersion )
                         g_fIS1x_To_NT5_Upgrade = TRUE;
                 }
             }
             break;

        case OC_QUERY_STATE:
            isDebugOut(( "OC_QUERY_STATE\n" ));

            if ( !SubcomponentId || _wcsicmp(SubcomponentId,wcsIndexsrvSystem) )
                return NO_ERROR;

            //
            // We can't return SubcompUseOcManagerDefault if 1.x is installed
            // the ocmgr registry key for index server won't be set if 1.x was
            // installed using the non-ocmgr installation.  In this case, check
            // if the ContentIndex key exists and if so return SubcompOn.
            //

            if ( ( OCSELSTATETYPE_ORIGINAL == Param1 ) && g_fIS1x_To_NT5_Upgrade )
            {
                isDebugOut(( "Upgrading from 1.x to NT 5, turning on IS by default\n" ));
                isDebugOut(( DEB_ITRACE, "Upgrading from 1.x to NT 5, turning on IS by default\n" ));

                dwRetVal = SubcompOn;
            }
            else
                dwRetVal = SubcompUseOcManagerDefault;

            break;

        case OC_REQUEST_PAGES:
            isDebugOut(( "OC_REQUEST_PAGES\n" ));

            return 0;   // no pages
            // break;

        case OC_QUERY_CHANGE_SEL_STATE:
            isDebugOut(( "OC_QUERY_CHANGE_SEL_STATE\n" ));

            isDebugOut(( "queryChangeSelState %#x, %#x, %#x\n", SubcomponentId, Param1, Param2 ));

            if ( !SubcomponentId || _wcsicmp(SubcomponentId,wcsIndexsrvSystem) )
            {
                return NO_ERROR;
            }

            if ( Param1 == 0 )
            {
                //
                // we're not selected
                //
                if ( 0 == g_cChangeSelection || !g_fFalseAlready )
                {
                    g_cChangeSelection++;
                    g_fFalseAlready = TRUE;
                }

                g_fCiSvcIsRequested = FALSE;
            }
            else
            {
                //
                // we are selected
                //
                if ( 0 == g_cChangeSelection || g_fFalseAlready )
                {
                    g_cChangeSelection++;
                    g_fFalseAlready = FALSE;
                }

                g_fCiSvcIsRequested = TRUE;
            }

            dwRetVal = TRUE;

            break;


        case OC_CALC_DISK_SPACE:
            isDebugOut(( "OC_CALC_DISK_SPACE\n" ));

            //
            // skip, no files are copied.
            //

            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "Calc Disk Space Failed: %d\n", dwRetVal ));

                ISError( IS_MSG_CALC_DISK_SPACE_FAILED, Err, LogSevError );
            }

            break;

        case OC_QUEUE_FILE_OPS:
            isDebugOut(( "OC_QUEUE_FILE_OPS\n" ));

            //
            // Param1 = unused
            // Param2 = HSPFILEQ to operate on
            //
            // Return value is Win32 error code indicating outcome.
            //
            // OC Manager calls this routine when it is ready for files to be
            // copied to effect the changes the user requested. The component
            // DLL must figure out whether it is being installed or uninstalled
            // and take appropriate action.
            // For this sample, we look in the private data section for this
            // component/subcomponent pair, and get the name of an uninstall
            // section for the uninstall case.
            //
            // Note that OC Manager calls us once for the *entire* component
            // and then once per subcomponent.
            //

            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "Queue File Operations Failed: %d\n", dwRetVal ));

                ISError( IS_MSG_QUEUE_FILE_OPS_FAILED, Err, LogSevError );
            }

            break;

        case OC_QUERY_STEP_COUNT:
            isDebugOut(( "OC_QUERY_STEP_COUNT\n" ));

            //
            // Param1 = unused
            // Param2 = unused
            //
            // Return value is an arbitrary 'step' count or -1 if error.
            //
            // OC Manager calls this routine when it wants to find out how much
            // work the component wants to perform for nonfile operations to
            // install/uninstall a component/subcomponent.
            // It is called once for the *entire* component and then once for
            // each subcomponent in the component.
            //
            // One could get arbitrarily fancy here but we simply return 1 step
            // per subcomponent. We ignore the "entire component" case.
            //
            if ( !SubcomponentId || _wcsicmp( SubcomponentId,wcsIndexsrvSystem ) )
            {
                return NO_ERROR;
            }

            dwRetVal = 1;

            break;

        case OC_ABOUT_TO_COMMIT_QUEUE:
            isDebugOut(( "OC_ABOUT_TO_COMMIT_QUEUE\n" ));

            if ( !SubcomponentId || _wcsicmp( wcsIndexsrvSystem,SubcomponentId ) )
            {
                return NO_ERROR;
            }

            dwRetVal = QueueConfigurationParams( gSetupInitComponent.ComponentInfHandle,
                                                 (HSPFILEQ)  Param2,
                                                 SubcomponentId,
                                                 Err );
            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut((DEB_ERROR,"QueueConfigurationParams Failed: %d\n",dwRetVal ));

                ISError( IS_MSG_QUEUE_CONFIG_PARAMS_FAILED, Err, LogSevError, dwRetVal );

                return ERROR_CANCELLED;
            }

            dwRetVal = SetRegBasedOnMachine(Err);

            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "SetRegBasedOnMachine Failed: %d\n", dwRetVal ));

                ISError( IS_MSG_SetRegBasedOnMachine_FAILED, Err, LogSevError, dwRetVal );
            }

            dwRetVal = SetRegBasedOnArchitecture(Err);

            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "SetRegBasedOnArchitecture Failed: %d\n", dwRetVal ));

                Err.Report(LogSevError, dwRetVal, L"SetRegBasedOnArchitecture FAILED");
            }

            break;

        case OC_COMPLETE_INSTALLATION:
            isDebugOut(( "OC_COMPLETE_INSTALLATION\n" ));

            if ( !SubcomponentId || _wcsicmp(SubcomponentId,wcsIndexsrvSystem) )
            {
                return NO_ERROR;
            }

            dwRetVal = CompleteInstallation(Err);
            if ( NO_ERROR != dwRetVal )
            {
                isDebugOut(( DEB_ERROR, "CompleteInstallation Failed: %d\n", dwRetVal ));

                ISError( IS_MSG_COMPLETE_INSTALLATION_FAILED, Err, LogSevError, dwRetVal );

            }

            if ( g_fLocallyOpened &&
                 INVALID_HANDLE_VALUE != gSetupInitComponent.ComponentInfHandle )
            {
                SetupCloseInfFile(gSetupInitComponent.ComponentInfHandle);

                gSetupInitComponent.ComponentInfHandle = INVALID_HANDLE_VALUE;
            }

            g_fInstallCancelled = FALSE;
            break;

        case OC_CLEANUP:
            isDebugOut(( "OC_CLEANUP\n" ));

            //
            // Do last-minute work now that the metabase is installed
            //

            OcCleanup( Err );

            break;

        case OC_QUERY_IMAGE:
            isDebugOut(( "OC_QUERY_IMAGE\n" ));
            //
            // not used
            //
            break;

    default:
            isDebugOut(( "OC_ message ignored\n" ));
            break;
    }

    isDebugOut(( "IndexSrv is returning %d\n", dwRetVal ));

    return dwRetVal;

}
CATCH (CException, e)
{
    isDebugOut(( "install is aborted, error %#x\n", e.GetErrorCode() ));

    g_fInstallAborted = TRUE;

    if ( g_fLocallyOpened &&
         INVALID_HANDLE_VALUE != gSetupInitComponent.ComponentInfHandle )
    {
        SetupCloseInfFile(gSetupInitComponent.ComponentInfHandle);

        gSetupInitComponent.ComponentInfHandle = INVALID_HANDLE_VALUE;
    }

    ISError( IS_MSG_EXCEPTION_CAUGHT, Err, LogSevError, e.GetErrorCode() );

    dwRetVal = e.GetErrorCode();
}
END_CATCH

    return dwRetVal;
}

//+-------------------------------------------------------------------------
//
//  Function:   OcCleanup
//
//  Synopsis:   Finish setup work now that everything else is installed.  It
//              would be better to do this in OC_COMPLETE_INSTALLATION, but
//              there is no guarantee IIS is installed by that point.
//
//  History:    11-3-98      dlee       Created
//
//--------------------------------------------------------------------------

void OcCleanup( CError & Err )
{
    //
    // Add metabase settings if IIS is around
    //

    TRY
    {
        if ( !g_fInstallCancelled )
            SetupW3Svc(Err);
    }
    CATCH( CException, e )
    {
        // If IIS isn't installed then setting up w3svc will fail.  Ignore
        isDebugOut(( "caught %#x adding w3svc stuff\n", e.GetErrorCode() ));
    }
    END_CATCH

    //
    // Start cisvc service if it was running, we're selected, and not in
    // NT setup mode.
    //

    TRY
    {
        if ( ( g_fCiSvcWasRunning  && !g_cChangeSelection ) ||
             ( g_fCiSvcIsRequested && !g_fNtGuiMode && !g_fInstallCancelled )        )
        {
            StartService(L"CiSvc");
        }
    }
    CATCH( CException, e )
    {
        // Don't hose the install if we can't start the service
        isDebugOut(( "caught %#x starting service\n", e.GetErrorCode() ));
    }
    END_CATCH
} //OcCleanup

//+-------------------------------------------------------------------------
//
//  Function:   OpenInfFile
//
//  Synopsis:   opens a handle to setupqry.inf file
//
//  Returns:    True upon success, False upon failure.
//
//  History:   6-28-97      mohamedn        created
//
//--------------------------------------------------------------------------

BOOL OpenInfFile(CError & Err)
{
  WCHAR InfPath[MAX_PATH];

  DWORD dwRetVal = GetModuleFileName( MyModuleHandle, InfPath, NUMELEM(InfPath));

  InfPath[ NUMELEM( InfPath ) - 1 ] = 0;

  if ( 0 == dwRetVal )
  {
    isDebugOut(( DEB_ERROR, "GetModuleFileName() Failed: %d\n", GetLastError() ));

    return FALSE;
  }

  LPWSTR p = wcsrchr( InfPath, L'\\' );
  if (p)
  {
      wcscpy( p+1, L"setupqry.inf" );

      gSetupInitComponent.ComponentInfHandle = SetupOpenInfFile( InfPath, NULL, INF_STYLE_WIN4, NULL );

      if (gSetupInitComponent.ComponentInfHandle == INVALID_HANDLE_VALUE)
      {
        isDebugOut(( DEB_ERROR, "SetupOpenInfFile(%ws) Failed: %d\n", InfPath, GetLastError() ));

        return FALSE;
      }
  }
  else
  {
    return FALSE;
  }

  g_fLocallyOpened = TRUE;

  return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   QueueConfigurationParams
//
//  Synopsis:   queue-up an inf section to install
//
//  Returns:    NO_ERROR upon success, win32 error upon failure
//
//  History:   6-28-97      mohamedn        created
//
//--------------------------------------------------------------------------

DWORD QueueConfigurationParams( HINF hInf, HSPFILEQ Param2, WCHAR const * pwszSectionName, CError &Err )
{

    BOOL fOk = SetupInstallFromInfSection( 0,
                                           hInf,
                                           pwszSectionName,
                                           SPINST_REGISTRY,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0  );
    if ( !fOk )
    {
        isDebugOut(( DEB_ERROR, "SetupInstallFromInfSection(%ws) Failed: %d\n",
                                 pwszSectionName, GetLastError() ));

        ISError( IS_MSG_SETUP_INSTALL_FROM_INFSECTION_FAILED, Err,
                 LogSevError, GetLastError() );
    }

    return  ( fOk ? NO_ERROR : GetLastError() );
}

//+-------------------------------------------------------------------------
//
//  Function:   SetupW3Svc
//
//  Synopsis:   Setup catalogs and script mappings for IIS
//
//  Arguments:  [Err] -- Error reporting object
//
//  History:    13-May-1998   KyleP   Created
//
//--------------------------------------------------------------------------

void SetupW3Svc(CError &Err)
{
    BOOL fCurrentlyChecked = g_HelperRoutines.QuerySelectionState(
                       g_HelperRoutines.OcManagerContext,
                       wcsIndexsrvSystem,
                       OCSELSTATETYPE_CURRENT );

    isDebugOut(( "currently checked: %d\n", fCurrentlyChecked ));

    TRY
    {
        do
        {
            //
            // Initialize/Uninitialize COM.  Allow any old mode, and allow
            // for the fact that some other broken component may have left
            // COM initialized.
            //

            XCom xcom( TRUE );
            WCHAR awc[MAX_PATH];

            isDebugOut(( "SetupW3Svc\n" ));
            isDebugOut(( "  g_fCiSvcIsRequested: %d\n", g_fCiSvcIsRequested ));
            isDebugOut(( "  g_fNtGuiMode: %d\n", g_fNtGuiMode ));
            isDebugOut(( "  g_cChangeSelection: %d\n", g_cChangeSelection ));
            isDebugOut(( "  g_dwPrevISVersion: %d \n", g_dwPrevISVersion ));
            isDebugOut(( "  g_fUpgrade: %d\n", g_fUpgrade ));

            {
                //
                // Is W3Svc even installed?
                //

                CMetaDataMgr mdMgr( TRUE, W3VRoot );

                //
                // Guess so.  We didn't throw.  Now, add the script mappings if
                // if appropriate:
                //
                // If the checkbox is selected, add scriptmaps if
                //    clean install or
                //    add/remove and they changed the state of the checkbox
                //    upgrade and scriptmaps weren't deleted by hand by the user
                //
                // Delete scriptmaps if
                //    Checkbox is unchecked and there was a change in the selection state
                //
                // Note the state of the checked/unchecked variable g_fCiSvcIsRequested
                // is only valid in add/remove AND if the user has changed the selection.
                // So this code uses fCurrentlyChecked instead.
                //

                if ( ( fCurrentlyChecked ) &&
                     ( g_fNtGuiMode || ( 0 != g_cChangeSelection ) ) )
                {
                    //
                    // IDQ and WEBHITS are always in System32
                    //
    
                    if ( (MAX_PATH - wcslen(g_awcSystemDir)) < 30 )  // DLL won't fit
                        break;
    
                    wcscpy( awc, L".idq," );
                    wcscat( awc, g_awcSystemDir );
    
                    //
                    // Add IDQ if add/remove                        OR
                    //            clean install                     OR
                    //            there is already a scriptmap      OR
                    //            there already is a (possibly old) scriptmap pointing at the expected dll
                    //
                    //
                    // Note: the "IIS lockdown" tool points our scriptmaps at
                    //       404.dll; it doesn't delete them.  I have no idea why.
                    //
                    //
                    // scriptmap flags -- 0x2 is obsolete (apparently)
                    //
                    // #define MD_SCRIPTMAPFLAG_SCRIPT                     0x00000001
                    // #define MD_SCRIPTMAPFLAG_CHECK_PATH_INFO            0x00000004
                    //
                    // Can't check path info for .htw due to null.htw support
                    //

                    BOOL fAddSM = ( ( !g_fNtGuiMode ) ||
                                    ( g_fNtGuiMode && !g_fUpgrade ) ||
                                    ( 0 == g_dwPrevISVersion ) );

                    BOOL fAdded = FALSE;
    
                    wcscat( awc, L"\\idq.dll,7,GET,HEAD,POST" );
                    if ( fAddSM ||
                         ( mdMgr.ExtensionHasTargetScriptMap( L".idq", L"idq.dll" ) ) ) 
                    {
                        fAdded = TRUE;
                        mdMgr.AddScriptMap( awc );
                    }
    
                    //
                    // Add IDA if add/remove or there is already a valid scriptmap
                    //
    
                    awc[3] = L'a';
                    if ( fAddSM ||
                         ( mdMgr.ExtensionHasTargetScriptMap( L".ida", L"idq.dll" ) ) )
                    {
                        fAdded = TRUE;
                        mdMgr.AddScriptMap( awc );
                    }
    
                    //
                    // Add HTW if add/remove or there is already a valid scriptmap
                    //
    
                    wcscpy( awc, L".htw," );
                    wcscat( awc, g_awcSystemDir );
                    wcscat( awc, L"\\webhits.dll,3,GET,HEAD,POST" );
    
                    if ( fAddSM ||
                         ( mdMgr.ExtensionHasTargetScriptMap( L".htw", L"webhits.dll" ) ) ) 
                    {
                        fAdded = TRUE;
                        mdMgr.AddScriptMap( awc );
                    }
    
                    //
                    // Add IS script maps as in-process.  Always do this.
                    //
    
                    wcscpy( awc, g_awcSystemDir );
                    wcscat( awc, L"\\idq.dll" );
                    mdMgr.AddInProcessIsapiApp( awc );
    
                    //
                    // By default, run this OOP.  The user can run in IP if they need to
                    // webhit files on remote virtual roots.
                    //

                    #if 0
                        wcscpy( awc, g_awcSystemDir );
                        wcscat( awc, L"\\webhits.dll" );
                        mdMgr.AddInProcessIsapiApp( awc );
                    #endif

                    //
                    // Add the Appliation dependencies and restriction list like this:
                    //
                    // ApplicationDependencies  "Indexing Service;IndexingService"
                    //
                    // WebSvcExtRestrictionList:
                    //         "0,c:\windows\system32\idq.dll,0,IndexingService,Indexing Service
                    //         0,c:\windows\system32\webhits.dll,0,IndexingService,Indexing Service"
                    //

                    if ( fAdded )
                    {
                        // Delete anything left around from before

                        mdMgr.RemoveApplicationDependency( pwcIISAppKey );
                        mdMgr.RemoveRestrictionList( pwcIISAppKey );

                        // Add the new stuff if the service name isn't huge

                        CResString strSvcDisplayName( IS_SERVICE_NAME );
                        WCHAR awcTemp[ MAX_PATH * 2 ];

                        if ( wcslen( strSvcDisplayName.Get() ) < ( MAX_PATH - 50 ) )
                        {
                            wcscpy( awcTemp, strSvcDisplayName.Get() );
                            wcscat( awcTemp, L";" );
                            wcscat( awcTemp, pwcIISAppKey );
                            mdMgr.AddApplicationDependency( awcTemp );
    
                            wcscpy( awcTemp, L"0," );
                            wcscat( awcTemp, g_awcSystemDir );
                            wcscat( awcTemp, L"\\idq.dll,0," );
                            wcscat( awcTemp, pwcIISAppKey );
                            wcscat( awcTemp, L"," );
                            wcscat( awcTemp, strSvcDisplayName.Get() );
                            mdMgr.AddRestrictionList( awcTemp );
    
                            wcscpy( awcTemp, L"0," );
                            wcscat( awcTemp, g_awcSystemDir );
                            wcscat( awcTemp, L"\\webhits.dll,0," );
                            wcscat( awcTemp, pwcIISAppKey );
                            wcscat( awcTemp, L"," );
                            wcscat( awcTemp, strSvcDisplayName.Get() );
                            mdMgr.AddRestrictionList( awcTemp );
                        }
                    }
                }

                if ( ( !fCurrentlyChecked ) && ( 0 != g_cChangeSelection ) )
                {
                    mdMgr.RemoveScriptMap( L".idq" );
                    mdMgr.RemoveScriptMap( L".ida" );
                    mdMgr.RemoveScriptMap( L".htw" );

                    mdMgr.RemoveApplicationDependency( pwcIISAppKey );
                    mdMgr.RemoveRestrictionList( pwcIISAppKey );
                }

                //
                // Make sure it makes it out to disk
                //

                mdMgr.Flush();
            }

            //
            // Only create a web catalog if everything looks like a new install...
            //

            BOOL fNew = FALSE;

            TRY
            {
                CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegCatalogsWebSubKey );

                if ( reg.Ok() )
                {
                    WCHAR   wcsSubKeyName[MAX_PATH+1];
                    DWORD   cwcName = sizeof wcsSubKeyName / sizeof WCHAR;

                    if ( reg.Enum( wcsSubKeyName, cwcName ) )
                    {
                        // There is at least one subkey
                        do 
                        {
                            //
                            // if there is a subkey other than properties, 
                            // we're not createing a new web catalog
                            //
                            if ( 0 != _wcsicmp( wcsSubKeyName, wszProperties ) )
                            {
                                fNew = FALSE;
                                break;
                            }  
                            else
                                 fNew = TRUE;

                        } while ( reg.Enum( wcsSubKeyName, cwcName ) );
                    }
                    else
                        fNew = TRUE;
                }
                else 
                    fNew = TRUE;
            }
            CATCH( CException, e )
            {
                fNew = TRUE;
            }
            END_CATCH

            if ( !fNew )
                break;

            //
            // Must look like a default install...
            //

            CMetaDataMgr mdMgrDefaultServer( FALSE, W3VRoot, 1 );
            mdMgrDefaultServer.GetVRoot( L"/", awc );

            unsigned ccRoot = wcslen(awc) - 8;  // <path> - "\wwwroot"

            if ( 0 != _wcsicmp( awc + ccRoot, L"\\wwwroot" ) )
                break;

            awc[ccRoot] = 0;

            //
            // Add a web catalog.
            //

            CCatReg CatReg(Err);
            CatReg.Init( L"Web", awc );
            CatReg.TrackW3Svc();

            //
            // set ISAPIDefaultCatalogDirectory to Web
            //

            CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );

            if ( !reg.Set( wcsISDefaultCatalogDirectory, L"Web" ) )
            {
                ISError( IS_MSG_COULD_NOT_MODIFY_REGISTRY, Err,
                         LogSevWarning, GetLastError() );
                return;
            }
        } while(FALSE);

        isDebugOut(( "successfully added w3svc stuff\n" ));
    }
    CATCH( CException, e )
    {
        isDebugOut(( "caught %x in SetupW3Svc\n", e.GetErrorCode() ));
    }
    END_CATCH
}

//+-------------------------------------------------------------------------
//
//  Function:   CompleteInstallation
//
//  Synopsis:   called by NT setup to cofigure Index server for operation.
//
//  Returns:    SCODE, S_OK upon success, other values upon failure
//
//  History:    6-28-97      mohamedn        created
//
//--------------------------------------------------------------------------

DWORD CompleteInstallation(CError &Err)
{
    SCODE sc          = S_OK;
    DWORD dwRetVal    = 0;
    DWORD dwLastError = 0;

    //MessageBox(NULL, L"BREAK HERE", NULL, MB_OK);

    TRY
    {

       //
       // Delete the "DonotStartCiSvc" registry parameter
       //

       CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );
       reg.Remove(wcsPreventCisvcParam);

       dwRetVal = SetDLLsToRegister (Err);
       if ( NO_ERROR != dwRetVal )
       {
            isDebugOut(( DEB_ERROR, "SetDllsToRegister Failed: %d", dwRetVal ));

            ISError( IS_MSG_SetDllsToRegister_FAILED, Err, LogSevError, dwRetVal );

            THROW(CException(HRESULT_FROM_WIN32(dwRetVal)) );
       }

       dwRetVal = SetFilterRegistryInfo(FALSE, Err);
       if ( NO_ERROR != dwRetVal )
       {
            isDebugOut(( DEB_ERROR, "SetFilterRegistryInfo Failed: %d", dwRetVal ));

            ISError( IS_MSG_SetFilterRegistryInfo_FAILED, Err, LogSevError, dwRetVal );

            THROW(CException(HRESULT_FROM_WIN32(dwRetVal)) );
       }

       dwRetVal = AddPerfData(Err);
       if ( NO_ERROR != dwRetVal )
       {
            isDebugOut(( DEB_ERROR, "AddPerfData Failed: %d\n",dwRetVal));

            THROW(CException(HRESULT_FROM_WIN32(dwRetVal)) );
       }

       //
       // stop cisvc
       //

       StopService(L"cisvc");

       //
       // Upgrade 1.1 to 3.0 if needed.  Must happen *before* AddCiSvc().
       //

       UpgradeIS1toIS3(Err);

       //
       // Delete the NTOP start menu items IS created
       //

       DeleteNTOPStartMenu();

       //
       // configure catalogs
       //

       dwRetVal = SetDefaultCatalog(Err);

       if ( NO_ERROR != dwRetVal )
       {
            isDebugOut(( DEB_ERROR, "SetDefaultCatalog Failed: %d\n",dwRetVal));

            ISError( IS_MSG_SetDefaultCatalog_FAILED, Err, LogSevError, dwRetVal );

            THROW(CException(HRESULT_FROM_WIN32(dwRetVal)) );
       }

       //
       // if selection count is odd (user changed the selection),
       // delete the service to create a new one.  Also delete and
       // re-create if we're upgrading IS 1.x.
       //

       if ( ( !g_fUpgrade && ( g_cChangeSelection & 0x1 ) ) ||
            1 == g_dwPrevISVersion )
            DeleteService(L"cisvc");

       //
       // add the service
       //

       AddCiSvc(Err);
    }
    CATCH( CException, e )
    {
       isDebugOut(( DEB_ERROR, "Caught Exception in CompleteInstallation: %d\n",e.GetErrorCode() ));

       ISError( IS_MSG_EXCEPTION_CAUGHT, Err, LogSevError, e.GetErrorCode() );

       sc = e.GetErrorCode();
       isDebugOut(( "Caught Exception in CompleteInstallation: %#x\n", sc ));

    }
    END_CATCH

    return sc;

} //CompleteInstallation

//+-------------------------------------------------------------------------
//
//  Function:   UpgradeIS1toIS3
//
//  Synopsis:   sets ISapiDefaultCatalogDirectory param if we're upgrading
//              from 1.0 or 1.1 to 3.0
//
//  Returns:    none.
//
//  History:    01-May-1998      mohamedn        created
//              05-Sep-1998      KyleP           Start service on upgrade
//
//  Notes:      This *must* be called before AddCisvc, since the decision
//              about whether to start the service may be changed in
//              this function.
//
//--------------------------------------------------------------------------

void UpgradeIS1toIS3(CError &Err)
{
    if (  !g_fNT4_To_NT5_Upgrade  ||  g_dwPrevISVersion >= 2 )
    {
        return;
    }

    g_awcIS1Path[0] = L'\0';

    {
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );

        reg.Get( wcsISDefaultCatalogDirectory, g_awcIS1Path, NUMELEM( g_awcIS1Path ) );

        if ( 0 == wcslen(g_awcIS1Path) || g_awcIS1Path[1] != L':' )
        {
            //
            // nothing to do.
            //
            g_awcIS1Path[0] = L'\0';
            return;
        }
    }

    //
    // The 'Catalogs' key needs to be created.
    //

    {
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );
        BOOL fExisted;

        if ( !reg.CreateKey( L"Catalogs", fExisted ) )
        {
            DWORD dw = GetLastError();

            isDebugOut(( DEB_ERROR, "created catalogs subkey Failed: %d\n", dw ));

            ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, Err , LogSevFatalError, dw );

            return;
        }
    }

    //
    // create the web catalog
    //

    CCatReg CatReg(Err);

    CatReg.Init( L"Web", g_awcIS1Path );
    CatReg.TrackW3Svc();

    //
    // set ISAPIDefaultCatalogDirectory to Web
    //

    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );
    if ( !reg.Set( wcsISDefaultCatalogDirectory, L"Web" ) )
    {
        ISError(IS_MSG_COULD_NOT_MODIFY_REGISTRY , Err, LogSevWarning, GetLastError() );

        return;
    }

    //
    // CI was running before the upgrade, so make sure it is running after
    // the upgrade as well.
    //

    g_fCiSvcIsRequested = TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetPreviousISSetupVersion
//
//  Synopsis:   gets version of previous installed IS, if any.
//
//  Arguments:  none
//
//  Returns:    none
//
//  History:    10-16-97    mohamedn    created
//
//--------------------------------------------------------------------------

void GetPreviousISSetupVersion(void)
{
    HKEY  hKey   = 0;
    DWORD dwType = 0;
    DWORD dwVal  = 0;
    DWORD cb     = sizeof DWORD;

    //
    // If it's not an upgrade, don't try to get the previous version as someone is
    // now writing contentindex\DoNotStartCisvc to the registry so we would
    // otherwise assume it's an upgrade without this check.
    //

    if ( !g_fUpgrade )
        return;

    LONG lRetVal = RegOpenKeyEx( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey, 0, KEY_READ, &hKey );

    if ( ERROR_SUCCESS == lRetVal )
    {
        lRetVal = RegQueryValueEx( hKey,
                                   L"MajorVersion",
                                   0,
                                   &dwType,
                                   (BYTE *)&dwVal,
                                   &cb );
        if ( ERROR_SUCCESS == lRetVal )
            g_dwPrevISVersion = dwVal;
        else
            g_dwPrevISVersion = 1;  // We didn't write this key in V1.

        RegCloseKey( hKey );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:  SetDefaultCatalog
//
//  Synopsis:  Configures IS catalog for indexing local file system based on
//             available disk space.
//
//  Arguments: none
//
//  Returns:   ErrorSuccess upon success, error value upon failure.
//
//  History:   9-10-97  mohamedn
//
//--------------------------------------------------------------------------

DWORD SetDefaultCatalog(CError &Err)
{
    BOOL     fExisted;
    DWORD    dwRetVal = NO_ERROR;

    if ( !IsSufficientMemory() )
    {
        ISError( IS_MSG_BAD_MACHINE, Err, LogSevError );

        ISError( IS_MSG_NEEDED_HARDWARE, Err, LogSevError );

        return ERROR_SUCCESS;
    }

    {
        CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );

        if (!reg.CreateKey( L"Catalogs", fExisted ) )
        {
            DWORD dw = GetLastError();

            isDebugOut(( DEB_ERROR, "created catalogs subkey Failed: %d\n", dw ));

            ISError( IS_MSG_COULD_NOT_CONFIGURE_CATALOGS, Err , LogSevFatalError, dw );

            return dw;
        }
    }

    //
    // return if Catalogs key exists, don't overwrite existing configuration
    //
    if ( fExisted && !g_fNT4_To_NT5_Upgrade )
    {
        return ERROR_SUCCESS;
    }

    //
    // Find the default profile path (Usually %windir%\Profiles)
    //

    CWin32RegAccess regProfileKey( HKEY_LOCAL_MACHINE, wszRegProfileKey );

    g_awcProfilePath[0] = L'\0';
    WCHAR wcTemp[MAX_PATH+1];

    if ( regProfileKey.Get( wszRegProfileValue, wcTemp, NUMELEM(wcTemp) ) )
    {
        unsigned ccTemp2 = ExpandEnvironmentStrings( wcTemp,
                                                   g_awcProfilePath,
                                                   NUMELEM(g_awcProfilePath) );
    }

    CCatalogConfig   Cat(Err);
    Cat.SetName( L"System" );

    if ( !Cat.InitDriveList() )
    {
        ISError( IS_MSG_DRIVE_ENUMERATION_FAILED, Err, LogSevError, GetLastError() );

        return ERROR_INSTALL_FAILURE;
    }

    BOOL bRetVal = Cat.ConfigureDefaultCatalog( g_awcProfilePath );

    if (bRetVal)
    {
        //
        // add paths to exclude indexing IE temp files.
        //
        ExcludeSpecialLocations( Cat );

        //
        // Set the catalog location
        wcsncpy(wcTemp, wszSysVolInfoDirectory, sizeof wcTemp / sizeof WCHAR);
        wcTemp[ (sizeof wcTemp / sizeof WCHAR) - 1 ] = 0;
        wcTemp[0] = *(Cat.GetCatalogDrive());
        Cat.SetLocation( wcTemp );

        // NOTE:  The catalog path will be created when first accessed by
        //        CClientDocStore.

        Cat.SaveState();
    }

    return ( bRetVal ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE );
}

//+-------------------------------------------------------------------------
//
//  Function:   SetDLLsToRegister
//
//  Synopsis:   Sets the "DLLsToRegister" value in the registry
//
//  History:    19-Jun-97       t-elainc        Created
//
//--------------------------------------------------------------------------

DWORD SetDLLsToRegister(CError &Err)
{
    WCHAR * apwc2[cDlls];
    unsigned cwcTotal = 1;

    // store full pathnames in array 2

    for (int i = 0; i < cDlls; i++)
    {
        unsigned cwc = wcslen( g_awcSystemDir ) + 1 + wcslen( apwcDlls[i] );

        if ( cwc >= MAX_PATH )
            return 0;

        WCHAR filepath[MAX_PATH];
        wcscpy(filepath, g_awcSystemDir );
        wcscat(filepath,  L"\\" );
        wcscat(filepath, apwcDlls[i] );

        cwcTotal += ( cwc + 1 );

        apwc2[i] = new WCHAR[MAX_PATH];
        wcscpy(apwc2[i], filepath);
    }

    WCHAR * apwc2Old[cOldDlls];

    // store full old pathnames in array 2

    for (i = 0; i < cOldDlls; i++)
    {
        unsigned cwc = wcslen( g_awcSystemDir ) + 1 + wcslen( apwcOldDlls[i] );

        if ( cwc >= MAX_PATH )
            return 0;

        WCHAR filepath[MAX_PATH];
        wcscpy(filepath, g_awcSystemDir );
        wcscat(filepath,  L"\\" );
        wcscat(filepath, apwcOldDlls[i] );

        apwc2Old[i] = new WCHAR[MAX_PATH];
        wcscpy(apwc2Old[i], filepath);
    }

    if ( cwcTotal >= 4096 )
        return 0;

    unsigned cwcRemaining = 4096 - cwcTotal;

    WCHAR awc[4096];   //buffer for new list
    WCHAR *pwc = awc;  //pointer to list
    *pwc = 0;          //set first slot in array to null

    // put our dlls in the beginning

    for (int i = 0; i < cDlls; i++)
        pwc = AppendMultiSZString(pwc, apwc2[i]);
    
    CWin32RegAccess reg( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey );

    {
        WCHAR awcOld[4096]; //the old buffer list of files to register
        if ( reg.Get( L"DLLsToRegister",
                      awcOld,
                      sizeof awcOld / sizeof WCHAR ) )
        {
            WCHAR *p = awcOld;
            while ( 0 != *p )
            {
                // Leave dlls not in our list -- 3rd party dlls

                BOOL fFound = FALSE;
                for ( int i = 0; i < cDlls; i++ )
                {
                    if (!_wcsicmp(p, apwc2[i]) )
                    {
                        fFound = TRUE;
                        break;
                    }
                }

                // Remove old dlls from the list (fsci & cifrmwrk)

                if ( !fFound )
                {
                    for ( int i = 0; i < cOldDlls; i++ )
                    {
                        if (!_wcsicmp(p, apwc2Old[i]) )
                        {
                            fFound = TRUE;
                            break;
                        }
                    }
                }

                if (!fFound)
                {
                    cwcTotal += ( wcslen( p ) + 1 );

                    if ( cwcTotal >= 4096 )
                        return 0;

                    pwc = AppendMultiSZString(pwc, p);
                }

                p += ( wcslen(p) + 1 );
            }
        }

        *pwc++ = 0;
    }

    for (int j = 0; j < cDlls; j++)
        delete apwc2[j];

    for (j = 0; j < cOldDlls; j++)
        delete apwc2Old[j];

    if ( !reg.SetMultiSZ( L"DLLsToRegister",
                          awc,
                          (ULONG)(pwc-awc) * sizeof WCHAR ) )
    {
        DWORD dw = GetLastError();
        ISError( IS_MSG_COULD_NOT_MODIFY_REGISTRY, Err, LogSevFatalError, dw );
        return dw;
    }

    return NO_ERROR;
} //SetDLLsToRegister

//+-------------------------------------------------------------------------
//
//  Function:   AppendMultiSZString
//
//  Synopsis:   Copies one string to another.
//
//  Returns:    Pointer to one wchar beyond the end of the copy
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

WCHAR * AppendMultiSZString(
    WCHAR *       pwcTo,
    WCHAR const * pwcFrom )
{
    isDebugOut((DEB_TRACE, "language or dll installed: '%ws'\n", pwcFrom ));

    unsigned x = wcslen( pwcFrom );
    wcscpy( pwcTo, pwcFrom );
    return pwcTo + x + 1;
} //AppendMultiSZString

//+-------------------------------------------------------------------------
//
//  Function:   ExcludeSpecialLocations, private
//
//  Synopsis:   Writes profile-based exclude scopes into the registry
//
//  Arguments:  none
//
//  History:    28-Aug-1998   KyleP    Created
//
//--------------------------------------------------------------------------

WCHAR const wszRegShellSpecialPathsKey[] =
    L".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders";

WCHAR const * const awszRegShellSpecialPathsValue[] = {
    L"AppData",
    L"Local Settings"
};

WCHAR const wszUserProfile[] = L"%USERPROFILE%";

void ExcludeSpecialLocations( CCatalogConfig & Cat )
{
    //
    // First, find the default profile path (Usually %windir%\Profiles)
    //

    WCHAR wcTemp[MAX_PATH+1];

    if ( g_awcProfilePath[0] )
    {
        WCHAR wcTemp2[MAX_PATH+1];
        wcsncpy( wcTemp2, g_awcProfilePath, sizeof wcTemp2 / sizeof WCHAR );
        wcTemp2[ (sizeof wcTemp2 / sizeof WCHAR) - 1 ] = 0;
        unsigned ccTemp2 = wcslen( wcTemp2 );

        //
        // Append the wildcard, for user profile directory
        //

        wcscpy( wcTemp2 + ccTemp2, L"\\*\\" );
        ccTemp2 += 3;

        //
        // Go through and look for special shell paths, which just happen
        // to include all our special cases too.
        //

        CWin32RegAccess regShellSpecialPathsKey( HKEY_USERS, wszRegShellSpecialPathsKey );

        for ( unsigned i = 0;
              i < NUMELEM(awszRegShellSpecialPathsValue);
              i++ )
        {
            if ( regShellSpecialPathsKey.Get( awszRegShellSpecialPathsValue[i],
                                              wcTemp, NUMELEM(wcTemp), FALSE) )
            {
                if ( RtlEqualMemory( wszUserProfile, wcTemp,
                                     sizeof(wszUserProfile) - sizeof(WCHAR) ) )
                {
                    wcscpy( wcTemp2 + ccTemp2, wcTemp + NUMELEM(wszUserProfile) );
                    wcscpy( wcTemp, wcTemp2 );
                }
                
                if ( wcschr( wcTemp, L'%' ) != 0 )
                {
                    WCHAR wcTemp3[MAX_PATH+1];
                    unsigned ccTemp3 = ExpandEnvironmentStrings(
                                                                wcTemp,
                                                                wcTemp3,
                                                                NUMELEM(wcTemp3) );
                    if ( 0 != ccTemp3 )
                        wcscpy( wcTemp, wcTemp3 );
                }

                wcscat( wcTemp, L"\\*" );
                isDebugOut(( DEB_TRACE, "Exclude: %ws\n", wcTemp ));

                Cat.AddExcludedDirOrPattern( wcTemp );
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   AddPerfData
//
//  Synopsis:   Runs unlodctr and lodctr on Index Server perf data
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD AddPerfData(CError &Err)
{
    // add counters if installing

    DWORD dwError = NO_ERROR;

    // remove existing counters (if they exist)

    RemovePerfData();

    isDebugOut((DEB_TRACE, "Installing perf data\n" ));

    dwError = LoadCounterAndDelete( L"perfci.ini", L"perfci.h", Err );

    if ( ERROR_SUCCESS == dwError )
    {
        dwError = LoadCounterAndDelete( L"perffilt.ini", L"perffilt.h", Err );

        if ( ERROR_SUCCESS == dwError )
        {
            dwError = LoadCounterAndDelete( L"perfwci.ini", L"perfwci.h", Err );
        }
    }

    return NO_ERROR; // Ignore failures return dwError;
} //AddPerfData

//+-------------------------------------------------------------------------
//
//  Function:   LoadCounterAndDelete
//
//  Synopsis:   Loads perf counters for a .ini and a .h, then deletes
//              the files.  Assumes the files are in system32.
//
//  Arguments:  [pwcINI] -- Name w/o path of .ini file.
//              [pwcH]   -- Name w/o path of .h file.
//
//  History:    30-Jan-97 dlee     Created
//              23-May-97 KyleP    Use LoadPerfCounterTextStrings API
//
//--------------------------------------------------------------------------

DWORD LoadCounterAndDelete(
    WCHAR const * pwcINI,
    WCHAR const * pwcH,
    CError &Err)
{
    unsigned cwc = wcslen( L"lodctr " ) + wcslen( g_awcSystemDir ) + 1 + wcslen( pwcINI );

    if ( cwc >= MAX_PATH )
        return 0;

    WCHAR awc[MAX_PATH];

    WCHAR const awcLodctr[] = L"lodctr ";

    wcscpy( awc, awcLodctr );
    wcscat( awc, g_awcSystemDir );
    wcscat( awc, L"\\" );
    wcscat( awc, pwcINI );

    DWORD dwError = (DWORD)LoadPerfCounterTextStrings( awc,       // .INI file
                                                       TRUE );    // Quiet mode

    if ( ERROR_SUCCESS != dwError )
    {
        isDebugOut(( DEB_ERROR, "Error %d from LoadPerfCounterTextStrings %ws\n", dwError, awc ));
        isDebugOut(( "Error %d from LoadPerfCounterTextStrings %ws\n", dwError, awc ));

        ISError( IS_MSG_LoadPerfCounterTextStrings_FAILED, Err, LogSevError, dwError );

        return dwError;
    }

    return dwError;
} //LoadCounterAndDelete

//+-------------------------------------------------------------------------
//
//  Function:   RemovePerfData
//
//  Synopsis:   Runs unlodctr and lodctr on Index Server perf data
//
//  History:    08-Jan-97 dlee     Created
//              23-May-97 KyleP    Use UnloadPerfCounterTextStrings API
//
//--------------------------------------------------------------------------

DWORD RemovePerfData()
{
    // remove existing counters (if they exist )

    DWORD dw0 = (DWORD)UnloadPerfCounterTextStrings( L"unlodctr ContentIndex",  // Key
                                                     TRUE );           // Quiet mode

    DWORD dw1 = (DWORD)UnloadPerfCounterTextStrings( L"unlodctr ContentFilter", // Key
                                                     TRUE );           // Quiet mode

    DWORD dw2 = (DWORD)UnloadPerfCounterTextStrings( L"unlodctr ISAPISearch",   // Key
                                                     TRUE );           // Quiet mode

    if ( NO_ERROR != dw0 )
    {
        isDebugOut(( DEB_ERROR, "RemovePerfData: unlodctr ContentIndex failed with 0x%x\n", dw0));
        return dw0;
    }
    else if ( NO_ERROR != dw1 )
    {
        isDebugOut(( DEB_ERROR, "RemovePerfData: unlodctr ContentFilter failed with 0x%x\n", dw1));
        return dw1;
    }
    else
    {
        if ( NO_ERROR != dw2 )
        {
            isDebugOut(( DEB_ERROR, "RemovePerfData: unlodctr ISAPISearch failed with 0x%x\n", dw0));
        }
        return dw2;
    }
} //RemovePerfData


//+-------------------------------------------------------------------------
//
//  Function:   IsSufficientMemory
//
//  Synopsis:   Determines available physical memory
//
//  Arguments:  none
//
//  Returns:    TRUE  if physical memory > required phys. memory
//              FALSE otherwise.
//
//  History:    6-27-97     mohamedn  created
//
//--------------------------------------------------------------------------

BOOL IsSufficientMemory(void)
{
    // 32MB RAM.machine, taking into account up to 1M used by the system.
    const ULONGLONG MIN_PHYSICAL_MEMORY = 30*ONE_MB;

    MEMORYSTATUSEX memoryStatus;

    RtlZeroMemory(&memoryStatus, sizeof memoryStatus );

    memoryStatus.dwLength = sizeof memoryStatus;

    GlobalMemoryStatusEx(&memoryStatus);

    return ( MIN_PHYSICAL_MEMORY <= memoryStatus.ullTotalPhys );
}

//+-------------------------------------------------------------------------
//
//  Function:   AddCiSvc
//
//  Synopsis:   Creates the cisvc service
//
//  Arguments:  [Err] -- The error object to update
//
//  Returns:    none - throws upon fatal failure
//
//  History:    6-29-97     mohamedn  created
//
//--------------------------------------------------------------------------

void AddCiSvc(CError &Err)
{
    DWORD dwLastError = 0;

    SC_HANDLE hSC = OpenSCManager( 0, 0, SC_MANAGER_CREATE_SERVICE );

    CServiceHandle xhSC(hSC);

    if( 0 == hSC )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ITRACE, "OpenSCManager() Failed: %x\n", dwLastError ));

        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }

    WCHAR wszServiceDependencyList[MAX_PATH];

    RtlZeroMemory(wszServiceDependencyList, MAX_PATH * sizeof WCHAR );

    wcscpy( wszServiceDependencyList, L"RPCSS" );

    WCHAR wszServicePath[300];

    unsigned cwc = wcslen( g_awcSystemDir ) + wcslen( L"\\cisvc.exe" );

    if ( cwc >= ( sizeof wszServicePath / sizeof WCHAR ) )
        return;

    wcscpy(wszServicePath, g_awcSystemDir );
    wcscat(wszServicePath, L"\\cisvc.exe" );

    do
    {
        dwLastError = 0;

        CResString strSvcDisplayName(IS_SERVICE_NAME);

        SC_HANDLE hNewSC = CreateService( hSC,           // handle to SCM database
                             TEXT("cisvc"),              // pointer to name of service to start
                             strSvcDisplayName.Get(),    // pointer to display name
                             SERVICE_ALL_ACCESS,         // type of access to service
                             SERVICE_WIN32_SHARE_PROCESS, // type of service
                             g_fCiSvcIsRequested ?
                                 SERVICE_AUTO_START :
                                 SERVICE_DISABLED,       // when to start service
                             SERVICE_ERROR_NORMAL,       // severity if service fails to start
                             wszServicePath,
                             NULL,                       // pointer to name of load ordering group
                             NULL,                       // pointer to variable to get tag identifier
                             wszServiceDependencyList,   // pointer to array of dependency names
                             NULL,                       // pointer to account name of service
                             NULL                        // pointer to password for service account
                           );

        CServiceHandle xService( hNewSC );

        if ( 0 == hNewSC )
        {
            dwLastError = GetLastError();

            if ( ERROR_SERVICE_EXISTS == dwLastError )
                dwLastError = RenameCiSvc( hSC, Err );
            else if ( ERROR_SERVICE_MARKED_FOR_DELETE != dwLastError )
            {
                isDebugOut(( DEB_ERROR, "CreateService() Failed: %x\n", dwLastError ));

                ISError( IS_MSG_CreateService_FAILED, Err, LogSevError, dwLastError );

                THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
            }
        }
        else
        {
            xService.Free();

            // We added the service, now set the description.

            RenameCiSvc( hSC, Err );
        }
    } while ( ERROR_SERVICE_MARKED_FOR_DELETE == dwLastError );
} //AddCiSvc

//+-------------------------------------------------------------------------
//
//  Function:   RenameCiSvc
//
//  Synopsis:   Renames the cisvc service to "Indexing Service".
//
//  History:    05-Sep-1998   KyleP     Created
//
//--------------------------------------------------------------------------

DWORD RenameCiSvc( SC_HANDLE hSC, CError &Err)
{
    DWORD     dwLastError = 0;

    SC_HANDLE hCisvc = OpenService( hSC, L"cisvc", SERVICE_CHANGE_CONFIG );

    CServiceHandle xhCisvc( hCisvc );

    if( 0 == hCisvc )
    {
        dwLastError = GetLastError();
        isDebugOut(( DEB_ERROR, "OpenService(cisvc) Failed: 0x%x\n", dwLastError ));
        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }

    CResString strSvcDisplayName(IS_SERVICE_NAME);

    if ( !ChangeServiceConfig( hCisvc,               // handle to service
                               SERVICE_NO_CHANGE,    // type of service
                               SERVICE_NO_CHANGE,    // when to start service
                               SERVICE_NO_CHANGE,    // severity if service fails to start
                               0,                    // pointer to service binary file name
                               0,                    // pointer to load ordering group name
                               0,                    // pointer to variable to get tag identifier
                               0,                    // pointer to array of dependency names
                               0,                    // pointer to account name of service
                               0,                    // pointer to password for service account
                               strSvcDisplayName.Get() ) )   // pointer to display name);
    {
        dwLastError = GetLastError();
    }

    SERVICE_DESCRIPTION sd;
    CResString strSvcDescription(IS_SERVICE_DESCRIPTION);
    sd.lpDescription = (WCHAR *)strSvcDescription.Get();

    if ( !ChangeServiceConfig2( hCisvc,
                                SERVICE_CONFIG_DESCRIPTION,
                                (LPVOID)&sd
                              )
       )
        dwLastError = GetLastError();

    return dwLastError;
}

//+-------------------------------------------------------------------------
//
//  Function:   StopService
//
//  Synopsis:   stops service by name
//
//  Arguments:  pwszServiceName  - name of service to stop.
//
//  Returns:    none - throws upon fatal failure
//
//  History:    6-29-97     mohamedn  created
//
//--------------------------------------------------------------------------

void StopService( WCHAR const * pwszServiceName )
{
    DWORD     dwLastError = 0;

    SC_HANDLE hSC = OpenSCManager( 0, 0, SC_MANAGER_ALL_ACCESS );

    CServiceHandle  xhSC(hSC);

    if( 0 == hSC )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ERROR, "OpenSCManager() Failed: %x\n", dwLastError ));

        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }

    //
    // stop cisvc
    //
    BOOL fStopped = FALSE;

    if ( !MyStopService( xhSC, pwszServiceName, fStopped ) && !fStopped )
    {
        //
        // don't throw here
        //
        isDebugOut(( DEB_ERROR, "Failed to stop cisvc service" ));
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   StartService
//
//  Synopsis:   start service by name
//
//  Arguments:  pwszServiceName  - name of service to stop.
//
//  Returns:    none
//
//  History:    6-29-97     mohamedn  created
//
//--------------------------------------------------------------------------

void StartService( WCHAR const * pwszServiceName )
{
    DWORD     dwLastError = 0;

    SC_HANDLE hSC = OpenSCManager( 0, 0, SC_MANAGER_ALL_ACCESS );

    CServiceHandle  xhSC(hSC);

    if( 0 == hSC )
    {
        isDebugOut(( DEB_ERROR, "OpenSCManager() Failed: %x\n", GetLastError() ));
    }
    else
    {
        //
        // start cisvc
        //
        MyStartService( xhSC, pwszServiceName );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyStartService
//
//  Synopsis:   Starts a given service
//
//  Arguments:  xSC         -- the service control manager
//              pwcService  -- name of the service to start
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

void MyStartService(
    CServiceHandle & xSC,
    WCHAR const *    pwcService )
{
    CServiceHandle xSVC( OpenService( xSC.Get(),
                                      pwcService,
                                      SERVICE_START |
                                      GENERIC_READ | GENERIC_WRITE ) );
    if ( 0 != xSVC.Get() )
    {
        if ( !StartService( xSVC.Get(), 0, 0 ) )
        {
            isDebugOut(( DEB_ERROR, "Failed to start '%ws': %d\n", pwcService, GetLastError() ));
        }
    }

} //MyStartService

//+-------------------------------------------------------------------------
//
//  Function:   IsSvcRunning
//
//  Synopsis:   Determines if a service is running
//
//  Arguments:  xSC      -- the service control manager
//
//  Returns:    TRUE if the service is running, FALSE otherwise
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL IsSvcRunning( CServiceHandle &x )
{
    SERVICE_STATUS svcStatus;
    if ( QueryServiceStatus( x.Get(), &svcStatus ) )
        return SERVICE_STOP_PENDING == svcStatus.dwCurrentState ||
               SERVICE_RUNNING == svcStatus.dwCurrentState ||
               SERVICE_PAUSED == svcStatus.dwCurrentState;

    return FALSE;
} //IsSvcRunning

//+-------------------------------------------------------------------------
//
//  Function:   MyStopService
//
//  Synopsis:   Stops a given service
//
//  Arguments:  xSC      -- the service control manager
//              pwcSVC   -- name of the service to stop
//
//  Returns:    TRUE if the service was stopped
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL MyStopService(
    CServiceHandle & xSC,
    WCHAR const *    pwcSVC,
    BOOL &           fStopped )
{
    fStopped = FALSE;
    BOOL fOK = TRUE;

    CServiceHandle xSVC( OpenService( xSC.Get(),
                                      pwcSVC,
                                      SERVICE_STOP |
                                      GENERIC_READ | GENERIC_WRITE ) );
    if ( 0 != xSVC.Get() )
    {
        SERVICE_STATUS svcStatus;
        if ( IsSvcRunning( xSVC ) )
        {
            g_fCiSvcWasRunning = TRUE;

            if ( ControlService( xSVC.Get(),
                                 SERVICE_CONTROL_STOP,
                                 &svcStatus ) )
            {
                for ( unsigned i = 0; i < 30 && IsSvcRunning( xSVC ); i++ )
                {
                    isDebugOut(( DEB_ITRACE, "sleeping waiting for service '%ws' to stop\n", pwcSVC ));
                    Sleep( 1000 );
                }

                if ( IsSvcRunning( xSVC ) )
                {
                    THROW( CException( E_FAIL ) );
                }

                isDebugOut(( DEB_TRACE, "stopped service '%ws'\n", pwcSVC ));
                fStopped = TRUE;
            }
            else
            {
                DWORD dw = GetLastError();
                isDebugOut(( DEB_ERROR, "can't stop service '%ws', error %d\n", pwcSVC, dw ));

                // failures other than timeout and out-of-control are ok

                if ( ERROR_SERVICE_REQUEST_TIMEOUT == dw ||
                     ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dw )
                     fOK = FALSE;
            }
        }
    }

    return fOK;
} //MyStopService

//+-------------------------------------------------------------------------
//
//  Function:   DeleteService
//
//  Synopsis:   deletes a service by name
//
//  Arguments:  pwszServiceName - name of service to delete
//
//  Returns:    none - throws upon fatal failure
//
//  History:    6-29-97     mohamedn  created
//
//--------------------------------------------------------------------------

void DeleteService( WCHAR const * pwszServiceName )
{
    DWORD     dwLastError = 0;

    SC_HANDLE hSC = OpenSCManager( 0, 0, SC_MANAGER_ALL_ACCESS );

    CServiceHandle  xhSC(hSC);

    if( 0 == hSC )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ERROR, "OpenSCManager() Failed: %x\n", dwLastError ));

        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }

    SC_HANDLE hCiSvc = OpenService( hSC, pwszServiceName, DELETE );

    CServiceHandle xhCiSvc( hCiSvc );

    if ( 0 == hCiSvc )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ERROR, "OpenService(Cisvc for delete) Failed: %x\n", dwLastError ));

    }
    else if ( !DeleteService(hCiSvc) )
    {
        dwLastError = GetLastError();

        isDebugOut(( DEB_ERROR, "DeleteService(Cisvc) Failed: %x\n", dwLastError ));

        THROW( CException(HRESULT_FROM_WIN32(dwLastError)) );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   ISError
//
//  Synopsis:   Reports a non-recoverable Index Server Install error
//
//  Arguments:  id  -- resource identifier for the error string
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

void ISError( UINT id, CError &Err, LogSeverity Severity, DWORD dwErr )
{
    CResString msg( id );
    CResString title( IS_MSG_INDEX_SERVER );

    Err.Report( Severity, dwErr, msg.Get() );

    if ( LogSevFatalError == Severity )
    {
        isDebugOut(( "ISError, error %#x abort install: '%ws'\n",
                     dwErr, msg.Get() ));

        isDebugOut(( DEB_ERROR, "ISError, error %#x abort install: '%ws'\n",
                     dwErr, msg.Get() ));

        g_fInstallAborted = TRUE;
    }

} //ISError

//+-------------------------------------------------------------------------
//
//  Function:   Exec
//
//  Synopsis:   Runs an app and waits for it to complete
//
//  History:    8-Jan-97 dlee     Created from cistp.dll code
//
//--------------------------------------------------------------------------

void Exec(
    WCHAR * pwc )
{
    isDebugOut(( "exec: '%ws'\n", pwc ));

    STARTUPINFO si;
    RtlZeroMemory( &si, sizeof si );

    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;

    PROCESS_INFORMATION pi;

    if ( CreateProcess( 0,      // pointer to name of executable module
                        pwc,    // pointer to command line string
                        0,      // pointer to process security attributes
                        0,      // pointer to thread security attributes
                        FALSE,  // handle inheritance flag
                        0,      // creation flags
                        0,      // pointer to new environment block
                        0,      // pointer to current directory name
                        &si,    // pointer to STARTUPINFO
                        &pi ) ) // pointer to PROCESS_INFORMATION
    {
        WaitForSingleObject( pi.hProcess, 0xFFFFFFFF );
    }
} //Exec

//+-------------------------------------------------------------------------
//
//  Function:   RegisterDll
//
//  Synopsis:   Calls DllRegisterServer on a given dll
//
//  Returns:    Win32 error code
//
//  History:    21-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD RegisterDll(WCHAR const * pwcDLL, CError &Err )
{
    DWORD dwErr = NO_ERROR;

    // All Index Server dlls are currently in system32

    TRY
    {
        unsigned cwc = wcslen( g_awcSystemDir ) + 1 + wcslen( pwcDLL );

        if ( cwc >= MAX_PATH )
            return 0;

        WCHAR awcPath[ MAX_PATH ];
        wcscpy( awcPath, g_awcSystemDir );
        wcscat( awcPath, L"\\" );
        wcscat( awcPath, pwcDLL );

        HINSTANCE hDll = LoadLibraryEx( awcPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );

        if( 0 != hDll )
        {
            SCODE (STDAPICALLTYPE *pfnDllRegisterServer)();
            pfnDllRegisterServer = (HRESULT (STDAPICALLTYPE *)())
                GetProcAddress(hDll, "DllRegisterServer");

            if ( 0 != pfnDllRegisterServer )
            {
                SCODE sc = (*pfnDllRegisterServer)();
                if ( S_OK != sc )
                {
                    isDebugOut(( DEB_ERROR, "dllregister server '%ws' failed 0x%x\n",
                                             awcPath, sc));

                    ISError(IS_MSG_DllRegisterServer_FAILED ,Err, LogSevError, sc );

                    // no way to map a scode to a win32 error

                    dwErr = sc; // kylep suggested this would be valuable.
                }
            }
            else
                dwErr = GetLastError();

            FreeLibrary( hDll );
        }
        else
        {
            dwErr = GetLastError();
        }

        isDebugOut((DEB_TRACE, "result of registering '%ws': %d\n", awcPath, dwErr ));

#ifdef _WIN64

        //
        // Register the 32 bit version of the DLL
        //

        WCHAR awcSysWow64[ MAX_PATH ];

        cwc = GetSystemWow64Directory( awcSysWow64, sizeof awcSysWow64 / sizeof WCHAR );

        if ( 0 == cwc )
            return GetLastError();

        if ( L'\\' != awcSysWow64[ cwc - 1 ] )
        {
            awcSysWow64[ cwc++ ] = '\\';
            awcSysWow64[ cwc ] = 0;
        }

        WCHAR awcCmd[ MAX_PATH * 2 ];

        wcscpy( awcCmd, awcSysWow64 );
        wcscat( awcCmd, L"regsvr32 /s " );

        wcscat( awcCmd, awcSysWow64 );
        wcscat( awcCmd, pwcDLL );

        Exec( awcCmd );

#endif //_WIN64

    }
    CATCH( CException, e )
    {
        // ignore, since it's probably the new html filter

        isDebugOut(( "caught %#x registering '%ws'\n",
                     e.GetErrorCode(),
                     pwcDLL ));
    }
    END_CATCH

    return dwErr; // used to return 0 to avoid returning error!
} //RegisterDll

//+-------------------------------------------------------------------------
//
//  Function:   UnregisterDll
//
//  Synopsis:   Calls DllUnregisterServer on a given dll
//
//  Returns:    Win32 error code
//
//  History:    21-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD UnregisterDll(
    WCHAR const * pwcDLL )
{
    UINT uiOld = SetErrorMode( SEM_NOOPENFILEERRORBOX |
                               SEM_FAILCRITICALERRORS );

    TRY
    {
        // All Index Server dlls are currently in system32

        unsigned cwc = wcslen( g_awcSystemDir ) + 1 + wcslen( pwcDLL );

        if ( cwc >= MAX_PATH )
            return 0;

        WCHAR awcPath[ MAX_PATH ];

        wcscpy( awcPath, g_awcSystemDir );
        wcscat( awcPath, L"\\" );
        wcscat( awcPath, pwcDLL );

        // don't display popups if a dll can't be loaded when trying to
        // unregister.

        DWORD dwErr = NO_ERROR;

        HINSTANCE hDll = LoadLibraryEx( awcPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );

        if( 0 != hDll )
        {
            SCODE (STDAPICALLTYPE *pfnDllUnregisterServer)();
            pfnDllUnregisterServer = (HRESULT (STDAPICALLTYPE *)())
                GetProcAddress(hDll, "DllUnregisterServer");

            if ( 0 != pfnDllUnregisterServer )
            {
                SCODE sc = (*pfnDllUnregisterServer)();
                if ( S_OK != sc )
                    dwErr = ERROR_INVALID_FUNCTION;
            }
            else
                dwErr = GetLastError();

            FreeLibrary( hDll );
        }
        else
        {
            dwErr = GetLastError();
        }

        isDebugOut((DEB_TRACE, "result of unregistering '%ws': %d\n", awcPath, dwErr ));
    }
    CATCH( CException, e )
    {
        // ignore, since it's probably the new html filter
    }
    END_CATCH

    SetErrorMode( uiOld );

    return 0; // explicitly ignore unregister errors
} //UnregisterDll

//+-------------------------------------------------------------------------
//
//  Function:   SetFilterRegistryInfo
//
//  Synopsis:   Installs registry info for Index Server filters
//
//  Returns:    Win32 error code
//
//  History:    8-Jan-97 dlee       Created
//              7-01-97  mohamedn   cleanedup for IS3.0 with NT5.0 setup.
//
//--------------------------------------------------------------------------

DWORD SetFilterRegistryInfo( BOOL fUnRegister, CError &Err )
{
    if ( fUnRegister )
    {
        // try to unregister old dlls

        UnregisterDll( L"query.dll" );
        UnregisterDll( L"htmlfilt.dll" );
        UnregisterDll( L"nlfilt.dll" );
        UnregisterDll( L"sccifilt.dll" );
        UnregisterDll( L"ciadmin.dll" );

        UnregisterDll( L"cifrmwrk.dll" );
        UnregisterDll( L"fsci.dll" );
        UnregisterDll( L"OffFilt.dll" );

        UnregisterDll( L"ixsso.dll" );
        UnregisterDll( L"ciodm.dll" );
        UnregisterDll( L"infosoft.dll" );
        UnregisterDll( L"mimefilt.dll" );
        UnregisterDll( L"LangWrBk.dll" );
    }
    else
    {
        // call the .dlls to have them registered

        for ( unsigned i = 0; i < cDlls; i++ )
        {
            DWORD dwErr = RegisterDll( apwcDlls[i], Err );
            if ( NO_ERROR != dwErr )
            {
                isDebugOut(( DEB_ERROR, "Failed to register(%ws): error code: %d\n",
                             apwcDlls[i], dwErr ));

                ISError(IS_MSG_DLL_REGISTRATION_FAILED , Err, LogSevError, dwErr );

                return dwErr;
            }
        }
    }

    return NO_ERROR;
} //SetFilterregistryInfo

//+-------------------------------------------------------------------------
//
//  Function:   SetRegBasedOnMachine
//
//  Synopsis:   Sets Index Server registry tuning paramaters based on the
//              capabilities of the machine.  Uninstall is .inf-based.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

DWORD SetRegBasedOnMachine(CError &Err)
{
    if ( 0 == gSetupInitComponent.ComponentInfHandle )
    {
        ISError( IS_MSG_INVALID_INF_HANDLE, Err, LogSevError );

        return NO_ERROR;
    }

    WCHAR * pwcInf = 0;
    BOOL    fServer = FALSE;

    switch(g_NtType)
    {
        case PRODUCT_SERVER_STANDALONE:
        case PRODUCT_SERVER_PRIMARY:
        case PRODUCT_SERVER_SECONDARY:
             {
                BOOL fLotsOfMem;
                DWORD cCpu;
                GetMachineInfo( fLotsOfMem, cCpu );

                if ( fLotsOfMem )
                {
                    if ( 1 == cCpu )
                        pwcInf = L"IndexSrv_Large";
                    else if ( 2 == cCpu )
                        pwcInf = L"IndexSrv_LargeMP2";
                    else
                        pwcInf = L"IndexSrv_LargeMPMany";
                }
                else
                {
                    if ( 1 == cCpu )
                        pwcInf = L"IndexSrv_Small";
                    else
                        pwcInf = L"IndexSrv_SmallMP2";
                }
             }

             fServer = TRUE;

             break;

        case PRODUCT_WORKSTATION:
        default:
             pwcInf = L"IndexSrv_Workstation";
    }

    if ( !SetupInstallFromInfSection( 0,
                                      gSetupInitComponent.ComponentInfHandle,
                                      pwcInf,
                                      SPINST_REGISTRY,
                                      0, 0, 0, 0, 0, 0, 0 ) )
        return GetLastError();

    // If a server, allow catalogs key to be read-only visible
    // to the world.  See KB Q155363

    // Note: In Win2k, the professional version requires this as well,
    // so I commented out the fServer check.

    //    if ( fServer )

    {
        CWin32RegAccess regAllowed( HKEY_LOCAL_MACHINE, wcsAllowedPaths );
        WCHAR awcValue[ 8192 ];

        if ( regAllowed.Get( L"Machine",
                             awcValue,
                             sizeof awcValue / sizeof WCHAR ) )
        {
            // don't re-add it if it already exists

            BOOL fFound = FALSE;
            WCHAR *p = awcValue;
            while ( 0 != *p )
            {
                if ( !_wcsicmp( p, wcsRegAdminSubKey ) )
                {
                    fFound = TRUE;
                    break;
                }
                while ( 0 != *p )
                    p++;
                p++;
            }

            if ( !fFound )
            {
                wcscpy( p, wcsRegAdminSubKey );
                p += ( 1 + wcslen( wcsRegAdminSubKey ) );
                *p++ = 0;

                if ( !regAllowed.SetMultiSZ( L"Machine",
                                             awcValue,
                                             (ULONG)(p-awcValue) * sizeof WCHAR ) )
                {
                    DWORD dw = GetLastError();
                    ISError( IS_MSG_COULD_NOT_MODIFY_REGISTRY, Err, LogSevFatalError, dw );
                    return dw;
                }
            }
        }
    }

    return NO_ERROR;
} //SetRegBasedOnMachine


//+-------------------------------------------------------------------------
//
//  Function:   SetRegBasedOnArchitecture
//
//  Synopsis:   Sets Index Server registry tuning paramaters based on the
//              architecture.  Uninstall is .inf-based.
//
//  History:    24-Feb-98     KrishnaN     Created
//
//--------------------------------------------------------------------------

DWORD SetRegBasedOnArchitecture(CError &Err)
{
    if ( 0 == gSetupInitComponent.ComponentInfHandle )
    {
        Err.Report(LogSevError,0,L"Couldn't set registry based on architecture, Invalid Inf Handle");

        return NO_ERROR;
    }

    WCHAR * pwcInf = 0;

    #if defined (_X86_)
        pwcInf = L"IndexSrv_X86";
    #else
        pwcInf = L"IndexSrv_RISC";
    #endif

    if ( !SetupInstallFromInfSection( 0,
                                      gSetupInitComponent.ComponentInfHandle,
                                      pwcInf,
                                      SPINST_REGISTRY,
                                      0, 0, 0, 0, 0, 0, 0 ) )
        return GetLastError();

    return NO_ERROR;
} //SetRegBasedOnArchitecture

//+-------------------------------------------------------------------------
//
//  Function:   GetMachineInfo
//
//  Synopsis:   Retrieves stats about the machine
//
//  Arguments:  fLotsOfMem  -- returns TRUE if the machine has "lots" of mem
//              cCPU        -- returns a count of CPUs
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

void GetMachineInfo(
    BOOL  & fLotsOfMem,
    DWORD & cCPU )
{
    SYSTEM_INFO si;
    GetSystemInfo( &si );
    cCPU = si.dwNumberOfProcessors;

    MEMORYSTATUSEX memStatus;
    memStatus.dwLength = sizeof( memStatus );
    GlobalMemoryStatusEx( &memStatus );
    fLotsOfMem = ( memStatus.ullTotalPhys >= 64000000 );
} //GetMachineInfo

//+-------------------------------------------------------------------------
//
//  Function:   isLogString
//
//  Synopsis:   Logs the string to %windir%\setupqry.log
//
//  Arguments:  pc  -- ansi string
//
//  History:    11-Nov-98 dlee     Created
//
//--------------------------------------------------------------------------

BOOL g_fCalledYet = FALSE;

void isLogString( const char * pc )
{
    WCHAR awc[ MAX_PATH ];
    UINT ui = GetWindowsDirectory( awc, sizeof awc / sizeof WCHAR );

    if ( 0 == ui )
        return;

    wcscat( awc, L"\\setupqry.log" );

    WCHAR const * pwcOpen = L"a";

    if ( !g_fCalledYet )
    {
        g_fCalledYet = TRUE;
        pwcOpen = L"w";
    }

    FILE *fp = _wfopen( awc, pwcOpen );

    if ( 0 != fp )
    {
        fprintf( fp, "%s", pc );
        fclose( fp );
    }
} //isLogString

//+-------------------------------------------------------------------------
//
//  Function:   SystemExceptionTranslator
//
//  Synopsis:   Translates system exceptions into C++ exceptions
//
//  History:    1-Dec-98 dlee     Copied from query.dll's version
//
//--------------------------------------------------------------------------

void _cdecl SystemExceptionTranslator(
    unsigned int                 uiWhat,
    struct _EXCEPTION_POINTERS * pexcept )
{
    throw CException( uiWhat );
} //SystemExceptionTranslator

//+-------------------------------------------------------------------------
//
//  Function:   DeleteNTOPStartMenu
//
//  Synopsis:   Deletes start menu items created by IS in the NTOP
//
//  History:    6-Jan-99 dlee     Created
//
//--------------------------------------------------------------------------

void DeleteNTOPStartMenu()
{
    //
    // Ignore all failures here -- it's ok if the link don't exist
    //

    CWin32RegAccess reg( HKEY_LOCAL_MACHINE,
                         L"software\\microsoft\\windows\\currentversion\\explorer\\shell folders" );

    WCHAR awc[MAX_PATH];

    if ( reg.Get( L"common programs",
                  awc,
                  MAX_PATH ) )
    {
        //
        // Build the directory where the links are located
        //

        wcscat( awc, L"\\" );

        CResString strNTOP( IS_MSG_NTOP );
        wcscat( awc, strNTOP.Get() );

        wcscat( awc, L"\\" );

        CResString strMIS( IS_MSG_START_MENU_NAME );
        wcscat( awc, strMIS.Get() );

        isDebugOut(( "NTOP start menu location: '%ws'\n", awc ));

        //
        // Delete the links
        //

        CResString strSample( IS_MSG_LINK_SAMPLE_NAME );
        DeleteShellLink( awc, strSample.Get() );
        isDebugOut(( "deleting NTOP item '%ws'\n", strSample.Get() ));

        CResString strAdmin( IS_MSG_LINK_ADMIN_NAME );
        DeleteShellLink( awc, strAdmin.Get() );
        isDebugOut(( "deleting NTOP item '%ws'\n", strAdmin.Get() ));

        CResString strMMC( IS_MSG_LINK_MMC_NAME );
        DeleteShellLink( awc, strMMC.Get() );
        isDebugOut(( "deleting NTOP item '%ws'\n", strMMC.Get() ));

        //
        // Note: when the last item is deleted, DeleteShellLink deletes
        // the directory
        //
    }
} //DeleteNTOPStartMenu
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\colname.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module colname.h |
//
//      Contains utility functions for maintaining property lists (symbol table?)
//
// @rev   0 | 12-Feb-97 | v-charca              | Created
//        1 | 24-Oct-98 | danleg                | cleanup
//

#ifndef __PROPERTYLIST_INCL__
#define __PROPERTYLIST_INCL__


//--------------------------------------------------------------------
// @func Makes a new copy of UNICODE string
// @side Allocates enough bytes from memory object to hold string
// @rdesc Pointer to new UNICODE string
inline WCHAR * CopyString( WCHAR const * pwc )
{
    unsigned c = wcslen( pwc ) + 1;
    WCHAR *pwcNew = new WCHAR[c];
    RtlCopyMemory( pwcNew, pwc, c * sizeof WCHAR );
    return pwcNew;
}

//--------------------------------------------------------------------
// @func Makes a new copy of UNICODE string
// @side Allocates enough bytes from memory object to hold string
// @rdesc Pointer to new UNICODE string
inline LPWSTR CoTaskStrDup
    (
    const WCHAR *   pwszOrig,
    UINT            cLen
    )
{
    UINT cBytes = (cLen+1) * sizeof WCHAR;
    WCHAR* pwszCopy = (WCHAR *) CoTaskMemAlloc( cBytes );
    if ( 0 != pwszCopy )
        RtlCopyMemory( pwszCopy, pwszOrig, cBytes );
    return pwszCopy;
}


//--------------------------------------------------------------------
// @func Makes a new copy of UNICODE string
// @side Allocates enough bytes from memory object to hold string
// @rdesc Pointer to new UNICODE string
inline LPWSTR CoTaskStrDup
    (
    const WCHAR * pwszOrig
    )
{
    return CoTaskStrDup( pwszOrig, wcslen(pwszOrig) );
}



//--------------------------------------------------------------------
typedef struct tagHASHENTRY
    {
    LPWSTR          wcsFriendlyName;
    UINT            wHashValue;
    DWORD           dbType;
    DBID            dbCol;
    tagHASHENTRY*   pNextHashEntry;
    } HASHENTRY;

class CPropertyList
{
public: //@access public functions
    CPropertyList(CPropertyList** ppGlobalPropertyList);
    ~CPropertyList();

    HRESULT LookUpPropertyName( LPWSTR          wszPropertyName, 
                                DBCOMMANDTREE** ppct, 
                                DBTYPE*         pdbType );

    HRESULT SetPropertyEntry  ( LPWSTR  pwszFriendlyName,
                                DWORD   dbType, 
                                GUID    guidPropset,
                                DBKIND  eKind, 
                                LPWSTR  pwszPropName,
                                BOOL    fGlobal );

    CIPROPERTYDEF* GetPropertyTable( UINT* pcSize );

    void DeletePropertyTable( CIPROPERTYDEF* pCiPropTable, 
                              UINT cSize );

protected: //@access protected functions
    HASHENTRY* FindPropertyEntry( LPWSTR wszPropertyName, 
                                  UINT *puHashValue );

    HASHENTRY* GetPropertyEntry( LPWSTR wszPropertyName, 
                                 UINT *puHashValue );

    inline UINT GetHashValue( LPWSTR wszPropertyName );

protected: //@access protected data
    XArray<HASHENTRY*>      m_aBucket;                  // Array of pointers to hash buckets
    int                     m_cMaxBucket;               // Number of hash buckets (PRIME!)
    CPropertyList**         m_ppGlobalPropertyList;     // Pointer to the global property list
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\iparser.cpp ===
//--------------------------------------------------------------------
// Microsoft OLE DB iparser object
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module iparser.CPP | IParser object implementation
//
//
#pragma hdrstop
#include    "msidxtr.h"


// CImpIParser::CImpIParser ---------------------------------------------------
//
// @mfunc Constructor
//
CImpIParser::CImpIParser()
{
    m_cRef                = 1;
    m_pGlobalPropertyList = 0;
    m_pGlobalViewList     = 0;
}

// CImpIParser::~CImpIParser --------------------------------------------------
//
// @mfunc Destructor
//
CImpIParser::~CImpIParser()
{
    delete m_pGlobalPropertyList;
    delete m_pGlobalViewList;
}

//-----------------------------------------------------------------------------
// @func CImpIParser::CreateSession 
//
// Creates a unique session within the parser.  This session is required to keep
// the views and properties in their correct lifetimes.
//
// @rdesc HRESULT
//      S_OK                      - IParserSession created
//      DB_E_DIALECTNOTSUPPOERTED - Specified dialect was not supported
//      E_OUTOFMEMORY             - low on resources
//      E_FAIL                    - unexpected error
//      E_INVALIDARG              - pGuidDialect, pIParserVerify, pIColMapCreator, 
//                                  or ppIParserSession was a NULL pointer 
//                                  (DEBUG ONLY). 
//-----------------------------------------------------------------------------
STDMETHODIMP CImpIParser::CreateSession(
    const GUID *            pGuidDialect,       // in | dialect for this session
    LPCWSTR                 pwszMachine,        // in | provider's current machine
    IParserVerify *         pIParserVerify,     // in | ptr to ParserVerify
    IColumnMapperCreator *  pIColMapCreator,
    IParserSession **       ppIParserSession )  // out | a unique parser session
{
    SCODE sc = S_OK;

#ifdef DEBUG
    if ( 0 == ppIParserSession || 0 == pIParserVerify ||
         0 == pIColMapCreator ||  0 == pGuidDialect)
        sc = E_INVALIDARG;
    else
#endif
    {
        TRANSLATE_EXCEPTIONS;
        TRY
        {
            if ( 0 != ppIParserSession )
                *ppIParserSession = 0;

            // Check Dialect

            if ( DBGUID_MSSQLTEXT == *pGuidDialect || DBGUID_MSSQLJAWS == *pGuidDialect )
            {
                XPtr<CViewList> xpGlobalViewList;
                if ( 0 == m_pGlobalViewList )
                    xpGlobalViewList.Set( new CViewList() );

                XInterface<CImpIParserSession> 
                    xpIParserSession( new CImpIParserSession( pGuidDialect,
                                                              pIParserVerify,
                                                              pIColMapCreator,
                                                              xpGlobalViewList.GetPointer() ) );

                XPtr<CPropertyList> xpGlobalPropertyList;

                sc = xpIParserSession->FInit( pwszMachine,
                                              &m_pGlobalPropertyList );
                if ( FAILED(sc) )
                    xpIParserSession.Free();
                else
                {
                    if ( 0 == m_pGlobalPropertyList )
                        xpGlobalPropertyList.Set( new CPropertyList(NULL) );
                }

                delete m_pGlobalViewList;
                m_pGlobalViewList = xpGlobalViewList.Acquire();
                delete m_pGlobalPropertyList;
                m_pGlobalPropertyList = xpGlobalPropertyList.Acquire();
                *ppIParserSession = xpIParserSession.Acquire();
            }
            else
                sc = DB_E_DIALECTNOTSUPPORTED;
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();
        }
        END_CATCH
        UNTRANSLATE_EXCEPTIONS;
    }
    return sc;
}




//-----------------------------------------------------------------------------
// @func CImpIParser::QueryInterface 
//
// @mfunc Returns a pointer to a specified interface. Callers use 
// QueryInterface to determine which interfaces the called object 
// supports. 
//
// @rdesc HResult indicating the status of the method
// @flag S_OK | Interface is supported and ppvObject is set.
// @flag E_NOINTERFACE | Interface is not supported by the object
// @flag E_INVALIDARG | One or more arguments are invalid. 
//-----------------------------------------------------------------------------

STDMETHODIMP CImpIParser::QueryInterface(
    REFIID  riid,           //@parm IN | Interface ID of the interface being queried for. 
    LPVOID* ppv )           //@parm OUT | Pointer to interface that was instantiated      
{
    if ( 0 == ppv )
        return ResultFromScode(E_INVALIDARG);

    //  This is the non-delegating IUnknown implementation
    if ( (riid == IID_IParser) ||
         (riid == IID_IUnknown) )
        *ppv = (LPVOID)this;
    else
        *ppv = 0;

    //  If we're going to return an interface, AddRef it first
    if ( 0 != *ppv )
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
}


//-----------------------------------------------------------------------------
// CImpIParser::AddRef 
//
// @mfunc Increments a persistence count for the object.
//
// @rdesc Reference count after operation.
//-----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CImpIParser::AddRef()
{
    return InterlockedIncrement((long *) &m_cRef);
}


//-----------------------------------------------------------------------------
// CImpIParser::Release 
//
// @mfunc Decrements a persistence count for the object and if
// persistence count is 0, the object destroys itself.
//
// @rdesc Current reference count
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CImpIParser::Release()
{
    Assert(m_cRef > 0);

    ULONG cRef= InterlockedDecrement( (long *) &m_cRef );
    if ( 0 == cRef )
    {
        TRACE("IParser refcount=0, now deleting.\n");

        delete this;
        return 0;
    }

    TRACE("IParser refcount=%d after Release().\n", cRef);
    return cRef;
}


//-----------------------------------------------------------------------------
// @func MakeIParser
//
// Creates an IParser
//
// @rdesc HRESULT
//    S_OK if successful; Error code otherwise
//-----------------------------------------------------------------------------
HRESULT __stdcall MakeIParser(
    IParser** ppIParser )
{
    SCODE sc = S_OK;

    if ( 0 == ppIParser )
        sc = E_INVALIDARG;
    else
    {
        TRANSLATE_EXCEPTIONS;
        TRY
        {
            XInterface<CImpIParser> xpIParser( new CImpIParser() );
            *ppIParser = xpIParser.Acquire();
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();
        }
        END_CATCH
        UNTRANSLATE_EXCEPTIONS;
    }
    
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\headers.cpp ===
//-----------------------------------------------------------------------------------
// Microsoft Monarch Parser
// (C) Copyright 1997 By Microsoft Corporation.
//
// @doc
//
// @module HEADERS.CPP | precompiled headers module
//
// @rev 1 | 10-17-97 | Briants | Created
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop
#include "msidxtr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\flexcpp.h ===
// $Header: /Monarch/src/msidxtr/flexcpp.h 10    8/01/97 2:17p A-charca $

// FlexLexer.h -- define interfaces for lexical analyzer classes generated
//        by flex

// Copyright (c) 1993 The Regents of the University of California.
// All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Kent Williams and Tom Epperly.
//
// Redistribution and use in source and binary forms are permitted provided
// that: (1) source distributions retain this entire copyright notice and
// comment, and (2) distributions including binaries display the following
// acknowledgement:  ``This product includes software developed by the
// University of California, Berkeley and its contributors'' in the
// documentation or other materials provided with the distribution and in
// all advertising materials mentioning features or use of this software.
// Neither the name of the University nor the names of its contributors may
// be used to endorse or promote products derived from this software without
// specific prior written permission.
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

// This file defines FlexLexer, an abstract class which specifies the
// external interface provided to flex C++ lexer objects, and YYLEXER,
// which defines a particular lexer class.
//
// If you want to create multiple lexer classes, you use the -P flag
// to rename each YYLEXER to some other xxFlexLexer.  You then
// include <FlexLexer.h> in your other sources once per lexer class:
//
//  #undef YYLEXER
//  #define YYLEXER xxFlexLexer
//  #include <FlexLexer.h>
//
//  #undef YYLEXER
//  #define YYLEXER zzFlexLexer
//  #include <FlexLexer.h>
//  ...

#ifndef __FLEX_LEXER_H
// Never included before - need to define base class.
#define __FLEX_LEXER_H

#ifndef YY_CHAR
#define YY_CHAR TCHAR
#endif

#ifdef UNICODE
# define strdup _wcsdup
# define strlen wcslen
# define atol   _wtol
inline double strtof(wchar_t *s) { char tmp[255]; wcstombs(tmp, s, 255); return atof(tmp); }
#else
# define strdup _strdup
# define strlen strlen
# define atol   atol
# define strtof atof
#endif


// extern "C++" {

struct yy_buffer_state;
typedef int yy_state_type;

class FlexLexer {
public:
//  virtual ~FlexLexer() = 0;

    const YY_CHAR* YYText() { return yytext; }
    int YYLeng()        { return yyleng; }

    virtual void
        yy_switch_to_buffer( struct yy_buffer_state* new_buffer ) = 0;
    virtual struct yy_buffer_state*
        yy_create_buffer( int size ) = 0;
    virtual void yy_delete_buffer( struct yy_buffer_state* b ) = 0;
    virtual void yyrestart( ) = 0;

    virtual int yylex(YYSTYPE *yylval) = 0;

    int lineno() const      { return yylineno; }

    int debug() const       { return yy_flex_debug; }
    void set_debug( int flag )  { yy_flex_debug = flag; }

protected:
    YY_CHAR* yytext;
    int yyleng;
    int yylineno;       // only maintained if you use %option yylineno
    int yy_flex_debug;  // only has effect with -d or "%option debug"
};

// }
#endif

#if defined(YYLEXER) || ! defined(yyFlexLexerOnce)
// Either this is the first time through (yyFlexLexerOnce not defined),
// or this is a repeated include to define a different flavor of
// YYLEXER, as discussed in the flex man page.
#define yyFlexLexerOnce

class YYPARSER; // forward declaration

class YYLEXER : public FlexLexer {
public:
    YYLEXER();
    virtual ~YYLEXER();

    void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
    struct yy_buffer_state* yy_create_buffer( int size );
    void yy_delete_buffer( struct yy_buffer_state* b );
    void yyrestart( );

    int yylex(YYSTYPE *yylval);

    void yyprimebuffer(YY_CHAR *pszBuffer);
    int yybufferinput(YY_CHAR *pszBuffer, int cMax);

    void yyprimelexer(int eToken);

protected:
    virtual int LexerInput( YY_CHAR* buf, int max_size );
    virtual void LexerOutput( const YY_CHAR* buf, int size );
    virtual void LexerError( const YY_CHAR* msg );
#ifdef DEBUG
    virtual void LexerTrace(const YY_CHAR* buf, int size, int tknNum);
#endif

    void yyunput( int c, YY_CHAR* buf_ptr );
    int yyinput();

    void ResetLexer();
    void CreateTknValue(YYSTYPE *ppqt, short tknNum, YY_CHAR wch = L'\0', BOOL fQuote = FALSE);
    void yy_load_buffer_state();
    void yy_init_buffer( struct yy_buffer_state* b );
    void yy_flush_buffer( struct yy_buffer_state* b );

    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int* yy_start_stack;

    void yy_push_state( int new_state );
    void yy_pop_state();
    int yy_top_state();

    yy_state_type yy_get_previous_state();
    yy_state_type yy_try_NUL_trans( yy_state_type current_state );
    int yy_get_next_buffer();

    struct yy_buffer_state* yy_current_buffer;

    // yy_hold_char holds the character lost when yytext is formed.
    YY_CHAR yy_hold_char;

    // Number of characters read into yy_ch_buf.
    int yy_n_chars;

    // Points to current character in buffer.
    YY_CHAR* yy_c_buf_p;
    YY_CHAR *pCurBuffer, *pszInputBuffer;
    int cInputBuffer;

    int yy_init;        // whether we need to initialize
    int yy_start;       // start state number
    int yyprimetoken;   // priming token

    // Flag which is used to allow yywrap()'s to do buffer switches
    // instead of setting up a fresh yyin.  A bit of a hack ...
    int yy_did_buffer_switch_on_eof;

    // The following are not always needed, but may be depending
    // on use of certain flex features (like REJECT or yymore()).

    yy_state_type yy_last_accepting_state;
    YY_CHAR* yy_last_accepting_cpos;

    yy_state_type* yy_state_buf;
    yy_state_type* yy_state_ptr;

    YY_CHAR* yy_full_match;
    int* yy_full_state;
    int yy_full_lp;

    int yy_lp;
    int yy_looking_for_trail_begin;

    int yy_more_flag;
    int yy_more_len;
    int yy_more_offset;
    int yy_prev_more_offset;
#ifdef DEBUG
    int tkndebug;
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\iparser.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module IPARSER.H | IParser base object and contained interface
// definitions
//
//
#ifndef _IPARSER_H_
#define _IPARSER_H_

// Includes ------------------------------------------------------------------


//----------------------------------------------------------------------------
// @class IParser | 
// CoType Object
//
class CImpIParser : public IParser
    {
    private: //@access private member data
        LONG            m_cRef;
        CViewList*      m_pGlobalViewList;
        CPropertyList*  m_pGlobalPropertyList;

    public: //@access public
        CImpIParser();
        ~CImpIParser();

        //@cmember Request an Interface
        STDMETHODIMP            QueryInterface(REFIID, LPVOID *);
        //@cmember Increments the Reference count
        STDMETHODIMP_(ULONG)    AddRef(void);
        //@cmember Decrements the Reference count
        STDMETHODIMP_(ULONG)    Release(void);

        //@cmember CreateSession method
        STDMETHODIMP CreateSession
                    (
                    const GUID*         pGuidDialect,   // in | dialect for this session
                    LPCWSTR             pwszMachine,    // in | provider's current machine
                    IParserVerify*      pIPVerify,      // in | unknown part of ParserInput
                    IColumnMapperCreator*   pIColMapCreator,
                    IParserSession**    ppIParserSession// out | a unique session of the parser
                    );
    };  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\iparsess.cpp ===
//--------------------------------------------------------------------
// Microsoft OLE DB Parser object
// (C) Copyright Microsoft Corporation, 1997 - 1999.
//
// @doc
//
// @module IParserSession.CPP | IParserSession object implementation
//
//
#pragma hdrstop
#include "msidxtr.h"
#include <ciexcpt.hxx>

// CViewData::CViewData ------------------------------------
//
// @mfunc Constructor
//
CViewData::CViewData() :
    m_pwszViewName( 0 ),
    m_pwszCatalogName( 0 ),
    m_pctProjectList( 0 ),
    m_pCScopeData( 0 )
{
}


// CViewData::CViewData ------------------------------------
//
// @mfunc Destructor
//
CViewData::~CViewData()
{
    delete [] m_pwszViewName;
    delete [] m_pwszCatalogName;

    DeleteDBQT(m_pctProjectList);
    if ( 0 != m_pCScopeData )
        m_pCScopeData->Release();
}


// CViewList::CViewList ------------------------------------
//
// @mfunc Constructor
//
CViewList::CViewList() :
        m_pViewData( 0 )
{
}

// CViewList::~CViewList -----------------------------------
//
// @mfunc Destructor
//
CViewList::~CViewList()
{
    CViewData* pViewData = m_pViewData;
    CViewData* pNextViewData = NULL;
    while( NULL != pViewData )
        {
        pNextViewData = pViewData->m_pNextView;
        delete pViewData;
        pViewData = pNextViewData;
        }
}

// CImpIParserSession::CImpIParserSession ------------------------------------
//
// @mfunc Constructor
//
CImpIParserSession::CImpIParserSession(
    const GUID*             pGuidDialect,       // in | dialect for this session
    IParserVerify*          pIPVerify,          // in |
    IColumnMapperCreator*   pIColMapCreator,    // in |
    CViewList*              pGlobalViewList ) : // in |
            m_pLocalViewList( 0 )
{
    assert( pGuidDialect && pIPVerify && pIColMapCreator );

    m_cRef                      = 1;

    m_lcid                      = LOCALE_SYSTEM_DEFAULT;
    m_dwRankingMethod           = VECTOR_RANK_JACCARD;

    m_pwszCatalog               = NULL;
    m_pwszMachine               = NULL;

    m_pGlobalViewList           = pGlobalViewList;
    m_globalDefinitions         = FALSE;

    m_pColumnMapper             = NULL;
    m_pCPropertyList            = NULL;

    InitializeCriticalSection( &m_csSession );

    m_pIPVerify = pIPVerify;
    m_pIPVerify->AddRef();

    m_pIColMapCreator = pIColMapCreator;
    m_pIColMapCreator->AddRef();

    m_GuidDialect = *pGuidDialect;

    if ( DBGUID_MSSQLTEXT == m_GuidDialect )
        m_dwSQLDialect = DBDIALECT_MSSQLTEXT;
    else if ( DBGUID_MSSQLJAWS == m_GuidDialect )
        m_dwSQLDialect = DBDIALECT_MSSQLJAWS;
    else
        assert( DBGUID_MSSQLTEXT == m_GuidDialect || DBGUID_MSSQLJAWS == m_GuidDialect );
}


// CImpIParserSession::~CImpIParserSession -----------------------------------
//
// @mfunc Destructor
//
CImpIParserSession::~CImpIParserSession()
{
    if( 0 != m_pIPVerify )
        m_pIPVerify->Release();

    if( 0 != m_pIColMapCreator )
        m_pIColMapCreator->Release();

    delete [] m_pwszCatalog;
    delete [] m_pwszMachine;

    delete m_pCPropertyList;
    delete m_pLocalViewList;

    DeleteCriticalSection( &m_csSession );
}


//-----------------------------------------------------------------------------
// @mfunc FInit
//
// Initialize member vars that could potentially fail.
//
//-----------------------------------------------------------------------------
HRESULT CImpIParserSession::FInit(
    LPCWSTR         pwszMachine,            // in | provider's current machine
    CPropertyList** ppGlobalPropertyList )  // in | caller's property list
{
    assert( 0 == m_pCPropertyList );
    assert( 0 != pwszMachine && 0 == m_pwszMachine );

    SCODE sc = S_OK;
    TRY
    {
        XPtrST<WCHAR> xMachine( CopyString(pwszMachine) );
        XPtr<CPropertyList> xpPropertyList( new CPropertyList(ppGlobalPropertyList) );
        XPtr<CViewList> xpLocalViewList( new CViewList() );

        Win4Assert( 0 == m_pCPropertyList );
        m_pCPropertyList = xpPropertyList.Acquire();

        Win4Assert( 0 == m_pLocalViewList );
        m_pLocalViewList = xpLocalViewList.Acquire();

        m_pwszMachine = xMachine.Acquire();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


// CImpIParserSession::QueryInterface ----------------------------------
//
// @mfunc Returns a pointer to a specified interface. Callers use
// QueryInterface to determine which interfaces the called object
// supports.
//
// @rdesc HResult indicating the status of the method
//      @flag S_OK | Interface is supported and ppvObject is set.
//      @flag E_NOINTERFACE | Interface is not supported by the object
//      @flag E_INVALIDARG | One or more arguments are invalid.
//
STDMETHODIMP CImpIParserSession::QueryInterface(
    REFIID   riid,              //@parm IN | Interface ID of the interface being queried for.
    LPVOID * ppv )              //@parm OUT | Pointer to interface that was instantiated
{
    if( 0 == ppv )
        return ResultFromScode(E_INVALIDARG);

    if( (riid == IID_IUnknown) ||
        (riid == IID_IParserSession) )
        *ppv = (LPVOID)this;
    else
        *ppv = 0;


    //  If we're going to return an interface, AddRef it first
    if( 0 != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


// CImpIParserSession::AddRef ------------------------------------------
//
// @mfunc Increments a persistence count for the object
//
// @rdesc Current reference count
//
STDMETHODIMP_(ULONG) CImpIParserSession::AddRef (void)
{
    return InterlockedIncrement( (long*) &m_cRef);
}


// CImpIParserSession::Release -----------------------------------------
//
// @mfunc Decrements a persistence count for the object and if
// persistence count is 0, the object destroys itself.
//
// @rdesc Current reference count
//
STDMETHODIMP_(ULONG) CImpIParserSession::Release (void)
{
    assert( m_cRef > 0 );

    ULONG cRef = InterlockedDecrement( (long *) &m_cRef );
    if( 0 == cRef )
    {
        delete this;
        return 0;
    }

    return cRef;
}


//-----------------------------------------------------------------------------
// @func CImpIParserSession::ToTree
//
// Transform a given text command to a valid command tree
//
// @rdesc HRESULT
//      S_OK           - Text was translated into DBCOMMANDTREE
//      DB_S_NORESULTS - CREATE VIEW or SET PROPERTY or batched set of
//                       these parsed successfully.  NOTE:  *ppTree and
//                       *ppPTProperties will be null.
//      E_OUTOFMEMORY  - low on resources
//      E_FAIL         - unexpected error
//      E_INVALIDARG   - pcwszText, ppCommandTree, or ppPTProperties
//                       was a NULL pointer.
//-----------------------------------------------------------------------------

STDMETHODIMP CImpIParserSession::ToTree(
    LCID                    lcid,
    LPCWSTR                 pcwszText,
    DBCOMMANDTREE**         ppCommandTree,
    IParserTreeProperties** ppPTProperties )
{
    HRESULT                     hr = S_OK;
    IColumnMapper*              pIColumnMapper = NULL;


    assert(pcwszText && ppCommandTree && ppPTProperties);

    if ( 0 == pcwszText || 0 == ppCommandTree || 0 == ppPTProperties )
        hr = ResultFromScode(E_INVALIDARG);
    else
    {
        *ppCommandTree = 0;
        *ppPTProperties = 0;

        CAutoBlock cab( &m_csSession );

        // Clear some member variables for this pass through the parser
        SetLCID( lcid );
        SetGlobalDefinition( FALSE );

        // Attempt to get the interface for accessing the built-in properties
        // This is done on each call to the parser in case different commands
        // use a different catalog, which is part of the
        // GetColumnMapper parameter list.
        if( SUCCEEDED(hr = m_pIColMapCreator->GetColumnMapper(LOCAL_MACHINE,
                                                    GetDefaultCatalog(),
                                                    &pIColumnMapper)) )
        {
            SetColumnMapperPtr(pIColumnMapper);
        }
        else
        {
            goto ParseErr;
        }

        try
        {
            XInterface<CImpIParserTreeProperties> xpPTProps;

            xpPTProps.Set( new CImpIParserTreeProperties() );

            hr = xpPTProps->FInit(GetDefaultCatalog(), GetDefaultMachine());
            if (FAILED(hr) )
                THROW( CException(hr) );

            MSSQLLexer  Lexer;
            MSSQLParser Parser(this, xpPTProps.GetPointer(), Lexer);

            // callee needs this to post parser errors when Parse() fails
            *ppPTProperties = xpPTProps.Acquire();

            Parser.yyprimebuffer( (LPWSTR)pcwszText );
            Parser.ResetParser();

#ifdef DEBUG
            Parser.yydebug = getenv("YYDEBUG") ? 1 : 0;
#endif
            // Actually parse the text producing a tree
            hr = Parser.Parse();
            if ( FAILED(hr) )
                goto ParseErr;

            // return the DBCOMMANDTREE
            *ppCommandTree = Parser.GetParseTree();

#ifdef DEBUG
            if (getenv("PRINTTREE"))
            {
                if ( *ppCommandTree )
                {
                    cout << "OLE DB Command Tree" << endl;
                    cout << pcwszText << endl << **ppCommandTree << endl << endl;

                    // Retrieve CiRestriction
                    VARIANT vVal;
                    VariantInit(&vVal);
                    if( SUCCEEDED((*ppPTProperties)->GetProperties(PTPROPS_CIRESTRICTION, &vVal)) )
                        if( V_BSTR(&vVal) )
                            cout << "CiRestriction: " << (LPWSTR)V_BSTR(&vVal) << endl;
                    VariantClear(&vVal);
                }
            }
#endif
            if ( 0 == *ppCommandTree )
            {
                hr = ResultFromScode(DB_S_NORESULT);

                // Spec states that this should be NULL when DB_S_NORESULTs is returned.
                (*ppPTProperties)->Release();
                *ppPTProperties = 0;
                goto ParseErr;
            }
        }
        catch( CException e )
        {
#ifdef DEBUG
            if (getenv("PRINTTREE"))
                cout << "At catch(...)!!!!!!!!!!!!!" << endl;
#endif
            hr = e.GetErrorCode();
        }
        catch(...)
        {
            hr = E_FAIL;
        }

ParseErr:

        pIColumnMapper = GetColumnMapperPtr();
        if ( 0 != pIColumnMapper )
        {
            pIColumnMapper->Release();
            pIColumnMapper = NULL;
            SetColumnMapperPtr(NULL);
        }
    }

    return hr;
}

//-----------------------------------------------------------------------------
// @func CImpIParserSession::FreeTree
//
// Free memory associated with a given command tree.
//
// @rdesc HRESULT
//      S_OK - command tree released
//      E_FAIL - tree could not be freed
//      E_INVALIDARG - ppTree was a NULL pointer
//-----------------------------------------------------------------------------
STDMETHODIMP CImpIParserSession::FreeTree(
    DBCOMMANDTREE** ppTree )
{
    SCODE sc = S_OK;

    if ( 0 == ppTree )
        sc = E_INVALIDARG;
    else
    {
        if ( 0 != *ppTree )
            DeleteDBQT( *ppTree );  // todo:  put error returns on DeleteDBQT

        *ppTree = 0;
    }

    return sc;
}

//-----------------------------------------------------------------------------
// @func CImpIParserSession::SetCatalog
//
// Establish the current catalog for this parser session.
//
// @rdesc HRESULT
//      S_OK - method successful
//      E_OUTOFMEMORY - low on resources
//      E_FAIL - unexpected error
//      E_INVALIDARG - pcwszCatalog was a NULL pointer (DEBUG ONLY)
//-----------------------------------------------------------------------------
STDMETHODIMP CImpIParserSession::SetCatalog(
    LPCWSTR pcwszCatalog )
{
    SCODE sc = S_OK;

    if ( 0 == pcwszCatalog )
        return E_INVALIDARG;

    TRY
    {
        XPtrST<WCHAR> xCatalog( CopyString(pcwszCatalog) );

        delete [] m_pwszCatalog;
        m_pwszCatalog = xCatalog.Acquire();

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


//--------------------------------------------------------------------
// @func Locate a view, if defined, in the view list
//
// @rdesc HRESULT
//
CViewData* CViewList::FindViewDefinition(
    LPWSTR          pwszViewName,     // @parm IN | name of view being defined
    LPWSTR          pwszCatalogName ) // @parm IN | name of catalog view is to be defined in
{
    CViewData* pViewData = m_pViewData;
    while (NULL != pViewData)
    {
        if ( 0 == _wcsicmp(pViewData->m_pwszViewName, pwszViewName) )
        {
            // pwszCatalogName will be null for built-in views which match all catalogs
            if ( 0 == pViewData->m_pwszCatalogName )
                break;
            if ( 0 == _wcsicmp(pViewData->m_pwszCatalogName, pwszCatalogName) )
                break;
        }
        pViewData = pViewData->m_pNextView;
    }
    return pViewData;
}


//--------------------------------------------------------------------
// @func Stores the information from a temporary view
//
// @rdesc S_OK          | Valid
//        E_INVALIDARG  | Attempt to redefine a view in the specified catalog
//        E_OUTOFMEMORY | Error result from HrQeTreeCopy or CopyScopeDataToView
//
HRESULT CViewList::SetViewDefinition(
    CImpIParserSession*         pIParsSess,     // @parm IN | IParserSession interface
    CImpIParserTreeProperties*  pIPTProps,      // @parm IN | IParserTreeProperties interface
    LPWSTR                      pwszViewName,   // @parm IN | name of view being defined
    LPWSTR                      pwszCatalogName,// @parm IN | name of catalog view is to be defined in
    DBCOMMANDTREE*              pctProjectList )// @parm IN | project list for the selected columns
{
    SCODE sc = S_OK;

    {
        CViewData* pViewData = FindViewDefinition( pwszViewName, pwszCatalogName );
        if( 0 != pViewData )     // this view already defined
            return E_INVALIDARG;
    }

    TRY
    {
        XPtr<CViewData> xpViewData( new CViewData() );
        xpViewData->m_pwszViewName = CopyString( pwszViewName );

        if ( 0 != pwszCatalogName )
            xpViewData->m_pwszCatalogName = CopyString( pwszCatalogName );

        sc = HrQeTreeCopy( &(xpViewData->m_pctProjectList),
                           pctProjectList );

        if ( SUCCEEDED(sc) )
        {
            //Save pointer to ScopeData object and up the refcount for our use.
            xpViewData->m_pCScopeData = pIPTProps->GetScopeDataPtr();
            xpViewData->m_pCScopeData->AddRef();

            sc = pIPTProps->CreateNewScopeDataObject( pIParsSess->GetDefaultMachine() );
            if( SUCCEEDED(sc) )
            {
                //@DEVNOTE: Anything added before the next two lines should
                // go through the error_exit routine.  WHY?  Because we haven't
                // added this node to our linked list until the next 2 lines.
                xpViewData->m_pNextView = m_pViewData;
                m_pViewData = xpViewData.Acquire();
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//--------------------------------------------------------------------
// @func Deletes the information for a temporary view.
//
// @rdesc HRESULT
//
HRESULT CViewList::DropViewDefinition(
    LPWSTR  pwszViewName,       // @parm IN | name of view being defined
    LPWSTR  pwszCatalogName )   // @parm IN | name of catalog view is defined in
{
    CViewData* pViewData = m_pViewData;
    CViewData* pPrevViewData = NULL;

    while (NULL != pViewData)
    {
        if ( 0 == _wcsicmp(pViewData->m_pwszViewName, pwszViewName) )
        {
            // pwszCatalogName will be null for built-in views which match all catalogs
            if ( 0 == pViewData->m_pwszCatalogName )
                break;
            if ( 0 == _wcsicmp(pViewData->m_pwszCatalogName, pwszCatalogName) )
                break;
        }
        pPrevViewData = pViewData;
        pViewData = pViewData->m_pNextView;
    }

    if ( 0 == pViewData )
        return E_FAIL;

    // unlink the view
    if ( 0 != pPrevViewData )
        pPrevViewData->m_pNextView = pViewData->m_pNextView;
    else
        m_pViewData = pViewData->m_pNextView;

    delete pViewData;

    return S_OK;
}




//--------------------------------------------------------------------
// @func Retrieves the information from a temporary view.
//       This returns a DBCOMMANDTREE for use as a project list
//      in the query specification.  The scope information is
//      stored in the compiler envirnment scope data.
//
// @rdesc DBCOMMANDTREE*
//      NULL                    | view not defined
//      DBOP_catalog_name       | verify catalog failed
//      DBOP_project_list_anchor| success
//
DBCOMMANDTREE* CViewList::GetViewDefinition(
    CImpIParserTreeProperties* pIPTProps,
    LPWSTR  pwszViewName,                   // @parm IN | name of view being defined
    LPWSTR  pwszCatalogName )               // @parm IN | name of catalog view is defined in
{
    DBCOMMANDTREE* pct = 0;

    CViewData* pViewData = FindViewDefinition( pwszViewName, pwszCatalogName );
    if( 0 != pViewData )
    {
        // Take the pointer to the scope data stored in the view definition and
        // AddRef the object so we have ownership rights in our current PTProps.
        pIPTProps->ReplaceScopeDataPtr( pViewData->m_pCScopeData );

        SCODE sc = HrQeTreeCopy( &pct, pViewData->m_pctProjectList );
        if ( FAILED(sc) )
            pct = 0;
    }

    return pct;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    makefile.inc.

!ENDIF

mssqllex.cpp: ms-sql.l ms-sql.y flexcpp.h flexcpp.skl mssqltab.h
    @ech Build_Status Generating mssqllex.cpp... ;
    -attrib -r mssqllex.cpp 2>nul
    -del mssqllex.cpp 2>nul
    flex -Sflexcpp.skl -i -+ -B -L -omssqllex.cpp ms-sql.l

mssqltab.cpp mssqltab.h: ms-sql.y
    @ech Build_Status Generating mssqltab.cpp... ;
    kbyacc -f sql -d -l -b ms-sql -c CYYBase "(CImpIParserSession* pParserSession, CImpIParserTreeProperties* pParserTreeProperties, YYLEXER & yylex)" ms-sql.y
    -attrib -r mssqltab.cpp 2>nul
    -attrib -r mssqltab.h 2>nul
    -del mssqltab.cpp
    -del mssqltab.h
    -ren ms-sql.tab.c mssqltab.cpp
    -ren ms-sql.tab.h mssqltab.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\iparsess.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module PARSER.H | IParserSession object
// definitions
//
//
#ifndef _IPARSERSESSION_H_
#define _IPARSERSESSION_H_



//----------------------------------------------------------------------------
// @class CViewData
//
class CViewData
{
    public: //@access public functions
        CViewData();
        ~CViewData();
        LPWSTR          m_pwszViewName;
        LPWSTR          m_pwszCatalogName;
        DBCOMMANDTREE*  m_pctProjectList;
        CScopeData*     m_pCScopeData;  
        CViewData*      m_pNextView;
};

//----------------------------------------------------------------------------
// @class CViewList
//
class CViewList
{
    public: //@access public functions
        CViewList();
        ~CViewList();

        HRESULT DropViewDefinition( LPWSTR pwszViewName,
                                    LPWSTR pwszCatalogName );

        HRESULT SetViewDefinition( CImpIParserSession* pIParsSess,
                                   CImpIParserTreeProperties* pIPTProps,
                                   LPWSTR pwszViewName,
                                   LPWSTR pwszCatalogName,
                                   DBCOMMANDTREE* pctSelectList );

        DBCOMMANDTREE* GetViewDefinition( CImpIParserTreeProperties* pIPTProps,
                                          LPWSTR pwszViewName,
                                          LPWSTR pwszCatalogName );

    private: //@access private data
        CViewData* FindViewDefinition( LPWSTR pwszViewName, 
                                       LPWSTR pwszCatalogName );

    protected: //@access protected data
        CViewData*  m_pViewData;
};

//----------------------------------------------------------------------------
// @class CImpIParserSession 
//
class CImpIParserSession : public IParserSession
    {
    private: //@access private member data
        LONG            m_cRef;
        LCID            m_lcid;
        DWORD           m_dwRankingMethod;

        GUID            m_GuidDialect;      // dialect for this session
        LPWSTR          m_pwszMachine;      // provider's current machine
        IParserVerify*  m_pIPVerify;        // unknown part of ParserInput

        CViewList*      m_pLocalViewList;
        CViewList*      m_pGlobalViewList;
        LPWSTR          m_pwszCatalog;
        DWORD           m_dwSQLDialect;
        BOOL            m_globalDefinitions;
        IColumnMapperCreator*   m_pIColMapCreator;

        // Critical Section for syncronizing access to session data.
        CRITICAL_SECTION    m_csSession;
        IColumnMapper*      m_pColumnMapper;

    public: //@access public data 
        CPropertyList*  m_pCPropertyList;       // User defined property list

    public:         //@access public
        CImpIParserSession( const GUID* pGuidDialect,   
                            IParserVerify* pIPVerify,
                            IColumnMapperCreator* pIColMapCreator,
                            CViewList* pGlobalViewList);
        ~CImpIParserSession();

        HRESULT         FInit(LPCWSTR pwszMachine, CPropertyList** ppGlobalPropertyList);
        
        STDMETHODIMP    QueryInterface(
                        REFIID riid, LPVOID* ppVoid);
        STDMETHODIMP_(ULONG) Release (void);
        STDMETHODIMP_(ULONG) AddRef (void);

        //@cmember ToTree method
        STDMETHODIMP    ToTree
                        (
                        LCID                    lcid,   
                        LPCWSTR                 pcwszText,
                        DBCOMMANDTREE**         ppCommandTree,
                        IParserTreeProperties** ppPTProperties
                        );

        STDMETHODIMP    FreeTree
                        (
                        DBCOMMANDTREE** ppTree
                        );

        STDMETHODIMP    SetCatalog
                        (
                        LPCWSTR pcwszCatalog
                        );

    public: //@access public functions
        inline IParserVerify*   GetIPVerifyPtr()
            { return m_pIPVerify; }

        inline IColumnMapper*   GetColumnMapperPtr()
            { return m_pColumnMapper; }

        inline void             SetColumnMapperPtr(IColumnMapper* pCMapper)
            { m_pColumnMapper = pCMapper; }

        inline LCID             GetLCID()
            { return m_lcid; }

        inline void             SetLCID(LCID lcid)
            { m_lcid = lcid; }

        inline DWORD            GetRankingMethod()
            { return m_dwRankingMethod; }

        inline void             SetRankingMethod(DWORD dwRankingMethod)
            { m_dwRankingMethod = dwRankingMethod; }

        inline DWORD            GetSQLDialect()
            { return m_dwSQLDialect; }

        inline LPWSTR           GetDefaultCatalog()
            { return m_pwszCatalog; }

        inline LPWSTR           GetDefaultMachine()
            { return m_pwszMachine; }

        inline void             SetGlobalDefinition(BOOL fGlobal)
            { m_globalDefinitions = fGlobal; }

        inline BOOL             GetGlobalDefinition()
            { return m_globalDefinitions; }

        inline CViewList*       GetLocalViewList()
            { return m_pLocalViewList; }


        inline CViewList*       GetGlobalViewList()
            { return m_pGlobalViewList; }

    private: //@access private functions
        CImpIParserSession() {};
    };

enum DBDIALECTENUM
        {
        DBDIALECT_UNKNOWN   = 0,
        DBDIALECT_MSSQLTEXT = 1,
        DBDIALECT_MSSQLJAWS = 2
        };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\msidxtr.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.
//
// module       msidxtr.h | Standard includes for msidxtr project.
//
//
// rev  0 | 3-4-97              | v-charca              | Created
#ifndef _MSIDXTR_H_
#define _MSIDXTR_H_

//      Don't include everything from windows.h, but always bring in OLE 2 support
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif
#if !defined(INC_OLE2)
#define INC_OLE2
#endif

// Note that we need both of these.
#if !defined(UNICODE)
#define  UNICODE        // Enable WIN32 API.
#endif
#if !defined(_UNICODE)
#define _UNICODE        // Enable runtime library routines.
#endif

#if defined(_DEBUG) && !defined(DEBUG)
#define DEBUG
#endif

#ifndef NUMELEM
#define NUMELEM(p1) (sizeof(p1) / sizeof(*(p1)))
#endif

#if (CIDBG == 1)
// Assert defined to Win4Assert in cidebnot.h
// #define Assert Win4Assert
#define assert(x) \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))
#define TRACE
#else
#define assert(x)
#define TRACE
#endif

// #define OLEDBVER 0x0250
#include <windows.h>
#include <limits.h>             // needed by cstring.cpp
#include <oaidl.h>
#include <stdio.h>
#include <oledb.h>
#include <cmdtree.h>
#include <oledberr.h>
//#include <assert.h>
#define DBEXPORT
#include "autobloc.h"
#ifdef DEBUG
#include <iostream.h>
#include <iomanip.h>
#endif
#include <ntquery.h>
#include <fsciclnt.h>
#include <query.h>
#include <ciintf.h>
#include <ciplist.hxx>

#ifdef DEBUG
#define YYDEBUG 1
#endif

//#include <cidebnot.h>
//#include <ciexcpt.hxx>

#include <smart.hxx>
#include <tsmem.hxx>

#include "yybase.hxx"
#include "mparser.h"
#include "colname.h"
#include "mssql.h"
#include "flexcpp.h"
#include "mssqltab.h"
#include "treeutil.h"
#include "PTProps.h"
#include "IParSess.h"
#include "IParser.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\mssql.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Query
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module mssql.h | 
//
// Contains utility functions for constructing, debugging and manipulating DNA query trees.
//
// @devnote Must include:
//
// @rev   0 | 01-Aug-95 | mikeu     | Created
//

#ifndef _MSSQL_H_INC
#define _MSSQL_H_INC
//#include  "colname.h"

//package is in use
#define YYAPI_PACKAGE                  1                        // package is in use
#define YYAPI_TOKENNAME                yychar                   
#define YYAPI_TOKENTYPE                int                      
#define YYAPI_TOKENEME(t)              (t)                      
#define YYAPI_TOKENNONE                -2                       
//# define YYAPI_TOKENSTR              yyGetTokenStr            /
//yyitos is defined by yacc. does correct thing for unicode or ansi
#define YYAPI_TOKENSTR(t)              (yyitos(t,yyitoa,10))    // string representation of the token
#define YYAPI_VALUENAME                yylval   
#define YYAPI_VALUETYPE                DBCOMMANDTREE *
#define YYAPI_VALUEOF(v)               v             
#define YYAPI_CALLAFTERYYLEX(t)                      
#define YYNEAR                                       
#define YYPASCAL                                     
#define YYSTATIC    static                           
#define YYLEX                           m_yylex.yylex
#define YYPARSEPROTO                            
#define YYSTYPE                         DBCOMMANDTREE *                   
#undef YYPARSER
#define YYPARSER                        MSSQLParser
#undef YYLEXER
#define YYLEXER                         MSSQLLexer
#undef  YY_CHAR 
#define YY_CHAR                         TCHAR

#ifndef YYERROR_VERBOSE
#define YYERROR_VERBOSE                        1
#endif




#define MONSQL_PARSE_ERROR                  1
#define MONSQL_CITEXTTOSELECTTREE_FAILED    MONSQL_PARSE_ERROR+1
#define MONSQL_PARSE_STACK_OVERFLOW         MONSQL_CITEXTTOSELECTTREE_FAILED+1
#define MONSQL_CANNOT_BACKUP_PARSER         MONSQL_PARSE_STACK_OVERFLOW+1
#define MONSQL_SEMI_COLON                   MONSQL_CANNOT_BACKUP_PARSER+1
#define MONSQL_ORDINAL_OUT_OF_RANGE         MONSQL_SEMI_COLON+1
#define MONSQL_VIEW_NOT_DEFINED             MONSQL_ORDINAL_OUT_OF_RANGE+1
#define MONSQL_BUILTIN_VIEW                 MONSQL_VIEW_NOT_DEFINED+1
#define MONSQL_COLUMN_NOT_DEFINED           MONSQL_BUILTIN_VIEW+1
#define MONSQL_OUT_OF_MEMORY                MONSQL_COLUMN_NOT_DEFINED+1
#define MONSQL_SELECT_STAR                  MONSQL_OUT_OF_MEMORY+1
#define MONSQL_OR_NOT                       MONSQL_SELECT_STAR+1
#define MONSQL_CANNOT_CONVERT               MONSQL_OR_NOT+1
#define MONSQL_OUT_OF_RANGE                 MONSQL_CANNOT_CONVERT+1
#define MONSQL_RELATIVE_INTERVAL            MONSQL_OUT_OF_RANGE+1
#define MONSQL_NOT_COLUMN_OF_VIEW           MONSQL_RELATIVE_INTERVAL+1
#define MONSQL_BUILTIN_PROPERTY             MONSQL_NOT_COLUMN_OF_VIEW+1
#define MONSQL_WEIGHT_OUT_OF_RANGE          MONSQL_BUILTIN_PROPERTY+1
#define MONSQL_MATCH_STRING                 MONSQL_WEIGHT_OUT_OF_RANGE+1
#define MONSQL_PROPERTY_NAME_IN_VIEW        MONSQL_MATCH_STRING+1
#define MONSQL_VIEW_ALREADY_DEFINED         MONSQL_PROPERTY_NAME_IN_VIEW+1
#define MONSQL_INVALID_CATALOG              MONSQL_VIEW_ALREADY_DEFINED+1



#endif /* _MSSQL_H_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\mssqltab.cpp ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar     1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
//--------------------------------------------------------------------
// Microsoft Monarch
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.
//
// @doc OPTIONAL EXTRACTION CODES
//
// @module  MS-sql.y |
//          Monarch SQL YACC Script
//
// @devnote none
//
// @rev 0 | 04-Feb-97 | v-charca | Created
//
/* 3.4  Object identifier for Database Language SQL */
#pragma hdrstop
#pragma optimize("g", off)

#include    "msidxtr.h"

EXTERN_C const IID IID_IColumnMapperCreator;

#define VAL_AND_CCH_MINUS_NULL(p1) (p1), ((sizeof(p1) / sizeof(*(p1))) - 1)

#ifdef YYDEBUG
#define YYTRACE(a,b,c) wprintf(L"** %s[%s%s] ** \n", a, b, c);
#else
#define YYTRACE(a,b,c)
#endif

#ifdef DEBUG
#define AssertReq(x)    Assert(x != NULL)
#else
#define AssertReq(x)
#endif



#define DEFAULTWEIGHT   1000

typedef struct tagDBTYPENAMETABLE
    {
    LPWSTR  pwszDBTypeName;
    DBTYPE  dbType;
    } DBTYPENAMETABLE;

//                            J   F   M   A   M   J   J   A   S   O   N   D
const short LeapDays[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
const short Days[12]     = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

#define IsLeapYear(yrs) (                       \
    (((yrs) % 400 == 0) ||                      \
     ((yrs) % 100 != 0) && ((yrs) % 4 == 0)) ?  \
        TRUE                                    \
    :                                           \
        FALSE                                   \
    )

#define DaysInMonth(YEAR,MONTH) (   \
    IsLeapYear(YEAR) ?              \
        LeapDays[(MONTH)]  :        \
        Days[(MONTH)]               \
    )

//-----------------------------------------------------------------------------
// @func GetDBTypeFromStr
//
// This function takes a TypeName as input, and returns the DBTYPE of the string
//
// @rdesc DBTYPE
//-----------------------------------------------------------------------------
DBTYPE GetDBTypeFromStr(
    LPWSTR  pwszDBTypeName )     // @parm IN
{
    DBTYPE dbType = DBTYPE_EMPTY;
    if ( 9 <= wcslen(pwszDBTypeName) )
        switch ( pwszDBTypeName[7] )
        {
        case L'U':
        case L'u':
            if (10 == wcslen(pwszDBTypeName))
                switch ( pwszDBTypeName[9])
                {
                    case L'1':
                        if (0 == _wcsicmp(L"DBTYPE_UI1", pwszDBTypeName))
                            dbType = DBTYPE_UI1;
                        break;

                    case L'2':
                        if (0 == _wcsicmp(L"DBTYPE_UI2", pwszDBTypeName))
                            dbType = DBTYPE_UI2;
                        break;

                    case L'4':
                        if (0 == _wcsicmp(L"DBTYPE_UI4", pwszDBTypeName))
                            dbType = DBTYPE_UI4;
                        break;

                    case L'8':
                        if (0 == _wcsicmp(L"DBTYPE_UI8", pwszDBTypeName))
                            dbType = DBTYPE_UI8;
                        break;

                    default:
                        break;
                }
            break;

        case L'I':
        case L'i':
            switch ( pwszDBTypeName[8] )
            {
                case L'1':
                    if ( 0 == _wcsicmp(L"DBTYPE_I1", pwszDBTypeName) )
                        dbType = DBTYPE_I1;
                    break;

                case L'2':
                    if ( 0 == _wcsicmp(L"DBTYPE_I2", pwszDBTypeName) )
                        dbType = DBTYPE_I2;
                    break;

                case L'4':
                    if ( 0 == _wcsicmp(L"DBTYPE_I4", pwszDBTypeName) )
                        dbType = DBTYPE_I4;
                    break;

                case L'8':
                    if ( 0 == _wcsicmp(L"DBTYPE_I8", pwszDBTypeName) )
                        dbType = DBTYPE_I8;
                    break;

                default:
                    break;
            }
            break;

        case L'R':
        case L'r':
            switch ( pwszDBTypeName[8] )
            {
                case L'4':
                    if ( 0 == _wcsicmp(L"DBTYPE_R4", pwszDBTypeName) )
                        dbType = DBTYPE_R4;
                    break;

                case L'8':
                    if (0 == _wcsicmp(L"DBTYPE_R8", pwszDBTypeName))
                        dbType = DBTYPE_R8;
                    break;

                default:
                    break;
            }
            break;

        case L'B':
        case L'b':
            if ( 10 <= wcslen(pwszDBTypeName) )
                switch ( pwszDBTypeName[8] )
                {
                    case L'S':
                    case L's':
                        if ( 0 == _wcsicmp(L"DBTYPE_BSTR", pwszDBTypeName) )
                            dbType = DBTYPE_BSTR;
                        break;

                    case L'O':
                    case L'o':
                        if ( 0 == _wcsicmp(L"DBTYPE_BOOL", pwszDBTypeName) )
                            dbType = DBTYPE_BOOL;
                        break;

                    case L'Y':
                    case L'y':
                        if ( 0 == _wcsicmp(L"DBTYPE_BYREF", pwszDBTypeName) )
                            dbType = DBTYPE_BYREF;
                        break;

                    default:
                        break;
                }
            break;

        case L'E':
        case L'e':
            if ( 0 == _wcsicmp(L"DBTYPE_EMPTY", pwszDBTypeName) )
                dbType = DBTYPE_EMPTY;
            break;

        case L'N':
        case L'n':
            if ( 0 == _wcsicmp(L"DBTYPE_NULL", pwszDBTypeName) )
                dbType = DBTYPE_NULL;
            break;

        case L'C':
        case L'c':
            if ( 0 == _wcsicmp(L"DBTYPE_CY", pwszDBTypeName) )
                dbType = DBTYPE_CY;
            break;

        case L'D':
        case L'd':
            if ( 0 == _wcsicmp(L"DBTYPE_DATE", pwszDBTypeName) )
                dbType = DBTYPE_DATE;
            break;

        case L'G':
        case L'g':
            if ( 0 == _wcsicmp(L"DBTYPE_GUID", pwszDBTypeName) )
                dbType = DBTYPE_GUID;
            break;

        case L'S':
        case L's':
            if ( 0 == _wcsicmp(L"DBTYPE_STR", pwszDBTypeName) )
                dbType = DBTYPE_STR;
            break;

        case L'W':
        case L'w':
            if ( 0 == _wcsicmp(L"DBTYPE_WSTR", pwszDBTypeName) )
                dbType = DBTYPE_WSTR;
            break;

        case L'T':
        case L't':
            if ( 0 == _wcsicmp(L"VT_FILETIME", pwszDBTypeName) )
                dbType = VT_FILETIME;
            break;

        case L'V':
        case L'v':
            if ( 0 == _wcsicmp(L"DBTYPE_VECTOR", pwszDBTypeName) )
                dbType = DBTYPE_VECTOR;
            break;

        default:
            break;
        }

    return dbType;
}


const DBTYPENAMETABLE dbTypeNameTable[] =
    {
        {L"DBTYPE_EMPTY",   DBTYPE_EMPTY},
        {L"DBTYPE_NULL",    DBTYPE_NULL},
        {L"DBTYPE_I2",      DBTYPE_I2},
        {L"DBTYPE_I4",      DBTYPE_I4},
        {L"DBTYPE_R4",      DBTYPE_R4},
        {L"DBTYPE_R8",      DBTYPE_R8},
        {L"DBTYPE_CY",      DBTYPE_CY},
        {L"DBTYPE_DATE",    DBTYPE_DATE},
        {L"DBTYPE_BSTR",    DBTYPE_BSTR},
        {L"DBTYPE_BOOL",    DBTYPE_BOOL},
        {L"DBTYPE_UI1",     DBTYPE_UI1},
        {L"DBTYPE_I1",      DBTYPE_I1},
        {L"DBTYPE_UI2",     DBTYPE_UI2},
        {L"DBTYPE_UI4",     DBTYPE_UI4},
        {L"DBTYPE_I8",      DBTYPE_I8},
        {L"DBTYPE_UI8",     DBTYPE_UI8},
        {L"DBTYPE_GUID",    DBTYPE_GUID},
        {L"DBTYPE_STR",     DBTYPE_STR},
        {L"DBTYPE_WSTR",    DBTYPE_WSTR},
        {L"DBTYPE_BYREF",   DBTYPE_BYREF},
        {L"VT_FILETIME",    VT_FILETIME},
        {L"DBTYPE_VECTOR",  DBTYPE_VECTOR}
    };


//-----------------------------------------------------------------------------
// @func PctCreateContentNode
//
// This function takes a content string as input and creates a content node
// with the specified generate method and weight.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctCreateContentNode(
    LPWSTR          pwszContent,    // @parm IN | content for the node
    DWORD           dwGenerateMethod,//@parm IN | generate method
    LONG            lWeight,        // @parm IN | weight
    LCID            lcid,           // @parm IN | locale identifier
    DBCOMMANDTREE*  pctFirstChild ) // @parm IN | node to link to new node
{
    DBCOMMANDTREE* pct = PctCreateNode( DBOP_content, DBVALUEKIND_CONTENT, pctFirstChild, NULL );
    if ( 0 != pct )
    {
        pct->value.pdbcntntValue->pwszPhrase = CoTaskStrDup( pwszContent );
        if (pct->value.pdbcntntValue->pwszPhrase)
        {
            pct->value.pdbcntntValue->dwGenerateMethod = dwGenerateMethod;
            pct->value.pdbcntntValue->lWeight = lWeight;
            pct->value.pdbcntntValue->lcid = lcid;
        }
        else
        {
            DeleteDBQT( pct );
            pct = 0;
        }
    }
    return pct;
}


//-----------------------------------------------------------------------------
// @func PctCreateBooleanNode
//
// This function creates a content node with the specified children and weight.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctCreateBooleanNode(
    DBCOMMANDOP     op,         // @parm IN | op tag for new node
    LONG            lWeight,    // @parm IN | Weight of the boolean node
    DBCOMMANDTREE*  pctChild,   // @parm IN | child of boolean node
    DBCOMMANDTREE*  pctSibling )// @parm IN | second child of boolean node
{
    DBCOMMANDTREE* pct = PctCreateNode( op, DBVALUEKIND_I4, pctChild, pctSibling, NULL );
    if ( 0 != pct )
        pct->value.lValue = lWeight;
    return pct;
}

//-----------------------------------------------------------------------------
// @func PctCreateNotNode
//
// This function creates a not node with the specified child and weight.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctCreateNotNode(
    LONG            lWeight,    // @parm IN | Weight of the boolean node
    DBCOMMANDTREE*  pctChild )  // @parm IN | child of NOT node
{
    DBCOMMANDTREE* pct = PctCreateNode( DBOP_not, DBVALUEKIND_I4, pctChild, NULL );
    if ( 0 != pct )
        pct->value.lValue = lWeight;
    return pct;
}

//-----------------------------------------------------------------------------
// @func PctCreateRelationalNode
//
// This function creates a relational node with the specied op and weight.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctCreateRelationalNode(
    DBCOMMANDOP op,         // @parm IN | op tag for new node
    LONG        lWeight )   // @parm IN | Weight of the relational node
{
    DBCOMMANDTREE* pct = PctCreateNode(op, DBVALUEKIND_I4, NULL);
    if ( 0 != pct)
        pct->value.lValue = lWeight;
    return pct;
}


//-----------------------------------------------------------------------------
// @func SetLWeight
//
// This function sets the lWeight value for vector searches
//
//-----------------------------------------------------------------------------
void SetLWeight(
    DBCOMMANDTREE*  pct,        // @parm IN | node or subtree to set
    LONG            lWeight )   // @parm IN | weight value for node(s)
{
    if ( DBOP_content == pct->op )
        pct->value.pdbcntntValue->lWeight = lWeight;
    else
    {
        AssertReq( pct->pctFirstChild );
        AssertReq( pct->pctFirstChild->pctNextSibling );
        SetLWeight(pct->pctFirstChild, lWeight);
        DBCOMMANDTREE* pctNext = pct->pctFirstChild->pctNextSibling;
        while ( pctNext )
        {
            // A content_proximity node can have lots of siblings
            SetLWeight( pctNext, lWeight );
            pctNext = pctNext->pctNextSibling;
        }
    }
}


//-----------------------------------------------------------------------------
// @func GetLWeight
//
// This function gets the lWeight value for vector searches
//-----------------------------------------------------------------------------
LONG GetLWeight(
    DBCOMMANDTREE*  pct )   // @parm IN | node or subtree to set
{
    if ( DBOP_content == pct->op )
        return pct->value.pdbcntntValue->lWeight;
    else
    {
        AssertReq( pct->pctFirstChild );
        return GetLWeight( pct->pctFirstChild );
    }
}


//-----------------------------------------------------------------------------
// @func PctBuiltInProperty
//
// This function takes a column name string as input and creates a column_name
// node containing the appropriate GUID information if the column_name is a
// built-in property
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctBuiltInProperty(
    LPWSTR                      pwszColumnName, // @parm IN | name of column
    CImpIParserSession*         pIPSession,     // @parm IN | Parser Session
    CImpIParserTreeProperties*  pIPTProps )     // @parm IN | Parser Properties
{
    DBCOMMANDTREE* pct = 0;
    DBID *pDBID = 0;
    DBTYPE uwType = 0;
    UINT uiWidth = 0;
    BOOL fOk = 0;
    IColumnMapper* pIColumnMapper = pIPSession->GetColumnMapperPtr();

    if ( 0 != pIColumnMapper )
    {
        // we were able to use the IColumnMapper interface
        HRESULT hr = S_OK;
        // Olympus kludge
        if ( 0 == _wcsicmp(pwszColumnName, L"URL") )
            hr = pIColumnMapper->GetPropInfoFromName( L"VPATH", &pDBID, &uwType, &uiWidth );
        else
            hr = pIColumnMapper->GetPropInfoFromName( pwszColumnName, &pDBID, &uwType, &uiWidth );

        if ( SUCCEEDED(hr) )
            fOk = TRUE;
        else
            fOk = FALSE;
    }
    else
        fOk = FALSE;    // @TODO:  this should generate some sort of error message.

    if ( fOk )    // this is a built-in (well known) property
    {
        pIPTProps->SetDBType( uwType );   // remember the type of this
        pct = PctCreateNode( DBOP_column_name, DBVALUEKIND_ID, NULL );
        if ( 0 != pct )
        {
            pct->value.pdbidValue->eKind = pDBID->eKind;
            pct->value.pdbidValue->uGuid.guid = pDBID->uGuid.guid;
            switch ( pct->value.pdbidValue->eKind )
            {
            case DBKIND_NAME:
            case DBKIND_GUID_NAME:
            {
                // need to create a new string
                pct->value.pdbidValue->uName.pwszName = CoTaskStrDup(pDBID->uName.pwszName);

                if ( 0 == pct->value.pdbidValue->uName.pwszName )
                {
                    pct->value.pdbidValue->eKind = DBKIND_GUID_PROPID;
                    DeleteDBQT( pct );
                    pct = 0;
                }
                break;
            }
            case DBKIND_GUID:
            case DBKIND_GUID_PROPID:
                pct->value.pdbidValue->uName.pwszName = pDBID->uName.pwszName;
                break;
            case DBKIND_PGUID_NAME:
            {
                // need to create a new string
                pct->value.pdbidValue->uName.pwszName = CoTaskStrDup(pDBID->uName.pwszName);

                if ( 0 == pct->value.pdbidValue->uName.pwszName )
                {
                    pct->value.pdbidValue->eKind = DBKIND_GUID_PROPID;
                    DeleteDBQT( pct );
                    pct = 0;
                    break;
                }    

                // need to allocate and copy guid
                pct->value.pdbidValue->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));
                if ( 0 == pct->value.pdbidValue->uName.pwszName )
                {
                    CoTaskMemFree( pct->value.pdbidValue->uName.pwszName );
                    pct->value.pdbidValue->uName.pwszName = 0;
                    pct->value.pdbidValue->eKind = DBKIND_GUID_PROPID;
                    DeleteDBQT( pct );
                    pct = 0;
                    break;
                }    

                *pct->value.pdbidValue->uGuid.pguid = *pDBID->uGuid.pguid;
                break;
            }
            case DBKIND_PGUID_PROPID:
            {
                // need to allocate and copy guid
                pct->value.pdbidValue->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));

                if ( 0 == pct->value.pdbidValue->uGuid.pguid )
                {
                    pct->value.pdbidValue->eKind = DBKIND_GUID_PROPID;
                    DeleteDBQT( pct );
                    pct = 0;
                    break;
                }    

                *pct->value.pdbidValue->uGuid.pguid = *pDBID->uGuid.pguid;
                break;
            }
            default:
                Assert(0);
            }
        }
    }
    return pct;
}

//-----------------------------------------------------------------------------
// @func PctMkColNodeFromStr
//
// This function takes a column name string as input and creates a column_name
// node containing the appropriate GUID information.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctMkColNodeFromStr(
    LPWSTR                      pwszColumnName, // @parm IN | name of column
    CImpIParserSession*         pIPSession,     // @parm IN | Parser Session
    CImpIParserTreeProperties*  pIPTProps )     // @parm IN | Parser Properties
{
    DBCOMMANDTREE* pct = 0;

    pct = PctBuiltInProperty( pwszColumnName, pIPSession, pIPTProps );
    if ( 0 == pct )
        { // this may be a user defined property, or is undefined
        DBTYPE dbType = 0;
        HRESULT hr = pIPSession->m_pCPropertyList->LookUpPropertyName( pwszColumnName, &pct, &dbType );

        if ( E_OUTOFMEMORY == hr )
            pIPTProps->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
        else if ( FAILED(hr) )
        {
            pIPTProps->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_COLUMN_NOT_DEFINED );
            pIPTProps->SetErrorToken( pwszColumnName );
        }
        else
        {
            AssertReq( 0 != pct );
            pIPTProps->SetDBType( dbType );
        }
    }
    return pct;
}


/* ************************************************************************************************ */
/* ************************************************************************************************ */
/* ************************************************************************************************ */

#define _OR 257
#define _AND 258
#define _NOT 259
#define _UMINUS 260
#define mHighest 261
#define _ALL 262
#define _ANY 263
#define _ARRAY 264
#define _AS 265
#define _ASC 266
#define _CAST 267
#define _COERCE 268
#define _CONTAINS 269
#define _CONTENTS 270
#define _CREATE 271
#define _DEEP_TRAVERSAL 272
#define _DESC 273
#define _DOT 274
#define _DOTDOT 275
#define _DOTDOT_SCOPE 276
#define _DOTDOTDOT 277
#define _DOTDOTDOT_SCOPE 278
#define _DROP 279
#define _EXCLUDE_SEARCH_TRAVERSAL 280
#define _FALSE 281
#define _FREETEXT 282
#define _FROM 283
#define _IS 284
#define _ISABOUT 285
#define _IS_NOT 286
#define _LIKE 287
#define _MATCHES 288
#define _NEAR 289
#define _NOT_LIKE 290
#define _NULL 291
#define _OF 292
#define _ORDER_BY 293
#define _PASSTHROUGH 294
#define _PROPERTYNAME 295
#define _PROPID 296
#define _RANKMETHOD 297
#define _SELECT 298
#define _SET 299
#define _SCOPE 300
#define _SHALLOW_TRAVERSAL 301
#define _FORMSOF 302
#define _SOME 303
#define _TABLE 304
#define _TRUE 305
#define _TYPE 306
#define _UNION 307
#define _UNKNOWN 308
#define _URL 309
#define _VIEW 310
#define _WHERE 311
#define _WEIGHT 312
#define _GE 313
#define _LE 314
#define _NE 315
#define _CONST 316
#define _ID 317
#define _TEMPVIEW 318
#define _INTNUM 319
#define _REALNUM 320
#define _SCALAR_FUNCTION_REF 321
#define _STRING 322
#define _DATE 323
#define _PREFIX_STRING 324
#define _DELIMITED_ID 325
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,    0,    2,    4,    4,    1,    1,    5,    5,
    5,    6,    6,   10,   10,   10,   10,   10,   13,   14,
   11,   11,   12,   12,   15,   16,    3,   17,   19,   19,
   20,   20,   23,   23,   24,   24,   24,   21,   21,   25,
   27,   27,   27,   29,   30,   30,   30,   33,   34,   32,
   32,   35,   35,   36,   36,   37,   37,   37,   38,   38,
   39,   28,   28,   26,   40,   40,   40,   40,   40,   40,
   40,   40,   31,   41,   41,   42,   22,   22,   43,   43,
   45,   45,   45,   45,   45,   45,   45,   46,   53,   53,
   55,   55,   55,   54,   54,   54,   54,   54,   54,   47,
   57,   57,   61,   58,   60,   60,   62,   62,   64,   64,
   66,   69,   66,   68,   68,   68,   68,   68,   63,   63,
   65,   65,   67,   67,   70,   71,   72,   76,   76,   77,
   75,   75,   78,   78,   78,   73,   79,   80,   80,   74,
   81,   81,   82,   82,   83,   83,   83,   83,   84,   59,
   59,   48,   49,   49,   85,   50,   86,   51,   89,   90,
   90,   87,   87,   87,   87,   87,   87,   87,   87,   87,
   87,   87,   87,   87,   87,   87,   87,   87,   87,   88,
   91,   93,   92,   92,   94,   94,   95,   52,   52,   44,
   44,   96,   96,   98,   98,   97,   99,  101,  100,  100,
  100,  100,  100,  100,  100,  103,  102,  102,  104,  105,
  105,  106,  108,  108,  108,  107,  107,   18,   18,    9,
    9,    9,  109,  109,  114,  115,  115,   56,   56,  117,
  113,  116,  112,  110,  118,  118,  111,    7,    8,
};
short yylen[] = {                                         2,
    1,    2,    1,    2,    0,    1,    3,    2,    1,    1,
    1,    0,    1,    1,    1,    1,    1,    1,    1,    1,
    8,    3,    1,    1,    1,    1,    2,    5,    0,    1,
    1,    1,    3,    1,    1,    3,    1,    1,    1,    3,
    1,    1,    1,    4,    5,    7,    5,    1,    1,    0,
    1,    3,    1,    4,    6,    0,    2,    2,    3,    1,
    1,    0,    2,    2,    1,    1,    3,    3,    5,    5,
    3,    3,    3,    4,    4,    2,    0,    1,    2,    5,
    1,    1,    1,    1,    1,    1,    1,    3,    1,    6,
    1,    3,    1,    1,    1,    1,    1,    1,    1,    8,
    0,    2,    0,    2,    1,    3,    1,    3,    1,    2,
    1,    0,    4,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    2,    2,    1,    2,
    1,    1,    1,    3,    1,    6,    1,    3,    1,    4,
    3,    1,    5,    1,    1,    1,    1,    1,    1,    0,
    2,    6,    3,    3,    1,    7,    1,    3,    1,    1,
    1,    1,    2,    2,    1,    2,    2,    1,    2,    2,
    1,    2,    2,    1,    2,    2,    1,    2,    2,    4,
    1,    1,    0,    1,    3,    1,    1,    3,    3,    1,
    3,    1,    3,    1,    2,    1,    1,    1,    1,    3,
    3,    3,    3,    3,    3,    0,    2,    3,    2,    3,
    1,    2,    0,    1,    1,    1,    1,    0,    1,    1,
    1,    1,    8,    8,    1,    0,    2,    1,    3,    1,
    1,    1,    1,    3,    2,    1,    3,    7,    3,
};
short yydefred[] = {                                      0,
    0,    0,    0,    0,    0,    0,    3,    0,    0,    9,
   10,   11,    0,  220,  221,  222,    0,    0,   30,    0,
    0,    0,    0,    2,    0,    6,    4,   13,    8,    0,
   27,  219,   25,   65,    0,    0,    0,    0,  239,   32,
   37,    0,    0,    0,    0,   34,  233,    0,    0,  234,
  237,    7,   93,   20,  217,    0,    0,  216,    0,  211,
    0,    0,    0,    0,    0,    0,    0,    0,   38,   39,
    0,    0,  235,    0,    0,  214,  215,  212,   49,    0,
   72,   71,   67,   68,    0,   36,    0,    0,    0,   41,
   42,   43,    0,    0,   64,    0,   28,   78,   33,   19,
  232,  231,    0,    0,   92,  210,    0,    0,    0,    0,
    0,    0,    0,   40,    0,    0,    0,  198,    0,    0,
    0,    0,  192,  194,    0,    0,    0,    0,    0,   69,
   70,  238,    0,   76,    0,    0,   73,    0,    0,    0,
    0,    0,   53,   26,   63,    0,    0,    0,    0,    0,
  196,    0,  197,    0,  195,    0,    0,    0,    0,    0,
    0,  207,   81,   82,   83,   84,   85,   86,   87,    0,
    0,  225,    0,    0,    0,    0,    0,    0,    0,    0,
   44,    0,    0,    0,    0,  208,    0,    0,  193,  201,
  200,  202,  204,  203,  205,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  223,  224,    0,   74,   75,   57,   58,    0,
   61,    0,   60,   52,    0,   45,   47,   80,    0,    0,
    0,    0,    0,  159,  161,  160,  163,  164,  178,  179,
  175,  176,  166,  167,  169,  170,  172,  173,   24,   23,
   14,   15,   16,   88,   17,   18,    0,    0,  158,  188,
  189,  155,  153,  154,  230,  227,    0,    0,    0,   54,
    0,    0,  102,  103,    0,    0,    0,  181,    0,    0,
    0,   59,   46,    0,    0,    0,    0,  157,    0,   22,
    0,  186,    0,    0,  229,   55,   90,    0,  123,  112,
    0,    0,  125,  126,  124,    0,    0,  107,  109,    0,
  111,    0,    0,  116,  117,  118,    0,    0,  152,    0,
    0,  182,  180,  187,    0,    0,    0,    0,    0,  119,
  120,    0,  121,  122,    0,  110,    0,  135,    0,  129,
    0,  151,  156,    0,  185,  100,    0,    0,    0,  147,
  148,    0,  142,    0,  137,    0,    0,  108,    0,  128,
  131,  132,  130,    0,  113,    0,  140,    0,    0,  134,
    0,  141,    0,  139,    0,   21,  149,    0,    0,  136,
  143,  138,
};
short yydgoto[] = {                                       5,
    6,    7,    8,   27,    9,   29,   10,   11,   12,  254,
  255,  256,  102,   55,   56,   57,   13,   31,   20,   44,
   68,   97,   45,   46,   69,   70,   89,  114,   90,   91,
   92,  141,   36,   37,  142,  143,  180,  222,  223,   38,
  110,  111,   98,  121,  162,  163,  164,  165,  166,  167,
  168,  169,  170,  206,   58,  266,  231,  285,  319,  306,
  286,  307,  332,  308,  335,  309,  310,  311,  327,  312,
  313,  314,  315,  316,  317,  339,  340,  341,  356,  375,
  352,  353,  354,  378,  263,  289,  207,  259,  237,  238,
  279,  293,  323,  294,  325,  122,  152,  123,  154,  124,
  125,  126,  127,   32,   59,   60,   61,   78,   14,   15,
   16,   48,  103,  173,  213,  104,  267,   50,
};
short yysindex[] = {                                    -81,
 -271, -241, -183, -155,    0,  -81,    0,   79,  107,    0,
    0,    0, -136,    0,    0,    0,  -52,  -52,    0,  -35,
 -171, -145, -134,    0,  107,    0,    0,    0,    0, -242,
    0,    0,    0,    0,    0,  -77,  -83,  -69,    0,    0,
    0,    0,  166,  -56,  195,    0,    0,  -48,  -65,    0,
    0,    0,    0,    0,    0,    0,  251,    0,  263,    0,
 -129,    7,  -26,   58,   45,    7,  -30,   28,    0,    0,
 -231,  -88,    0,    7, -242,    0,    0,    0,    0,   75,
    0,    0,    0,    0,  -35,    0,   44,  315,   96,    0,
    0,    0,  -21,  129,    0,  -27,    0,    0,    0,    0,
    0,    0,  100,  104,    0,    0,  124,  -56,    7,  -33,
  106,  347,    7,    0,    7,  351,  362,    0,  -31,  376,
  180,  165,    0,    0,  399, -102,  -58,    7,    7,    0,
    0,    0,    0,    0, -133,  171,    0,  186,  187, -142,
  409,  407,    0,    0,    0,  168,  347,  347,   -8,  130,
    0,  -31,    0,  -31,    0, -114,  -67,  413,  414,  415,
  416,    0,    0,    0,    0,    0,    0,    0,    0,  -42,
  -61,    0,  151,  151,    7,   44,   44,  167,  169,  -34,
    0,  347,  418,  419,  421,    0,  422,  165,    0,    0,
    0,    0,    0,    0,    0, -209, -209, -209, -209, -139,
 -139, -139, -139, -139, -139,  102,  200,  174,  175,  145,
  145,    7,    0,    0,  192,    0,    0,    0,    0,  160,
    0,  141,    0,    0,  347,    0,    0,    0,  205,  427,
  433,  152,  429,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  435,  385,    0,    0,
    0,    0,    0,    0,    0,    0,  353,  196,  160,    0,
  437,    7,    0,    0,  438,  158,  -36,    0,  102,    7,
  442,    0,    0,  441,  444,   86,  423,    0,  443,    0,
  445,    0,  393,  446,    0,    0,    0,  447,    0,    0,
  451,  452,    0,    0,    0,  -97,  -13,    0,    0,  -38,
    0,    0,    0,    0,    0,    0, -110,  176,    0,  423,
  177,    0,    0,    0,  102,  423,   86,  -80,  172,    0,
    0,   86,    0,    0,   86,    0,  453,    0, -110,    0,
   72,    0,    0,  454,    0,    0,  -37,    0,    0,    0,
    0,  217,    0,  185,    0,  455,  -13,    0,  459,    0,
    0,    0,    0,    7,    0,  -80,    0,  461,  181,    0,
  463,    0,  183,    0,  235,    0,    0,  465,  181,    0,
    0,    0,
};
short yyrindex[] = {                                      0,
    0,    0,  -28,    0,    0,  487,    0,  502,   65,    0,
    0,    0,   41,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   65,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   35,    0,    0,    0,    0,    0,
    0,  -29,    0,    0,  225,    0,    0,    0,   59,    0,
    0,    0,    0,    0,    0,   12,    0,    0,   51,    0,
   55,    0,    0,    0,    0,    0,    0,   36,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   24,    0,
    0,    0,    0,    0,    0,  118,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  466,    0,    0,    0,    0,    0,    0,  118,    0,
   38,   23,    0,    0,  118,   11,    0,    0,    0,    0,
    0,    0,  162,    0,    0,    0,    0,    0,    0,  -19,
    0,  468,    0,    0,    0,    0,  466,  466,    0,    0,
    0,  118,    0,  118,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   67,    0,   61,   61,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   26,    0,    0,
    0,    0,    0,    0,    0,    0,  471,  189,    0, -149,
 -118, -112,   73,   92,   98,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  466,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   22,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  420,    0,
    0,    0,    0,    0,    0,    0,   84,    0,    0,    0,
    0,    0,    0,  424,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  473,  -11,    0,    0,    0,
    0,   95,  109,    0,    0,    0,    0,    0,    0,   84,
    0,    0,    0,    0,    0,   84,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   77,    0,   -7,    0,
    0,    0,    0,    0,    0,    0,    0,   60,   62,    0,
    0,    0,    0,  274,    0,    0,   37,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,
};
short yygindex[] = {                                      0,
    0,  508,    0,    0,  509,  491,    0,    0,    0, -190,
  154,    0,    0,    0,  -17,   68,    0,    0,    0,  434,
  412,    0,    0,  450,    0,    0,    0,    0,    0,  417,
    0, -104,   13,   40,    0,  340,    0,  303,  255,   42,
    0,  269,    0,  406,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  -22,  256,  329,    0, -278,  202,
    0,  198,    0,  197,    0,  221,    0,    0,    0, -163,
 -275, -235, -212,    0,  193,    0,  194,    0,    0,    0,
    0,  170,    0,    0,  324,    0,    0,    0,  224,  229,
    0,    0,    0,    0,    0,  386,    0,  383,    0,  425,
    0,    0,    0,    0,    0,  464,    0,    0,    0,    0,
    0,    0,    0,  411,  367,    0,  262,    0,
};
#define YYTABLESIZE 550
short yytable[] = {                                      35,
   35,  300,   42,  365,  290,  220,   40,  137,  119,   87,
  199,   91,  119,   29,   35,  338,   26,  204,  200,  205,
   56,  228,  190,   62,  334,  191,  331,  105,   53,  105,
  127,  127,  186,  127,   66,   77,  127,   79,   17,   41,
  218,  343,  184,  185,   79,   82,   84,  346,   86,   35,
  209,  199,  349,   42,  213,   91,  105,   26,  236,   39,
  226,   53,  228,  190,   12,  362,  191,   42,   18,  199,
   91,   91,   91,   91,   33,  106,   54,  106,   19,   93,
  228,  190,   62,  150,  191,   33,  331,   43,  292,  131,
  349,  133,  350,   66,   77,  144,   79,   79,  213,  218,
  145,   80,  146,  145,  171,  146,   94,   33,   95,  209,
  172,  172,  105,  213,  162,  351,  127,  236,  305,  226,
  271,  135,  234,  235,  150,  300,   89,   89,   89,  178,
  350,   94,  114,  114,  345,  114,   76,   26,   43,   21,
  175,   22,  150,   77,  116,  177,  115,  115,  136,  115,
   47,  174,   43,  351,  146,   94,   30,   79,  179,  330,
  106,   23,   99,  236,  348,   28,  190,   94,   98,   94,
   94,   49,   94,  229,  230,  230,  233,  361,  337,  270,
  145,  156,   51,  157,  269,  131,   99,  132,  257,    1,
  191,   64,   98,  192,  265,   65,   62,    2,   99,   63,
   99,   99,  348,   99,   98,  374,   98,   98,  158,   98,
  159,   66,   53,  193,  215,  382,    3,    4,  114,  330,
  131,  302,  208,  160,  209,  210,   67,  118,  211,  161,
  100,  118,  115,  101,  132,   41,  281,  194,   71,  269,
  195,  303,   29,  304,  333,  105,  301,   72,  151,  127,
  127,   73,  115,   35,  265,   63,  116,  367,   33,  291,
  366,  257,  265,  302,   33,   34,  120,  199,  199,   88,
  201,  202,  203,  138,  221,  380,   91,   91,  379,  190,
   33,   33,  191,  303,   91,  304,   33,   34,   29,   56,
   33,   81,  228,  106,   62,   91,   74,   91,   91,   66,
  228,   91,   62,  199,  127,   66,   75,  257,   48,   49,
   49,   48,   48,   66,  144,  190,   62,  144,  191,  228,
  228,   62,   62,   33,   91,   91,   91,   66,   77,  236,
   79,  226,   66,   66,   62,   12,  165,  236,   96,  226,
  150,  150,   85,   12,  299,   66,  257,  109,  131,  107,
  132,  114,  114,   95,  112,  168,  236,  236,  226,  226,
  113,  171,   12,   12,  128,  115,  115,  150,  129,  150,
  301,  145,   96,  146,   33,   83,  150,   95,   97,   89,
   89,   89,  249,  131,  206,  140,  206,  302,  206,   95,
  147,   95,   95,  303,   95,  304,   96,  132,  133,  206,
  133,  148,   97,   64,  117,  206,  250,  303,   96,  304,
   96,   96,  139,   96,   97,  150,   97,   97,   33,   97,
  251,  252,  153,  253,  239,  241,  243,  245,  247,  240,
  242,  244,  246,  248,  206,   48,  151,   49,  119,   48,
   33,  130,  107,  183,  216,  217,  117,  176,  177,  181,
  182,  187,  196,  197,  198,  199,  212,  225,  218,  226,
  219,  227,  228,  258,  260,  261,  262,  183,  221,  272,
  273,  274,  276,  275,  277,  278,  280,  283,  287,  288,
  296,  297,  298,  320,  318,  322,    1,  326,  321,  324,
  328,  329,  359,  355,  342,  344,  368,  364,  369,  370,
  373,    5,  303,  376,  377,  381,   50,   31,   51,  101,
  101,  104,  183,   24,   25,   52,  184,  371,  108,  132,
   99,  224,  268,  282,  149,  134,  232,  284,  347,  357,
  336,  358,  360,  363,  264,  372,  189,  188,  106,  174,
  214,  295,    0,    0,    0,    0,    0,    0,    0,  155,
};
short yycheck[] = {                                      17,
   18,   40,   20,   41,   41,   40,   42,   41,   40,   40,
    0,    0,   40,   42,   44,  126,   46,   60,   61,   62,
   40,    0,    0,    0,   38,    0,  124,   39,  271,   41,
   38,   39,   41,   41,    0,    0,   44,    0,  310,  271,
    0,  320,  147,  148,   62,   63,   64,  326,   66,   67,
    0,   41,  328,   71,    0,   44,   74,   46,    0,   18,
    0,  271,   41,   41,    0,  341,   41,   85,  310,   59,
   59,   60,   61,   62,  317,   39,  319,   41,  262,   67,
   59,   59,   59,    0,   59,  317,  124,   20,  279,  107,
  366,  109,  328,   59,   59,  113,   59,  115,   44,   59,
   41,   62,   41,   44,  127,   44,   67,  317,   67,   59,
  128,  129,  124,   59,  264,  328,  124,   59,   33,   59,
  225,  109,  262,  263,   41,   40,   60,   61,   62,  272,
  366,  281,   38,   39,  325,   41,  266,   59,   71,  295,
  274,  297,   59,  273,  278,  264,   38,   39,  109,   41,
  322,  264,   85,  366,  115,  305,  293,  175,  301,  257,
  124,  317,  281,  303,  328,   59,  281,  317,  281,  319,
  320,  317,  322,  196,  197,  198,  199,  341,  289,   39,
  113,  284,  317,  286,   44,  126,  305,  126,  206,  271,
  305,  275,  305,  308,  212,  265,  274,  279,  317,  277,
  319,  320,  366,  322,  317,  369,  319,  320,  267,  322,
  269,   46,  271,  281,  175,  379,  298,  299,  124,  257,
  126,  302,  284,  282,  286,  287,  283,  259,  290,  288,
  319,  259,  124,  322,  126,  271,   41,  305,   44,   44,
  308,  322,  271,  324,  258,  257,  285,  296,  257,  257,
  258,  317,  274,  283,  272,  277,  278,   41,  317,  277,
   44,  279,  280,  302,  317,  318,  294,  257,  258,  300,
  313,  314,  315,  307,  309,   41,  265,  266,   44,  257,
  317,  317,  257,  322,  273,  324,  317,  318,  317,  309,
  317,  318,  271,  257,  271,  284,   46,  286,  287,  265,
  279,  290,  279,  293,  312,  271,   44,  325,  274,  275,
  276,  277,  278,  279,   41,  293,  293,   44,  293,  298,
  299,  298,  299,  317,  313,  314,  315,  293,  293,  271,
  293,  271,  298,  299,  311,  271,  264,  279,  311,  279,
  257,  258,  298,  279,  259,  311,  364,  304,  289,  275,
  289,  257,  258,  281,   40,  264,  298,  299,  298,  299,
  265,  264,  298,  299,  265,  257,  258,  284,  265,  286,
  285,  312,  281,  312,  317,  318,  293,  305,  281,  313,
  314,  315,  281,  289,  267,   39,  269,  302,  271,  317,
   40,  319,  320,  322,  322,  324,  305,  289,  322,  282,
  324,   40,  305,  275,  276,  288,  305,  322,  317,  324,
  319,  320,  307,  322,  317,   40,  319,  320,  317,  322,
  319,  320,  258,  322,  201,  202,  203,  204,  205,  201,
  202,  203,  204,  205,  317,  274,  257,  276,   40,  278,
  317,  318,  275,  276,  176,  177,  276,  262,  262,   41,
   44,  322,   40,   40,   40,   40,  306,   40,  292,   41,
  292,   41,   41,  264,  291,  291,  322,  276,  309,  265,
   44,   39,   44,  322,   40,   91,  124,   41,   41,  322,
   39,   41,   39,   41,   62,   93,    0,   41,   44,   44,
   40,   40,   40,  322,  319,  319,  312,   44,   44,   41,
   40,    0,  322,   41,  322,   41,   41,  283,   41,   39,
  322,   39,   93,    6,    6,   25,   93,  364,   85,  108,
   71,  182,  220,  269,  119,  109,  198,  272,  327,  332,
  310,  335,  339,  341,  211,  366,  154,  152,   75,  129,
  174,  280,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  125,
};
#define YYFINAL 5
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 325
#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"'!'",0,0,0,0,"'&'","'\\''","'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,
0,0,0,0,0,0,0,0,0,"';'","'<'","'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'|'",0,"'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_OR","_AND","_NOT","_UMINUS",
"mHighest","_ALL","_ANY","_ARRAY","_AS","_ASC","_CAST","_COERCE","_CONTAINS",
"_CONTENTS","_CREATE","_DEEP_TRAVERSAL","_DESC","_DOT","_DOTDOT",
"_DOTDOT_SCOPE","_DOTDOTDOT","_DOTDOTDOT_SCOPE","_DROP",
"_EXCLUDE_SEARCH_TRAVERSAL","_FALSE","_FREETEXT","_FROM","_IS","_ISABOUT",
"_IS_NOT","_LIKE","_MATCHES","_NEAR","_NOT_LIKE","_NULL","_OF","_ORDER_BY",
"_PASSTHROUGH","_PROPERTYNAME","_PROPID","_RANKMETHOD","_SELECT","_SET",
"_SCOPE","_SHALLOW_TRAVERSAL","_FORMSOF","_SOME","_TABLE","_TRUE","_TYPE",
"_UNION","_UNKNOWN","_URL","_VIEW","_WHERE","_WEIGHT","_GE","_LE","_NE",
"_CONST","_ID","_TEMPVIEW","_INTNUM","_REALNUM","_SCALAR_FUNCTION_REF",
"_STRING","_DATE","_PREFIX_STRING","_DELIMITED_ID",
};
char *yyrule[] = {
"$accept : entry_point",
"entry_point : definition_list",
"entry_point : definition_list executable_statement",
"entry_point : executable_statement",
"executable_statement : ordered_query_specification semicolon",
"semicolon :",
"semicolon : ';'",
"definition_list : definition_list definition opt_semi",
"definition_list : definition opt_semi",
"definition : create_view_statement",
"definition : drop_view_statement",
"definition : set_statement",
"opt_semi :",
"opt_semi : ';'",
"typed_literal : _INTNUM",
"typed_literal : _REALNUM",
"typed_literal : _STRING",
"typed_literal : relative_date_time",
"typed_literal : boolean_literal",
"unsigned_integer : _INTNUM",
"integer : _INTNUM",
"relative_date_time : identifier '(' identifier ',' _INTNUM ',' relative_date_time ')'",
"relative_date_time : identifier '(' ')'",
"boolean_literal : _TRUE",
"boolean_literal : _FALSE",
"identifier : _ID",
"correlation_name : identifier",
"ordered_query_specification : query_specification opt_order_by_clause",
"query_specification : _SELECT opt_set_quantifier select_list from_clause opt_where_clause",
"opt_set_quantifier :",
"opt_set_quantifier : _ALL",
"select_list : select_sublist",
"select_list : '*'",
"select_sublist : select_sublist ',' derived_column",
"select_sublist : derived_column",
"derived_column : identifier",
"derived_column : correlation_name '.' identifier",
"derived_column : _CREATE",
"from_clause : common_from_clause",
"from_clause : from_view_clause",
"common_from_clause : _FROM scope_specification opt_AS_clause",
"scope_specification : unqualified_scope_specification",
"scope_specification : qualified_scope_specification",
"scope_specification : union_all_scope_specification",
"unqualified_scope_specification : _SCOPE '(' scope_definition ')'",
"qualified_scope_specification : machine_name _DOTDOTDOT_SCOPE '(' scope_definition ')'",
"qualified_scope_specification : machine_name _DOT catalog_name _DOTDOT_SCOPE '(' scope_definition ')'",
"qualified_scope_specification : catalog_name _DOTDOT_SCOPE '(' scope_definition ')'",
"machine_name : identifier",
"catalog_name : identifier",
"scope_definition :",
"scope_definition : scope_element_list",
"scope_element_list : scope_element_list ',' scope_element",
"scope_element_list : scope_element",
"scope_element : '\\'' opt_traversal_exclusivity path_or_virtual_root_list '\\''",
"scope_element : '\\'' opt_traversal_exclusivity '(' path_or_virtual_root_list ')' '\\''",
"opt_traversal_exclusivity :",
"opt_traversal_exclusivity : _DEEP_TRAVERSAL _OF",
"opt_traversal_exclusivity : _SHALLOW_TRAVERSAL _OF",
"path_or_virtual_root_list : path_or_virtual_root_list ',' path_or_virtual_root",
"path_or_virtual_root_list : path_or_virtual_root",
"path_or_virtual_root : _URL",
"opt_AS_clause :",
"opt_AS_clause : _AS correlation_name",
"from_view_clause : _FROM view_name",
"view_name : _TEMPVIEW",
"view_name : identifier",
"view_name : catalog_name _DOTDOT _TEMPVIEW",
"view_name : catalog_name _DOTDOT identifier",
"view_name : machine_name _DOT catalog_name _DOTDOT _TEMPVIEW",
"view_name : machine_name _DOT catalog_name _DOTDOT identifier",
"view_name : machine_name _DOTDOTDOT identifier",
"view_name : machine_name _DOTDOTDOT _TEMPVIEW",
"union_all_scope_specification : '(' union_all_scope_element ')'",
"union_all_scope_element : union_all_scope_element _UNION _ALL explicit_table",
"union_all_scope_element : explicit_table _UNION _ALL explicit_table",
"explicit_table : _TABLE qualified_scope_specification",
"opt_where_clause :",
"opt_where_clause : where_clause",
"where_clause : _WHERE search_condition",
"where_clause : _WHERE _PASSTHROUGH '(' _STRING ')'",
"predicate : comparison_predicate",
"predicate : contains_predicate",
"predicate : freetext_predicate",
"predicate : like_predicate",
"predicate : matches_predicate",
"predicate : vector_comparison_predicate",
"predicate : null_predicate",
"comparison_predicate : column_reference_or_cast comp_op typed_literal",
"column_reference_or_cast : column_reference",
"column_reference_or_cast : _CAST '(' column_reference _AS dbtype ')'",
"column_reference : identifier",
"column_reference : correlation_name '.' identifier",
"column_reference : _CREATE",
"comp_op : '='",
"comp_op : _NE",
"comp_op : '<'",
"comp_op : '>'",
"comp_op : _LE",
"comp_op : _GE",
"contains_predicate : _CONTAINS '(' opt_contents_column_reference '\\'' content_search_condition '\\'' ')' opt_greater_than_zero",
"opt_contents_column_reference :",
"opt_contents_column_reference : column_reference ','",
"$$1 :",
"content_search_condition : $$1 content_search_cond",
"content_search_cond : content_boolean_term",
"content_search_cond : content_search_cond or_operator content_boolean_term",
"content_boolean_term : content_boolean_factor",
"content_boolean_term : content_boolean_term and_operator content_boolean_factor",
"content_boolean_factor : content_boolean_primary",
"content_boolean_factor : not_operator content_boolean_primary",
"content_boolean_primary : content_search_term",
"$$2 :",
"content_boolean_primary : '(' $$2 content_search_cond ')'",
"content_search_term : simple_term",
"content_search_term : prefix_term",
"content_search_term : proximity_term",
"content_search_term : stemming_term",
"content_search_term : isabout_term",
"or_operator : _OR",
"or_operator : '|'",
"and_operator : _AND",
"and_operator : '&'",
"not_operator : _NOT",
"not_operator : '!'",
"simple_term : _STRING",
"prefix_term : _PREFIX_STRING",
"proximity_term : proximity_operand proximity_expression_list",
"proximity_expression_list : proximity_expression_list proximity_expression",
"proximity_expression_list : proximity_expression",
"proximity_expression : proximity_specification proximity_operand",
"proximity_operand : simple_term",
"proximity_operand : prefix_term",
"proximity_specification : _NEAR",
"proximity_specification : _NEAR '(' ')'",
"proximity_specification : '~'",
"stemming_term : _FORMSOF '(' stem_type ',' stemmed_simple_term_list ')'",
"stem_type : _STRING",
"stemmed_simple_term_list : stemmed_simple_term_list ',' simple_term",
"stemmed_simple_term_list : simple_term",
"isabout_term : _ISABOUT '(' vector_component_list ')'",
"vector_component_list : vector_component_list ',' vector_component",
"vector_component_list : vector_component",
"vector_component : vector_term _WEIGHT '(' weight_value ')'",
"vector_component : vector_term",
"vector_term : simple_term",
"vector_term : prefix_term",
"vector_term : proximity_term",
"vector_term : stemming_term",
"weight_value : _STRING",
"opt_greater_than_zero :",
"opt_greater_than_zero : '>' _INTNUM",
"freetext_predicate : _FREETEXT '(' opt_contents_column_reference _STRING ')' opt_greater_than_zero",
"like_predicate : column_reference _LIKE wildcard_search_pattern",
"like_predicate : column_reference _NOT_LIKE wildcard_search_pattern",
"wildcard_search_pattern : _STRING",
"matches_predicate : _MATCHES '(' column_reference ',' matches_string ')' opt_greater_than_zero",
"matches_string : _STRING",
"vector_comparison_predicate : column_reference_or_cast vector_comp_op vector_literal",
"all : _ALL",
"some : _SOME",
"some : _ANY",
"vector_comp_op : '='",
"vector_comp_op : '=' all",
"vector_comp_op : '=' some",
"vector_comp_op : _NE",
"vector_comp_op : _NE all",
"vector_comp_op : _NE some",
"vector_comp_op : '<'",
"vector_comp_op : '<' all",
"vector_comp_op : '<' some",
"vector_comp_op : '>'",
"vector_comp_op : '>' all",
"vector_comp_op : '>' some",
"vector_comp_op : _LE",
"vector_comp_op : _LE all",
"vector_comp_op : _LE some",
"vector_comp_op : _GE",
"vector_comp_op : _GE all",
"vector_comp_op : _GE some",
"vector_literal : _ARRAY left_sqbrkt opt_literal_list right_sqbrkt",
"left_sqbrkt : '['",
"right_sqbrkt : ']'",
"opt_literal_list :",
"opt_literal_list : literal_list",
"literal_list : literal_list comma typed_literal",
"literal_list : typed_literal",
"comma : ','",
"null_predicate : column_reference _IS _NULL",
"null_predicate : column_reference _IS_NOT _NULL",
"search_condition : boolean_term",
"search_condition : search_condition or_op boolean_term",
"boolean_term : boolean_factor",
"boolean_term : boolean_term and_op boolean_factor",
"boolean_factor : boolean_test",
"boolean_factor : not_op boolean_test",
"or_op : _OR",
"and_op : _AND",
"not_op : _NOT",
"boolean_test : boolean_primary",
"boolean_test : boolean_primary _IS _TRUE",
"boolean_test : boolean_primary _IS _FALSE",
"boolean_test : boolean_primary _IS _UNKNOWN",
"boolean_test : boolean_primary _IS_NOT _TRUE",
"boolean_test : boolean_primary _IS_NOT _FALSE",
"boolean_test : boolean_primary _IS_NOT _UNKNOWN",
"$$3 :",
"boolean_primary : $$3 predicate",
"boolean_primary : '(' search_condition ')'",
"order_by_clause : _ORDER_BY sort_specification_list",
"sort_specification_list : sort_specification_list ',' sort_specification",
"sort_specification_list : sort_specification",
"sort_specification : sort_key opt_ordering_specification",
"opt_ordering_specification :",
"opt_ordering_specification : _ASC",
"opt_ordering_specification : _DESC",
"sort_key : column_reference",
"sort_key : integer",
"opt_order_by_clause :",
"opt_order_by_clause : order_by_clause",
"set_statement : set_propertyname_statement",
"set_statement : set_rankmethod_statement",
"set_statement : set_global_directive",
"set_propertyname_statement : _SET _PROPERTYNAME guid_format _PROPID property_id _AS column_alias opt_type_clause",
"set_propertyname_statement : _SET _PROPERTYNAME guid_format _PROPID property_name _AS column_alias opt_type_clause",
"column_alias : identifier",
"opt_type_clause :",
"opt_type_clause : _TYPE dbtype",
"dbtype : base_dbtype",
"dbtype : base_dbtype '|' base_dbtype",
"base_dbtype : identifier",
"property_id : unsigned_integer",
"property_name : _STRING",
"guid_format : _STRING",
"set_rankmethod_statement : _SET _RANKMETHOD rankmethod",
"rankmethod : _ID _ID",
"rankmethod : _ID",
"set_global_directive : _SET _ID _ID",
"create_view_statement : _CREATE _VIEW view_name _AS _SELECT select_list from_clause",
"drop_view_statement : _DROP _VIEW view_name",
};
#endif
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
YYPARSER::YYPARSER(CImpIParserSession* pParserSession, CImpIParserTreeProperties* pParserTreeProperties, YYLEXER & yylex)
        : CYYBase( pParserSession, pParserTreeProperties, yylex ) {
    xyyvs.SetSize(INITSTACKSIZE);
    yydebug = 0;
}
#define YYABORT(sc) { EmptyValueStack( yylval ); return ResultFromScode(sc); }
#define YYFATAL QPARSE_E_INVALID_QUERY
#define YYSUCCESS S_OK
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
int mystrlen(char * str)
{
    Win4Assert( 0 != str );
    int i = 0;
    while ( 0 != str[i] )
        i++;
    return i;        
}
void YYPARSER::ResetParser()
{
     yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

yyssp = xyyss.Get();
yyvsp = xyyvs.Get();
    *yyssp = 0;
}

void YYPARSER::PopVs()
{
    if ( NULL != *yyvsp ) 
        DeleteDBQT(*yyvsp);
    yyvsp--;
}

void YYPARSER::EmptyValueStack( YYAPI_VALUETYPE yylval )
{
    if ( yyvsp != NULL ) 
    {
        if ((*yyvsp != yylval) && (NULL != yylval))
            DeleteDBQT(yylval);

        unsigned cCount = (unsigned)ULONG_PTR(yyvsp - xyyvs.Get());
        for ( unsigned i=0; i < cCount; i++ )
        {
            if (NULL != xyyvs[i] )
                DeleteDBQT(xyyvs[i]);
        }
    }

   //@TODO RE-ACTIVATE
   // note:  This was only done to empty any scope arrays
   //      m_pIPSession->SetScopeProperties(m_pICommand);

        m_pIPTProperties->SetContainsColumn(NULL);
}

int YYPARSER::Parse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

yyssp = xyyss.Get();
yyvsp = xyyvs.Get();
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        YYAPI_VALUENAME = NULL;
        try
        {
            if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) 
                yychar = 0;
        }
        catch (HRESULT hr)
        {
            switch(hr)
            {
            case E_OUTOFMEMORY:
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                break;

            default:
                YYABORT(QPARSE_E_INVALID_QUERY);
                break;
            }
        }
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
        {
            int yysspLoc = (int) ( yyssp - xyyss.Get() );
            xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);
            yyssp = xyyss.Get() + yysspLoc;
        }
        if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
        {
            int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
            xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2); 
            yyvsp = xyyvs.Get() + yyvspLoc;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
#ifdef YYERROR_VERBOSE
// error reporting; done before the goto error recovery
{

    // must be first - cleans m_pIPTProperties
    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);

    int size = 0, totSize = 0;
    int curr_yychar;
    XGrowable<WCHAR> xMsg;
    for ( curr_yychar =0; curr_yychar<=YYMAXTOKEN; curr_yychar++)
    {
    
        if ( ( yycheck[yysindex[yystate] + curr_yychar] == curr_yychar ) ||
             ( yycheck[yyrindex[yystate] + curr_yychar] == curr_yychar ) )
        {          
         
            char * token_name = yyname[curr_yychar];
            if ( 0 != token_name )
            {
               if ( '_' == token_name[0] )
                   token_name++;
               size = mystrlen(token_name) + 1 ;
               xMsg.SetSize(totSize+size+2); // +2 for ", "
               if (0 == MultiByteToWideChar(CP_ACP, 0, token_name, size,
                                            xMsg.Get()+totSize, size))
               {
                    break;
               }
               totSize += size-1;
               wcscpy( xMsg.Get()+totSize, L", " );
               totSize+=2;
            }
        }
    }
    // get rid of last comma
    if ( totSize >= 2 ) 
        (xMsg.Get())[totSize-2] = 0;

    if ( wcslen((YY_CHAR*)m_yylex.YYText()) )
         m_pIPTProperties->SetErrorToken( (YY_CHAR*)m_yylex.YYText() );
    else
         m_pIPTProperties->SetErrorToken(L"<end of input>");
    
    m_pIPTProperties->SetErrorToken(xMsg.Get());
}
#endif //YYERROR_VERBOSE
    if (yyerrflag) goto yyinrecovery;
    yyerror("syntax error");
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
                {
                    int yysspLoc = (int) ( yyssp - xyyss.Get() );
                    xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);
                    yyssp = xyyss.Get() + yysspLoc;
                }
                if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
                {
                    int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
                    xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2); 
                    yyvsp = xyyvs.Get() + yyvspLoc;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\
",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= xyyss.Get()) goto yyabort;
                PopVs();
                --yyssp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{
            yyval = NULL;
            }
break;
case 2:
{
            yyval = yyvsp[0];
            }
break;
case 3:
{
            yyval = yyvsp[0];
            }
break;
case 4:
{
            if (yyvsp[0])
                {
                /* There is a semicolon, either as a statement terminator or as*/
                /* a statement separator.  We don't allow either of those.*/
                m_pIPTProperties->SetErrorHResult(DB_E_MULTIPLESTATEMENTS, MONSQL_SEMI_COLON);
                YYABORT(DB_E_MULTIPLESTATEMENTS);
                }
            yyval = yyvsp[-1];
            }
break;
case 5:
{
            yyval = NULL;
            }
break;
case 6:
{
            yyval = PctAllocNode(DBVALUEKIND_NULL, DBOP_NULL);
            }
break;
case 7:
{
            yyval = NULL;
            }
break;
case 8:
{
            yyval = NULL;
            }
break;
case 9:
{
            yyval = NULL;
            }
break;
case 10:
{
            yyval = NULL;
            }
break;
case 11:
{
            yyval = NULL;
            }
break;
case 14:
{
            AssertReq(yyvsp[0]);
            Assert(VT_UI8 == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt ||
                    VT_I8 == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt ||
                    VT_BSTR == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt);

            m_pIPTProperties->AppendCiRestriction((YY_CHAR*)m_yylex.YYText(), wcslen(m_yylex.YYText()));

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 15:
{
            AssertReq(yyvsp[0]);
            Assert(VT_R8 == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt ||
                    VT_BSTR == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt);

            m_pIPTProperties->AppendCiRestriction((YY_CHAR*)m_yylex.YYText(), wcslen(m_yylex.YYText()));

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 16:
{
            AssertReq(yyvsp[0]);
            Assert(VT_BSTR == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt);

            if (VT_DATE     == m_pIPTProperties->GetDBType() ||
                VT_FILETIME == m_pIPTProperties->GetDBType())
                m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal,
                                                wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal));
            else
                {
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
                m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal,
                                                wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal));
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
                }

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 17:
{
            AssertReq(yyvsp[0]);
            Assert(VT_FILETIME == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt);

            SYSTEMTIME stValue = {0, 0, 0, 0, 0, 0, 0, 0};
            if (FileTimeToSystemTime(&(((PROPVARIANT*)yyvsp[0]->value.pvValue)->filetime), &stValue))
                {
                WCHAR wchDateTime[50];
                if (NULL == wchDateTime)
                    {
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                    YYABORT(E_OUTOFMEMORY);
                    }

                int cItems = swprintf(wchDateTime, L" %4d/%02d/%02d %02d:%02d:%02d",
                                                    stValue.wYear,
                                                    stValue.wMonth,
                                                    stValue.wDay,
                                                    stValue.wHour,
                                                    stValue.wMinute,
                                                    stValue.wSecond);
                m_pIPTProperties->AppendCiRestriction(wchDateTime, wcslen(wchDateTime));
                }

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);

            yyval = yyvsp[0];
        }
break;
case 18:
{
            m_pIPTProperties->AppendCiRestriction((YY_CHAR*)m_yylex.YYText(), wcslen(m_yylex.YYText()));

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 19:
{
            HRESULT hr = CoerceScalar(VT_UI4, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 20:
{
            HRESULT hr = CoerceScalar(VT_I4, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 21:
{
            /* should be DateAdd(<datepart>, <negative integer>, <relative date/time>)*/
            AssertReq(yyvsp[-7]);
            AssertReq(yyvsp[-5]);
            AssertReq(yyvsp[-3]);
            AssertReq(yyvsp[-1]);

            if (0 != _wcsicmp(L"DateAdd", yyvsp[-7]->value.pwszValue))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-7]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"DateAdd");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            HRESULT hr = CoerceScalar(VT_I4, &yyvsp[-3]);
            if (S_OK != hr)
                YYABORT(hr);

            if (((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal > 0)
                {
                WCHAR wchError[30];
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                swprintf(wchError, L"%d", ((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal);
                m_pIPTProperties->SetErrorToken(wchError);
                swprintf(wchError, L"%d", -((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal);
                m_pIPTProperties->SetErrorToken(wchError);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            LARGE_INTEGER hWeek     =   {686047232,    1408};
            LARGE_INTEGER hDay      =   {711573504,     201};
            LARGE_INTEGER hHour     =   {1640261632,      8};
            LARGE_INTEGER hMinute   =   {600000000,       0};
            LARGE_INTEGER hSecond   =   {10000000,        0};

            LARGE_INTEGER hIncr = {0,0};

            bool    fHandleMonth = false;
            ULONG   ulMonths = 1;

            switch ( yyvsp[-5]->value.pwszValue[0] )
                {
                case L'Y':
                case L'y':
                    if (0 == (_wcsicmp(L"YY", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"YEAR", yyvsp[-5]->value.pwszValue)))
                    {
                        /* fall through and handle as 12 months*/
                        ulMonths = 12;
                    }

                case L'Q':
                case L'q':
                    if (0 == (_wcsicmp(L"QQ", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"QUARTER", yyvsp[-5]->value.pwszValue)))
                    {
                        /* fall through and handle as 3 months*/
                        ulMonths = 3;
                    }

                case L'M':
                case L'm':
                    if ( 0 == (_wcsicmp(L"YY", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"YEAR", yyvsp[-5]->value.pwszValue)) ||
                         0 == (_wcsicmp(L"QQ", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"QUARTER", yyvsp[-5]->value.pwszValue)) ||
                         0 == (_wcsicmp(L"MM", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"MONTH", yyvsp[-5]->value.pwszValue)))
                    {
                        /**/
                        /* Convert to system time*/
                        /**/
                        SYSTEMTIME st = { 0, 0, 0, 0, 0, 0, 0, 0 };
                        FileTimeToSystemTime( &((PROPVARIANT*)yyvsp[-1]->value.pvValue)->filetime, &st );

                        LONGLONG llDays       =  0;
                        LONG     lMonthsLeft = ulMonths * -((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal;
                        LONG     yr          = st.wYear;
                        LONG     lCurMonth   = st.wMonth-1;

                        while ( lMonthsLeft )
                        {
                            LONG lMonthsDone = 1;
                            while ( lMonthsDone<=lMonthsLeft )
                            {
                                /* Will we still be in the current year when looking at the prev month?*/
                                if ( 0 == lCurMonth )
                                    break;

                                /* Subtract the number of days in the previous month.  We will adjust*/
                                llDays += DaysInMonth( yr, lCurMonth-1);

                                lMonthsDone++;
                                lCurMonth--;
                            }

                            /* Months left over in prev year*/
                            lMonthsLeft -= lMonthsDone-1;

                            if ( 0 != lMonthsLeft )
                            {
                                yr--;
                                lCurMonth = 12;  /* 11 is December.*/
                            }
                        }

                        /**/
                        /* adjust current date to at most max of destination month*/
                        /**/
                        if ( llDays > 0 && st.wDay > DaysInMonth(yr, lCurMonth-1) )
                            llDays += st.wDay - DaysInMonth(yr, lCurMonth-1);

                        hIncr.QuadPart = hDay.QuadPart * llDays;
                        fHandleMonth = true;
                    }
                    else if (0 == (_wcsicmp(L"MI", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"MINUTE", yyvsp[-5]->value.pwszValue)))
                        hIncr = hMinute;
                    break;

                case L'W':
                case L'w':
                    if (0 == (_wcsicmp(L"WK", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"WEEK", yyvsp[-5]->value.pwszValue)))
                        hIncr = hWeek;
                    break;

                case L'D':
                case L'd':
                    if (0 == (_wcsicmp(L"DD", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"DAY", yyvsp[-5]->value.pwszValue)))
                        hIncr = hDay;
                    break;

                case L'H':
                case L'h':
                    if (0 == (_wcsicmp(L"HH", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"HOUR", yyvsp[-5]->value.pwszValue)))
                        hIncr = hHour;
                    break;

                case L'S':
                case L's':
                    if (0 == (_wcsicmp(L"SS", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"SECOND", yyvsp[-5]->value.pwszValue)))
                        hIncr = hSecond;
                    break;

                default:
                    break;
                }

            if (0 == hIncr.LowPart && 0 == hIncr.HighPart)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-5]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(
                    L"YEAR, QUARTER, MONTH, WEEK, DAY, HOUR, MINUTE, SECOND");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            if ( fHandleMonth )
            {
                ((PROPVARIANT*)yyvsp[-1]->value.pvValue)->hVal.QuadPart -= hIncr.QuadPart;
#ifdef DEBUG
                SYSTEMTIME st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };
                FileTimeToSystemTime( &((PROPVARIANT*)yyvsp[-1]->value.pvValue)->filetime, &st1 );
#endif
            }
            else
            {
                for (int i = 0; i < -((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal; i++)
                    ((PROPVARIANT*)yyvsp[-1]->value.pvValue)->hVal.QuadPart -= hIncr.QuadPart;
            }

            yyval = yyvsp[-1];
            DeleteDBQT(yyvsp[-7]);
            DeleteDBQT(yyvsp[-5]);
            DeleteDBQT(yyvsp[-3]);
            }
break;
case 22:
{
            /* should be getgmdate()*/
            AssertReq(yyvsp[-2]);

            if (0 != _wcsicmp(L"GetGMTDate", yyvsp[-2]->value.pwszValue))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-2]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"GetGMTDate");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[-2]);
            yyvsp[-2] = 0;

            yyval = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }

            HRESULT hr = CoFileTimeNow(&(((PROPVARIANT*)yyval->value.pvValue)->filetime));
            ((PROPVARIANT*)yyval->value.pvValue)->vt = VT_FILETIME;
            }
break;
case 23:
{
            yyval = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            ((PROPVARIANT*)yyval->value.pvValue)->vt = VT_BOOL;
            ((PROPVARIANT*)yyval->value.pvValue)->boolVal = VARIANT_TRUE;
            }
break;
case 24:
{
            yyval = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            ((PROPVARIANT*)yyval->value.pvValue)->vt = VT_BOOL;
            ((PROPVARIANT*)yyval->value.pvValue)->boolVal = VARIANT_FALSE;
            }
break;
case 27:
{
            AssertReq(yyvsp[-1]);      /* need a query specification tree*/

            if (NULL != yyvsp[0])     /* add optional ORDER BY nodes*/
                {
                /* Is project list built correctly?*/
                AssertReq(yyvsp[-1]->pctFirstChild);
                AssertReq(yyvsp[-1]->pctFirstChild->pctNextSibling);
                AssertReq(yyvsp[-1]->pctFirstChild->pctNextSibling->pctFirstChild);
                Assert((yyvsp[-1]->op == DBOP_project) &&
                        (yyvsp[-1]->pctFirstChild->pctNextSibling->op == DBOP_project_list_anchor));

                DBCOMMANDTREE* pctSortList = yyvsp[0]->pctFirstChild;
                AssertReq(pctSortList);

                while (pctSortList)
                    {
                    /* Is sort list built correctly?*/
                    Assert(pctSortList->op == DBOP_sort_list_element);
                    AssertReq(pctSortList->pctFirstChild);
                    Assert((pctSortList->pctFirstChild->op == DBOP_column_name) ||
                            (pctSortList->pctFirstChild->op == DBOP_scalar_constant));

                    if (pctSortList->pctFirstChild->op == DBOP_scalar_constant)
                        {
                        /* we've got an ordinal rather than a column number, so we've got to*/
                        /* walk through the project list to find the corresponding column*/
                        Assert(DBVALUEKIND_VARIANT == pctSortList->pctFirstChild->wKind);
                        Assert(VT_I4 == pctSortList->pctFirstChild->value.pvarValue->vt);

                        DBCOMMANDTREE* pctProjectList = yyvsp[-1]->pctFirstChild->pctNextSibling->pctFirstChild;
                        AssertReq(pctProjectList);

                        LONG cProjectListElements = GetNumberOfSiblings(pctProjectList);
                        if ((cProjectListElements < pctSortList->pctFirstChild->value.pvarValue->lVal) ||
                            (0 >= pctSortList->pctFirstChild->value.pvarValue->lVal))
                            {
                            /* ordinal is larger than number of elements in project list*/
                            WCHAR wchError[30];
                            m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_ORDINAL_OUT_OF_RANGE);
                            swprintf(wchError, L"%d", pctSortList->pctFirstChild->value.pvarValue->lVal);
                            m_pIPTProperties->SetErrorToken(wchError);
                            swprintf(wchError, L"%d", cProjectListElements);
                            m_pIPTProperties->SetErrorToken(wchError);
                            YYABORT(DB_E_ERRORSINCOMMAND);
                            }
                        else
                            {
                            LONG lColumnNumber = 1;

                            while (pctProjectList &&
                                    (lColumnNumber < pctSortList->pctFirstChild->value.pvarValue->lVal))
                                {
                                /* find the ulVal'th column in the project list*/
                                Assert(pctProjectList->op == DBOP_project_list_element);
                                pctProjectList = pctProjectList->pctNextSibling;
                                lColumnNumber++;
                                }

                            DeleteDBQT(pctSortList->pctFirstChild);
                            HRESULT hr = HrQeTreeCopy(&pctSortList->pctFirstChild,
                                                        pctProjectList->pctFirstChild);
                            if (FAILED(hr))
                                {
                                m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
                                YYABORT(hr);
                                }
                            }
                        }

                    pctSortList = pctSortList->pctNextSibling;
                    }

                m_pIPTProperties->SetSortDesc(QUERY_SORTASCEND);    /* reset "stick" sort direction*/
                yyval = PctCreateNode(DBOP_sort, yyvsp[-1], yyvsp[0], NULL);

                if ( NULL == yyval )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                    YYABORT( E_OUTOFMEMORY );
                    }

                }
            else
                {
                yyval = yyvsp[-1];
                }

            AssertReq(yyval);
            }
break;
case 28:
{
            AssertReq(yyvsp[-2]);      /* need a select list*/
            AssertReq(yyvsp[-1]);      /* need a from clause*/

            if (NULL != yyvsp[-1]->pctNextSibling)
                {   /* the from clause is a from view*/
                if (DBOP_outall_name == yyvsp[-2]->op)
                    {
                    DeleteDBQT( yyvsp[-2] );
                    yyvsp[-2] = yyvsp[-1];
                    yyvsp[-1] = yyvsp[-2]->pctNextSibling;
                    yyvsp[-2]->pctNextSibling = NULL;

                    AssertReq( yyvsp[-2]->pctFirstChild );   /* first project list element*/
                    DBCOMMANDTREE* pct = yyvsp[-2]->pctFirstChild;
                    while ( pct )
                        {   /* recheck the properties to get current definitions*/
                        DeleteDBQT( pct->pctFirstChild );
                        pct->pctFirstChild =
                            PctMkColNodeFromStr( pct->value.pwszValue, m_pIPSession, m_pIPTProperties );
                        if ( 0 == pct->pctFirstChild )
                            YYABORT( DB_E_ERRORSINCOMMAND );
                        pct = pct->pctNextSibling;
                        }
                    }
                else
                    {
                    yyvsp[-4] = yyvsp[-1];
                    yyvsp[-1] = yyvsp[-4]->pctNextSibling;
                    yyvsp[-4]->pctNextSibling = NULL;
                    AssertReq(yyvsp[-2]);                                  /* project list anchor*/
                    AssertReq(yyvsp[-2]->pctFirstChild);                   /* first project list element*/
                    DBCOMMANDTREE* pctNewPrjLst = yyvsp[-2]->pctFirstChild;
                    AssertReq(yyvsp[-4]);                                  /* project list anchor*/
                    AssertReq(yyvsp[-4]->pctFirstChild);                   /* first project list element*/
                    DBCOMMANDTREE* pctViewPrjLst = NULL;            /* initialized within loop*/
                    while (pctNewPrjLst)
                        {
                        pctViewPrjLst = yyvsp[-4]->pctFirstChild;
                        Assert( DBOP_project_list_element == pctNewPrjLst->op );
                        Assert( DBVALUEKIND_WSTR == pctNewPrjLst->wKind );
                        while ( pctViewPrjLst )
                            {
                            Assert( DBOP_project_list_element == pctViewPrjLst->op );
                            Assert( DBVALUEKIND_WSTR == pctViewPrjLst->wKind );
                            if ( 0 == _wcsicmp(pctNewPrjLst->value.pwszValue, pctViewPrjLst->value.pwszValue) )
                                break;
                            pctViewPrjLst = pctViewPrjLst->pctNextSibling;
                            if ( !pctViewPrjLst )
                                {
                                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_NOT_COLUMN_OF_VIEW );
                                m_pIPTProperties->SetErrorToken( pctNewPrjLst->value.pwszValue );
                                /* UNDONE:  Might want to include a view name on error message*/
                                YYABORT( DB_E_ERRORSINCOMMAND );
                                }
                            }
                        pctNewPrjLst = pctNewPrjLst->pctNextSibling;
                        }
                    DeleteDBQT( yyvsp[-4] );
                    yyvsp[-4] = 0;
                    }
                }
            else
                {
                /* "standard" from clause*/
                if ( DBOP_outall_name == yyvsp[-2]->op )
                    if ( DBDIALECT_MSSQLJAWS != m_pIPSession->GetSQLDialect() )
                        {
                        /* SELECT * only allowed in JAWS*/
                        m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_SELECT_STAR );
                        YYABORT( DB_E_ERRORSINCOMMAND );
                        }
                    else
                        {
                        yyvsp[-2] = PctCreateNode( DBOP_project_list_element, yyvsp[-2], NULL );
                        if ( NULL == yyvsp[-2] )
                            {
                            m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                            YYABORT( E_OUTOFMEMORY );
                            }

                        yyvsp[-2] = PctCreateNode( DBOP_project_list_anchor, yyvsp[-2], NULL );
                        if ( NULL == yyvsp[-2] )
                            {
                            m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                            YYABORT( E_OUTOFMEMORY );
                            }
                        }
                }

            if ( NULL != yyvsp[0] )
                {
                yyvsp[-4] = PctCreateNode( DBOP_select, yyvsp[-1], yyvsp[0], NULL );
                if ( NULL == yyvsp[-4] )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                    YYABORT( E_OUTOFMEMORY );
                    }
                }
            else
                yyvsp[-4] = yyvsp[-1];

            yyval = PctCreateNode( DBOP_project, yyvsp[-4], yyvsp[-2], NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 29:
{
            yyval = NULL;
            }
break;
case 30:
{
            /* ignore ALL keyword, its just noise*/
            yyval = NULL;
            }
break;
case 31:
{
            AssertReq(yyvsp[0]);

            yyvsp[0] = PctReverse(yyvsp[0]);
            yyval = PctCreateNode(DBOP_project_list_anchor, yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 32:
{
            yyval = PctCreateNode(DBOP_outall_name, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 33:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            /**/
            /* chain project list elements together*/
            /**/
            yyval = PctLink( yyvsp[0], yyvsp[-2] );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 35:
{
            AssertReq(yyvsp[0]);

            yyvsp[0]->op = DBOP_project_list_element;
            yyvsp[0]->pctFirstChild = PctMkColNodeFromStr(yyvsp[0]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL == yyvsp[0]->pctFirstChild)
                YYABORT(DB_E_ERRORSINCOMMAND);
            yyval = yyvsp[0];
            }
break;
case 36:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            DeleteDBQT(yyvsp[-2]);     /* UNDONE:  Don't use the correlation name for now*/
            yyvsp[-2] = NULL;
            yyvsp[0]->op = DBOP_project_list_element;
            yyvsp[0]->pctFirstChild = PctMkColNodeFromStr(yyvsp[0]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL == yyvsp[0]->pctFirstChild)
                YYABORT(DB_E_ERRORSINCOMMAND);
            yyval = yyvsp[0];
            }
break;
case 37:
{
            yyval = PctMkColNodeFromStr(L"CREATE", m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            yyval = PctCreateNode(DBOP_project_list_element, DBVALUEKIND_WSTR, yyval, NULL);
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->value.pwszValue = CoTaskStrDup(L"CREATE");
            }
break;
case 40:
{
            AssertReq( yyvsp[-1] );

            yyval = yyvsp[-1];

            if ( NULL != yyvsp[0] )
                {
                yyvsp[0]->pctFirstChild = yyval;
                yyval = yyvsp[0];
                }
            }
break;
case 41:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 42:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 43:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 44:
{ /* _SCOPE '(' scope_definition ')'*/
            AssertReq( yyvsp[-1] );

            /**/
            /* Set the machine and catalog to the defaults*/
            /**/
            (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval = yyvsp[-1];
            }
break;
case 45:
{ /* machine_name _DOTDOTDOT_SCOPE '(' scope_definition ')'*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-1] );

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            SCODE sc = m_pIPSession->GetIPVerifyPtr()->VerifyCatalog(
                                                        yyvsp[-4]->value.pwszValue,
                                                        m_pIPSession->GetDefaultCatalog() );
            if ( S_OK != sc )
                {
                m_pIPTProperties->SetErrorHResult( sc, MONSQL_INVALID_CATALOG );
                m_pIPTProperties->SetErrorToken( m_pIPSession->GetDefaultCatalog() );
                YYABORT( sc );
                }

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-4] );
            yyval = yyvsp[-1];
            }
break;
case 46:
{ /* machine_name _DOT catalog_name _DOTDOT_SCOPE '(' scope_definition ')'*/
            AssertReq( yyvsp[-6] );
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-1] );

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-6]->value.pwszValue );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            /**/
            /* Verify catalog on machine specified*/
            /**/

            SCODE sc = m_pIPSession->GetIPVerifyPtr()->VerifyCatalog(
                                                        yyvsp[-6]->value.pwszValue,
                                                        yyvsp[-4]->value.pwszValue );
            if ( S_OK != sc )
                {
                m_pIPTProperties->SetErrorHResult( sc, MONSQL_INVALID_CATALOG );
                m_pIPTProperties->SetErrorToken( yyvsp[-4]->value.pwszValue );
                YYABORT( sc );
                }

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-6] );
            DeleteDBQT( yyvsp[-4] );
            yyval = yyvsp[-1];
            }
break;
case 47:
{ /* catalog_name _DOTDOT_SCOPE '(' scope_definition ')'*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-1] );

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            /**/
            /* See if catalog is valid on default machine*/
            /**/

            SCODE sc = m_pIPSession->GetIPVerifyPtr()->VerifyCatalog(
                                                        m_pIPSession->GetDefaultMachine(),
                                                        yyvsp[-4]->value.pwszValue );
            if ( S_OK != sc )
                {
                m_pIPTProperties->SetErrorHResult( sc, MONSQL_INVALID_CATALOG );
                m_pIPTProperties->SetErrorToken( yyvsp[-4]->value.pwszValue );
                YYABORT( sc );
                }

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-4] );
            yyval = yyvsp[-1];
            }
break;
case 48:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 49:
{
            AssertReq( yyvsp[0] );

            /**/
            /* Defer validation of the catalog to the point where we*/
            /* know the machine name.  Return whatever was parsed here.*/
            /**/

            yyval = yyvsp[0];
            }
break;
case 50:
{ /* empty rule for scope_definition*/

            /**/
            /* Create a DBOP_content_table node with default scope settings*/
            /**/
            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 51:
{ /* scope_element_list*/

            AssertReq(yyvsp[0]);

            yyvsp[0] = PctReverse( yyvsp[0] );
            yyval = PctCreateNode( DBOP_scope_list_anchor, yyvsp[0], NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval = PctCreateNode( DBOP_content_table, DBVALUEKIND_CONTENTTABLE, yyval, NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 52:
{
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0]);

            /**/
            /* chain scope list elements together*/
            /**/
            yyval = PctLink( yyvsp[0], yyvsp[-2] );
            }
break;
case 53:
{
            AssertReq( yyvsp[0] );

            yyval = yyvsp[0];
            }
break;
case 54:
{
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[-1] );

            yyvsp[-1] = PctReverse( yyvsp[-1] );

            SetDepthAndInclusion( yyvsp[-2], yyvsp[-1] );

            DeleteDBQT( yyvsp[-2] );
            yyval = yyvsp[-1];
            }
break;
case 55:
{
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-2] );

            yyvsp[-2] = PctReverse( yyvsp[-2] );

            SetDepthAndInclusion( yyvsp[-4], yyvsp[-2] );

            DeleteDBQT( yyvsp[-4] );
            yyval = yyvsp[-2];
            }
break;
case 56:
{
            yyval = PctAllocNode( DBVALUEKIND_CONTENTSCOPE, DBOP_scope_list_element );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_DEEP;
            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_INCLUDE;
            }
break;
case 57:
{
            yyval = PctAllocNode( DBVALUEKIND_CONTENTSCOPE, DBOP_scope_list_element );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_DEEP;
            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_INCLUDE;
            }
break;
case 58:
{
            yyval = PctAllocNode( DBVALUEKIND_CONTENTSCOPE, DBOP_scope_list_element );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->value.pdbcntntscpValue->dwFlags   &= ~(SCOPE_FLAG_DEEP);
            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_INCLUDE;
            }
break;
case 59:
{
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            /**/
            /* chain path/vpath nodes together*/
            /**/
            yyval = PctLink( yyvsp[0], yyvsp[-2] );
            }
break;
case 60:
{
            AssertReq( yyvsp[0] );

            yyval = yyvsp[0];
            }
break;
case 61:
{
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTSCOPE, DBOP_scope_list_element );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->value.pdbcntntscpValue->pwszElementValue =
                CoTaskStrDup( (yyvsp[0]->value.pvarValue)->bstrVal );

            if ( NULL == yyval->value.pdbcntntscpValue->pwszElementValue )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            if ( NULL != wcschr(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, L'/'))
                yyval->value.pdbcntntscpValue->dwFlags |= SCOPE_TYPE_VPATH;
            else
                yyval->value.pdbcntntscpValue->dwFlags |= SCOPE_TYPE_WINPATH;

            /**/
            /* Path names need backlashes not forward slashes*/
            /**/
            for (WCHAR *wcsLetter = yyval->value.pdbcntntscpValue->pwszElementValue;
                 *wcsLetter != L'\0';
                 wcsLetter++)
                     if (L'/' == *wcsLetter)
                         *wcsLetter = L'\\';

            DeleteDBQT( yyvsp[0] );
            }
break;
case 62:
{
            yyval = NULL;
            }
break;
case 63:
{
            AssertReq(yyvsp[0]);
/*          $2->op = DBOP_alias;            // retag _ID node to be table alias*/
/*          $$ = $2;                        // UNDONE:  This doesn't work with Index Server*/
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = NULL;
            }
break;
case 64:
{ /* _FROM view_name*/
            AssertReq( yyvsp[0] );

            /* node telling where the view is defined*/
            Assert( DBOP_content_table == yyvsp[0]->op );

            /* name of the view*/
            AssertReq( yyvsp[0]->pctNextSibling );

            yyval = m_pIPSession->GetLocalViewList()->GetViewDefinition( m_pIPTProperties,
                                                                      yyvsp[0]->pctNextSibling->value.pwszValue,
                                                                      (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
            if ( 0 == yyval )
                yyval = m_pIPSession->GetGlobalViewList()->GetViewDefinition( m_pIPTProperties,
                                                                           yyvsp[0]->pctNextSibling->value.pwszValue,
                                                                           (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
            if ( 0 == yyval )
                {   /* If this isn't JAWS, this is an undefined view*/
                if (DBDIALECT_MSSQLJAWS != m_pIPSession->GetSQLDialect())
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_VIEW_NOT_DEFINED );
                    m_pIPTProperties->SetErrorToken( yyvsp[0]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }

                /* setting the default scope for JAWS*/
                CScopeData* pScopeData = m_pIPTProperties->GetScopeDataPtr();
                pScopeData->SetTemporaryDepth(QUERY_DEEP);
                pScopeData->MaskTemporaryDepth(QUERY_VIRTUAL_PATH);
                pScopeData->SetTemporaryScope(VAL_AND_CCH_MINUS_NULL(L"/"));
                pScopeData->SetTemporaryCatalog(yyvsp[0]->value.pwszValue, wcslen(yyvsp[0]->value.pwszValue));
                pScopeData->IncrementScopeCount();

                yyval = yyvsp[0]->pctNextSibling;
                yyvsp[0]->pctNextSibling = NULL;
                DeleteDBQT(yyvsp[0]);
                }
            else    /* actually a view name*/
                {

                /* If we didn't store scope information (global views), set up the scope now*/
                if ( 0 == yyval->pctNextSibling )
                    {
                    /* name of the view*/
                    DeleteDBQT( yyvsp[0]->pctNextSibling );
                    yyvsp[0]->pctNextSibling = 0;

                    yyval->pctNextSibling = yyvsp[0];
                    }
                else
                    {
                    AssertReq( DBOP_content_table == yyval->pctNextSibling->op );
                    DeleteDBQT( yyvsp[0] );  /* throw away the view name*/
                    }
                }
            }
break;
case 65:
{ /* _TEMPVIEW*/
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 66:
{ /* identifier*/
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 67:
{ /* catalog_name _DOTDOT _TEMPVIEW*/
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 68:
{ /* catalog_name _DOTDOT identifier*/
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 69:
{ /* machine_name _DOT catalog_name _DOTDOT _TEMPVIEW*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-4] );
            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 70:
{ /* machine_name _DOT catalog_name _DOTDOT identifier*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-4] );
            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 71:
{ /* machine_name _DOTDOTDOT identifier*/
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 72:
{ /* machine_name _DOTDOTDOT _TEMPVIEW*/
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 73:
{
            yyval = yyvsp[-1];
            }
break;
case 74:
{
            AssertReq( yyvsp[-3] );
            AssertReq( yyvsp[0] );

            yyval = PctCreateNode( DBOP_set_union, yyvsp[-3], yyvsp[0], NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 75:
{
            AssertReq( yyvsp[-3] );
            AssertReq( yyvsp[0] );

            yyval = PctCreateNode( DBOP_set_union, yyvsp[-3], yyvsp[0], NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 76:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 77:
{
            yyval = NULL;
            }
break;
case 79:
{
            AssertReq(yyvsp[0]);
            yyval = yyvsp[0];
            }
break;
case 80:
{
            AssertReq(yyvsp[-1]);

            if (wcslen(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal))
                m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal,
                                                    wcslen(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal));

            UINT cSize = 0;
            CIPROPERTYDEF* pPropTable = m_pIPSession->m_pCPropertyList->GetPropertyTable(&cSize);
            if (!pPropTable)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }

            if (FAILED(CITextToSelectTreeEx(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal,
                                        ISQLANG_V2,
                                        &yyval,
                                        cSize,
                                        pPropTable,
                                        m_pIPSession->GetLCID())))
                {
                m_pIPSession->m_pCPropertyList->DeletePropertyTable(pPropTable, cSize);
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_CITEXTTOSELECTTREE_FAILED);
                m_pIPTProperties->SetErrorToken(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[-1]);
            yyvsp[-1] = NULL;
            m_pIPSession->m_pCPropertyList->DeletePropertyTable(pPropTable, cSize);
            }
break;
case 88:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[-1]);

            if (m_pIPTProperties->GetDBType() & DBTYPE_VECTOR)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"<literal>");
                m_pIPTProperties->SetErrorToken(L"ARRAY");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            yyvsp[-2]->pctNextSibling = yyvsp[0];
            yyvsp[-1]->pctFirstChild = yyvsp[-2];
            yyval = yyvsp[-1];
            }
break;
case 89:
{
            AssertReq(yyvsp[0]);

            m_pIPTProperties->UseCiColumn(L'@');
            yyval = yyvsp[0];
            }
break;
case 90:
{
            AssertReq(yyvsp[-3]);
            AssertReq(yyvsp[-1]);

            if (DBDIALECT_MSSQLJAWS != m_pIPSession->GetSQLDialect())
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"CAST");
                m_pIPTProperties->SetErrorToken(L"column_reference");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            m_pIPTProperties->UseCiColumn(L'@');

            m_pIPTProperties->SetDBType(yyvsp[-1]->value.usValue);
            DeleteDBQT(yyvsp[-1]);
            yyval = yyvsp[-3];
            }
break;
case 91:
{
            AssertReq(yyvsp[0]);

            yyval = PctMkColNodeFromStr(yyvsp[0]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            m_pIPTProperties->SetCiColumn(yyvsp[0]->value.pwszValue);
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            }
break;
case 92:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctMkColNodeFromStr(yyvsp[0]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            m_pIPTProperties->SetCiColumn(yyvsp[0]->value.pwszValue);
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            DeleteDBQT(yyvsp[-2]);     /* UNDONE:  Don't use the correlation name for now*/
            yyvsp[-2] = NULL;
            }
break;
case 93:
{
            m_pIPTProperties->SetCiColumn(L"CREATE");
            yyval = PctMkColNodeFromStr(L"CREATE", m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"CREATE "));
            }
break;
case 94:
{
            yyval = PctCreateRelationalNode(DBOP_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"="));
            }
break;
case 95:
{
            yyval = PctCreateRelationalNode(DBOP_not_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"!="));
            }
break;
case 96:
{
            yyval = PctCreateRelationalNode(DBOP_less, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"<"));
            }
break;
case 97:
{
            yyval = PctCreateRelationalNode(DBOP_greater, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L">"));
            }
break;
case 98:
{
            yyval = PctCreateRelationalNode(DBOP_less_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"<="));
            }
break;
case 99:
{
            yyval = PctCreateRelationalNode(DBOP_greater_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L">="));
            }
break;
case 100:
{
            AssertReq(!yyvsp[-5]); /* should have been NULLed out in opt_contents_column_reference*/
            AssertReq(yyvsp[-3]);

            yyval = yyvsp[-3];
            DeleteDBQT(m_pIPTProperties->GetContainsColumn());
            m_pIPTProperties->SetContainsColumn(NULL);
            }
break;
case 101:
{ /* opt_contents_column_reference empty rule*/
            yyval = PctMkColNodeFromStr(L"CONTENTS", m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            m_pIPTProperties->SetCiColumn(L"CONTENTS");
            m_pIPTProperties->SetContainsColumn(yyval);
            yyval = NULL;
            }
break;
case 102:
{ /* column_reference ','*/
            m_pIPTProperties->SetContainsColumn(yyvsp[-1]);
            yyval = NULL;
            }
break;
case 103:
{
            /* This forces a left parentheses before the content search condition*/
            /* The matching right paren will be added below.*/
            m_pIPTProperties->CiNeedLeftParen();
            yyval = NULL;
            }
break;
case 104:
{
            AssertReq(yyvsp[0]);

            yyval = yyvsp[0];
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L")"));
            }
break;
case 106:
{
            if (DBOP_not == yyvsp[0]->op)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OR_NOT);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            yyval = PctCreateBooleanNode(DBOP_or, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 108:
{
            yyval = PctCreateBooleanNode(DBOP_and, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 110:
{
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 112:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"("));
            }
break;
case 113:
{
            AssertReq(yyvsp[-1]);

            yyval = yyvsp[-1];
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L")"));
            }
break;
case 119:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" | "));
            }
break;
case 120:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" | "));
            }
break;
case 121:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" & "));
            }
break;
case 122:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" & "));
            }
break;
case 123:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ! "));
            }
break;
case 124:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ! "));
            }
break;
case 125:
{
            AssertReq(yyvsp[0]);

            HRESULT hr = HrQeTreeCopy(&yyval, m_pIPTProperties->GetContainsColumn());
            if (FAILED(hr))
                {
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
                YYABORT(hr);
                }
            m_pIPTProperties->UseCiColumn(L'@');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal,
                                                wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            yyval = PctCreateContentNode(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, GENERATE_METHOD_EXACT,
                                        DEFAULTWEIGHT, m_pIPSession->GetLCID(), yyval);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            }
break;
case 126:
{
            AssertReq(yyvsp[0]);
            Assert(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[wcslen(
                ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal)-1] == L'*');

            m_pIPTProperties->UseCiColumn(L'@');
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal,
                                                wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal));
            ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[wcslen(
                ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal)-1] = L'\0';
            HRESULT hr = HrQeTreeCopy(&yyval, m_pIPTProperties->GetContainsColumn());
            if (FAILED(hr))
                {
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
                YYABORT(hr);
                }
            yyval = PctCreateContentNode(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, GENERATE_METHOD_PREFIX,
                                        DEFAULTWEIGHT, m_pIPSession->GetLCID(), yyval);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            }
break;
case 127:
{
            AssertReq(yyvsp[-1]);
            AssertReq(yyvsp[0]);

            yyvsp[0] = PctReverse(yyvsp[0]);
            yyval = PctCreateNode(DBOP_content_proximity, DBVALUEKIND_CONTENTPROXIMITY, yyvsp[-1], yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdbcntntproxValue->dwProximityUnit = PROXIMITY_UNIT_WORD;
            yyval->value.pdbcntntproxValue->ulProximityDistance = 50;
            yyval->value.pdbcntntproxValue->lWeight = DEFAULTWEIGHT;
            }
break;
case 128:
{
            AssertReq(yyvsp[-1]);
            AssertReq(yyvsp[0]);

            yyval = PctLink(yyvsp[0], yyvsp[-1]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 130:
{
            AssertReq(yyvsp[0]);

            yyval = yyvsp[0];        /* UNDONE:  What is proximity_specification good for?*/
            }
break;
case 133:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ~ "));
            }
break;
case 134:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ~ "));
            }
break;
case 135:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ~ "));
            }
break;
case 136:
{
            AssertReq(yyvsp[-1]);

            /* UNDONE:  Should make use of $3 somewhere in here*/
            yyval = yyvsp[-1];
            }
break;
case 137:
{
            if (0 == _wcsicmp(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, L"INFLECTIONAL"))
                {
                DeleteDBQT(yyvsp[0]);
                yyvsp[0] = NULL;
                yyval = NULL;
                }
/*  *************************************NOT IMPLEMENTED BY INDEX SERVER **************************************
            else if (0 == _wcsicmp(((PROPVARIANT*)$1->value.pvValue)->bstrVal, L"DERIVATIONAL"))
                {
                m_pIPTProperties->SetErrorHResult(E_NOTIMPL, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"DERIVATIONAL");
                YYABORT(E_NOTIMPL);
                }
            else if (0 == _wcsicmp(((PROPVARIANT*)$1->value.pvValue)->bstrVal, L"SOUNDEX"))
                {
                m_pIPTProperties->SetErrorHResult(E_NOTIMPL, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"DERIVATIONAL");
                YYABORT(E_NOTIMPL);
                }
            else if (0 == _wcsicmp(((PROPVARIANT*)$1->value.pvValue)->bstrVal, L"THESAURUS"))
                {
                m_pIPTProperties->SetErrorHResult(E_NOTIMPL, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"THESAURUS");
                YYABORT(E_NOTIMPL);
                }
    *************************************NOT IMPLEMENTED BY INDEX SERVER ************************************** */
            else
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal);
                m_pIPTProperties->SetErrorToken(L"INFLECTIONAL");
                YYABORT(E_NOTIMPL);
                }
            }
break;
case 138:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);
            Assert(DBOP_content == yyvsp[0]->op);

            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"**"));
            yyvsp[0]->value.pdbcntntValue->dwGenerateMethod = GENERATE_METHOD_INFLECT;
            yyval = PctCreateBooleanNode(DBOP_or, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 139:
{
            AssertReq(yyvsp[0]);
            Assert(DBOP_content == yyvsp[0]->op);

            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"**"));
            yyvsp[0]->value.pdbcntntValue->dwGenerateMethod = GENERATE_METHOD_INFLECT;
            yyval = yyvsp[0];
            }
break;
case 140:
{
            AssertReq(yyvsp[-1]);
            yyvsp[-1] = PctReverse(yyvsp[-1]);
            yyval = PctCreateNode(DBOP_content_vector_or, DBVALUEKIND_CONTENTVECTOR, yyvsp[-1], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdbcntntvcValue->dwRankingMethod = m_pIPSession->GetRankingMethod();
            yyval->value.pdbcntntvcValue->lWeight = DEFAULTWEIGHT;
            }
break;
case 141:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);
            Assert((DBOP_content == yyvsp[0]->op) || (DBOP_or == yyvsp[0]->op) || (DBOP_content_proximity == yyvsp[0]->op));

            yyval = PctLink(yyvsp[0], yyvsp[-2]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 142:
{
            AssertReq(yyvsp[0]);
            Assert((DBOP_content == yyvsp[0]->op) || (DBOP_or == yyvsp[0]->op) || (DBOP_content_proximity == yyvsp[0]->op));

            yyval = yyvsp[0];
            }
break;
case 143:
{
            AssertReq(yyvsp[-4]);
            AssertReq(yyvsp[-1]);
            if ((yyvsp[-1]->value.pvarValue->dblVal < 0.0) ||
                (yyvsp[-1]->value.pvarValue->dblVal > 1.0))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_WEIGHT_OUT_OF_RANGE);
                WCHAR wchErr[30];
                swprintf(wchErr, L"%f", yyvsp[-1]->value.pvarValue->dblVal);
                m_pIPTProperties->SetErrorToken(wchErr);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            yyval = yyvsp[-4];
            SetLWeight(yyval, (LONG) (yyvsp[-1]->value.pvarValue->dblVal * DEFAULTWEIGHT));
            WCHAR wchWeight[10];
            if (swprintf(wchWeight, L"%d", (LONG) (yyvsp[-1]->value.pvarValue->dblVal * DEFAULTWEIGHT)))
                {
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"["));
                m_pIPTProperties->AppendCiRestriction(wchWeight, wcslen(wchWeight));
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"] "));
                }
            DeleteDBQT(yyvsp[-1]);
            yyvsp[-1] = NULL;
            }
break;
case 144:
{
        m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" "));
        yyval = yyvsp[0];
        }
break;
case 149:
{
            HRESULT hr = CoerceScalar(VT_R8, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);

            yyval = yyvsp[0];
            }
break;
case 150:
{
            yyval = NULL;
            }
break;
case 151:
{
            HRESULT hr = CoerceScalar(VT_I4, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);

            if (0 != yyvsp[0]->value.pvarValue->lVal)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                WCHAR wchErr[30];
                swprintf(wchErr, L"%d", yyvsp[0]->value.pvarValue->lVal);
                m_pIPTProperties->SetErrorToken(wchErr);
                m_pIPTProperties->SetErrorToken(L"0");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = NULL;
            }
break;
case 152:
{
            AssertReq(!yyvsp[-3]);
            AssertReq(yyvsp[-2]);

            HRESULT hr = HrQeTreeCopy(&yyval, m_pIPTProperties->GetContainsColumn());
            if (FAILED(hr))
                {
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
                YYABORT(hr);
                }
            m_pIPTProperties->UseCiColumn(L'$');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->bstrVal,
                                            wcslen(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->bstrVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));

            yyval = PctCreateNode(DBOP_content_freetext, DBVALUEKIND_CONTENT, yyval, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdbcntntValue->pwszPhrase = CoTaskStrDup(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->bstrVal);
            yyval->value.pdbcntntValue->dwGenerateMethod = GENERATE_METHOD_EXACT;
            yyval->value.pdbcntntValue->lWeight = DEFAULTWEIGHT;
            yyval->value.pdbcntntValue->lcid = m_pIPSession->GetLCID();

            DeleteDBQT(m_pIPTProperties->GetContainsColumn());
            m_pIPTProperties->SetContainsColumn(NULL);
            DeleteDBQT(yyvsp[-2]);
            yyvsp[-2] = NULL;
            }
break;
case 153:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            m_pIPTProperties->UseCiColumn(L'#');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal,
                                            wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            yyval = PctCreateNode(DBOP_like, DBVALUEKIND_LIKE, yyvsp[-2], yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdblikeValue->guidDialect = DBGUID_LIKE_OFS;
            yyval->value.pdblikeValue->lWeight = DEFAULTWEIGHT;
            }
break;
case 154:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            m_pIPTProperties->UseCiColumn(L'#');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal,
                                            wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            yyvsp[-1] = PctCreateNode(DBOP_like, DBVALUEKIND_LIKE, yyvsp[-2], yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyvsp[-1]->value.pdblikeValue->guidDialect = DBGUID_LIKE_OFS;
            yyvsp[-1]->value.pdblikeValue->lWeight = DEFAULTWEIGHT;
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[-1]);
            }
break;
case 155:
{
            UINT cLen = wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal);
            BSTR bstrCopy = SysAllocStringLen(NULL, 4 * cLen);
            if ( 0 == bstrCopy )
            {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
            }

            UINT j = 0;
            for (UINT i = 0; i <= cLen; i++)
                {
                switch ( ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i] )
                    {
                    case L'%':
                        bstrCopy[j++] = L'*';
                        break;

                    case L'_':
                        bstrCopy[j++] = L'?';
                        break;

                    case L'|':
                        bstrCopy[j++] = L'|';
                        bstrCopy[j++] = L'|';
                        break;

                    case L'*':
                        bstrCopy[j++] = L'|';
                        bstrCopy[j++] = L'[';
                        bstrCopy[j++] = L'*';
                        bstrCopy[j++] = L']';
                        break;

                    case L'?':
                        bstrCopy[j++] = L'|';
                        bstrCopy[j++] = L'[';
                        bstrCopy[j++] = L'?';
                        bstrCopy[j++] = L']';
                        break;

                    case L'[':
                        /* UNDONE:  Make sure we're not going out of range with these tests*/
                        if ((L'%' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+1]) &&
                            (L']' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+2]))
                            {
                            bstrCopy[j++] = L'%';
                            i = i + 2;
                            }
                        else if ((L'_' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+1]) &&
                                (L']' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+2]))
                            {
                            bstrCopy[j++] = L'_';
                            i = i + 2;
                            }
                        else if ((L'[' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+1]) &&
                                (L']' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+2]))
                            {
                            bstrCopy[j++] = L'[';
                            i = i + 2;
                            }
                        else if ((L'^' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+1]) &&
                                (L']' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+2]) &&
                                (wcschr((WCHAR*)&(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+3]), L']')))
                            {
                            bstrCopy[j++] = L'|';
                            bstrCopy[j++] = L'[';
                            bstrCopy[j++] = L'^';
                            bstrCopy[j++] = L']';
                            i = i + 2;
                            }
                        else
                            {
                            bstrCopy[j++] = L'|';
                            bstrCopy[j++] = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i++];

                            while ((((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i] != L']') && (i < cLen))
                                bstrCopy[j++] = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i++];

                            if (i < cLen)
                                bstrCopy[j++] = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i];
                            }
                        break;

                    default:
                        bstrCopy[j++] = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i];
                        break;
                    }
                }

            SysFreeString(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal);
            ((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal = CoTaskStrDup(bstrCopy);
            ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt = VT_LPWSTR;
            SysFreeString(bstrCopy);
            yyval = yyvsp[0];
            }
break;
case 156:
{
            AssertReq(yyvsp[-4]);
            AssertReq(yyvsp[-2]);
            m_pIPTProperties->UseCiColumn(L'#');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->pwszVal,
                                            wcslen(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->pwszVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            yyval = PctCreateNode(DBOP_like, DBVALUEKIND_LIKE, yyvsp[-4], yyvsp[-2], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdblikeValue->guidDialect = DBGUID_LIKE_OFS;
            yyval->value.pdblikeValue->lWeight = DEFAULTWEIGHT;
            }
break;
case 157:
{
            AssertReq(yyvsp[0]);
            HRESULT hr = CoerceScalar(VT_LPWSTR, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);

            LPWSTR pwszMatchString = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal;
            while (*pwszMatchString)
                {
                /* perform some soundness checking on string since Index Server won't be happy*/
                /* with an ill formed string*/
                if (L'|' == *pwszMatchString++)
                    {
                    hr = DB_E_ERRORSINCOMMAND;
                    switch ( *pwszMatchString++ )
                        {
                        case L'(':
                            while (*pwszMatchString)
                                if (L'|' == *pwszMatchString++)
                                    if (*pwszMatchString)
                                        if (L')' == *pwszMatchString++)
                                            {
                                            hr = S_OK;
                                            break;
                                            }
                            break;

                        case L'{':
                            while (*pwszMatchString)
                                if (L'|' == *pwszMatchString++)
                                    if (*pwszMatchString)
                                        if (L'}' == *pwszMatchString++)
                                            {
                                            hr = S_OK;
                                            break;
                                            }
                            break;

                        default:
                            hr = S_OK;
                        }
                    }
                }

            if (S_OK != hr)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_MATCH_STRING);
                YYABORT(hr);
                }

            yyval = yyvsp[0];
            }
break;
case 158:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[-1]);

            DBCOMMANDTREE * pct = 0;
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                {
                pct = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
                if (NULL == pct)
                    {
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                    YYABORT( E_OUTOFMEMORY );
                    }

                DBCOMMANDTREE* pctList=yyvsp[0];
                UINT i = 0;

                pct->value.pvarValue->vt = m_pIPTProperties->GetDBType();
                ((PROPVARIANT*)pct->value.pvarValue)->caub.cElems = GetNumberOfSiblings(yyvsp[0]);

                if (0 == ((PROPVARIANT*)pct->value.pvarValue)->caub.cElems)
                    {
                    ((PROPVARIANT*)pct->value.pvarValue)->caub.pElems = (UCHAR*) NULL;
                    }
                else
                    {
                    switch ( m_pIPTProperties->GetDBType() )
                        {
                        case (VT_UI1|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->caub.pElems =
                                (UCHAR*) CoTaskMemAlloc(sizeof(UCHAR)*((PROPVARIANT*)pct->value.pvarValue)->caub.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->caub.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->caub.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->caub.pElems[i] = pctList->value.pvarValue->bVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_I1|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cac.pElems =
                                (CHAR*) CoTaskMemAlloc(sizeof(CHAR)*((PROPVARIANT*)pct->value.pvarValue)->cac.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cac.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cac.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cac.pElems[i] = pctList->value.pvarValue->cVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_UI2|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->caui.pElems =
                                (USHORT*) CoTaskMemAlloc(sizeof(USHORT)*((PROPVARIANT*)pct->value.pvarValue)->caui.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->caui.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->caui.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->caui.pElems[i] = pctList->value.pvarValue->uiVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_I2|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cai.pElems =
                                (SHORT*) CoTaskMemAlloc(sizeof(SHORT)*((PROPVARIANT*)pct->value.pvarValue)->cai.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cai.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cai.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cai.pElems[i] = pctList->value.pvarValue->iVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_UI4|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->caul.pElems =
                                (ULONG*) CoTaskMemAlloc(sizeof(ULONG)*((PROPVARIANT*)pct->value.pvarValue)->caul.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->caul.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->caul.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->caul.pElems[i] = pctList->value.pvarValue->ulVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_I4|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cal.pElems =
                                (LONG*) CoTaskMemAlloc(sizeof(LONG)*((PROPVARIANT*)pct->value.pvarValue)->cal.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cal.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cal.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cal.pElems[i] = pctList->value.pvarValue->lVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_UI8|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cauh.pElems =
                                (ULARGE_INTEGER*) CoTaskMemAlloc(sizeof(ULARGE_INTEGER)*((PROPVARIANT*)pct->value.pvarValue)->cauh.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cauh.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cauh.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cauh.pElems[i] = ((PROPVARIANT*)pctList->value.pvarValue)->uhVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_I8|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cah.pElems =
                                (LARGE_INTEGER*) CoTaskMemAlloc(sizeof(LARGE_INTEGER)*((PROPVARIANT*)pct->value.pvarValue)->cah.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cah.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cah.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cah.pElems[i] = ((PROPVARIANT*)pctList->value.pvarValue)->hVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_R4|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->caflt.pElems =
                                (float*) CoTaskMemAlloc(sizeof(float)*((PROPVARIANT*)pct->value.pvarValue)->caflt.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->caflt.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->caflt.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->caflt.pElems[i] = pctList->value.pvarValue->fltVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_R8|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems =
                                (double*) CoTaskMemAlloc(sizeof(double)*((PROPVARIANT*)pct->value.pvarValue)->cadbl.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cadbl.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems[i] = pctList->value.pvarValue->dblVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_BOOL|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cabool.pElems =
                                (VARIANT_BOOL*) CoTaskMemAlloc(sizeof(VARIANT_BOOL)*((PROPVARIANT*)pct->value.pvarValue)->cabool.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cabool.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cabool.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cabool.pElems[i] = pctList->value.pvarValue->boolVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_CY|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cacy.pElems =
                                (CY*) CoTaskMemAlloc(sizeof(CY)*((PROPVARIANT*)pct->value.pvarValue)->cacy.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cacy.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cacy.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cacy.pElems[i] =
                                    ((PROPVARIANT*)pctList->value.pvarValue)->cyVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_DATE|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems =
                                (double*) CoTaskMemAlloc(sizeof(double)*((PROPVARIANT*)pct->value.pvarValue)->cadbl.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cadbl.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems[i] =
                                    ((PROPVARIANT*)pctList->value.pvarValue)->date;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_FILETIME|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cafiletime.pElems =
                                (FILETIME*) CoTaskMemAlloc(sizeof(FILETIME)*((PROPVARIANT*)pct->value.pvarValue)->cafiletime.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cafiletime.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cafiletime.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cafiletime.pElems[i] =
                                    ((PROPVARIANT*)pctList->value.pvarValue)->filetime;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_BSTR|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cabstr.pElems =
                                (BSTR*) CoTaskMemAlloc(sizeof(BSTR)*((PROPVARIANT*)pct->value.pvarValue)->cabstr.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cabstr.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cabstr.cElems; i++)
                                {
                                    ((PROPVARIANT*)pct->value.pvarValue)->cabstr.pElems[i] =
                                        SysAllocString(pctList->value.pvarValue->bstrVal);
                                    if ( 0 == ((PROPVARIANT*)pct->value.pvarValue)->cabstr.pElems[i] )
                                    {
                                        m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                                        YYABORT( E_OUTOFMEMORY );
                                    }
                                    pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (DBTYPE_STR|VT_VECTOR):
                            pct->value.pvarValue->vt = VT_LPSTR | VT_VECTOR;
                            ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems =
                                (LPSTR*) CoTaskMemAlloc(sizeof(LPSTR)*((PROPVARIANT*)pct->value.pvarValue)->calpstr.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->calpstr.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems[i] =
                                    (LPSTR)CoTaskMemAlloc((lstrlenA(((PROPVARIANT*)pctList->value.pvarValue)->pszVal)+2)*sizeof(CHAR));
                                if ( 0 == ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems[i] )
                                    {
                                    /* free allocations made so far*/
                                    for ( int j = i-1; j >= 0; j++ )
                                        CoTaskMemFree( ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems[i] );
                                    CoTaskMemFree( ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems );

                                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                                    YYABORT( E_OUTOFMEMORY );
                                    }

                                strcpy(((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems[i],
                                    ((PROPVARIANT*)pctList->value.pvarValue)->pszVal);
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (DBTYPE_WSTR|VT_VECTOR):
                            pct->value.pvarValue->vt = VT_LPWSTR | VT_VECTOR;
                            ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems =
                                (LPWSTR*) CoTaskMemAlloc(sizeof(LPWSTR)*((PROPVARIANT*)pct->value.pvarValue)->calpwstr.cElems);

                            if ( 0 == ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems )
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for ( i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->calpwstr.cElems; i++ )
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems[i] =
                                    CoTaskStrDup(((PROPVARIANT*)pctList->value.pvarValue)->pwszVal);
                                if ( 0 == ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems[i] )
                                    {
                                    /* free allocations made so far*/
                                    for ( int j = i-1; j >= 0; j++ )
                                        CoTaskMemFree( ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems[i] );
                                    CoTaskMemFree( ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems );

                                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                                    YYABORT( E_OUTOFMEMORY );
                                    }


                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_CLSID|VT_VECTOR):
                            pct->value.pvarValue->vt = VT_CLSID | VT_VECTOR;
                            ((PROPVARIANT*)pct->value.pvarValue)->cauuid.pElems =
                                (GUID*) CoTaskMemAlloc(sizeof(GUID)*((PROPVARIANT*)pct->value.pvarValue)->cauuid.cElems);

                            if ( NULL == ((PROPVARIANT*)pct->value.pvarValue)->cauuid.pElems )
                                {
                                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for ( i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cauuid.cElems; i++ )
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cauuid.pElems[i] =
                                    *((PROPVARIANT*)pctList->value.pvarValue)->puuid;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        default:
                            assert(!"PctAllocNode: illegal wKind");
                            m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                            m_pIPTProperties->SetErrorToken(L"ARRAY");
                            DeleteDBQT( pct );
                            YYABORT(DB_E_ERRORSINCOMMAND);
                        }
                    }
                }
            else
                {
                switch ( m_pIPTProperties->GetDBType() )
                    {
                    case VT_UI1:
                    case VT_UI2:
                    case VT_UI4:
                    case VT_UI8:
                        /* Allows:*/
                        /*      DBOP_allbits*/
                        /*      DBOP_anybits*/
                        /* when the LHS is a non vector.*/
                        /**/
                        /* There isn't a way to say the following through SQL currently:*/
                        /*      DBOP_anybits_all*/
                        /*      DBOP_anybits_any*/
                        /*      DBOP_allbits_all*/
                        /*      DBOP_allbits_any*/
                        pct = yyvsp[0];
                        yyvsp[0] = 0;
                        break;

                    default:
                        assert(!"PctAllocNode: illegal wKind");
                        m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                        m_pIPTProperties->SetErrorToken(L"ARRAY");
                        YYABORT(DB_E_ERRORSINCOMMAND);
                    }
                }

            if (yyvsp[0])
                {
                DeleteDBQT(yyvsp[0]);
                yyvsp[0] = NULL;
                }
            yyvsp[-2]->pctNextSibling = pct;
            yyvsp[-1]->pctFirstChild = yyvsp[-2];
            yyval = yyvsp[-1];
            }
break;
case 162:
{
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                yyval = PctCreateRelationalNode( DBOP_equal, DEFAULTWEIGHT );
            else
                yyval = PctCreateRelationalNode( DBOP_equal, DEFAULTWEIGHT );

            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction( VAL_AND_CCH_MINUS_NULL(L" = ") );
            }
break;
case 163:
{
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                yyval = PctCreateRelationalNode( DBOP_equal_all, DEFAULTWEIGHT );
            else
                yyval = PctCreateRelationalNode( DBOP_allbits, DEFAULTWEIGHT );

            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                m_pIPTProperties->AppendCiRestriction( VAL_AND_CCH_MINUS_NULL(L" = ^a ") );
            else
                m_pIPTProperties->AppendCiRestriction( VAL_AND_CCH_MINUS_NULL(L" ^a ") );
            }
break;
case 164:
{
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                yyval = PctCreateRelationalNode( DBOP_equal_any, DEFAULTWEIGHT );
            else
                yyval = PctCreateRelationalNode( DBOP_anybits, DEFAULTWEIGHT );

            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" = ^s "));
            else
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ^s "));
            }
break;
case 165:
{
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                yyval = PctCreateRelationalNode( DBOP_not_equal, DEFAULTWEIGHT );

            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" != ") );
            }
break;
case 166:
{
            yyval = PctCreateRelationalNode(DBOP_not_equal_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" != ^a "));
            }
break;
case 167:
{
            yyval = PctCreateRelationalNode(DBOP_not_equal_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" != ^s "));
            }
break;
case 168:
{
            yyval = PctCreateRelationalNode(DBOP_less, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" < "));
            }
break;
case 169:
{
            yyval = PctCreateRelationalNode(DBOP_less_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" < ^a "));
            }
break;
case 170:
{
            yyval = PctCreateRelationalNode(DBOP_less_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" < ^s "));
            }
break;
case 171:
{
            yyval = PctCreateRelationalNode(DBOP_greater, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" > "));
            }
break;
case 172:
{
            yyval = PctCreateRelationalNode(DBOP_greater_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" > ^a "));
            }
break;
case 173:
{
            yyval = PctCreateRelationalNode(DBOP_greater_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" > ^s "));
            }
break;
case 174:
{
            yyval = PctCreateRelationalNode(DBOP_less_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" <= "));
            }
break;
case 175:
{
            yyval = PctCreateRelationalNode(DBOP_less_equal_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" <= ^a "));
            }
break;
case 176:
{
            yyval = PctCreateRelationalNode(DBOP_less_equal_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" <= ^s "));
            }
break;
case 177:
{
            yyval = PctCreateRelationalNode(DBOP_greater_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" >= "));
            }
break;
case 178:
{
            yyval = PctCreateRelationalNode(DBOP_greater_equal_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" >= ^a "));
            }
break;
case 179:
{
            yyval = PctCreateRelationalNode(DBOP_greater_equal_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" >= ^s "));
            }
break;
case 180:
{
            yyval = PctReverse(yyvsp[-1]);
            }
break;
case 181:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"{"));
            }
break;
case 182:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"}"));
            }
break;
case 183:
{
            yyval = NULL;
            }
break;
case 185:
{
            AssertReq(yyvsp[-2]);

            if (NULL == yyvsp[0])
                YYABORT(DB_E_CANTCONVERTVALUE);
            yyval = PctLink(yyvsp[0], yyvsp[-2]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 186:
{
            if (NULL == yyvsp[0])
                YYABORT(DB_E_CANTCONVERTVALUE);
            yyval = yyvsp[0];
            }
break;
case 187:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L","));
            }
break;
case 188:
{
            AssertReq(yyvsp[-2]);

            yyvsp[-1] = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }

            ((PROPVARIANT*)yyvsp[-1]->value.pvValue)->vt = VT_EMPTY;
            yyval = PctCreateRelationalNode(DBOP_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->pctFirstChild = yyvsp[-2];
            yyvsp[-2]->pctNextSibling = yyvsp[-1];
            }
break;
case 189:
{
            AssertReq(yyvsp[-2]);

            yyvsp[-1] = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }

            ((PROPVARIANT*)yyvsp[-1]->value.pvValue)->vt = VT_EMPTY;
/*          $$ = PctCreateRelationalNode(DBOP_not_equal, DEFAULTWEIGHT);*/
            yyval = PctCreateRelationalNode(DBOP_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->pctFirstChild = yyvsp[-2];
            yyvsp[-2]->pctNextSibling = yyvsp[-1];
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyval);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 191:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctCreateBooleanNode(DBOP_or, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 193:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctCreateBooleanNode(DBOP_and, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 195:
{
            AssertReq(yyvsp[0]);

            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 196:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" OR "));
            }
break;
case 197:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" AND "));
            }
break;
case 198:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" NOT "));
            }
break;
case 200:
{
            AssertReq(yyvsp[-2]);
            yyval = PctCreateNode(DBOP_is_TRUE, yyvsp[-2], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 201:
{
            AssertReq(yyvsp[-2]);
            yyval = PctCreateNode(DBOP_is_FALSE, yyvsp[-2], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 202:
{
            AssertReq(yyvsp[-2]);
            yyval = PctCreateNode(DBOP_is_INVALID, yyvsp[-2], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 203:
{
            AssertReq(yyvsp[-2]);
            yyvsp[-1] = PctCreateNode(DBOP_is_TRUE, yyvsp[-2], NULL);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[-1]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 204:
{
            AssertReq(yyvsp[-2]);
            yyvsp[-1] = PctCreateNode(DBOP_is_FALSE, yyvsp[-2], NULL);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[-1]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 205:
{
            AssertReq(yyvsp[-2]);
            yyvsp[-1] = PctCreateNode(DBOP_is_INVALID, yyvsp[-2], NULL);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[-1]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 206:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"("));
            yyval = NULL;
            }
break;
case 207:
{
            AssertReq(yyvsp[0]);

            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L")"));
            yyval = yyvsp[0];
            }
break;
case 208:
{
            AssertReq(yyvsp[-1]);

            yyval = yyvsp[-1];
            }
break;
case 209:
{
            AssertReq(yyvsp[0]);

            yyvsp[0] = PctReverse(yyvsp[0]);
            yyval = PctCreateNode(DBOP_sort_list_anchor, yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 210:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctLink(yyvsp[0], yyvsp[-2]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 212:
{
            AssertReq(yyvsp[-1]);
            AssertReq(yyvsp[0]);

            yyvsp[0]->value.pdbsrtinfValue->lcid = m_pIPSession->GetLCID();
            yyvsp[0]->pctFirstChild = yyvsp[-1];
            yyval = yyvsp[0];
            }
break;
case 213:
{
            yyval = PctCreateNode(DBOP_sort_list_element, DBVALUEKIND_SORTINFO, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->value.pdbsrtinfValue->fDesc = m_pIPTProperties->GetSortDesc();
            }
break;
case 214:
{
            yyval = PctCreateNode(DBOP_sort_list_element, DBVALUEKIND_SORTINFO, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->value.pdbsrtinfValue->fDesc = QUERY_SORTASCEND;
            m_pIPTProperties->SetSortDesc(QUERY_SORTASCEND);
            }
break;
case 215:
{
            yyval = PctCreateNode(DBOP_sort_list_element, DBVALUEKIND_SORTINFO, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY );
                }
            yyval->value.pdbsrtinfValue->fDesc = QUERY_SORTDESCEND;
            m_pIPTProperties->SetSortDesc(QUERY_SORTDESCEND);
            }
break;
case 216:
{
/*@SetCiColumn does the clear   m_pCMonarchSessionData->ClearCiColumn();*/
            }
break;
case 218:
{
            yyval = NULL;
            }
break;
case 219:
{
            yyval = yyvsp[0];
            }
break;
case 223:
{
            HRESULT hr = S_OK;
            yyvsp[-7] = PctBuiltInProperty(yyvsp[-1]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL != yyvsp[-7])
                {
                /* This is a built-in friendly name.  Definition better match built in definition.*/
                if (*yyvsp[-5]->value.pGuid != yyvsp[-7]->value.pdbidValue->uGuid.guid     ||
                    m_pIPTProperties->GetDBType() != yyvsp[0]->value.usValue ||
                    DBKIND_GUID_PROPID != yyvsp[-7]->value.pdbidValue->eKind        ||
                    yyvsp[-3]->value.pvarValue->lVal != (long)yyvsp[-7]->value.pdbidValue->uName.ulPropid)
                    {
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_BUILTIN_PROPERTY);
                    m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                    YYABORT(DB_E_ERRORSINCOMMAND);
                    }
                }
            else
                m_pIPSession->m_pCPropertyList->SetPropertyEntry(yyvsp[-1]->value.pwszValue,
                                                yyvsp[0]->value.ulValue,
                                                *yyvsp[-5]->value.pGuid,
                                                DBKIND_GUID_PROPID,
                                                (LPWSTR) LongToPtr( yyvsp[-3]->value.pvarValue->lVal ),
                                                m_pIPSession->GetGlobalDefinition());
            if (FAILED(hr))
                {
                /* Unable to store the property name and/or values in the symbol table*/
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            if (yyvsp[-7])
                DeleteDBQT(yyvsp[-7]);
            DeleteDBQT(yyvsp[-5]);
            DeleteDBQT(yyvsp[-3]);
            DeleteDBQT(yyvsp[-1]);
            DeleteDBQT(yyvsp[0]);
            yyval = NULL;
            }
break;
case 224:
{
            HRESULT hr = S_OK;
            yyvsp[-7] = PctBuiltInProperty(yyvsp[-1]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL != yyvsp[-7])
                {
                /* This is a built-in friendly name.  Definition better match built in definition.*/
                if (*yyvsp[-5]->value.pGuid != yyvsp[-7]->value.pdbidValue->uGuid.guid     ||
                    m_pIPTProperties->GetDBType() != yyvsp[0]->value.ulValue ||
                    DBKIND_GUID_NAME != yyvsp[-7]->value.pdbidValue->eKind          ||
                    0 != _wcsicmp(((PROPVARIANT*)yyvsp[-3]->value.pvValue)->bstrVal, yyvsp[-7]->value.pdbidValue->uName.pwszName))
                    {
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_BUILTIN_PROPERTY);
/*                  m_pIPTProperties->SetErrorToken($1->value.pwszValue);*/
                    YYABORT(DB_E_ERRORSINCOMMAND);
                    }
                }
            else
                hr = m_pIPSession->m_pCPropertyList->SetPropertyEntry(yyvsp[-1]->value.pwszValue,
                                                        yyvsp[0]->value.ulValue,
                                                        *yyvsp[-5]->value.pGuid,
                                                        DBKIND_GUID_NAME,
                                                        ((PROPVARIANT*)yyvsp[-3]->value.pvValue)->bstrVal,
                                                        m_pIPSession->GetGlobalDefinition());
            if (FAILED(hr))
                {
                /* Unable to store the property name and/or values in the symbol table*/
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            if (yyvsp[-7])
                DeleteDBQT(yyvsp[-7]);
            DeleteDBQT(yyvsp[-5]);
            DeleteDBQT(yyvsp[-3]);
            DeleteDBQT(yyvsp[-1]);
            DeleteDBQT(yyvsp[0]);
            }
break;
case 226:
{
            yyval = PctCreateNode(DBOP_scalar_constant, DBVALUEKIND_UI2, NULL);
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->value.usValue = DBTYPE_WSTR|DBTYPE_BYREF;
            }
break;
case 227:
{
            yyval = yyvsp[0];
            }
break;
case 228:
{
            AssertReq(yyvsp[0]);

            DBTYPE dbType = GetDBTypeFromStr(yyvsp[0]->value.pwszValue);
            if ((DBTYPE_EMPTY == dbType) ||
                (DBTYPE_BYREF == dbType) ||
                (DBTYPE_VECTOR == dbType))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"<base Indexing Service dbtype1");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = PctCreateNode(DBOP_scalar_constant, DBVALUEKIND_UI2, NULL);
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            if (DBTYPE_WSTR == dbType || DBTYPE_STR == dbType)
                dbType = dbType | DBTYPE_BYREF;
            yyval->value.usValue = dbType;
            }
break;
case 229:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            DBTYPE dbType1 = GetDBTypeFromStr(yyvsp[-2]->value.pwszValue);
            DBTYPE dbType2 = GetDBTypeFromStr(yyvsp[0]->value.pwszValue);
            if ((DBTYPE_BYREF == dbType1 || DBTYPE_VECTOR == dbType1) &&
                (DBTYPE_BYREF == dbType2 || DBTYPE_VECTOR == dbType2))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(
                    L"DBTYPE_I2, DBTYPE_I4, DBTYPE_R4, DBTYPE_R8, DBTYPE_CY, DBTYPE_DATE, DBTYPE_BSTR, DBTYPE_BOOL, DBTYPE_STR, DBTYPE_WSTR");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            if (DBTYPE_BYREF != dbType1 && DBTYPE_VECTOR != dbType1 &&
                DBTYPE_BYREF != dbType2 && DBTYPE_VECTOR != dbType2)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"DBTYPE_BYREF, DBTYPE_VECTOR");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[-2]);
            yyvsp[-2] = NULL;
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = PctCreateNode(DBOP_scalar_constant, DBVALUEKIND_UI2, NULL);
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->value.usValue = dbType1 | dbType2;
            }
break;
case 233:
{
            GUID* pGuid = (GUID*) CoTaskMemAlloc(sizeof GUID);  /* this will become part of tree*/
            if (NULL == pGuid)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }

            BOOL bRet = ParseGuid(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, *pGuid);
            if ( bRet && GUID_NULL != *pGuid)
                {
                SCODE sc = PropVariantClear((PROPVARIANT*)yyvsp[0]->value.pvValue);
                Assert(SUCCEEDED(sc));  /* UNDONE:  meaningful error message*/
                CoTaskMemFree(yyvsp[0]->value.pvValue);
                yyvsp[0]->wKind = DBVALUEKIND_GUID;
                yyvsp[0]->value.pGuid = pGuid;
                yyval = yyvsp[0];
                }
            else
                {
                CoTaskMemFree(pGuid);
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            }
break;
case 234:
{
            yyval = NULL;
            }
break;
case 235:
{
            AssertReq(yyvsp[-1]);
            AssertReq(yyvsp[0]);

            if ((0==_wcsicmp(yyvsp[-1]->value.pwszValue, L"Jaccard")) &&
                (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"coefficient")))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_JACCARD);
            else if ((0==_wcsicmp(yyvsp[-1]->value.pwszValue, L"dice")) &&
                (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"coefficient")))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_DICE);
            else if ((0==_wcsicmp(yyvsp[-1]->value.pwszValue, L"inner")) &&
                (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"product")))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_INNER);
            else
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"MINIMUM, MAXIMUM, JACCARD COEFFICIENT, DICE COEFFICIENT, INNER PRODUCT");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            DeleteDBQT(yyvsp[-1]);
            yyvsp[-1] = NULL;
            yyval = NULL;
            }
break;
case 236:
{
            AssertReq(yyvsp[0]);

            if (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"minimum"))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_MIN);
            else if (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"maximum"))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_MAX);
            else
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"MINIMUM, MAXIMUM, JACCARD COEFFICIENT, DICE COEFFICIENT, INNER PRODUCT");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = NULL;
            }
break;
case 237:
{
            if (0 != _wcsicmp(yyvsp[-1]->value.pwszValue, L"GLOBAL"))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"GLOBAL");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            if (0 == _wcsicmp(yyvsp[0]->value.pwszValue, L"ON"))
                m_pIPSession->SetGlobalDefinition(TRUE);
            else if (0 == _wcsicmp(yyvsp[0]->value.pwszValue, L"OFF"))
                m_pIPSession->SetGlobalDefinition(FALSE);
            else
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"ON, OFF");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[-1]);
            DeleteDBQT(yyvsp[0]);
            yyval = NULL;
            }
break;
case 238:
{ /* _CREATE _VIEW view_name _AS _SELECT select_list from_clause*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-1] );
            AssertReq( yyvsp[0] );

            /**/
            /* Can create views only on the current catalog*/
            /**/
            if ( 0 != _wcsicmp((yyvsp[-4]->value.pdbcntnttblValue)->pwszMachine, m_pIPSession->GetDefaultMachine()) &&
                 0 != _wcsicmp((yyvsp[-4]->value.pdbcntnttblValue)->pwszCatalog, m_pIPSession->GetDefaultCatalog()) )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken( (yyvsp[-4]->pctNextSibling)->value.pwszValue );
                m_pIPTProperties->SetErrorToken( L"<unqualified temporary view name>" );
                YYABORT( DB_E_ERRORSINCOMMAND );
                }

            if ( DBOP_outall_name == yyvsp[-1]->op )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                m_pIPTProperties->SetErrorToken( L"*" );
                m_pIPTProperties->SetErrorToken( L"<select list>" );
                YYABORT( DB_E_ERRORSINCOMMAND );
                }

            Assert( DBOP_content_table == yyvsp[-4]->op );
            AssertReq( yyvsp[-4]->pctNextSibling );        /* name of the view*/

            SCODE sc = S_OK;

            /* This is the LA_proj, which doesn't have a NextSibling.*/
            /* Use the next sibling to store contenttable tree*/
            /* specified in the from_clause*/
            Assert( 0 == yyvsp[-1]->pctNextSibling );

            if ( L'#' != yyvsp[-4]->pctNextSibling->value.pwszValue[0] )
                {
                if ( m_pIPSession->GetGlobalDefinition() )
                    sc = m_pIPSession->GetGlobalViewList()->SetViewDefinition(
                                                                m_pIPSession,
                                                                m_pIPTProperties,
                                                                yyvsp[-4]->pctNextSibling->value.pwszValue,
                                                                NULL,       /* all catalogs*/
                                                                yyvsp[-1]);
                else
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[-4]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( L"<temporary view name>" );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                }
            else
                {
                if ( 1 >= wcslen(yyvsp[-4]->pctNextSibling->value.pwszValue) )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[-4]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( L"<temporary view name>" );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                else if ( L'#' == yyvsp[-4]->pctNextSibling->value.pwszValue[1] )
                    {
                    /* store the scope information for the view*/

                    yyvsp[-1]->pctNextSibling = yyvsp[0];
                    yyvsp[0] = 0;

                    sc = m_pIPSession->GetLocalViewList()->SetViewDefinition(
                                                                        m_pIPSession,
                                                                        m_pIPTProperties,
                                                                        yyvsp[-4]->pctNextSibling->value.pwszValue,
                                                                        (yyvsp[-4]->value.pdbcntnttblValue)->pwszCatalog,
                                                                        yyvsp[-1]);
                    }
                else
                    {
                    yyvsp[-1]->pctNextSibling = yyvsp[0];
                    yyvsp[0] = 0;

                    sc = m_pIPSession->GetGlobalViewList()->SetViewDefinition(
                                                                        m_pIPSession,
                                                                        m_pIPTProperties,
                                                                        yyvsp[-4]->pctNextSibling->value.pwszValue,
                                                                        (yyvsp[-4]->value.pdbcntnttblValue)->pwszCatalog,
                                                                        yyvsp[-1]);
                    }
                }

            if ( FAILED(sc) )
                {
                if ( E_INVALIDARG == sc )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_VIEW_ALREADY_DEFINED );
                    m_pIPTProperties->SetErrorToken( yyvsp[-4]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( (yyvsp[-4]->value.pdbcntnttblValue)->pwszCatalog );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                else
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[-4]->pctNextSibling->value.pwszValue );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                }

            DeleteDBQT( yyvsp[-4] );
            DeleteDBQT( yyvsp[-1] );

            if ( 0 != yyvsp[0] )
                DeleteDBQT( yyvsp[0] );

            yyval = 0;
            }
break;
case 239:
{
            AssertReq( yyvsp[0] );
            AssertReq( yyvsp[0]->pctNextSibling ); /* name of the view*/

            SCODE sc = S_OK;
            if ( L'#' != yyvsp[0]->pctNextSibling->value.pwszValue[0] )
                {
                if ( m_pIPSession->GetGlobalDefinition() )
                    sc = m_pIPSession->GetGlobalViewList()->DropViewDefinition( yyvsp[0]->pctNextSibling->value.pwszValue, NULL );
                else
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[0]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( L"<temporary view name>" );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                }
            else
                {
                if ( 1 >= wcslen(yyvsp[0]->pctNextSibling->value.pwszValue) )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[0]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( L"<temporary view name>" );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                else if ( L'#' == yyvsp[0]->pctNextSibling->value.pwszValue[1] )
                    sc = m_pIPSession->GetLocalViewList()->DropViewDefinition( yyvsp[0]->pctNextSibling->value.pwszValue,
                                                                               (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
                else
                    sc = m_pIPSession->GetGlobalViewList()->DropViewDefinition( yyvsp[0]->pctNextSibling->value.pwszValue,
                                                                                (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
                }
            if ( FAILED(sc) )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_VIEW_NOT_DEFINED );
                    m_pIPTProperties->SetErrorToken( yyvsp[0]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
            DeleteDBQT( yyvsp[0] );
            yyval = 0;
            }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            YYAPI_VALUENAME = NULL;
            try
            {
                if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) 
                    yychar = 0;
            }
            catch (HRESULT hr)
            {
                switch(hr)
                {
                case E_OUTOFMEMORY:
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                    YYABORT(E_OUTOFMEMORY);
                    break;

                default:
                    YYABORT(QPARSE_E_INVALID_QUERY);
                    break;
                }
            }
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
    {
        int yysspLoc = (int) ( yyssp - xyyss.Get() );
        xyyss.SetSize((unsigned) ( yyssp-xyyss.Get())+2);
        yyssp = xyyss.Get() + yysspLoc;
    }
    if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
    {
        int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
        xyyvs.SetSize((unsigned) ( yyvsp-xyyvs.Get())+2);
        yyvsp = xyyvs.Get() + yyvspLoc;
    }
    *++yyssp = (short) yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyabort:
    EmptyValueStack(yylval);
    return YYFATAL;
yyaccept:
    return YYSUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\mssqllex.cpp ===
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#include <pch.cxx>
#pragma hdrstop

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5



/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifndef YY_CHAR
#define YY_CHAR TCHAR
#endif

#ifdef __cplusplus

#include <tchar.h>
#include <stdlib.h>
        // class istream;

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed YY_CHAR to an unsigned
 * integer for use as an array index.  If the signed YY_CHAR is negative,
 * we want to instead treat it as an 8-bit unsigned YY_CHAR, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (YY_CHAR) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 32767       // UNDONE:  Should really just take the input from the bstr passed in

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *      if ( condition_holds )
 *              yyless( 5 );
 *      else
 *              do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                *yy_cp = yy_hold_char; \
                YY_RESTORE_YY_MORE_OFFSET \
                yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
                YY_DO_BEFORE_ACTION; /* set up yytext again */ \
                } \
        while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
        {
        // istream* yy_input_file;

        YY_CHAR *yy_ch_buf;             /* input buffer */
        YY_CHAR *yy_buf_pos;            /* current position in input buffer */

        /* Size of input buffer in bytes, not including room for EOB
         * characters.
         */
        yy_size_t yy_buf_size;

        /* Number of characters read into yy_ch_buf, not including EOB
         * characters.
         */
        int yy_n_chars;

        /* Whether we "own" the buffer - i.e., we know we created it,
         * and can realloc() it to grow it, and should free() it to
         * delete it.
         */
        int yy_is_our_buffer;

        /* Whether this is an "interactive" input source; if so, and
         * if we're using stdio for input, then we want to use getc()
         * instead of fread(), to make sure we stop fetching input after
         * each newline.
         */
        int yy_is_interactive;

        /* Whether we're considered to be at the beginning of a line.
         * If so, '^' rules will be active on the next match, otherwise
         * not.
         */
        int yy_at_bol;

        /* Whether to try to fill the input buffer when we reach the
         * end of it.
         */
        int yy_fill_buffer;

        int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
        /* When an EOF's been seen but there's still some text to process
         * then we mark the buffer as YY_EOF_PENDING, to indicate that we
         * shouldn't try reading from the input source any more.  We might
         * still have a bunch of tokens to match, though, because of
         * possible backing-up.
         *
         * When we actually see the EOF, we change the status to "new"
         * (via yyrestart()), so that the user can continue scanning by
         * just pointing yyin at a new input file.
         */
#define YY_BUFFER_EOF_PENDING 2
        };


/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer



static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( YY_BUF_SIZE ); \
        yy_current_buffer->yy_is_interactive = is_interactive; \
        }

#define yy_set_bol(at_bol) \
        { \
        if ( ! yy_current_buffer ) \
                yy_current_buffer = yy_create_buffer( YY_BUF_SIZE ); \
        yy_current_buffer->yy_at_bol = at_bol; \
        }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

#define yytext_ptr yytext


/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
        yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
        yy_hold_char = *yy_cp; \
        *yy_cp = '\0'; \
        yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 97
#define YY_END_OF_BUFFER 98
static yyconst short int yy_accept[406] =
    {   0,
        0,    0,    0,    0,   78,   78,    0,    0,    0,    0,
        0,    0,    0,    0,   98,   57,   39,   39,   57,   57,
       57,   57,   57,   57,   52,   45,   45,   57,   57,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   62,   61,   61,   62,
       58,   59,   78,   77,   77,   79,   78,   76,   78,   78,
       78,   78,   82,   81,   81,   80,   92,   89,   89,   92,
       90,   91,   92,   92,   92,   92,   92,   96,   93,   93,
       96,   95,   97,   97,   63,   39,   51,    0,   43,    0,
       41,    0,   44,   45,   45,   47,    0,   53,   46,   46,

        0,    0,   49,   50,   48,   40,   40,   40,   40,    5,
       40,   40,   40,   40,   40,   40,   40,   15,   40,   40,
       40,   40,   22,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   61,    0,   60,   59,   78,
        0,   77,    0,    0,    0,   78,    0,   75,    0,   78,
       78,   78,   78,   78,   78,   81,   89,    0,   83,    0,
        0,    0,   87,    0,   93,    0,   94,    0,   64,   63,
        0,   42,   41,    0,   47,   54,    0,    0,   46,    0,
       46,   45,    1,    2,    3,   40,    6,   40,   40,   40,
       40,   40,   40,   40,   40,    0,   40,   40,   19,   40,

       40,   40,   40,   40,   40,   40,   30,   40,   40,   40,
       40,   40,   40,   40,   40,    0,    0,    0,    0,    0,
       75,    0,   78,   78,   74,   78,   78,   78,   78,    0,
       84,    0,    0,    0,    0,   65,   64,   42,    0,    0,
        0,   46,   40,    7,   40,   40,   10,   11,   40,   40,
       14,    0,   17,   40,    0,   21,   40,   40,   40,   40,
       40,   40,   31,   40,   33,   34,   40,   40,   37,   40,
        0,    0,    0,   71,    0,   74,   78,   78,   78,   78,
        0,    0,    0,   65,    0,    0,    4,   40,   40,   12,
       40,    0,   40,    0,   40,   40,   40,   40,   40,   28,

       40,   32,   35,   40,   38,   66,   69,   70,   78,   78,
       78,   78,    0,    0,    0,    0,    0,   40,    8,   40,
       16,   40,    0,    0,   40,   40,   26,   40,   29,   40,
       67,   78,   78,   73,    0,    0,    0,    0,   55,   40,
       40,   18,    0,    0,   40,   40,   40,   36,   72,   68,
        0,    0,    0,   56,    9,   13,   20,   23,   40,   40,
       40,    0,    0,    0,   40,   40,   40,    0,    0,    0,
       40,   40,   27,    0,    0,    0,   24,   40,    0,    0,
        0,   25,    0,    0,    0,    0,    0,    0,   85,    0,
        0,    0,    0,    0,    0,    0,   88,    0,    0,    0,

        0,    0,    0,   86,    0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    2,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
       10,   11,   12,    7,   13,   14,    1,   15,   16,   16,
       16,   16,   16,   16,   16,   16,   16,    1,    1,   17,
       18,   19,    1,    1,   21,   22,   23,   24,   25,   26,
       27,   28,   29,   30,   31,   32,   33,   34,   35,   36,
       30,   37,   38,   39,   40,   41,   42,   43,   44,   30,
        7,    1,    7,    1,   20,    1,   21,   22,   23,   24,

       25,   26,   27,   28,   29,   30,   31,   32,   33,   34,
       35,   36,   30,   37,   38,   39,   40,   41,   42,   43,
       44,   30,    1,    7,    1,    7,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[45] =
    {   0,
        1,    2,    3,    2,    1,    4,    2,    1,    2,    2,
        1,    1,    1,    1,    5,    5,    1,    1,    1,    6,
        7,    7,    7,    7,    7,    7,    8,    8,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
        8,    8,    8,    8
    } ;

static yyconst short int yy_base[431] =
    {   0,
        0,    0,   44,    0,   87,  128,   96,   98,  169,  206,
      101,  112,  244,    0,  812,  813,  106,  116,  793,  805,
      803,  800,  105,  110,  125,  130,  133,  109,  789,  127,
        0,  131,  125,  132,  768,  776,  783,  140,  766,  139,
      781,  160,  161,  767,  771,  771,  813,  140,  184,  793,
      813,    0,  789,  189,  198,  813,  287,  788,  191,  194,
      159,  181,  813,  210,  215,  813,  813,  218,  232,  790,
      813,  813,  762,  768,  749,  765,  762,  813,  234,  236,
      784,  813,  813,  782,    0,  240,  813,  782,  781,    0,
        0,  777,  776,  285,  288,    0,  290,  276,  292,  296,

      303,    0,  813,  813,  813,    0,  751,  285,  745,  758,
      742,  745,  753,  739,  741,  743,   77,  320,  743,  734,
      733,  739,  746,  731,  733,  733,  731,  124,  732,  742,
      723,  726,  295,  736,  735,  328,  754,  753,    0,  749,
      748,  330,  721,  300,  717,  364,  217,  176,  329,  374,
      745,  319,  188,  328,  312,  336,  340,  747,  746,  718,
      724,  725,  813,  726,  343,  741,  740,    0,    0,    0,
      739,    0,    0,  735,    0,  704,  718,  340,  332,  343,
      345,    0,    0,    0,    0,  719,    0,  700,  699,  716,
      713,  699,  696,  708,  699,  360,  706,  707,  384,  697,

      703,  689,  690,  694,  688,  698,    0,  697,  689,  695,
      694,  683,  683,  674,  678,  709,  689,  691,  672,  386,
      705,  385,  395,  405,  362,  383,  384,  400,  403,  704,
      813,  672,  675,  674,  700,    0,    0,    0,  681,  668,
      403,  408,  658,    0,  680,  661,    0,    0,  674,  659,
        0,  662,    0,  668,  423,    0,  658,  655,  325,  660,
      667,  668,    0,  665,    0,    0,  655,  653,    0,  662,
      425,  649,  429,  431,  390,  680,  180,  413,  421,  429,
      433,  644,  651,    0,  647,  645,    0,  651,  654,    0,
      653,  638,  651,  646,  436,  646,  636,  648,  646,    0,

      631,    0,    0,  627,    0,  438,  813,  440,  436,  437,
      438,  440,  447,  644,  632,  630,  640,  630,    0,  620,
      813,  624,  630,  451,  623,  620,    0,  619,    0,  623,
      629,  372,  444,  625,  589,  586,  568,  578,  813,  557,
      548,    0,  554,  534,  532,  511,  522,    0,  541,  534,
      485,  456,  460,  813,    0,    0,  813,  813,  465,  470,
      467,  460,  462,  464,  472,  477,  473,  471,  470,  457,
      465,  459,    0,  454,  469,  468,    0,  463,  449,  448,
      443,    0,  461,  458,  455,  445,  448,  438,  813,  466,
      436,  468,  439,  410,  361,  356,  813,  252,  215,  177,

      139,  113,   61,  813,  813,  507,  515,  523,  531,  539,
      544,  552,  556,  564,  568,  576,  584,  592,  600,  605,
      609,  611,  615,  623,  627,  634,  636,  640,  644,  648
    } ;

static yyconst short int yy_def[431] =
    {   0,
      405,    1,  405,    3,  406,  406,  407,  407,  408,  408,
      409,  409,  405,   13,  405,  405,  405,  405,  405,  410,
      411,  412,  405,  405,  405,  405,  405,  405,  405,  413,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  413,  405,  405,  405,  414,
      405,  415,  416,  405,  405,  405,  417,  405,  416,  416,
      416,  416,  405,  405,  405,  405,  405,  405,  405,  418,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      419,  405,  405,  420,  421,  405,  405,  410,  405,  422,
      423,  412,  405,  405,  405,  424,  405,  405,  405,  405,

      405,  425,  405,  405,  405,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  405,  414,  405,  415,  416,
      405,  405,  405,  405,  405,  417,  426,  416,  426,  417,
      416,  416,  416,  416,  416,  405,  405,  418,  405,  405,
      405,  405,  405,  405,  405,  419,  405,  427,  428,  421,
      410,  429,  423,  412,  424,  405,  405,  405,  405,  405,
      405,  425,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  405,  413,  413,  413,  413,

      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  414,  405,  405,  405,  405,
      405,  426,  417,  417,  416,  416,  416,  416,  416,  418,
      405,  405,  405,  405,  419,  430,  428,  429,  405,  405,
      405,  405,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  405,  413,  413,  405,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      405,  405,  405,  405,  426,  405,  416,  416,  416,  416,
      405,  405,  405,  430,  405,  405,  413,  413,  413,  413,
      413,  405,  413,  405,  413,  413,  413,  413,  413,  413,

      413,  413,  413,  413,  413,  405,  405,  405,  416,  416,
      416,  416,  405,  405,  405,  405,  405,  413,  413,  413,
      405,  413,  405,  405,  413,  413,  413,  413,  413,  413,
      416,  416,  416,  416,  405,  405,  405,  405,  405,  413,
      413,  413,  405,  405,  413,  413,  413,  413,  416,  416,
      405,  405,  405,  405,  413,  413,  405,  405,  413,  413,
      413,  405,  405,  405,  413,  413,  413,  405,  405,  405,
      413,  413,  413,  405,  405,  405,  413,  413,  405,  405,
      405,  413,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,

      405,  405,  405,  405,    0,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405
    } ;

static yyconst short int yy_nxt[858] =
    {   0,
       16,   17,   18,   19,   20,   21,   16,   22,   16,   16,
       16,   23,   24,   25,   26,   27,   28,   16,   29,   16,
       30,   31,   32,   33,   31,   34,   31,   31,   35,   31,
       31,   36,   37,   38,   39,   40,   41,   42,   43,   44,
       45,   46,   31,   31,   47,   48,   49,   47,   50,   47,
       47,   51,   47,   47,   47,   47,   47,   47,   47,   47,
       47,   47,   47,   47,   52,   52,   52,   52,   52,   52,
       52,   52,   52,   52,   52,   52,   52,   52,   52,   52,
       52,   52,   52,   52,   52,   52,   52,   52,   54,   55,
       56,   57,  404,   56,   58,   56,   56,   64,   65,   64,

       65,  194,   79,   80,   66,   81,   66,   86,   86,   59,
       82,  195,   60,   79,   80,   61,   81,   86,   86,   94,
       95,   82,   96,   97,   94,   95,  103,  104,   62,   54,
       55,   56,   57,  403,   56,   58,   56,   56,   98,   99,
       99,  136,  136,  100,   95,   95,  100,   95,   95,  114,
       59,  111,  116,   60,  101,  206,   61,  101,  107,  124,
      108,  115,  207,  109,  110,  112,  141,  113,  117,   62,
       68,   69,  102,   70,  121,  125,  402,   71,   72,  122,
      223,  130,  127,  141,  128,  136,  136,  141,  141,   73,
      142,  142,   74,   75,  129,  141,  154,  131,  141,  142,

      142,  141,  309,   76,  132,  155,   77,   68,   69,  143,
       70,  156,  156,  401,   71,   72,  156,  156,  143,  157,
      157,  221,  144,  145,  227,  152,   73,  222,  153,   74,
       75,  144,  145,  157,  157,  165,  165,  165,  165,  400,
       76,   86,   86,   77,   83,   83,   83,   83,   83,   84,
       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
       83,   83,   83,   83,   85,   85,   85,   85,   85,   85,
       85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
       85,   85,   85,   85,   85,   85,   85,   85,  147,  176,
      147,  148,  399,  147,  149,  147,  147,  150,  100,   95,

       95,  100,   95,   95,   99,   99,   99,   99,  184,  101,
      179,  179,  101,  177,  180,  180,  178,  181,  181,  141,
      101,  196,  196,  212,  218,  213,  141,  102,  185,  136,
      136,  142,  142,  221,  219,  141,  224,  156,  156,  222,
      229,  157,  157,  226,  165,  165,  179,  179,  228,  297,
      143,  241,  241,  298,  242,  242,  101,  181,  181,  181,
      181,  196,  196,  144,  145,  147,  223,  147,  148,  141,
      147,  149,  147,  147,  150,  147,  398,  147,  225,  141,
      147,  149,  147,  147,  150,  255,  255,  274,  274,  276,
      141,  141,  397,  252,  221,  222,  147,  349,  147,  148,

      222,  147,  149,  147,  147,  150,  147,  141,  147,  148,
      141,  147,  149,  147,  147,  150,  278,  242,  242,  277,
      141,  279,  242,  242,  255,  255,  306,  306,  141,  280,
      308,  308,  274,  274,  313,  313,  141,  324,  324,  306,
      306,  308,  308,  141,  141,  141,  396,  141,  313,  313,
      310,  141,  324,  324,  294,  311,  312,  363,  363,  395,
      331,  364,  364,  363,  363,  364,  364,  392,  392,  392,
      392,  332,  344,  393,  391,  390,  389,  333,  334,  388,
      387,  386,  350,  385,  384,  335,  383,  382,  381,  380,
      379,  378,  377,  376,  375,  374,  373,  372,  371,  369,

      368,  367,  370,  366,  365,  362,  394,   53,   53,   53,
       53,   53,   53,   53,   53,   63,   63,   63,   63,   63,
       63,   63,   63,   67,   67,   67,   67,   67,   67,   67,
       67,   78,   78,   78,   78,   78,   78,   78,   78,   88,
       88,  141,   88,   88,   88,   88,   88,   91,  141,  361,
       91,   91,   92,   92,  360,   92,   92,   92,   92,   92,
      106,  106,  106,  106,  137,  137,  359,  137,  137,  137,
      137,  137,  139,  139,  139,  139,  140,  358,  357,  140,
      140,  140,  140,  140,  146,  146,  356,  146,  146,  146,
      146,  146,  158,  158,  355,  158,  158,  158,  158,  158,

      166,  166,  354,  166,  166,  166,  166,  166,  169,  353,
      352,  169,  169,  170,  170,  170,  170,  172,  172,  173,
      173,  173,  173,  175,  175,  351,  175,  175,  175,  175,
      175,  182,  141,  182,  147,  147,  141,  147,  147,  147,
      147,  147,  236,  236,  237,  237,  237,  237,  238,  238,
      238,  238,  284,  284,  284,  284,  348,  347,  346,  345,
      343,  342,  341,  340,  339,  338,  337,  336,  330,  329,
      328,  327,  326,  325,  323,  322,  321,  320,  319,  318,
      317,  316,  315,  314,  275,  307,  305,  304,  303,  302,
      301,  300,  299,  296,  295,  293,  292,  291,  290,  289,

      288,  287,  286,  285,  167,  283,  282,  281,  159,  275,
      273,  272,  271,  138,  270,  269,  268,  267,  266,  265,
      264,  263,  262,  261,  260,  259,  258,  257,  256,  254,
      253,  251,  250,  249,  248,  247,  246,  245,  244,  243,
      240,  239,   93,   89,  235,  167,  234,  233,  232,  231,
      230,  159,  141,  220,  217,  151,  141,  216,  138,  215,
      214,  211,  210,  209,  208,  205,  204,  203,  202,  201,
      200,  199,  198,  197,  193,  192,  191,  190,  189,  188,
      187,  186,  183,  174,   93,  171,   89,  168,  167,  164,
      163,  162,  161,  160,  159,  151,  141,  138,  135,  134,

      133,  126,  123,  120,  119,  118,  105,   93,   90,   89,
       87,  405,   15,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405
    } ;

static yyconst short int yy_chk[858] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    5,    5,
        5,    5,  403,    5,    5,    5,    5,    7,    7,    8,

        8,  117,   11,   11,    7,   11,    8,   17,   17,    5,
       11,  117,    5,   12,   12,    5,   12,   18,   18,   23,
       23,   12,   24,   24,   24,   24,   28,   28,    5,    6,
        6,    6,    6,  402,    6,    6,    6,    6,   25,   25,
       25,   48,   48,   26,   26,   26,   27,   27,   27,   33,
        6,   32,   34,    6,   26,  128,    6,   27,   30,   40,
       30,   33,  128,   30,   30,   32,   61,   32,   34,    6,
        9,    9,   26,    9,   38,   40,  401,    9,    9,   38,
      148,   43,   42,  148,   42,   49,   49,  277,   62,    9,
       54,   54,    9,    9,   42,  153,   61,   43,   59,   55,

       55,   60,  277,    9,   43,   62,    9,   10,   10,   54,
       10,   64,   64,  400,   10,   10,   65,   65,   55,   68,
       68,  147,   54,   54,  153,   59,   10,  147,   60,   10,
       10,   55,   55,   69,   69,   79,   79,   80,   80,  399,
       10,   86,   86,   10,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   57,   98,
       57,   57,  398,   57,   57,   57,   57,   57,   94,   94,

       94,   95,   95,   95,   97,   97,   99,   99,  108,   94,
      100,  100,   95,   98,  101,  101,   99,  101,  101,  155,
      100,  118,  118,  133,  144,  133,  152,   94,  108,  136,
      136,  142,  142,  149,  144,  154,  149,  156,  156,  149,
      155,  157,  157,  152,  165,  165,  179,  179,  154,  259,
      142,  178,  178,  259,  178,  178,  179,  180,  180,  181,
      181,  196,  196,  142,  142,  146,  225,  146,  146,  225,
      146,  146,  146,  146,  146,  150,  396,  150,  150,  332,
      150,  150,  150,  150,  150,  199,  199,  220,  220,  222,
      226,  227,  395,  196,  275,  222,  223,  332,  223,  223,

      275,  223,  223,  223,  223,  223,  224,  228,  224,  224,
      229,  224,  224,  224,  224,  224,  227,  241,  241,  226,
      278,  228,  242,  242,  255,  255,  271,  271,  279,  229,
      273,  273,  274,  274,  281,  281,  280,  295,  295,  306,
      306,  308,  308,  309,  310,  311,  394,  312,  313,  313,
      278,  333,  324,  324,  255,  279,  280,  352,  352,  393,
      309,  353,  353,  363,  363,  364,  364,  390,  390,  392,
      392,  310,  324,  391,  388,  387,  386,  311,  312,  385,
      384,  383,  333,  381,  380,  313,  379,  378,  376,  375,
      374,  372,  371,  370,  369,  368,  367,  366,  365,  363,

      362,  361,  364,  360,  359,  351,  392,  406,  406,  406,
      406,  406,  406,  406,  406,  407,  407,  407,  407,  407,
      407,  407,  407,  408,  408,  408,  408,  408,  408,  408,
      408,  409,  409,  409,  409,  409,  409,  409,  409,  410,
      410,  350,  410,  410,  410,  410,  410,  411,  349,  347,
      411,  411,  412,  412,  346,  412,  412,  412,  412,  412,
      413,  413,  413,  413,  414,  414,  345,  414,  414,  414,
      414,  414,  415,  415,  415,  415,  416,  344,  343,  416,
      416,  416,  416,  416,  417,  417,  341,  417,  417,  417,
      417,  417,  418,  418,  340,  418,  418,  418,  418,  418,

      419,  419,  338,  419,  419,  419,  419,  419,  420,  337,
      336,  420,  420,  421,  421,  421,  421,  422,  422,  423,
      423,  423,  423,  424,  424,  335,  424,  424,  424,  424,
      424,  425,  334,  425,  426,  426,  331,  426,  426,  426,
      426,  426,  427,  427,  428,  428,  428,  428,  429,  429,
      429,  429,  430,  430,  430,  430,  330,  328,  326,  325,
      323,  322,  320,  318,  317,  316,  315,  314,  304,  301,
      299,  298,  297,  296,  294,  293,  292,  291,  289,  288,
      286,  285,  283,  282,  276,  272,  270,  268,  267,  264,
      262,  261,  260,  258,  257,  254,  252,  250,  249,  246,

      245,  243,  240,  239,  235,  234,  233,  232,  230,  221,
      219,  218,  217,  216,  215,  214,  213,  212,  211,  210,
      209,  208,  206,  205,  204,  203,  202,  201,  200,  198,
      197,  195,  194,  193,  192,  191,  190,  189,  188,  186,
      177,  176,  174,  171,  167,  166,  164,  162,  161,  160,
      159,  158,  151,  145,  143,  141,  140,  138,  137,  135,
      134,  132,  131,  130,  129,  127,  126,  125,  124,  123,
      122,  121,  120,  119,  116,  115,  114,  113,  112,  111,
      110,  109,  107,   93,   92,   89,   88,   84,   81,   77,
       76,   75,   74,   73,   70,   58,   53,   50,   46,   45,

       44,   41,   39,   37,   36,   35,   29,   22,   21,   20,
       19,   15,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405,  405,  405,  405,
      405,  405,  405,  405,  405,  405,  405
    } ;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
#define INITIAL 0
//--------------------------------------------------------------------
// Microsoft Monarch
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.
//
// @doc OPTIONAL EXTRACTION CODES
//
// @module  ms-sql.l |
//          LEX tokenizer script
//
// @devnotes none
//
// @rev 0 | 04-Feb-97 | v-charca  | Created
//

/**
** NOTE : when adding a new token (XXX) modify the following:
**      1.) Add %token _XXX to sql.y
**      2.) Add lexeme pattern to sql.l stating whether the token returns a TOKEN
**          or a VALUE.  If the token returns a value a node will need to be created to
**          contain the value information. Therefore the VALUE macro will also need to
**          specify a valid VARIANT type for the value.
**/


#include "msidxtr.h"

#ifdef DEBUG
# define YYTRACE(tknNum) LexerTrace(yytext, yyleng, tknNum);
#else
# define YYTRACE(tknNum)
#endif


#define TOKEN(tknNum) YYTRACE(tknNum) return(tknNum);

#define VALUE(tknNum)                   \
    {                                   \
    YYTRACE(tknNum)                     \
    CreateTknValue(yylval, tknNum);     \
    return tknNum;                      \
    }

#define STRING_VALUE(tknNum, wch, fQuote)           \
    {                                               \
    YYTRACE(tknNum)                                 \
    CreateTknValue(yylval, tknNum, wch, fQuote);    \
    return tknNum;                                  \
    }

#define ID_VALUE(tknNum, wch)               \
    {                                       \
    YYTRACE(tknNum)                         \
    CreateTknValue(yylval, tknNum, wch);    \
    return _ID;                             \
    }

/*
** Make Lex read from a block of data
**    buffer is the character buffer,
**    result is a variable to store the number of chars read
**    ms is the size of the buffer
*/
#undef YY_INPUT
#define YY_INPUT(b, r, ms) (r = yybufferinput(b, ms))

//--------------------------------------------------------------------------------------------
// @func Makes a new copy of UNICODE string.  Filters out double quotes
// @side Allocates enough bytes to hold string
// @rdesc Pointer to new UNICODE string

LPWSTR PwszDupFilter(
    LPWSTR  pwszOrig,
    WCHAR   wch )
{
    LPWSTR pwszCopy = (LPWSTR)CoTaskMemAlloc( (wcslen(pwszOrig)+2)*sizeof(WCHAR) );
    if ( 0 != pwszCopy )
    {
        LPWSTR pwsz = pwszCopy;
        while ( 0 != *pwszOrig )
        {
            if ( *(pwszOrig+1) && *(pwszOrig+1) == *pwszOrig && wch == *pwszOrig )
                pwszOrig++;
            else
                *pwsz++ = *pwszOrig++;
        }
        *pwsz = L'\0';
    }

    return pwszCopy;
}

//--------------------------------------------------------------------------------------------
//      YYLEXER::CreateTknValue
//      Creates a QUERYTREE node structure which is passed to the YACC value stack.
//      This routines uses the TokenInfo map to determine which opids to create for
//      the given string.
//
//
void YYLEXER::CreateTknValue(
    YYSTYPE *ppct,
    short tknNum,
    YY_CHAR wch,
    BOOL fQuote )
{
    // Note that values containing variants can only be CONSTANTS or ID's
    // SHOULD BE DONE BY valType
    switch ( tknNum )
    {
        case _ID:
        case _TEMPVIEW:
            {
                // Assume table_name for now.  Might have to correct this when I
                // see the context in the parser.
                if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_WSTR)) )
                    throw(E_OUTOFMEMORY);

                (*ppct)->op    = DBOP_table_name;
                (*ppct)->wKind = DBVALUEKIND_WSTR;
                (*ppct)->value.pwszValue = CoTaskStrDup(yytext_ptr);
                if( 0 == (*ppct)->value.pwszValue )
                {
                    DeleteDBQT( *ppct );
                    *ppct = NULL;
                    throw(E_OUTOFMEMORY);
                }
                _wcsupr((*ppct)->value.pwszValue);
                break;
            }

        case _DELIMITED_ID:
            {
                if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_WSTR)) )
                    throw(E_OUTOFMEMORY);

                (*ppct)->op    = DBOP_table_name;
                (*ppct)->wKind = DBVALUEKIND_WSTR;
                // Strip quotes on delimited identifier
                yytext_ptr[wcslen(yytext_ptr)-1] = L'\0';
                (*ppct)->value.pwszValue = PwszDupFilter(yytext_ptr+1, wch);
                if( 0 == (*ppct)->value.pwszValue )
                {
                    DeleteDBQT( *ppct );
                    *ppct = NULL;
                    throw(E_OUTOFMEMORY);
                }
                break;
            }

        case _URL:
        case _STRING:
        case _PREFIX_STRING:
            {
                // NOTE:  This is really a PROPVARIANT node, but there is no DBVALUEKIND for PROPVARIANT.
                if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant)) )
                    throw(E_OUTOFMEMORY);

                LPWSTR pwsz = yytext_ptr;
                LPWSTR pwszCopy = PwszDupFilter(pwsz, wch);

                if ( 0 == pwszCopy )
                {
                    DeleteDBQT( *ppct );
                    *ppct = NULL;
                    throw(E_OUTOFMEMORY);
                }

                LPWSTR pwszTemp = pwszCopy;
                // Strip quotes on literals or
                if ( fQuote && (*pwszCopy == L'\"' || *pwszCopy == L'\'') )
                {
                    pwszCopy++;
                    Assert(pwszCopy[wcslen(pwszCopy)-1] == L'\"' || pwszCopy[wcslen(pwszCopy)-1] == L'\'');
                    pwszCopy[wcslen(pwszCopy)-1] = L'\0';
                }

                ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal = SysAllocString( pwszCopy );
                CoTaskMemFree( pwszTemp );  // throw away temporary before testing for out of memory
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_BSTR;
                if( 0 == ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal )
                {
                    DeleteDBQT( *ppct );
                    *ppct = 0;
                    throw(E_OUTOFMEMORY);
                }
            }
            break;

        case _INTNUM:
            if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant)) )
                throw(E_OUTOFMEMORY);

            ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal = SysAllocString( yytext_ptr );
            ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_BSTR;
            if ( 0 == ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal )
            {
                DeleteDBQT( *ppct );
                *ppct = 0;
                throw(E_OUTOFMEMORY);
            }

            (*ppct)->hrError = PropVariantChangeTypeI64( (PROPVARIANT*)(*ppct)->value.pvValue );
            if ( FAILED((*ppct)->hrError) )
            {
                HRESULT hr = (*ppct)->hrError;
                DeleteDBQT( *ppct );
                *ppct = 0;
                throw(hr);
            }
            break;

        case _REALNUM:
            if ( 0 == (*ppct = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant)) )
                throw(E_OUTOFMEMORY);

            ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal = SysAllocString( yytext_ptr );
            ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_BSTR;
            if ( 0 == ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal )
            {
                DeleteDBQT( *ppct );
                *ppct = NULL;
                throw(E_OUTOFMEMORY);
            }

            (*ppct)->hrError = VariantChangeTypeEx( (*ppct)->value.pvarValue,  // convert in place
                                                    (*ppct)->value.pvarValue,
                                                    LOCALE_SYSTEM_DEFAULT,
                                                    0,
                                                    VT_R8 );
            if ( FAILED((*ppct)->hrError) )
            {
                HRESULT hr = (*ppct)->hrError;
                DeleteDBQT( *ppct );
                *ppct = 0;
                throw(hr);
            }
            break;

        default:
            Assert( !"Unkown token value" );
    }
}


#define contains 1

#define cntntsrch 2

#define scope0 3

#define scope1 4

#define scope2 5

#define view 6


/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
 int yyywrap YY_PROTO(( void )) {return 1;}
#else
extern int yyywrap YY_PROTO(( void ));
#endif
#endif


#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( YY_CHAR *, yyconst YY_CHAR *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst YY_CHAR * ));
#endif

#ifndef YY_NO_INPUT
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE (8192 / sizeof(TCHAR))
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
#define ECHO LexerOutput( yytext, yyleng )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( (result = LexerInput( (YY_CHAR *) buf, max_size )) < 0 ) \
                /*YY_FATAL_ERROR( L"input in flex scanner failed" );*/
                throw(E_FAIL);
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) LexerError( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int YYLEXER::yylex(YYSTYPE *yylval)
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
        {
        register yy_state_type yy_current_state;
        register YY_CHAR *yy_cp, *yy_bp;
        register int yy_act;




/***
 *** Reserved words in every context
 ***/


        if ( yy_init )
                {
                yy_init = 0;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yy_start )
                        yy_start = 1;   /* first start state */

                if ( ! yy_current_buffer )
                        yy_current_buffer =
                                yy_create_buffer( (cInputBuffer * sizeof(YY_CHAR)) + sizeof(YY_CHAR) );

                yy_load_buffer_state();

                if (yyprimetoken)
                        {
                        int yysavetoken = yyprimetoken;
                        yyprimetoken = 0;
                        return yysavetoken;
                        }
                }

        while ( 1 )             /* loops until end-of-file is reached */
                {
                yy_cp = yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = 1; if (256 > *yy_cp) yy_c = (YY_CHAR) yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 406 )
					yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 405 );
		yy_cp = yy_last_accepting_cpos;
		yy_current_state = yy_last_accepting_state;

yy_find_action:
		yy_act = yy_accept[yy_current_state];

                YY_DO_BEFORE_ACTION;


do_action:      /* This label is used only to access EOF actions. */


                switch ( yy_act )
        { /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
{ TOKEN(_ALL);                      }
	YY_BREAK
case 2:
YY_RULE_SETUP
{ TOKEN(_AND);                      }
	YY_BREAK
case 3:
YY_RULE_SETUP
{ TOKEN(_ANY);                      }
	YY_BREAK
case 4:
YY_RULE_SETUP
{ TOKEN(_ARRAY);                    }
	YY_BREAK
case 5:
YY_RULE_SETUP
{ TOKEN(_AS);                       }
	YY_BREAK
case 6:
YY_RULE_SETUP
{ TOKEN(_ASC);                      }
	YY_BREAK
case 7:
YY_RULE_SETUP
{ TOKEN(_CAST);                     }
	YY_BREAK
case 8:
YY_RULE_SETUP
{ TOKEN(_CREATE);                   }
	YY_BREAK
case 9:
YY_RULE_SETUP
{ BEGIN contains;TOKEN(_CONTAINS);  }
	YY_BREAK
case 10:
YY_RULE_SETUP
{ TOKEN(_DESC);                     }
	YY_BREAK
case 11:
YY_RULE_SETUP
{ TOKEN(_DROP);                     }
	YY_BREAK
case 12:
YY_RULE_SETUP
{ TOKEN(_FALSE);                    }
	YY_BREAK
case 13:
YY_RULE_SETUP
{ TOKEN(_FREETEXT);                 }
	YY_BREAK
case 14:
YY_RULE_SETUP
{ TOKEN(_FROM);                     }
	YY_BREAK
case 15:
YY_RULE_SETUP
{ TOKEN(_IS);                       }
	YY_BREAK
case 16:
YY_RULE_SETUP
{ TOKEN(_IS_NOT);                   }
	YY_BREAK
case 17:
YY_RULE_SETUP
{ TOKEN(_LIKE);                     }
	YY_BREAK
case 18:
YY_RULE_SETUP
{ TOKEN(_MATCHES);                  }
	YY_BREAK
case 19:
YY_RULE_SETUP
{ TOKEN(_NOT);                      }
	YY_BREAK
case 20:
YY_RULE_SETUP
{ TOKEN(_NOT_LIKE);                 }
	YY_BREAK
case 21:
YY_RULE_SETUP
{ TOKEN(_NULL);                     }
	YY_BREAK
case 22:
YY_RULE_SETUP
{ TOKEN(_OR);                       }
	YY_BREAK
case 23:
YY_RULE_SETUP
{ TOKEN(_ORDER_BY);                 }
	YY_BREAK
case 24:
YY_RULE_SETUP
{ TOKEN(_PASSTHROUGH);              }
	YY_BREAK
case 25:
YY_RULE_SETUP
{ TOKEN(_PROPERTYNAME);             }
	YY_BREAK
case 26:
YY_RULE_SETUP
{ TOKEN(_PROPID);                   }
	YY_BREAK
case 27:
YY_RULE_SETUP
{ TOKEN(_RANKMETHOD);               }
	YY_BREAK
case 28:
YY_RULE_SETUP
{ BEGIN scope0; TOKEN(_SCOPE);      }
	YY_BREAK
case 29:
YY_RULE_SETUP
{ TOKEN(_SELECT);                   }
	YY_BREAK
case 30:
YY_RULE_SETUP
{ TOKEN(_SET);                      }
	YY_BREAK
case 31:
YY_RULE_SETUP
{ TOKEN(_SOME);                     }
	YY_BREAK
case 32:
YY_RULE_SETUP
{ TOKEN(_TABLE);                    }
	YY_BREAK
case 33:
YY_RULE_SETUP
{ TOKEN(_TRUE);                     }
	YY_BREAK
case 34:
YY_RULE_SETUP
{ TOKEN(_TYPE);                     }
	YY_BREAK
case 35:
YY_RULE_SETUP
{ TOKEN(_UNION);                    }
	YY_BREAK
case 36:
YY_RULE_SETUP
{ TOKEN(_UNKNOWN);                  }
	YY_BREAK
case 37:
YY_RULE_SETUP
{ TOKEN(_VIEW);                     }
	YY_BREAK
case 38:
YY_RULE_SETUP
{ TOKEN(_WHERE);                    }
	YY_BREAK
case 39:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 40:
YY_RULE_SETUP
{ VALUE(_ID);                       }
	YY_BREAK
case 41:
YY_RULE_SETUP
{ VALUE(_TEMPVIEW);                 }
	YY_BREAK
case 42:
YY_RULE_SETUP
{ VALUE(_TEMPVIEW);                 }
	YY_BREAK
case 43:
YY_RULE_SETUP
{ ID_VALUE(_DELIMITED_ID, L'"');        }
	YY_BREAK
case 44:
YY_RULE_SETUP
{ STRING_VALUE(_STRING, L'\'', TRUE);}
	YY_BREAK
case 45:
YY_RULE_SETUP
{ VALUE(_INTNUM);                   }
	YY_BREAK
case 46:
YY_RULE_SETUP
{ VALUE(_REALNUM);                  }
	YY_BREAK
case 47:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 48:
YY_RULE_SETUP
{ TOKEN(_GE);                       }
	YY_BREAK
case 49:
YY_RULE_SETUP
{ TOKEN(_LE);                       }
	YY_BREAK
case 50:
YY_RULE_SETUP
{ TOKEN(_NE);                       }
	YY_BREAK
case 51:
YY_RULE_SETUP
{ TOKEN(_NE);                       }
	YY_BREAK
case 52:
YY_RULE_SETUP
{ TOKEN(_DOT);                      }
	YY_BREAK
case 53:
YY_RULE_SETUP
{ BEGIN view; TOKEN(_DOTDOT);       }
	YY_BREAK
case 54:
YY_RULE_SETUP
{ BEGIN view; TOKEN(_DOTDOTDOT);    }
	YY_BREAK
case 55:
YY_RULE_SETUP
{ BEGIN scope0; TOKEN(_DOTDOT_SCOPE);}
	YY_BREAK
case 56:
YY_RULE_SETUP
{ BEGIN scope0; TOKEN(_DOTDOTDOT_SCOPE);}
	YY_BREAK
case 57:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0]; }
	YY_BREAK

/***
 *** A <contains predicate> has been started.  The only things we should see are:
 ***    (                   - matched by .
 ***    <column reference>  - matched by {id} or "{br_id}"
 ***    ,                   - matched by .
 ***    '                   - matched by \'.  Also switch to content search state (cntnsrch).
 ***/

case 58:
YY_RULE_SETUP
{ BEGIN cntntsrch;YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 59:
YY_RULE_SETUP
{ VALUE(_ID);                       }
	YY_BREAK
case 60:
YY_RULE_SETUP
{ ID_VALUE(_DELIMITED_ID, L'"');        }
	YY_BREAK
case 61:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 62:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK

/***
 *** The only things we should see are:
 ***    <global view name>  - matched by {id}
 ***    _TEMPVIEW           - matched by \#{id} or \#\#{id}
 ***/

case 63:
YY_RULE_SETUP
{ BEGIN INITIAL; VALUE(_ID);        }
	YY_BREAK
case 64:
YY_RULE_SETUP
{ BEGIN INITIAL; VALUE(_TEMPVIEW);  }
	YY_BREAK
case 65:
YY_RULE_SETUP
{ BEGIN INITIAL; VALUE(_TEMPVIEW);  }
	YY_BREAK

/***
 *** A <content search condition> has been started.  There are several keywords we can see here.
 *** We are also looking for a quoted string, a prefix string, or a simple term.  We are taken
 *** back to the initial state by a single quote (').
 ***/

case 66:
YY_RULE_SETUP
{ unput(L' '); TOKEN(_AND);         }
	YY_BREAK
case 67:
YY_RULE_SETUP
{ TOKEN(_COERCE);                   }
	YY_BREAK
case 68:
YY_RULE_SETUP
{ TOKEN(_ISABOUT);                  }
	YY_BREAK
case 69:
YY_RULE_SETUP
{ TOKEN(_NEAR);                     }
	YY_BREAK
case 70:
YY_RULE_SETUP
{ unput(L' '); TOKEN(_NOT);         }
	YY_BREAK
case 71:
YY_RULE_SETUP
{ unput(L' '); TOKEN(_OR);          }
	YY_BREAK
case 72:
YY_RULE_SETUP
{ TOKEN(_FORMSOF);                  }
	YY_BREAK
case 73:
YY_RULE_SETUP
{ TOKEN(_WEIGHT);                   }
	YY_BREAK
case 74:
YY_RULE_SETUP
{ STRING_VALUE(_PREFIX_STRING, L'\'', TRUE);}
	YY_BREAK
case 75:
YY_RULE_SETUP
{ STRING_VALUE(_STRING, L'\'', TRUE);}
	YY_BREAK
case 76:
YY_RULE_SETUP
{ BEGIN INITIAL; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 77:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 78:
YY_RULE_SETUP
{ STRING_VALUE(_STRING, L'\'', FALSE)}
	YY_BREAK
case 79:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK

/***
 *** A <from clause> has been started.  We've already seen the keyword SCOPE, so this
 *** is not a FROM <view name>.  We're just looking for a ( now to put us into the
 *** next state (scope1).
 ***    (                   - matched by \(.  Also switch to scope1 state.
 ***/

case 80:
YY_RULE_SETUP
{ BEGIN scope1; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 81:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 82:
YY_RULE_SETUP
{ BEGIN scope1; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK

/***
 *** We're in the middle of a <from clause>.  We've seen FROM SCOPE(, so now we need to recognize
 *** the various scope definitions that we might see here.  The two important things to recognize
 *** are:
 ***    (                   - matched by \(.  Also switch to scope2 state to match parens.
 ***    )                   - matched by \).  Also switch to the initial (finished <from clause>).
 ***/

case 83:
YY_RULE_SETUP
{ STRING_VALUE(_URL, L'"', TRUE);   }
	YY_BREAK
case 84:
YY_RULE_SETUP
{ TOKEN(_ALL);                      }
	YY_BREAK
case 85:
YY_RULE_SETUP
{ TOKEN(_DEEP_TRAVERSAL);           }
	YY_BREAK
case 86:
YY_RULE_SETUP
{ TOKEN(_EXCLUDE_SEARCH_TRAVERSAL);}
	YY_BREAK
case 87:
YY_RULE_SETUP
{ TOKEN(_OF);                       }
	YY_BREAK
case 88:
YY_RULE_SETUP
{ TOKEN(_SHALLOW_TRAVERSAL);        }
	YY_BREAK
case 89:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 90:
YY_RULE_SETUP
{ BEGIN scope2; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 91:
YY_RULE_SETUP
{ BEGIN INITIAL; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 92:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK

/***
 *** We're still in the middle of a <from clause>.  So far we've seen:
 ***    FROM SCOPE( ... (
 *** We need to find a ')' to finish out the element we're working on:
 ***    )                   - matched by \).  Also switch back to scope1 state.
 ***/

case 93:
YY_RULE_SETUP
{ /* empty lex rule */              }
	YY_BREAK
case 94:
YY_RULE_SETUP
{ STRING_VALUE(_URL, L'"', TRUE);  }
	YY_BREAK
case 95:
YY_RULE_SETUP
{ BEGIN scope1; YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 96:
YY_RULE_SETUP
{ YYTRACE(yytext[0]); return yytext[0];}
	YY_BREAK
case 97:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(contains):
case YY_STATE_EOF(cntntsrch):
case YY_STATE_EOF(scope0):
case YY_STATE_EOF(scope1):
case YY_STATE_EOF(scope2):
case YY_STATE_EOF(view):
	yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB YY_CHAR. */
                int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between yy_current_buffer and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yy_n_chars = yy_current_buffer->yy_n_chars;
                        yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p "<=" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state();

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state );

                        yy_bp = yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
				yy_cp = yy_last_accepting_cpos;
				yy_current_state = yy_last_accepting_state;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer() )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yy_did_buffer_switch_on_eof = 0;

                                if ( yyywrap() )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yy_c_buf_p =
                                        yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yy_c_buf_p =
                                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                                yy_current_state = yy_get_previous_state();

                                yy_cp = yy_c_buf_p;
                                yy_bp = yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                /* YY_FATAL_ERROR(L"fatal flex scanner internal error--no action found" );*/
                throw(E_FAIL);
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of yylex */

YYLEXER::YYLEXER()
        {
        yy_c_buf_p = 0;
        yy_init = 1;
        yy_start = 0;
        yyprimetoken = 0;
        yy_flex_debug = 0;
        yylineno = 1;   // this will only get updated if %option yylineno

        yy_did_buffer_switch_on_eof = 0;

        yy_looking_for_trail_begin = 0;
        yy_more_flag = 0;
        yy_more_len = 0;
        yy_more_offset = yy_prev_more_offset = 0;

        yy_start_stack_ptr = yy_start_stack_depth = 0;
        yy_start_stack = 0;

        yy_current_buffer = 0;

#ifdef YY_USES_REJECT
        yy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];
#else
        yy_state_buf = 0;
#endif

        pszInputBuffer = pCurBuffer = (YY_CHAR *)NULL;
        cInputBuffer = 0;
#ifdef DEBUG
        tkndebug = getenv("TKNDEBUG") ? 1 : 0;
#endif
        }

YYLEXER::~YYLEXER()
        {
        delete yy_state_buf;
        yy_delete_buffer( yy_current_buffer );
        }

#ifdef YY_INTERACTIVE
int YYLEXER::LexerInput( YY_CHAR* buf, int /* max_size */ )
#else
int YYLEXER::LexerInput( YY_CHAR* buf, int max_size )
#endif
        {
        return 0;
        }

void YYLEXER::LexerOutput( const YY_CHAR* buf, int size )
        {
        /*
        for (int i=0; i<size; i++)
                yyout->put(char(buf[i]));

        (void) yyout->put('\n');
        */
        }


#ifdef DEBUG
void YYLEXER::LexerTrace(const YY_CHAR* buf, int size, int tknNum)
        {
        if (tkndebug > 0)
                {
                cout << ">> Lexing Token : ";
                for (int i=0; i<size; i++)
                        cout << char(buf[i]);
                cout << " (" << tknNum << ")"<< endl;
                }
        }
#endif


void YYLEXER::ResetLexer()
        {
        yy_init = 1;
        yy_start = 0;
#ifdef DEBUG
        tkndebug = getenv("TKNTRACE") ? 1 : 0;
#endif
        }

int YYLEXER::yybufferinput(YY_CHAR *pszBuffer, int cMax)
        {
        int n = min(cMax, cInputBuffer - (int) (pCurBuffer - pszInputBuffer));

        if (n > 0)
                {
                memcpy(pszBuffer, pCurBuffer, n * sizeof(TCHAR));
                pCurBuffer += n;
                }
        return n;
        }

void YYLEXER::yyprimebuffer(YY_CHAR *pszBuffer)
        {
//      if (NULL != pszInputBuffer)
//              CoTaskMemFree(pszInputBuffer);

//      pszInputBuffer = pCurBuffer = strdup(pszBuffer);
        pszInputBuffer = pCurBuffer = pszBuffer;
        cInputBuffer = strlen(pszInputBuffer);

        ResetLexer();
        }

void YYLEXER::yyprimelexer(int eToken)
        {
        yyprimetoken = eToken;
        }

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */

int YYLEXER::yy_get_next_buffer()
        {
        register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
        register YY_CHAR *source = yytext_ptr;
        register int number_to_move, i;
        int ret_val;

        if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
                /* YY_FATAL_ERROR(L"fatal flex scanner internal error--end of buffer missed" ); */
                throw(E_FAIL);

        if ( yy_current_buffer->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                yy_current_buffer->yy_n_chars = yy_n_chars = 0;

        else
                {
                int num_to_read =
                        yy_current_buffer->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
                        /*YY_FATAL_ERROR(L"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );*/
                        throw(E_OUTOFMEMORY);
#else

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = yy_current_buffer;

                        int yy_c_buf_p_offset =
                                (int) (yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (YY_CHAR *)
                                        /* Include room in for 2 EOB chars. */
                                        yy_flex_realloc( (void *) b->yy_ch_buf,
                                                         b->yy_buf_size + 2 );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                /*YY_FATAL_ERROR(L"fatal error - scanner input buffer overflow");*/
                                throw(E_FAIL);

                        yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = yy_current_buffer->yy_buf_size -
                                                number_to_move - 1;
#endif
                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
                        yy_n_chars, num_to_read );

                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        if ( yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        yyrestart( );
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        yy_current_buffer->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        yy_n_chars += number_to_move;
        yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

        return ret_val;
        }


/* yy_get_previous_state - get the state just before the EOB YY_CHAR was reached */

yy_state_type YYLEXER::yy_get_previous_state()
        {
        register yy_state_type yy_current_state;
        register YY_CHAR *yy_cp;

	yy_current_state = yy_start;

        for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
                {
		register YY_CHAR yy_c = 1; if (0!= *yy_cp && 256 > *yy_cp) yy_c = (YY_CHAR) yy_ec[YY_SC_TO_UI(*yy_cp)];
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 406 )
				yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
        }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */

yy_state_type YYLEXER::yy_try_NUL_trans( yy_state_type yy_current_state )
        {
        register int yy_is_jam;
	register YY_CHAR *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 406 )
			yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 405);

        return yy_is_jam ? 0 : yy_current_state;
        }


void YYLEXER::yyunput( int c, register YY_CHAR* yy_bp )
        {
        register YY_CHAR *yy_cp = yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yy_hold_char;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                { /* need to shift things up to make room */
                /* +2 for EOB chars. */
                register int number_to_move = yy_n_chars + 2;
                register YY_CHAR *dest = &yy_current_buffer->yy_ch_buf[
                                        yy_current_buffer->yy_buf_size + 2];
                register YY_CHAR *source =
                                &yy_current_buffer->yy_ch_buf[number_to_move];

                while ( source > yy_current_buffer->yy_ch_buf )
                        *--dest = *--source;

                yy_cp += (int) (dest - source);
                yy_bp += (int) (dest - source);
                yy_current_buffer->yy_n_chars =
                        yy_n_chars = yy_current_buffer->yy_buf_size;

                if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
                        /*YY_FATAL_ERROR( L"flex scanner push-back overflow" );*/
                        throw(E_FAIL);
                }

        *--yy_cp = (YY_CHAR) c;


        yytext_ptr = yy_bp;
        yy_hold_char = *yy_cp;
        yy_c_buf_p = yy_cp;
        }


int YYLEXER::yyinput()
        {
        int c;

        *yy_c_buf_p = yy_hold_char;

        if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
                {
                /* yy_c_buf_p now points to the character we want to return.
                 * If this occurs *before* the EOB characters, then it's a
                 * valid NUL; if not, then we've hit the end of the buffer.
                 */
                if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                        /* This was really a NUL. */
                        *yy_c_buf_p = '\0';

                else
                        { /* need more input */
                        int offset = (int)(yy_c_buf_p - yytext_ptr);
                        ++yy_c_buf_p;

                        switch ( yy_get_next_buffer() )
                                {
                                case EOB_ACT_LAST_MATCH:
                                        /* This happens because yy_g_n_b()
                                         * sees that we've accumulated a
                                         * token and flags that we need to
                                         * try matching the token before
                                         * proceeding.  But for input(),
                                         * there's no matching to consider.
                                         * So convert the EOB_ACT_LAST_MATCH
                                         * to EOB_ACT_END_OF_FILE.
                                         */

                                        /* Reset buffer status. */
                                        yyrestart( );

                                        /* fall through */

                                case EOB_ACT_END_OF_FILE:
                                        {
                                        if ( yyywrap() )
                                                return EOF;

                                        if ( ! yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
#ifdef __cplusplus
                                        return yyinput();
#else
                                        return input();
#endif
                                        }

                                case EOB_ACT_CONTINUE_SCAN:
                                        yy_c_buf_p = yytext_ptr + offset;
                                        break;
                                }
                        }
                }

        c = *(YY_CHAR *) yy_c_buf_p;    /* cast for 8-bit YY_CHAR's */
        *yy_c_buf_p = '\0';     /* preserve yytext */
        yy_hold_char = *++yy_c_buf_p;


        return c;
        }


void YYLEXER::yyrestart( )
        {
        if ( ! yy_current_buffer )
                yy_current_buffer = yy_create_buffer( (cInputBuffer * sizeof(YY_CHAR)) + sizeof(YY_CHAR) );

        yy_init_buffer( yy_current_buffer );
        yy_load_buffer_state();
        }


void YYLEXER::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
        {
        if ( yy_current_buffer == new_buffer )
                return;

        if ( yy_current_buffer )
                {
                /* Flush out information for old buffer. */
                *yy_c_buf_p = yy_hold_char;
                yy_current_buffer->yy_buf_pos = yy_c_buf_p;
                yy_current_buffer->yy_n_chars = yy_n_chars;
                }

        yy_current_buffer = new_buffer;
        yy_load_buffer_state();

        /* We don't actually know whether we did this switch during
         * EOF (yyywrap()) processing, but the only time this flag
         * is looked at is after yyywrap() is called, so it's safe
         * to go ahead and always set it.
         */
        yy_did_buffer_switch_on_eof = 1;
        }


void YYLEXER::yy_load_buffer_state()
        {
        yy_n_chars = yy_current_buffer->yy_n_chars;
        yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
        yy_hold_char = *yy_c_buf_p;
        }


YY_BUFFER_STATE YYLEXER::yy_create_buffer( int size )
        {
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
        if ( ! b )
                /*YY_FATAL_ERROR( L"out of dynamic memory in yy_create_buffer()" );*/
                throw(E_OUTOFMEMORY);

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (YY_CHAR *) yy_flex_alloc( b->yy_buf_size + 2 );
        if ( ! b->yy_ch_buf )
                /*YY_FATAL_ERROR( L"out of dynamic memory in yy_create_buffer()" );*/
                throw(E_OUTOFMEMORY);

        b->yy_is_our_buffer = 1;

        yy_init_buffer( b );

        return b;
        }


void YYLEXER::yy_delete_buffer( YY_BUFFER_STATE b )
        {
        if ( ! b )
                return;

        if ( b == yy_current_buffer )
                yy_current_buffer = (YY_BUFFER_STATE) 0;

        if ( b->yy_is_our_buffer )
                yy_flex_free( (void *) b->yy_ch_buf );

        yy_flex_free( (void *) b );
        }


extern "C" int isatty YY_PROTO(( int ));
void YYLEXER::yy_init_buffer( YY_BUFFER_STATE b )

        {
        yy_flush_buffer( b );

        b->yy_fill_buffer = 1;

        b->yy_is_interactive = 0;
        }


void YYLEXER::yy_flush_buffer( YY_BUFFER_STATE b )
        {
        if ( ! b )
                return;

        b->yy_n_chars = 0;

        /* We always need two end-of-buffer characters.  The first causes
         * a transition to the end-of-buffer state.  The second causes
         * a jam in that state.
         */
        b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
        b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

        b->yy_buf_pos = &b->yy_ch_buf[0];

        b->yy_at_bol = 1;
        b->yy_buffer_status = YY_BUFFER_NEW;

        if ( b == yy_current_buffer )
                yy_load_buffer_state();
        }


#ifndef YY_NO_SCAN_BUFFER
#endif


#ifndef YY_NO_SCAN_STRING
#endif


#ifndef YY_NO_SCAN_BYTES
#endif


#ifndef YY_NO_PUSH_STATE
void YYLEXER::yy_push_state( int new_state )
        {
        if ( yy_start_stack_ptr >= yy_start_stack_depth )
                {
                yy_size_t new_size;

                yy_start_stack_depth += YY_START_STACK_INCR;
                new_size = yy_start_stack_depth * sizeof( int );

                if ( ! yy_start_stack )
                        yy_start_stack = (int *) yy_flex_alloc( new_size );

                else
                        yy_start_stack = (int *) yy_flex_realloc(
                                        (void *) yy_start_stack, new_size );

                if ( ! yy_start_stack )
                        /*YY_FATAL_ERROR(L"out of memory expanding start-condition stack" );*/
                        throw(E_OUTOFMEMORY);
                }

        yy_start_stack[yy_start_stack_ptr++] = YY_START;

        BEGIN(new_state);
        }
#endif


#ifndef YY_NO_POP_STATE
void YYLEXER::yy_pop_state()
        {
        if ( --yy_start_stack_ptr < 0 )
                /*YY_FATAL_ERROR( L"start-condition stack underflow" );*/
                throw(E_FAIL);

        BEGIN(yy_start_stack[yy_start_stack_ptr]);
        }
#endif


#ifndef YY_NO_TOP_STATE
int YYLEXER::yy_top_state()
        {
        return yy_start_stack[yy_start_stack_ptr - 1];
        }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif


void YYLEXER::LexerError( yyconst YY_CHAR msg[] )
        {
/* ******************************** Don't really want to do this ************************************
        // UNDONE:  3/28/97  This needs to pass the error message back to yacc (or
        //                      store it in the error area itself!
        for (unsigned int i=0; i<wcslen(msg); i++)
                cerr << char(msg[i]);
        cerr << endl;
        exit( YY_EXIT_FAILURE );
   ******************************** Don't really want to do this ************************************ */
        }


/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
                yytext[yyleng] = yy_hold_char; \
                yy_c_buf_p = yytext + n; \
                yy_hold_char = *yy_c_buf_p; \
                *yy_c_buf_p = '\0'; \
                yyleng = n; \
                } \
        while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( YY_CHAR *s1, yyconst YY_CHAR *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
YY_CHAR *s1;
yyconst YY_CHAR *s2;
int n;
#endif
        {
        register int i;
        for ( i = 0; i < n; ++i )
                s1[i] = s2[i];
        }
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst YY_CHAR *s )
#else
static int yy_flex_strlen( s )
yyconst YY_CHAR *s;
#endif
        {
        register int n;
        for ( n = 0; s[n]; ++n )
                ;

        return n;
        }
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
        {
        return (void *) malloc( size );
        }

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
        {
        /* The cast to (YY_CHAR *) in the following accommodates both
         * implementations that use YY_CHAR* generic pointers, and those
         * that use void* generic pointers.  It works with the latter
         * because both ANSI C and C++ allow castless assignment from
         * any pointer type to void*, and deal with argument conversions
         * as though doing an assignment.
         */
        return (void *) realloc( (YY_CHAR *) ptr, size );
        }

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
        {
        free( ptr );
        }


#if YY_MAIN
int main()
        {
        yylex();
        return 0;
        }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\mssqltab.h ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar     1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define _OR 257
#define _AND 258
#define _NOT 259
#define _UMINUS 260
#define mHighest 261
#define _ALL 262
#define _ANY 263
#define _ARRAY 264
#define _AS 265
#define _ASC 266
#define _CAST 267
#define _COERCE 268
#define _CONTAINS 269
#define _CONTENTS 270
#define _CREATE 271
#define _DEEP_TRAVERSAL 272
#define _DESC 273
#define _DOT 274
#define _DOTDOT 275
#define _DOTDOT_SCOPE 276
#define _DOTDOTDOT 277
#define _DOTDOTDOT_SCOPE 278
#define _DROP 279
#define _EXCLUDE_SEARCH_TRAVERSAL 280
#define _FALSE 281
#define _FREETEXT 282
#define _FROM 283
#define _IS 284
#define _ISABOUT 285
#define _IS_NOT 286
#define _LIKE 287
#define _MATCHES 288
#define _NEAR 289
#define _NOT_LIKE 290
#define _NULL 291
#define _OF 292
#define _ORDER_BY 293
#define _PASSTHROUGH 294
#define _PROPERTYNAME 295
#define _PROPID 296
#define _RANKMETHOD 297
#define _SELECT 298
#define _SET 299
#define _SCOPE 300
#define _SHALLOW_TRAVERSAL 301
#define _FORMSOF 302
#define _SOME 303
#define _TABLE 304
#define _TRUE 305
#define _TYPE 306
#define _UNION 307
#define _UNKNOWN 308
#define _URL 309
#define _VIEW 310
#define _WHERE 311
#define _WEIGHT 312
#define _GE 313
#define _LE 314
#define _NE 315
#define _CONST 316
#define _ID 317
#define _TEMPVIEW 318
#define _INTNUM 319
#define _REALNUM 320
#define _SCALAR_FUNCTION_REF 321
#define _STRING 322
#define _DATE 323
#define _PREFIX_STRING 324
#define _DELIMITED_ID 325
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
#define INITSTACKSIZE 30
class YYPARSER : public CYYBase
{
    friend class YYLEXER;
public:

    YYPARSER(CImpIParserSession* pParserSession, CImpIParserTreeProperties* pParserTreeProperties, YYLEXER & yylex);

    ~YYPARSER() {}

    void ResetParser();             // Use to possibly restart parser
    int  Parse();

#ifdef YYAPI_VALUETYPE
    YYAPI_VALUETYPE GetParseTree()      // Get result of parse
                    {
                        return yyval;
                    }
#endif

    void EmptyValueStack( YYAPI_VALUETYPE yylval );
    void PopVs();

private:

    int yydebug;
    int yynerrs;
    int yyerrflag;
    int yychar;
    short *yyssp;
    YYSTYPE *yyvsp;
    YYSTYPE yyval;
    YYSTYPE yylval;
    XGrowable<short, INITSTACKSIZE> xyyss;
    CDynArrayInPlace<YYSTYPE> xyyvs;
};
#define yystacksize YYSTACKSIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\treeutil.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module treeutil.h | 
// 
// Contains prototypes for tree manipulation utility functions for OLE-DB trees.
//
//
// @rev   0 | 04-Feb-97 | v-charca  | Created
//
#ifdef DEBUG
#include <iostream.h>
#endif

// Change a variant to from BSTR to I8 or UI8
HRESULT PropVariantChangeTypeI64(PROPVARIANT* pvarValue);

////////// OLE-DB tree manipulation prototypes /////////////
//Allocate a tree of given kind and type.
DBCOMMANDTREE * PctAllocNode(DBVALUEKIND wKind,DBCOMMANDOP op = DBOP_DEFAULT);

// Make a list of dbcommandtree nodes
//--------------------------------------------------------------------
// @func Links two DBCOMMANDTREEs together.
//
// @rdesc (inline) DBCOMMANDTREE *
//
_inline DBCOMMANDTREE * PctLink
    (
    DBCOMMANDTREE *pct1,                // @parm IN | 1st node in list
    DBCOMMANDTREE *pct2                 // @parm IN | 2nd node in list
    )
    {
    Assert(pct1 != NULL && pct2 != NULL);
    DBCOMMANDTREE* pct = pct1;
    
    while(pct->pctNextSibling != NULL) 
        pct = pct->pctNextSibling;
    pct->pctNextSibling = pct2;

    return pct1;
    }


DBCOMMANDTREE * PctCreateNode(DBCOMMANDOP op, DBVALUEKIND wKind, DBCOMMANDTREE * pctxpr, ...);
DBCOMMANDTREE * PctCreateNode(DBCOMMANDOP op, DBCOMMANDTREE * pctxpr, ...);
DBCOMMANDTREE * PctReverse(DBCOMMANDTREE * pct);

// Count the number of siblings of a node
UINT GetNumberOfSiblings(DBCOMMANDTREE *pct);

// Delete tree
void DeleteDBQT(DBCOMMANDTREE * pct);

// Copy a tree.
HRESULT HrQeTreeCopy(DBCOMMANDTREE **pctDest, const DBCOMMANDTREE *pctSrc);

void SetDepthAndInclusion( DBCOMMANDTREE* pctInfo, DBCOMMANDTREE * pctScpList );

// Defined in querylib.lib
BOOL ParseGuid( WCHAR* pwszGuid, GUID & guid );

#ifdef DEBUG
// Print a wide character string
ostream& operator <<(ostream &osOut, LPWSTR pwszName);
// Print given tree
ostream& operator <<(ostream &osOut, DBCOMMANDTREE& qe);
ostream& operator <<(ostream &osOut, GUID guid);
ostream& operator <<(ostream &osOut, DBID __RPC_FAR *pdbid);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\yybase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       YYBase.cxx
//
//  Contents:   Custom base class for YYPARSER
//
//  History:    30-Nov-1999   KyleP       Created
//
//----------------------------------------------------------------------------

#pragma hdrstop

#include "msidxtr.h"
#include "yybase.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::CYYBase, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pParserSession]        -- Session state
//              [pParserTreeProperties] -- Command properties
//              [yylex]                 -- Lexer
//
//  History:    30-Nov-1999   KyleP       Created
//
//--------------------------------------------------------------------------

CYYBase::CYYBase( CImpIParserSession* pParserSession,
                  CImpIParserTreeProperties* pParserTreeProperties,
                  YYLEXER & yylex )
        : m_yylex( yylex ),
          m_pIPSession( pParserSession ),
          m_pIPTProperties( pParserTreeProperties )
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::~CYYBase, public
//
//  Synopsis:   Destructor
//
//  History:    30-Nov-1999   KyleP       Created
//
//--------------------------------------------------------------------------

CYYBase::~CYYBase()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::CoerceScalar, public
//
//  Synopsis:   Converts a scalar node to specified type.
//
//  Arguments:  [dbTypeExpected] -- Expected type
//              [ppct]           -- Node to convert
//
//  Returns:    Error if conversion not possible
//
//  History:    30-Nov-1999   KyleP       Moved from YYPARSER
//
//--------------------------------------------------------------------------

HRESULT CYYBase::CoerceScalar(
    DBTYPE                  dbTypeExpected,         // @parm IN | DBTYPE that is expected in current context
    DBCOMMANDTREE**         ppct )                    // @parm IN/OUT | scalar node
{
    Assert( VT_I8       == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_UI8      == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_R8       == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_BSTR     == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_BOOL     == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_FILETIME == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt );

    DBTYPE dbType = dbTypeExpected & ~DBTYPE_VECTOR;

    if (DBTYPE_STR == (dbType & ~DBTYPE_BYREF))
        dbType = VT_LPSTR;
    if (DBTYPE_WSTR == (dbType & ~DBTYPE_BYREF))
        dbType = VT_LPWSTR;

    HRESULT hr = (*ppct)->hrError;
    if (S_OK != hr)
        goto error;
    if (dbType == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt)
        return hr;

    switch ( ((PROPVARIANT*)(*ppct)->value.pvValue)->vt )
    {
    case VT_UI8:
       {
            ULONGLONG uhVal = ((PROPVARIANT*)(*ppct)->value.pvValue)->uhVal.QuadPart;
            switch ( dbType )
            {
            case VT_UI1:
                if (uhVal > UCHAR_MAX)
                    hr = DISP_E_TYPEMISMATCH;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->bVal = (UCHAR)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_UI1;
                }
                break;

            case VT_I1:
                if (uhVal > CHAR_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->cVal = (CHAR)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I1;
                }
                break;

            case VT_UI2:
                if (uhVal > USHRT_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->uiVal = (USHORT)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt    = VT_UI2;
                }
                break;

            case VT_I2:
                if (uhVal > SHRT_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->iVal = (SHORT)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I2;
                }
                break;

            case VT_UI4:
                if (uhVal > ULONG_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->ulVal = (ULONG)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt    = VT_UI4;
                }
                break;

            case VT_I4:
                if (uhVal > LONG_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->lVal = (LONG)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I4;
                }
                break;

            case VT_I8:
                if (uhVal > _I64_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->hVal.QuadPart = (LONGLONG)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt            = VT_I8;
                }
                break;

            case VT_R4:
                ((PROPVARIANT*)(*ppct)->value.pvValue)->fltVal = (float)(LONGLONG)uhVal;
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R4;
                break;

            case VT_R8:
                ((PROPVARIANT*)(*ppct)->value.pvValue)->dblVal = (double)(LONGLONG)uhVal;
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R8;
                break;

            default:
                hr = DB_E_CANTCONVERTVALUE;
            }
        }
        break;

    case VT_I8:
        {
            LONGLONG hVal = ((PROPVARIANT*)(*ppct)->value.pvValue)->hVal.QuadPart;
            switch ( dbType )
            {
            case VT_UI1:
            case VT_UI2:
            case VT_UI4:
            case VT_UI8:
                hr = DB_E_CANTCONVERTVALUE;
                break;

            case VT_I1:
                if (hVal < CHAR_MIN || hVal > CHAR_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->cVal = (CHAR)hVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I1;
                }
                break;

            case VT_I2:
                if (hVal < SHRT_MIN || hVal > SHRT_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->iVal = (SHORT)hVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I2;
                }
                break;

            case VT_I4:
                if (hVal < LONG_MIN || hVal > LONG_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->lVal = (LONG)hVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I4;
                }
                break;

            case VT_R4:
                ((PROPVARIANT*)(*ppct)->value.pvValue)->fltVal = (float)hVal;
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R4;
                break;

            case VT_R8:
                ((PROPVARIANT*)(*ppct)->value.pvValue)->dblVal = (double)hVal;
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R8;
                break;

            default:
                hr = DB_E_CANTCONVERTVALUE;
            }
        }
        break;

    case VT_R8:
        switch ( dbType )
        {
        case VT_R4:
            ((PROPVARIANT*)(*ppct)->value.pvValue)->fltVal =
                (float)((PROPVARIANT*)(*ppct)->value.pvValue)->dblVal;
            ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R4;
            break;

        case VT_CY:
            hr = VariantChangeTypeEx( (*ppct)->value.pvarValue,  // convert in place
                                      (*ppct)->value.pvarValue,
                                      LOCALE_SYSTEM_DEFAULT,
                                      0,
                                      VT_CY );
            break;

        default:
            hr = DB_E_CANTCONVERTVALUE;
        }
        break;

    case VT_BSTR:
        switch ( dbType )
        {
        case VT_R8:
            //
            // Our syntax doesn't allow for numeric separators in other
            // locales than US English.  So, use the English US lcid for this
            // conversion.
            //
            hr = VariantChangeTypeEx((*ppct)->value.pvarValue,  // convert in place
                                (*ppct)->value.pvarValue,
                                MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                                   SORT_DEFAULT),
                                0,
                                VT_R8);
            break;

        case VT_LPSTR:
            {
                int cLen = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal,
                        SysStringLen(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal), // number of characters in string
                        NULL,       // address of buffer for new string
                        0,          // size of buffer
                        NULL,       // address of default for unmappable characters
                        NULL);      // address of flag set when default char. used

                LPSTR pszVal = (LPSTR) CoTaskMemAlloc(cLen+1);
                if (NULL == pszVal)
                    hr = E_OUTOFMEMORY;
                else
                {
                    cLen =  WideCharToMultiByte(
                            CP_ACP,
                            0,
                            ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal,
                            SysStringLen(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal), // number of characters in string
                            pszVal,     // address of buffer for new string
                            cLen+1,     // size of buffer
                            NULL,       // address of default for unmappable characters
                            NULL);      // address of flag set when default char. used
                    SysFreeString(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);
                    pszVal[cLen] = '\0';
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_LPSTR;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->pszVal = pszVal;
                }
            }
            break;

        case VT_LPWSTR:
            {
                LPWSTR pwszVal = CoTaskStrDup(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);
                if (NULL == pwszVal)
                    hr = E_OUTOFMEMORY;
                else
                {
                    SysFreeString(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_LPWSTR;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->pwszVal = pwszVal;
                }
            }
            break;

        case VT_CLSID:
            {
                GUID* pGuid = (GUID*) CoTaskMemAlloc(sizeof GUID);
                if (NULL == pGuid)
                    hr = E_OUTOFMEMORY;
                else
                {
                    BOOL bRet = ParseGuid(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal, *pGuid);
                    if ( bRet && GUID_NULL != *pGuid )
                    {
                        SysFreeString(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);
                        ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_CLSID;
                        ((PROPVARIANT*)(*ppct)->value.pvValue)->puuid = pGuid;
                    }
                    else
                    {
                        CoTaskMemFree(pGuid);
                        hr = DB_E_CANTCONVERTVALUE;
                    }
                }
            }
            break;

        case VT_FILETIME:
        case VT_DATE:
            {
                SYSTEMTIME stValue = {0, 0, 0, 0, 0, 0, 0, 0};
                // convert a string to a filetime value
                int cItems = swscanf(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal,
                                    L"%4hd/%2hd/%2hd %2hd:%2hd:%2hd:%3hd",
                                    &stValue.wYear,
                                    &stValue.wMonth,
                                    &stValue.wDay,
                                    &stValue.wHour,
                                    &stValue.wMinute,
                                    &stValue.wSecond,
                                    &stValue.wMilliseconds);

                if (1 == cItems)
                    cItems = swscanf(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal,
                                    L"%4hd-%2hd-%2hd %2hd:%2hd:%2hd:%3hd",
                                    &stValue.wYear,
                                    &stValue.wMonth,
                                    &stValue.wDay,
                                    &stValue.wHour,
                                    &stValue.wMinute,
                                    &stValue.wSecond,
                                    &stValue.wMilliseconds );

                if (cItems != 3 && cItems != 6 && cItems != 7)
                    hr = E_FAIL;

                //
                // Make a sensible split for Year 2000 using the user's system settings
                //

                if ( stValue.wYear < 100 )
                {
                    DWORD dwYearHigh = 0;
                    if ( 0 == GetCalendarInfo ( m_pIPSession->GetLCID(),
                                                CAL_GREGORIAN,
                                                CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                                                0,
                                                0,
                                                &dwYearHigh ) )
                    {
                        hr = HRESULT_FROM_WIN32 ( GetLastError() );
                    }

                    if ( ( dwYearHigh < 99 ) || ( dwYearHigh > 9999 ) )
                        dwYearHigh = 2029;

                    WORD wMaxDecade = (WORD) dwYearHigh % 100;
                    WORD wMaxCentury = (WORD) dwYearHigh - wMaxDecade;
                    if ( stValue.wYear <= wMaxDecade )
                        stValue.wYear += wMaxCentury;
                    else
                        stValue.wYear += ( wMaxCentury - 100 );
                }

                SysFreeString(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);

                int iResult = 0;
                if (VT_FILETIME == dbType)
                    iResult = SystemTimeToFileTime(&stValue, &((PROPVARIANT*)(*ppct)->value.pvValue)->filetime);
                else
                    iResult = SystemTimeToVariantTime(&stValue, &((PROPVARIANT*)(*ppct)->value.pvValue)->date);
                if (0 == iResult)
                {
                    // SystemTimeTo* conversion failed. Most likely we were given the date in a bogus format.
                    (*ppct)->hrError = DB_E_CANTCONVERTVALUE;
                    hr = DB_E_CANTCONVERTVALUE;
                }
                else
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = dbType;
            }
            break;

        default:
            hr = DB_E_CANTCONVERTVALUE;
        }
        break;

    case VT_FILETIME:
        switch ( dbType )
        {
        case VT_DATE:
            {
                SYSTEMTIME stValue = {0, 0, 0, 0, 0, 0, 0, 0};
                if ( FileTimeToSystemTime(&((PROPVARIANT*)(*ppct)->value.pvValue)->filetime, &stValue) )
                {
                    int iResult = SystemTimeToVariantTime(&stValue, &((PROPVARIANT*)(*ppct)->value.pvValue)->date);
                    if (0 == iResult)
                    {
                        // SystemTimeToVariantTime failed. Most likely we were given the date in a bogus format.
                        (*ppct)->hrError = DB_E_CANTCONVERTVALUE;
                        hr = DB_E_CANTCONVERTVALUE;
                    }
                    else
                        ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_DATE;
                }
                else
                    hr = DISP_E_TYPEMISMATCH;
            }
            break;

        default:
            hr = DB_E_CANTCONVERTVALUE;
        }
        break;

    default:
        hr = DB_E_CANTCONVERTVALUE;
        break;
    }

error:
    if (S_OK != hr)
    {
        switch ( hr )
        {
        case DB_E_DATAOVERFLOW:
            m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_RANGE);
            break;

        case E_OUTOFMEMORY:
            m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
            break;

        default:
            m_pIPTProperties->SetErrorHResult(hr, MONSQL_CANNOT_CONVERT);
        }

        m_pIPTProperties->SetErrorToken((YY_CHAR*)m_yylex.YYText());

        switch ( dbType )
        {
        case DBTYPE_UI1:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_UI1");
            break;

        case DBTYPE_I1:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_I1");
            break;

        case DBTYPE_UI2:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_UI2");
            break;

        case DBTYPE_UI4:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_UI4");
            break;

        case DBTYPE_UI8:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_UI8");
            break;

        case DBTYPE_I2:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_I2");
            break;

        case DBTYPE_I4:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_I4");
            break;

        case DBTYPE_I8:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_I8");
            break;

        case DBTYPE_R4:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_R4");
            break;

        case DBTYPE_R8:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_R8");
            break;

        case DBTYPE_CY:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_CY");
            break;

        case DBTYPE_DATE:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_DATE");
            break;

        case DBTYPE_BSTR:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_BSTR");
            break;

        case DBTYPE_BOOL:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_BOOL");
            break;

        case DBTYPE_GUID:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_GUID");
            break;

        case DBTYPE_STR:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_STR");
            break;

        case DBTYPE_STR | DBTYPE_BYREF:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_STR|DBTYPE_BYREF");
            break;

        case DBTYPE_WSTR:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_WSTR");
            break;

        case DBTYPE_WSTR | DBTYPE_BYREF:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_WSTR | DBTYPE_BYREF");
            break;

        case VT_FILETIME:
            m_pIPTProperties->SetErrorToken(L"VT_FILETIME");
            break;

        default:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_NULL");
            break;
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::yyprimebuffer, public
//
//  Synopsis:   Prime lexer with text (passthrough to lexer)
//
//  Arguments:  [pszBuffer] -- Buffer
//
//  History:    30-Nov-1999   KyleP       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CYYBase::yyprimebuffer(YY_CHAR *pszBuffer)
{
    m_yylex.yyprimebuffer(pszBuffer);
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::yyprimelexer, public
//
//  Synopsis:   Prime lexer with initial token (passthrough to lexer)
//
//  Arguments:  [eToken] -- Token
//
//  History:    30-Nov-1999   KyleP       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CYYBase::yyprimelexer(int eToken)
{
    m_yylex.yyprimelexer(eToken);
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::yyerror, protected
//
//  Synopsis:   Report parsing errors
//
//  Arguments:  [szError] -- Error string
//
//  History:    30-Nov-1999   KyleP       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CYYBase::yyerror( char const * szError )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\ptprops.cpp ===
//----------------------------------------------------------------------------
// Microsoft OLE DB Implementation For Index Server
// (C) Copyright 1997 By Microsoft Corporation.
//
// @doc
//
// @module PTPROPS.CPP | 
//
// @rev 1 | 10-13-97 | Briants  | Created
//

// Includes ------------------------------------------------------------------
#pragma hdrstop
#include "msidxtr.h"

// Constants and Static Struct -----------------------------------------------
#define CALC_CCH_MINUS_NULL(p1) (sizeof(p1) / sizeof(*(p1))) - 1

// Code ----------------------------------------------------------------------
// CScopeData::CScopeData ---------------------------------------------------
//
// @mfunc Constructor
//
CScopeData::CScopeData()
{
    m_cRef              = 1;
    m_cScope            = 0;
    m_cMaxScope         = 0;

    m_cbData            = 0;
    m_cbMaxData         = 0;

    m_rgbData           = NULL;
    m_rgulDepths        = NULL;
    m_rgCatalogOffset   = NULL;
    m_rgScopeOffset     = NULL;
    m_rgMachineOffset   = NULL;
}


// CScopeData::~CScopeData ---------------------------------------------------
//
// @mfunc Destructor
//
CScopeData::~CScopeData()
{
    delete m_rgulDepths;
    delete m_rgCatalogOffset;
    delete m_rgScopeOffset;
    delete m_rgMachineOffset;
    delete m_rgbData;
}

// CScopeData::Reset ---------------------------------------------------------
//
// @mfunc Reset the scope count and offsets back to initial state.
//
// @rdesc HRESULT | status of methods success / failure
//      @flags OTHER | from called methods
//
HRESULT CScopeData::Reset(void)
{
    
    // Reset the offsets to unused
    for (ULONG i = 0; i<m_cMaxScope; i++)
    {
        m_rgScopeOffset[i] = UNUSED_OFFSET;
        m_rgCatalogOffset[i] = UNUSED_OFFSET;
        m_rgMachineOffset[i] = UNUSED_OFFSET;
    }

    // Set Scope Index Back to 0
    m_cScope = 0;
    
    return S_OK;
}

// CScopeData::FInit ---------------------------------------------------------
//
// @mfunc Initialize the Constructed Object
//
// @rdesc HRESULT | status of methods success / failure
//      @flags OTHER | from called methods
//
HRESULT CScopeData::FInit
    (
    LPCWSTR pwszMachine     // @param IN | current default machine
    )
{
    HRESULT hr;
    
    // Allocate Scope buffers
    // @devnote: IncrementScopeCount() has special logic for the first 
    // allocation, thus the m_cScope will remain 0 after this call
    if( SUCCEEDED(hr = IncrementScopeCount()) )
    {
        assert( m_cScope == 0 );

        // Initialize the machine 
        hr = SetTemporaryMachine((LPWSTR)pwszMachine, wcslen( pwszMachine ) );
    }

    return hr;
}


// CScopeData::AddRef ------------------------------------------
//
// @mfunc Increments a persistence count for the object
//
// @rdesc Current reference count
//
ULONG CScopeData::AddRef (void)
{
    return InterlockedIncrement( (long*) &m_cRef);
}


// CScopeData::Release -----------------------------------------
//
// @mfunc Decrements a persistence count for the object and if
// persistence count is 0, the object destroys itself.
//
// @rdesc Current reference count
//
ULONG CScopeData::Release (void)
{
    assert( m_cRef > 0 );

    ULONG cRef = InterlockedDecrement( (long *) &m_cRef );
    if( 0 == cRef )
    {
        delete this;
        return 0;
    }

    return cRef;
}


// CScopeData::GetData -------------------------------------------------------
//
// @mfunc Copies the current value of our scope data into the passed in 
//  variant
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK | retrieved the scope data
//      @flags E_INVALIDARG | Unknown PropId requested
//      @flags OTHER | from called methods
//
HRESULT CScopeData::GetData(
    ULONG       uPropId,    //@parm IN | id of scope data to return
    VARIANT*    pvValue,        //@parm INOUT | Variant to return data in
    LPCWSTR     pcwszCatalog
    )
{
    assert( pvValue );

    HRESULT         hr;
    ULONG           ul;
    SAFEARRAYBOUND  rgsabound[1];   
    SAFEARRAY FAR*  psa = NULL;
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = m_cScope;

    // Make sure that we free any memory that may be held by the variant.
    VariantClear(pvValue);

    switch( uPropId )
    {
        LONG    rgIx[1];
    
        case PTPROPS_SCOPE:
        {
            // Create a 1 dim safe array of type BSTR
            psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
            if( psa )
            {
                for(ul=0; ul<m_cScope; ul++)
                {
                    rgIx[0] = ul;
                    BSTR    bstrVal = SysAllocString((LPWSTR)(m_rgbData + m_rgScopeOffset[ul]));
                    if( bstrVal )
                    {
                        hr = SafeArrayPutElement(psa, rgIx, bstrVal);
                        SysFreeString(bstrVal);
                        if( FAILED(hr) )
                            goto error_delete;
                    }
                    else
                    {
                        hr = ResultFromScode(E_OUTOFMEMORY);
                        goto error_delete;
                    }
                }
                V_VT(pvValue) = VT_BSTR | VT_ARRAY;
                V_ARRAY(pvValue) = psa;
                psa = NULL;
            }
            else
                return ResultFromScode(E_OUTOFMEMORY);
        }
            break;
        case PTPROPS_DEPTH:
        {
            // Create a 1 dim safe array of type I4
            psa = SafeArrayCreate(VT_I4, 1, rgsabound);
            if( psa )
            {
                for(ul=0; ul<m_cScope; ul++)
                {
                    rgIx[0] = ul;

                    hr = SafeArrayPutElement(psa, rgIx, (void*)&m_rgulDepths[ul]);
                    if( FAILED(hr) )
                        goto error_delete;
                }
                V_VT(pvValue) = VT_I4 | VT_ARRAY;
                V_ARRAY(pvValue) = psa;
                psa = NULL;
            }
            else
                return ResultFromScode(E_OUTOFMEMORY);
        }
            break;
        case PTPROPS_CATALOG:
        {
            assert( pcwszCatalog );
            // Create a 1 dim safe array of type BSTR
            psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
            if( psa )
            {
                for(ul=0; ul<m_cScope; ul++)
                {
                    rgIx[0] = ul;
                    BSTR    bstrVal;
                    // Check to see if the catalog value has been cached, if not
                    // 
                    if( m_rgCatalogOffset[ul] != UNUSED_OFFSET )
                    {
                        bstrVal = SysAllocString((LPWSTR)(m_rgbData + m_rgCatalogOffset[ul]));
                    }
                    else
                    {
                        bstrVal = SysAllocString(pcwszCatalog);
                    }
                    
                    if( bstrVal )
                    {
                        hr = SafeArrayPutElement(psa, rgIx, bstrVal);
                        SysFreeString(bstrVal);
                        if( FAILED(hr) )
                            goto error_delete;
                    }
                    else
                    {
                        hr = ResultFromScode(E_OUTOFMEMORY);
                        goto error_delete;
                    }
                }
                V_VT(pvValue) = VT_BSTR | VT_ARRAY;
                V_ARRAY(pvValue) = psa;
                psa = NULL;
            }
            else
                return ResultFromScode(E_OUTOFMEMORY);
        }
            break;
        case PTPROPS_MACHINE:
        {
            // Create a 1 dim safe array of type BSTR
            psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
            if( psa )
            {
                for(ul=0; ul<m_cScope; ul++)
                {
                    rgIx[0] = ul;
                    BSTR    bstrVal = SysAllocString((LPWSTR)(m_rgbData + m_rgMachineOffset[ul]));
                    if( bstrVal )
                    {
                        hr = SafeArrayPutElement(psa, rgIx, bstrVal);
                        SysFreeString(bstrVal);
                        if( FAILED(hr) )
                            goto error_delete;
                    }
                    else
                    {
                        hr = ResultFromScode(E_OUTOFMEMORY);
                        goto error_delete;
                    }
                }
                V_VT(pvValue) = VT_BSTR | VT_ARRAY;
                V_ARRAY(pvValue) = psa;
                psa = NULL;
            }
            else
                return ResultFromScode(E_OUTOFMEMORY);
        }
            break;
        default:
            return ResultFromScode(E_INVALIDARG);
            break;
    }

    hr = S_OK;

error_delete:
    if( psa )
        SafeArrayDestroy(psa);

    return hr;
}


// CScopeData::CacheData -----------------------------------------------------
//
// @mfunc Manages storing data values in our buffer
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK | Data value stored at returned offset.
//      @flags E_OUTOFMEMORY | Could not allocate resources.
//
HRESULT CScopeData::CacheData(
    LPVOID  pData,
    ULONG   cb,
    ULONG*  pulOffset
    )
{
    SCODE sc = S_OK;

    TRY
    {
        assert( pData && pulOffset && cb > 0 );

        // Check to see if there is room in the Data buffer, if not
        // reallocate data buffer
        if( m_cbData + cb > m_cbMaxData )
        {
            ULONG cbTempMax = m_cbMaxData + ( (cb < CB_SCOPE_DATA_BUFFER_INC) ? 
                                              (CB_SCOPE_DATA_BUFFER_INC) : 
                                              (cb + CB_SCOPE_DATA_BUFFER_INC) );

            m_rgbData = renewx( m_rgbData, m_cbMaxData, cbTempMax );
            m_cbMaxData = cbTempMax;
        }

        // copy data and terminator
        RtlCopyMemory( (m_rgbData + m_cbData), pData, cb );

        // Set the offset where the new value can be found
        *pulOffset = m_cbData;
    
        // Adjust offset to start on an 8 Byte boundary.
        assert( (m_cbData % 8) == 0 );

        // @devnote: After this calculation, m_cchData may actually be larger
        // than m_cchMaxData.  This is OK, because FindOffsetBuffer will re-alloc
        // the next time around.
        m_cbData += cb + (8 - (cb % 8));  
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


// CScopeData::SetTemporaryMachine -------------------------------------------
//
// @mfunc Stores the machine name used for setting machine properties
//        in the compiler environment. 
//
// @rdesc HRESULT | status of methods success / failure
//      @flags OTHER | from called methods
//
HRESULT CScopeData::SetTemporaryMachine
    (
    LPWSTR  pwszMachine,    // @parm IN | machine to store
    ULONG   cch             // @parm IN | count of characters for new scope, exclude terminator
    )
{
    HRESULT hr;
    ULONG   ulOffset;

    assert( pwszMachine );
    assert( wcslen(pwszMachine) == cch );

    // Increment count of characters to include null terminator
    cch++;

    hr = CacheData(pwszMachine, (cch * sizeof(WCHAR)), &ulOffset);
    if( SUCCEEDED(hr) )
    {
        m_rgMachineOffset[m_cScope] = ulOffset;
    }

    return hr;
}


// CScopeData::SetTemporaryCatalog -------------------------------------------
//
// @mfunc Stores the catalog name used for setting scope properties
//       in the compiler environment. 
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK | Data value stored at returned offset.
//      @flags OTHER | from called methods
//
HRESULT CScopeData::SetTemporaryCatalog
    (
    LPWSTR  pwszCatalog,    // @parm IN | catalog name
    ULONG   cch
    )
{
    assert( pwszCatalog );
    assert( wcslen(pwszCatalog) == cch );

    ULONG   ulOffset;

    // Increment count of characters to include null terminator
    cch++;

    // Store the catalog value
    HRESULT hr = CacheData( pwszCatalog, (cch * sizeof(WCHAR)), &ulOffset );

    if( SUCCEEDED(hr) )
        m_rgCatalogOffset[m_cScope] = ulOffset;

    return hr;
}


// CScopeData::SetTemporaryScope ---------------------------------------------
//
// @mfunc Stores the scope name used for setting scope properties
//        in the compiler environment. 
//
// @rdesc HRESULT | status of methods success / failure
//      @flags OTHER | from called methods
//
HRESULT CScopeData::SetTemporaryScope
    (
    LPWSTR  pwszScope,  // @parm IN | scope to store
    ULONG   cch         // @parm IN | count of characters for new scope, exclude terminator
    )
{
    HRESULT hr;
    ULONG   ulOffset;

    assert( pwszScope );
    assert( wcslen(pwszScope) == cch );

    // Increment count of characters to include null terminator
    cch++;

    hr = CacheData(pwszScope, (cch * sizeof(WCHAR)), &ulOffset);
    if( SUCCEEDED(hr) )
    {
        m_rgScopeOffset[m_cScope] = ulOffset;

        // @devnote: Fixup for '/' being in the scope, Index Server requires
        // this to rewritten.
        for (WCHAR *wcsLetter = (WCHAR*)(m_rgbData + ulOffset); *wcsLetter != L'\0'; wcsLetter++)
            if (L'/' == *wcsLetter)
                *wcsLetter = L'\\'; // path names needs backslashes, not forward slashes
    }

    return hr;
}


// CScopeData::IncrementScopeCount -------------------------------------------
//
// @mfunc Increments the number of temporary scopes defined.  It also
//        copies the depth values to the next scope in case multiple
//        scopes are defined with the same traversal depth.
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK | Activated next scope arrays element
//      @flags E_OUTOFMEMORY | could allocate enough resources to do this.
//
HRESULT CScopeData::IncrementScopeCount()
{
    SCODE sc = S_OK;

    TRY
    {
        ULONG cCurScope = m_cScope + 1;

        // Check if re-alloc must be done.
        if( cCurScope >= m_cMaxScope )
        {
            ULONG cNewMaxScope = m_cMaxScope + SCOPE_BUFFERS_INCREMENT;

            m_rgulDepths = renewx( m_rgulDepths, m_cMaxScope, cNewMaxScope );
            m_rgScopeOffset = renewx( m_rgScopeOffset, m_cMaxScope, cNewMaxScope );
            m_rgCatalogOffset = renewx( m_rgCatalogOffset, m_cMaxScope, cNewMaxScope );
            m_rgMachineOffset = renewx( m_rgMachineOffset, m_cMaxScope, cNewMaxScope );

            // If the is the initial Allocation, then make our current scope
            // equal to 0
            if( m_cMaxScope == 0 )
                cCurScope = 0;

            // Initialize new elements
            for (ULONG i = cCurScope; i<cNewMaxScope; i++)
            {
                m_rgScopeOffset[i] = UNUSED_OFFSET;
                m_rgCatalogOffset[i] = UNUSED_OFFSET;
                m_rgMachineOffset[i] = UNUSED_OFFSET;
            }

            // Save new Max Elements.
            m_cMaxScope = cNewMaxScope;
        }

        // Transfer Depth from previous node

        if ( m_rgulDepths[m_cScope] & QUERY_DEEP )
            m_rgulDepths[cCurScope] = QUERY_DEEP;
        else
            m_rgulDepths[cCurScope] = QUERY_SHALLOW;

        // Transfer Machine and Catalog from previous node

        m_rgCatalogOffset[cCurScope] = m_rgCatalogOffset[m_cScope];
        m_rgMachineOffset[cCurScope] = m_rgMachineOffset[m_cScope];

        // Set the current # of used scopes to our new node.
        m_cScope = cCurScope;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}




//============================================================================
//=
//= CImpIParserTreeProperties
//=
//============================================================================

// CImpIParserTreeProperties::CImpIParserTreeProperties ------------------------
//
// @mfunc Constructor
//
// @rdesc None
//
CImpIParserTreeProperties::CImpIParserTreeProperties()
{
    // Reference count.
    m_cRef                      = 1;

    m_LastHR                    = S_OK;
    m_iErrOrd                   = 0;
    m_cErrParams                = 0;
    m_dbType                    = 0;
    m_fDesc                     = QUERY_SORTASCEND;
    m_pctContainsColumn         = NULL;

    m_pCScopeData               = NULL;
    m_pwszCatalog               = NULL;

    // initialize the CiRestriction data
    m_rgwchCiColumn[0]          = L' ';     // First character to a <space>
    m_rgwchCiColumn[1]          = L'\0';    // Second is Null Term
    m_cchMaxRestriction         = 0;
    m_cchRestriction            = 0;
    m_pwszRestriction           = NULL;
    m_pwszRestrictionAppendPtr  = NULL;
    m_fLeftParen                = false;
}


// CImpIParserTreeProperties::~CImpIParserTreeProperties -----------------------
//
// @mfunc Destructor
//
// @rdesc None
//
CImpIParserTreeProperties::~CImpIParserTreeProperties()
{
    FreeErrorDescriptions();

    delete [] m_pwszRestriction;
    delete [] m_pwszCatalog;

    if( 0 != m_pCScopeData )
        m_pCScopeData->Release();
}


// CImpIParserTreeProperties::FInit -------------------------------
//
// @mfunc Initialize class
//
// @rdesc HResult indicating the status of the method
//      @flag S_OK | Init'd
//
HRESULT CImpIParserTreeProperties::FInit(
    LPCWSTR pcwszCatalog,   //@parm IN | Current Catalog
    LPCWSTR pcwszMachine )  //@parm IN | Current Machine
{
    SCODE sc = S_OK;
    
    TRY
    {
        Win4Assert( 0 != pcwszCatalog );
        Win4Assert( 0 == m_pwszCatalog );

        XPtrST<WCHAR> xCatalog( CopyString(pcwszCatalog) );
        sc = CreateNewScopeDataObject( pcwszMachine );

        if (SUCCEEDED(sc) )
            m_pwszCatalog = xCatalog.Acquire();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


// CImpIParserTreeProperties::GetTreeProperties -------------------------------
//
// @mfunc Allows retrieval of properties
//
// @rdesc HResult indicating the status of the method
//      @flag S_OK | Property Value retrieved
//
STDMETHODIMP CImpIParserTreeProperties::GetProperties(
    ULONG       eParseProp,     //@parm IN | property to return value for
    VARIANT*    vParseProp      //@parm IN | Value of property
    )
{
    // Require a buffer
    assert( vParseProp );

//@TODO should we have to do this, or assume it is clean.
    VariantClear(vParseProp);

    switch( eParseProp )
    {
        case PTPROPS_SCOPE:
        case PTPROPS_DEPTH:
        case PTPROPS_MACHINE:
            return m_pCScopeData->GetData(eParseProp, vParseProp);
            break;
        case PTPROPS_CATALOG:
            return m_pCScopeData->GetData(eParseProp, vParseProp, m_pwszCatalog);
            break;
        case PTPROPS_CIRESTRICTION:
            V_BSTR(vParseProp) = SysAllocString(m_pwszRestriction);
            V_VT(vParseProp) = VT_BSTR;
            break;

        case PTPROPS_ERR_IDS:
            V_I4(vParseProp) = m_iErrOrd;
            V_VT(vParseProp) = VT_I4;            
            break;
        case PTPROPS_ERR_HR:
            V_I4(vParseProp) = m_LastHR;
            V_VT(vParseProp) = VT_I4;            
            break;          
        case PTPROPS_ERR_DISPPARAM:
        {
            HRESULT         hr = NOERROR;
            SAFEARRAYBOUND  rgsabound[1];   

            V_VT(vParseProp) = VT_BSTR | VT_ARRAY;
            V_ARRAY(vParseProp) = NULL;         

            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = m_cErrParams;

            // Create a 1 dim safe array of type BSTR
            SAFEARRAY FAR* psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
            if( psa )
            {
                LONG rgIx[1];
                for(ULONG ul=0; ul<m_cErrParams; ul++)
                {
                    rgIx[0] = ul;
                    BSTR bstrVal = SysAllocString(m_pwszErrParams[ul]);
                    if( bstrVal )
                    {
                        hr = SafeArrayPutElement(psa, rgIx, bstrVal);
                        SysFreeString(bstrVal);
                        if( FAILED(hr) )
                            break;
                    }
                    else
                    {
                        hr = ResultFromScode(E_OUTOFMEMORY);
                        break;
                    }
                }
                if( SUCCEEDED(hr) )
                    V_ARRAY(vParseProp) = psa;
                else
                    SafeArrayDestroy(psa);
            }
        }
            break;          
        default:
            return ResultFromScode(E_INVALIDARG);
            break;
    }

    return S_OK;
}


// CImpIParserTreeProperties::QueryInterface ----------------------------------
//
// @mfunc Returns a pointer to a specified interface. Callers use 
// QueryInterface to determine which interfaces the called object 
// supports. 
//
// @rdesc HResult indicating the status of the method
//      @flag S_OK | Interface is supported and ppvObject is set.
//      @flag E_NOINTERFACE | Interface is not supported by the object
//      @flag E_INVALIDARG | One or more arguments are invalid. 
//
STDMETHODIMP CImpIParserTreeProperties::QueryInterface
    (
    REFIID riid,                //@parm IN | Interface ID of the interface being queried for. 
    LPVOID * ppv                //@parm OUT | Pointer to interface that was instantiated      
    )
{
    if( ppv == NULL )
        return ResultFromScode(E_INVALIDARG);

    if( (riid == IID_IUnknown) ||
        (riid == IID_IParserTreeProperties) )
        *ppv = (LPVOID)this;
    else
        *ppv = NULL;


    //  If we're going to return an interface, AddRef it first
    if( *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


// CImpIParserTreeProperties::AddRef ------------------------------------------
//
// @mfunc Increments a persistence count for the object
//
// @rdesc Current reference count
//
STDMETHODIMP_(ULONG) CImpIParserTreeProperties::AddRef (void)
{
    return InterlockedIncrement( (long*) &m_cRef);
}


// CImpIParserTreeProperties::Release -----------------------------------------
//
// @mfunc Decrements a persistence count for the object and if
// persistence count is 0, the object destroys itself.
//
// @rdesc Current reference count
//
STDMETHODIMP_(ULONG) CImpIParserTreeProperties::Release (void)
{
    assert( m_cRef > 0 );

        ULONG cRef = InterlockedDecrement( (long *) &m_cRef );
    if( 0 == cRef )
    {
        delete this;
        return 0;
    }

    return cRef;
}


// CImpIParserTreeProperties::SetCiColumn -------------------------------------
//
// @mfunc Store the current column name to be applied to the
// restriction later
//
// @rdesc None
//
void CImpIParserTreeProperties::SetCiColumn
    (
    LPWSTR pwszColumn   // @parm IN | column name for this portion of restriction
    )
{
    // Should alway remain a <space>
    assert( *m_rgwchCiColumn == L' ' ); 
    assert( wcslen(pwszColumn) <= MAX_CCH_COLUMNNAME );

    // Copy column name into buffer.
    wcscpy(&m_rgwchCiColumn[1], pwszColumn);
}


// CImpIParserTreeProperties::AppendCiRestriction -----------------------------
//
// @mfunc Appends the given string to the end of the contructed CiRestriction. 
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK
//      @flags E_OUTOFMEMORY
//
HRESULT CImpIParserTreeProperties::AppendCiRestriction
    (
    LPWSTR  pwsz,   // @parm IN | latest addition to the generated CiRestriction
    ULONG   cch     // @parm IN | count of characters for new token, exclude terminator
    )
{
    SCODE sc = S_OK;

    TRY
    {
        assert( 0 != pwsz && 0 != cch );
        assert( wcslen(pwsz) == cch );    // cch should NOT include space for terminator

        // Determine if buffer is large enough or needs to be expanded.
        if( m_cchRestriction + cch > m_cchMaxRestriction )
        {
            ULONG cchNew = m_cchRestriction + ( (cch >= CCH_CIRESTRICTION_INCREMENT) ? 
                                                (CCH_CIRESTRICTION_INCREMENT + cch) :
                                                CCH_CIRESTRICTION_INCREMENT);

            LPWSTR pwszTemp = renewx( m_pwszRestriction, m_cchMaxRestriction, cchNew );

            // First allocation Processing
            if( 0 == m_cchMaxRestriction )
            {
                *pwszTemp = L'\0';
                m_cchRestriction = 1;
            }

            // Recalculate Append Pointer
            m_pwszRestrictionAppendPtr = pwszTemp + (m_pwszRestrictionAppendPtr - m_pwszRestriction);

            // Set member variable to new buffer.
            m_pwszRestriction = pwszTemp;

            // Set Max number of character slots
            m_cchMaxRestriction = cchNew;
        }

        assert( m_pwszRestriction );
        assert( *m_pwszRestrictionAppendPtr == L'\0' ); //Should always be on Null Terminator
    
        wcscpy( m_pwszRestrictionAppendPtr, pwsz );
        m_cchRestriction += cch;
        m_pwszRestrictionAppendPtr += cch;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    
    return sc;
}


// CImpIParserTreeProperties::UseCiColumn -------------------------------------
//
// @mfunc Copies the current CiRestriction column name to the CiRestriction
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK
//      @flags OTHER | from called methods
//
HRESULT CImpIParserTreeProperties::UseCiColumn
    (
    WCHAR wch   // @parm IN | prefix for column access
    )
{
    SCODE sc = S_OK;

    // Do we have a column name stored
    if( m_rgwchCiColumn[1] != L'\0' )
    {
        m_rgwchCiColumn[0] = wch;

        sc = AppendCiRestriction( m_rgwchCiColumn, wcslen(m_rgwchCiColumn) );
        if( SUCCEEDED(sc) )
        {
            if( true == m_fLeftParen )
            {
                sc = AppendCiRestriction(L" (", CALC_CCH_MINUS_NULL(L" ("));
                m_fLeftParen = false;
            }
            else
            {
                sc = AppendCiRestriction(L" ", CALC_CCH_MINUS_NULL(L" "));
            }
        }

        m_rgwchCiColumn[0] = L' ';
    }

    return sc;
}



// CImpIParserTreeProperties::CreateNewScopeDataObject -------------------------
//
// @mfunc Creates a new ScopeData container
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK
//      @flags E_FAIL | FInit failed
//      @flags E_OUTOFMEMORY
//
HRESULT CImpIParserTreeProperties::CreateNewScopeDataObject
    (
    LPCWSTR pcwszMachine        // @param IN | the current default machine
    )
{
    Assert( 0 != pcwszMachine );

    SCODE sc = S_OK;

    TRY
    {
        // Allocate ScopeData container
        // @devnote: After this allocation has succeeded, all
        // deletions of this object should be done through refcounts
        XInterface<CScopeData> xpScopeData( new CScopeData() );

        sc = xpScopeData->FInit( pcwszMachine );
        if( SUCCEEDED(sc) )
        {
            if ( m_pCScopeData )
                m_pCScopeData->Release();
            m_pCScopeData = xpScopeData.Acquire();
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}
        

// CImpIParserTreeProperties::ReplaceScopeDataPtr -------------------------
//
// @mfunc Take ownership of the ScopeData
//
// @rdesc void 
//
void CImpIParserTreeProperties::ReplaceScopeDataPtr(CScopeData* pCScopeData)
{
    assert( pCScopeData );

    if( m_pCScopeData )
    {
        ULONG ulRef = m_pCScopeData->Release();
        assert( ulRef == 0 );
    }

    m_pCScopeData = pCScopeData;
    m_pCScopeData->AddRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\ptprops.h ===
//----------------------------------------------------------------------------
// Microsoft OLE DB Implementation For Index Server
// (C) Copyright 1997 By Microsoft Corporation.
//
// @doc
//
// @module PTPROPS.H | 
//
// @rev 1 | 10-13-97 | Briants  | Created
//

// Includes ------------------------------------------------------------------
#ifndef _PTPROPS_H_
#define _PTPROPS_H_

const ULONG MAX_CCH_COLUMNNAME = 128;  // per Section 3.1 of spec
const ULONG CCH_CIRESTRICTION_INCREMENT = 128;
const ULONG CB_SCOPE_DATA_BUFFER_INC = 512;
const ULONG SCOPE_BUFFERS_INCREMENT = 5;
const ULONG UNUSED_OFFSET = (ULONG)-1;

#define MAX_ERRORS  2

class CScopeData
{
    private: //@access Private Data Members
        LONG        m_cRef;

        ULONG       m_cScope;
        ULONG       m_cMaxScope;
        ULONG*      m_rgulDepths;
        ULONG*      m_rgCatalogOffset;
        ULONG*      m_rgScopeOffset;
        ULONG*      m_rgMachineOffset;

        ULONG       m_cbData;
        ULONG       m_cbMaxData;
        BYTE*       m_rgbData;

    private: //@access Private Member Functions
        HRESULT         CacheData(LPVOID pData, ULONG cb, ULONG* pulOffset);

    public:
        CScopeData();
        ~CScopeData();

        HRESULT         FInit(LPCWSTR pcwszMachine);
        HRESULT         Reset(void);

        // Handle sharing of this object
        ULONG           AddRef(void);
        ULONG           Release(void);

        
        HRESULT         GetData(ULONG uPropId, VARIANT* pvValue, LPCWSTR pcwszCatalog = NULL);
        HRESULT         SetTemporaryMachine(LPWSTR pwszMachine, ULONG cch);
        HRESULT         SetTemporaryCatalog(LPWSTR pwszCatalog, ULONG cch);
        HRESULT         SetTemporaryScope(LPWSTR pwszScope, ULONG cch);
        HRESULT         IncrementScopeCount();


        //--------------------------------------------------------------------
        // @mfunc Stores the traversl depth used for setting scope properties
        //  in the compiler environment. 
        //
        // @rdesc none
        //
        inline void     SetTemporaryDepth( 
            ULONG   ulDepth     // @parm IN | search depth
            )
        {
            m_rgulDepths[m_cScope] = ulDepth;
        }


        //--------------------------------------------------------------------
        // @func Masks the traversal depth used for setting scope          
        //       properties in the compiler environment.  This is used
        //       to specify virtual or physical paths.
        //
        // @rdesc none
        //
        inline void     MaskTemporaryDepth(
            ULONG   ulMask      // @parm IN | search mask (virtual or physical)
            )
        {
            m_rgulDepths[m_cScope] |= ulMask;
        }
};


//  CImpIParserTreeProperties Object
class CImpIParserTreeProperties : public IParserTreeProperties 
{
    private:
        LONG        m_cRef;

        //@cmember 
        CScopeData* m_pCScopeData;

        LPWSTR      m_pwszCatalog;

        HRESULT     m_LastHR;
        UINT        m_iErrOrd;
        WCHAR*      m_pwszErrParams[MAX_ERRORS];
        ULONG       m_cErrParams;

        // Have buffer with space for max column name + 
        // a space before the column name.
        WCHAR       m_rgwchCiColumn[MAX_CCH_COLUMNNAME + 2];
        ULONG       m_cchMaxRestriction;
        ULONG       m_cchRestriction;
        LPWSTR      m_pwszRestriction;
        LPWSTR      m_pwszRestrictionAppendPtr;
        bool        m_fLeftParen;

        BOOL        m_fDesc;            // make the sort direction "sticky"
        DBTYPE      m_dbType;
        DBCOMMANDTREE*  m_pctContainsColumn;


    public: 
        // CTOR and DTOR
        CImpIParserTreeProperties();
        ~CImpIParserTreeProperties();

        HRESULT         FInit(LPCWSTR pwszCatalog, LPCWSTR pwszMachine);
        
        STDMETHODIMP    QueryInterface(
                        REFIID riid, LPVOID* ppVoid);
        STDMETHODIMP_(ULONG) Release (void);
        STDMETHODIMP_(ULONG) AddRef (void);

        STDMETHODIMP    GetProperties(
                        ULONG eParseProp, VARIANT* vParseProp);

        void            SetCiColumn(LPWSTR pwszColumn);
        HRESULT         AppendCiRestriction(LPWSTR pwsz, ULONG cch);
        HRESULT         UseCiColumn(WCHAR wch);
        HRESULT         CreateNewScopeDataObject(LPCWSTR pwszMachine);
        void            ReplaceScopeDataPtr(CScopeData* pCScopeData);

        // Inline Functions
        inline CScopeData*  GetScopeDataPtr()
            { return m_pCScopeData; }

        inline void     CiNeedLeftParen(void)
            { m_fLeftParen = true; }

        inline void     SetNumErrParams(UINT cErrParams)
            { m_cErrParams = cErrParams; }

        inline UINT     GetNumErrParams()
            { return m_cErrParams; }

        inline void     SetErrorHResult(HRESULT hr, UINT iErrOrd=0)
            {
            m_LastHR = hr;
            m_iErrOrd = iErrOrd;
            m_cErrParams = 0;
            }

        inline void     SetErrorToken(const WCHAR* pwstr)
            {
            assert(m_cErrParams < MAX_ERRORS);  // can't happen
            WCHAR * pwc = CopyString( pwstr );

            // Truncate long errors since FormatMessage will fail otherwise

            if ( wcslen( pwc ) >= (MAX_PATH-1) )
                pwc[ MAX_PATH-1] = 0;

            m_pwszErrParams[m_cErrParams++] = pwc;
            }

        inline HRESULT  GetErrorHResult()
            { return m_LastHR; }

        inline UINT     GetErrorOrdinal()
            { return m_iErrOrd; }

        inline void FreeErrorDescriptions()
            { 
                for (UINT i = 0; i < m_cErrParams; i++) 
                    delete [] m_pwszErrParams[i]; 
            }

        inline DBTYPE           GetDBType()
            { return m_dbType; }

        inline void             SetDBType(DBTYPE dbType)
            { m_dbType = dbType; }

        inline BOOL             GetSortDesc()
            { return m_fDesc; }

        inline void             SetSortDesc(BOOL fDesc)
            { m_fDesc = fDesc; }

        inline DBCOMMANDTREE*   GetContainsColumn()
            { return m_pctContainsColumn; }

        inline void             SetContainsColumn(DBCOMMANDTREE* pct)
            { m_pctContainsColumn = pct; }

};  // End of Class

#endif // _PTPROPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\treeutil.cpp ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Query
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module treeutil.cpp | 
//
//  Contains tree manipulation utility functions for both OLE-DB and QTE trees.
//
// @devnote None
//
// @rev   0 | 12-Feb-97 | v-charca      | Created
//
#pragma hdrstop
#include "msidxtr.h"


#define INDENTLINE setfill('\t') << setw(indentLevel) << "" 
#define VAL_AND_CCH_MINUS_NULL(p1) (p1), ((sizeof(p1) / sizeof(*(p1))) - 1)



//--------------------------------------------------------------------
// @func Converts a wide character string string into a LARGEINTEGER
// @rdesc Pointer to new UNICODE string

HRESULT PropVariantChangeTypeI64( 
    PROPVARIANT* pvarValue )
{
    LPWSTR pwszVal = pvarValue->bstrVal;
    ULONGLONG uhVal = 0;
    UINT iBase = 10;
    BOOL fNegative = FALSE;
    UINT uiDigitVal = 0;
    if (L'-' == *pwszVal)
    {
        fNegative = TRUE;   // remember we need to negate later
        pwszVal++;
    }
    else if (L'+' == *pwszVal)
        pwszVal++;      // a plus sign is simply noise

    if ((L'0' == pwszVal[0]) && (L'x' == pwszVal[1] || L'X' == pwszVal[1]))
    {
        iBase = 16;
        pwszVal += 2;
    }
    ULONGLONG uhMaxPartial = _UI64_MAX / iBase;

    while (*pwszVal)
    {
        if (iswdigit(*pwszVal))
            uiDigitVal = *pwszVal - L'0';
        else /* a-fA-F */
            uiDigitVal = towupper(*pwszVal) - L'A' + 10;

        if (uhVal < uhMaxPartial ||
            (uhVal == uhMaxPartial && (ULONGLONG)uiDigitVal <= _UI64_MAX % iBase))
            uhVal = uhVal * iBase + uiDigitVal;
        else  // adding this digit would cause an overflow to occur
            return DISP_E_OVERFLOW;

        pwszVal++;
    }

    
    if (fNegative)
    {
        if (uhVal > -_I64_MIN)
            return DISP_E_OVERFLOW;
        else
        {
            SysFreeString(pvarValue->bstrVal);
            pvarValue->vt = VT_I8;
            pvarValue->hVal.QuadPart = -(LONGLONG)uhVal;
        }
    }
    else
    {
        SysFreeString(pvarValue->bstrVal);
        pvarValue->vt = VT_UI8;
        pvarValue->uhVal.QuadPart = uhVal;
    }

    return S_OK;
}


#ifdef DEBUG
//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given LPOLESTR string into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream     &osOut,    //@parm INOUT   | ostream in which node is to be placed.
    LPWSTR      pwszName   //@parm IN      | LPWSTR string to dump.
    )
{
    UINT cLen = wcslen(pwszName);
    for (UINT i=0; i<cLen; i++)
        osOut << char(pwszName[i]);
    return osOut;
}
#endif

//--------------------------------------------------------------------
//@func Allocates and initializes an OLE-DB DBCOMMANDTREE 
//  of the given kind and op.
//
//@rdesc DBCommandTree node of the correct kind and
//  with any additional memory for the value field allocated.
//  All other fields are NULL or default values.
//
DBCOMMANDTREE * PctAllocNode(
    DBVALUEKIND wKind,  //@parm IN | kind of tree to create
    DBCOMMANDOP op )    //@parm IN 
{
    DBCOMMANDTREE* pTableNode = NULL;
    
    pTableNode = (DBCOMMANDTREE*) CoTaskMemAlloc(sizeof(DBCOMMANDTREE));
    if (NULL == pTableNode)
        return NULL;

    // Set default values
    pTableNode->op = op;
    pTableNode->wKind = (WORD)wKind;
    pTableNode->pctFirstChild = NULL;
    pTableNode->pctNextSibling = NULL;
    pTableNode->value.pvValue = NULL;
    pTableNode->hrError = S_OK;

    switch (wKind)
    {
    case DBVALUEKIND_BYGUID:
        pTableNode->value.pdbbygdValue = (DBBYGUID*) CoTaskMemAlloc(sizeof DBBYGUID);
        if (NULL == pTableNode->value.pdbbygdValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_COLDESC:
        pTableNode->value.pcoldescValue = (DBCOLUMNDESC*) CoTaskMemAlloc(sizeof DBCOLUMNDESC);
        if (NULL == pTableNode->value.pcoldescValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_ID:
        pTableNode->value.pdbidValue = (DBID*) CoTaskMemAlloc(sizeof DBID);
        if (NULL == pTableNode->value.pdbidValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_CONTENT:
        pTableNode->value.pdbcntntValue = (DBCONTENT*) CoTaskMemAlloc(sizeof DBCONTENT);
        if (NULL == pTableNode->value.pdbcntntValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_CONTENTSCOPE:
        pTableNode->value.pdbcntntscpValue = (DBCONTENTSCOPE*) CoTaskMemAlloc(sizeof DBCONTENTSCOPE);
        if ( NULL == pTableNode->value.pdbcntntscpValue )
        {
            CoTaskMemFree( pTableNode );
            pTableNode = NULL;
        }
        else
            RtlZeroMemory( pTableNode->value.pdbcntntscpValue, sizeof(DBCONTENTSCOPE) );
        break;

    case DBVALUEKIND_CONTENTTABLE:
        pTableNode->value.pdbcntnttblValue = (DBCONTENTTABLE*) CoTaskMemAlloc(sizeof DBCONTENTTABLE);
        if ( NULL == pTableNode->value.pdbcntnttblValue )
        {
            CoTaskMemFree( pTableNode );
            pTableNode = NULL;
        }
        else
            RtlZeroMemory( pTableNode->value.pdbcntnttblValue, sizeof(DBCONTENTTABLE) );
        break;

    case DBVALUEKIND_CONTENTVECTOR:
        pTableNode->value.pdbcntntvcValue = (DBCONTENTVECTOR*) CoTaskMemAlloc(sizeof DBCONTENTVECTOR);
        if (NULL == pTableNode->value.pdbcntntvcValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_GROUPINFO:
        pTableNode->value.pdbgrpinfValue = (DBGROUPINFO*) CoTaskMemAlloc(sizeof DBGROUPINFO);
        if (NULL == pTableNode->value.pdbgrpinfValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

//      case DBVALUEKIND_PARAMETER:
//      case DBVALUEKIND_PROPERTY:

    case DBVALUEKIND_SETFUNC:
        pTableNode->value.pdbstfncValue = (DBSETFUNC*) CoTaskMemAlloc(sizeof DBSETFUNC);
        if (NULL == pTableNode->value.pdbstfncValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_SORTINFO:
        pTableNode->value.pdbsrtinfValue = (DBSORTINFO*) CoTaskMemAlloc(sizeof DBSORTINFO);
        if (NULL == pTableNode->value.pdbsrtinfValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_TEXT:
        pTableNode->value.pdbtxtValue = (DBTEXT*) CoTaskMemAlloc(sizeof DBTEXT);
        if (NULL == pTableNode->value.pdbtxtValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_COMMAND:
    case DBVALUEKIND_MONIKER:
    case DBVALUEKIND_ROWSET:
        break;

    case DBVALUEKIND_LIKE:
        pTableNode->value.pdblikeValue = (DBLIKE*) CoTaskMemAlloc(sizeof DBLIKE);
        if (NULL == pTableNode->value.pdblikeValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_CONTENTPROXIMITY:
        pTableNode->value.pdbcntntproxValue = (DBCONTENTPROXIMITY*) CoTaskMemAlloc(sizeof DBCONTENTPROXIMITY);
        if (NULL == pTableNode->value.pdbcntntproxValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_IDISPATCH:
    case DBVALUEKIND_IUNKNOWN:
    case DBVALUEKIND_EMPTY:
    case DBVALUEKIND_NULL:
    case DBVALUEKIND_I2:
    case DBVALUEKIND_I4:
    case DBVALUEKIND_R4:
    case DBVALUEKIND_R8:
    case DBVALUEKIND_CY:
    case DBVALUEKIND_DATE:
    case DBVALUEKIND_BSTR:
    case DBVALUEKIND_ERROR:
    case DBVALUEKIND_BOOL:
        break;

    case DBVALUEKIND_VARIANT:
        // NOTE:  This is really a PROPVARIANT node, but there is no DBVALUEKIND for PROPVARIANT.
        pTableNode->value.pvValue = (PROPVARIANT*) CoTaskMemAlloc(sizeof PROPVARIANT);
        if (NULL == pTableNode->value.pvValue )
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        else
            PropVariantInit((PROPVARIANT*)(pTableNode->value.pvValue));
        break;  

    case DBVALUEKIND_VECTOR:
    case DBVALUEKIND_ARRAY:
    case DBVALUEKIND_BYREF:
    case DBVALUEKIND_I1:
    case DBVALUEKIND_UI1:
    case DBVALUEKIND_UI2:
    case DBVALUEKIND_UI4:
    case DBVALUEKIND_I8:
    case DBVALUEKIND_UI8:
        break;

    case DBVALUEKIND_GUID:
        pTableNode->value.pGuid = (GUID*) CoTaskMemAlloc(sizeof GUID);
        if (NULL == pTableNode->value.pGuid)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_BYTES:
    case DBVALUEKIND_STR:
    case DBVALUEKIND_WSTR:
    case DBVALUEKIND_NUMERIC:
//      case DBVALUEKIND_DBDATE:
//      case DBVALUEKIND_DBTIME:
//      case DBVALUEKIND_DBTIMESTAMP:
        break;

    default:
        assert(!"PctAllocNode: illegal wKind");
        CoTaskMemFree(pTableNode);
        pTableNode = NULL;
        break;
    }

    return pTableNode;
}


//--------------------------------------------------------------------
// @func Reverses a linked list of DBCOMMANDTREE siblings. This is necessary 
//      for left recursive rule in the YACC grammar.
//
// @rdesc DBCOMMANDTREE *
//
DBCOMMANDTREE * PctReverse(
    DBCOMMANDTREE * pct )       // @parm IN | original list to be reversed
{
    DBCOMMANDTREE *pctPrev = NULL;
    DBCOMMANDTREE *pctNext = pct;

    /** NULL or 1 item list is itself **/
    if(pct == NULL || pct->pctNextSibling == NULL)  
        return pct;
    
    Assert(pct != NULL);

    while(pct != NULL)
    {
        pctNext = pctNext->pctNextSibling;
        pct->pctNextSibling = pctPrev;
        pctPrev = pct;
        pct = pctNext;
    }

    return pctPrev;
}



//--------------------------------------------------------------------
// @func Creates a DBCOMMANDTREE and tags it by the given op and sets its
//      arguments. Note that this routine is takes variable params to DBCOMMANDTREE's.  This
//      allows the YACC grammer file to use a central entry point to create a
//      parse tree complete with all its children args.
//
// @side This routine will traverse arg inputs before appending trailing args. This
//      gives the effect of appending lists to lists.
//
// @rdesc DBCOMMANDTREE *
//
// @devnote 
//  Last argument must be NULL: As end of var args is detected with NULL.
//
DBCOMMANDTREE *PctCreateNode(
    DBCOMMANDOP op,                 // @parm IN | op tag for new node
    DBVALUEKIND wKind,              //@parm IN | kind to node to allocate
    DBCOMMANDTREE * pctArg,         // @parm IN | var arg children
    ... )                            
{
    HRESULT hr = S_OK;
    DBCOMMANDTREE * pctRoot = NULL;
    DBCOMMANDTREE * pctCurArg = NULL;
    USHORT cNode = 0;
    va_list pArg;

    if (pctArg != NULL)
    {
        va_start(pArg, pctArg);     // start var arg list

        /** create arg list by chaining all input node togther **/
        pctCurArg = pctArg;
        while(TRUE)
        {

            /** walk to the end of the current list **/
            while (pctCurArg->pctNextSibling != NULL)
            {
                pctCurArg = pctCurArg->pctNextSibling;
                cNode++;
            }

            /** place the next arg onto the tail of the list (this might also be a list) **/
            pctCurArg->pctNextSibling = va_arg(pArg, DBCOMMANDTREE *); // get next var arg

            /** no more args to append to list**/
            if (pctCurArg->pctNextSibling == NULL)
                break;
        }

        va_end(pArg);   // destruct var arg list
    }

    /** create the node and add specifc type info **/
    if((pctRoot = PctAllocNode(wKind)) == NULL)
    { 
        hr = E_OUTOFMEMORY;
        goto CreateErr;
    }
    

    /** tag node type and set child arg list **/
    pctRoot->op = op;   
    pctRoot->pctFirstChild = pctArg;

    Assert(NULL != pctRoot);
    
    /** Success **/
    return pctRoot;

CreateErr:
    return NULL;
}

//--------------------------------------------------------------------
// @func Creates a DBCOMMANDTREE and tags it by the given op and sets its
//      arguments. Note that this routine is takes variable params to DBCOMMANDTREE's.  This
//      allows the YACC grammer file to use a central entry point to create a
//      parse tree complete with all its children args.
//
// @side This routine will traverse arg inputs before appending trailing args. This
//      gives the effect of appending lists to lists.
//
// @rdesc DBCOMMANDTREE *
//
// @devnote 
//  Last argument must be NULL: As end of var args is detected with NULL.
//
DBCOMMANDTREE *PctCreateNode(
    DBCOMMANDOP op,                 // @parm IN | op tag for new node
    DBCOMMANDTREE * pctArg,         // @parm IN | var arg children
    ... )
{
    HRESULT hr = S_OK;
    DBCOMMANDTREE * pctRoot = NULL;
    DBCOMMANDTREE * pctCurArg = NULL;
    USHORT cNode = 0;
    va_list pArg;

    if (pctArg != NULL)
    {
        va_start(pArg, pctArg);     // start var arg list

        /** create arg list by chaining all input node togther **/
        pctCurArg = pctArg;
        while(TRUE)
        {

            /** walk to the end of the current list **/
            while (pctCurArg->pctNextSibling != NULL)
            {
                pctCurArg = pctCurArg->pctNextSibling;
                cNode++;
            }

            /** place the next arg onto the tail of the list (this might also be a list) **/
            pctCurArg->pctNextSibling = va_arg(pArg, DBCOMMANDTREE *); // get next var arg

            /** no more args to append to list**/
            if (pctCurArg->pctNextSibling == NULL)
                break;
        }

        va_end(pArg);   // destruct var arg list
    }

    /** create the node and add specifc type info **/
    if((pctRoot = PctAllocNode(DBVALUEKIND_EMPTY)) == NULL)
    { 
        hr = E_OUTOFMEMORY;
        goto CreateErr;
    }
    

    /** tag node type and set child arg list **/
    pctRoot->op = op;   
    pctRoot->pctFirstChild = pctArg;

    Assert(NULL != pctRoot);
    
    /** Success **/
    return pctRoot;

CreateErr:
    return NULL;
}


//--------------------------------------------------------------------
//@func Determines the number of siblings of a given node.
//
UINT GetNumberOfSiblings(
    DBCOMMANDTREE *pct ) //@parm IN | starting node
{
    UINT cSiblings =0;
    while (pct)
    {
        cSiblings++;
        pct=pct->pctNextSibling;
    }
    return cSiblings;
}

//--------------------------------------------------------------------
//@func Recursively deletes a command tree using CoTaskMemFree
//
void DeleteDBQT(
    DBCOMMANDTREE* pTableNode )  //@parm IN | Tree to delete
{
    if ( 0 == pTableNode )
        return;

    //delete children and siblings
    if (pTableNode->pctFirstChild)
        DeleteDBQT(pTableNode->pctFirstChild);
    if (pTableNode->pctNextSibling)
        DeleteDBQT(pTableNode->pctNextSibling);

    //delete member pointers
    switch (pTableNode->wKind)
    {
    case DBVALUEKIND_BYGUID:
        CoTaskMemFree(pTableNode->value.pdbbygdValue);
        break;

    case DBVALUEKIND_COLDESC:
        CoTaskMemFree(pTableNode->value.pcoldescValue);
        break;

    case DBVALUEKIND_ID:
        switch (pTableNode->value.pdbidValue->eKind)
        {
        case DBKIND_NAME:
        case DBKIND_GUID_NAME:
            CoTaskMemFree(pTableNode->value.pdbidValue->uName.pwszName);
            break;

        case DBKIND_PGUID_PROPID:
            CoTaskMemFree(pTableNode->value.pdbidValue->uGuid.pguid);
            break;

        case DBKIND_PGUID_NAME:
            CoTaskMemFree(pTableNode->value.pdbidValue->uName.pwszName);
            CoTaskMemFree(pTableNode->value.pdbidValue->uGuid.pguid);
            break;

        case DBKIND_GUID:
        case DBKIND_GUID_PROPID:
            break;  // nothing to get rid of

        default:    // It shouldn't be anything else
            Assert(0);
        }
        CoTaskMemFree(pTableNode->value.pdbidValue);
        break;

    case DBVALUEKIND_CONTENT:
        CoTaskMemFree(pTableNode->value.pdbcntntValue->pwszPhrase);
        CoTaskMemFree(pTableNode->value.pdbcntntValue);
        break;

    case DBVALUEKIND_CONTENTSCOPE:
        CoTaskMemFree(pTableNode->value.pdbcntntscpValue->pwszElementValue);
        CoTaskMemFree(pTableNode->value.pdbcntntscpValue);
        break;

    case DBVALUEKIND_CONTENTTABLE:
        CoTaskMemFree(pTableNode->value.pdbcntnttblValue->pwszMachine);
        CoTaskMemFree(pTableNode->value.pdbcntnttblValue->pwszCatalog);
        CoTaskMemFree(pTableNode->value.pdbcntnttblValue);
        break;

    case DBVALUEKIND_CONTENTVECTOR:
        CoTaskMemFree(pTableNode->value.pdbcntntvcValue);
        break;

    case DBVALUEKIND_LIKE:
        CoTaskMemFree(pTableNode->value.pdblikeValue);
        break;

    case DBVALUEKIND_CONTENTPROXIMITY:
        CoTaskMemFree(pTableNode->value.pdbcntntproxValue);
        break;

    case DBVALUEKIND_GROUPINFO:
        CoTaskMemFree(pTableNode->value.pdbgrpinfValue);
        break;

    case DBVALUEKIND_SETFUNC:
        CoTaskMemFree(pTableNode->value.pdbstfncValue);
        break;

    case DBVALUEKIND_SORTINFO:
        CoTaskMemFree(pTableNode->value.pdbsrtinfValue);
        break;

    case DBVALUEKIND_TEXT:
        Assert(NULL != pTableNode->value.pdbtxtValue);
        Assert(NULL != pTableNode->value.pdbtxtValue->pwszText);
        CoTaskMemFree(pTableNode->value.pdbtxtValue->pwszText);
        CoTaskMemFree(pTableNode->value.pdbtxtValue);
        break;

    case DBVALUEKIND_COMMAND:
    case DBVALUEKIND_MONIKER:
    case DBVALUEKIND_ROWSET:
    case DBVALUEKIND_IDISPATCH:
    case DBVALUEKIND_IUNKNOWN:
    case DBVALUEKIND_EMPTY:
    case DBVALUEKIND_NULL:
    case DBVALUEKIND_I2:
    case DBVALUEKIND_I4:
    case DBVALUEKIND_R4:
    case DBVALUEKIND_R8:
    case DBVALUEKIND_CY:
    case DBVALUEKIND_DATE:
        break;

    case DBVALUEKIND_BSTR:
        CoTaskMemFree(pTableNode->value.pbstrValue);
        break;

    case DBVALUEKIND_ERROR:
    case DBVALUEKIND_BOOL:
        break;

    case DBVALUEKIND_VARIANT:
        {
        HRESULT hr = PropVariantClear((PROPVARIANT*)pTableNode->value.pvValue);
        if (FAILED(hr))
            Assert(0);  // UNDONE:  meaningful error message
        CoTaskMemFree(pTableNode->value.pvValue);
        }
        break;

    case DBVALUEKIND_VECTOR:
    case DBVALUEKIND_ARRAY:
    case DBVALUEKIND_BYREF:
        assert(!"DeleteDBQT Vector,array,byref not implemented");
        break;
    
    case DBVALUEKIND_I1:
    case DBVALUEKIND_UI1:
    case DBVALUEKIND_UI2:
    case DBVALUEKIND_UI4:
    case DBVALUEKIND_I8:
    case DBVALUEKIND_UI8:
        break;

    case DBVALUEKIND_GUID:
        CoTaskMemFree(pTableNode->value.pGuid);
        break;

    case DBVALUEKIND_BYTES:
        assert(!"DeleteDBQT BYTES not implemented");
        break;

    case DBVALUEKIND_WSTR:
        CoTaskMemFree(pTableNode->value.pwszValue);
        break;

    case DBVALUEKIND_NUMERIC:
        CoTaskMemFree(pTableNode->value.pdbnValue);
        break;

    default :
        Assert(FALSE);
        break;
    }
    CoTaskMemFree(pTableNode);
}

//--------------------------------------------------------------------
//@func Copies the OLE-DB tree (pTableNodeSrc) into a new tree
//@rdesc Return pointer to new tree in ppTableNodeDest
//
HRESULT HrQeTreeCopy(
    DBCOMMANDTREE **ppTableNodeDest,     // @parm OUT | destination for copy
    const DBCOMMANDTREE *pTableNodeSrc ) // @parm IN | src OLE-DB tree
{
    HRESULT hr = S_OK;

    *ppTableNodeDest = NULL;
    if (pTableNodeSrc == NULL)
        return hr;

    // Allocates the correct 
    DBCOMMANDTREE * pTableNode = PctAllocNode(pTableNodeSrc->wKind);
    if (NULL == pTableNode)
        return E_OUTOFMEMORY;

    pTableNode->op = pTableNodeSrc->op;
    pTableNode->hrError = pTableNodeSrc->hrError;
    
    
    //Now for byref data, make a copy of the data
    switch(pTableNode->wKind)
    {
    case DBVALUEKIND_ID:
        RtlCopyMemory(pTableNode->value.pdbidValue,pTableNodeSrc->value.pdbidValue,sizeof(DBID));
        switch (pTableNodeSrc->value.pdbidValue->eKind)
        {
        case DBKIND_NAME:
        case DBKIND_GUID_NAME:
            // need to create a new string
            pTableNode->value.pdbidValue->uName.pwszName =
                CoTaskStrDup(pTableNodeSrc->value.pdbidValue->uName.pwszName);
            break;
        case DBKIND_GUID:
        case DBKIND_GUID_PROPID:
            // nothing new to copy
            break;
        case DBKIND_PGUID_NAME:
            // need to create a new string
            pTableNode->value.pdbidValue->uName.pwszName =
                CoTaskStrDup(pTableNodeSrc->value.pdbidValue->uName.pwszName);
            // need to allocate and copy guid
            pTableNode->value.pdbidValue->uGuid.pguid =
                (GUID*)CoTaskMemAlloc(sizeof(GUID));
            *pTableNode->value.pdbidValue->uGuid.pguid =
                *pTableNodeSrc->value.pdbidValue->uGuid.pguid;
            break;
        case DBKIND_PGUID_PROPID:
            // need to allocate and copy guid
            pTableNode->value.pdbidValue->uGuid.pguid =
                (GUID*)CoTaskMemAlloc(sizeof(GUID));
            *pTableNode->value.pdbidValue->uGuid.pguid =
                *pTableNodeSrc->value.pdbidValue->uGuid.pguid;
            break;
        default:
            Assert(0);
        }
        break;
    case DBVALUEKIND_BYGUID:
        RtlCopyMemory(pTableNode->value.pdbbygdValue,pTableNodeSrc->value.pdbbygdValue,sizeof(DBBYGUID));
        break;
    case DBVALUEKIND_COLDESC:
        if (NULL == pTableNodeSrc->value.pcoldescValue)
            pTableNode->value.pcoldescValue = NULL;
        else
        {
            RtlCopyMemory(pTableNode->value.pcoldescValue, pTableNodeSrc->value.pcoldescValue, sizeof(DBCOLUMNDESC));

            if (NULL != pTableNodeSrc->value.pcoldescValue->dbcid.uName.pwszName)
                pTableNode->value.pcoldescValue->dbcid.uName.pwszName = CoTaskStrDup(pTableNodeSrc->value.pcoldescValue->dbcid.uName.pwszName);
            else
                pTableNode->value.pcoldescValue->dbcid.uName.pwszName = NULL;
        }
        break;
    case DBVALUEKIND_CONTENT:
        RtlCopyMemory(pTableNode->value.pdbcntntValue, pTableNodeSrc->value.pdbcntntValue, sizeof(DBCONTENT));
// UNDONE: allocate and stuff ->pwszPhrase
        break;
    case DBVALUEKIND_CONTENTSCOPE:
        (pTableNode->value.pdbcntntscpValue)->pwszElementValue = CoTaskStrDup( (pTableNodeSrc->value.pdbcntntscpValue)->pwszElementValue );
        (pTableNode->value.pdbcntntscpValue)->dwFlags = (pTableNodeSrc->value.pdbcntntscpValue)->dwFlags;
        // RtlCopyMemory(pTableNode->value.pdbcntntscpValue, pTableNodeSrc->value.pdbcntntscpValue, sizeof(DBCONTENTSCOPE));
        break;
    case DBVALUEKIND_CONTENTTABLE:
        (pTableNode->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( (pTableNodeSrc->value.pdbcntnttblValue)->pwszMachine );
        (pTableNode->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( (pTableNodeSrc->value.pdbcntnttblValue)->pwszCatalog );
        // RtlCopyMemory(pTableNode->value.pdbcntnttblValue, pTableNodeSrc->value.pdbcntnttblValue, sizeof(DBCONTENTTABLE));
        break;
    case DBVALUEKIND_LIKE:
        RtlCopyMemory(pTableNode->value.pdblikeValue,pTableNodeSrc->value.pdblikeValue,sizeof(DBLIKE));
        break;
    case DBVALUEKIND_CONTENTPROXIMITY:
        RtlCopyMemory(pTableNode->value.pdbcntntproxValue, pTableNodeSrc->value.pdbcntntproxValue, sizeof(DBCONTENTPROXIMITY));
// UNDONE: allocate and stuff ->pwszPhrase
        break;
    case DBVALUEKIND_CONTENTVECTOR:
//UNDONE:           CoTaskMemFree(pTableNode->value.pdbcntntvcValue->rgulWeights);
        RtlCopyMemory(pTableNode->value.pdbcntntvcValue, pTableNodeSrc->value.pdbcntntvcValue, sizeof(DBCONTENTVECTOR));
        break;
    case DBVALUEKIND_GROUPINFO:
        RtlCopyMemory(pTableNode->value.pdbgrpinfValue,pTableNodeSrc->value.pdbgrpinfValue,sizeof(DBGROUPINFO));
        break;
    case DBVALUEKIND_SETFUNC:
        RtlCopyMemory(pTableNode->value.pdbstfncValue,pTableNodeSrc->value.pdbstfncValue,sizeof(DBSETFUNC));
        break;
    case DBVALUEKIND_SORTINFO:
        RtlCopyMemory(pTableNode->value.pdbsrtinfValue,pTableNodeSrc->value.pdbsrtinfValue,sizeof(DBSORTINFO));
        break;
    case DBVALUEKIND_TEXT:
        pTableNode->value.pdbtxtValue->guidDialect = pTableNodeSrc->value.pdbtxtValue->guidDialect;
        pTableNode->value.pdbtxtValue->pwszText = CoTaskStrDup(pTableNodeSrc->value.pdbtxtValue->pwszText);
        pTableNode->value.pdbtxtValue->ulErrorLocator = pTableNodeSrc->value.pdbtxtValue->ulErrorLocator;
        pTableNode->value.pdbtxtValue->ulTokenLength = pTableNodeSrc->value.pdbtxtValue->ulTokenLength;
        break;

    case DBVALUEKIND_BSTR:
        assert(!"HrQeTreeCopy:BSTR not implemented");
        break;

    case DBVALUEKIND_VARIANT:
        PropVariantCopy((PROPVARIANT*)pTableNode->value.pvValue,
                        (PROPVARIANT*)pTableNodeSrc->value.pvValue);
        break;
        
    case DBVALUEKIND_VECTOR:
    case DBVALUEKIND_ARRAY:
    case DBVALUEKIND_BYREF:
        assert(!"HrQeTreeCopy:Vector,Array,Byref not implemented");
        break;

    case DBVALUEKIND_GUID:
        *(pTableNode->value.pGuid) = *(pTableNodeSrc->value.pGuid);
        break;

    case DBVALUEKIND_BYTES:
        assert(!"HrQeTreeCopy:bytes not implemented");
        break;

    case DBVALUEKIND_WSTR:
        pTableNode->value.pwszValue = CoTaskStrDup(pTableNodeSrc->value.pwszValue);
        break;
        
    // Copied as part of first 8 bytes
    case DBVALUEKIND_COMMAND:
    case DBVALUEKIND_MONIKER:
    case DBVALUEKIND_ROWSET:
    case DBVALUEKIND_IDISPATCH:
    case DBVALUEKIND_IUNKNOWN:
    //NYI : rossbu (6/29/95) -- AddRef interfaces on copy
    case DBVALUEKIND_EMPTY:
    case DBVALUEKIND_NULL:
    case DBVALUEKIND_I2:
    case DBVALUEKIND_I4:
    case DBVALUEKIND_R4:
    case DBVALUEKIND_R8:
    case DBVALUEKIND_CY:
    case DBVALUEKIND_DATE:
    
    // Copied as part of first 8 bytes
    case DBVALUEKIND_ERROR:
    case DBVALUEKIND_BOOL:

    // Copied as part of first 8 bytes
    case DBVALUEKIND_I1:
    case DBVALUEKIND_UI1:
    case DBVALUEKIND_UI2:
    case DBVALUEKIND_UI4:
    case DBVALUEKIND_I8:
    case DBVALUEKIND_UI8:
        //Copy the data values
        RtlCopyMemory(&(pTableNode->value), &(pTableNodeSrc->value),(sizeof pTableNode->value));
        break;
        
    default :
        Assert(FALSE);
        break;
    }

    hr = HrQeTreeCopy(&pTableNode->pctFirstChild, pTableNodeSrc->pctFirstChild);
    if (FAILED(hr))
        return ResultFromScode(hr);

    hr = HrQeTreeCopy(&pTableNode->pctNextSibling, pTableNodeSrc->pctNextSibling);
    if (FAILED(hr))
        return ResultFromScode(hr);

    *ppTableNodeDest = pTableNode;
    return ResultFromScode(hr);
}

// ----------------------------------------------------------------------------
// 
//  Method:     SetDepthAndInclusion
//
//  Synopsis:   Walks through the list of scopes and applies the scope
//              information provided by pctInfo to each node.
//
//  Arguments:  [pctInfo]     -- a node with deep/shallow, include/exclude info 
//              [pctScpList]  -- a list of scope_list_element nodes
// 
//  History:    07-25-98    danleg          Created
//
// ----------------------------------------------------------------------------

void SetDepthAndInclusion( 
    DBCOMMANDTREE * pctInfo,
    DBCOMMANDTREE * pctScpList )
{
    Assert( 0 != pctInfo && NULL != pctScpList );

    DBCOMMANDTREE* pct = pctScpList;
    while( NULL != pct )
    {
        pct->value.pdbcntntscpValue->dwFlags |= 
            (pctInfo->value.pdbcntntscpValue->dwFlags & (SCOPE_FLAG_MASK));

        pct = pct->pctNextSibling;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DEBUG OUTPUT////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG



/* 
** DBOP to string map.  Used to dump name rather than op # in OLE-DB tree nodes 
** This map should be kept consistent with the OLE-DB op definitions since there
** is a one to one mapping.
*/
LPSTR mpoplpstr[] = {
    "DBOP_scalar_constant",
    "DBOP_DEFAULT",
    "DBOP_NULL",
    "DBOP_bookmark_name",
    "DBOP_catalog_name",
    "DBOP_column_name",
    "DBOP_schema_name",
    "DBOP_outall_name",
    "DBOP_qualifier_name",
    "DBOP_qualified_column_name",
    "DBOP_table_name",
    "DBOP_nested_table_name",
    "DBOP_nested_column_name",
    "DBOP_row",
    "DBOP_table",
    "DBOP_sort",
    "DBOP_distinct",
    "DBOP_distinct_order_preserving",
    "DBOP_alias",
    "DBOP_cross_join",
    "DBOP_union_join",
    "DBOP_inner_join",
    "DBOP_left_semi_join",
    "DBOP_right_semi_join",
    "DBOP_left_anti_semi_join",
    "DBOP_right_anti_semi_join",
    "DBOP_left_outer_join",
    "DBOP_right_outer_join",
    "DBOP_full_outer_join",
    "DBOP_natural_join",
    "DBOP_natural_left_outer_join",
    "DBOP_natural_right_outer_join",
    "DBOP_natural_full_outer_join",
    "DBOP_set_intersection",
    "DBOP_set_union",
    "DBOP_set_left_difference",
    "DBOP_set_right_difference",
    "DBOP_set_anti_difference",
    "DBOP_bag_intersection",
    "DBOP_bag_union",
    "DBOP_bag_left_difference",
    "DBOP_bag_right_difference",
    "DBOP_bag_anti_difference",
    "DBOP_division",
    "DBOP_relative_sampling",
    "DBOP_absolute_sampling",
    "DBOP_transitive_closure",
    "DBOP_recursive_union",
    "DBOP_aggregate",
    "DBOP_remote_table",
    "DBOP_select",
    "DBOP_order_preserving_select",
    "DBOP_project",
    "DBOP_project_order_preserving",
    "DBOP_top",
    "DBOP_top_percent",
    "DBOP_top_plus_ties",
    "DBOP_top_percent_plus_ties",
    "DBOP_rank",
    "DBOP_rank_ties_equally",
    "DBOP_rank_ties_equally_and_skip",
    "DBOP_navigate",
    "DBOP_nesting",
    "DBOP_unnesting",
    "DBOP_nested_apply",
    "DBOP_cross_tab",
    "DBOP_is_NULL",
    "DBOP_is_NOT_NULL",
    "DBOP_equal",
    "DBOP_not_equal",
    "DBOP_less",
    "DBOP_less_equal",
    "DBOP_greater",
    "DBOP_greater_equal",
    "DBOP_equal_all",
    "DBOP_not_equal_all",
    "DBOP_less_all",
    "DBOP_less_equal_all",
    "DBOP_greater_all",
    "DBOP_greater_equal_all",
    "DBOP_equal_any",
    "DBOP_not_equal_any",
    "DBOP_less_any",
    "DBOP_less_equal_any",
    "DBOP_greater_any",
    "DBOP_greater_equal_any",
    "DBOP_anybits",
    "DBOP_allbits",
    "DBOP_anybits_any",
    "DBOP_allbits_any",
    "DBOP_anybits_all",
    "DBOP_allbits_all",
    "DBOP_between",
    "DBOP_between_unordered",
    "DBOP_match",
    "DBOP_match_unique",
    "DBOP_match_partial",
    "DBOP_match_partial_unique",
    "DBOP_match_full",
    "DBOP_match_full_unique",
    "DBOP_scalar_parameter",
    "DBOP_scalar_function",
    "DBOP_plus",
    "DBOP_minus",
    "DBOP_times",
    "DBOP_over",
    "DBOP_div",
    "DBOP_modulo",
    "DBOP_power",
    "DBOP_like",
    "DBOP_sounds_like",
    "DBOP_like_any",
    "DBOP_like_all",
    "DBOP_is_INVALID",
    "DBOP_is_TRUE",
    "DBOP_is_FALSE",
    "DBOP_and",
    "DBOP_or",
    "DBOP_xor",
    "DBOP_equivalent",
    "DBOP_not",
    "DBOP_implies",
    "DBOP_overlaps",
    "DBOP_case_condition",
    "DBOP_case_value",
    "DBOP_nullif",
    "DBOP_cast",
    "DBOP_coalesce",
    "DBOP_position",
    "DBOP_extract",
    "DBOP_char_length",
    "DBOP_octet_length",
    "DBOP_bit_length",
    "DBOP_substring",
    "DBOP_upper",
    "DBOP_lower",
    "DBOP_trim",
    "DBOP_translate",
    "DBOP_convert",
    "DBOP_string_concat",
    "DBOP_current_date",
    "DBOP_current_time",
    "DBOP_current_timestamp",
    "DBOP_content_select",
    "DBOP_content",
    "DBOP_content_freetext",
    "DBOP_content_proximity",
    "DBOP_content_vector_or",
    "DBOP_delete",
    "DBOP_update",
    "DBOP_insert",
    "DBOP_min",
    "DBOP_max",
    "DBOP_count",
    "DBOP_sum",
    "DBOP_avg",
    "DBOP_any_sample",
    "DBOP_stddev",
    "DBOP_stddev_pop",
    "DBOP_var",
    "DBOP_var_pop",
    "DBOP_first",
    "DBOP_last",
    "DBOP_in",
    "DBOP_exists",
    "DBOP_unique",
    "DBOP_subset",
    "DBOP_proper_subset",
    "DBOP_superset",
    "DBOP_proper_superset",
    "DBOP_disjoint",
    "DBOP_pass_through",
    "DBOP_defined_by_GUID",
    "DBOP_text_command",
    "DBOP_SQL_select",
    "DBOP_prior_command_tree",
    "DBOP_add_columns",
    "DBOP_column_list_anchor",
    "DBOP_column_list_element",
    "DBOP_command_list_anchor",
    "DBOP_command_list_element",
    "DBOP_from_list_anchor",
    "DBOP_from_list_element",
    "DBOP_project_list_anchor", 
    "DBOP_project_list_element",
    "DBOP_row_list_anchor",
    "DBOP_row_list_element",
    "DBOP_scalar_list_anchor",  
    "DBOP_scalar_list_element",
    "DBOP_set_list_anchor",
    "DBOP_set_list_element",
    "DBOP_sort_list_anchor",
    "DBOP_sort_list_element",
    "DBOP_alter_character_set", 
    "DBOP_alter_collation",
    "DBOP_alter_domain",
    "DBOP_alter_index",
    "DBOP_alter_procedure",
    "DBOP_alter_schema",
    "DBOP_alter_table",
    "DBOP_alter_trigger",
    "DBOP_alter_view",
    "DBOP_coldef_list_anchor",
    "DBOP_coldef_list_element",
    "DBOP_create_assertion",
    "DBOP_create_character_set",
    "DBOP_create_collation",
    "DBOP_create_domain",
    "DBOP_create_index",
    "DBOP_create_procedure",
    "DBOP_create_schema",
    "DBOP_create_synonym",
    "DBOP_create_table",
    "DBOP_create_temporary_tab",
    "DBOP_create_translation",
    "DBOP_create_trigger",
    "DBOP_create_view",
    "DBOP_drop_assertion",
    "DBOP_drop_character_set",
    "DBOP_drop_collation",
    "DBOP_drop_domain",
    "DBOP_drop_index",
    "DBOP_drop_procedure",
    "DBOP_drop_schema",
    "DBOP_drop_synonym",
    "DBOP_drop_table",
    "DBOP_drop_translation",
    "DBOP_drop_trigger",
    "DBOP_drop_view",
    "DBOP_foreign_key", 
    "DBOP_grant_privileges",
    "DBOP_index_list_anchor",
    "DBOP_index_list_element",
    "DBOP_primary_key",
    "DBOP_property_list_anchor",
    "DBOP_property_list_element",
    "DBOP_referenced_table",
    "DBOP_rename_object",
    "DBOP_revoke_privileges",
    "DBOP_schema_authorization",
    "DBOP_unique_key",
    "DBOP_scope_list_anchor",
    "DBOP_scope_list_element",
    "DBOP_content_table",
    NULL,   // needed for DBOP_from_string (able to find the end of the list)
   };

int indentLevel=0;


//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given GUID node into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream &osOut, //@parm INOUT   | ostream in which node is to be placed.
    GUID    guid    //@parm IN      | DBID node to dump.
    )
    {
    osOut.setf(ios::hex,ios::basefield);
    osOut << guid.Data1 << "-" << guid.Data2 << "-" << guid.Data3 << "-";
    
    for (int i=0; i<8; i++)
        osOut << (unsigned int)guid.Data4[i] << " ";
    osOut.setf(ios::dec,ios::basefield);
    return osOut;
    }



//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given DBID node into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream             &osOut,     //@parm INOUT   | ostream in which node is to be placed.
    VARIANT __RPC_FAR   *pvarValue  //@parm IN      | DBID node to dump.
    )
    {
    switch (pvarValue->vt)
        {
        case VT_EMPTY:
            osOut << "VT_EMPTY" << endl;
            break;
                    
        case VT_NULL:
            osOut << "VT_NULL" << endl;
            break;
                    
        case VT_UI1:
            osOut << "VT_UI1 = " << pvarValue->bVal << endl;
            break;
                    
        case VT_I2:
            osOut << "VT_I2 = " << pvarValue->iVal << endl;
            break;
                    
        case VT_UI2:
            osOut << "VT_UI2 = " << pvarValue->uiVal << endl;
            break;
                    
        case VT_BOOL:
            if (VARIANT_TRUE == pvarValue->boolVal)
                osOut << "VT_BOOL = TRUE" << endl;
            else
                osOut << "VT_BOOL = FALSE" << endl;
            break;

        case VT_I4:
            osOut << "VT_I4 = " << pvarValue->lVal << endl;
            break;
                    
        case VT_UI4:
            osOut << "VT_UI4 = " << pvarValue->ulVal << endl;
            break;
                    
        case VT_I8:
            {
            WCHAR pwszI8[20];
            swprintf(pwszI8, L"%I64d", ((PROPVARIANT*)pvarValue)->hVal);
            osOut << "VT_I8 = " << pwszI8 << endl;
            }
            break;
                    
        case VT_UI8:
            {
            WCHAR pwszUI8[20];
            swprintf(pwszUI8, L"%I64u (%I64x)",
                    ((PROPVARIANT*)pvarValue)->uhVal,
                    ((PROPVARIANT*)pvarValue)->uhVal);
            osOut << "VT_UI8 = " << pwszUI8 << endl;
            }
            break;
                    
        case VT_R4:
            osOut << "VT_R4 = " << pvarValue->fltVal << endl;
            break;
                    
        case VT_R8:
            osOut << "VT_R8 = " << pvarValue->dblVal << endl;
            break;
                    
        case VT_CY:
            {
            WCHAR pwszI8[20];
            swprintf(pwszI8, L"%I64d", ((PROPVARIANT*)pvarValue)->cyVal);
            osOut << "VT_CY = " << pwszI8 << endl;
            }
            break;
                    
        case VT_DATE:
            {
            BSTR bstrVal = NULL;
            HRESULT hr = VarBstrFromDate(pvarValue->date , LOCALE_SYSTEM_DEFAULT, 0, &bstrVal);

            osOut << "VT_DATE = \"" << (LPWSTR)bstrVal << "\"" << endl;
            SysFreeString(bstrVal);
            }
            break;
                    
        case VT_CLSID:
            osOut << "VT_CLSID = " << ((PROPVARIANT*)pvarValue)->puuid << "  " 
                  << *((PROPVARIANT*)pvarValue)->puuid << endl;
            break;
                    
        case VT_BSTR:
            osOut << "VT_BSTR = \"" << pvarValue->bstrVal << "\"" << endl;
            break;
                    
        case VT_LPSTR:
            osOut << "VT_LPSTR (tagDBVARIANT) = \"" << ((PROPVARIANT*)pvarValue)->pszVal << "\"" << endl;
            break;
                    
        case VT_LPWSTR:
            osOut << "VT_LPWSTR (tagDBVARIANT) = \"" << ((PROPVARIANT*)pvarValue)->pwszVal << "\"" << endl;
            break;
                    
        case VT_FILETIME:
            {
            SYSTEMTIME systemTime;
            FileTimeToSystemTime(&(((PROPVARIANT*)pvarValue)->filetime),&systemTime);
            osOut << "VT_FILETIME  (tagPROPVARIANT)  = \"" << systemTime.wYear << "-" << 
                     systemTime.wMonth << "-" << systemTime.wDay << "  " <<
                     systemTime.wHour << ":" <<  systemTime.wMinute << ":" << 
                     systemTime.wSecond << "." << systemTime.wMilliseconds << endl;
            }
            break;

        case (VT_UI1|VT_VECTOR):
            {
            osOut << "VT_UI1|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caub.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caub.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->caub.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_I2|VT_VECTOR):
            {
            osOut << "VT_I2|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cai.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cai.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cai.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_UI2|VT_VECTOR):
            {
            osOut << "VT_UI2|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caui.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caui.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->caui.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_BOOL|VT_VECTOR):
            {
            osOut << "VT_BOOL|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cabool.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cabool.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cabool.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_I4|VT_VECTOR):
            {
            osOut << "VT_I4|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cal.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cal.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cal.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_UI4|VT_VECTOR):
            {
            osOut << "VT_UI4|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caul.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caul.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->caul.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_R4|VT_VECTOR):
            {
            osOut << "VT_R4|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caflt.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caflt.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->caflt.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_ERROR|VT_VECTOR):
            {
            osOut << "VT_ERROR|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cascode.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cascode.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cascode.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_I8|VT_VECTOR):
            {
            osOut << "VT_I8|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cah.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cah.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->cah.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_UI8|VT_VECTOR):
            {
            osOut << "VT_UI8|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cauh.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cauh.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->cauh.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_R8|VT_VECTOR):
            {
            osOut << "VT_R8|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cadbl.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cadbl.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cadbl.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_CY|VT_VECTOR):
            {
            osOut << "VT_CY|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cacy.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cacy.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->cacy.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_DATE|VT_VECTOR):
            {
            osOut << "VT_DATE|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cadate.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cadate.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cadate.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_FILETIME|VT_VECTOR):
            {
            osOut << "VT_FILETIME|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cafiletime.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cafiletime.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->cafiletime.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_CLSID|VT_VECTOR):
            {
            osOut << "VT_CLSID|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cauuid.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cauuid.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cauuid.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_CF|VT_VECTOR):
            {
            osOut << "VT_CF|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caclipdata.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caclipdata.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->caclipdata.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_BSTR|VT_VECTOR):
            {
            osOut << "VT_BSTR|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cabstr.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cabstr.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cabstr.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_LPSTR|VT_VECTOR):
            {
            osOut << "VT_LPSTR|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->calpstr.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->calpstr.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->calpstr.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_LPWSTR|VT_VECTOR):
            {
            osOut << "VT_LPWSTR|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->calpwstr.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->calpwstr.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->calpwstr.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_VARIANT|VT_VECTOR):
            {
            osOut << "VT_VARIANT|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->capropvar.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->capropvar.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->capropvar.pElems[i];
            osOut << endl;
            }
            break;

        default:
            osOut << "type :" << pvarValue->vt << endl;
            break;
        }
    return osOut;
    }


//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given DBID node into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream         &osOut, //@parm INOUT   | ostream in which node is to be placed.
    DBID __RPC_FAR *pdbid   //@parm IN      | DBID node to dump.
    )
    {
    osOut << endl;
    switch (pdbid->eKind)
        {
        case DBKIND_NAME:
            osOut << INDENTLINE << "\t\tpwszName: " << pdbid->uName.pwszName << endl;
            break;
        case DBKIND_GUID:
            osOut << INDENTLINE << "\t\tguid: "<< pdbid->uGuid.guid << endl;
            break;
        case DBKIND_GUID_NAME:
            osOut << INDENTLINE << "\t\tguid: "<< pdbid->uGuid.guid << endl;
            osOut << INDENTLINE << "\t\tpwszName: " << pdbid->uName.pwszName << endl;
            break;
        case DBKIND_GUID_PROPID:
            osOut << INDENTLINE << "\t\tguid: "<< pdbid->uGuid.guid << endl;
            osOut << INDENTLINE << "\t\tulPropid: " << pdbid->uName.ulPropid << endl;
            break;
        case DBKIND_PGUID_NAME:
            osOut << INDENTLINE << "\t\tpguid: "<< (void*)pdbid->uGuid.pguid << "  " << *pdbid->uGuid.pguid << endl;
            osOut << INDENTLINE << "\t\tpwszName: " << pdbid->uName.pwszName << endl;
            break;
        case DBKIND_PGUID_PROPID:
            osOut << INDENTLINE << "\t\tpguid: "<< (void*)pdbid->uGuid.pguid << "  " << *pdbid->uGuid.pguid << endl;
            osOut << INDENTLINE << "\t\tulPropid: " << pdbid->uName.ulPropid << endl;
            break;
        default:
            Assert(0);
        }
    return osOut;
    }



//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given DBCONTENTVECTOR node into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream         &osOut,                     //@parm INOUT   | ostream in which node is to be placed.
    DBCONTENTVECTOR __RPC_FAR *pdbcntntvcValue  //@parm IN      | DBCONTENTVECTOR node to dump.
    )
    {
    osOut << endl << INDENTLINE << "\t\tdwRankingMethod " << pdbcntntvcValue->dwRankingMethod;
    switch(pdbcntntvcValue->dwRankingMethod)
        {
        case VECTOR_RANK_MIN:
            osOut << " VECTOR_RANK_MIN" << endl;
            break;
        case VECTOR_RANK_MAX:
            osOut << " VECTOR_RANK_MAX" << endl;
            break;
        case VECTOR_RANK_INNER:
            osOut << " VECTOR_RANK_INNER" << endl;
            break;
        case VECTOR_RANK_DICE:
            osOut << " VECTOR_RANK_DICE" << endl;
            break;
        case VECTOR_RANK_JACCARD:
            osOut << " VECTOR_RANK_JACCARD" << endl;
            break;
        }
    osOut << endl;
    return osOut;
    }


//--------------------------------------------------------------------
//@func:(DEBUG) ostream& | operator shift-left |
//   Dumps the given DBCOMMANDTREE node into the given ostream.
//@rdesc ostream
//
ostream & operator <<
    (
    ostream &osOut, //@parm INOUT   | ostream in which node is to be placed.
    DBCOMMANDTREE &qt   //@parm IN  | OLE-DB node to dump.
    )
    {
    DBCOMMANDTREE *pTableNodeT = NULL;

    osOut << INDENTLINE << "Node" << &qt << endl;
    osOut << INDENTLINE << "{" << endl;
    osOut << INDENTLINE << "\tOP = " << mpoplpstr[qt.op] << "  // Enum value: " << (USHORT) qt.op  << endl;
//  osOut << INDENTLINE << "\tError = " << qt.hrError << endl;
    if (qt.pctFirstChild)
        osOut << INDENTLINE << "\tpctFirstChild =  " << qt.pctFirstChild << endl;
    if (qt.pctNextSibling)
        osOut << INDENTLINE << "\tpctNextSibling = " << qt.pctNextSibling << endl;

    switch(qt.wKind)
        {
        case DBVALUEKIND_BYGUID:
            osOut << INDENTLINE << "\twKind : BYGUID" << endl;
            osOut << INDENTLINE << "\tcbInfo:" << qt.value.pdbbygdValue->cbInfo << endl;
            osOut << INDENTLINE << "\tpbInfo:" << (VOID*)qt.value.pdbbygdValue->pbInfo << endl;
            osOut << INDENTLINE << "\tguid:" << qt.value.pdbbygdValue->guid << endl;
            break;

        case DBVALUEKIND_ID:
            osOut << INDENTLINE << "\twKind : ID " << qt.value.pdbidValue <<endl;
            break;

        case DBVALUEKIND_CONTENT:
            osOut << INDENTLINE << "\twKind : CONTENT " << qt.value.pdbcntntValue <<endl;
            osOut << INDENTLINE << "\t\tpwszPhrase \"" << qt.value.pdbcntntValue->pwszPhrase << "\"" << endl;
            osOut << INDENTLINE << "\t\tdwGenerateMethod " << qt.value.pdbcntntValue->dwGenerateMethod;
            switch(qt.value.pdbcntntValue->dwGenerateMethod)
                {
                    case GENERATE_METHOD_EXACT:
                        osOut << " GENERATE_METHOD_EXACT" << endl;
                        break;
                    case GENERATE_METHOD_PREFIX:
                        osOut << " GENERATE_METHOD_PREFIX" << endl;
                        break;
                    case GENERATE_METHOD_INFLECT:
                        osOut << " GENERATE_METHOD_INFLECT" << endl;
                        break;
                }
            osOut << INDENTLINE << "\t\tlWeight " << qt.value.pdbcntntValue->lWeight << endl;
            osOut << INDENTLINE << "\t\tlcid " << qt.value.pdbcntntValue->lcid << endl;
            break;

        case DBVALUEKIND_CONTENTSCOPE:
            osOut << INDENTLINE << "\tdwFlags" << endl;
            osOut << INDENTLINE << "\t\tInclude = " << (qt.value.pdbcntntscpValue->dwFlags & SCOPE_FLAG_INCLUDE) << endl;
            osOut << INDENTLINE << "\t\tDeep = " << (qt.value.pdbcntntscpValue->dwFlags & SCOPE_FLAG_DEEP) << endl;
            osOut << INDENTLINE << "\t\tType = " << (qt.value.pdbcntntscpValue->dwFlags & ~SCOPE_FLAG_MASK);
            switch (qt.value.pdbcntntscpValue->dwFlags & ~(SCOPE_FLAG_MASK) )
                {
                    case SCOPE_TYPE_WINPATH:
                        osOut << " SCOPE_TYPE_WINPATH" << endl;
                        break;
                    case SCOPE_TYPE_VPATH:
                        osOut << " SCOPE_TYPE_VPATH" << endl;
                        break;
                    default:
                        osOut << " Unknown type" << endl;
                        break;
                }
            osOut << INDENTLINE << "\tpwszElementValue = " << qt.value.pdbcntntscpValue->pwszElementValue << endl;
            break;

        case DBVALUEKIND_CONTENTTABLE:
            osOut << INDENTLINE << "\tpwszMachine = " << qt.value.pdbcntnttblValue->pwszMachine << endl;
            osOut << INDENTLINE << "\tpwszCatalog = " << qt.value.pdbcntnttblValue->pwszCatalog << endl;
            break;

        case DBVALUEKIND_LIKE:
            osOut << INDENTLINE << "\twKind : LIKE " << qt.value.pdblikeValue << endl;
            break;

        case DBVALUEKIND_CONTENTPROXIMITY:
            osOut << INDENTLINE << "\twKind : CONTENTPROXIMITY " << qt.value.pdbcntntproxValue << endl;
            osOut << INDENTLINE << "\t\tProximityUnit: " << qt.value.pdbcntntproxValue->dwProximityUnit << endl;
            osOut << INDENTLINE << "\t\tProximityDistance: " << qt.value.pdbcntntproxValue->ulProximityDistance << endl;
            osOut << INDENTLINE << "\t\tlWeight: " << qt.value.pdbcntntproxValue->lWeight << endl;
            break;
        case DBVALUEKIND_CONTENTVECTOR:
            osOut << INDENTLINE << "\twKind : CONTENTVECTOR " << qt.value.pdbcntntvcValue <<endl;
            break;

        case DBVALUEKIND_GROUPINFO:
            osOut << INDENTLINE << "\twKind : GROUPINFO" << endl;
            osOut << INDENTLINE << "\tlcid : " << (long)qt.value.pdbgrpinfValue->lcid << endl;
            break;

        case DBVALUEKIND_PROPERTY:
            osOut << "\twKind : PROPERTY" << endl;

        case DBVALUEKIND_SORTINFO:
            osOut << INDENTLINE << "\twKind : sort info" << endl;
            osOut << INDENTLINE << "\tlcid : " << (long)qt.value.pdbsrtinfValue->lcid << endl;
            osOut << INDENTLINE << "\tsort direction : ";
            if (TRUE == qt.value.pdbsrtinfValue->fDesc)
                osOut << "Desc" << endl;
            else 
                osOut << "Asc" << endl;
            break;

        case DBVALUEKIND_TEXT:
            osOut << INDENTLINE << "//\twKind : TEXT" << endl;
            osOut << INDENTLINE << "\t\t dialect guid: " << qt.value.pdbtxtValue->guidDialect << endl;
            osOut << INDENTLINE << "\t\tpwszText : " << qt.value.pdbtxtValue->pwszText << endl;
            break;

        case DBVALUEKIND_COMMAND:
        case DBVALUEKIND_MONIKER:
        case DBVALUEKIND_ROWSET:
        case DBVALUEKIND_IDISPATCH:
        case DBVALUEKIND_IUNKNOWN:
            assert(!"operator << for DBCOMMANDTREE: no COMMAND-UNKNOWN not implemented");
            break;

        case DBVALUEKIND_EMPTY:
            osOut << INDENTLINE << "\twKind = empty" << endl;
            break;
        case DBVALUEKIND_NULL:
        case DBVALUEKIND_I2:
            osOut << INDENTLINE << "\twKind = I2" << endl;
            osOut << INDENTLINE << "\t\t sValue = " << qt.value.sValue << endl;
            break;
        case DBVALUEKIND_I4:
            osOut << INDENTLINE << "\twKind = I4" << endl;
            osOut << INDENTLINE << "\t\t lValue = " << qt.value.lValue << endl;
            break;
        case DBVALUEKIND_R4:
            osOut << INDENTLINE << "\twKind = R4" << endl;
            osOut << INDENTLINE << "\t\t flValue = " << qt.value.flValue << endl;
            break;
        case DBVALUEKIND_R8:
            osOut << INDENTLINE << "\twKind = R8" << endl;
            osOut << INDENTLINE << "\t\t dblValue = " << qt.value.dblValue << endl;
            break;
        case DBVALUEKIND_CY:
            osOut << INDENTLINE << "\twKind = CY" << endl;
            assert(!"Printing Currency values not implemented");
//          osOut << "\t\t cyValue = " << qt.value.cyValue << endl;
            break;
        case DBVALUEKIND_DATE:
            osOut << INDENTLINE << "\twKind = DATE" << endl;
            osOut << INDENTLINE << "\t\t dateValue = " << qt.value.dateValue << endl;
            break;
        case DBVALUEKIND_BSTR:
            osOut << INDENTLINE << "\twKind = BSTR" << endl;
            osOut << INDENTLINE << "\t\t pbstrValue = " << qt.value.pbstrValue << endl;
            break;
        case DBVALUEKIND_ERROR:
            osOut << INDENTLINE << "\twKind = ERROR" << endl;
            osOut << INDENTLINE << "\t\t scodeValue = " << qt.value.scodeValue << endl;
            break;
        case DBVALUEKIND_BOOL:
            osOut << INDENTLINE << "\twKind = BOOL" << endl;
            osOut << INDENTLINE << "\t\t fValue = " << qt.value.fValue << endl;
            break;
        case DBVALUEKIND_VARIANT:
            osOut << INDENTLINE << "\twKind : VARIANT " << qt.value.pvarValue << endl;
            break;
        case DBVALUEKIND_VECTOR:
            osOut << INDENTLINE << "\twKind = VECTOR" << endl;
            osOut << INDENTLINE << "\t\t pdbvectorValue = " << qt.value.pdbvectorValue << endl;
            break;
        case DBVALUEKIND_ARRAY:
            osOut << INDENTLINE << "\twKind = ARRAY" << endl;
            osOut << "\t\t parrayValue = " << qt.value.parrayValue << endl;
            break;
        case DBVALUEKIND_BYREF:
            osOut << INDENTLINE << "\twKind = BYREF" << endl;
            osOut << INDENTLINE << "\t\t pvValue = " << qt.value.pvValue << endl;
            break;
        
        case DBVALUEKIND_I1:
            osOut << INDENTLINE << "\twKind = I1" << endl;
            osOut << INDENTLINE << "\t\t bValue = " << qt.value.schValue << endl;
            break;
        case DBVALUEKIND_UI1:
            osOut << INDENTLINE << "\twKind = UI1" << endl;
            osOut << INDENTLINE << "\t\t bValue = " << qt.value.uchValue << endl;
            break;
        case DBVALUEKIND_UI2:
            osOut << INDENTLINE << "\twKind = UI2" << endl;
            osOut << INDENTLINE << "\t\t sValue = " << qt.value.sValue << endl;
            break;
        case DBVALUEKIND_UI4:
            osOut << INDENTLINE << "\twKind = UI4" << endl;
            osOut << INDENTLINE << "\t\t ulValue = " << qt.value.ulValue << endl;
            break;
        case DBVALUEKIND_I8:
            osOut << INDENTLINE << "\twKind = I8" << endl;
            assert(!"llValue printing not supported");
            break;
        case DBVALUEKIND_UI8:
            osOut << INDENTLINE << "\twKind = UI8" << endl;
            assert(!"ullValue printing not supported");
            break;
        case DBVALUEKIND_GUID:
            osOut << INDENTLINE << "\twKind = GUID" << endl;
            osOut << INDENTLINE << "\t\t pGuid = " << qt.value.pGuid << endl;
            break;
        case DBVALUEKIND_BYTES:
            osOut << INDENTLINE << "\twKind = BYTES" << endl;
            osOut << INDENTLINE << "\t\t pbValue = " << qt.value.pbValue << endl;
            break;
        case DBVALUEKIND_WSTR:
            osOut << INDENTLINE << "\twKind = WSTR" << endl;
            osOut << INDENTLINE << "\t pwszValue = " << (void*) qt.value.pwszValue 
                    << " : " << qt.value.pwszValue << endl;
            break;
        case DBVALUEKIND_NUMERIC:
            osOut << INDENTLINE << "\twKind = NUMERIC" << endl;
            osOut << INDENTLINE << "\t\t pdbnValue = " << qt.value.pdbnValue << endl;
            break;
        default :
            osOut << INDENTLINE << "\twKind = UNKNOWN " << (UINT) qt.wKind << endl;
            assert(FALSE);
            break;
        }
    
//  short cnt;
//  for (cnt = 0, pTableNodeT = qt.pctFirstChild; pTableNodeT != NULL; pTableNodeT = pTableNodeT->pctNextSibling, cnt++)
//      {
//      osOut << INDENTLINE << "\tinput[" << cnt << "]: " << endl;
//      osOut << INDENTLINE << "\t\tchild = " << "Node" << pTableNodeT << endl;
//      }
    
    osOut << INDENTLINE << "}" << endl << endl;

    indentLevel++;
    for (pTableNodeT = qt.pctFirstChild; pTableNodeT != NULL; pTableNodeT = pTableNodeT->pctNextSibling)
        osOut << *pTableNodeT;
    indentLevel--;

    return osOut;
    }


#endif //DEBUG
/////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DEBUG OUTPUT////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\sqltext\yypars.hpp ===
// Notes: The parser is embodied/encapsulated in the class YYPARSER. Given a 
// <grammar>.y the C++ YACC generates a YYPARSER object along with the needed 
// parse tables as static data members. To create a parser object is as simple 
// as creating an object of class YYPARSER. The YYPARSER code now is 
// automatically re-entrant.

#ifndef YYPARS_INCLUDED
#define YYPARS_INCLUDED


#ifdef UNICODE
#define yyitos  _itow
#else
#define yyitos  _itoa
#endif


#ifndef YYAPI_PACKAGE
# define YYAPI_TOKENNAME        yychar          //name used for return value of yylex   
# define YYAPI_TOKENTYPE        int             //type of the token
# define YYAPI_TOKENEME(t)      (t)             //the value of the token that the parser should see
# define YYAPI_TOKENNONE        -2              //the representation when there is no token
# define YYAPI_TOKENSTR(t)      (yyitos(t,yyitoa,10))       //string representation of the token
# define YYAPI_VALUENAME        yylval          //the name of the value of the token
# define YYAPI_VALUETYPE        YYSTYPE         //the type of the value of the token (if null, then the value is derivable from the token itself)
# define YYAPI_VALUEOF(v)       (v)             //how to get the value of the token
# define YYAPI_CALLAFTERYYLEX(t)                //
# define YYAPI_PACKAGE                          //package is in use
#endif  // YYAPI_PACKAGE

#ifndef YYPARSER
# define YYPARSER               yyparse
#endif
#ifndef YYLEX
# define YYLEX                  yylex
#endif
#ifndef YYPARSEPROTO
# define YYPARSEPROTO 
#endif
#ifndef YYSTYPE
# define YYSTYPE                int
#endif

#define yyerrok                 ClearErrRecoveryState()     //provided for compatibility with YACC
#define yyclearin               YYAPI_TOKENNAME = YYAPI_TOKENNONE

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif

#ifndef YYR_T
#define YYR_T   int
typedef YYR_T   yyr_t;
#endif


class CImpIParserSession;
class CImpIParserTreeProperties;

class YYPARSER {
    friend class YYLEXER;
// ctor & dtor
public: 
    YYPARSER(CImpIParserSession* pParserSession, CImpIParserTreeProperties* pParserTreeProperties);
    ~YYPARSER();

// Public interface
public:
    void ResetParser();     //use to possibly restart parser
    HRESULT Parse(YYPARSEPROTO);            //bread and butter function

// Public interface that's reluctantly provided
public:
    int NoOfErrors();                   //current count of parsing errors
    int ErrRecoveryState();             //error recovery state.
    void ClearErrRecoveryState();       //error recovery is complete. 

#ifdef YYAPI_VALUETYPE                  
    YYAPI_VALUETYPE GetParseTree()      // Get result of parse
        {
        return /*YYAPI_VALUENAME*/yyval;
        };
#endif

    YYAPI_TOKENTYPE GetCurrentToken();              //current token seen by the parser. 
    void SetCurrentToken(YYAPI_TOKENTYPE newToken); //change current token. 
    void YYPARSER::yySetBuffer(short iBuffer, YY_CHAR *szValue);
    YY_CHAR *YYPARSER::yyGetBuffer(short iBuffer);
    void yyprimebuffer(YY_CHAR *pszBuffer);
    void yyprimelexer(int eToken);
    void EmptyValueStack();
    HRESULT CoerceScalar(DBTYPE dbTypeExpected, DBCOMMANDTREE** ppct);



// private data
private:
    int yyn;
    int yychar1;        /*  lookahead token as an internal (translated) token number */
    short   yyssa[YYMAXDEPTH];  /*  the state stack         */
    YYSTYPE yyvsa[YYMAXDEPTH];  /*  the semantic value stack        */
    short *yyss;                /*  refer to the stacks thru separate pointers */
    YYSTYPE *yyvs;              /*  to allow yyoverflow to reallocate them elsewhere */
    int yystacksize;
    int yynerrs;

    YYSTYPE yyval;/*  the variable used to return       */
                /*  semantic values from the action */
                /*  routines                */
    int yylen;


    YYAPI_TOKENTYPE YYAPI_TOKENNAME;    //current input token
 #ifdef YYAPI_VALUETYPE                 
    //could be defined as attribute of the token; In this case.
    //YYAPI_TOKENNAME and YYAPI_VALUENAME must match.
    YYAPI_VALUETYPE YYAPI_VALUENAME;    //value of current input token
 #endif
    int yyerrflag;                      //error recovery flag
    int yyerrstatus;    /*  number of tokens to shift before error messages enabled */

// private pointer data
private:
    short yystate;                      //parse state
    short *yyssp;                       //state pointer
    YYSTYPE *yyvsp;                     //pointer to value of a state
    CImpIParserSession* m_pIPSession;   //all of the data necessary for this parser
    CImpIParserTreeProperties * m_pIPTProperties;

public:
    YYLEXER  m_yylex;                   // lexer object for this instance of parser

// private tables
private:
    //These may be allocated dynamically
    YY_CHAR yyitoa[20];                 // Buff to store text version of token

// debugging helpers
public:
//  ICommand* m_pICommand;              //command object
#ifdef YYDEBUG
    int yydebug;
#endif

private:
#ifdef YYDUMP
    void DumpYYS();
    void DumpYYV();
#endif

    void Trace(TCHAR *message);
    void Trace(TCHAR *message, const TCHAR *tokname, short state = 0);
    void Trace(TCHAR *message, int state, short tostate = 0, short token = 0);

private:
# define maxYYBuffer 5
    YY_CHAR *rgpszYYBuffer[maxYYBuffer];
};

#endif  // YYPARS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\txtfilt\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       exports.cxx
//
//  Contents:   Code to export filter and word breaker class factories
//
//  History:    15-Aug-1994     SitaramR   Created
//
//  Notes:      Copied from txtifilt.hxx and then modified
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <nullfilt.hxx>
#include <txtifilt.hxx>
#include <defbreak.hxx>
#include <classf.hxx>
#include <cicontrl.hxx>

#include "classid.hxx"

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter or a word breaker class factory
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown *  pResult;
    SCODE       sc      = S_OK;

    TRY
    {
        if ( CLSID_CTextIFilter == cid || CLSID_CTextClass == cid ) {
            
            pResult = (IUnknown *)new CTextIFilterCF;
        
        } else if ( CLSID_CNullIFilter == cid ) {
            
            pResult = (IUnknown *)new CNullIFilterCF;
        
        } else if ( CLSID_Neutral_WBreaker == cid ) {
            
            pResult = (IUnknown *)new CDefWordBreakerCF;
        
        } else if ( guidStorageFilterObject == cid) {
            
            pResult = (IUnknown *) new CStorageFilterObjectCF;
        
        } else if ( guidStorageDocStoreLocatorObject == cid) {
            
            pResult = (IUnknown *) new CStorageDocStoreLocatorObjectCF;
        
        } else if ( clsidCiControl == cid) {            
            pResult = (IUnknown *) new CCiControlObjectCF;
        } else {
            
            ciDebugOut(( DEB_ITRACE, "DllGetClassObject: no such interface found\n" ));
            pResult = 0;
            sc = E_NOINTERFACE;
        
        }
    }
    CATCH(CException, e)
    {
        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    if (0 != pResult) {
        sc = pResult->QueryInterface( iid, ppvObj );
        pResult->Release( );
    }

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( gulcInstances <= 0 )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\txtfilt\mmistrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mmistrm.hxx
//
//  Contents:   Memory Mapped IStream
//
//  Classes:    CMmIStream
//
//  History:    11-Feb-97 KyleP     Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmistrm.hxx>

unsigned const cbMaxMappable = 1024 * 1024;

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::CMMIStream, public
//
//  Synopsis:   Constructor
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

CMmIStream::CMmIStream()
        : _pStream( 0 ),
          _pBuf( 0 )
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::~CMMIStream, public
//
//  Synopsis:   Destructor
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

CMmIStream::~CMmIStream()
{
    Close();
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Open, public
//
//  Synopsis:   Opens a stream
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Open( IStream * pStream )
{
    Win4Assert( 0 == _pStream );
    Win4Assert( 0 == _pBuf );

    _pStream = pStream;
    _pStream->AddRef();

    //
    // Get stream stats.
    //

    SCODE sc = pStream->Stat( &_statstg, STATFLAG_NONAME );

    if ( FAILED(sc) )
    {
        THROW( CException( sc ) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Close, public
//
//  Synopsis:   Close a stream
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Close()
{
    if ( 0 != _pStream )
        _pStream->Release();

    delete [] _pBuf;

    _pStream = 0;
    _pBuf = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::MapAll, public
//
//  Synopsis:   Map all of a stream
//
//  Arguments:  [sbuf] -- Stream buffer to fill in
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::MapAll( CMmStreamBuf& sbuf )
{
    //
    // Only 'map' up to a reasonable size.
    //

    if ( 0 != SizeHigh() )
        THROW( CException( STATUS_SECTION_TOO_BIG ) );

    Map( sbuf, SizeLow(), 0, 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Map, public
//
//  Synopsis:   Map part of a stream
//
//  Arguments:  [sbuf]         -- Stream buffer to fill in
//              [cb]           -- Size to map
//              [offLow]       -- Offset in stream
//              [offHigh]      -- Offset in stream
//              [fMapForWrite] -- TRUE --> Writeable (invalid option here)
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Map ( CMmStreamBuf& sbuf,
                       ULONG cb,
                       ULONG offLow,
                       ULONG offHigh,
                       BOOL  fMapForWrite )
{
    //
    // Only 'map' up to a reasonable size.
    //

    if ( cb > cbMaxMappable )
        THROW( CException( STATUS_SECTION_TOO_BIG ) );

    //
    // Now, allocate the memory.
    //

    Win4Assert( 0 == _pBuf );
    _pBuf = new BYTE [ cb ];

    //
    // Then seek and read.
    //

    LARGE_INTEGER off = { offLow, offHigh };

    SCODE sc = _pStream->Seek( off,
                               STREAM_SEEK_SET,     // From beginning of file
                               0 );                 // Don't return new seek pointer

    if ( FAILED(sc) )
    {
        THROW( CException( sc ) );
    }

    ULONG cbRead = 0;

    sc = _pStream->Read( _pBuf, cb, &cbRead );

    if ( FAILED(sc) )
    {
        THROW( CException( sc ) );
    }

    if ( cb > cbRead )
    {
        THROW( CException( E_FAIL ) );
    }

    //
    // Finally, set up the buffer.
    //

    sbuf.SetBuf( _pBuf );
    sbuf.SetSize ( cbRead );
    sbuf.SetStream ( this );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Unmap, public
//
//  Synopsis:   Unmap stream
//
//  Arguments:  [sbuf]         -- Stream buffer to unmap
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Unmap ( CMmStreamBuf& sbuf )
{
    Win4Assert( sbuf.Get() == _pBuf );

    sbuf.SetBuf( 0 );
    sbuf.SetSize( 0 );

    delete [] _pBuf;
    _pBuf = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Flush, public
//
//  Synopsis:   Flush stream
//
//  Arguments:  [sbuf] -- Stream buffer to flush
//              [cb]   -- # bytes to flush
//
//  History:    11-Feb-97 KyleP     Created
//
//  Notes:      Only r/o streams supported.  Flush has no meaning.
//
//--------------------------------------------------------------------------

void CMmIStream::Flush ( CMmStreamBuf& sbuf, ULONG cb, BOOL fThrowOnFailure )
{
    Win4Assert( !"Not implemented" );
    THROW( CException( E_FAIL ) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::FlushMetaData, public
//
//  Synopsis:   Flush stream
//
//  Arguments:  [sbuf] -- Stream buffer to flush
//              [cb]   -- # bytes to flush
//
//  History:    11-Feb-97 KyleP     Created
//
//  Notes:      Only r/o streams supported.  Flush has no meaning.
//
//--------------------------------------------------------------------------

void CMmIStream::FlushMetaData( BOOL fThrowOnFailure )
{
    Win4Assert( !"Not implemented" );
    THROW( CException( E_FAIL ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\txtfilt\mmscbuf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       mmscbuf.cxx
//
//  Contents:   Memory Mapped Stream buffer for consecutive buffer mapping
//
//  Classes:    CMmStreamConsecBuf
//
//  History:    22-Jul-93 AmyA      Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmscbuf.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::CMmStreamConsecBuf, public
//
//  Synopsis:   Constructor
//
//  History:    22-Jul-93 AmyA      Created
//
//--------------------------------------------------------------------------

CMmStreamConsecBuf::CMmStreamConsecBuf()
: _pMmStream(0)
{
    _liOffset.QuadPart = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Map, public
//
//  Synopsis:   Map next consecutive part of file
//
//  Arguments:  [cb] -- size of the mapped area
//
//  History:    22-Jul-93 AmyA      Created
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Map( ULONG cb )
{
    Win4Assert( 0 != _pMmStream );

    if ( Get() != 0 )
        _pMmStream->Unmap( *this );

    LARGE_INTEGER liNewOffset;
    LARGE_INTEGER liStreamSize={_pMmStream->SizeLow(), _pMmStream->SizeHigh()};

     liNewOffset.QuadPart = cb + _liOffset.QuadPart;

    if ( liNewOffset.QuadPart > liStreamSize.QuadPart )
    {
        cb = (ULONG)(liStreamSize.QuadPart - _liOffset.QuadPart);
        liNewOffset = liStreamSize;
    }

    _pMmStream->Map( *this,
                     cb,
                     _liOffset.LowPart,
                     _liOffset.HighPart );

    _liOffset = liNewOffset;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Init, public
//
//  Synopsis:   Initizializes CMmStreamConsecBuf
//
//  Arguments:  [pMmStream] -- pointer to the CMmStream from which to fill
//                             the buffer
//
//  History:    22-Jul-93 AmyA      Created
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Init( PMmStream * pMmStream )
{
    _pMmStream = pMmStream;
    _liOffset.QuadPart = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Rewind, public
//
//  Synopsis:   Rewind file to beginning.
//
//  History:    13-Dec-93 AmyA      Created
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Rewind()
{
    if ( 0 != Get() )
    {
        Win4Assert( 0 != _pMmStream );

        _pMmStream->Unmap( *this );
    }

    _liOffset.QuadPart = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Eof, public
//
//  Synopsis:   Returns whether end of file has been hit
//
//  Returns:    FALSE if there is still more file to be mapped.  TRUE
//              otherwise.
//
//  History:    22-Jul-93 AmyA      Created
//
//--------------------------------------------------------------------------

BOOL CMmStreamConsecBuf::Eof()
{
    Win4Assert( 0 != _pMmStream );
    return( ( (ULONG) _liOffset.HighPart == _pMmStream->SizeHigh() ) &&
            ( _liOffset.LowPart == _pMmStream->SizeLow() ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\txtfilt\txtifilt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       txtifilt.cxx
//
//  Contents:   Text filter 'class factory'.
//
//  History:    23-Feb-1994     KyleP   Created
//
//  Notes:      Machine generated.  Hand modified.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <tfilt.hxx>
#include <nullfilt.hxx>
#include <params.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>

extern long gulcInstances;

extern "C" GUID TYPID_CTextIFilter = {
    0xd5355200,
    0x77e3,
    0x101a,
    { 0xb5, 0x52, 0x08, 0x00, 0x2b, 0x33, 0xb0, 0xe6 }
};

ULONG g_cbMaxTextFilter = CI_MAX_TEXT_FILTER_BYTES_DEFAULT;

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::CTextIFilterBase
//
//  Synopsis:   Base constructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CTextIFilterBase::CTextIFilterBase()
        : _cRefs(1)
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::~CTextIFilterBase
//
//  Synopsis:   Base destructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CTextIFilterBase::~CTextIFilterBase()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilterBase::QueryInterface( REFIID riid,
                                                          void  ** ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IFilter == riid )
        *ppvObject = (IUnknown *)(IFilter *)this;
    else if ( IID_IPersist == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else if ( IID_IPersistFile == riid )
        *ppvObject = (IUnknown *)(IPersistFile *)this;
#if 0 // not checked in because it might break SQL/Exchange without testing
    else if ( IID_IPersistStream == riid )
        *ppvObject = (IUnknown *)(IPersistStream *)this;
#endif
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CTextIFilterBase::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CTextIFilterBase::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::CTextIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CTextIFilterCF::CTextIFilterCF()
        : _cRefs( 1 )
{
    InterlockedIncrement( &gulcInstances );

    CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );
    g_cbMaxTextFilter= reg.Read( wcsMaxTextFilterBytes,
                                 CI_MAX_TEXT_FILTER_BYTES_DEFAULT,
                                 CI_MAX_TEXT_FILTER_BYTES_MIN,
                                 CI_MAX_TEXT_FILTER_BYTES_MAX );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::~CTextIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CTextIFilterCF::~CTextIFilterCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilterCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_ITypeLib == riid )
        sc = E_NOTIMPL;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CTextIFilterCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CTextIFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::CreateInstance
//
//  Synopsis:   Creates new TextIFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    CTextIFilter *  pIUnk = 0;
    SCODE sc = S_OK;

    TRY
    {
        pIUnk = new CTextIFilter();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pIUnk );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\tdbv1\tdbv1.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       tdbv1.CXX
//
//  Contents:   Test program for OLE-DB phase 3 interface classes.
//
//  TODO:
//              Large result sets
//
//  History:    30 June 1994    Alanw   Created (from cidrt)
//              10 Nov. 1994    Alanw   Converted for OLE-DB phase 3 interfaces
//              01 Oct. 1996    Alanw   Converted for OLE-DB V1.0 interfaces
//
//--------------------------------------------------------------------------

#define DO_NOTIFICATION
#define DO_CATEG_TESTS

#define DO_CONTENT_TESTS

#define DO_MULTI_LEVEL_CATEG_TEST

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <olectl.h>
}

#include <windows.h>

#if !defined(UNIT_TEST)
#define DBINITCONSTANTS
#if !defined(OLEDBVER)
#define OLEDBVER 0x0250
#endif  // !OLEDBVER
#endif  // !UNIT_TEST

#include <oledb.h>
#include <oledberr.h>
#include <ntquery.h>
#include <query.h>
#include <ciintf.h>
#include <cierror.h>
#include <stgprop.h>

#include <vquery.hxx>
#include <dbcmdtre.hxx>

#include <crt\io.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <time.h>
#include <process.h>
#include <propapi.h>
#include <propvar.h>

#include <oleext.h>

#include <initguid.h>
#include <srvprvdr.h>

#if defined(UNIT_TEST)
#define PROG_NAME       "tdbv1"
//#include "tabledbg.hxx"

#else  // !UNIT_TEST
#define PROG_NAME       "fsdbdrt"

#endif // UNIT_TEST

#if defined(UNIT_TEST)
#include <compare.hxx>
#include <coldesc.hxx>
#endif

WCHAR *pwcThisMachine = L".";
#define TEST_MACHINE ( pwcThisMachine )

WCHAR const wcsDefaultTestCatalog[] = L"::_noindex_::";
#define TEST_CATALOG ( wcsTestCatalog )

WCHAR const wcsDefaultContentCatalog[] = L"system";
#define CONTENT_CATALOG ( wcsDefaultContentCatalog )

BOOL isEven(unsigned n)
{
     return !(n & 0x1);
}

//
// Maximum time for test to complete.
//

int const MAXTIME = 120;
int const MINREPORTTIME = 5;
int const MAXWAITTIME = 10;

int const MAXCOLUMNS = 20;

const int cbPV = sizeof PROPVARIANT;
const int cbPPV = sizeof( PROPVARIANT * );

const HCHAPTER DBCHP_FIRST = 1;

time_t tstart;
BOOL CheckTime();


//
// Test files
//

WCHAR const wcsTestDir[]     = L"QueryTest";
WCHAR const wcsTestFile[]    = L"Test file for OFS Query";

WCHAR const wcsPropFile[] = L"Test file for Property Query.txt";
WCHAR const wcsPropFile2[] = L"Test file for Property Query2.txt";

WCHAR const wcsTestCiFile1[] = L"Test file for OFS Content Query1.txt";
WCHAR const wcsTestCiFile2[] = L"Test file for OFS Content Query2.txt";
WCHAR const wcsTestCiFile3[] = L"Test file for OFS Content Query3.txt";

DBOBJECT dbPersistObject;

// For testing safearrays of various types.

GUID const guidArray = { 0x92452ac2, 0xfcbb, 0x11d1,
                         0xb7, 0xca, 0x00, 0xa0, 0xc9, 0x06, 0xb2, 0x39 };

//
// Storage Properties
//

#define PSID_PSSecurityTest { 0xa56168e0,       \
                              0x0ef3, 0x11cf,   \
                              0xbb, 0x01, 0x00, 0x00, 0x4c, 0x75, 0x2a, 0x9a }


#define PSID_PSMyPropSet { 0x49691CF4, \
                           0x7E17, 0x101A, \
                           0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9 }

#define guidZero { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

GUID const guidMyPropSet = PSID_PSMyPropSet;
GUID const guidSecurityTest = PSID_PSSecurityTest;

const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};
const GUID guidQueryExt = DBPROPSET_QUERYEXT;

const GUID guidFsCiFrmwrkExt = DBPROPSET_FSCIFRMWRK_EXT;

const GUID guidCiFrmwrkExt = DBPROPSET_CIFRMWRKCORE_EXT;

const GUID guidMsidxsExt = DBPROPSET_MSIDXS_ROWSETEXT;

CDbColId const psSecurityTest = CDbColId( guidSecurityTest, 2 );

CDbColId const psTestProperty1 = CDbColId( guidMyPropSet, 2 );
CDbColId const psTestProperty2 = CDbColId( guidMyPropSet, L"A Property" );
CDbColId const psTestProperty10 = CDbColId( guidMyPropSet, L"An Empty Property" );
CDbColId const psTestProperty11 = CDbColId( guidMyPropSet, L"A Bstr Property" );
CDbColId const psTestProperty12 = CDbColId( guidMyPropSet, L"A Bstr Vector Property" );
CDbColId const psBlobTest = CDbColId( guidMyPropSet,
                                                L"BlobTest" );
CDbColId const psGuidTest = CDbColId( guidMyPropSet,
                                                L"GuidTest" );

CDbColId const psTestProperty13 = CDbColId( guidMyPropSet, 13 );
CDbColId const psTestProperty14 = CDbColId( guidMyPropSet, 14 );
CDbColId const psTestProperty15 = CDbColId( guidMyPropSet, 15 );
CDbColId const psTestProperty16 = CDbColId( guidMyPropSet, 16 );
CDbColId const psTestProperty17 = CDbColId( guidMyPropSet, 17 );
CDbColId const psTestProperty18 = CDbColId( guidMyPropSet, 18 );
CDbColId const psTestProperty19 = CDbColId( guidMyPropSet, 19 );
CDbColId const psTestProperty20 = CDbColId( guidMyPropSet, 20 );

CDbColId const psTestProperty21 = CDbColId( guidMyPropSet, 21 );
CDbColId const psTestProperty22 = CDbColId( guidMyPropSet, 22 );

#ifndef PROPID_PSDocument
//#include <winole.h>
#define PSID_PSDocument { \
                        0xF29F85E0, \
                        0x4FF9, 0x1068, \
                        0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9 \
}
#define PROPID_PSDocument_Author        4
#define PROPID_PSDocument_Keywords      5
#endif // PROPID_PSDocument

static GUID guidDocument = PSID_PSDocument;

CDbColId const psAuthor = CDbColId( guidDocument,
                                    PROPID_PSDocument_Author );
CDbColId const psKeywords = CDbColId( guidDocument,
                                      PROPID_PSDocument_Keywords );

CDbColId const psRelevantWords = CDbColId( guidMyPropSet,
                                           L"RelevantWords" );

CDbColId const psManyRW = CDbColId( guidMyPropSet,
                                    L"ManyRW" );

PROPVARIANT varProp1;
PROPVARIANT varProp2;
PROPVARIANT varProp3;
PROPVARIANT varProp4;
PROPVARIANT varProp5;
PROPVARIANT varProp6;
PROPVARIANT varProp7;
PROPVARIANT varProp8, varProp8A;
PROPVARIANT varProp9;
PROPVARIANT varProp10;
PROPVARIANT varProp11, varProp11A;
PROPVARIANT varProp12;
// for coercion test
PROPVARIANT varProp13;
PROPVARIANT varProp14;
PROPVARIANT varProp15;
PROPVARIANT varProp16;
PROPVARIANT varProp17;
PROPVARIANT varProp18, varProp18A;
PROPVARIANT varProp19;
PROPVARIANT varProp20;
PROPVARIANT varProp21;
PROPVARIANT varProp22;

VARTYPE const PROP1_TYPE = VT_I4;
VARTYPE const PROP2_TYPE = VT_LPWSTR;
VARTYPE const PROP3_TYPE = VT_LPWSTR;
VARTYPE const PROP4_TYPE = (VT_VECTOR|VT_LPWSTR);
VARTYPE const PROP5_TYPE = (VT_VECTOR|VT_I4);
VARTYPE const PROP6_TYPE = VT_BLOB;
VARTYPE const PROP7_TYPE = VT_CLSID;
VARTYPE const PROP8_TYPE = (VT_VECTOR|VT_I4);
VARTYPE const PROP9_TYPE = VT_I4;
VARTYPE const PROP10_TYPE = VT_LPWSTR;
VARTYPE const PROP11_TYPE = VT_BSTR;
VARTYPE const PROP12_TYPE = (VT_VECTOR|VT_BSTR);
// for coercion test
VARTYPE const PROP13_TYPE = VT_UI1;
VARTYPE const PROP14_TYPE = VT_I2;
VARTYPE const PROP15_TYPE = VT_UI2;
VARTYPE const PROP16_TYPE = VT_I4;
VARTYPE const PROP17_TYPE = VT_R4;
VARTYPE const PROP18_TYPE = VT_R8;
VARTYPE const PROP19_TYPE = VT_BOOL;
VARTYPE const PROP20_TYPE = VT_LPSTR;
VARTYPE const PROP21_TYPE = VT_CF;
VARTYPE const PROP22_TYPE = VT_CF | VT_VECTOR;

const long PROP1_VAL = 1234;
#define PROP1_cb ( sizeof ULONG )
const long PROP1_VAL_Alternate = 123;

const WCHAR * PROP2_VAL = L"Wow! In a property.";
#define PROP2_cb ( ( sizeof WCHAR ) * ( wcslen(PROP2_VAL) ) )

const WCHAR * PROP3_VAL = L"AlanW";
#define PROP3_cb ( ( sizeof WCHAR ) * ( wcslen(PROP3_VAL) ) )

const WCHAR * alpwstrProp4[] = {        L"This",
                                        L"is",
                                        L"a",
                                        L"Vector",
                                        L"Property",
                                };
const int clpwstrProp4 = (sizeof alpwstrProp4 / sizeof (WCHAR *));
const CALPWSTR PROP4_VAL = { clpwstrProp4, (WCHAR * *) alpwstrProp4 };
#define PROP4_cb 0

const LONG SecondRelevantWord = 0x23;

LONG alProp5[] = { 0x12, SecondRelevantWord, 0x35, 0x47, 0x59 };
const int clProp5 = (sizeof alProp5 / sizeof (LONG));
CAL PROP5_VAL = { clProp5, &alProp5[0] };

LONG alProp5Less[] = { alProp5[0]-1, alProp5[1]-1, alProp5[2]-1, alProp5[3]-1, alProp5[4]-1 };
const int clProp5Less = (sizeof alProp5Less / sizeof (LONG));
CAL PROP5_VAL_LESS = { clProp5Less, &alProp5Less[0] };

LONG alProp5More[] = { alProp5[0]+1, alProp5[1]+1, alProp5[2]+1, alProp5[3]+1, alProp5[4]+1 };
const int clProp5More = (sizeof alProp5More / sizeof (LONG));
CAL PROP5_VAL_MORE = { clProp5More, &alProp5More[0] };

LONG alProp5AllLess[] = { 1, 2, 3, 4, 5 };
const int clProp5AllLess = (sizeof alProp5AllLess / sizeof (LONG));
CAL PROP5_VAL_ALLLESS = { clProp5AllLess, &alProp5AllLess[0] };

LONG alProp5AllMore[] = { 0xffff, 0xfffe, 0xfffd, 0xfffc, 0xfffb };
const int clProp5AllMore = (sizeof alProp5AllMore / sizeof (LONG));
CAL PROP5_VAL_ALLMORE = { clProp5AllMore, &alProp5AllMore[0] };

LONG alProp5Jumble[] = { alProp5[4], alProp5[3], alProp5[1], alProp5[2], alProp5[0] };
const int clProp5Jumble = (sizeof alProp5Jumble / sizeof (LONG));
CAL PROP5_VAL_JUMBLE = { clProp5Jumble, &alProp5Jumble[0] };

LONG alProp5Like[] = { 0x1, 0x1, 0x2, 0x3, SecondRelevantWord };
const int clProp5Like = (sizeof alProp5Like / sizeof (LONG));
CAL PROP5_VAL_LIKE = { clProp5Like, &alProp5Like[0] };

LONG alProp5None[] = { 0x1, 0x1, 0x2, 0x3, 0x4 };
const int clProp5None = (sizeof alProp5None / sizeof (LONG));
CAL PROP5_VAL_NONE = { clProp5None, &alProp5None[0] };
#define PROP5_cb 0

BLOB PROP6_VAL = { sizeof alProp5, (BYTE*) &alProp5[0] };
#define PROP6_cb ( sizeof PROPVARIANT )

GUID PROP7_VAL = guidMyPropSet;
#define PROP7_cb ( sizeof GUID )
#define PROP7_STR_VAL "{49691CF4-7E17-101A-A91C-08002B2ECDA9}"

// note: loading the value of prop8 will be deferred
LONG alProp8[5000];
const int clProp8 = (sizeof alProp8 / sizeof (LONG));
CAL PROP8_VAL = { clProp8, &alProp8[0] };
#define PROP8_cb 0

const long PROP9_VAL = 4321;
#define PROP9_cb ( sizeof ULONG )

const WCHAR * PROP10_VAL = L"";                 // an empty string
#define PROP10_cb ( ( sizeof WCHAR ) * (wcslen(PROP10_VAL) ) )

const WCHAR * PROP11_VAL = L"This is a BSTR";  // string for a BSTR prop
WCHAR PROP11_LONGVAL[5000] = L"This is a large BSTR     ";  // string for a BSTR prop

const char PROP13_VAL = 65;
#define PROP13_cb ( sizeof char )
#define PROP13_STR_VAL "65"

const short PROP14_VAL = -1234;
#define PROP14_cb ( sizeof short )
#define PROP14_STR_VAL "-1234"

const unsigned short PROP15_VAL = 1234;
#define PROP15_cb ( sizeof (unsigned short) )
#define PROP15_STR_VAL "1234"

const int PROP16_VAL = -1234;
#define PROP16_cb ( sizeof int )
#define PROP16_STR_VAL "-1234"

const float PROP17_VAL = 1234.5678F;
#define PROP17_cb ( sizeof (float) )
// This would get truncated in result as we supply a smaller buffer
#define PROP17_STR_VAL "123"

const double PROP18_VAL = 1234.12345678;
#define PROP18_cb ( sizeof double )
#define PROP18_STR_VAL "1234.12345678"

const WORD PROP19_VAL = 0;
#define PROP19_cb ( sizeof WORD )
#define PROP19_STR_VAL "False"

const LPSTR PROP20_VAL = "1245.5678";
#define PROP20_cb ( strlen( PROP20_VAL ) )
#define PROP20_DBL_VAL 1245.5678

// note: not all the data in the CF is used, just the # of bytes specified

CLIPDATA aClipData[3] =
{
    { 20, 3, (BYTE *) "abcdefghijklmnopqrstuvwxyz" },
    { 16, 5, (BYTE *) "zyxwvutsrqponmlkjihgfedcba" },
    { 24, 7, (BYTE *) "01234567abcdefghijklmnopqrstuvwxyz" },
};

#define PROP21_cb (sizeof( void *) )
#define PROP21_VAL &aClipData[0]
#define PROP22_cb 0
#define PROP22_VAL aClipData
#define PROP22_CVALS ( sizeof aClipData / sizeof aClipData[0] )


// safearray propvariants:
PROPVARIANT vaI4;
PROPSPEC psSA_I4 = { PRSPEC_PROPID, 2 };
CDbColId const colSA_I4 = CDbColId( guidArray, 2 );
PROPVARIANT vaBSTR;
PROPSPEC psSA_BSTR = { PRSPEC_PROPID, 3 };
CDbColId const colSA_BSTR = CDbColId( guidArray, 3 );
PROPVARIANT vaVARIANT;
PROPSPEC psSA_VARIANT = { PRSPEC_PROPID, 4 };
CDbColId const colSA_VARIANT = CDbColId( guidArray, 4 );
PROPVARIANT vaR8;
PROPSPEC psSA_R8 = { PRSPEC_PROPID, 5 };
CDbColId const colSA_R8 = CDbColId( guidArray, 5 );
PROPVARIANT vaDATE;
PROPSPEC psSA_DATE = { PRSPEC_PROPID, 6 };
CDbColId const colSA_DATE = CDbColId( guidArray, 6 );
PROPVARIANT vaBOOL;
PROPSPEC psSA_BOOL = { PRSPEC_PROPID, 7 };
CDbColId const colSA_BOOL = CDbColId( guidArray, 7 );
PROPVARIANT vaDECIMAL;
PROPSPEC psSA_DECIMAL = { PRSPEC_PROPID, 8 };
CDbColId const colSA_DECIMAL = CDbColId( guidArray, 8 );
PROPVARIANT vaI1;
PROPSPEC psSA_I1 = { PRSPEC_PROPID, 9 };
CDbColId const colSA_I1 = CDbColId( guidArray, 9 );
PROPVARIANT vaR4;
PROPSPEC psSA_R4 = { PRSPEC_PROPID, 10 };
CDbColId const colSA_R4 = CDbColId( guidArray, 10 );
PROPVARIANT vaCY;
PROPSPEC psSA_CY = { PRSPEC_PROPID, 11 };
CDbColId const colSA_CY = CDbColId( guidArray, 11 );
PROPVARIANT vaUINT;
PROPSPEC psSA_UINT = { PRSPEC_PROPID, 12 };
CDbColId const colSA_UINT = CDbColId( guidArray, 12 );
PROPVARIANT vaINT;
PROPSPEC psSA_INT = { PRSPEC_PROPID, 13 };
CDbColId const colSA_INT = CDbColId( guidArray, 13 );
PROPVARIANT vaERROR;
PROPSPEC psSA_ERROR = { PRSPEC_PROPID, 14 };
CDbColId const colSA_ERROR = CDbColId( guidArray, 14 );

//
//  Desired output columns (as both CDbColId and DBCOMUNID)
//

static GUID guidSystem = PSGUID_STORAGE;
static GUID guidQuery = PSGUID_QUERY;
static GUID guidBmk = DBBMKGUID;
static GUID guidSelf = DBCOL_SELFCOLUMNS;


static CDbColId psName( guidSystem, PID_STG_NAME );
static CDbColId psPath( guidSystem, PID_STG_PATH );
static CDbColId psAttr( guidSystem, PID_STG_ATTRIBUTES );
static CDbColId psSize( guidSystem, PID_STG_SIZE );
static CDbColId psWriteTime( guidSystem, PID_STG_WRITETIME );
static CDbColId psClassid( guidSystem, PID_STG_CLASSID );
static CDbColId psContents( guidSystem, PID_STG_CONTENTS );

static CDbColId psRank( guidQuery, DISPID_QUERY_RANK );
static CDbColId psWorkid( guidQuery, DISPID_QUERY_WORKID );
static CDbColId psBookmark( guidBmk, PROPID_DBBMK_BOOKMARK );
static CDbColId psSelf( guidSelf, PROPID_DBSELF_SELF );
static CDbColId psChapt( guidBmk, PROPID_DBBMK_CHAPTER );


static CDbSortKey sortSize( psSize, QUERY_SORTDESCEND );
static CDbSortKey sortClassid( psClassid, QUERY_SORTDESCEND );
static CDbSortKey sortWriteTime( psWriteTime, QUERY_SORTASCEND );
static CDbSortKey sortName( psName, QUERY_SORTDESCEND );
static CDbSortKey sortAttr( psName, QUERY_SORTASCEND );

CDbSortKey  aSortCols[] = {
    sortSize, sortClassid, sortWriteTime, sortName,
};

CDbSortKey  aCatSortCols[] = {
    sortSize, sortWriteTime,
};

CDbSortKey  aMultiCatSortCols[] = {
    sortAttr, sortSize,
};


static CDbSortKey sortKeywords( psKeywords, QUERY_SORTASCEND );
static CDbSortKey sortRelevantWords( psRelevantWords, QUERY_SORTASCEND );
static CDbSortKey sortTestProperty1( psTestProperty1, QUERY_SORTASCEND );


CDbSortKey aPropSortCols[] = {
    sortKeywords, sortRelevantWords, sortTestProperty1
};


const int cSortColumns = (sizeof aSortCols) / (sizeof aSortCols[0]);
const int cCatSortColumns = (sizeof aCatSortCols) / (sizeof aCatSortCols[0]);
const int cMultiCatSortColumns = (sizeof aMultiCatSortCols) / (sizeof aMultiCatSortCols[0]);
const int cPropSortColumns = (sizeof aPropSortCols) / (sizeof aPropSortCols[0]);



const BYTE bmkFirst = (BYTE) DBBMK_FIRST;
const BYTE bmkLast = (BYTE) DBBMK_LAST;

//
// Text in content index files
//

char const szCIFileData1[] =
    "   The content index was created by Kyle Peltonen and Bartosz Milewski\n"
    "with help from Amy Arlin, Wade Richards, Mike Hewitt and a host of others.\n"
    "   \"To be or not to be\" is most likely a noise phrase.  \"To be or\n"
    "not to be, that is the question\" contains at least one non-noise\n"
    "word.\n"
    "Now is the time for all good men to come to the aid of their country.\n"
    "The content index is a superb piece of engineering. ;-)\n";

char const szCIFileData2[] =
    "\"Anybody can be good in the country.  "
    "There are no temptations there.\"\n"
    "\n"
    "Oscar Wilde (1854-1900), Anglo-Irish playwright, author.\n"
    "Lord Henry, in The Picture of Dorian Gray, ch. 19 (1891).\n";

char const szOFSFileData[] = "PLEASE DELETE ME!\n";

WCHAR wcsTestPath[MAX_PATH];
WCHAR wcsTestCatalog[MAX_PATH];

struct SBasicTest
{
    // field lengths
    DBLENGTH  cbClsid;
    DBLENGTH  cbSize;
    DBLENGTH  cbWriteTime;
    DBLENGTH  cbAttr;
    DBLENGTH  cbName;
    DBLENGTH  cbPath;

    // field status
    ULONG     sClsid;
    ULONG     sSize;
    ULONG     sWriteTime;
    ULONG     sIPSStorage;
    ULONG     sAttr;
    ULONG     sName;
    ULONG     sPath;

    // field data
    CLSID     clsid;
    _int64    size;
    _int64    writeTime;
    unsigned  attr;
    WCHAR     awcName[MAX_PATH + 1];
    WCHAR    *pwcPath;
    IUnknown *pIPSStorage;
};

struct SBasicAltTest
{
    // field lengths
    DBLENGTH  cbSize;
    DBLENGTH  cbWriteTime1;
    DBLENGTH  cbWriteTime2;
    DBLENGTH  cbWriteTime3;

    // field status
    ULONG     sSize;
    ULONG     sWriteTime1;
    ULONG     sWriteTime2;
    ULONG     sWriteTime3;

    // field data
    LONG      Size;
    DBDATE    writeTime1;
    DBTIME    writeTime2;
    DBTIMESTAMP writeTime3;
};


const ULONG cbRowName = sizeof WCHAR * (MAX_PATH + 1);


#define ALLPARTS ( DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS )

DBBINDING aBasicTestCols[] =
{
  // the iOrdinal field is filled in after the cursor is created

  { 0,
    offsetof(SBasicTest,clsid),
    offsetof(SBasicTest,cbClsid),
    offsetof(SBasicTest,sClsid),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof CLSID,
    0, DBTYPE_GUID,
    0, 0 },
  { 0,
    offsetof(SBasicTest,size),
    offsetof(SBasicTest,cbSize),
    offsetof(SBasicTest,sSize),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof LONGLONG,
    0, DBTYPE_UI8,
    0, 0 },
  { 0,
    offsetof(SBasicTest,writeTime),
    offsetof(SBasicTest,cbWriteTime),
    offsetof(SBasicTest,sWriteTime),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof LONGLONG,
    0, VT_FILETIME,
    0, 0 },
  { 0,
    offsetof(SBasicTest,attr),
    offsetof(SBasicTest,cbAttr),
    offsetof(SBasicTest,sAttr),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    3, // 3 for cb is ok: fixed len field so ignored
    0, DBTYPE_I4,
    0, 0 },
  { 0,
    offsetof(SBasicTest,awcName),
    offsetof(SBasicTest,cbName),
    offsetof(SBasicTest,sName),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbRowName,
    0, DBTYPE_WSTR,
    0, 0 },
  { 0,
    offsetof(SBasicTest,pwcPath),
    offsetof(SBasicTest,cbPath),
    offsetof(SBasicTest,sPath),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    0,
    0, DBTYPE_WSTR|DBTYPE_BYREF,
    0, 0 },
  { 0,
    offsetof(SBasicTest,pIPSStorage),
    0,
    offsetof(SBasicTest,sIPSStorage),
    0, // pTypeInfo
    &dbPersistObject, // pObject
    0,  // pBindExt
    DBPART_VALUE|DBPART_STATUS,  // dwPart
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM, // dwMemOwner
    0,               // cbMaxLen
    0,               // dwFlags
    DBTYPE_IUNKNOWN, // wType
    0, 0 },          // bPrecision, bScale
};

const ULONG cBasicTestCols = sizeof aBasicTestCols / sizeof aBasicTestCols[0];

DBBINDING aBasicAltCols[] =
{
  // the iOrdinal field is filled in after the cursor is created

  { 0,
    offsetof(SBasicAltTest,Size),
    offsetof(SBasicAltTest,cbSize),
    offsetof(SBasicAltTest,sSize),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    3, // 3 for cb is ok: fixed len field so ignored
    0, DBTYPE_I4,
    0, 0 },
  { 0,
    offsetof(SBasicAltTest,writeTime1),
    offsetof(SBasicAltTest,cbWriteTime1),
    offsetof(SBasicAltTest,sWriteTime1),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof DBDATE,
    0, DBTYPE_DBDATE,
    0, 0 },
  { 0,
    offsetof(SBasicAltTest,writeTime2),
    offsetof(SBasicAltTest,cbWriteTime2),
    offsetof(SBasicAltTest,sWriteTime2),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof DBTIME,
    0, DBTYPE_DBTIME,
    0, 0 },
  { 0,
    offsetof(SBasicAltTest,writeTime3),
    offsetof(SBasicAltTest,cbWriteTime3),
    offsetof(SBasicAltTest,sWriteTime3),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof DBTIMESTAMP,
    0, DBTYPE_DBTIMESTAMP,
    0, 0 },
};

const ULONG cBasicAltCols = sizeof aBasicAltCols / sizeof aBasicAltCols[0];

int     fTimeout = 1;   // non-zero if query times out
int     fVerbose = 0;   // non-zero if verbose mode
int     cFailures = 0;  // count of failures in test (unit test only)


// Class to be used as an outer unknown.  All QIs are simply
// passed on to inner unknown.
class COuterUnk: public IUnknown
{
public:

    //
    // IUnknown methods.
    //

    STDMETHOD(QueryInterface) ( THIS_ REFIID riid,
                                LPVOID *ppiuk )
                           {
                              // do blindly delegate for purpose of test
                              // don't AddRef as the inner unk will do it
                              return _pInnerUnk->QueryInterface(riid,ppiuk);
                           }
    STDMETHOD_(ULONG, AddRef) (THIS)
                            {
                                InterlockedIncrement( (long *)&_ref );
                                return( _ref );
                            }

    STDMETHOD_(ULONG, Release) (THIS)
                            {
                                if ( InterlockedDecrement( (long *)&_ref ) <= 0 )
                                {
                                    InterlockedIncrement( (long *)&_ref ); // artificial ref count for aggr
                                    delete this;
                                    return 0;
                                }
                                return ( _ref );
                            }
     void Set(IUnknown *pInnerUnk)  {_pInnerUnk = pInnerUnk;
                                     _pInnerUnk->AddRef();}


     COuterUnk() :   _ref(1), _pInnerUnk(NULL)
                          {};
    ~COuterUnk() {
                    if (_pInnerUnk)
                    {
                       _pInnerUnk->Release();
                       _pInnerUnk = 0;
                    }
       };

private:
    long  _ref;                   // OLE reference count
    IUnknown * _pInnerUnk;
};

void DownlevelTest(BOOL fSequential);
void SingleLevelCategTest();
void MultiLevelCategTest();
void CategTest( HCHAPTER hUpperChapt,
                IRowset *pRowsetCateg, IRowset *pRowset, unsigned cCols );

void RunPropTest( );
void RunSafeArrayTest( );
void RunDistribQueryTest( BOOL fDoContentTest );
void DeleteTest(BOOL fSequential);
void ContentTest(void);

void ConflictingPropsTest( LPWSTR pwszScope,
                           CDbCmdTreeNode * pTree,
                           COuterUnk * pobjOuterUnk,
                           ICommandTree **ppCmdTree );

void CheckColumns( IUnknown* pRowset, CDbColumns& rColumns, BOOL fQuiet = FALSE );
void CheckPropertiesInError( ICommand* pCmd, BOOL fQuiet = FALSE );
void CheckPropertiesOnCommand( ICommand* pCmd, BOOL fQuiet = FALSE );
void BasicTest( IRowset* pRowset,
                BOOL fSequential, HCHAPTER hChapt, unsigned cCols,
                BOOL fByRef, ICommandTree * pCmdTree = 0 );
void BackwardsFetchTest( IRowset* pRowset );
void FetchTest(IRowset* pRowset);
void BindingTest(IUnknown* pRowset, BOOL fICommand = FALSE, BOOL fSequential = FALSE );
void MoveTest(IRowset* pRowset, HCHAPTER hChapt = DB_NULL_HCHAPTER);

int CheckHrowIdentity( IRowsetIdentity * pRowsetIdentity,
                       DBROWCOUNT lOffset,
                       DBCOUNTITEM cRows1,
                       HROW * phRows1,
                       DBCOUNTITEM cRows2,
                       HROW * phRows2 );

void TestIAccessorOnCommand( ICommandTree * pCmdTree );

void CheckPropertyValue( PROPVARIANT const & varntPropRet,
                         PROPVARIANT const & varntPropExp);

BOOL GetBooleanProperty ( IRowset * pRowset, DBPROPID dbprop );
BOOL SetBooleanProperty ( ICommand * pCmd, DBPROPID dbprop, VARIANT_BOOL f );

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode * pRst,
                                CDbColumns & Cols,
                                CDbSortSet * pSort,
                                LPWSTR * aColNames = 0 );

void GetCommandTreeErrors(ICommandTree* pCmdTree);

IRowsetScroll * InstantiateRowset(
    ICommand *pQueryIn,
    DWORD dwDepth,
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    REFIID riid,
    COuterUnk *pobjOuterUnk = 0,
    ICommandTree ** ppCmdTree = 0,
    BOOL fExtendedTypes = TRUE
);

void InstantiateMultipleRowsets(
    DWORD dwDepth,
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    REFIID riid,
    unsigned cRowsets,
    IUnknown ** aRowsets,
    ICommandTree ** ppCmdTree = 0
);

void ReleaseStaticHrows( IRowset * pRowset, DBCOUNTITEM cRows, HROW * phRows );
void FreeHrowsArray( IRowset * pRowset, DBCOUNTITEM cRows, HROW ** pphRows );

HACCESSOR MapColumns(
        IUnknown * pUnknown,
        DBORDINAL cCols,
        DBBINDING * pBindings,
        const DBID * pColIds,
        BOOL fByRef = FALSE );
void ReleaseAccessor( IUnknown * pUnknown, HACCESSOR hAcc );

int  WaitForCompletion( IRowset *pRowset, BOOL fQuiet = FALSE );
void Setup(void);
void Cleanup(void);
ULONG Delnode( WCHAR const * wcsDir );
void BuildFile( WCHAR const * wcsFile, char const * data, ULONG cb );

void CantRun(void);
void Fail(void);
void Usage(void);

void LogProgress( char const * pszFormat, ... );
void LogError( char const * pszFormat, ... );
void LogFail( char const * pszFormat, ... );
WCHAR * FormatGuid( GUID const & guid );

void DBSortTest(void);

SCODE SetScopeProperties( ICommand * pCmd,
                         unsigned cDirs,
                         WCHAR const * const * apDirs,
                         ULONG const *  aulFlags,
                         WCHAR const * const * apCats = 0,
                         WCHAR const * const * apMachines = 0 );

BOOL DoContentQuery(
    ICommand * pQuery,
    CDbRestriction & CiRst,
    unsigned cExpectedHits );

char *ProgName = PROG_NAME;

void Usage(void)
{
#ifdef UNIT_TEST
    printf("Usage:  %s [ -d[:InfoLevel] ] [-v] [-V] [-t] [-c]\n",
           ProgName);
#else // !UNIT_TEST
    printf("Usage:  %s [-v] [-V] [-t] [-c]\n", ProgName);
#endif // UNIT_TEST
    printf("\t-v\tverbose\n"
           "\t-V\tvery verbose - dumps tables, column and rowset info\n"
           "\t-t\tdon't timeout queries\n"
           "\t-c\tdon't do content query test\n");
    //       "\t-dl\tdon't do tests on downlevel file system\n"
    //       "\t-ofs\tdon't do tests on OFS file system\n");
    //       "\t-n{d,o}\tdon't do tests on downlevel (-nd) or OFS (-no)\n");
#ifdef UNIT_TEST
    printf("\t-d[:InfoLevel]\tset debug infolevel to InfoLevel\n");
#endif // UNIT_TEST
    exit(2);
}


//+-------------------------------------------------------------------------
//
//  Function:   IsContentFilteringEnabled, public
//
//  Synopsis:   Read the registry for the key FilterContent at the
//              location
//
//--------------------------------------------------------------------------

BOOL IsContentFilteringEnabled()
{
    WCHAR wcsFilterContents[] = L"FilterContents";
    WCHAR wcsRegAdmin[]       = L"ContentIndex";
    BOOL  fFilteringEnabled    = FALSE;

    RTL_QUERY_REGISTRY_TABLE regtab[2];

    regtab[0].DefaultType   = REG_NONE;
    regtab[0].DefaultData   = 0;
    regtab[0].DefaultLength = 0;
    regtab[0].QueryRoutine  = 0;
    regtab[0].Name          = wcsFilterContents;
    regtab[0].EntryContext  = &fFilteringEnabled;
    regtab[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;

    regtab[1].QueryRoutine = 0;
    regtab[1].Flags = 0;

    NTSTATUS Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                              wcsRegAdmin,
                                              &regtab[0],
                                              0,
                                              0 );

    if ( NT_ERROR(Status) || !fFilteringEnabled )
        return FALSE;

    ISimpleCommandCreator * pCmdCreator = 0;
    CLSID clsidSCC = CLSID_CISimpleCommandCreator;
    SCODE sc = CoCreateInstance( clsidSCC,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_ISimpleCommandCreator,
                                 (void **)&pCmdCreator );

    if ( S_OK != sc )
    {
        LogError( "CoCreateInstance for cmd creator returned %08x\n", sc );
        return FALSE;
    }

    WCHAR awchCatalog[80];
    ULONG cchCat = 0;
    sc = pCmdCreator->GetDefaultCatalog( awchCatalog,
                                  sizeof awchCatalog/sizeof(awchCatalog[0]),
                                  &cchCat );

    if ( S_OK != sc )
    {
        LogError( "GetDefaultCatalog returned %08x\n", sc );
        pCmdCreator->Release();
        return FALSE;
    }

    sc = pCmdCreator->VerifyCatalog( TEST_MACHINE, CONTENT_CATALOG );
    pCmdCreator->Release();

    return sc == S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   main, public
//
//  Synopsis:   Test the file system implementation of the IRowset
//              family of interfaces.
//
//  Notes:
//
//  History:    25 Mar 1994     Alanw   Created
//
//--------------------------------------------------------------------------

int __cdecl main(int argc, char **argv)
{
    #ifdef UNIT_TEST
        DBSortTest();
    #endif

    unsigned i;
    BOOL fDoContentTest = TRUE;

    //
    // Parse arguments.
    //

    ProgName = argv[0];

    for ( i = 1; i < (unsigned)argc ; i++ )
    {
        char *pszArg = argv[i];
        if ( *pszArg == '-' ) {
            switch ( *++pszArg )
            {
            case 'd':
               // if (pszArg[1] == 'l')  // -dl - no downlevel tests
               // {
               //     fNoDownlevel = TRUE;
               //     break;
               // }
#if defined (UNIT_TEST) && (DBG == 1)
                if (*++pszArg == ':')   // -d:xx - debug output mode
                    pszArg++;

                {
                    unsigned fInfoLevel = atoi(pszArg);
                    tbInfoLevel = fInfoLevel ? fInfoLevel : 0xFFFFF;
                }
                break;
#else // !UNIT_TEST
                Usage();
                exit(2);
#endif // UNIT_TEST

            case 't':           // don't timeout
                fTimeout = 0;
                break;

            case 'c':
                fDoContentTest = FALSE;
                break;

            case 'V':           // very verbose, dumps table
                fVerbose++;
            case 'v':           // verbose
                fVerbose++;
                break;

            default:
                Usage();
                exit (2);
            }
        } else {

            //  Exit the argument loop

            argc -= i;
            argv += i;
            break;
        }
    }

    printf( "%s: OLE-DB cursor unit test.\n"
#if defined (UNIT_TEST)
                "   No expected failures\n"
#if !(defined(DO_CATEG_TESTS) && \
      defined(DO_NOTIFICATION) && \
      defined(DO_CONTENT_TESTS) && \
      defined(MULTI_LEVEL_CATEG_TEST) )
                "   Not all tests are turned on\n"
#endif // conditional tests
#endif // defined(UNIT_TEST)
                , ProgName );

    for (i = 0; i < clProp8; i++)
        alProp8[i] = i;

    CoInitialize( 0 );

    Setup();

    // Patch in this iid, which can't be done in the initializer

    dbPersistObject.dwFlags = STGM_PRIORITY | STGM_READ;
    dbPersistObject.iid = IID_IPropertySetStorage;

    //
    // Base functionality test
    //


    RunPropTest( );
    RunSafeArrayTest();

    RunDistribQueryTest( fDoContentTest );

    DownlevelTest(TRUE);
    DownlevelTest(FALSE);

    #ifdef DO_CATEG_TESTS
        SingleLevelCategTest();

        #ifdef DO_MULTI_LEVEL_CATEG_TEST
            MultiLevelCategTest();
        #endif

    #endif // DO_CATEG_TESTS

    #ifdef DO_CONTENT_TESTS
        if ( fDoContentTest && IsContentFilteringEnabled() )
        {
            ContentTest();
        }
        else
    #endif
            LogProgress("WARNING: Content Query test disabled\n");

    DeleteTest(TRUE);
    DeleteTest(FALSE);

    CIShutdown();

//#if defined (UNIT_TEST)
    if (cFailures)
    {
        printf("%d failures occurred\n", cFailures);
        Fail();
    }
//#endif // defined(UNIT_TEST)

    Cleanup();
    CoUninitialize();

    printf( "%s: PASSED\n", ProgName );
    if (! _isatty(_fileno(stdout)) )
        fprintf( stderr, "%s: PASSED\n", ProgName );
    return( 0 );
} //main


//+-------------------------------------------------------------------------
//
//  Function:   DownlevelTest, public
//
//  Synopsis:   Basic query feature test.
//
//  History:    30 Jun 94       AlanW     Created
//
//  Notes:      Just looks for files in the system directory.
//
//--------------------------------------------------------------------------

void DownlevelTest(BOOL fSequential)
{
    LogProgress( "Non-content %s query\n",
                fSequential? "sequential" : "scrollable");

    SCODE sc;

    //
    // Find system directory

    WCHAR wcsSysDir[MAX_PATH];

    #if 0
    wcscpy(wcsSysDir, L"F:\\winnt\\system32");
    #else
    if( !GetSystemDirectory( wcsSysDir, sizeof(wcsSysDir) / sizeof(WCHAR) ) )
    {
        LogFail( "Unable to determine system directory.\n" );
    }
    #endif

    //
    // Get name, size and class id for *.exe, *.dll, *.doc and *.sys
    //

    int cCol = 7;
    if ( !fSequential )
        cCol++;

    CDbColumns cols(cCol);

    cols.Add( psClassid, 0 );
    cols.Add( psSize, 1 );
    cols.Add( psWriteTime, 2 );
    cols.Add( psAttr, 3 );
    cols.Add( psName, 4 );
    cols.Add( psPath, 5 );
    cols.Add( psSelf, 6 );
    if ( !fSequential )
    {
        cols.Add( psWorkid, 7);
    }

    CDbPropertyRestriction rst;

    rst.SetRelation( DBOP_like );
    rst.SetProperty( psName );
    rst.SetValue( L"*.|(exe|,dll|,doc|,sys|,zzz|)" );

    CDbSortSet ss(cSortColumns);
    for (unsigned i = 0; i<cSortColumns; i++)
         ss.Add(aSortCols[i], i);

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree(&rst, cols, &ss);


    if (! fSequential)
    {
        ConflictingPropsTest(wcsSysDir, pDbCmdTree, 0, 0);
    }

    ICommandTree * pCmdTree=0;
    COuterUnk *pOuterUnk = new COuterUnk();

    IRowset * pRowset = InstantiateRowset(
                            0,
                            QUERY_SHALLOW,           // Depth
                            wcsSysDir,               // Scope
                            pDbCmdTree,              // DBCOMMANDTREE
                            fSequential ? IID_IRowset :
                                  IID_IRowsetScroll, // IID of i/f to return
                            pOuterUnk,
                            &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "Downlevel query unsuccessful.\n" );
    }

    //
    //  Do basic function tests.
    //
    BasicTest(pRowset, fSequential,  0, cBasicTestCols, TRUE);
    BasicTest(pRowset, fSequential,  0, cBasicTestCols, TRUE, pCmdTree);

    //
    // Do backward fetch tests
    //
    if ( !fSequential )
    {
        BackwardsFetchTest( pRowset );
    }

    FetchTest(pRowset);

    //
    // Test SetBindings, GetBindings, Move and Scroll
    //
    BindingTest(pRowset, FALSE, fSequential );
    BindingTest(pCmdTree, TRUE, fSequential );

    if ( ! fSequential )
    {
        MoveTest(pRowset);
    }

    pCmdTree->Release();
    pRowset->Release();

    pOuterUnk->Release(); // truly release it

} //DownlevelTest


//+---------------------------------------------------------------------------
//
//  Function:   ConflictingPropsTest
//
//  Synopsis:   Tests handling of conflicting settings of rowset properties.
//
//  Arguments:  [pswzScope] - Query scope
//              [pTree]     - pointer to DBCOMMANDTREE for the query
//              [pUnkOuter] - pointer to outer unknown object
//              [ppCmdTree] - if non-zero, ICommandTree will be returned here.
//
//  Returns:    NOTHING
//
//  History:    26 May  1998   AlanW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void ConflictingPropsTest(
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    COuterUnk * pobjOuterUnk,
    ICommandTree **ppCmdTree
) {
    DWORD dwDepth = QUERY_SHALLOW;

    // run the query
    ICommand * pQuery = 0;

    IUnknown * pIUnknown;
    SCODE sc = CICreateCommand( &pIUnknown,
                                (IUnknown *)pobjOuterUnk,
                                IID_IUnknown,
                                TEST_CATALOG,
                                TEST_MACHINE );

    if ( FAILED( sc ) )
        LogFail( "ConflictingPropsTest - error 0x%x Unable to create command\n",
                     sc );

    if (pobjOuterUnk)
    {
       pobjOuterUnk->Set(pIUnknown);
    }

    if (pobjOuterUnk)
        sc = pobjOuterUnk->QueryInterface(IID_ICommand, (void **) &pQuery );
    else
        sc = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );

    pIUnknown->Release();

    if ( FAILED( sc ) )
        LogFail( "ConflictingPropsTest - error 0x%x Unable to QI ICommand\n",
                 sc );

    sc = SetScopeProperties( pQuery,
                             1,
                             &pwszScope,
                             &dwDepth );

    if ( FAILED( sc ) )
        LogFail( "ConflictingPropsTest - error 0x%x Unable to set scope '%ws'\n",
                 sc, pwszScope );

    CheckPropertiesOnCommand( pQuery );

    ICommandTree *pCmdTree = 0;

    if (pobjOuterUnk)
        sc = pobjOuterUnk->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);
    else
        sc = pQuery->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);

    if (FAILED (sc) )
    {
        if ( 0 != pQuery )
            pQuery->Release();

        LogFail("QI for ICommandTree failed\n");
    }

    DBCOMMANDTREE * pRoot = pTree->CastToStruct();

    sc = pCmdTree->SetCommandTree( &pRoot, 0, TRUE);
    if (FAILED (sc) )
    {
        if ( 0 != pQuery )
           pQuery->Release();

        pCmdTree->Release();
        LogFail("SetCommandTree failed, %08x\n", sc);
    }

    ICommandProperties *pCmdProp = 0;
    if (pobjOuterUnk)
        sc = pobjOuterUnk->QueryInterface(IID_ICommandProperties, (void **)&pCmdProp);
    else
        sc = pQuery->QueryInterface(IID_ICommandProperties, (void **)&pCmdProp);

    if (FAILED (sc) )
    {
        if ( 0 != pQuery )
            pQuery->Release();

        LogFail("QI for ICommandProperties failed\n");
    }

    //
    //  Set conflicting properties
    //
    const unsigned MAX_PROPS = 6;
    DBPROPSET  aPropSet[MAX_PROPS];
    DBPROP     aProp[MAX_PROPS];
    ULONG      cProp = 0;

    aProp[cProp].dwPropertyID = DBPROP_IRowsetScroll;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;

    aProp[cProp].dwPropertyID = DBPROP_BOOKMARKS;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;


    sc = pCmdProp->SetProperties( cProp, aPropSet );
    //pCmdProp->Release();

    if ( FAILED(sc) || DB_S_ERRORSOCCURRED == sc )
    {
        if ( 0 != pQuery )
            pQuery->Release();

        LogError("ICommandProperties::SetProperties failed\n");
        cFailures++;
    }

    IRowset * pRowset = 0;

    sc = pQuery->Execute( 0,                    // no aggr. IUnknown
                          IID_IRowset,          // IID for i/f to return
                          0,                    // disp. params
                          0,                    // count of rows affected
                          (IUnknown **)&pRowset);  // Returned interface

    if (SUCCEEDED (sc))
    {
        if ( 0 == pRowset )
            LogError("ICommand::Execute returned success(%x), but pRowset is null\n", sc);
        else
            LogError("ICommand::Execute returned success(%x) with conflicting props\n", sc);

        if (DB_S_ERRORSOCCURRED == sc)
        {
            CheckPropertiesInError(pQuery);
        }
        pRowset->Release();
        pCmdProp->Release();
        pCmdTree->Release();
        pQuery->Release();
        Fail();
    }
    else // FAILED (sc)
    {

        if (DB_E_ERRORSOCCURRED != sc)
        {
            LogError("ICommand::Execute with conflicing props failed, %x\n", sc);
            if (DB_E_ERRORSINCOMMAND == sc)
                GetCommandTreeErrors(pCmdTree);

            pCmdProp->Release();
            pCmdTree->Release();
            pQuery->Release();
            Fail();
        }
        CheckPropertiesInError(pQuery, TRUE);
    }

// TODO: check other combinations of conflicting properties
//       check that execute succeeds on same ICommand after reset
    // Set properties back to their default state
    cProp = 0;

    aProp[cProp].dwPropertyID = DBPROP_IRowsetLocate;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;

    aProp[cProp].dwPropertyID = DBPROP_BOOKMARKS;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;

    aProp[cProp].dwPropertyID = DBPROP_IRowsetScroll;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal = VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;

    sc = pCmdProp->SetProperties( cProp, aPropSet );
    pCmdProp->Release();

    if (FAILED (sc) )
    {
        LogError("ICommandProperties::SetProperties failed, %08x\n", sc);
        if (DB_E_ERRORSINCOMMAND == sc)
        {
            GetCommandTreeErrors(pCmdTree);
        }
        if (DB_E_ERRORSOCCURRED == sc)
        {
            CheckPropertiesInError(pQuery);
        }
        pQuery->Release();
        pCmdTree->Release();
        Fail();
    }

    pQuery->Release();
    if ( 0 == ppCmdTree )
    {
        pCmdTree->Release();
    }
    else
    {
        *ppCmdTree = pCmdTree;
    }

    return;
}


#ifdef DO_CATEG_TESTS
//+-------------------------------------------------------------------------
//
//  Function:   SingleLevelCategTest, public
//
//  Synopsis:   Basic query categorization feature test.
//
//  History:    30 Mar 95       dlee     Created
//
//  Notes:      Just looks for files in the system directory.
//
//--------------------------------------------------------------------------

void SingleLevelCategTest()
{
    LogProgress( "Non-content categorization query\n" );

    SCODE sc;

    //
    // Find system directory
    //

    WCHAR wcsSysDir[MAX_PATH];

#if 0
    wcscpy(wcsSysDir,L"g:\\winnt\\system32");
#else
    if( !GetSystemDirectory( wcsSysDir, sizeof(wcsSysDir) / sizeof(WCHAR) ) )
        LogFail( "Unable to determine system directory.\n" );
#endif

    //
    // Get name, size and class id for *.exe, *.dll, *.doc, and *.sys
    //
    CDbColumns cols(8);

    cols.Add( psClassid, 0 );
    cols.Add( psSize, 1 );
    cols.Add( psWriteTime, 2 );
    cols.Add( psAttr, 3 );
    cols.Add( psName, 4 );
    cols.Add( psPath, 5 );
    cols.Add( psSelf, 6 );
    cols.Add( psBookmark, 7);

    CDbNestingNode nest;

    nest.AddGroupingColumn( psSize );

    nest.AddParentColumn( psBookmark );
    nest.AddParentColumn( psSize );

    nest.AddChildColumn( psClassid );
    nest.AddChildColumn( psSize );
    nest.AddChildColumn( psWriteTime );
    nest.AddChildColumn( psAttr );
    nest.AddChildColumn( psName );
    nest.AddChildColumn( psPath );
    nest.AddChildColumn( psSelf );
    nest.AddChildColumn( psBookmark);

    CDbPropertyRestriction rst;

    rst.SetRelation( DBOP_like );
    rst.SetProperty( psName );
    rst.SetValue( L"*.|(exe|,dll|,doc|,sys|,zzz|)" );

    CDbSelectNode * pSelect = new CDbSelectNode();
    pSelect->AddRestriction( rst.Clone() );

    nest.AddTable( pSelect );
    pSelect = 0;

    IRowset * pRowsets[2];
    ICommandTree * pCmdTree = 0;

    InstantiateMultipleRowsets(
                            QUERY_SHALLOW,           // Depth
                            wcsSysDir,               // Scope
                            nest.Clone(),            // DBCOMMANDTREE
                            IID_IRowsetScroll,       // IID for i/f to return
                            2,
                            (IUnknown **)pRowsets,
                            &pCmdTree );

    IRowset *pRowsetCateg = pRowsets[0];
    IRowset *pRowset = pRowsets[1];

    //
    // Verify columns
    //

    CDbColumns chapCols(3);

    chapCols.Add( psBookmark, 0 );
    chapCols.Add( psSize, 1 );
    chapCols.Add( psChapt, 2 ); // chapt must be last since it is added to
                                // the end automatically above.
    CheckColumns( pRowsetCateg, chapCols );
    CheckColumns( pRowset, cols );

    if ( !WaitForCompletion( pRowset, FALSE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        pRowsetCateg->Release();
        LogFail( "Downlevel query unsuccessful.\n" );
    }

    //
    //  Do basic function tests.
    //
    FetchTest(pRowset);

    //
    // Test SetBindings, GetBindings, Move and Scroll
    //
    BindingTest(pRowset);
    BindingTest(pCmdTree, TRUE);

    CategTest(0, pRowsetCateg, pRowset, cBasicTestCols);

    pCmdTree->Release();
    pRowset->Release();
    pRowsetCateg->Release();
} //SingleLevelCategTest


#define MAX_CHAPT_LENGTH     32

static DBBINDING aCategCols[] =
{
  {
    0, sizeof DBLENGTH,
    0, 0,
    0,0,0,
    DBPART_VALUE|DBPART_LENGTH,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    MAX_CHAPT_LENGTH,
    0, DBTYPE_BYTES,
    0,0 },
};

const ULONG cCategCols = sizeof aCategCols / sizeof aCategCols[0];

static DBBINDING aSizeCol[] =
{
  {
    0, 0,
    0, 0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof LONGLONG,
    0, DBTYPE_UI8,
    0, 0 },
};

static DBBINDING aAttrCol[] =
{
  {
    0, 0,
    0, 0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof LONG,
    0, DBTYPE_I4,
    0, 0 },
};

struct ChaptBinding
{
    DBLENGTH len;
    ULONG    chapt; // because I know the first 4 bytes are the chapt
    char     abChapt[MAX_CHAPT_LENGTH - sizeof ULONG];
};

void CategTest(
    HCHAPTER  hUpperChapt,
    IRowset * pRowsetCateg,
    IRowset * pRowset,
    unsigned  cCols )
{
    LogProgress( " Categorization test\n" );

    BOOL fBackwardFetch = GetBooleanProperty( pRowset, DBPROP_CANFETCHBACKWARDS );
    BOOL fCanHoldRows   = GetBooleanProperty( pRowset, DBPROP_CANHOLDROWS );

    if ( !fBackwardFetch || !fCanHoldRows )
        LogProgress("WARNING: Categorized backward fetch test disabled\n");

    IUnknown * pAccessor = pRowsetCateg;

    HACCESSOR hAccCateg = MapColumns( pAccessor,
                                      cCategCols, aCategCols, &psChapt);

    HACCESSOR hAccSize = MapColumns( pRowsetCateg,
                                     1, aSizeCol, &psSize);

    IRowsetLocate * pRLC = 0;
    SCODE sc = pRowsetCateg->QueryInterface( IID_IRowsetLocate,
                                             (void **)&pRLC);

    if (FAILED(sc) || pRLC == 0)
        LogFail("QueryInterface to IRowsetLocate failed\n");

    IRowsetIdentity * pRowsetIdentity = 0;
    sc = pRowsetCateg->QueryInterface( IID_IRowsetIdentity,
                                       (void **)&pRowsetIdentity);

    if (FAILED(sc) && (sc != E_NOINTERFACE || pRowsetIdentity != 0)) {
        LogError("QueryInterface to IRowsetIdentity failed (%x)\n", sc);
        pRowsetIdentity = 0;
        cFailures++;
    }

    IChapteredRowset * pChapteredRowset = 0;
    sc = pRowset->QueryInterface( IID_IChapteredRowset,
                                  (void **)&pChapteredRowset);

    if (FAILED(sc)) {
        LogError("QueryInterface to IChapteredRowset failed (%x)\n", sc);
        pChapteredRowset = 0;
        cFailures++;
    }

    IRowsetScroll * pRS = 0;
    sc = pRowset->QueryInterface( IID_IRowsetScroll,
                                  (void **)&pRS);

    if (FAILED(sc) || pRS == 0)
        LogFail("QueryInterface to IRowsetScroll failed\n");

    SCODE scHier = S_OK;
    HROW ahRows[10];
    HROW* phRows = ahRows;
    DBCOUNTITEM cCategories = 0;
    DBCOUNTITEM cRowsTotal = 0;
    DBCOUNTITEM cRowsReturned = 0;

    LONGLONG llSizePrev = -1;

    while (scHier != DB_S_ENDOFROWSET)
    {
        scHier = pRLC->GetNextRows( hUpperChapt, 0, 10, &cRowsReturned, &phRows);
        if (FAILED(scHier))
            LogFail("pRLC->GetNextRows failed: 0x%lx\n", scHier);

        if ( 0 == cRowsReturned )
        {
            if ( DB_S_ENDOFROWSET != scHier )
                LogFail("pRLC->GetNextRows bad return at end of rowset: 0x%lx\n", scHier);
            continue;
        }

        cCategories += cRowsReturned;
        HCHAPTER hLastChapter = DB_NULL_HCHAPTER;

        for (ULONG row = 0; row < cRowsReturned; row++)
        {
            ChaptBinding data;

            SCODE sc = pRLC->GetData(phRows[row], hAccCateg, &data);
            if ( FAILED( sc ) )
                LogFail("Can't get category data in CategTest()\n");

            LONGLONG llSize;
            sc = pRLC->GetData(phRows[row], hAccSize, &llSize);
            if ( FAILED( sc ) )
                LogFail("Can't get size data in CategTest()\n");

            if (fVerbose > 1)
                printf( "  category, file size: %lx, %d\n",
                        data.chapt,
                        (int) llSize );

            if ( llSize == llSizePrev )
                LogFail("Duplicate size categories\n");

            if ( llSizePrev > llSize )
                LogFail("categories unsorted by size\n");

            llSizePrev = llSize;

            DBCOUNTITEM cRows;
            sc = pRS->GetApproximatePosition( data.chapt, 0, 0, 0, &cRows );
            if ( FAILED( sc ) )
                LogFail("GetApproximatePosition with chapter failed %x\n", sc);
            cRowsTotal += cRows;

            // then test fetching rows in the category

            BasicTest(pRowset, FALSE, data.chapt, cCols, FALSE);
            MoveTest(pRowset, data.chapt);
            if (cCategories == cRowsReturned && 0 == row &&
                DB_NULL_HCHAPTER == hUpperChapt)
            {
                // Do testing on entire base rowset
                BasicTest(pRowset, FALSE, DB_NULL_HCHAPTER, cCols, FALSE);
                MoveTest(pRowset, DB_NULL_HCHAPTER);
            }

            if (pChapteredRowset && row != (cRowsReturned - 1))
            {
                ULONG ulRefCnt = 10;
                sc = pChapteredRowset->ReleaseChapter( data.chapt, &ulRefCnt );
                
                if ( FAILED( sc ) )
                {
                    LogError("ReleaseChapter failed, sc = %x\n", sc);
                    cFailures++;
                }
                else if ( ulRefCnt != 0 )
                {
                    LogError("ReleaseChapter returned bad refcount: got %d, exp 0\n", ulRefCnt);
                    cFailures++;
                }
            }
            else
                hLastChapter = data.chapt;
        }

        if (pChapteredRowset)
        {
            ULONG ulRefCnt = 10;
            sc = pChapteredRowset->AddRefChapter( hLastChapter, &ulRefCnt );
            
            if ( FAILED( sc ) )
            {
                LogError("AddRefChapter failed, sc = %x\n", sc);
                cFailures++;
            }
            else if ( ulRefCnt != 2 )
            {
                LogError("AddRefChapter returned bad refcount: %d\n", ulRefCnt);
                cFailures++;
            }
        }
        if ( fBackwardFetch && fCanHoldRows )
        {
            HROW  ahRows2[10];
            HROW* phRows2 = ahRows2;
            DBCOUNTITEM cRowsRet2 = 0;
            DBROWOFFSET oRows = - (DBROWOFFSET)cRowsReturned;

            // fetch the categories BACKWARD to test GetNextRows behavior
            // over chapters.
            sc = pRLC->GetNextRows( hUpperChapt, 0, oRows,
                                    &cRowsRet2, &phRows2);
            if (FAILED(sc))
                LogFail("pRLC->GetNextRows backward fetch failed: 0x%lx\n", sc);
    
            if ( cRowsRet2 != cRowsReturned )
            {
                LogFail("pRLC->GetNextRows different row count on fwd/bkwd fetch: %d %d\n",
                         cRowsReturned, cRowsRet2);
            }

            // The first row retrieved in ahRows2 is the last retrieved in
            // ahRows.  Fetch the chapter again and check its refcount to see
            // if it was collapsed properly.
            if (pChapteredRowset)
            {
                ChaptBinding data;
    
                sc = pRLC->GetData(phRows2[0], hAccCateg, &data);
                if ( FAILED( sc ) )
                    LogFail("Can't re-fetch category data in CategTest()\n");

                ULONG ulRefCnt = 10;
                sc = pChapteredRowset->ReleaseChapter( data.chapt, &ulRefCnt );
                
                if ( FAILED( sc ) )
                {
                    LogError("ReleaseChapter failed on chapt refetch, sc = %x\n", sc);
                    cFailures++;
                }
                else if ( ulRefCnt != 2 )
                {
                    LogError("ReleaseChapter returned bad refcount: got %d, exp 2\n", ulRefCnt);
                    cFailures++;
                }
                else
                {
                    pChapteredRowset->ReleaseChapter( data.chapt, &ulRefCnt );
                    pChapteredRowset->ReleaseChapter( data.chapt, &ulRefCnt );
                }
            }

            // Reverse the order of the rows for HROW identity check
            unsigned i, j;
            for (i=0, j=(unsigned)(cRowsRet2-1); i < j; i++, j--)
            {
                HROW hrTmp = ahRows2[i];
                ahRows2[i] = ahRows2[j];
                ahRows2[j] = hrTmp;
            }
            
            int cFailed = CheckHrowIdentity( pRowsetIdentity, 0,
                                             cRowsReturned, ahRows,
                                             cRowsRet2, ahRows2 );
            if ( cFailed > 0 )
            {
                LogFail( "Backwards category fetch CheckHrowIdentity returned %d\n", cFailed );
            }

            // Release first row in handle array, use that position to refetch
            // last row in array.
            sc = pRLC->ReleaseRows( 1, phRows2, 0, 0, 0 );
    
            DBCOUNTITEM cRowsRet3 = 0;
            sc = pRLC->GetNextRows( hUpperChapt, cRowsRet2-1, 1,
                                    &cRowsRet3, &phRows2);
            if (FAILED(sc))
                LogFail("pRLC->GetNextRows re-fetch failed: 0x%lx\n", sc);
    
            if ( cRowsRet3 != 1 )
            {
                LogFail("pRLC->GetNextRows unexpected row count on re-fetch: %d\n",
                         cRowsRet3);
            }
            cFailed = CheckHrowIdentity( pRowsetIdentity, cRowsRet2-1,
                                         1, ahRows2,
                                         1, ahRows2 );
            if ( cFailed > 0 )
            {
                LogFail( "Category re-fetch CheckHrowIdentity returned %d\n", cFailed );
            }
            sc = pRLC->ReleaseRows( cRowsRet2, phRows2, 0, 0, 0 );
        }

        sc = pRLC->ReleaseRows( cRowsReturned, phRows, 0, 0, 0 );
    }

    if (cCategories == 0)
        LogFail("No categories found\n");

    DBCOUNTITEM cRows;
    sc = pRS->GetApproximatePosition( DB_NULL_HCHAPTER, 0, 0, 0, &cRows );
    if ( FAILED( sc ) )
        LogFail("GetApproximatePosition with NULL chapter failed %x\n", sc);

    if (DB_NULL_HCHAPTER == hUpperChapt && cRowsTotal != cRows)
        LogFail("Sum of rows in chapters(%d) is not same as total rows(%d)\n",
                cRowsTotal, cRows);
    if (DB_NULL_HCHAPTER != hUpperChapt && cRowsTotal > cRows)
        LogFail("Sum of rows in chapters(%d) is greater than total rows(%d)\n",
                cRowsTotal, cRows);

    ReleaseAccessor( pAccessor, hAccCateg );
    ReleaseAccessor( pRowsetCateg, hAccSize );

    pRLC->Release();
    pRS->Release();
    if (pRowsetIdentity)
        pRowsetIdentity->Release();
    if (pChapteredRowset)
        pChapteredRowset->Release();

} //CategTest
#endif // DO_CATEG_TESTS


#ifdef DO_MULTI_LEVEL_CATEG_TEST

void UpperLevelCategTest(
    IRowset *pRowsetUpperCateg,
    IRowset *pRowsetLowerCateg,
    IRowset *pRowset,
    unsigned cCols)
{
    LogProgress( " Upper Level Categorization test\n" );

    HACCESSOR hAccCateg = MapColumns( pRowsetUpperCateg,
                                      cCategCols, aCategCols, &psChapt);

    HACCESSOR hAccAttr = MapColumns( pRowsetUpperCateg,
                                     1, aAttrCol, &psAttr);

    IRowsetLocate * pRLUC = 0;
    SCODE sc = pRowsetUpperCateg->QueryInterface( IID_IRowsetLocate,
                                             (void **)&pRLUC);

    if (FAILED(sc) || pRLUC == 0)
        LogFail("QueryInterface to IRowsetLocate failed\n");

    IRowsetScroll * pRSLC = 0;
    sc = pRowsetLowerCateg->QueryInterface( IID_IRowsetScroll,
                                            (void **)&pRSLC);

    if (FAILED(sc) || pRSLC == 0)
        LogFail("QueryInterface to IRowsetScroll failed\n");
    SCODE scHier = S_OK;
    HROW ahRows[10];
    HROW* phRows = ahRows;
    ULONG cCategories = 0;
    DBCOUNTITEM cRowsTotal = 0;
    DBCOUNTITEM cRowsReturned = 0;

    LONG lAttrPrev = 0xffffffff;

    while (scHier != DB_S_ENDOFROWSET)
    {
        scHier = pRLUC->GetNextRows(0, 0, 10, &cRowsReturned, &phRows);
        if (FAILED(scHier))
            LogFail("pRLUC->GetNextRows failed: 0x%lx\n", scHier);

        cCategories += (ULONG) cRowsReturned;

        for (ULONG row = 0; row < cRowsReturned; row++)
        {
            ChaptBinding data;

            SCODE sc = pRLUC->GetData(phRows[row],hAccCateg,&data);
            if ( FAILED( sc ) )
                LogFail("GetData in UpperLevelCategTest failed: 0x%lx\n",sc);

            LONG lAttr;
            sc = pRLUC->GetData(phRows[row],hAccAttr,&lAttr);
            if ( FAILED( sc ) )
                LogFail("GetData in UpperLevelCategTest failed: 0x%lx\n",sc);

            if (fVerbose > 1)
                printf( "upper level category, attr:: %lx, %lx\n",
                        data.chapt,
                        lAttr );

            if ( lAttrPrev == lAttr )
                LogFail("duplicate attrib categories\n");

            if ( lAttrPrev > lAttr )
                LogFail("categories unsorted by attrib\n");

            lAttrPrev = lAttr;

            DBCOUNTITEM cRows;
            sc = pRSLC->GetApproximatePosition( data.chapt, 0, 0, 0, &cRows );
            if ( FAILED( sc ) )
                LogFail("GetApproximatePosition with chapter failed %x\n", sc);
            cRowsTotal += cRows;

            // then test fetching rows in the category

            MoveTest( pRowsetLowerCateg,
                      data.chapt );

            CategTest( data.chapt,
                       pRowsetLowerCateg,
                       pRowset,
                       cCols );
        }

        sc = pRLUC->ReleaseRows( cRowsReturned, phRows, 0, 0, 0 );
    }

    if (cCategories == 0)
        LogFail("No categories found\n");

    DBCOUNTITEM cRows;
    sc = pRSLC->GetApproximatePosition( DB_NULL_HCHAPTER, 0, 0, 0, &cRows );
    if ( FAILED( sc ) )
        LogFail("GetApproximatePosition with NULL chapter failed %x\n", sc);
    if (cRowsTotal != cRows)
        LogFail("Sum of rows in chapters(%d) is not same as total rows(%d)\n",
                cRowsTotal, cRows);

    ReleaseAccessor( pRLUC, hAccCateg );
    ReleaseAccessor( pRLUC, hAccAttr );

    pRSLC->Release();
    pRLUC->Release();
} //UpperLevelCategTest

//+-------------------------------------------------------------------------
//
//  Function:   MultiLevelCategTest, public
//
//  Synopsis:   Basic query categorization feature test.
//
//  History:    30 Mar 95       dlee     Created
//
//  Notes:      Just looks for files in the system directory.
//
//--------------------------------------------------------------------------

void MultiLevelCategTest()
{
    LogProgress( "Non-content multi-level categorization query\n" );

    SCODE sc;

    WCHAR wcsSysDir[MAX_PATH];

#if 0
    wcscpy(wcsSysDir,L"g:\\winnt\\system32");
#else
    if( !GetSystemDirectory( wcsSysDir, sizeof(wcsSysDir) / sizeof(WCHAR) ) )
        LogFail( "Unable to determine system directory.\n" );
#endif

    //
    // Get name, size and class id for *.exe, *.dll, *.doc, and *.sys
    // Group on attribute, then size.
    //
    CDbColumns cols(8);

    cols.Add( psClassid, 0 );
    cols.Add( psSize, 1 );
    cols.Add( psWriteTime, 2 );
    cols.Add( psAttr, 3 );
    cols.Add( psName, 4 );
    cols.Add( psPath, 5 );
    cols.Add( psSelf, 6 );
    cols.Add( psBookmark, 7);

    CDbNestingNode nest1;

    nest1.AddGroupingColumn( psAttr );

    nest1.AddParentColumn( psBookmark );
    nest1.AddParentColumn( psAttr );

    CDbNestingNode nest2;

    nest2.AddGroupingColumn( psSize );

    nest2.AddParentColumn( psBookmark );
    nest2.AddParentColumn( psSize );

    nest2.AddChildColumn( psClassid );
    nest2.AddChildColumn( psSize );
    nest2.AddChildColumn( psWriteTime );
    nest2.AddChildColumn( psAttr );
    nest2.AddChildColumn( psName );
    nest2.AddChildColumn( psPath );
    nest2.AddChildColumn( psSelf );
    nest2.AddChildColumn( psBookmark);

    CDbPropertyRestriction rst;

    rst.SetRelation( DBOP_like );
    rst.SetProperty( psName );
    rst.SetValue( L"*.|(exe|,dll|,doc|,sys|,zzz|)" );

    CDbSelectNode * pSelect = new CDbSelectNode();
    pSelect->AddRestriction( rst.Clone() );

    nest2.AddTable( pSelect );
    pSelect = 0;
    nest1.AddTable( nest2.Clone() );

    IRowset * pRowsets[3];
    ICommandTree * pCmdTree;

    InstantiateMultipleRowsets(
                            QUERY_SHALLOW,           // Depth
                            wcsSysDir,               // Scope
                            nest1.Clone(),           // DBCOMMANDTREE
                            IID_IRowsetScroll,       // IID for i/f to return
                            3,
                            (IUnknown **)pRowsets,
                            &pCmdTree );

    IRowset *pRowsetUpperCateg = pRowsets[0];
    IRowset *pRowsetLowerCateg = pRowsets[1];
    IRowset *pRowset = pRowsets[2];

    //
    // Verify columns
    //

    CDbColumns chapCols(4);

    chapCols.Add( psBookmark, 0 );
    chapCols.Add( psAttr, 1 );
    chapCols.Add( psChapt, 2 );

    CheckColumns( pRowsetUpperCateg, chapCols );

    chapCols.Add( psSize, 1 );
    chapCols.Add( psChapt, 2 );
    CheckColumns( pRowsetLowerCateg, chapCols );

    CheckColumns( pRowset, cols );

    if ( !WaitForCompletion( pRowset, FALSE ) )
    {
        pRowset->Release();
        LogFail( "Downlevel query unsuccessful.\n" );
    }

    //
    //  Do basic function tests.
    //
    FetchTest(pRowset);

    //
    // Test SetBindings, GetBindings, Move and Scroll
    //
    BindingTest(pRowset);
    BindingTest(pCmdTree, TRUE);

    MoveTest( pRowsetUpperCateg );

    UpperLevelCategTest( pRowsetUpperCateg,
                         pRowsetLowerCateg,
                         pRowset,
                         cBasicTestCols );

    pCmdTree->Release();

    pRowset->Release();

    pRowsetUpperCateg->Release();
    pRowsetLowerCateg->Release();

} //MultiLevelCategTest

#endif // DO_MULTI_LEVEL_CATEG_TEST

//+-------------------------------------------------------------------------
//
//  Function:   RunPropQuery, public
//
//  Synopsis:   Execute a retricted query and check results
//
//  History:
//
//--------------------------------------------------------------------------

static DBBINDING aPropTestColsByRef[] =
{
  { 0, 0 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 1, 1 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 2, 2 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 3, 3 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { sizeof( PROPVARIANT * ), 4 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 5, 5 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 6, 6 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 7, 7 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 8, 8 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 9, 9 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 10,10* (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 11,11* (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 12,12* (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 13,13* (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
};

const ULONG cPropTestColsByRef = sizeof aPropTestColsByRef /
                                 sizeof aPropTestColsByRef[0];


LPWSTR aPropTestColNames[] = {
    L"TestProp1",
    L"TestProp2",
    L"Author",
    L"Keywords",
    L"RelevantWords",
    L"MyBlob",
    L"MyGuid",
    L"ManyRW",
    L"SecurityTest",
    L"TestProp10",
    L"TestProp11",
    L"TestProp12",
    L"TestProp21",
    L"TestProp22",
    L"Path",
};


void RunPropQueryByRefBindings(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    //
    // Get twelve properties back
    //

    CDbColumns cols(cPropTestColsByRef);
    cols.Add( psTestProperty1, 0 );
    cols.Add( psTestProperty2, 1 );
    cols.Add( psAuthor, 2 );
    cols.Add( psKeywords, 3 );
    cols.Add( psRelevantWords, 4 );
    cols.Add( psBlobTest, 5 );
    cols.Add( psGuidTest, 6 );
    cols.Add( psManyRW, 7 );
    cols.Add( psSecurityTest, 8 );
    cols.Add( psTestProperty10, 9 );
    cols.Add( psTestProperty11, 10 );
    cols.Add( psTestProperty12, 11 );
    cols.Add( psTestProperty21, 12 );
    cols.Add( psTestProperty22, 13 );
    if (isEven( numTest/2 ))
        cols.Add( psPath, cols.Count() );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss(cPropSortColumns);
    for (unsigned i = 0; i < cPropSortColumns; i++)
        ss.Add (aPropSortCols[i], i);

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss,
                                                 aPropTestColNames );
    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,          // Depth
                                0,                      // Scope
                                pDbCmdTree,             // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        LogError( "property query unsuccessful.\n" );
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowset->GetRowsAt A returned 0x%x\n", sc );
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQueryByRefBindings, %d returned rows, expected 0\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt B returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt C returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cPropTestColsByRef];
    aDbCols[0] = psTestProperty1;
    aDbCols[1] = psTestProperty2;
    aDbCols[2] = psAuthor;
    aDbCols[3] = psKeywords;
    aDbCols[4] = psRelevantWords;
    aDbCols[5] = psBlobTest;
    aDbCols[6] = psGuidTest;
    aDbCols[7] = psManyRW;
    aDbCols[8] = psSecurityTest;
    aDbCols[9] = psTestProperty10;
    aDbCols[10] = psTestProperty11;
    aDbCols[11] = psTestProperty12;
    aDbCols[12] = psTestProperty21;
    aDbCols[13] = psTestProperty22;

    IUnknown * pAccessor = (IUnknown *) pRowset; // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below

    HACCESSOR hAccessor = MapColumns( pAccessor, cPropTestColsByRef,
                                      aPropTestColsByRef, aDbCols, TRUE);

    //
    // Fetch the data
    //

    PROPVARIANT * aVarnt[cPropTestColsByRef];

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, aVarnt);

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        // Ascending sort, prop1 > prop1Alternate.
        // If one hit, it's PROP1_VAL, not the alternate.
        // prop1=1234, alternate=123

        BOOL fAlternate = FALSE;
        if ( fSeq )
        {
            if ( 1 == cRowsReturned )
            {
                varProp1.lVal = PROP1_VAL;
                CheckPropertyValue( *aVarnt[0], varProp1 );
            }
            else
            {
                // no sort order -- it's either prop1 or alternate

                if ( PROP1_TYPE != aVarnt[0]->vt )
                    LogFail( "bad datatype for prop1: 0x%x\n", aVarnt[0]->vt );

                if ( PROP1_VAL != aVarnt[0]->lVal &&
                     PROP1_VAL_Alternate != aVarnt[0]->lVal )
                    LogFail( "bad value for prop1: 0x%x\n", aVarnt[0]->lVal );
                fAlternate = aVarnt[0]->lVal == PROP1_VAL_Alternate;
            }
        }
        else
        {
            fAlternate = (0 == row) && (1 != cRowsReturned);
            varProp1.lVal = fAlternate ?
                            PROP1_VAL_Alternate :
                            PROP1_VAL;
            CheckPropertyValue( *aVarnt[0], varProp1 );
        }

        CheckPropertyValue( *aVarnt[1], varProp2 );
        CheckPropertyValue( *aVarnt[2], varProp3 );
        CheckPropertyValue( *aVarnt[3], varProp4 );
        CheckPropertyValue( *aVarnt[4], varProp5 );
        CheckPropertyValue( *aVarnt[5], varProp6 );
        CheckPropertyValue( *aVarnt[6], varProp7 );
        CheckPropertyValue( *aVarnt[7], fAlternate ? varProp8A : varProp8 );
        CheckPropertyValue( *aVarnt[8], varProp9 );
        CheckPropertyValue( *aVarnt[9], varProp10 );
        if ( aVarnt[10]->vt == VT_BSTR &&
             SysStringLen( aVarnt[10]->bstrVal) < 1000 )
        {
            CheckPropertyValue( *aVarnt[10], varProp11 );
        }
        else
        {
            CheckPropertyValue( *aVarnt[10], varProp11A );
        }
        CheckPropertyValue( *aVarnt[11], varProp12 );
        CheckPropertyValue( *aVarnt[12], varProp21 );
        CheckPropertyValue( *aVarnt[13], varProp22 );
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunPropQueryByRefBindings

struct SPropTestColsTight
{
    int         p1_i4;
    WCHAR *     p2_pwc;
    WCHAR *     p3_pwc;
    int         dummy1;  // vectors need 8 byte alignment
    DBVECTOR    p4_vpwc;
    DBVECTOR    p5_vi;
    PROPVARIANT* p6_pvar;
    GUID *      p7_pguid;
    DBVECTOR    p8_vi;
    SAFEARRAY * p8a_ai;
    int         p9_i4;
    WCHAR *     p10_pwc;
    BSTR        p11_pwc;
    DBVECTOR    p12_vpwc;
    CLIPDATA *  p21_pclipdata;
    int         dummy3;  // vectors need 8 byte alignment
    CACLIPDATA  p22_caclipdata;
    WCHAR *     p2a_pwc;

    DBLENGTH    p1_cb;
    DBLENGTH    p2_cb;
    DBLENGTH    p3_cb;
    DBLENGTH    p4_cb;
    DBLENGTH    p5_cb;
    DBLENGTH    p6_cb;
    DBLENGTH    p7_cb;
    DBLENGTH    p8_cb;
    DBLENGTH    p8a_cb;
    DBLENGTH    p9_cb;
    DBLENGTH    p10_cb;
    DBLENGTH    p11_cb;
    DBLENGTH    p12_cb;
    DBLENGTH    p21_cb;
    DBLENGTH    p22_cb;
    DBLENGTH    p2a_cb;

    ULONG       p1_status;
    ULONG       p2_status;
    ULONG       p3_status;
    ULONG       p4_status;
    ULONG       p5_status;
    ULONG       p6_status;
    ULONG       p7_status;
    ULONG       p8_status;
    ULONG       p8a_status;
    ULONG       p9_status;
    ULONG       p10_status;
    ULONG       p11_status;
    ULONG       p12_status;
    ULONG       p21_status;
    ULONG       p22_status;
    ULONG       p2a_status;
};

#define DBTYPE_BRWSTR ( DBTYPE_BYREF | DBTYPE_WSTR )

static DBBINDING aPropTestColsTight[] =
{
  { 0,
    offsetof(SPropTestColsTight,p1_i4),
    offsetof(SPropTestColsTight,p1_cb),
    offsetof(SPropTestColsTight,p1_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof ULONG, 0,
    DBTYPE_I4,
    0, 0 },
  { 1,
    offsetof(SPropTestColsTight,p2_pwc),
    offsetof(SPropTestColsTight,p2_cb),
    offsetof(SPropTestColsTight,p2_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (WCHAR *), 0,
    DBTYPE_BRWSTR,
    0, 0 },
  { 2,
    offsetof(SPropTestColsTight,p3_pwc),
    offsetof(SPropTestColsTight,p3_cb),
    offsetof(SPropTestColsTight,p3_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (WCHAR *), 0,
    DBTYPE_BRWSTR,
    0, 0 },
  { 3,
    offsetof(SPropTestColsTight,p4_vpwc),
    offsetof(SPropTestColsTight,p4_cb),
    offsetof(SPropTestColsTight,p4_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof DBVECTOR, 0,
    DBTYPE_VECTOR|VT_LPWSTR,
    0, 0 },
  { 4,
    offsetof(SPropTestColsTight,p5_vi),
    offsetof(SPropTestColsTight,p5_cb),
    offsetof(SPropTestColsTight,p5_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof DBVECTOR, 0,
    DBTYPE_VECTOR|DBTYPE_I4,
    0, 0 },
  { 5,
    offsetof(SPropTestColsTight,p6_pvar),
    offsetof(SPropTestColsTight,p6_cb),
    offsetof(SPropTestColsTight,p6_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (PROPVARIANT *), 0,
    DBTYPE_VARIANT|DBTYPE_BYREF,
    0, 0 },
  { 6,
    offsetof(SPropTestColsTight,p7_pguid),
    offsetof(SPropTestColsTight,p7_cb),
    offsetof(SPropTestColsTight,p7_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (GUID *), 0,
    DBTYPE_GUID|DBTYPE_BYREF,
    0, 0 },
  { 7,
    offsetof(SPropTestColsTight,p8_vi),
    offsetof(SPropTestColsTight,p8_cb),
    offsetof(SPropTestColsTight,p8_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof DBVECTOR, 0,
    DBTYPE_VECTOR|DBTYPE_I4,
    0, 0 },
  { 8,
    offsetof(SPropTestColsTight,p9_i4),
    offsetof(SPropTestColsTight,p9_cb),
    offsetof(SPropTestColsTight,p9_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof ULONG, 0,
    DBTYPE_I4,
    0, 0 },
  { 9,
    offsetof(SPropTestColsTight,p10_pwc),
    offsetof(SPropTestColsTight,p10_cb),
    offsetof(SPropTestColsTight,p10_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (WCHAR *), 0,
    DBTYPE_BRWSTR,
    0, 0 },
  { 10,
    offsetof(SPropTestColsTight,p11_pwc),
    offsetof(SPropTestColsTight,p11_cb),
    offsetof(SPropTestColsTight,p11_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (BSTR), 0,
    DBTYPE_BSTR,
    0, 0 },
  { 11,
    offsetof(SPropTestColsTight,p12_vpwc),
    offsetof(SPropTestColsTight,p12_cb),
    offsetof(SPropTestColsTight,p12_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof DBVECTOR, 0,
    DBTYPE_VECTOR|DBTYPE_BSTR,
    0, 0 },
  { 12,
    offsetof(SPropTestColsTight,p21_pclipdata),
    offsetof(SPropTestColsTight,p21_cb),
    offsetof(SPropTestColsTight,p21_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( CLIPDATA * ), 0,
    VT_CF | DBTYPE_BYREF,
    0, 0 },
  { 13,
    offsetof(SPropTestColsTight,p22_caclipdata),
    offsetof(SPropTestColsTight,p22_cb),
    offsetof(SPropTestColsTight,p22_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof CACLIPDATA, 0,
    DBTYPE_VECTOR | VT_CF,
    0, 0 },
  { 14,         // Prop 2 again, as a different type
    offsetof(SPropTestColsTight,p2a_pwc),
    offsetof(SPropTestColsTight,p2a_cb),
    offsetof(SPropTestColsTight,p2a_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    30, 0,
    DBTYPE_WSTR | DBTYPE_BYREF,
    0, 0 },
  { 15,         // Prop 8 again, as a different type
    offsetof(SPropTestColsTight,p8a_ai),
    offsetof(SPropTestColsTight,p8a_cb),
    offsetof(SPropTestColsTight,p8a_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_I4,
    0, 0 },
};

const ULONG cPropTestColsTight = sizeof aPropTestColsTight /
                                 sizeof aPropTestColsTight[0];

void RunPropQueryTightBindings(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    //
    // Get twelve properties back
    //

    CDbColumns cols(cPropTestColsTight);
    cols.Add( psTestProperty1, 0 );
    cols.Add( psTestProperty2, 1 );
    cols.Add( psAuthor, 2 );
    cols.Add( psKeywords, 3 );
    cols.Add( psRelevantWords, 4 );
    cols.Add( psBlobTest, 5 );
    cols.Add( psGuidTest, 6 );
    cols.Add( psManyRW, 7 );
    cols.Add( psSecurityTest, 8 );
    cols.Add( psTestProperty10, 9 );
    cols.Add( psTestProperty11, 10 );
    cols.Add( psTestProperty12, 11 );
    cols.Add( psTestProperty21, 12 );
    cols.Add( psTestProperty22, 13 );

    CDbSortSet ss(cPropSortColumns);
    for (unsigned i = 0; i < cPropSortColumns; i++)
        ss.Add (aPropSortCols[i], i);

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree(&PropRst, cols, &ss);
    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,          // Depth
                                0,                      // Scope
                                pDbCmdTree,             // DBCOMMANDTREE
                                IID_IRowsetScroll,      // IID for i/f to return
                                0,
                                &pCmdTree,
                                TRUE );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        LogError( "property query unsuccessful.\n" );
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetRowsAt(0,0, 1, &bmkFirst, 0, 10, &cRowsReturned,
                                  &pgrhRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowset->GetRowsAt D returned 0x%x\n", sc );
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
        {
            LogError("RunPropQueryTightBindings, %d returned rows, expected 0\n",
                    cRowsReturned);
#if defined(UNIT_TEST)
            cFailures++;
            return;
#else
            Fail();
#endif
        }
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt E returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt F returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cPropTestColsTight];
    aDbCols[0] = psTestProperty1;
    aDbCols[1] = psTestProperty2;
    aDbCols[2] = psAuthor;
    aDbCols[3] = psKeywords;
    aDbCols[4] = psRelevantWords;
    aDbCols[5] = psBlobTest;
    aDbCols[6] = psGuidTest;
    aDbCols[7] = psManyRW;
    aDbCols[8] = psSecurityTest;
    aDbCols[9] = psTestProperty10;
    aDbCols[10] = psTestProperty11;
    aDbCols[11] = psTestProperty12;
    aDbCols[12] = psTestProperty21;
    aDbCols[13] = psTestProperty22;
    aDbCols[14] = psTestProperty2;      // repeated
    aDbCols[15] = psManyRW;             // repeated


    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below

    HACCESSOR hAccessor = MapColumns( pAccessor, cPropTestColsTight,
                                      aPropTestColsTight, aDbCols, TRUE);

    //
    // Fetch the data
    //

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        SPropTestColsTight sRow;

        // Ascending sort, prop1 > prop1Alternate.
        // If one hit, it's not the alternate.

        BOOL fAlternate = (0 == row) && (1 != cRowsReturned);

        sc = pRowset->GetData( pgrhRows[row], hAccessor, & sRow );

        // Either the conversion of varProp8 to array will fail, or the
        // conversion of varProp8A to vector will fail.
        if (DB_S_ERRORSOCCURRED != sc && !fAlternate)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            LogError("IRowset->GetData returned 0x%x (expected 0x40eda)\n",sc);
            if (S_OK != sc &&
                DB_E_ERRORSOCCURRED != sc)
            {
                pCmdTree->Release();
                pRowset->Release();
                Fail();
            }
        }

        if (DB_S_ERRORSOCCURRED != sc && fAlternate)
        {
            // Prop 8 should fail to convert for alternate row.
            LogError("IRowset->GetData returned 0x%x (expected 0x40eda)\n",sc);
            if (S_OK != sc && DB_E_ERRORSOCCURRED != sc)
            {
                pCmdTree->Release();
                pRowset->Release();
                Fail();
            }
        }

        //
        // Verify the data.  Put output data into variants for comparison
        //

        PROPVARIANT vTest;

        if ( DBSTATUS_S_OK != sRow.p1_status )
            LogFail( "status of property 1 is bad: %x\n", sRow.p1_status );
        varProp1.lVal = fAlternate ? PROP1_VAL_Alternate : PROP1_VAL;
        vTest.vt = DBTYPE_I4;
        vTest.iVal = (SHORT) sRow.p1_i4;
        CheckPropertyValue( vTest, varProp1 );
        if ( sRow.p1_cb != PROP1_cb )
            LogFail( "cb of property 1 is %ld, should be %ld\n",
                     sRow.p1_cb, PROP1_cb );

        if ( DBSTATUS_S_OK != sRow.p2_status )
            LogFail( "status of property 2 is bad: %x\n", sRow.p2_status );
        vTest.vt = VT_LPWSTR;
        vTest.pwszVal = sRow.p2_pwc;
        CheckPropertyValue( vTest, varProp2 );
        if ( sRow.p2_cb != PROP2_cb )
            LogFail( "cb of property 2 is %ld, should be %ld\n",
                     sRow.p2_cb, PROP2_cb );

        if ( DBSTATUS_S_OK != sRow.p3_status )
            LogFail( "status of property 3 is bad: %x\n", sRow.p3_status );
        vTest.vt = VT_LPWSTR;
        vTest.pwszVal = sRow.p3_pwc;
        CheckPropertyValue( vTest, varProp3 );
        if ( sRow.p3_cb != PROP3_cb )
            LogFail( "cb of property 3 is %ld, should be %ld\n",
                     sRow.p3_cb, PROP3_cb );

        if ( DBSTATUS_S_OK != sRow.p4_status )
            LogFail( "status of property 4 is bad: %x\n", sRow.p4_status );
        vTest.vt = VT_VECTOR | VT_LPWSTR;
        memcpy( & vTest.cal, & sRow.p4_vpwc, sizeof DBVECTOR );
        CheckPropertyValue( vTest, varProp4 );
        if ( sRow.p4_cb != PROP4_cb )
            LogFail( "cb of property 4 is %ld, should be %ld\n",
                     sRow.p4_cb, PROP4_cb );

        if ( DBSTATUS_S_OK != sRow.p5_status )
            LogFail( "status of property 5 is bad: %x\n", sRow.p5_status );
        vTest.vt = VT_VECTOR | VT_I4;
        memcpy( & vTest.cal, & sRow.p5_vi, sizeof DBVECTOR );
        CheckPropertyValue( vTest, varProp5 );
        if ( sRow.p5_cb != PROP5_cb )
            LogFail( "cb of property 5 is %ld, should be %ld\n",
                     sRow.p5_cb, PROP5_cb );

        if ( DBSTATUS_S_OK != sRow.p6_status )
            LogFail( "status of property 6 is bad: %x\n", sRow.p6_status );
        CheckPropertyValue( *sRow.p6_pvar, varProp6 );
        // is cb of 20 right, or is 0 right?  blobs aren't in OLEDB!
        if ( sRow.p6_cb != PROP6_cb )
            LogFail( "cb of property 6 is %ld, should be %ld\n",
                     sRow.p6_cb, PROP6_cb );

        if ( DBSTATUS_S_OK != sRow.p7_status )
            LogFail( "status of property 7 is bad: %x\n", sRow.p7_status );
        vTest.vt = VT_CLSID;
        vTest.puuid = sRow.p7_pguid;
        CheckPropertyValue( vTest, varProp7 );
        if ( sRow.p7_cb != PROP7_cb )
            LogFail( "cb of property 7 is %ld, should be %ld\n",
                     sRow.p7_cb, PROP7_cb );


        if (! fAlternate)
        {
            if ( DBSTATUS_S_OK != sRow.p8_status )
                LogFail( "status of property 8 is bad: %x\n", sRow.p8_status );
            if ( DBSTATUS_E_CANTCONVERTVALUE != sRow.p8a_status )
                LogFail( "alt. status of property 8 is OK for prim: %x\n", sRow.p8a_status );
            vTest.vt = VT_VECTOR | VT_I4;
            memcpy( & vTest.cal, & sRow.p8_vi, sizeof DBVECTOR );
            CheckPropertyValue( vTest, varProp8 );
            if ( sRow.p8_cb != PROP8_cb )
                LogFail( "cb of property 8 is %ld, should be %ld\n",
                         sRow.p8_cb, PROP8_cb );
        }
        else
        {
            if ( DBSTATUS_E_CANTCONVERTVALUE != sRow.p8_status )
                LogFail( "status of property 8 is OK for alt: %x\n", sRow.p8_status );
            if ( DBSTATUS_S_OK != sRow.p8a_status )
                LogFail( "alt status of property 8 is bad: %x\n", sRow.p8a_status );
            vTest.vt = VT_ARRAY | VT_I4;
            memcpy( &vTest.parray, &sRow.p8a_ai, sizeof (SAFEARRAY *) );
            CheckPropertyValue( vTest, varProp8A );
        }

        // can't see prop9 due to its no-read security
        if ( DBSTATUS_S_ISNULL != sRow.p9_status )
            LogFail( "status of property 9 is bad: %x\n", sRow.p9_status );
        if ( 0 != sRow.p9_cb )
            LogFail( "cb of property 9 is bad: %x\n", sRow.p9_cb );

        if ( DBSTATUS_S_OK != sRow.p10_status )
            LogFail( "status of property 10 is bad: %x\n", sRow.p10_status );
        vTest.vt = VT_LPWSTR;
        vTest.pwszVal = sRow.p10_pwc;
        CheckPropertyValue( vTest, varProp10 );
        if ( sRow.p10_cb != PROP10_cb )
            LogFail( "cb of property 10 is %ld, should be %ld\n",
                     sRow.p10_cb, PROP10_cb );

        if ( DBSTATUS_S_OK != sRow.p11_status )
            LogFail( "status of property 11 is bad: %x\n", sRow.p11_status );
        vTest.vt = VT_BSTR;
        vTest.pwszVal = sRow.p11_pwc;
        // Note: prop 11 conditional on size...
        if ( SysStringLen(sRow.p11_pwc) > 1000)
        {
            CheckPropertyValue( vTest, varProp11A );
        }
        else
        {
            CheckPropertyValue( vTest, varProp11 );
        }

        // NOTE: the length of a BSTR is sizeof BSTR
        //unsigned PROP11_cb = SysStringLen(varProp11.bstrVal) * sizeof (OLECHAR)
        //                      + sizeof (DWORD) + sizeof (OLECHAR);
        unsigned PROP11_cb = sizeof BSTR;
        if ( sRow.p11_cb != PROP11_cb )
            LogFail( "cb of property 11 is %ld, should be %ld\n",
                     sRow.p11_cb, PROP11_cb );

        if ( DBSTATUS_S_OK != sRow.p12_status )
            LogFail( "status of property 12 is bad: %x\n", sRow.p12_status );
        vTest.vt = VT_VECTOR | VT_BSTR;
        memcpy( & vTest.cal, & sRow.p12_vpwc, sizeof DBVECTOR );
        CheckPropertyValue( vTest, varProp12 );
        if ( sRow.p12_cb != PROP4_cb )
            LogFail( "cb of property 12 is %ld, should be %ld\n",
                     sRow.p12_cb, PROP4_cb );

        if ( DBSTATUS_S_OK != sRow.p21_status )
            LogFail( "status of property 21 is bad: %x\n", sRow.p21_status );
        vTest.vt = VT_CF;
        vTest.pclipdata = sRow.p21_pclipdata;
        CheckPropertyValue( vTest, varProp21 );
        if ( sRow.p21_cb != PROP21_cb )
            LogFail( "cb of property 21 is %ld, should be %ld\n",
                     sRow.p21_cb, PROP21_cb );

        if ( DBSTATUS_S_OK != sRow.p22_status )
            LogFail( "status of property 22 is bad: %x\n", sRow.p22_status );
        vTest.vt = VT_VECTOR | VT_CF;
        vTest.caclipdata = sRow.p22_caclipdata;
        CheckPropertyValue( vTest, varProp22 );
        if ( sRow.p22_cb != PROP22_cb )
            LogFail( "cb of property 22 is %ld, should be %ld\n",
                     sRow.p22_cb, PROP22_cb );

        if ( DBSTATUS_S_OK != sRow.p2a_status )
            LogFail( "status of property 2 as WSTR is bad: %x\n", sRow.p2a_status );

        vTest.vt = VT_LPWSTR;
        vTest.pwszVal = sRow.p2a_pwc;
        CheckPropertyValue( vTest, varProp2 );

        if ( sRow.p2a_cb != PROP2_cb )
            LogFail( "cb of property 2 as WSTR is %ld, should be %ld\n",
                     sRow.p2a_cb, PROP2_cb );
        // Don't free anything -- this is byref
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();

} //RunPropQueryTightBindings

//+-------------------------------------------------------------------------
//
//  Function:   RunPropQuery, public
//
//  Synopsis:   Execute a retricted query and check results
//
//  History:
//
//--------------------------------------------------------------------------

static DBBINDING aPropTestCols[] =
{
  { 0, 0 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 1, 1 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 2, 2 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 3, 3 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 4, 4 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 5, 5 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 6, 6 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 7, 7 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 8, 8 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 9, 9 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 10,10* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 11,11* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 12,12* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 13,13* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
};

const ULONG cPropTestCols = sizeof aPropTestCols / sizeof aPropTestCols[0];

void RunPropQuery(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    RunPropQueryTightBindings( pQuery, PropRst, cExpectedHits, numTest );
    RunPropQueryByRefBindings( pQuery, PropRst, cExpectedHits, numTest );

    //
    // Get twelve properties back
    //

    CDbColumns cols(cPropTestCols);
    cols.Add( psTestProperty1, 0 );
    cols.Add( psTestProperty2, 1 );
    cols.Add( psAuthor, 2 );
    cols.Add( psKeywords, 3 );
    cols.Add( psRelevantWords, 4 );
    cols.Add( psBlobTest, 5 );
    cols.Add( psGuidTest, 6 );
    cols.Add( psManyRW, 7 );
    cols.Add( psSecurityTest, 8 );
    cols.Add( psTestProperty10, 9 );
    cols.Add( psTestProperty11, 10 );
    cols.Add( psTestProperty12, 11 );
    cols.Add( psTestProperty21, 12 );
    cols.Add( psTestProperty22, 13 );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss(cPropSortColumns);
    for (unsigned i = 0; i < cPropSortColumns; i++)
        ss.Add (aPropSortCols[i], i);

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss );

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "IRowset->GetRowsAt G returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt H returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt I returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cPropTestCols];
    aDbCols[0] = psTestProperty1;
    aDbCols[1] = psTestProperty2;
    aDbCols[2] = psAuthor;
    aDbCols[3] = psKeywords;
    aDbCols[4] = psRelevantWords;
    aDbCols[5] = psBlobTest;
    aDbCols[6] = psGuidTest;
    aDbCols[7] = psManyRW;
    aDbCols[8] = psSecurityTest;
    aDbCols[9] = psTestProperty10;
    aDbCols[10] = psTestProperty11;
    aDbCols[11] = psTestProperty12;
    aDbCols[12] = psTestProperty21;
    aDbCols[13] = psTestProperty22;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns(pAccessor, cPropTestCols, aPropTestCols, aDbCols);

    //
    // Fetch the data
    //

    PROPVARIANT aVarnt[cPropTestCols];

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, aVarnt);

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        // Ascending sort, prop1 > prop1Alternate.
        // If one hit, it's PROP1_VAL, not the alternate.
        // prop1=1234, alternate=123

        BOOL fAlternate = FALSE;
        if ( fSeq )
        {
            if ( 1 == cRowsReturned )
            {
                varProp1.lVal = PROP1_VAL;
                CheckPropertyValue( aVarnt[0], varProp1 );
            }
            else
            {
                // no sort order -- it's either prop1 or alternate

                if ( PROP1_TYPE != aVarnt[0].vt )
                    LogFail( "bad datatype for prop1: 0x%x\n", aVarnt[0].vt );

                if ( PROP1_VAL != aVarnt[0].lVal &&
                     PROP1_VAL_Alternate != aVarnt[0].lVal )
                    LogFail( "bad value for prop1: 0x%x\n", aVarnt[0].lVal );
                fAlternate = aVarnt[0].lVal == PROP1_VAL_Alternate;
            }
        }
        else
        {
            fAlternate = (0 == row) && (1 != cRowsReturned);
            varProp1.lVal = fAlternate ?
                                PROP1_VAL_Alternate :
                                PROP1_VAL;
            CheckPropertyValue( aVarnt[0], varProp1 );
        }

        CheckPropertyValue( aVarnt[1], varProp2 );
        CheckPropertyValue( aVarnt[2], varProp3 );
        CheckPropertyValue( aVarnt[3], varProp4 );
        CheckPropertyValue( aVarnt[4], varProp5 );
        CheckPropertyValue( aVarnt[5], varProp6 );
        CheckPropertyValue( aVarnt[6], varProp7 );
        CheckPropertyValue( aVarnt[7], fAlternate ? varProp8A : varProp8 );
        CheckPropertyValue( aVarnt[8], varProp9 );
        CheckPropertyValue( aVarnt[9], varProp10 );
        if ( aVarnt[10].vt == VT_BSTR &&
             SysStringLen( aVarnt[10].bstrVal) < 1000 )
        {
            CheckPropertyValue( aVarnt[10], varProp11 );
        }
        else
        {
            CheckPropertyValue( aVarnt[10], varProp11A );
        }
        CheckPropertyValue( aVarnt[11], varProp12 );
        CheckPropertyValue( aVarnt[12], varProp21 );
        CheckPropertyValue( aVarnt[13], varProp22 );

        //
        // Free extra data allocated byref in the variants above
        //

        CoTaskMemFree(aVarnt[1].pwszVal);
        CoTaskMemFree(aVarnt[2].pwszVal);

        for (unsigned x = 0; x < aVarnt[3].calpwstr.cElems; x++ )
            CoTaskMemFree( aVarnt[3].calpwstr.pElems[ x ] );

        CoTaskMemFree(aVarnt[3].calpwstr.pElems);
        CoTaskMemFree(aVarnt[4].cal.pElems);
        CoTaskMemFree(aVarnt[5].blob.pBlobData);
        CoTaskMemFree(aVarnt[6].puuid);

        // sometimes a VT_VECTOR, sometimes a VT_ARRAY

        HRESULT hrPVC = PropVariantClear( &aVarnt[7] );
        if ( S_OK != hrPVC )
            LogError( "bad propvariant clear: %#x\n", hrPVC );

        // nothing to free for [8] -- insufficient security to load value
        CoTaskMemFree(aVarnt[9].pwszVal);
        PropVariantClear(&aVarnt[10]);
        PropVariantClear(&aVarnt[11]);
        PropVariantClear(&aVarnt[12]);
        PropVariantClear(&aVarnt[13]);
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunPropQuery



const int COERCE_PROP_BUF_SIZE = 129;

struct CoercePropStruct
{
    char szProp13[COERCE_PROP_BUF_SIZE];
    char szProp14[COERCE_PROP_BUF_SIZE];
    char szProp15[COERCE_PROP_BUF_SIZE];
    char szProp16[COERCE_PROP_BUF_SIZE];
    char szProp17[COERCE_PROP_BUF_SIZE];
    char szProp18[COERCE_PROP_BUF_SIZE];
    char szProp19[COERCE_PROP_BUF_SIZE];
    char szProp7[COERCE_PROP_BUF_SIZE];
    double szProp20;
} ;


static DBBINDING aPropTestCoerceCols[] =
{

  { 0, COERCE_PROP_BUF_SIZE * 0, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop13

  { 1, COERCE_PROP_BUF_SIZE * 1, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop14

  { 2, COERCE_PROP_BUF_SIZE * 2, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop15

  { 3, COERCE_PROP_BUF_SIZE * 3, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop16

  { 4, COERCE_PROP_BUF_SIZE * 4, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    4, 0, DBTYPE_STR, 0, 0}, // prop17  // give smaller size to test if truncation works

  { 5, COERCE_PROP_BUF_SIZE * 5, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, //prop18

  { 6, COERCE_PROP_BUF_SIZE * 6, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop19

  { 7, COERCE_PROP_BUF_SIZE * 7, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0},   // prop7

  { 8, COERCE_PROP_BUF_SIZE * 8, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof( double ), 0, DBTYPE_R8, 0, 0}   // prop20
};

const ULONG cPropTestCoerceCols = sizeof aPropTestCoerceCols / sizeof aPropTestCoerceCols[0];


void RunPropQueryAndCoerce(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{

    CoercePropStruct CoerceResultTestData;

    // set up the expected result data
    memset( &CoerceResultTestData, 0, sizeof CoercePropStruct );
    strcpy( CoerceResultTestData.szProp13, PROP13_STR_VAL );
    strcpy( CoerceResultTestData.szProp14, PROP14_STR_VAL );
    strcpy( CoerceResultTestData.szProp15, PROP15_STR_VAL );
    strcpy( CoerceResultTestData.szProp16, PROP16_STR_VAL );
    strcpy( CoerceResultTestData.szProp17, PROP17_STR_VAL );
    strcpy( CoerceResultTestData.szProp18, PROP18_STR_VAL );
    strcpy( CoerceResultTestData.szProp19, PROP19_STR_VAL );
    strcpy( CoerceResultTestData.szProp7,  PROP7_STR_VAL );
    CoerceResultTestData.szProp20 = PROP20_DBL_VAL;

    CDbColumns cols(cPropTestCoerceCols);
    cols.Add( psTestProperty13, 0 );
    cols.Add( psTestProperty14, 1 );
    cols.Add( psTestProperty15, 2 );
    cols.Add( psTestProperty16, 3 );
    cols.Add( psTestProperty17, 4 );
    cols.Add( psTestProperty18, 5 );
    cols.Add( psTestProperty19, 6 );
    cols.Add( psGuidTest, 7 );
    cols.Add( psTestProperty20, 8 );

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 0);

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                IID_IRowset,  // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "RunPropQueryAndCoerce IRowset->GetNextRows A returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQueryAndCoerce, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "RunPropQueryAndCoerce IRowset->GetNextRows C returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "RunPropQueryAndCoerce IRowset->GetNextRows D returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cPropTestCoerceCols];

    aDbCols[0] = psTestProperty13;
    aDbCols[1] = psTestProperty14;
    aDbCols[2] = psTestProperty15;
    aDbCols[3] = psTestProperty16;
    aDbCols[4] = psTestProperty17;
    aDbCols[5] = psTestProperty18;
    aDbCols[6] = psTestProperty19;
    aDbCols[7] = psGuidTest;
    aDbCols[8] = psTestProperty20;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns(pAccessor, cPropTestCoerceCols, aPropTestCoerceCols, aDbCols);

    //
    // Fetch the data
    //

    //PROPVARIANT aVarnt[cPropTestCols];

    CoercePropStruct rowData;

    memset( &rowData, 0, sizeof CoercePropStruct );

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, &rowData);

        if (S_OK != sc)
        {
            LogError("RunPropQueryAndCoerce IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        // verify
        if ( memcmp( &rowData, &CoerceResultTestData, sizeof CoercePropStruct ) )
        {
            LogFail( "RunPropQueryAndCoerce failed." );
        }

    }
    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunPropQueryAndCoerce



//+-------------------------------------------------------------------------
//
//  Function:   RunDistribQueryTest, public
//
//  Synopsis:   Minimal test for the distributed rowset
//
//  History:    07 Oct 98   vikasman    created
//
//  Notes:      This is a pretty minimal test; should try sorted and
//              scrollable (all combinations), larger result sets
//
//--------------------------------------------------------------------------

void RunDistribQueryTest( BOOL fDoContentTest )
{
    LogProgress( "Distributed Query Test\n" );

    IUnknown * pIUnknown;
    ICommand * pQuery = 0;

    SCODE scIC = CICreateCommand( &pIUnknown,
                                  0,
                                  IID_IUnknown,
                                  TEST_CATALOG,
                                  TEST_MACHINE );
    if ( FAILED( scIC ) )
        LogFail( "RunDistribQueryTest - error 0x%x Unable to create ICommand\n",
                 scIC );

    scIC = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );
    pIUnknown->Release();

    if ( FAILED( scIC ) )
        LogFail( "RunDistribQueryTest - error 0x%x Unable to QI ICommand\n",
                 scIC  );

    if ( 0 == pQuery )
        LogFail( "RunDistribQueryTest - CICreateCommand succeeded, but returned null pQuery\n" );

    WCHAR * awcMachines[2];
    WCHAR * awcCatalogs[2];
    WCHAR * awcScopes[2];
    WCHAR aComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD aDepths[2];
    ULONG cComputerName = MAX_COMPUTERNAME_LENGTH + 1;

    GetComputerName( aComputerName, &cComputerName );

    awcMachines[0] = TEST_MACHINE;
    awcCatalogs[0] = TEST_CATALOG;
    awcScopes[0]   = wcsTestPath;
    aDepths[0]     = QUERY_SHALLOW;

    awcMachines[1] = aComputerName;
    awcCatalogs[1] = TEST_CATALOG;
    awcScopes[1]   = wcsTestPath;
    aDepths[1]     = QUERY_SHALLOW;
    

    scIC = SetScopeProperties( pQuery,
                               2,
                               awcScopes,
                               aDepths,
                               awcCatalogs,
                               awcMachines );

    if ( FAILED( scIC ) )
        LogFail( "RunDistribQueryTest - error 0x%x Unable to set scope '%ws'\n",
                 scIC, wcsTestPath );

    CheckPropertiesOnCommand( pQuery );

    unsigned numTest = 1;

    // singleton DBOP_equal singleton - Coersion test
    {
        LogProgress( " DistributedRowset -  Property coercion to String test\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( PROP1_VAL );
        RunPropQueryAndCoerce( pQuery, PropRst, 2, numTest++ );
    }

    pQuery->Release();
}


//+-------------------------------------------------------------------------
//
//  Function:   RunPropTest, public
//
//  Synopsis:   Very minimal test of property query
//
//  History:    13-May-93       KyleP   Created
//              15 Oct 94       Alanw   Converted to OLE-DB query
//
//--------------------------------------------------------------------------

void RunPropTest( void )
{
    LogProgress( "Property Retrieval Test\n" );

    PROPVARIANT pvProp5;
    pvProp5.vt = VT_I4|VT_VECTOR;
    pvProp5.cal.cElems = clProp5;
    pvProp5.cal.pElems = (LONG *) alProp5;

    PROPVARIANT pvProp5Jumble;
    pvProp5Jumble.vt = VT_I4|VT_VECTOR;
    pvProp5Jumble.cal.cElems = clProp5Jumble;
    pvProp5Jumble.cal.pElems = (LONG *) alProp5Jumble;

    PROPVARIANT pvProp5Like;
    pvProp5Like.vt = VT_I4|VT_VECTOR;
    pvProp5Like.cal.cElems = clProp5Like;
    pvProp5Like.cal.pElems = (LONG *) alProp5Like;

    PROPVARIANT pvProp5None;
    pvProp5None.vt = VT_I4|VT_VECTOR;
    pvProp5None.cal.cElems = clProp5None;
    pvProp5None.cal.pElems = (LONG *) alProp5None;

    PROPVARIANT pvProp5Less;
    pvProp5Less.vt = VT_I4|VT_VECTOR;
    pvProp5Less.cal.cElems = clProp5Less;
    pvProp5Less.cal.pElems = (LONG *) alProp5Less;

    PROPVARIANT pvProp5AllLess;
    pvProp5AllLess.vt = VT_I4|VT_VECTOR;
    pvProp5AllLess.cal.cElems = clProp5AllLess;
    pvProp5AllLess.cal.pElems = (LONG *) alProp5AllLess;

    PROPVARIANT pvProp5More;
    pvProp5More.vt = VT_I4|VT_VECTOR;
    pvProp5More.cal.cElems = clProp5More;
    pvProp5More.cal.pElems = (LONG *) alProp5More;

    PROPVARIANT pvProp5AllMore;
    SAFEARRAY saProp5AllMore = { 1,               // Dimension
                          FADF_AUTO,              // Flags: on stack
                          sizeof(LONG),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)alProp5AllMore, // The data
                          { clProp5AllMore, 0 } };// Bounds (element count, low bound)
    pvProp5AllMore.vt = VT_I4|VT_ARRAY;
    pvProp5AllMore.parray = &saProp5AllMore;

    WCHAR *pwszScope = wcsTestPath;

    DWORD dwDepth = QUERY_SHALLOW;
    IUnknown * pIUnknown;
    ICommand * pQuery = 0;
    SCODE scIC = CICreateCommand( &pIUnknown,
                                  0,
                                  IID_IUnknown,
                                  TEST_CATALOG,
                                  TEST_MACHINE );
    if ( FAILED( scIC ) )
        LogFail( "RunPropTest - error 0x%x Unable to create ICommand\n",
                 scIC );

    scIC = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );
    pIUnknown->Release();

    if ( FAILED( scIC ) )
        LogFail( "RunPropTest - error 0x%x Unable to QI ICommand\n",
                 scIC  );

    if ( 0 == pQuery )
        LogFail( "RunPropTest - CICreateCommand succeeded, but returned null pQuery\n" );

    scIC = SetScopeProperties( pQuery,
                               1,
                               &pwszScope,
                               &dwDepth );

    if ( FAILED( scIC ) )
        LogFail( "RunPropTest - error 0x%x Unable to set scope '%ws'\n",
                 scIC, pwszScope );

    CheckPropertiesOnCommand( pQuery );

    unsigned numTest = 1;

    // singleton DBOP_equal singleton - Coersion test
    {
        LogProgress( " Property coercion to String test 0\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( PROP1_VAL );
        RunPropQueryAndCoerce( pQuery, PropRst, 1, numTest++ );
    }

    // singleton DBOP_equal singleton
    {
        LogProgress( " Property Retrieval test 0\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( PROP1_VAL );
        RunPropQuery( pQuery, PropRst, 1, numTest++ );
    }

    // vector DBOP_equal vector
    {
        LogProgress( " Property Retrieval test 1\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5)) );
        RunPropQueryAndCoerce( pQuery, PropRst, 2, numTest );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // vector DBOP_equal_all vector (FAIL getting any hits back)
    {
        LogProgress( " Property Retrieval test 2\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // singleton DBOP_equal_any singleton
    {
        LogProgress( " Property Retrieval test 3\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( PROP1_VAL );
        RunPropQuery( pQuery, PropRst, 1, numTest++ );
    }

    // singleton DBOP_equal vector (FAIL getting any hits back)
    {
        LogProgress( " Property Retrieval test 4\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( SecondRelevantWord );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // singleton DBOP_equal_any vector (FAIL -- singleton not in vector)
    {
        LogProgress( " Property Retrieval test 5\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( (LONG) 666 );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // singleton DBOP_equal_any vector
    {
        LogProgress( " Property Retrieval test 6\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( SecondRelevantWord );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // reordered vector DBOP_equal_any vector
    {
        LogProgress( " Property Retrieval test 7\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Jumble)) );
        RunPropQuery( pQuery, PropRst, 2 , numTest++ );
    }

    // vector with one element match DBOP_equal_any vector
    {
        LogProgress( " Property Retrieval test 8\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Like)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // vector with 0 element overlap DBOP_equal_any vector (FAIL getting any hits back)
    {
        LogProgress( " Property Retrieval test 9\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5None)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // reordered vector DBOP_equal_any vector
    {
        LogProgress( " Property Retrieval test 10\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Jumble)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // vector with one element match DBOP_equal_all vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 11\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Like)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_less vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 12\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Less)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_greater vector
    {
        LogProgress( " Property Retrieval test 13\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Less)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // more vector DBOP_greater_equal vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 14\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_equal );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5More)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // more vector DBOP_less_equal vector
    {
        LogProgress( " Property Retrieval test 15\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_equal );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5More)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // less vector DBOP_less_all vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 16\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_greater_all vector
    {
        LogProgress( " Property Retrieval test 17\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // more vector DBOP_greater_equal_all vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 18\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_equal_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // more vector DBOP_less_equal_all vector
    {
        LogProgress( " Property Retrieval test 19\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_equal_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // less vector DBOP_less_any vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 20\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_greater_any vector
    {
        LogProgress( " Property Retrieval test 21\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // more vector DBOP_greater_equal_any vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 22\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // more vector DBOP_less_equal_any vector
    {
        LogProgress( " Property Retrieval test 23\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // singleton wstr DBOP_equal_any string vector
    {
        LogProgress( " Property Retrieval test 24\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psKeywords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( L"is" );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // bogus singleton wstr DBOP_equal_any string vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 25\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psKeywords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( L"666" );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // bogus singleton DBOP_equal_any singleton
    {
        LogProgress( " Property Retrieval test 26\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( PROP1_VAL + 100 );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // singleton DBOP_equal singleton (empty string)
    {
        LogProgress( " Property Retrieval test 27\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty10 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( PROP10_VAL );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // singleton DBOP_equal singleton (BSTR string)
    {
        LogProgress( " Property Retrieval test 28\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty11 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( varProp11 );
        RunPropQuery( pQuery, PropRst, 1, numTest++ );
    }

    // less vector DBOP_less_all large vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 29\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psManyRW );
        PropRst.SetRelation( DBOP_less_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_greater_all large vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 30\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psManyRW );
        PropRst.SetRelation( DBOP_greater_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // more vector DBOP_less_all large vector
    {
        LogProgress( " Property Retrieval test 31\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psManyRW );
        PropRst.SetRelation( DBOP_less_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // singleton DBOP_less_equal_all large vector
    {
        LogProgress( " Property Retrieval test 32\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psManyRW );
        PropRst.SetRelation( DBOP_less_equal_all );
        PropRst.SetValue( (LONG) (clProp8-1) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    pQuery->Release();

} //RunPropTest

struct SSafeArrayTestColsTight
{
    SAFEARRAY * a_I4;
    SAFEARRAY * a_BSTR;
    SAFEARRAY * a_VARIANT;
    SAFEARRAY * a_R8;
    SAFEARRAY * a_DATE;
    SAFEARRAY * a_BOOL;
    SAFEARRAY * a_DECIMAL;
    SAFEARRAY * a_I1;
    SAFEARRAY * a_R4;
    SAFEARRAY * a_CY;
    SAFEARRAY * a_UINT;
    SAFEARRAY * a_INT;
    SAFEARRAY * a_ERROR;

    DBLENGTH    I4_cb;
    DBLENGTH    BSTR_cb;
    DBLENGTH    VARIANT_cb;
    DBLENGTH    R8_cb;
    DBLENGTH    DATE_cb;
    DBLENGTH    BOOL_cb;
    DBLENGTH    DECIMAL_cb;
    DBLENGTH    I1_cb;
    DBLENGTH    R4_cb;
    DBLENGTH    CY_cb;
    DBLENGTH    UINT_cb;
    DBLENGTH    INT_cb;
    DBLENGTH    ERROR_cb;

    ULONG    I4_status;
    ULONG    BSTR_status;
    ULONG    VARIANT_status;
    ULONG    R8_status;
    ULONG    DATE_status;
    ULONG    BOOL_status;
    ULONG    DECIMAL_status;
    ULONG    I1_status;
    ULONG    R4_status;
    ULONG    CY_status;
    ULONG    UINT_status;
    ULONG    INT_status;
    ULONG    ERROR_status;
};

static DBBINDING aSafeArrayTestColsTight[] =
{
  { 0,
    offsetof(SSafeArrayTestColsTight,a_I4),
    offsetof(SSafeArrayTestColsTight,I4_cb),
    offsetof(SSafeArrayTestColsTight,I4_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_I4,
    0, 0 },
  { 1,
    offsetof(SSafeArrayTestColsTight,a_BSTR),
    offsetof(SSafeArrayTestColsTight,BSTR_cb),
    offsetof(SSafeArrayTestColsTight,BSTR_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_BSTR,
    0, 0 },
  { 2,
    offsetof(SSafeArrayTestColsTight,a_VARIANT),
    offsetof(SSafeArrayTestColsTight,VARIANT_cb),
    offsetof(SSafeArrayTestColsTight,VARIANT_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_VARIANT,
    0, 0 },
  { 3,
    offsetof(SSafeArrayTestColsTight,a_R8),
    offsetof(SSafeArrayTestColsTight,R8_cb),
    offsetof(SSafeArrayTestColsTight,R8_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_R8,
    0, 0 },
  { 4,
    offsetof(SSafeArrayTestColsTight,a_DATE),
    offsetof(SSafeArrayTestColsTight,DATE_cb),
    offsetof(SSafeArrayTestColsTight,DATE_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_DATE,
    0, 0 },
  { 5,
    offsetof(SSafeArrayTestColsTight,a_BOOL),
    offsetof(SSafeArrayTestColsTight,BOOL_cb),
    offsetof(SSafeArrayTestColsTight,BOOL_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_BOOL,
    0, 0 },
  { 6,
    offsetof(SSafeArrayTestColsTight,a_DECIMAL),
    offsetof(SSafeArrayTestColsTight,DECIMAL_cb),
    offsetof(SSafeArrayTestColsTight,DECIMAL_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_DECIMAL,
    0, 0 },
  { 7,
    offsetof(SSafeArrayTestColsTight,a_I1),
    offsetof(SSafeArrayTestColsTight,I1_cb),
    offsetof(SSafeArrayTestColsTight,I1_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_I1,
    0, 0 },
  { 8,
    offsetof(SSafeArrayTestColsTight,a_R4),
    offsetof(SSafeArrayTestColsTight,R4_cb),
    offsetof(SSafeArrayTestColsTight,R4_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_R4,
    0, 0 },
  { 9,
    offsetof(SSafeArrayTestColsTight,a_CY),
    offsetof(SSafeArrayTestColsTight,CY_cb),
    offsetof(SSafeArrayTestColsTight,CY_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_CY,
    0, 0 },
  { 10,
    offsetof(SSafeArrayTestColsTight,a_UINT),
    offsetof(SSafeArrayTestColsTight,UINT_cb),
    offsetof(SSafeArrayTestColsTight,UINT_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|VT_UINT,
    0, 0 },
  { 11,
    offsetof(SSafeArrayTestColsTight,a_INT),
    offsetof(SSafeArrayTestColsTight,INT_cb),
    offsetof(SSafeArrayTestColsTight,INT_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|VT_INT,
    0, 0 },
  { 12,
    offsetof(SSafeArrayTestColsTight,a_ERROR),
    offsetof(SSafeArrayTestColsTight,ERROR_cb),
    offsetof(SSafeArrayTestColsTight,ERROR_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_ERROR,
    0, 0 },
};

const ULONG cSafeArrayTestColsTight = sizeof aSafeArrayTestColsTight /
                                 sizeof aSafeArrayTestColsTight[0];

void RunSafeArrayTightBindings(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    //
    // Get 13 properties back
    //

    CDbColumns cols(cSafeArrayTestColsTight);
    cols.Add( colSA_I4, 0 );
    cols.Add( colSA_BSTR, 1 );
    cols.Add( colSA_VARIANT, 2 );
    cols.Add( colSA_R8, 3 );
    cols.Add( colSA_DATE, 4 );
    cols.Add( colSA_BOOL, 5 );
    cols.Add( colSA_DECIMAL, 6 );
    cols.Add( colSA_I1, 7 );
    cols.Add( colSA_R4, 8 );
    cols.Add( colSA_CY, 9 );
    cols.Add( colSA_UINT, 10 );
    cols.Add( colSA_INT, 11 );
    cols.Add( colSA_ERROR, 12 );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss( 1 );
    ss.Add( colSA_VARIANT, 0 );

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss );

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "IRowset->GetRowsAt G returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt H returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt I returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cSafeArrayTestColsTight];
    aDbCols[0] =  colSA_I4;
    aDbCols[1] =  colSA_BSTR;
    aDbCols[2] =  colSA_VARIANT;
    aDbCols[3] =  colSA_R8;
    aDbCols[4] =  colSA_DATE;
    aDbCols[5] =  colSA_BOOL;
    aDbCols[6] =  colSA_DECIMAL;
    aDbCols[7] =  colSA_I1;
    aDbCols[8] =  colSA_R4;
    aDbCols[9] =  colSA_CY;
    aDbCols[10] = colSA_UINT;
    aDbCols[11] = colSA_INT;
    aDbCols[12] = colSA_ERROR;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns( pAccessor,
                                      cSafeArrayTestColsTight,
                                      aSafeArrayTestColsTight,
                                      aDbCols,
                                      TRUE );

    //
    // Fetch the data
    //

    SSafeArrayTestColsTight saData;

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, &saData );

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        PROPVARIANT var;

        var.vt = VT_ARRAY | VT_I4;
        var.parray = saData.a_I4;
        CheckPropertyValue( var, vaI4 );

        var.vt = VT_ARRAY | VT_BSTR;
        var.parray = saData.a_BSTR;
        CheckPropertyValue( var, vaBSTR );

        var.vt = VT_ARRAY | VT_VARIANT;
        var.parray = saData.a_VARIANT;
        CheckPropertyValue( var, vaVARIANT );

        var.vt = VT_ARRAY | VT_R8;
        var.parray = saData.a_R8;
        CheckPropertyValue( var, vaR8 );

        var.vt = VT_ARRAY | VT_DATE;
        var.parray = saData.a_DATE;
        CheckPropertyValue( var, vaDATE );

        var.vt = VT_ARRAY | VT_BOOL;
        var.parray = saData.a_BOOL;
        CheckPropertyValue( var, vaBOOL );

        var.vt = VT_ARRAY | VT_DECIMAL;
        var.parray = saData.a_DECIMAL;
        CheckPropertyValue( var, vaDECIMAL );

        var.vt = VT_ARRAY | VT_I1;
        var.parray = saData.a_I1;
        CheckPropertyValue( var, vaI1 );

        var.vt = VT_ARRAY | VT_R4;
        var.parray = saData.a_R4;
        CheckPropertyValue( var, vaR4 );

        var.vt = VT_ARRAY | VT_CY;
        var.parray = saData.a_CY;
        CheckPropertyValue( var, vaCY );

        var.vt = VT_ARRAY | VT_UINT;
        var.parray = saData.a_UINT;
        CheckPropertyValue( var, vaUINT );

        var.vt = VT_ARRAY | VT_INT;
        var.parray = saData.a_INT;
        CheckPropertyValue( var, vaINT );

        var.vt = VT_ARRAY | VT_ERROR;
        var.parray = saData.a_ERROR;
        CheckPropertyValue( var, vaERROR );
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunSafeArrayTightBindings

static DBBINDING aSafeArrayTestByRefCols[] =
{
  { 0, 0 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 1, 1 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 2, 2 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 3, 3 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 4, 4 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 5, 5 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 6, 6 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 7, 7 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 8, 8 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 9, 9 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 10,10* cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 11,11* cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 12,12* cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
};

const ULONG cSafeArrayTestByRefCols = sizeof aSafeArrayTestByRefCols / sizeof aSafeArrayTestByRefCols[0];

void RunSafeArrayByRefBindings(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    //
    // Get 13 properties back
    //

    CDbColumns cols(cSafeArrayTestByRefCols);
    cols.Add( colSA_I4, 0 );
    cols.Add( colSA_BSTR, 1 );
    cols.Add( colSA_VARIANT, 2 );
    cols.Add( colSA_R8, 3 );
    cols.Add( colSA_DATE, 4 );
    cols.Add( colSA_BOOL, 5 );
    cols.Add( colSA_DECIMAL, 6 );
    cols.Add( colSA_I1, 7 );
    cols.Add( colSA_R4, 8 );
    cols.Add( colSA_CY, 9 );
    cols.Add( colSA_UINT, 10 );
    cols.Add( colSA_INT, 11 );
    cols.Add( colSA_ERROR, 12 );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss( 1 );
    ss.Add( colSA_CY, 0 );

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss );

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "IRowset->GetRowsAt G returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt H returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt I returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cSafeArrayTestByRefCols];
    aDbCols[0] =  colSA_I4;
    aDbCols[1] =  colSA_BSTR;
    aDbCols[2] =  colSA_VARIANT;
    aDbCols[3] =  colSA_R8;
    aDbCols[4] =  colSA_DATE;
    aDbCols[5] =  colSA_BOOL;
    aDbCols[6] =  colSA_DECIMAL;
    aDbCols[7] =  colSA_I1;
    aDbCols[8] =  colSA_R4;
    aDbCols[9] =  colSA_CY;
    aDbCols[10] = colSA_UINT;
    aDbCols[11] = colSA_INT;
    aDbCols[12] = colSA_ERROR;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns( pAccessor,
                                      cSafeArrayTestByRefCols,
                                      aSafeArrayTestByRefCols,
                                      aDbCols,
                                      TRUE );

    //
    // Fetch the data
    //

    PROPVARIANT * aVarnt[cSafeArrayTestByRefCols];

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, aVarnt);

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        CheckPropertyValue( *aVarnt[0], vaI4 );
        CheckPropertyValue( *aVarnt[1], vaBSTR );
        CheckPropertyValue( *aVarnt[2], vaVARIANT );
        CheckPropertyValue( *aVarnt[3], vaR8 );
        CheckPropertyValue( *aVarnt[4], vaDATE );
        CheckPropertyValue( *aVarnt[5], vaBOOL );
        CheckPropertyValue( *aVarnt[6], vaDECIMAL );
        CheckPropertyValue( *aVarnt[7], vaI1 );
        CheckPropertyValue( *aVarnt[8], vaR4 );
        CheckPropertyValue( *aVarnt[9], vaCY );
        CheckPropertyValue( *aVarnt[10], vaUINT );
        CheckPropertyValue( *aVarnt[11], vaINT );
        CheckPropertyValue( *aVarnt[12], vaERROR );
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunSafeArrayByRefBindings

static DBBINDING aSafeArrayTestCols[] =
{
  { 0, 0 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 1, 1 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 2, 2 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 3, 3 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 4, 4 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 5, 5 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 6, 6 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 7, 7 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 8, 8 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 9, 9 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 10,10* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 11,11* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 12,12* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
};

const ULONG cSafeArrayTestCols = sizeof aSafeArrayTestCols / sizeof aSafeArrayTestCols[0];

void RunSafeArrayQuery(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    RunSafeArrayTightBindings( pQuery, PropRst, cExpectedHits, numTest );
    RunSafeArrayByRefBindings( pQuery, PropRst, cExpectedHits, numTest );

    //
    // Get twelve properties back
    //

    CDbColumns cols(cSafeArrayTestCols);
    cols.Add( colSA_I4, 0 );
    cols.Add( colSA_BSTR, 1 );
    cols.Add( colSA_VARIANT, 2 );
    cols.Add( colSA_R8, 3 );
    cols.Add( colSA_DATE, 4 );
    cols.Add( colSA_BOOL, 5 );
    cols.Add( colSA_DECIMAL, 6 );
    cols.Add( colSA_I1, 7 );
    cols.Add( colSA_R4, 8 );
    cols.Add( colSA_CY, 9 );
    cols.Add( colSA_UINT, 10 );
    cols.Add( colSA_INT, 11 );
    cols.Add( colSA_ERROR, 12 );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss( 1 );
    ss.Add( colSA_BSTR, 0 );

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss );

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "IRowset->GetRowsAt G returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt H returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt I returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cSafeArrayTestCols];
    aDbCols[0] =  colSA_I4;
    aDbCols[1] =  colSA_BSTR;
    aDbCols[2] =  colSA_VARIANT;
    aDbCols[3] =  colSA_R8;
    aDbCols[4] =  colSA_DATE;
    aDbCols[5] =  colSA_BOOL;
    aDbCols[6] =  colSA_DECIMAL;
    aDbCols[7] =  colSA_I1;
    aDbCols[8] =  colSA_R4;
    aDbCols[9] =  colSA_CY;
    aDbCols[10] = colSA_UINT;
    aDbCols[11] = colSA_INT;
    aDbCols[12] = colSA_ERROR;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns(pAccessor, cSafeArrayTestCols, aSafeArrayTestCols, aDbCols);

    //
    // Fetch the data
    //

    PROPVARIANT aVarnt[cSafeArrayTestCols];

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, aVarnt);

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        CheckPropertyValue( aVarnt[0], vaI4 );
        CheckPropertyValue( aVarnt[1], vaBSTR );
        CheckPropertyValue( aVarnt[2], vaVARIANT );
        CheckPropertyValue( aVarnt[3], vaR8 );
        CheckPropertyValue( aVarnt[4], vaDATE );
        CheckPropertyValue( aVarnt[5], vaBOOL );
        CheckPropertyValue( aVarnt[6], vaDECIMAL );
        CheckPropertyValue( aVarnt[7], vaI1 );
        CheckPropertyValue( aVarnt[8], vaR4 );
        CheckPropertyValue( aVarnt[9], vaCY );
        CheckPropertyValue( aVarnt[10], vaUINT );
        CheckPropertyValue( aVarnt[11], vaINT );
        CheckPropertyValue( aVarnt[12], vaERROR );
        for ( int i = 0; i < 13; i++ )
            PropVariantClear( & aVarnt[i] );
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunSafeArrayQuery

//+-------------------------------------------------------------------------
//
//  Function:   RunSafeArrayTest, public
//
//  Synopsis:   Very minimal test of safe array property query
//
//  History:    17-Jun-98       dlee   Created
//
//--------------------------------------------------------------------------

void RunSafeArrayTest( void )
{
    LogProgress( "SafeArray Retrieval Test\n" );

    WCHAR *pwszScope = wcsTestPath;
    DWORD dwDepth = QUERY_SHALLOW;
    IUnknown * pIUnknown;
    ICommand * pQuery = 0;
    SCODE scIC = CICreateCommand( &pIUnknown,
                                  0,
                                  IID_IUnknown,
                                  TEST_CATALOG,
                                  TEST_MACHINE );
    if ( FAILED( scIC ) )
        LogFail( "RunSafeArrayTest - error 0x%x Unable to create ICommand\n",
                 scIC );

    scIC = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );
    pIUnknown->Release();

    if ( FAILED( scIC ) )
        LogFail( "RunSafeArrayTest - error 0x%x Unable to QI ICommand\n",
                 scIC  );

    if ( 0 == pQuery )
        LogFail( "RunSafeArrayTest - CICreateCommand succeeded, but returned null pQuery\n" );

    scIC = SetScopeProperties( pQuery,
                               1,
                               &pwszScope,
                               &dwDepth );

    if ( FAILED( scIC ) )
        LogFail( "RunSafeArrayTest - error 0x%x Unable to set scope '%ws'\n",
                 scIC, pwszScope );

    CheckPropertiesOnCommand( pQuery );

    unsigned numTest = 1;

    {
        LogProgress( " SafeArray test 1\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_I4 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaI4 );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 2\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_BSTR );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaBSTR );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 3\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_VARIANT );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaVARIANT );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 4\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_R8 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaR8 );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 5\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_DATE );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaDATE );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 6\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_BOOL );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaBOOL );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 7\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_DECIMAL );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaDECIMAL );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 8\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_I1 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaI1 );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 9\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_R4 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaR4 );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 10\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_CY );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaCY );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 11\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_UINT );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaUINT );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 12\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_INT );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaINT );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 13\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_ERROR );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaERROR );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    pQuery->Release();
} //RunSafeArrayTest

//+-------------------------------------------------------------------------
//
//  Function:   CheckPropertyValue, public
//
//  Synopsis:   Check that a returned property value is as expected
//
//  Arguments:  [varntPropRet] -- Returned property value
//              [varntPropExp] -- Expected property value
//
//  Returns:    nothing - calls Fail() if error
//
//  History:    20 Oct 93       Alanw     Created
//
//--------------------------------------------------------------------------

void CheckPropertyValue(
    PROPVARIANT const & varntPropRet,
    PROPVARIANT const & varntPropExp
) {
    if ( varntPropRet.vt != varntPropExp.vt )
    {
        LogError( "Invalid return data type for property!\n" );
        LogError( "   Got %x expected %x\n",
                varntPropRet.vt, varntPropExp.vt );
        cFailures++;
        //Fail();
    }
    else if (varntPropExp.vt & VT_ARRAY)
    {
        SAFEARRAY * pSaRet = varntPropRet.parray;
        SAFEARRAY * pSaExp = varntPropExp.parray;

        if (pSaRet->fFeatures != pSaExp->fFeatures ||
         //   pSaRet->cLocks    != pSaExp->cLocks    ||
            pSaRet->cDims     != pSaExp->cDims     ||
            pSaRet->cbElements!= pSaExp->cbElements)
        {
            LogError( "Mismatched safearray param!\n" );
            LogError( "   Got %x expected %x\n", pSaRet, pSaExp );
            cFailures++;
            //Fail();
        }
        else
        {
            BOOL fValuesEqual = TRUE;
            unsigned cDataElements = 1;

            //
            // get total data memory, and number of data elements in it.
            //
            for ( unsigned i = 0; i < pSaExp->cDims; i++ )
            {
                if ( pSaExp->rgsabound[i].cElements != pSaRet->rgsabound[i].cElements ||
                     pSaExp->rgsabound[i].lLbound != pSaRet->rgsabound[i].lLbound )
                {
                    LogError( "Mismatched safearray dimension %d!\n", i );
                    LogError( "   Got %x expected %x\n", pSaRet, pSaExp );
                    fValuesEqual = FALSE;
                    //Fail();
                }

                cDataElements *= pSaExp->rgsabound[i].cElements;
            }

            if (fValuesEqual)
            {
                ULONG cb = cDataElements * pSaExp->cbElements;
                if ( varntPropExp.vt == (VT_ARRAY|VT_VARIANT ))
                {
                    // Not needed as the engine doesn't support it yet.

                    LogError( "can't validate arrays of variant\n" );
                }
                else if (varntPropExp.vt != (VT_ARRAY|VT_BSTR))
                {
                    fValuesEqual = memcmp( pSaExp->pvData, pSaRet->pvData, cb ) == 0;
                    if (! fValuesEqual)
                    {
                        if ( 0 == ( cb % sizeof ULONGLONG ) )
                        {
                            ULONG c = cb / sizeof ULONGLONG;
                            unsigned __int64 *pE = (unsigned __int64 *) pSaExp->pvData;
                            unsigned __int64 *pR = (unsigned __int64 *) pSaRet->pvData;
                            for ( ULONG i = 0; i < c; i++ )
                            {
                                printf( "%d: e %#I64x, r %#I64x\n",
                                        i, pE[i], pR[i] );
                            }
                        }
                        printf( "varntPropExp: %#x\n", varntPropExp.vt );
                        printf( "varntPropRet: %#x\n", varntPropRet.vt );
                        LogError("Incorrect value for safearray property.\n");
                               // "   Got %d, expected %d\n", i,
                               // varntPropRet.cal.pElems[i],
                               // varntPropExp.cal.pElems[i]);
                    }
                }
                else
                {
                    BSTR * rgbstrExp = (BSTR *)pSaExp->pvData;
                    BSTR * rgbstrRet = (BSTR *)pSaRet->pvData;
                    for (unsigned i=0; i<cDataElements; i++)
                    {
                        fValuesEqual = (BSTRLEN(rgbstrRet[i]) ==
                                        BSTRLEN(rgbstrExp[i])) &&
                                       (memcmp(rgbstrRet[i],
                                               rgbstrExp[i],
                                          BSTRLEN(rgbstrExp[i])) == 0);
                        if (! fValuesEqual)
                        {
                            LogError("Incorrect value for BSTR array property [%d].\n"
                                    "   Got <%ws>, expected <%ws>\n", i,
                                    rgbstrRet[i],
                                    rgbstrExp[i]);
                            break;
                        }
                    }
                }
            }

            if (! fValuesEqual)
            {
                cFailures++;
                //Fail();
            }
        }
    }
    else if (varntPropExp.vt & VT_VECTOR)
    {
        if (varntPropExp.cal.cElems != varntPropRet.cal.cElems)
        {
            LogError( "Incorrect value count for property.\n"
                    "   Got count %d, expected count %d\n",
                    varntPropRet.cal.cElems, varntPropExp.cal.cElems);
            cFailures++;
            //Fail();
        }

        BOOL fValuesEqual = FALSE;

        for (unsigned i=0; i<varntPropRet.cal.cElems; i++) {

            switch (varntPropExp.vt)
            {
            case VT_VECTOR|VT_I4:
                fValuesEqual = varntPropRet.cal.pElems[i] ==
                                varntPropExp.cal.pElems[i];
                if (! fValuesEqual)
                    LogError("Incorrect value for vector property [%d].\n"
                            "   Got %d, expected %d\n", i,
                            varntPropRet.cal.pElems[i],
                            varntPropExp.cal.pElems[i]);
                break;

            case VT_VECTOR|VT_LPWSTR:
                fValuesEqual = wcscmp(varntPropRet.calpwstr.pElems[i],
                                      varntPropExp.calpwstr.pElems[i]) == 0;
                if (! fValuesEqual)
                    LogError("Incorrect value for vector property [%d].\n"
                            "   Got <%ws>, expected <%ws>\n", i,
                            varntPropRet.calpwstr.pElems[i],
                            varntPropExp.calpwstr.pElems[i]);
                break;

            case VT_VECTOR|VT_BSTR:
                fValuesEqual = (BSTRLEN(varntPropRet.cabstr.pElems[i]) ==
                                BSTRLEN(varntPropExp.cabstr.pElems[i])) &&
                               (memcmp(varntPropRet.cabstr.pElems[i],
                                       varntPropExp.cabstr.pElems[i],
                                  BSTRLEN(varntPropExp.cabstr.pElems[i])) == 0);
                if (! fValuesEqual)
                    LogError("Incorrect value for vector property [%d].\n"
                            "   Got <%ws>, expected <%ws>\n", i,
                            varntPropRet.cabstr.pElems[i],
                            varntPropExp.cabstr.pElems[i]);
                break;

            case VT_VECTOR|VT_CF:
            {
                CLIPDATA & cdR = varntPropRet.caclipdata.pElems[i];
                CLIPDATA & cdE = varntPropExp.caclipdata.pElems[i];
                fValuesEqual = ( ( cdR.cbSize == cdE.cbSize ) &&
                                 ( cdR.ulClipFmt == cdE.ulClipFmt ) &&
                                 ( 0 != cdR.pClipData ) &&
                                 ( 0 != cdE.pClipData ) &&
                                 ( 0 == memcmp( cdR.pClipData,
                                                cdE.pClipData,
                                                CBPCLIPDATA( cdR ) ) ) );
                if ( !fValuesEqual )
                    LogError( "Incorrect value for VT_VECTOR|VT_CF property\n" );
                break;
            }

            default:
                LogError("Unexpected property variant type %x\n", varntPropExp.vt);
            }
            if (! fValuesEqual)
            {
                cFailures++;
                //Fail();
            }
        }
    }
    else
    {
        BOOL fValuesEqual = FALSE;

        switch (varntPropExp.vt)
        {
        case VT_I4:
            fValuesEqual = varntPropRet.iVal == varntPropExp.iVal;
            if (! fValuesEqual)
                LogError("Incorrect value for property.\n"
                         "   Got %d, expected %d\n",
                         varntPropRet.iVal, varntPropExp.iVal);
            break;

        case VT_LPWSTR:
        case DBTYPE_WSTR | DBTYPE_BYREF:
            fValuesEqual = wcscmp(varntPropRet.pwszVal, varntPropExp.pwszVal)
                                == 0;
            if (! fValuesEqual)
                LogError("Incorrect value for property.\n"
                         "   Got <%ws>, expected <%ws>\n",
                         varntPropRet.pwszVal, varntPropExp.pwszVal);
            break;

        case VT_BSTR:
            fValuesEqual =
                ( SysStringLen( varntPropRet.bstrVal ) ==
                  SysStringLen( varntPropExp.bstrVal ) ) &&
                memcmp( varntPropRet.bstrVal, varntPropExp.bstrVal,
                        SysStringLen( varntPropExp.bstrVal ) ) == 0;

            if ( SysStringLen( varntPropRet.bstrVal ) !=
                 SysStringLen( varntPropExp.bstrVal ) )
                LogError("Incorrect BSTR length for property.\n"
                         "   Got %d, expected %d\n",
                         SysStringLen( varntPropRet.bstrVal ),
                         SysStringLen( varntPropExp.bstrVal ) );
            else if (! fValuesEqual)
                LogError("Incorrect value for property.\n"
                         "   Got <%ws>, expected <%ws>\n",
                         varntPropRet.pwszVal, varntPropExp.pwszVal);
            break;

        case VT_CLSID:
            fValuesEqual = *varntPropRet.puuid == *varntPropExp.puuid;

            if (! fValuesEqual)
                LogError("Incorrect value for guid property.\n");
            break;


        case VT_BLOB:
            fValuesEqual =
                (varntPropRet.blob.cbSize == varntPropExp.blob.cbSize) &&
                memcmp(varntPropRet.blob.pBlobData, varntPropExp.blob.pBlobData,
                        varntPropExp.blob.cbSize)
                                == 0;
            if (! fValuesEqual)
                LogError("Incorrect value for blob property.\n");
            break;

        case VT_CF:
        {
            CLIPDATA & cdR = *varntPropRet.pclipdata;
            CLIPDATA & cdE = *varntPropExp.pclipdata;
            fValuesEqual = ( ( cdR.cbSize == cdE.cbSize ) &&
                             ( cdR.ulClipFmt == cdE.ulClipFmt ) &&
                             ( 0 != cdR.pClipData ) &&
                             ( 0 != cdE.pClipData ) &&
                             ( 0 == memcmp( cdR.pClipData,
                                            cdE.pClipData,
                                            CBPCLIPDATA( cdR ) ) ) );
            if ( !fValuesEqual )
                LogError( "Incorrect value for VT_CF property\n" );
            break;
        }

        case VT_EMPTY:
            // nothing to check
            fValuesEqual = TRUE;
            break;

        default:
            LogError("Unexpected property variant type %d\n", varntPropExp.vt);
        }
        if (! fValuesEqual)
        {
            cFailures++;
            //Fail();
        }
    }

    return;
} //CheckPropertyValue


#ifdef DO_CONTENT_TESTS

//+-------------------------------------------------------------------------
//
//  Function:   DoContentQuery, public
//
//  Synopsis:   Execute a retricted content query and check results
//
//  Arguments:  [pQuery]        -- ICommand * for the query
//              [CiRst]         -- content restirction
//              [cExpectedHits] -- expected number of hits
//
//  Returns:    BOOL - FALSE if first content query, and less than the
//                     expected number of hits was found.  Probably indicates
//                     that the content index was not up-to-date.
//
//  History:    01 Aug 1995    AlanW    Created
//
//--------------------------------------------------------------------------

const unsigned MAX_CI_RETRIES = 5;
const unsigned CI_SLEEP_TICKS = 15 * 1000;

BOOL DoContentQuery(
    ICommand * pQuery,
    CDbRestriction & CiRst,
    unsigned cExpectedHits )
{
    static fFirstTime = TRUE;

    //
    // Get three properties back
    //

    CDbColumns cols(3);
    cols.Add( psName, 0 );
    cols.Add( psPath, 1 );
    cols.Add( psRank, 2 );

    //
    // Do it!
    //

    unsigned cRetries = 0;
    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;
    SCODE sc;
    IRowset * pRowset = 0;

    do {

        CDbCmdTreeNode * pCmdTree = FormQueryTree(&CiRst, cols, 0);

        pRowset = InstantiateRowset( pQuery,
                                     QUERY_SHALLOW,     // Depth
                                     wcsTestPath,       // Scope
                                     pCmdTree,          // DBCOMMANDTREE
                                     IID_IRowset);      // IID of i/f to return

        //
        // Verify columns
        //
        CheckColumns( pRowset, cols, TRUE );

        if ( !WaitForCompletion( pRowset, TRUE ) )
        {
            LogError( "Content query unsuccessful.\n" );
            pRowset->Release();
            Fail();
        }

        //
        // Get data
        //

        sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetNextRows returned 0x%x\n", sc );
            pRowset->Release();
            Fail();
        }

        //
        // Check to see if the CI is up-to-date
        //

        IRowsetQueryStatus * pRowsetQueryStatus = 0;

        SCODE scTemp = pRowset->QueryInterface(IID_IRowsetQueryStatus,
                                               (void **) &pRowsetQueryStatus);

        if ( FAILED( scTemp ) &&  scTemp != E_NOINTERFACE )
        {
            LogError( "IRowset::QI IRowsetQueryStatus failed, 0x%x\n", sc );
            cFailures++;
        }

        DWORD dwStatus = 0;
        if (pRowsetQueryStatus != 0)
        {
            scTemp = pRowsetQueryStatus->GetStatus( &dwStatus );
            pRowsetQueryStatus->Release();

            if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_CONTENT_OUT_OF_DATE )
            {
                FreeHrowsArray( pRowset, cRowsReturned, &pgrhRows );
                pRowset->Release();
                cRetries++;
                if (cRetries < MAX_CI_RETRIES)
                {
                    Sleep( CI_SLEEP_TICKS );
                    continue;
                }
            }
            break;
        }
        else if (fFirstTime && cRowsReturned < cExpectedHits)
        {
            FreeHrowsArray( pRowset, cRowsReturned, &pgrhRows );
            pRowset->Release();
            cRetries++;
            if (cRetries < MAX_CI_RETRIES)
                Sleep( CI_SLEEP_TICKS );
        }
        else
        {
            break;
        }
    } while ( cRetries < MAX_CI_RETRIES );

    if (cRetries >= MAX_CI_RETRIES)
    {
        LogError( "Content query test skipped due to timeout\n" );
        return FALSE;
    }
    fFirstTime = FALSE;

    if ( 0 == cExpectedHits )
    {
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("DoContentQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return TRUE;

    }

    if (sc != DB_S_ENDOFROWSET && cRowsReturned != 10)
    {
        LogError( "IRowset->GetNextRows returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return TRUE;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 to 5 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetNextRows returned %d rows (expected %d),"
                  " status (%x)\n",
                 cRowsReturned, cExpectedHits, sc );
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return TRUE;
#else
        Fail();
#endif
    }

    FreeHrowsArray( pRowset, cRowsReturned, &pgrhRows );

    //
    // Clean up.
    //

    pRowset->Release();
    return TRUE;
} //DoContentQuery


//+-------------------------------------------------------------------------
//
//  Function:   ContentTest, public
//
//  Synopsis:   Very minimal test of Content query
//
//  History:    13-May-93       KyleP   Created
//              15 Oct 94       Alanw   Converted to OLE-DB query
//
//--------------------------------------------------------------------------

void ContentTest()
{
    LogProgress( "Content Query\n" );

    WCHAR *pwszScope = wcsTestPath;

    DWORD dwDepth = QUERY_SHALLOW;
    ICommand * pQuery = 0;
    SCODE scIC = CICreateCommand( (IUnknown **)&pQuery,
                                  0,
                                  IID_ICommand,
                                  CONTENT_CATALOG,
                                  TEST_MACHINE );
    if ( FAILED( scIC ) )
        LogFail( "RunPropTest - error 0x%x Unable to create ICommand\n", scIC );

    if ( 0 == pQuery )
        LogFail( "RunPropTest - CICreateCommand succeeded, but returned null pQuery\n" );

    scIC = SetScopeProperties( pQuery,
                               1,
                               &pwszScope,
                               &dwDepth );

    // simple content query
    {
        LogProgress( " Content Query test 0\n" );
        CDbContentRestriction CiRst( L"country", psContents);
        if (! DoContentQuery( pQuery, CiRst, 2 ))
        {
            pQuery->Release();
            return;
        }
    }

    // content query on property
    {
        LogProgress( " Content Query test 1\n" );
        CDbContentRestriction CiRst( L"alanw", psAuthor);
        DoContentQuery( pQuery, CiRst, 2 );
    }

    // natural language query
    {
        LogProgress( " Content Query test 2\n" );
        CDbNatLangRestriction CiRst( L"who is oscar wilde", psContents);
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with prefix match
    {
        LogProgress( " Content Query test 3\n" );
        CDbContentRestriction CiRst( L"cont", psContents, GENERATE_METHOD_PREFIX );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with stemming
    {
        LogProgress( " Content Query test 4\n" );
        CDbContentRestriction CiRst( L"temptation", psContents, GENERATE_METHOD_INFLECT );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with more obscure stemming (prefix match)
    {
        LogProgress( " Content Query test 4A\n" );
        CDbContentRestriction CiRst( L"crea", psContents, GENERATE_METHOD_PREFIX );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with more obscure stemming (stemmed)
    {
        LogProgress( " Content Query test 4B\n" );
        CDbContentRestriction CiRst( L"crea", psContents, GENERATE_METHOD_INFLECT );
        DoContentQuery( pQuery, CiRst, 0 );
    }

    // content query with more obscure stemming (prefix match)
    {
        LogProgress( " Content Query test 4C\n" );
        CDbContentRestriction CiRst( L"create", psContents, GENERATE_METHOD_PREFIX );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with more obscure stemming (stemmed)
    {
        LogProgress( " Content Query test 4D\n" );
        CDbContentRestriction CiRst( L"create", psContents, GENERATE_METHOD_INFLECT );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // and content query
    {
        LogProgress( " Content Query test 5\n" );
        CDbBooleanNodeRestriction CiRst( DBOP_and );
        CDbContentRestriction *pRst1 = new
                  CDbContentRestriction( L"country", psContents);
        CDbContentRestriction *pRst2 = new
                  CDbContentRestriction( L"content", psContents);
        CiRst.AppendChild(pRst1);
        CiRst.AppendChild(pRst2);
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // and not content query
    {
        LogProgress( " Content Query test 6\n" );
        CDbBooleanNodeRestriction CiRst( DBOP_and );
        CDbContentRestriction *pRst1 = new
                  CDbContentRestriction( L"country", psContents);
        CDbContentRestriction *pRst2 = new
                  CDbContentRestriction( L"content", psContents);
        CDbNotRestriction *pRst3 = new CDbNotRestriction( pRst2 );
        CiRst.AppendChild(pRst1);
        CiRst.AppendChild(pRst3);
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // proximity content query
    {
        LogProgress( " Content Query test 7\n" );
        CDbProximityNodeRestriction CiRst;
        CDbContentRestriction *pRst1 = new
                  CDbContentRestriction( L"country", psContents);
        CDbContentRestriction *pRst2 = new
                  CDbContentRestriction( L"temptations", psContents);
        CiRst.AppendChild(pRst1);
        CiRst.AppendChild(pRst2);
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // vector or query
    {
        LogProgress( " Content Query test 8\n" );
        CDbVectorRestriction CiRst( VECTOR_RANK_MIN );
        CDbContentRestriction *pRst1 = new
                  CDbContentRestriction( L"country", psContents);
        CDbContentRestriction *pRst2 = new
                  CDbContentRestriction( L"temptations", psContents);
        CDbContentRestriction *pRst3 = new
                  CDbContentRestriction( L"DELETE", psContents);

        pRst1->SetWeight( 500 );
        pRst2->SetWeight( 1000 );
        pRst3->SetWeight( 50 );

        CiRst.AppendChild( pRst1 );
        CiRst.AppendChild( pRst2 );
        CiRst.AppendChild( pRst3 );

        // This might return 3 if the test directory is on FAT
        const unsigned cMatches = 2;
        DoContentQuery( pQuery, CiRst, cMatches );
    }

    pQuery->Release();
} //ContentTest

#endif // DO_CONTENT_TESTS


#if defined( DO_NOTIFICATION )
class CTestRowsetNotify : public IRowsetNotify
{
    public:
        CTestRowsetNotify() :
            _fChecking(FALSE),
            _cRef(1),
            _dwReasonToCheck(0),
            _cNotifies(0) {}

        ~CTestRowsetNotify()
        {
        }

        void StartCheck(DWORD dwReason)
        {
            _fChecking = TRUE;
            _dwReasonToCheck = dwReason;
            _cNotifies = 0;
        }

        void TestCheck( ULONG cNotifies )
        {
            if (_cNotifies != cNotifies )
                LogError ( "CTestRowsetNotify::TestCheck failed, "
                           "reason %d, exp %d  got %d\n",
                            _dwReasonToCheck, cNotifies, _cNotifies );
            _fChecking = FALSE;
        }

        //
        // IUnknown methods.
        //

        STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppiuk)
            {
                *ppiuk = (void **) this; // hold our breath and jump
                AddRef();
                return S_OK;
            }

        STDMETHOD_(ULONG, AddRef) (THIS)
            { return ++_cRef; }

        STDMETHOD_(ULONG, Release) (THIS)
            { return --_cRef; }

    //
    // IRowsetNotify methods.
    //

    STDMETHOD(OnFieldChange) ( IRowset *    pRowset,
                               HROW         hRow,
                               DBORDINAL    cColumns,
                               DBORDINAL    rgColumns[],
                               DBREASON     eReason,
                               DBEVENTPHASE ePhase,
                               BOOL         fCantDeny )
        {
            if ( _fChecking && eReason == _dwReasonToCheck )
            {
                _cNotifies++;
            }
            return S_OK;
        }

    STDMETHOD(OnRowChange) ( IRowset *    pRowset,
                             DBCOUNTITEM  cRows,
                             const HROW   rghRows[],
                             DBREASON     eReason,
                             DBEVENTPHASE ePhase,
                             BOOL         fCantDeny )
        {
            if ( _fChecking && eReason == _dwReasonToCheck )
            {
                _cNotifies++;
            }
            return S_OK;
        }

    STDMETHOD(OnRowsetChange) ( IRowset *    pRowset,
                                DBREASON     eReason,
                                DBEVENTPHASE ePhase,
                                BOOL         fCantDeny )
        {
            if ( _fChecking && eReason == _dwReasonToCheck )
            {
                _cNotifies++;
            }
            return S_OK;
        }

    private:
        ULONG _cRef;
        BOOL  _fChecking;
        DWORD _dwReasonToCheck;
        ULONG _cNotifies;
};


class CTestWatchNotify : public IRowsetWatchNotify
{
    public:
        CTestWatchNotify() :
            _fChecking(FALSE),
            _fRequery(FALSE),
            _fComplete(FALSE),
            _cRowChanges(0),
            _cRef(1) {}

        void DoChecking(BOOL fChecking)
        {
            _fChecking = fChecking;
        }

        ~CTestWatchNotify()
        {
            if (_fChecking)
            {
                if (1 != _cRef) // NOTE: notify objects are static allocated
                {
                    LogFail( "Bad refcount on CTestWatchNotify: %#x, %d.\n",
                             this, _cRef );
                }
            }
        }

        //
        // IUnknown methods.
        //

        STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppiuk)
            {
                *ppiuk = (void **) this; // hold our breath and jump
                AddRef();
                return S_OK;
            }

        STDMETHOD_(ULONG, AddRef) (THIS)
            { /*printf( "addref: %d\n", _cRef+1 );*/ return ++_cRef; }

        STDMETHOD_(ULONG, Release) (THIS)
            { /*printf( "release: %d\n", _cRef-1 );*/ return --_cRef; }

        //void DumpRef() { printf( "ref: %d\n", _cRef ); }

        //
        // IRowsetNotifyWatch method
        //

        STDMETHOD(OnChange) (THIS_ IRowset* pRowset, DBWATCHNOTIFY changeType)
        {
            switch (changeType)
            {
            case DBWATCHNOTIFY_ROWSCHANGED:
                _cRowChanges++;         break;
            case DBWATCHNOTIFY_QUERYDONE:
                _fComplete = TRUE;      break;
            case DBWATCHNOTIFY_QUERYREEXECUTED:
                _fRequery = TRUE;       break;
            default:
                _BadChangeType = changeType;
            }
            return S_OK;
        }

    private:
        ULONG   _cRef;
        BOOL    _fChecking;
        BOOL    _fComplete;
        BOOL    _fRequery;
        ULONG   _cRowChanges;
        DBWATCHNOTIFY _BadChangeType;
};


//+-------------------------------------------------------------------------
//
//  Function:   NotificationTest, public
//
//  Synopsis:   Test basic notification functionality
//
//  Returns:    Nothing
//
//  Notes:      At the point this is called, the notification has been
//              set up.  This function adds/deletes/modifies files and
//              expects to get notifications of these changes.
//
//  History:    14 Oct 94       dlee    created
//
//--------------------------------------------------------------------------

void NotificationTest()
{
    LogProgress( " Notification test\n" );

    //
    // Makes files in the nt\system32 directory that look like "X.zzz"
    //

    WCHAR wcsSysDir[MAX_PATH];
    if( !GetSystemDirectory( wcsSysDir, sizeof(wcsSysDir) / sizeof(WCHAR) ) )
    {
        LogFail( "Unable to determine system directory.\n" );
    }

    wcscat(wcsSysDir,L"\\X.zzz");
    unsigned iNamePos = wcslen(wcsSysDir) - 5;

    DWORD dwStart = GetTickCount();

    //
    // create / touch / delete files for 5 seconds
    //

    while ((GetTickCount() - dwStart) < 3000)
    {
        Sleep(rand() % 300);

        wcsSysDir[iNamePos] = (WCHAR) ('a' + (rand() % 10));

        HANDLE h = CreateFile(wcsSysDir,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ,
                   0,
                   OPEN_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL |
                   (((rand() % 103) < 20) ? FILE_FLAG_DELETE_ON_CLOSE : 0),
                   0);

        if (INVALID_HANDLE_VALUE != h)
        {
            DWORD dw = 0xf0f0f0f0;
            DWORD dwWritten;
            WriteFile(h,&dw,sizeof(DWORD),&dwWritten,0);

            CloseHandle(h);
        }
        else
        {
            LogFail( "Can't create test file in the system32 directory.\n" );
        }
    }

    //
    // sleep some more to pick up all the notifications
    //

    Sleep(1000);

} //NotificationTest
#endif // defined( DO_NOTIFICATION )



//+-------------------------------------------------------------------------
//
//  Function:   CheckColumns, public
//
//  Synopsis:   Verify that the cursor contains all the requested columns
//              Also, check to see if the IColumnsInfo and IColumnsRowset
//              interfaces are supported.  Print out column info. and rowset
//              properties if the very verbose option is chosen.
//
//  Arguments:  [pRowset] - a pointer to an IRowset* to be tested.
//              [rColumns] - a reference to a CDbColumns giving the input
//                      columns
//
//  Returns:    Nothing
//
//  Notes:      This function may be called prior to the rowset population
//              having completed.
//
//  History:    14 Nov 94       Alanw   Created
//
//--------------------------------------------------------------------------


char *DBTYPE_Tag (DBTYPE type)
{
    #define CASE(name) \
            case DBTYPE_ ## name: \
                    return #name

    switch (type)
    {
    CASE (NULL);
    CASE (BOOL);
    CASE (I1);
    CASE (UI1);
    CASE (I2);
    CASE (I4);
    CASE (UI2);
    CASE (UI4);
    CASE (I8);
    CASE (UI8);
    CASE (R4);
    CASE (R8);
    CASE (CY);
    CASE (DATE);
    CASE (VARIANT);
    CASE (GUID);
    CASE (STR);
    CASE (BYTES);
    CASE (WSTR);
    CASE (NUMERIC);

    default:
        return "BAD";
    }

    #undef CASE
}

void PrintColumnFlags (DBCOLUMNFLAGS flags)
{
    #define FLAG(name) \
            if (flags & DBCOLUMNFLAGS_ ## name) \
                    printf (#name " ")

    FLAG (ISBOOKMARK);
    FLAG (MAYDEFER);
//  FLAG (MAYREFERENCE);
    FLAG (WRITE);
    FLAG (WRITEUNKNOWN);
//  FLAG (ISSIGNED);
    FLAG (ISFIXEDLENGTH);
    FLAG (ISNULLABLE);
    FLAG (MAYBENULL);
    FLAG (ISCHAPTER);
    FLAG (ISLONG);
    FLAG (ISROWID);
    FLAG (ISROWVER);
    FLAG (CACHEDEFERRED);

    #undef FLAG
}


DBPROP * LocateProperty (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cPropSets,
    DBPROPSET * pPropSets)
{
    for (unsigned i=0; i<cPropSets; i++, pPropSets++)
    {
        if (pPropSets->guidPropertySet != rPropSet)
            continue;

        for (unsigned j=0; j<pPropSets->cProperties; j++)
        {
            if (pPropSets->rgProperties[j].dwPropertyID == dwPropId)
                return &pPropSets->rgProperties[j];
        }
        return 0;
    }

    return 0;
}

DBPROPINFO UNALIGNED * LocatePropertyInfo (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cPropInfoSets,
    DBPROPINFOSET * pPropInfoSets)
{
    for (unsigned i=0; i<cPropInfoSets; i++, pPropInfoSets++)
    {
        if (pPropInfoSets->guidPropertySet != rPropSet)
            continue;

        for (unsigned j=0; j<pPropInfoSets->cPropertyInfos; j++)
        {
            if (pPropInfoSets->rgPropertyInfos[j].dwPropertyID == dwPropId)
                return &pPropInfoSets->rgPropertyInfos[j];
        }
        return 0;
    }

    return 0;
}

BOOL CheckBooleanProperty (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cProps,
    DBPROPSET * pProps)
{
    DBPROP * pPropDesc = LocateProperty( rPropSet, dwPropId, cProps, pProps );

    if (pPropDesc)
    {
        if ( !( (pPropDesc->vValue.vt == VT_EMPTY &&
                 pPropDesc->dwStatus == DBPROPSTATUS_NOTSUPPORTED)  ||
                (pPropDesc->vValue.vt == VT_BOOL &&
                 (pPropDesc->vValue.boolVal == VARIANT_TRUE ||
                  pPropDesc->vValue.boolVal == VARIANT_FALSE)) ) )
        {
            LogError( "Bad boolean property value %d, %d\n",
                       pPropDesc->vValue.vt, pPropDesc->vValue.lVal );
        }
        return (pPropDesc->vValue.vt == VT_BOOL &&
                pPropDesc->vValue.boolVal == VARIANT_TRUE);
    }
    return FALSE;
}

BOOL CheckNumericProperty (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cProps,
    DBPROPSET * pProps,
    LONG & rlVal)
{
    DBPROP * pPropDesc = LocateProperty( rPropSet, dwPropId, cProps, pProps );

    if (pPropDesc)
    {
        if ( !( (pPropDesc->vValue.vt == VT_EMPTY &&
                 pPropDesc->dwStatus == DBPROPSTATUS_NOTSUPPORTED)  ||
                (pPropDesc->vValue.vt == VT_I4) ) )
        {
            LogError( "Bad numeric property value %d\n", pPropDesc->vValue.vt );
            return FALSE;
        }
        rlVal = pPropDesc->vValue.lVal;
        return (pPropDesc->vValue.vt == VT_I4);
    }
    return FALSE;
}

void CheckSafeArrayProperty (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cProps,
    DBPROPSET * pProps )
{
    DBPROP * pPropDesc = LocateProperty( rPropSet, dwPropId, cProps, pProps );

    if (pPropDesc)
    {
        if ( pPropDesc->vValue.vt == (VT_ARRAY | VT_BSTR ) )
        {
            if ( 1 != SafeArrayGetDim( pPropDesc->vValue.parray ) )
                printf( "Bad array dimension\n" );
            else
            {
                long LBound = 1;
                long UBound = 0;

                SafeArrayGetLBound( pPropDesc->vValue.parray, 1, &LBound );
                SafeArrayGetUBound( pPropDesc->vValue.parray, 1, &UBound );

                for ( long j = LBound; j <= UBound; j++ )
                {
                    WCHAR ** pwcsVal;

                    SCODE sc = SafeArrayPtrOfIndex( pPropDesc->vValue.parray, &j, (void **)&pwcsVal );

                    if ( SUCCEEDED(sc) )
                    {
                        if ( j != LBound )
                            printf( ", " );
                        printf( "%ws", *pwcsVal );
                    }
                }
            }
        }
        else if ( pPropDesc->vValue.vt == VT_BSTR )
        {
            printf( "%ws", pPropDesc->vValue.bstrVal );
        }
        else if ( pPropDesc->vValue.vt == (VT_ARRAY | VT_I4 ) )
        {
            if ( 1 != SafeArrayGetDim( pPropDesc->vValue.parray ) )
                printf( "Bad array dimension\n" );
            else
            {
                long LBound = 1;
                long UBound = 0;

                SafeArrayGetLBound( pPropDesc->vValue.parray, 1, &LBound );
                SafeArrayGetUBound( pPropDesc->vValue.parray, 1, &UBound );

                for ( long j = LBound; j <= UBound; j++ )
                {
                    ULONG ulVal;

                    SCODE sc = SafeArrayGetElement( pPropDesc->vValue.parray, &j, &ulVal );

                    if ( SUCCEEDED(sc) )
                    {
                        if ( j != LBound )
                            printf( ", " );
                        printf( "%u", ulVal );
                    }
                }
            }
        }
        else if ( pPropDesc->vValue.vt == VT_I4 )
        {
            printf( "%u", pPropDesc->vValue.lVal );
        }
        else
            printf( "Unknown VT type %d\n", pPropDesc->vValue.vt );
    }
    else
        printf( "n/a" );
}

//
//  GetBooleanProperty - return boolean property value setting for dbprop
//

BOOL GetBooleanProperty ( IRowset * pRowset, DBPROPID dbprop )
{
    DBPROPSET *pPropInfo = 0;
    ULONG cPropSets = 0;
    DBPROPIDSET PropIdSet;
    DBPROPID PropID = dbprop;

    PropIdSet.rgPropertyIDs = &PropID;
    PropIdSet.cPropertyIDs = 1;
    PropIdSet.guidPropertySet = DBPROPSET_ROWSET;

    IRowsetInfo *pIRowInfo = 0;
    SCODE sc = pRowset->QueryInterface(IID_IRowsetInfo,(void **) &pIRowInfo);

    sc = pIRowInfo->GetProperties( 1, &PropIdSet, &cPropSets, &pPropInfo );
    pIRowInfo->Release();

    BOOL fReturnValue = FALSE;
    if ( FAILED( sc ) || cPropSets != 1 || pPropInfo->cProperties != 1 )
    {
        LogFail( "IRowsetInfo::GetProperties returned sc=0x%lx, cPropSets=%d\n", sc, cPropSets );
    }
    else
    {
        if (pPropInfo->rgProperties->vValue.vt == VT_BOOL &&
            pPropInfo->rgProperties->dwStatus == DBPROPSTATUS_OK)
        {
            fReturnValue = (pPropInfo->rgProperties->vValue.boolVal == VARIANT_TRUE);
        }
        else
        {
            LogFail( "IRowsetInfo::GetProperties returned bad DBPROPSET,"
                      " vt = %d  status = %x\n",
               pPropInfo->rgProperties->vValue.vt, pPropInfo->rgProperties->dwStatus );
        }
        if (pPropInfo)
        {
            if (pPropInfo->rgProperties)
                CoTaskMemFree(pPropInfo->rgProperties);
            CoTaskMemFree(pPropInfo);
        }
    }
    return fReturnValue;
}


void PrintRowsetProps (ULONG cProps, DBPROPSET * pProps)
{
    printf("\nRowset Properties:" );

    unsigned cBoolProps = 0;

    #define BOOLPROP(name)                                               \
            if (CheckBooleanProperty( DBPROPSET_ROWSET, DBPROP_ ## name, cProps, pProps) ) \
            {       if ((cBoolProps % 4) == 0) printf("\n\t");           \
                    cBoolProps++;                                        \
                    printf (#name " ");                                  \
            }

    BOOLPROP (ABORTPRESERVE);
    BOOLPROP (APPENDONLY);
    BOOLPROP (BLOCKINGSTORAGEOBJECTS);
    BOOLPROP (BOOKMARKS);
    BOOLPROP (BOOKMARKSKIPPED);
    BOOLPROP (CACHEDEFERRED);
    BOOLPROP (CANFETCHBACKWARDS);
    BOOLPROP (CANHOLDROWS);
    BOOLPROP (CANSCROLLBACKWARDS);
    BOOLPROP (CHANGEINSERTEDROWS);
#ifdef DBPROP_CHAPTERED
    BOOLPROP (CHAPTERED);
#endif // DBPROP_CHAPTERED
    BOOLPROP (COLUMNRESTRICT);
    BOOLPROP (COMMITPRESERVE);
    BOOLPROP (DEFERRED);
    BOOLPROP (DELAYSTORAGEOBJECTS);
    BOOLPROP (IMMOBILEROWS);
    BOOLPROP (LITERALBOOKMARKS);
    BOOLPROP (LITERALIDENTITY);
#ifdef DBPROP_MULTICHAPTERED
    BOOLPROP (MULTICHAPTERED);
#endif // DBPROP_MULTICHAPTERED
    BOOLPROP (MAYWRITECOLUMN);
    BOOLPROP (ORDEREDBOOKMARKS);
    BOOLPROP (OTHERINSERT);
    BOOLPROP (OTHERUPDATEDELETE);
    BOOLPROP (OWNINSERT);
    BOOLPROP (OWNUPDATEDELETE);
    BOOLPROP (QUICKRESTART);
    BOOLPROP (REENTRANTEVENTS);
    BOOLPROP (REMOVEDELETED);
    BOOLPROP (REPORTMULTIPLECHANGES);
    BOOLPROP (RETURNPENDINGINSERTS);
    BOOLPROP (ROWRESTRICT);
    BOOLPROP (SERVERCURSOR);
    BOOLPROP (STRONGIDENTITY);
    BOOLPROP (TRANSACTEDOBJECT);

    cBoolProps = 0;
    BOOLPROP (IAccessor);
    BOOLPROP (IChapteredRowset);
    BOOLPROP (IColumnsInfo);
    BOOLPROP (IColumnsRowset);
    BOOLPROP (IConnectionPointContainer);
    BOOLPROP (IDBAsynchStatus);
    BOOLPROP (IRowset);
    BOOLPROP (IRowsetChange);
    BOOLPROP (IRowsetIdentity);
    BOOLPROP (IRowsetInfo);
    BOOLPROP (IRowsetLocate);
    BOOLPROP (IRowsetResynch);
    BOOLPROP (IRowsetScroll);
    BOOLPROP (IRowsetUpdate);
    BOOLPROP (ISupportErrorInfo);
    BOOLPROP (IRowsetAsynch);
    BOOLPROP (IRowsetWatchAll);
    BOOLPROP (IRowsetWatchRegion);

// The following are per-column
//    BOOLPROP (ILockBytes);
//    BOOLPROP (ISequentialStream);
//    BOOLPROP (IStorage);
//    BOOLPROP (IStream);

    #undef BOOLPROP

    printf("\n");

    LONG n;

    #define NUMPROP(name)                                                   \
            if (CheckNumericProperty( DBPROPSET_ROWSET, DBPROP_ ## name, cProps, pProps, n) ) \
                    printf ("\t" #name ":\t%d\n", n);                       \
            else                                                            \
                    printf ("\t" #name ":\t--\n");

    NUMPROP( BOOKMARKTYPE );
    NUMPROP( COMMANDTIMEOUT );
    NUMPROP( MAXOPENROWS );
#ifdef DBPROP_MAXOPENROWSPERCHAPTER
    NUMPROP( MAXOPENROWSPERCHAPTER );
#endif // DBPROP_MAXOPENROWSPERCHAPTER
    NUMPROP( MAXPENDINGROWS );
    NUMPROP( MAXROWS );
#ifdef DBPROP_MAXPENDINGCHANGESCHAPTER
    NUMPROP( MAXPENDINGCHANGESPERCHAPTER );
#endif // DBPROP_MAXPENDINGCHANGESCHAPTER
    NUMPROP( MEMORYUSAGE );
    NUMPROP( NOTIFICATIONGRANULARITY );
    NUMPROP( NOTIFICATIONPHASES );
    NUMPROP( NOTIFYROWSETRELEASE );
    NUMPROP( NOTIFYROWSETFETCHPOSITIONCHANGE );
    // NUMPROP( NOTIFYCOLUMNSET, et al. );
    NUMPROP( ROWSET_ASYNCH );
    NUMPROP( ROWTHREADMODEL );
    NUMPROP( UPDATABILITY );

    #undef NUMPROP

    #define BOOLPROP(name)                                               \
            if (CheckBooleanProperty( guidQueryExt, DBPROP_ ## name, cProps, pProps) ) \
            {       if ((cBoolProps % 4) == 0) printf("\n\t");           \
                    cBoolProps++;                                        \
                    printf (#name " ");                                  \
            }

    cBoolProps = 0;
    BOOLPROP (USECONTENTINDEX);
    BOOLPROP (DEFERNONINDEXEDTRIMMING);
    BOOLPROP (USEEXTENDEDDBTYPES);

    #undef BOOLPROP

    printf("\n\n");

    #define SAPROP(name)                                               \
            printf ( "\t" #name ": ");                                       \
            CheckSafeArrayProperty( guidFsCiFrmwrkExt, DBPROP_ ## name, cProps, pProps); \
            printf ( "\n" );

    SAPROP (CI_INCLUDE_SCOPES);
    SAPROP (CI_DEPTHS);
    SAPROP (CI_CATALOG_NAME);

    #undef SAPROP
    #define SAPROP(name)                                               \
            printf ( "\t" #name ": ");                                       \
            CheckSafeArrayProperty( guidCiFrmwrkExt, DBPROP_ ## name, cProps, pProps); \
            printf ( "\n" );

    SAPROP (MACHINE);

    #undef SAPROP

    printf ( "\n" );

    #define SAPROP(name)                                               \
            printf ( "\t" #name ": ");                                       \
            CheckSafeArrayProperty( guidMsidxsExt, MSIDXSPROP_ ## name, cProps, pProps); \
            printf ( "\n" );

    SAPROP (ROWSETQUERYSTATUS);
    SAPROP (COMMAND_LOCALE_STRING);
    SAPROP (QUERY_RESTRICTION);


    #undef SAPROP
}

//
//  CheckRowsetProperties - print rowset properties.  If IServiceProperties is
//                        supported, check that the set of properties returned
//                        by GetPropertyInfo is the same.
//
void CheckRowsetProperties( ULONG cProps,
                            DBPROPSET * pProps,
                            IUnknown * pUnk,
                            BOOL fCheckAllProperties = TRUE )
{
    IServiceProperties *pSvcProp = 0;
    SCODE sc = pUnk->QueryInterface(IID_IServiceProperties,(void **) &pSvcProp);

    DBPROPSTATUS ExpStatus = fCheckAllProperties ? DBPROPSTATUS_OK :
                                                   DBPROPSTATUS_CONFLICTING;

    if (SUCCEEDED( sc ))
    {
        DBPROPINFOSET * pPropInfoSet = 0;
        ULONG cPropInfoSet = 0;
        WCHAR * pwszDescriptions = 0;

        DBPROPIDSET PropID;
        PropID.cPropertyIDs = 0;
        PropID.rgPropertyIDs = 0;
        PropID.guidPropertySet = DBPROPSET_ROWSETALL;

        sc = pSvcProp->GetPropertyInfo( 1, &PropID,
                                        &cPropInfoSet, &pPropInfoSet,
                                        &pwszDescriptions );
        pSvcProp->Release();

        if ( FAILED( sc ) )
        {
            LogFail( "IServiceProperties::GetPropertyInfo returned 0x%lx\n",
                      sc );
        }

        //
        // Check that all properties returned by GetProperties are in the
        // propinfo structures.
        //
        for (unsigned iPropSet=0; iPropSet < cProps; iPropSet++)
        {
            DBPROP *pDbProp = pProps[iPropSet].rgProperties;

            for (unsigned iProp=0; iProp<pProps[iPropSet].cProperties; iProp++)
            {
                DBPROPINFO UNALIGNED * pPropInfo = LocatePropertyInfo(
                                             pProps[iPropSet].guidPropertySet,
                                             pDbProp[iProp].dwPropertyID,
                                             cPropInfoSet, pPropInfoSet );

                if (0 == pPropInfo)
                {
                    LogError("Property info record couldn't be found for property %ws %d\n",
                             FormatGuid(pProps[iPropSet].guidPropertySet),
                             pDbProp[iProp].dwPropertyID);
                    cFailures++;
                    continue;
                }
                if (pDbProp[iProp].dwStatus != ExpStatus)
                {
                    LogError("Property status error (%d) for property %ws %d (%ws)\n",
                             pDbProp[iProp].dwStatus,
                             FormatGuid(pProps[iPropSet].guidPropertySet),
                             pDbProp[iProp].dwPropertyID,
                             pPropInfo->pwszDescription);
                    cFailures++;
                }
                if (pPropInfo->vtType != pDbProp[iProp].vValue.vt)
                {
                    LogError("Property type mismatch (%d %d) for property %ws %d (%ws)\n",
                             pPropInfo->vtType, pDbProp[iProp].vValue.vt,
                             FormatGuid(pProps[iPropSet].guidPropertySet),
                             pDbProp[iProp].dwPropertyID,
                             pPropInfo->pwszDescription);
                    cFailures++;
                }
            }
        }

        if (fCheckAllProperties)
        {
            //
            // Check that all properties returned by GetPropertyInfo are in the
            // DBPROP structures.
            //
            for (iPropSet=0; iPropSet<cPropInfoSet; iPropSet++)
            {
                DBPROPINFO UNALIGNED *pPropInfo = pPropInfoSet[iPropSet].rgPropertyInfos;

                for ( unsigned iProp=0;
                      iProp < pPropInfoSet[iPropSet].cPropertyInfos;
                      iProp++)
                {
                    DBPROP * pDbProp = LocateProperty(
                                     pPropInfoSet[iPropSet].guidPropertySet,
                                     pPropInfo[iProp].dwPropertyID,
                                     cProps, pProps );

                    if (0 == pDbProp)
                    {
                        LogError("Property record couldn't be found for property %ws %d\n",
                                 FormatGuid(pPropInfoSet[iPropSet].guidPropertySet),
                                 pPropInfo[iProp].dwPropertyID);
                        cFailures++;
                    }
                }
            }
        }

        //
        // Free all the structures in the DBPROPINFOSET
        //
        for (iPropSet=0; iPropSet<cPropInfoSet; iPropSet++)
        {
            DBPROPINFO UNALIGNED *pPropInfo = pPropInfoSet[iPropSet].rgPropertyInfos;

            for (unsigned iProp=0;
                 iProp<pPropInfoSet[iPropSet].cPropertyInfos;
                 iProp++)
            {
                VARIANT v;
                RtlCopyMemory( &v, &pPropInfo[iProp].vValues, sizeof v );
                VariantClear( &v );
            }
            CoTaskMemFree( pPropInfo );
        }
        CoTaskMemFree( pPropInfoSet );
        CoTaskMemFree( pwszDescriptions );
    }
    else
    {

        //
        // Check the status of all properties returned by GetProperties.
        //
        for (unsigned iPropSet=0; iPropSet < cProps; iPropSet++)
        {
            DBPROP *pDbProp = pProps[iPropSet].rgProperties;

            for (unsigned iProp=0; iProp<pProps[iPropSet].cProperties; iProp++)
            {
                if (pDbProp[iProp].dwStatus != ExpStatus)
                {
                    LogError("Property status error (%d) for property %ws %d\n",
                             pDbProp[iProp].dwStatus,
                             FormatGuid(pProps[iPropSet].guidPropertySet),
                             pDbProp[iProp].dwPropertyID );
                    cFailures++;
                }

            }
        }
    }

    if (fVerbose > 1)
    {
        PrintRowsetProps (cProps, pProps);
        printf ("\n");
    }
    for (unsigned i=0; i<cProps; i++)
    {
        CoTaskMemFree(pProps[i].rgProperties);
    }
    CoTaskMemFree(pProps);
}

void CheckPropertiesInError( ICommand* pCmd, BOOL fQuiet )
{
    if (! fQuiet)
        LogProgress( " Checking properties in error\n" );

    DBPROPSET * pPropInfo = 0;
    ULONG cPropsets = 0;

    DBPROPIDSET PropIDSet;
    PropIDSet.rgPropertyIDs = 0;
    PropIDSet.cPropertyIDs = 0;
    PropIDSet.guidPropertySet = DBPROPSET_PROPERTIESINERROR;

    ICommandProperties *pCmdProp = 0;
    SCODE sc = pCmd->QueryInterface(IID_ICommandProperties,(void **) &pCmdProp);

    sc = pCmdProp->GetProperties( 1, &PropIDSet, &cPropsets, &pPropInfo );
    pCmdProp->Release();
    if ( FAILED( sc ) )
    {
        LogFail( "ICommandProperties::GetProperties returned 0x%lx\n", sc );
    }
    if ( 0 == cPropsets || 0 == pPropInfo )
    {
        LogFail( "ICommandProperties::GetProperties returned no properties\n");
    }

    if (!fQuiet)
        fVerbose++;
    CheckRowsetProperties( cPropsets, pPropInfo, pCmd, FALSE );
    if (!fQuiet)
        fVerbose--;
}


void CheckPropertiesOnCommand( ICommand* pCmd, BOOL fQuiet )
{
    if (! fQuiet)
        LogProgress( " Verifying rowset properties (from command object)\n" );

    DBPROPSET * pPropInfo = 0;
    ULONG cPropsets = 0;

    ICommandProperties *pCmdProp = 0;
    SCODE sc = pCmd->QueryInterface(IID_ICommandProperties,(void **) &pCmdProp);

    sc = pCmdProp->GetProperties( 0, 0, &cPropsets, &pPropInfo );

    pCmdProp->Release();

    if ( FAILED( sc ) )
    {
        //
        // This isn't really kosher, but it helps to avoid spurious (client-side) memory leaks.
        //

        pCmd->Release();
        LogFail( "ICommandProperties::GetProperties returned 0x%lx\n", sc );
    }

    CheckRowsetProperties( cPropsets, pPropInfo, pCmd );
}


void CheckColumns( IUnknown* pRowset, CDbColumns& rColumns, BOOL fQuiet )
{
    if (! fQuiet)
        LogProgress( " Verifying output columns\n" );

    DBPROPSET * pPropInfo = 0;
    ULONG cPropsets = 0;

    IRowsetInfo *pIRowInfo = 0;
    SCODE sc = pRowset->QueryInterface(IID_IRowsetInfo,(void **) &pIRowInfo);

    sc = pIRowInfo->GetProperties( 0, 0, &cPropsets, &pPropInfo );
    pIRowInfo->Release();
    if ( FAILED( sc ) )
    {
        LogFail( "IRowsetInfo::GetProperties returned 0x%lx\n", sc );
    }

    CheckRowsetProperties( cPropsets, pPropInfo, pRowset );

    DBID aDbCols[MAXCOLUMNS];

    if (rColumns.Count() > MAXCOLUMNS)
    {
        LogError( "TEST ERROR: MAXCOLUMNS is too small\n" );
        CantRun();
    }

    for (ULONG x = 0; x < rColumns.Count(); x++)
        aDbCols[x] = * ((DBID *) &rColumns.Get(x));

    aDbCols[0].uGuid.pguid = &(((DBID *)(&rColumns.Get(0)))->uGuid.guid);
    if (aDbCols[0].eKind == DBKIND_GUID_PROPID)
        aDbCols[0].eKind = DBKIND_PGUID_PROPID;
    else
        aDbCols[0].eKind = DBKIND_PGUID_NAME;

    IColumnsInfo *pIColInfo = 0;
    sc = pRowset->QueryInterface(IID_IColumnsInfo,(void **) &pIColInfo);

    if ( FAILED( sc ) )
    {
        if ( sc == E_NOINTERFACE )
            LogError( "IColumnsInfo failed (must be supported for MapColumnIDs), 0x%x\n", sc );

        LogError( "IRowset::QI IColumnsInfo failed, 0x%x\n", sc );
        cFailures++;
    }

    DBORDINAL aColIds[MAXCOLUMNS];
    sc = pIColInfo->MapColumnIDs(rColumns.Count(), aDbCols, aColIds);

    if (S_OK != sc)
    {
        LogFail( "CheckColumns, IRowset->MapColumnIDs returned 0x%lx\n",sc);
    }

    unsigned iExpCol = 1;
    for (unsigned i = 0; i < rColumns.Count(); i++)
    {
        DBID dbidCol = rColumns.Get(i);
        if (dbidCol.eKind = DBKIND_GUID_PROPID &&
            dbidCol.uName.ulPropid == PROPID_DBBMK_BOOKMARK &&
            dbidCol.uGuid.guid == guidBmk)
        {
            if (aColIds[i] != 0)
            {
                LogError( "IRowset->MapColumnIDs returned unexpected column number for bookmark col.\n" );
                cFailures++;
            }
        }
        else
        {
            if (aColIds[i] != iExpCol)
            {
                LogError( "IRowset->MapColumnIDs returned unexpected column number for col. %d\n", i);
                cFailures++;
            }
            iExpCol++;
        }
    }

    DBORDINAL cColumns = 0;
    DBCOLUMNINFO *pColumnInfo = 0;
    WCHAR *pColumnNames = 0;

    sc = pIColInfo->GetColumnInfo( &cColumns, &pColumnInfo, &pColumnNames );

    if ( FAILED( sc ) )
    {
        LogError( "IColumnsInfo::GetColumnInfo failed, 0x%x\n", sc );
        cFailures++;
    }
    else
    {
        if ( cColumns < rColumns.Count() )
        {
            LogError( "Rowset has too few columns, %d %d\n",
                            cColumns, rColumns.Count() );
            cFailures++;
        }
    }

    if (pColumnInfo != 0)
    {
        if (fVerbose > 1)
            printf("Columns Info:\n" );

        for (ULONG iCol = 0; iCol < cColumns; iCol++)
        {
            DBCOLUMNINFO &Info = pColumnInfo [iCol];

            if ( ( 0 == Info.iOrdinal &&
                   ! ( Info.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) ) ||
                 Info.iOrdinal > cColumns)
            {
                LogError( "IColumnsInfo->GetColumnInfo returned bad column number %d) for col. %d\n", Info.iOrdinal, iCol);
                cFailures++;
            }
            if (Info.columnid.eKind != DBKIND_GUID_PROPID &&
                Info.columnid.eKind != DBKIND_GUID_NAME &&
                Info.columnid.eKind != DBKIND_PGUID_PROPID &&
                Info.columnid.eKind != DBKIND_PGUID_NAME &&
                Info.columnid.eKind != DBKIND_NAME)
            {
                LogError( "IColumnsInfo->GetColumnInfo returned bad column kind %d) for col. %d\n", Info.columnid.eKind, iCol);
                cFailures++;
            }

            if (fVerbose > 1)
            {
                if (Info.columnid.eKind == DBKIND_GUID_PROPID)
                    printf ("(G) %-12li ", Info.columnid.uName.ulPropid);
                else if (Info.columnid.eKind == DBKIND_GUID_NAME)
                    printf ("(G) '%-10ls' ", Info.columnid.uName.pwszName);
                else if (Info.columnid.eKind == DBKIND_PGUID_PROPID)
                    printf ("(PG) %-12li ", Info.columnid.uName.ulPropid);
                else if (Info.columnid.eKind == DBKIND_PGUID_NAME)
                    printf ("(PG) '%-10ls' ", Info.columnid.uName.pwszName);
                else if (Info.columnid.eKind == DBKIND_NAME)
                    printf ("'%-14ls' ", Info.columnid.uName.pwszName);
                else
                    printf ("BAD NAME ");

                printf ("'%-14ls' %2lu %6s %2lu", Info.pwszName, Info.iOrdinal,
                        DBTYPE_Tag (Info.wType), Info.ulColumnSize);

                printf ("\n     ");
                PrintColumnFlags (Info.dwFlags);

                printf ("\n");
            }
        }
        CoTaskMemFree(pColumnInfo);
        CoTaskMemFree(pColumnNames);
    }


    IColumnsRowset *pIColRowset = 0;

    sc = pRowset->QueryInterface(IID_IColumnsRowset,(void **) &pIColRowset );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IColumnsRowset failed, 0x%x\n", sc );
        cFailures++;
    }

    if (0 == pIColRowset && 0 == pIColInfo)
    {
        LogError( "At least one of IColumnsInfo and IColumnsRowset "
                "must be implemented\n" );
        cFailures++;
    }

    if (pIColRowset)
    {
        IRowset *pRowsetCols = 0;
        SCODE scCC = pIColRowset->GetColumnsRowset(0, 0, 0, IID_IRowset, 0, 0,
                                                   (IUnknown**)&pRowsetCols);

        if (FAILED(scCC))
        {
            LogError( "IColumnsRowset::GetColumnsRowset failed, 0x%x\n", scCC );
            cFailures++;
        }

        if (SUCCEEDED(scCC))
            pRowsetCols->Release();
    }

    if (pIColInfo)
    {
        pIColInfo->Release();
        pIColInfo = 0;
    }
    if ( pIColRowset )
    {
        pIColRowset->Release();
        pIColRowset = 0;
    }

} //CheckColumns


//+-------------------------------------------------------------------------
//
//  Function:   BasicTest, public
//
//  Synopsis:   Test basic cursor functionality
//
//  Arguments:  [pCursor] - a pointer to an IRowset* to be tested.
//              [fSequential] - if TRUE, the pCursor will not support
//                              IRowsetLocate, etc.
//              [hChapt]  - chapter pointer
//              [cCols]   - # of columns over which to test
//
//  Returns:    Nothing
//
//  Notes:      The passed in cursor is assumed to be set up with the
//              usual column bindings.  It is also assumed that the
//              query has not necesarily completed.
//
//  History:    26 Sep 94       AlanW   Created from DownLevel test
//              11 Nov 94       Alanw   Converted for phase 3
//
//--------------------------------------------------------------------------

void BasicTest(
    IRowset* pCursor,
    BOOL fSequential,
    HCHAPTER hChapt,
    unsigned cCols,
    BOOL fByRef,
    ICommandTree * pCmdTree )
{
    int fFailed = 0;
    DBCOUNTITEM cRows = 0;
    IRowsetScroll * pIRowsetScroll = 0;
    BOOL fChaptered = GetBooleanProperty( pCursor, DBPROP_IChapteredRowset );

    if (cCols != cBasicTestCols && cCols != cBasicTestCols-1)
        LogFail( "TEST ERROR - bad cCols (%d) passed to BasicTest\n", cCols );

    SCODE sc = pCursor->QueryInterface(IID_IRowsetScroll,(void **) &pIRowsetScroll );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IRowsetScroll failed, 0x%x\n", sc );
        cFailures++;
    }

    if ( fSequential )
    {
        if (0 != pIRowsetScroll )
        {
            LogError( "Sequential cursor supports IRowsetScroll\n" );
            cFailures++;
        }
    }
    else
    {
        if (0 == pIRowsetScroll )
        {
            LogError( "Non-sequential cursor does not support IRowsetScroll\n" );
            cFailures++;
        }
        else
        {
            sc = pIRowsetScroll->GetApproximatePosition(hChapt, 0,0,
                                                        0, &cRows);

            if ( FAILED( sc ) )
            {
                LogError( "IRowset->GetApproximatePosition returned 0x%lx\n", sc );
                cFailures++;
            }

            if ( cRows == 0 )
            {
                LogError( "Query failed to return data\n" );
                pIRowsetScroll->Release();
                pCursor->Release();
                Fail();
            }
        }
    }

    //
    // Patch the column index numbers with true numbers
    //

    DBID aDbCols[cBasicTestCols];
    aDbCols[0] = psClassid;
    aDbCols[1] = psSize;
    aDbCols[2] = psWriteTime;
    aDbCols[3] = psAttr;
    aDbCols[4] = psName;
    aDbCols[5] = psPath;
    aDbCols[6] = psSelf;

    IUnknown * pAccessor = (IUnknown *) pCursor; // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below


    if (fByRef)
    {
        aBasicTestCols[5].dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
    }
    else
    {
        aBasicTestCols[5].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
    }
    HACCESSOR hAccessor = MapColumns( pAccessor,
                                      cCols,
                                      aBasicTestCols,
                                      aDbCols,
                                      fByRef );

    DBID aDbAltCols[cBasicAltCols];
    aDbAltCols[0] = psSize;
    aDbAltCols[1] = psWriteTime;
    aDbAltCols[2] = psWriteTime;
    aDbAltCols[3] = psWriteTime;

    HACCESSOR hAccessor2 = MapColumns( pAccessor,
                                       cBasicAltCols,
                                       aBasicAltCols,
                                       aDbAltCols,
                                       fByRef );

#if defined( DO_NOTIFICATION )
    IConnectionPoint *pConnectionPoint = 0;
    DWORD dwAdviseID = 0;

    CTestWatchNotify Notify;

    if ( ! fSequential )
    {
        Notify.DoChecking(TRUE);

        //
        // Get the connection point container
        //

        IConnectionPointContainer *pConnectionPointContainer = 0;
        sc = pCursor->QueryInterface(IID_IConnectionPointContainer,
                                     (void **) &pConnectionPointContainer);
        if (FAILED(sc))
        {
            LogError( "IRowset->QI for IConnectionPointContainer failed: 0x%x\n",
                    sc );
            pCursor->Release();
            Fail();
        }

        //
        // Make a connection point from the connection point container
        //

        sc = pConnectionPointContainer->FindConnectionPoint(
                 IID_IRowsetWatchNotify,
                 &pConnectionPoint);

        if (FAILED(sc) && CONNECT_E_NOCONNECTION != sc )
        {
            LogError( "FindConnectionPoint failed: 0x%x\n",sc );
            pCursor->Release();
            Fail();
        }

        pConnectionPointContainer->Release();

        if (0 != pConnectionPoint)
        {
            //
            // Give a callback object to the connection point
            //

            sc = pConnectionPoint->Advise((IUnknown *) &Notify,
                                          &dwAdviseID);
            if (FAILED(sc))
            {
                LogError( "IConnectionPoint->Advise failed: 0x%x\n",sc );
                pConnectionPoint->Release();
                pCursor->Release();
                Fail();
            }
        }
    }
#endif // DO_NOTIFICATION

    DBCOUNTITEM totalRowsFetched = 0;
    DBCOUNTITEM cRowsReturned = 0;
    HROW ahRows[10];
    HROW* phRows = ahRows;
    LONGLONG PrevFileSize = 0x7fffffffffffffff;

    //
    // Try passing chapters to non-chaptered rowsets.
    // This causes an exception, so just do it once for each case.
    //

    static BOOL fTriedChaptOnNonChaptered = FALSE;

#if 0   // NOTE: null chapters work on chaptered rowsets!
    static BOOL fTriedNoChaptOnChaptered = FALSE;
    if ( !fTriedNoChaptOnChaptered && 0 != hChapt )
    {
        fTriedNoChaptOnChaptered = TRUE;
        sc = pCursor->GetNextRows(DB_NULL_HCHAPTER, 0, 10, &cRowsReturned, &phRows);
        if (!FAILED(sc))
            LogFail("chaptered IRowset->GetNextRows should have failed\n");
    }
#endif 0

    if ( !fTriedChaptOnNonChaptered && (0 == hChapt) )
    {
        fTriedChaptOnNonChaptered = TRUE;
        sc = pCursor->GetNextRows(DBCHP_FIRST, 0, 10, &cRowsReturned, &phRows);
        if (!FAILED(sc))
            LogFail("unchaptered IRowset->GetNextRows should have failed\n");
    }

    do
    {
        sc = pCursor->GetNextRows(hChapt, 0, 10, &cRowsReturned, &phRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetNextRows returned 0x%x\n", sc );
            pCursor->Release();
            Fail();
        }

        if (sc != DB_S_ENDOFROWSET &&
            cRowsReturned != 10)
        {
            LogError( "IRowset->GetNextRows returned %d of %d rows,"
                    " status (%x) != DB_S_ENDOFROWSET\n",
                        cRowsReturned, 10,
                        sc);
#if defined (UNIT_TEST)
            cFailures++;
#else // defined(UNIT_TEST)
            pCursor->Release();
            Fail();
#endif // defined(UNIT_TEST)
        }

        totalRowsFetched += cRowsReturned;

        if ( (0 != pIRowsetScroll ) &&
             (totalRowsFetched > cRows) )
        {
            //
            // check that no more rows have been added while we were
            // fetching.
            //
            LogProgress("Checking for expansion of result set\n");

            SCODE sc1 = pIRowsetScroll->GetApproximatePosition(hChapt,
                                                0,0, 0, &cRows);

            if ( totalRowsFetched > cRows )
            {
                LogError("Fetched more rows than exist in the result set, %d %d\n",
                        totalRowsFetched, cRows);
                cFailures++;
            }
        }
        //
        // Make sure the hits are sorted by size and that the query
        // really was shallow and that the length fields are correct.
        //

        unsigned i;
        for (i = 0; i < cRowsReturned; i++)
        {
            SBasicTest Row;
            Row.pIPSStorage = 0;

            SCODE sc1 = pCursor->GetData(ahRows[i],hAccessor,&Row);

            if ( FAILED( sc1 ) )
                LogFail( "IRowset->GetData returned 0x%x\n", sc1 );

            LONGLONG size = Row.size;
            if ( PrevFileSize < size &&
                 ( ! fChaptered || hChapt != DB_NULL_HCHAPTER) )
                LogFail("Hitset not sorted by filesize\n");

            if (wcsstr( Row.pwcPath, L"system32\\drivers\\" ) ||
                wcsstr( Row.pwcPath, L"SYSTEM32\\DRIVERS\\" ) ||
                wcsstr( Row.pwcPath, L"System32\\Drivers\\" ))
                LogFail("Query wasn't shallow as expected\n");

            if ( Row.sClsid == DBSTATUS_S_OK &&
                 Row.cbClsid != sizeof CLSID )
                LogFail("length of clsid column not correct: %d\n", Row.cbClsid);

            if ( Row.sSize != DBSTATUS_S_OK ||
                 Row.cbSize != sizeof LONGLONG )
                LogFail("status or length of size column not correct: %d\n",
                        Row.cbSize);

            if ( Row.sWriteTime != DBSTATUS_S_OK ||
                 Row.cbWriteTime != sizeof LONGLONG)
                LogFail("status or length of time column not correct: %d\n", Row.cbWriteTime);

            if ( Row.sAttr != DBSTATUS_S_OK ||
                 Row.cbAttr != sizeof ULONG)
                LogFail("length of attr column not correct: %d\n", Row.cbAttr);

            if ( Row.sName == DBSTATUS_S_OK &&
                 Row.cbName != wcslen(Row.awcName) * sizeof (WCHAR) )
                LogFail( "length of name column 0x%x not consistent with data 0x%x\n",
                         Row.cbName,
                         wcslen(Row.awcName) * sizeof WCHAR );

            if ( Row.sPath == DBSTATUS_S_OK &&
                 Row.cbPath != (wcslen(Row.pwcPath) * sizeof (WCHAR)) )
                LogFail("length of path column not consistent with data\n");

            if ( !fByRef )
                CoTaskMemFree(Row.pwcPath);

            if ( 0 != Row.pIPSStorage )
            {
                Row.pIPSStorage->Release();
                Row.pIPSStorage = 0;
            }

            SBasicAltTest AltRow;
            SCODE sc2 = pCursor->GetData(ahRows[i], hAccessor2, &AltRow);

            if ( FAILED( sc2 ) )
                LogFail( "IRowset->GetData returned 0x%x\n", sc2 );

            if ( AltRow.sSize != DBSTATUS_S_OK ||
                 AltRow.cbSize != sizeof AltRow.Size )
                LogFail("status or length of alt size column not correct: %d\n",
                        AltRow.cbSize);

            if ( AltRow.Size != Row.size )
                LogFail("size column doesn't compare in alt. accessor\n");

            //
            //  Check time conversions
            //
            FILETIME LocalFTime;
            SYSTEMTIME SysTime;

            FileTimeToSystemTime((FILETIME *) &(Row.writeTime), &SysTime);

            if ( AltRow.sWriteTime1 != DBSTATUS_S_OK ||
                 AltRow.cbWriteTime1 != sizeof AltRow.writeTime1)
                LogFail("status or length of writeTime1 column not correct: %d\n",
                         AltRow.cbWriteTime1);

            if ( AltRow.sWriteTime2 != DBSTATUS_S_OK ||
                 AltRow.cbWriteTime2 != sizeof AltRow.writeTime2)
                LogFail("status or length of writeTime2 column not correct: %d\n",
                         AltRow.cbWriteTime2);

            if ( AltRow.sWriteTime3 != DBSTATUS_S_OK ||
                 AltRow.cbWriteTime3 != sizeof AltRow.writeTime3)
                LogFail("status or length of writeTime3 column not correct: %d\n",
                        AltRow.cbWriteTime3);

            if ( SysTime.wYear != AltRow.writeTime1.year ||
                 SysTime.wMonth != AltRow.writeTime1.month ||
                 SysTime.wDay != AltRow.writeTime1.day)
                LogFail("Write time 1 mismatch\n");

            if ( SysTime.wHour != AltRow.writeTime2.hour ||
                 SysTime.wMinute != AltRow.writeTime2.minute ||
                 SysTime.wSecond != AltRow.writeTime2.second)
                LogFail("Write time 2 mismatch\n");

            if ( SysTime.wYear != AltRow.writeTime3.year ||
                 SysTime.wMonth != AltRow.writeTime3.month ||
                 SysTime.wDay != AltRow.writeTime3.day ||
                 SysTime.wHour != AltRow.writeTime3.hour ||
                 SysTime.wMinute != AltRow.writeTime3.minute ||
                 SysTime.wSecond != AltRow.writeTime3.second ||
                 SysTime.wMilliseconds != AltRow.writeTime3.fraction/1000000)
                LogFail("Write time 3 mismatch\n");


            PrevFileSize = size;
        }

        if (fVerbose > 1)
        {
            for (i = 0; i < cRowsReturned; i++)
            {
                SBasicTest Row;
                Row.pIPSStorage = 0;

                SCODE sc1 = pCursor->GetData(ahRows[i],hAccessor,&Row);

                if ( FAILED( sc1 ) )
                {
                    LogError( "IRowset->GetData returned 0x%x\n", sc1 );
                    pCursor->Release();
                    Fail();
                }

                //
                //  print name, attributes and size
                //
                printf( "\t%-16.16ws%04x\t%7d\t",
                        Row.awcName,
                        Row.attr,
                        (ULONG) Row.size );

                //
                //  print file mod. time
                //
                FILETIME LocalFTime;
                SYSTEMTIME SysTime;

                FileTimeToLocalFileTime((FILETIME *) &(Row.writeTime),
                                        &LocalFTime);
                FileTimeToSystemTime(&LocalFTime, &SysTime);

                printf("%02d/%02d/%02d %2d:%02d:%02d\n",
                    SysTime.wMonth, SysTime.wDay, SysTime.wYear % 100,
                    SysTime.wHour, SysTime.wMinute, SysTime.wSecond);

                if ( !fByRef )
                    CoTaskMemFree(Row.pwcPath);

                if (0 != Row.pIPSStorage )
                {
                    Row.pIPSStorage->Release();
                    Row.pIPSStorage = 0;
                }
            }
        }

        if (0 != cRowsReturned)
        {
            SCODE sc1 = pCursor->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
            if ( FAILED( sc1 ) )
            {
                LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
                pCursor->Release();
                Fail();
            }
            cRowsReturned = 0;
        }

    } while (SUCCEEDED(sc) && sc != DB_S_ENDOFROWSET);

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pCursor->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pCursor->Release();
            Fail();
        }
    }

    if ( 0 == totalRowsFetched && 0 != hChapt )
        LogFail("Chapter had no rows for GetNextRows()\n");

    ReleaseAccessor( pAccessor, hAccessor);
    ReleaseAccessor( pAccessor, hAccessor2);

#if defined( DO_NOTIFICATION )
    if ( ! fSequential && 0 != pConnectionPoint )
    {
        NotificationTest();

        //
        // Clean up notification stuff
        //

        sc = pConnectionPoint->Unadvise(dwAdviseID);

        if (S_OK != sc)
        {
            LogError( "IConnectionPoint->Unadvise returned 0x%lx\n",sc);
            pCursor->Release();
            Fail();
        }

        pConnectionPoint->Release();
        //Notify.Release();
    }
#endif // DO_NOTIFICATION

    if (0 != pIRowsetScroll )
    {
        pIRowsetScroll->Release();
        pIRowsetScroll = 0;
    }

#if !defined(UNIT_TEST)
    if (cFailures) {
        pCursor->Release();
        Fail();
    }
#endif // !UNIT_TEST
} //BasicTest



//+-------------------------------------------------------------------------
//
//  Function:   BackwardsFetchTest, public
//
//  Synopsis:   Test backwards fetching
//
//  Arguments:  [pRowset] - IRowset to be tested
//
//  History:    03-Sep-97       SitaramR    Created
//
//--------------------------------------------------------------------------

void BackwardsFetchTest( IRowset* pRowset )
{
    //
    // Patch the column index numbers with true numbers
    //

    DBID aDbCols[cBasicTestCols];
    aDbCols[0] = psClassid;
    aDbCols[1] = psSize;
    aDbCols[2] = psWriteTime;
    aDbCols[3] = psAttr;
    aDbCols[4] = psName;
    aDbCols[5] = psPath;
    aDbCols[6] = psSelf;

    IUnknown * pAccessor = (IUnknown *) pRowset; // hAccessor must be created on rowset
                                                 // to be used with rowset->GetData below

    aBasicTestCols[5].dwMemOwner = DBMEMOWNER_PROVIDEROWNED;

    HACCESSOR hAccessor = MapColumns( pAccessor,
                                      cBasicTestCols,
                                      aBasicTestCols,
                                      aDbCols,
                                      TRUE );

    DBCOUNTITEM cRowsReturned = 0;
    HROW ahRows[10];
    HROW* phRows = ahRows;

    //
    // Backwards fetch for GetNextRows
    //

    SCODE sc = pRowset->RestartPosition( 0 );
    if ( FAILED( sc ) )
    {
        LogError( "IRowset->RestartPosition returned 0x%x\n", sc );
        pRowset->Release();
        Fail();
    }

    sc = pRowset->GetNextRows(0, 9, -9, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowset->GetNextRows returned 0x%x\n", sc );
        pRowset->Release();
        Fail();
    }

    if ( cRowsReturned != 9 )
    {
        LogError( "IRowset->GetNextRows returned %d of %d rows,"
                  " status (%x) != DB_S_ENDOFROWSET\n",
                  cRowsReturned,
                  10,
                  sc);
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowset->Release();
        Fail();
#endif
    }

    //
    // Check data of some of the fields
    //

    for ( unsigned i = 0; i < cRowsReturned; i++)
    {
        SBasicTest Row;
        Row.pIPSStorage = 0;

        SCODE sc1 = pRowset->GetData(ahRows[i],hAccessor,&Row);

        if ( FAILED( sc1 ) )
            LogFail( "IRowset->GetData returned 0x%x\n", sc1 );

        if (wcsstr( Row.pwcPath, L"system32\\drivers\\" ) ||
            wcsstr( Row.pwcPath, L"SYSTEM32\\DRIVERS\\" ) ||
            wcsstr( Row.pwcPath, L"System32\\Drivers\\" ))
            LogFail("Query wasn't shallow as expected\n");

        if ( Row.sClsid == DBSTATUS_S_OK &&
             Row.cbClsid != sizeof CLSID )
            LogFail("length of clsid column not correct: %d\n", Row.cbClsid);

        if ( Row.sSize != DBSTATUS_S_OK ||
             Row.cbSize != sizeof LONGLONG )
            LogFail("status or length of size column not correct: %d\n",
                    Row.cbSize);
    }

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pRowset->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pRowset->Release();
            Fail();
        }
    }

    sc = pRowset->RestartPosition( 0 );
    if ( FAILED( sc ) )
    {
        LogError( "IRowset->RestartPosition returned 0x%x\n", sc );
        pRowset->Release();
        Fail();
    }

    //
    // Backwards fetch for GetRowsAt
    //

    IRowsetLocate *pRowsetLocate = 0;
    sc = pRowset->QueryInterface(IID_IRowsetLocate,(void **) &pRowsetLocate );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IRowsetLocate failed, 0x%x\n", sc );
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowset->Release();
        Fail();
#endif
    }

    sc = pRowsetLocate->GetRowsAt(0, 0, 1, &bmkFirst, 9, -10, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt returned 0x%x\n", sc );
        pRowsetLocate->Release();
        Fail();
    }

    if ( cRowsReturned != 10 )
    {
        LogError( "IRowset->GetRowsAt returned %d of %d rows,"
                  " status (%x) != DB_S_ENDOFROWSET\n",
                  cRowsReturned,
                  10,
                  sc);
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowsetLocate->Release();
        Fail();
#endif
    }

    //
    // Check data of some of the fields
    //

    for ( i = 0; i < cRowsReturned; i++)
    {
        SBasicTest Row;
        Row.pIPSStorage = 0;

        SCODE sc1 = pRowsetLocate->GetData(ahRows[i],hAccessor,&Row);

        if ( FAILED( sc1 ) )
            LogFail( "IRowset->GetData returned 0x%x\n", sc1 );

        if (wcsstr( Row.pwcPath, L"system32\\drivers\\" ) ||
            wcsstr( Row.pwcPath, L"SYSTEM32\\DRIVERS\\" ) ||
            wcsstr( Row.pwcPath, L"System32\\Drivers\\" ))
            LogFail("Query wasn't shallow as expected\n");

        if ( Row.sClsid == DBSTATUS_S_OK &&
             Row.cbClsid != sizeof CLSID )
            LogFail("length of clsid column not correct: %d\n", Row.cbClsid);

        if ( Row.sSize != DBSTATUS_S_OK ||
             Row.cbSize != sizeof LONGLONG )
            LogFail("status or length of size column not correct: %d\n",
                    Row.cbSize);
    }

    HROW ahRows2[10];
    HROW ahRows3[10];
    DBCOUNTITEM cRowsReturned2;
    HROW *phRows2 = ahRows2;

    //
    // Forward fetch rows 1 to 10 for CheckHrowIdentity comparison below
    //

    sc = pRowsetLocate->GetRowsAt(0, 0, 1, &bmkFirst, 0, 10, &cRowsReturned2, &phRows2);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt returned 0x%x\n", sc );
        pRowsetLocate->Release();
        Fail();
    }

    if ( cRowsReturned2 != 10 )
    {
        LogError( "IRowset->GetRowsAt returned %d of %d rows,"
                  " status (%x) != DB_S_ENDOFROWSET\n",
                  cRowsReturned,
                  10,
                  sc);
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowsetLocate->Release();
        Fail();
#endif
    }

    //
    // Reverse ahRows2 into ahRows3 in preparation for CheckHrowIdentity
    // comparison below.
    //
    for ( i=0; i<10; i++ )
        ahRows3[i] = ahRows2[9-i];

    //
    // Check that forward fetch of rows 1 thru 10 and backwards fetch of
    // rows 10 thru 1 (and then reversed) are the same.
    //
    int fFailed = CheckHrowIdentity( 0, 0, 10, ahRows, 10, ahRows3 );
    if ( fFailed > 0 )
    {
        LogError( "Backwards fetch CheckHrowIdentity returned 0x%x\n", fFailed );
        pRowsetLocate->Release();
        Fail();
    }

    if (0 != cRowsReturned2)
    {
        SCODE sc1 = pRowsetLocate->ReleaseRows(cRowsReturned2, ahRows2, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pRowsetLocate->Release();
            Fail();
        }
    }

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pRowsetLocate->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pRowsetLocate->Release();
            Fail();
        }
    }

    pRowsetLocate->Release();

    //
    // Backwards fetch for GetRowsAtRatio
    //

    IRowsetScroll *pRowsetScroll = 0;
    sc = pRowset->QueryInterface(IID_IRowsetScroll,(void **) &pRowsetScroll );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IRowsetScroll failed, 0x%x\n", sc );
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowset->Release();
        Fail();
#endif
    }

    sc = pRowsetScroll->GetRowsAtRatio(0, 0, 50, 100, -9, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetScroll->GetRowsAtRatio returned 0x%x\n", sc );
        pRowsetScroll->Release();
        Fail();
    }

    //
    // Check data of some of the fields
    //

    for ( i = 0; i < cRowsReturned; i++)
    {
        SBasicTest Row;
        Row.pIPSStorage = 0;

        SCODE sc1 = pRowsetScroll->GetData(ahRows[i],hAccessor,&Row);

        if ( FAILED( sc1 ) )
            LogFail( "IRowsetScroll->GetData returned 0x%x\n", sc1 );

        if (wcsstr( Row.pwcPath, L"system32\\drivers\\" ) ||
            wcsstr( Row.pwcPath, L"SYSTEM32\\DRIVERS\\" ) ||
            wcsstr( Row.pwcPath, L"System32\\Drivers\\" ))
            LogFail("Query wasn't shallow as expected\n");

        if ( Row.sClsid == DBSTATUS_S_OK &&
             Row.cbClsid != sizeof CLSID )
            LogFail("length of clsid column not correct: %d\n", Row.cbClsid);

        if ( Row.sSize != DBSTATUS_S_OK ||
             Row.cbSize != sizeof LONGLONG )
            LogFail("status or length of size column not correct: %d\n",
                    Row.cbSize);
    }

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pRowsetScroll->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowsetScroll->ReleaseRows returned 0x%x\n", sc1 );
            pRowsetScroll->Release();
            Fail();
        }
    }

    pRowsetScroll->Release();
    ReleaseAccessor( pAccessor, hAccessor);
}


//+-------------------------------------------------------------------------
//
//  Function:   FetchTest, public
//
//  Synopsis:   Test GetNextRows variations
//
//  Arguments:  [pRowset] - a pointer to an IRowset to be tested.
//
//  Returns:    Nothing
//
//  Notes:      The passed in Rowset is assumed to be set up with the
//              usual column bindings and is capable of supporting
//              Rowset movement via bookmarks in GetRowsAt.
//
//  History:    30 Sep 94       AlanW   Created from BasicTest test
//
//  ToDo:       add tests:
//                  backward fetch
//                  caller/callee allocated hrow array
//                  fetch of 0 rows
//
//--------------------------------------------------------------------------

void FetchTest( IRowset* pRowset )
{
    LogProgress( " Row fetch test\n" ); 

    int fFailed = 0;
    HROW hBad = (HROW) 0xDEDEDEDE;
    ULONG cRefsLeft = 0;
    DBROWSTATUS RowStatus = 0;

    // Try releasing a bad HROW (bug #7449)
    SCODE sc = pRowset->ReleaseRows( 1, &hBad, 0, &cRefsLeft, &RowStatus );
    if (sc != DB_E_ERRORSOCCURRED ||
        RowStatus != DBROWSTATUS_E_INVALID)
    {
        LogError( "ReleaseRows of bad handle returned %x, %x\n", sc, RowStatus );
        fFailed++;
    }

    cFailures += fFailed;
#if !defined(UNIT_TEST)
    if (fFailed) {
        pRowset->Release();
        Fail();
    }
#endif // !UNIT_TEST
} //FetchTest


//+-------------------------------------------------------------------------
//
//  Function:   BindingTest, public
//
//  Synopsis:   Test some of the many possible error paths in CreateAccessor
//
//  Arguments:  [pCursor] - a pointer to an IRowset* to be tested.
//
//  Returns:    Nothing
//
//  Notes:      The helper function TryBinding does much of the work,
//              trying a couple of different scenarios with each input
//              binding set, checking results and reporting errors.
//
//  History:    02 Jul 94       AlanW   Created
//
//--------------------------------------------------------------------------

static DBBINDING aTestBindings[] =
{
  { 0,                   // binding 0
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof (VARIANT),
    0, DBTYPE_VARIANT,
    0,0},
  { 2,                   // binding 1
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    0,
    0, DBTYPE_I8,
    0,0},
  { 2,                  // binding 2
    2 * sizeof (VARIANT),
    0,
    0,
    0,0,0,
    (DBPART) 0x01000000,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof (VARIANT),
    0, DBTYPE_VARIANT,
    0,0},
  { 2,                  // binding 3
    3 * sizeof (VARIANT),
    0,
    0,
    0,0,0,
    DBPART_STATUS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof (VARIANT),
    0, DBTYPE_VARIANT,
    0,0},
  { 2,                  // binding 4
    7,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_I8,
    0,0},
  { 1,                  // binding 5
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE|DBPART_STATUS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_I8,
    0,0},
  { 1,                  // binding 6
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_GUID,
    0,0},
  { 1,                  // binding 7
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_GUID,
    0,0},
  { 1,                  // binding 8
    0,
    0,
    0,
    (ITypeInfo *) 1,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_VARIANT,
    0,0},
  { 1,                  // binding 9
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_GUID,
    0,0},
  { 1,                  // binding 10
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_I4|DBTYPE_BYREF,
    0,0},
  { 1,                  // binding 11
    0,
    20,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    DBBINDFLAG_HTML, DBTYPE_WSTR,
    0,0},
  { 1,                  // binding 12
    0,
    20,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0x20, DBTYPE_WSTR,
    0,0},
};

int TryBinding(
    int        iTest,
    IAccessor * pIAccessor,
    DBACCESSORFLAGS   dwAccessorFlags,
    ULONG      cBindings,
    ULONG      iFirstBinding,
    SCODE      scExpected,
    DBBINDSTATUS FailStatus = DBBINDSTATUS_OK)
{
    HACCESSOR hAccessor = 0;
    DBBINDSTATUS aBindStatus[20];
    SCODE sc = pIAccessor->CreateAccessor( dwAccessorFlags,
                                           cBindings,
                                           &(aTestBindings[iFirstBinding]),
                                           0,
                                           &hAccessor,
                                           aBindStatus );

    int iRet = 0;

    if (scExpected != sc)
    {
        LogError( "IAccessor->CreateAccessor test %d returned 0x%x (expected 0x%x)\n",
                iTest,
                sc,
                scExpected );
        iRet = 1;
    }

    if ((SUCCEEDED(sc) || DB_E_ERRORSOCCURRED == sc) &&
        DBBINDSTATUS_OK != FailStatus)
    {
        for (unsigned i=0; i<cBindings; i++)
        {
            if (aBindStatus[i] == FailStatus)
                break;
        }

        if (i == cBindings)
        {
            LogError( "IAccessor->CreateAccessor test %d returned DBBINDSTATUS 0x%x (expected 0x%x)\n",
                    iTest,
                    aBindStatus[0],
                    FailStatus );
            iRet = 1;
        }
    }

    if (! FAILED(sc))
        pIAccessor->ReleaseAccessor( hAccessor, 0);

    return iRet;
} //TryBinding

void BindingTest( IUnknown* pUnk, BOOL fICommand, BOOL fSequential )
{
    LogProgress( " Accessor binding test\n" );

    int fFailed = 0;
    DBACCESSORFLAGS StdFlags = DBACCESSOR_ROWDATA;

    IAccessor * pIAcc = 0;

    SCODE sc = pUnk->QueryInterface( IID_IAccessor, (void **)&pIAcc);
    if ( FAILED( sc ) || pIAcc == 0 )
    {
        LogFail( "QueryInterface for IAccessor returned 0x%lx\n", sc );
    }

    // regr test for bug #71492, check that we can QI to IConvertType
    // from IAccessor

    IConvertType * pICvtType = 0;
    sc = pUnk->QueryInterface( IID_IConvertType, (void **)&pICvtType);
    if ( FAILED( sc ) || pICvtType == 0 )
    {
        LogError( "QueryInterface for IConvertType returned 0x%lx\n", sc );
        fFailed++;
    }
    else
    {
        pICvtType->Release();
    }

    sc = pIAcc->QueryInterface( IID_IConvertType, (void **)&pICvtType);
    if ( FAILED( sc ) || pICvtType == 0 )
    {
        LogError( "QueryInterface for IConvertType from accessor returned 0x%lx\n", sc );
        fFailed++;
    }
    else
    {
        pICvtType->Release();
    }

    SCODE scExpected = (fSequential & !fICommand) ? DB_E_ERRORSOCCURRED : S_OK;
    DBBINDSTATUS BindStatExp = (fSequential & !fICommand) ?
                                             DBBINDSTATUS_BADORDINAL :
                                             DBBINDSTATUS_OK;

    // Test the return value for a bad column ordinal
    aTestBindings[0].iOrdinal = 0;
    fFailed += TryBinding( 1, pIAcc, StdFlags, 1, 0, scExpected, BindStatExp);

    scExpected = fICommand ? S_OK : DB_E_ERRORSOCCURRED;
    BindStatExp = fICommand ? DBBINDSTATUS_OK : DBBINDSTATUS_BADORDINAL;

    // Test the return value for another bad column ordinal
    aTestBindings[0].iOrdinal = 1000;
    fFailed += TryBinding( 2, pIAcc, StdFlags, 1, 0, scExpected, BindStatExp);

    // Don't allow room for the I8 to be returned
    // But that's ok! fixed-len fields are allowed to pass bogus
    // values for length
    fFailed += TryBinding( 3, pIAcc, StdFlags, 1, 1, S_OK );

    // bogus accessor flags (no bits on, and unused bits turned on)
    fFailed += TryBinding( 4, pIAcc, 0, 1, 1, DB_E_BADACCESSORFLAGS );
    fFailed += TryBinding( 5, pIAcc, DBACCESSOR_ROWDATA|(DBACCESSOR_OPTIMIZED<<1), 1, 1, DB_E_BADACCESSORFLAGS );

    // null binding array
    fFailed += TryBinding( 6, pIAcc, StdFlags, 0, 1, DB_E_NULLACCESSORNOTSUPPORTED );

    // ofs doesn't support Param accessors (yet)
    fFailed += TryBinding( 7, pIAcc, DBACCESSOR_PARAMETERDATA, 1, 1, DB_E_BADACCESSORFLAGS ); //E_NOTIMPL );

#if 0 // Replace these with some other test...
    // ofs doesn't support writable accessors
    fFailed += TryBinding( 8, pIAcc, DBACCESSOR_ROWDATA, 1, 1, DB_E_ACCESSVIOLATION );
#endif // 

    // ofs doesn't support passbyref accessors
    fFailed += TryBinding( 9, pIAcc, DBACCESSOR_ROWDATA|DBACCESSOR_PASSBYREF, 1, 1, DB_E_BYREFACCESSORNOTSUPPORTED );

    // bogus dbcolumnpart -- none of the valid bits turned on
    fFailed += TryBinding( 10, pIAcc, StdFlags, 1, 2, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // just ask for status -- not for data too
    fFailed += TryBinding( 11, pIAcc, StdFlags, 1, 3, S_OK );

    // bad alignment for output data -- No longer fatal.
    fFailed += TryBinding( 12, pIAcc, StdFlags, 1, 4, S_OK );

    // overlap value and status output fields
    fFailed += TryBinding( 13, pIAcc, StdFlags, 1, 5, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // make sure each of the two duplicate bindings used below is ok by itself
    fFailed += TryBinding( 14, pIAcc, StdFlags, 1, 6, S_OK );
    fFailed += TryBinding( 15, pIAcc, StdFlags, 1, 7, S_OK );

    // overlap value fields in two bindings
    fFailed += TryBinding( 16, pIAcc, StdFlags, 2, 6, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // supply ITypeInfo field
    fFailed += TryBinding( 17, pIAcc, StdFlags, 1, 8, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // direct bind to GUID type
    fFailed += TryBinding( 18, pIAcc, StdFlags, 1, 9, S_OK );

    // unsupported byref binding
    fFailed += TryBinding( 19, pIAcc, StdFlags, 1, 10, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO ); //danleg changed hraccess... UNSUPPORTEDCONVERSION );

    // unsupported HTML flag
    fFailed += TryBinding( 20, pIAcc, StdFlags, 1, 11, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // unknown dwFlags field
    fFailed += TryBinding( 21, pIAcc, StdFlags, 1, 12, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    cFailures += fFailed;
    pIAcc->Release();

#if !defined(UNIT_TEST)
    if (fFailed) {
        pUnk->Release();
        Fail();
    }
#endif // !UNIT_TEST

} //BindingTest


void TestIAccessorOnCommand( ICommandTree * pCmdTree )
{
    DBID aDbCols[cBasicTestCols];
    aDbCols[0] = psClassid;
    aDbCols[1] = psSize;
    aDbCols[2] = psWriteTime;
    aDbCols[3] = psAttr;
    aDbCols[4] = psName;
    aDbCols[5] = psPath;
    aDbCols[6] = psSelf;

    HACCESSOR hAccessor = MapColumns( pCmdTree,
                                      cBasicTestCols,
                                      aBasicTestCols,
                                      aDbCols,
                                      FALSE );

    //
    // Clean up.
    //
    ReleaseAccessor( pCmdTree, hAccessor);
}

#define MAX_BOOKMARK_LENGTH     16

DBBINDING aMoveTestCols[] =
{
  // the iOrdinal field is filled out after the cursor is created

  {
    0,
    sizeof DBLENGTH,
    0,
    0,
    0,0,0,
    DBPART_VALUE|DBPART_LENGTH,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    MAX_BOOKMARK_LENGTH,
    0, DBTYPE_BYTES,
    0, 0},
};

const ULONG cMoveTestCols = sizeof aMoveTestCols / sizeof aMoveTestCols[0];

struct BookmarkBinding {
    DBLENGTH    cbBmk;
    BYTE        abBmk[MAX_BOOKMARK_LENGTH];
};


BookmarkBinding aBmks[21];

HACCESSOR hBmkAccessor = 0;


//+-------------------------------------------------------------------------
//
//  Function:   GetBookmarks, public
//
//  Synopsis:   Retrieve bookmarks into the global bookmarks array
//
//  Effects:    aBmks is loaded with bookmarks, one for each row
//
//  Arguments:  [pRowset] - a pointer to IRowsetLocate
//              [cRows]   - nuumber of HROWs in the array
//              [phRows] - a pointer to the HROWs array
//
//  Returns:    0/1 - count of failures
//
//  Notes:      Assumes hBmkAccessor is bound to the rowset for
//              retrieving into the BookmarkBinding struct.
//
//  History:    30 Mar 1995     AlanW   Created
//
//--------------------------------------------------------------------------

int GetBookmarks(
    IRowsetLocate * pRowset,
    DBCOUNTITEM cRows,
    HROW * phRows )
{
    int fFailed = 0;
    SCODE sc;

    for (unsigned i=0; i<cRows; i++)
    {
        sc = pRowset->GetData(phRows[i], hBmkAccessor, &aBmks[i]);
        if (FAILED(sc) || DB_S_ERRORSOCCURRED == sc)
        {
            if (! fFailed)
                LogError( "IRowset::GetData for bookmark failed 0x%x\n", sc );
            fFailed++;
        }
    }
    if (fFailed)
        LogError(" %d/%d failures\n", fFailed, cRows);

    return fFailed != 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   CheckHrowIdentity, private
//
//  Synopsis:   Check for hrow identity among two arrays of HROWs
//
//  Arguments:  [pRowsetIdentity] - if non-zero, a pointer to an
//                      IRowsetIdentity for comparing the HROWs.
//              [lOffset] - offset of matching rows in the two arrays.
//                      Positive if second array is shifted from first,
//                      negative otherwise.
//              [cRows1] - count of rows in first array
//              [phRows1] - pointer to HROWs, first array
//              [cRows2] - count of rows in second array
//              [phRows2] - pointer to HROWs, second array
//
//  Returns:    int - error count
//
//  Notes:
//
//  History:     03 Apr 95      AlanW   Created
//
//--------------------------------------------------------------------------

int CheckHrowIdentity(
    IRowsetIdentity * pRowsetIdentity,
    DBROWCOUNT lOffset,
    DBCOUNTITEM cRows1,
    HROW * phRows1,
    DBCOUNTITEM cRows2,
    HROW * phRows2
) {
    int fFailed = 0;
    SCODE sc;

    DBROWCOUNT o1 = 0, o2 = 0;
    DBCOUNTITEM cRows = min(cRows1, cRows2);

    if (lOffset < 0)
    {
        o1 = -lOffset;
        if (cRows1 - o1 < cRows)
            cRows = cRows1 - o1;
    }
    else if (lOffset > 0)
    {
        o2 = lOffset;
        if (cRows2 - o2 < cRows)
            cRows = cRows2 - o2;
    }

    for (unsigned i=0; i<cRows; i++)
    {
        int fHrowEqual = 0;

        // Compare HROWs for identity
        if (pRowsetIdentity)
        {
            sc = pRowsetIdentity->IsSameRow(phRows1[i+o1], phRows2[i+o2]);
            if (sc == S_OK)
                fHrowEqual = 1;
            else if (sc == S_FALSE)
                fHrowEqual = 0;
            else
            {
                LogError("IRowsetIdentity->IsSameRow returned %x\n", sc);
                fFailed++;
                fHrowEqual = 1;         // only one error for this
            }
        }
        else
            fHrowEqual = (phRows1[i+o1] == phRows2[i+o2]);

        if (! fHrowEqual)
        {
            LogError( "Hrows didn't compare for equality (used identity %d), %x %x\n",
                      ( 0 != pRowsetIdentity ), phRows1[i+o1], phRows2[i+o2] );
            fFailed++;
        }

        if (o1 == o2 || phRows1 == phRows2)
            continue;

        //  Now compare two which should be unequal
        if (pRowsetIdentity)
        {
            sc = pRowsetIdentity->IsSameRow(phRows1[i], phRows2[i]);
            if (sc == S_OK)
                fHrowEqual = 1;
            else if (sc == S_FALSE)
                fHrowEqual = 0;
            else
            {
                LogError("IRowsetIdentity->IsSameRow (2) returned %x\n", sc);
                fFailed++;
                fHrowEqual = 1;         // only one error for this
            }
        }
        else
            fHrowEqual = (phRows1[i] == phRows2[i]);

        if (fHrowEqual)
        {
            LogError("Different Hrows compared equal, %x %x\n",
                                    phRows1[i], phRows2[i]);
            fFailed++;
        }
    }
    return fFailed;
}


//+-------------------------------------------------------------------------
//
//  Function:   MoveTest, public
//
//  Synopsis:   Test IRowsetLocate and IRowsetScroll methods
//
//  Arguments:  [pRowset] - a rowset supporting IRowsetLocate and
//                          optionally IRowsetScroll
//              [hChapt]  - rowset chapter if chaptered
//
//  Returns:    Nothing, exits if test error
//
//  Notes:      IRowsetLocate tests:
//                  QI to IRowsetLocate
//                  QI to IRowsetIdentity
//                  Bind to bookmark column
//                  Compare bookmarks with standard bookmark combinations
//                  Move to beginning and fetch
//                  Get bookmarks for fetched rows
//                  Compare bookmarks for first and second rows
//                  Fetch starting at second row
//                  Check bookmark equivalence for overlapping rows
//                  Check HROW identity for overlapping rows
//                  Move to end and fetch, check cRowsReturned and status
//                  Move after end and fetch, check cRowsReturned and status
//
//              IRowsetScroll tests:
//                  QI to IRowsetScroll
//                  Scroll to 50% and fetch, check GetApproximatePosition
//                  Scroll to 14/27 and fetch, compare rows from 50% fetch
//                  Scroll to 14/13, check for error
//                  Check GetApproximatePosition with std bookmarks
//
//  History:    16 Aug 94       AlanW   Created
//              02 Apr 95       AlanW   Updated for ole-db phase 3, bookmark
//                                      bindings.
//
//--------------------------------------------------------------------------

BookmarkBinding FirstRowBmk;
BookmarkBinding SecondRowBmk;
BookmarkBinding LastRowBmk;
BookmarkBinding PenultimateRowBmk;

const long cLocateTest = 7;
const long cLocateTest2 = 9;

void MoveTest(
    IRowset * pRowset, HCHAPTER hChapt
) {
    int fFailed = 0;

    if (hChapt == DB_NULL_HCHAPTER)
        LogProgress( " IRowsetLocate test\n" );

    IRowsetLocate * pRowsetLocate = 0;
    SCODE sc = pRowset->QueryInterface(IID_IRowsetLocate,
                                       (void **)&pRowsetLocate);

    if (FAILED(sc) || pRowsetLocate == 0) {
        LogFail("QueryInterface to IRowsetLocate failed\n");
    }

    IRowsetIdentity * pRowsetIdentity = 0;
    sc = pRowset->QueryInterface(IID_IRowsetIdentity,
                                       (void **)&pRowsetIdentity);

    if (FAILED(sc) && (sc != E_NOINTERFACE || pRowsetIdentity != 0)) {
        LogError("QueryInterface to IRowsetIdentity failed (%x)\n", sc);
        pRowsetIdentity = 0;
        fFailed++;
    }

    BOOL fCompareOrdered = GetBooleanProperty( pRowset, DBPROP_ORDEREDBOOKMARKS );
    BOOL fBookmarkBound = FALSE;

    // need to know how many rows in the chapter total, so that tests
    // below can be relaxed if there are just a few.

    DBCOUNTITEM cTableRows;
    IRowsetScroll * pIRowsetScroll = 0;
    SCODE sca = pRowset->QueryInterface(IID_IRowsetScroll,(void **) &pIRowsetScroll );
    if ( FAILED( sca ) )
    {
        LogError( "IRowset::qi for rowsetscroll returned 0x%lx\n", sca );
        fFailed++;
    }

    sca = pIRowsetScroll->GetApproximatePosition(hChapt,
                                                0,0, 0, &cTableRows);

    if ( FAILED( sca ) )
    {
        LogError( "IRowsetScroll::GetApproximatePosition returned 0x%lx\n", sca );
        fFailed++;
    }

    if (fVerbose > 1)
        LogProgress("   Movable rowset has %d rows\n",cTableRows);

    pIRowsetScroll->Release();

    //
    //  Get the column number for the standard bookmark if available
    //
    hBmkAccessor = MapColumns(pRowset, 1, aMoveTestCols, &psBookmark);
    fBookmarkBound = TRUE;

    if ( aMoveTestCols[0].iOrdinal != 0 )
    {
        LogError( "Bookmark column is not ordinal 0 ( = %d)\n",
                  aMoveTestCols[0].iOrdinal );
        fFailed++;
    }

    HROW* phRows = 0;
    DBROWCOUNT cRowsRequested = 1000;
    DBCOUNTITEM cRowsReturned =   0;

    //
    //  Fetch 1000 rows from the beginning of the rowset.
    //
    sc = pRowsetLocate->GetRowsAt( 0, hChapt, 1, &bmkFirst, 0,
                                   cRowsRequested, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt(1000) returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc != DB_S_ENDOFROWSET &&
             cRowsReturned != (DBCOUNTITEM) cRowsRequested)
    {
        LogError( "IRowsetLocate->GetRowsAt J returned %d of %d rows\n",
                    cRowsReturned, cRowsRequested);
        fFailed++;
    }

    if (phRows)
        FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    //
    //  Fetch 10 rows from the beginning of the rowset.
    //
    cRowsRequested = 10;
    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkFirst, 0,
                             cRowsRequested, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt K returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc != DB_S_ENDOFROWSET &&
             cRowsReturned != (DBCOUNTITEM) cRowsRequested)
    {
        LogError( "IRowsetLocate->GetRowsAt L returned %d of %d rows\n",
                    cRowsReturned, cRowsRequested);
        fFailed++;
    }

    HROW* phRows2 = 0;
    DBCOUNTITEM cRowsReturned2 = 0;

    DWORD dwCompare = 0xFFFFFFFF;

    if (fBookmarkBound)
    {
        fFailed += GetBookmarks( pRowsetLocate, cRowsReturned, phRows);
        FirstRowBmk = aBmks[0];

        if ( cRowsReturned > 1 )
            SecondRowBmk = aBmks[1];
        else
            SecondRowBmk.cbBmk = 0;

        sc = pRowsetLocate->Compare(hChapt, 1,&bmkFirst,
                            FirstRowBmk.cbBmk, FirstRowBmk.abBmk, &dwCompare);

        if ( FAILED( sc ) )
        {
            LogError( "IRowsetLocate->Compare of DBBMK_FIRST returned 0x%x\n", sc );
            fFailed++;
        }
        else if (dwCompare != DBCOMPARE_NE)
        {
            // DBBMK_FIRST is not the same as the first row's bookmark
            LogError( "Compare of DBBMK_FIRST and returned bookmark not "
                        "notequal (%d)\n", dwCompare );
            fFailed++;
        }
        if (cRowsReturned >= 2)
        {
            sc = pRowsetLocate->Compare(hChapt,
                                    FirstRowBmk.cbBmk, FirstRowBmk.abBmk,
                                    SecondRowBmk.cbBmk, SecondRowBmk.abBmk,
                                    &dwCompare);

            if ( FAILED( sc ) )
            {
                LogError( "IRowsetLocate->Compare returned 0x%x\n", sc );
                fFailed++;
            }
            else if ((fCompareOrdered && dwCompare != DBCOMPARE_LT) ||
                     (! fCompareOrdered && dwCompare != DBCOMPARE_NE))
            {
                LogError( "Compare of first and second returned bookmarks not "
                            "%s (%d)\n",
                            fCompareOrdered? "less than" : "not equal",
                            dwCompare );
                fFailed++;
            }

            //
            //  Fetch 10 rows starting at the second row.  Compare
            //  the overlapping returned HROWs.
            //

            sc = pRowsetLocate->GetRowsAt(0, hChapt,
                                    SecondRowBmk.cbBmk, SecondRowBmk.abBmk, 0,
                                    cRowsRequested, &cRowsReturned2, &phRows2);

            if ( FAILED( sc ) )
            {
                LogError("IRowsetLocate->GetRowsAt (2) returned 0x%x\n", sc );
                fFailed++;
            }
            else if (sc != DB_S_ENDOFROWSET &&
                     cRowsReturned2 != (DBCOUNTITEM) cRowsRequested)
            {
                LogError("IRowsetLocate->GetRowsAt (2) returned %d of %d rows\n",
                            cRowsReturned2, cRowsRequested);
                fFailed++;
            }
            else if (sc == DB_S_ENDOFROWSET &&
                     cRowsReturned2 < (DBCOUNTITEM) cRowsRequested &&
                     cRowsReturned2 != cRowsReturned - 1)
            {
                LogError("IRowsetLocate->GetRowsAt (2) returned inconsistent row count, %d  - %d\n",
                            cRowsReturned2, cRowsReturned);
                fFailed++;
            }

            fFailed += CheckHrowIdentity(pRowsetIdentity, -1,
                                         cRowsReturned, phRows,
                                         cRowsReturned2, phRows2);


            fFailed += GetBookmarks( pRowsetLocate, 1, phRows2);

            sc = pRowsetLocate->Compare(hChapt,
                                    SecondRowBmk.cbBmk, SecondRowBmk.abBmk,
                                    aBmks[0].cbBmk, aBmks[0].abBmk,
                                    &dwCompare);

            if ( FAILED( sc ) )
            {
                LogError( "IRowsetLocate->Compare returned 0x%x\n", sc );
                fFailed++;
            }
            else if (dwCompare != DBCOMPARE_EQ)
            {
                LogError( "Compare of second row bookmarks not equal (%d)\n",
                                        dwCompare );
                fFailed++;
            }
            FreeHrowsArray( pRowsetLocate, cRowsReturned2, &phRows2);
        }
    }

    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    //
    //  Fetch at end, 3 cases:
    //          Last - 1        expect 2 rows returned
    //          Last + 0        expect 1 row returned
    //          Last + 1        expect 0 rows
    //

    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, -1,
                                cRowsRequested, &cRowsReturned, &phRows);

    PenultimateRowBmk.cbBmk = 0;
    LastRowBmk.cbBmk = 0;

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt M returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc != DB_S_ENDOFROWSET ||
             (cRowsReturned != 2 && cTableRows >= 2 ) )
    {
        LogError( "IRowsetLocate->GetRowsAt N returned %d rows at DBBMK_LAST - 1, sc: %lx\n",
                    cRowsReturned, sc );
        fFailed++;
    }
    else if (fBookmarkBound && cRowsReturned >= 2)
    {
        fFailed += GetBookmarks( pRowsetLocate, cRowsReturned, phRows);
        LastRowBmk = aBmks[1];
        PenultimateRowBmk = aBmks[0];

        sc = pRowsetLocate->Compare(hChapt, 1,&bmkLast,
                            LastRowBmk.cbBmk, LastRowBmk.abBmk, &dwCompare);

        if ( FAILED( sc ) )
        {
            LogError( "IRowsetLocate->Compare of DBBMK_LAST returned 0x%x\n", sc );
            fFailed++;
        }
        else if (dwCompare != DBCOMPARE_NE)
        {
            // DBBMK_LAST is not the same as the last row's bookmark
            LogError( "Compare of DBBMK_LAST and returned bookmark not "
                        "notequal (%d)\n", dwCompare );
            fFailed++;
        }

        if (cRowsReturned >= 2)
        {
            sc = pRowsetLocate->Compare(hChapt,
                                    LastRowBmk.cbBmk, LastRowBmk.abBmk,
                                    aBmks[0].cbBmk, aBmks[0].abBmk,
                                    &dwCompare);

            if ( FAILED( sc ) )
            {
                LogError( "IRowsetLocate->Compare returned 0x%x\n", sc );
                fFailed++;
            }
            else if ((fCompareOrdered && dwCompare != DBCOMPARE_GT) ||
                     (! fCompareOrdered && dwCompare != DBCOMPARE_NE))
            {
                LogError( "Compare of last and penultimate returned bookmarks not "
                            "%s (%d)\n",
                            fCompareOrdered? "greater than" : "not equal",
                            dwCompare );
                fFailed++;
            }
        }
    }

    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, 0,
                                cRowsRequested, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt O returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc != DB_S_ENDOFROWSET ||
             cRowsReturned != 1 )
    {
        LogError( "IRowsetLocate->GetRowsAt P returned %d rows at DBBMK_LAST, sc: %lx\n",
                    cRowsReturned, sc );
        fFailed++;
    }

    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, 1,
                                cRowsRequested, &cRowsReturned, &phRows);

    if ( FAILED( sc ) /* && DB_E_BADSTARTPOSITION != sc */ )
    {
        LogError( "IRowsetLocate->GetRowsAt Q returned 0x%x\n", sc );
        fFailed++;
    }
    else if ( sc != DB_S_ENDOFROWSET || cRowsReturned != 0 )
    {
        LogError( "IRowsetLocate->GetRowsAt R returned sc 0x%x, %d rows at DBBMK_LAST + 1\n",
                   sc, cRowsReturned );
        fFailed++;
    }

    if (0 == cRowsReturned &&
        phRows != 0)            // Bug #7668 (part)
    {
        LogError("HROW array allocated without returned rows\n");
        fFailed++;
    }

    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    // OLE-DB spec. bug #1007
    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, 0,
                                1, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt S returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc == DB_S_ENDOFROWSET ||
             cRowsReturned != 1 )
    {
        LogError( "IRowsetLocate->GetRowsAt T returned ENDOFROWSET inappropriately"
                " at DBBMK_LAST, %d\n",
                    cRowsReturned );
        fFailed++;
    }
    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    if ( cTableRows > cLocateTest2 )
    {
        sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, -cLocateTest,
                            cLocateTest + 1, &cRowsReturned, &phRows);

        if ( FAILED( sc ) )
        {
            LogError("IRowsetLocate->GetRowsAt U (end-%d) returned 0x%x\n", cLocateTest,
                     sc );
            fFailed++;
        }
        else if (fBookmarkBound)
            fFailed += GetBookmarks( pRowsetLocate, cRowsReturned, phRows);

        sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, -cLocateTest2,
                            cLocateTest2 + 1, &cRowsReturned2, &phRows2);

        if ( FAILED( sc ) )
        {
            LogError("IRowsetLocate->GetRowsAt(2) V (end-%d) returned 0x%x\n",
                     cLocateTest2, sc );
            fFailed++;
        }
        else if ( (cRowsReturned <= cLocateTest && cRowsReturned2 != cRowsReturned) ||
                  (cRowsReturned == (cLocateTest+1) && cRowsReturned2 <= cLocateTest) )
        {
            if ( sc != DB_S_ENDOFROWSET )
            {
                LogError("IRowsetLocate->GetRowsAt W (end-%d) returned %d rows\n",
                         cLocateTest2, cRowsReturned2 );
                fFailed++;
            }
        }
        else
        {
            fFailed += CheckHrowIdentity( pRowsetIdentity,
                                          cRowsReturned2 - cRowsReturned,
                                          cRowsReturned, phRows,
                                          cRowsReturned2, phRows2);

        }
        FreeHrowsArray( pRowsetLocate, cRowsReturned2, &phRows2);
        FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

        if (fBookmarkBound)
        {
            // Attempt to call GetRowsByBookmark with bookmarks we've collected.

            const unsigned cBybmkTest = cLocateTest + 1 + 5 + 1;
            DBBKMARK rgcbBookmarks[cBybmkTest];
            BYTE* rgpBookmarks[cBybmkTest];
            ULONG cBookmarks = 0;

            for (unsigned i = 0; i<cRowsReturned; i++)
            {
                rgcbBookmarks[cBookmarks] = aBmks[i].cbBmk;
                rgpBookmarks[cBookmarks] = &aBmks[i].abBmk[0];
                cBookmarks++;
            }

            rgcbBookmarks[cBookmarks] = FirstRowBmk.cbBmk;
            rgpBookmarks[cBookmarks++] = &FirstRowBmk.abBmk[0];

            if ( 0 != SecondRowBmk.cbBmk )
            {
                rgcbBookmarks[cBookmarks] = SecondRowBmk.cbBmk;
                rgpBookmarks[cBookmarks++] = &SecondRowBmk.abBmk[0];
            }

            if ( 0 != LastRowBmk.cbBmk )
            {
                rgcbBookmarks[cBookmarks] = LastRowBmk.cbBmk;
                rgpBookmarks[cBookmarks++] = &LastRowBmk.abBmk[0];
            }

            if ( 0 != PenultimateRowBmk.cbBmk )
            {
                rgcbBookmarks[cBookmarks] = PenultimateRowBmk.cbBmk;
                rgpBookmarks[cBookmarks++] = &PenultimateRowBmk.abBmk[0];
            }

            rgcbBookmarks[cBookmarks] = FirstRowBmk.cbBmk;
            rgpBookmarks[cBookmarks++] = &FirstRowBmk.abBmk[0];

            DBROWSTATUS BmkErrors[cBybmkTest];
            HROW hRows[cBybmkTest];
            sc = pRowsetLocate->GetRowsByBookmark( hChapt,
                                                   cBookmarks, rgcbBookmarks,
                                                   (const BYTE **)rgpBookmarks,
                                                   hRows, BmkErrors);
            if ( FAILED( sc ) )
            {
                LogError( "IRowsetLocate->GetRowsByBookmark returned 0x%x\n", sc );
                fFailed++;
            }
            else if ( sc != S_OK )
            {
                LogError( "Not all rows returned from GetRowsByBookmark, sc = 0x%x"
                            "\t%d\n", sc, cBookmarks );
                fFailed++;
            }
            else
            {
                fFailed += GetBookmarks( pRowsetLocate, cBookmarks, hRows);
            }

            ReleaseStaticHrows( pRowsetLocate, cBookmarks, hRows);

            //
            // Try with a bad bookmark; check that correct status and
            // HROW are returned.  Regression test for #80381.
            //
            unsigned iBadRow = cBookmarks / 2;
            rgcbBookmarks[cBookmarks] = rgcbBookmarks[iBadRow];
            rgpBookmarks[cBookmarks++] = rgpBookmarks[iBadRow];

            rgcbBookmarks[iBadRow] = 1;
            rgpBookmarks[iBadRow] = (BYTE *)&bmkFirst;

            sc = pRowsetLocate->GetRowsByBookmark( hChapt,
                                                   cBookmarks, rgcbBookmarks,
                                                   (const BYTE **)rgpBookmarks,
                                                   hRows, BmkErrors);

            if ( sc != DB_S_ERRORSOCCURRED )
            {
                LogError( "GetRowsByBookmark with special bookmark didn't give error, sc = 0x%x"
                            "\t%d\n", sc, cBookmarks );
                fFailed++;
            }
            else if (hRows[iBadRow] != DB_NULL_HROW ||
                     BmkErrors[iBadRow] != DBROWSTATUS_E_INVALID)
            {
                LogError( "GetRowsByBookmark with special bookmark didn't give null hrow or correct status, "
                          "hrow = 0x%x\trs = 0x%x\n", hRows[iBadRow], BmkErrors[iBadRow] );
                fFailed++;
            }
            ReleaseStaticHrows( pRowsetLocate, cBookmarks, hRows);
        }
    }


    //-------------------------
    //
    //  IRowsetScroll tests
    //
    //-------------------------

    IRowsetScroll * pRowsetScroll;
    sc = pRowset->QueryInterface(IID_IRowsetScroll,
                                 (void **)&pRowsetScroll);

    BOOL fScroll = SUCCEEDED(sc);

    if (fScroll)
    {
        if (hChapt == DB_NULL_HCHAPTER)
            LogProgress( " IRowsetScroll test\n" );

        DBCOUNTITEM ulNum = 1, cRows = 0;
        BookmarkBinding HalfRowBmk;

/***
Additional Scroll tests to be coded up:
    Scroll to 10%, 20%, 30%..., GetBookmark, GetPosition and check
    Try bad fractions, 0/0, 101/100, fffffffe/ffffffff, etc.
***/
        //
        //  Try a simple scroll
        //

        cRowsRequested = 20;
        sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 50, 100,
                                    cRowsRequested, &cRowsReturned, &phRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetRowsAtRatio returned 0x%x\n", sc );
            fFailed++;
        }
        else if (sc != DB_S_ENDOFROWSET &&
                 cRowsReturned != (DBCOUNTITEM) cRowsRequested)
        {
            LogError( "IRowset->GetRowsAtRatio returned %d of %d rows\n",
                        cRowsReturned,
                        cRowsRequested);
            fFailed++;
        }
        else if (fBookmarkBound)
        {
            fFailed += GetBookmarks(pRowsetScroll, cRowsReturned, phRows);

            HalfRowBmk = aBmks[0];
            sc = pRowsetScroll->GetApproximatePosition(hChapt,
                                        HalfRowBmk.cbBmk, HalfRowBmk.abBmk,
                                        &ulNum, &cRows);
            if ( FAILED( sc ) )
            {
                LogError( "IRowset->GetApproximatePosition returned 0x%x\n", sc );
                fFailed++;
            }
            else if (cRows == 0 ||
                     (ulNum-1 < ((cRows-1)*40)/100 || ulNum-1 > (cRows*60)/100))
            {
                LogError( "Scroll 50%%/GetApproximatePosition returned %d, %d\n",
                                ulNum, cRows );
                fFailed++;
            }
        }

        cRowsRequested = 10;
        sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 14, 27,
                                    cRowsRequested, &cRowsReturned2, &phRows2);
        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetRowsAtRation 14/27 returned 0x%x\n", sc );
            fFailed++;
        }
        else if (fBookmarkBound)
        {
            DBCOUNTITEM ulNum2 = 0;
            fFailed += GetBookmarks(pRowsetScroll, cRowsReturned2, phRows2);

            sc = pRowsetScroll->GetApproximatePosition( hChapt,
                                        aBmks[0].cbBmk, aBmks[0].abBmk,
                                        &ulNum2, &cRows);
            if ( FAILED( sc ) )
            {
                LogError( "IRowset->GetApproximatePosition 14/27 returned 0x%x\n", sc );
                fFailed++;
            }
            else if (cRows == 0 || ulNum > ulNum2)
            {
                LogError( "Scroll 51.8%%/GetApproximatePosition returned %d, %d, %d, total rows: %d\n",
                                ulNum, ulNum2, cRows, cTableRows );
                fFailed++;
            }
            else if (ulNum != ulNum2)
            {
                sc = pRowsetLocate->Compare(hChapt,
                                        HalfRowBmk.cbBmk, HalfRowBmk.abBmk,
                                        aBmks[0].cbBmk, aBmks[0].abBmk,
                                        &dwCompare);

                if ( FAILED( sc ) )
                {
                    LogError( "IRowsetLocate->Compare returned 0x%x\n", sc );
                    fFailed++;
                }
                else if ((fCompareOrdered && dwCompare != DBCOMPARE_LT) ||
                         (! fCompareOrdered && dwCompare != DBCOMPARE_NE))
                {
                    LogError( "Compare of 50%% and 51.8%% returned bookmarks not "
                                "%s (%d)\n",
                                fCompareOrdered? "less than" : "not equal",
                                dwCompare );
                    fFailed++;
                }
            }

            if ( ( ulNum2 - ulNum ) < (DBCOUNTITEM) cRowsRequested)
            {
                DBCOUNTITEM oRowDiff = ulNum - ulNum2;
                fFailed += CheckHrowIdentity( pRowsetIdentity, oRowDiff,
                                              cRowsReturned, phRows,
                                              cRowsReturned2, phRows2);
            }
        }
        FreeHrowsArray(pRowsetScroll, cRowsReturned2, &phRows2);
        FreeHrowsArray(pRowsetScroll, cRowsReturned, &phRows);

        static cTimesBadRatioTested = 0;

        if ( cTimesBadRatioTested < 10  )
        {
            // limited to 10 tests of this because it causes an exception
            // internally which slows the drt down unnecessarily

            cTimesBadRatioTested++;
            sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 14, 13,
                                        cRowsRequested, &cRowsReturned, &phRows);
            if ( sc != DB_E_BADRATIO )
            {
                LogError( "IRowset->GetRowsAtRatio returned 0x%x for invalid fraction\n",
                            sc );
                fFailed++;
            }

            FreeHrowsArray(pRowsetScroll, cRowsReturned, &phRows);
        }

        sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 0, 100,
                                    cRowsRequested, &cRowsReturned, &phRows);
        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetRowsAtRatio, 0%% returned 0x%x\n", sc );
            fFailed++;
        }
        else if (fBookmarkBound)
            fFailed += GetBookmarks( pRowsetScroll, cRowsReturned, phRows);

        FreeHrowsArray(pRowsetScroll, cRowsReturned, &phRows);

        if (fBookmarkBound)
        {
            sc = pRowsetScroll->GetApproximatePosition( hChapt,
                                            aBmks[0].cbBmk, aBmks[0].abBmk,
                                            &ulNum, &cRows);
            if ( FAILED( sc ) )
            {
                LogError( "IRowset->GetApproximatePosition 0%% returned 0x%x\n", sc );
                fFailed++;
            }
            else if (cRows == 0 || ulNum != 1)
            {
                LogError( "GetApproximatePosition, first row returned %d, %d\n",
                                ulNum, cRows );
                fFailed++;
            }
        }

        if ( 0 == hChapt )
        {
            sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 100, 100,
                                        cRowsRequested, &cRowsReturned, &phRows);
    //      if ( FAILED(sc) )
            if (cRowsReturned != 0 || sc != DB_S_ENDOFROWSET)
            {
                LogError( "IRowsetScroll->GetRowsAtRatio 100%% returned sc: 0x%x, cRowsReturned: 0x%x\n",
                          sc, cRowsReturned );
                fFailed++;
            }
            FreeHrowsArray(pRowsetScroll, cRowsReturned, &phRows);
        }

        sc = pRowsetScroll->GetApproximatePosition( hChapt,
                                            1, &bmkLast,
                                            &ulNum, &cRows);
        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetApproximatePosition DBBMK_LAST returned 0x%x\n", sc );
            fFailed++;
        }
        else if (ulNum != cRows)
        {
            LogError( "GetApproximatePosition, last row returned %d, %d\n",
                            ulNum, cRows );
            fFailed++;
        }
        pRowsetScroll->Release();
    }   // end if (fScroll)


    cFailures += fFailed;
    pRowsetLocate->Release();
    if (fBookmarkBound)
        ReleaseAccessor( pRowset, hBmkAccessor);

    if (0 != pRowsetIdentity)
        pRowsetIdentity->Release();

#if !defined(UNIT_TEST)
//    if (fFailed) {
//        pRowset->Release();
//        Fail();
//    }
#endif // !UNIT_TEST
    return;
} //MoveTest


//+-------------------------------------------------------------------------
//
//  Function:   DeleteTest, public
//
//  Synopsis:   Check that row delete works correctly
//
//  Returns:    Nothing
//
//  Notes:      Duplication scenario for bug# 12282
//
//  History:    18 May 1995       AlanW   Created
//
//--------------------------------------------------------------------------

struct SDeleteTest
{
    DBLENGTH  cbName;
    DBLENGTH  cbPath;

    DBROWSTATUS sName;
    DBROWSTATUS sPath;

    WCHAR     awcName[40];
    WCHAR     awcPath[MAX_PATH+1];
};

DBBINDING aDeleteTestCols[] =
{
  // the iOrdinal field is filled out after the cursor is created

  { 0,
    offsetof(SDeleteTest,awcName),
    offsetof(SDeleteTest,cbName),
    offsetof(SDeleteTest,sName),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    40 * sizeof (WCHAR),
    0, DBTYPE_WSTR,
    0,0,
    },
  { 0,
    offsetof(SDeleteTest,awcPath),
    offsetof(SDeleteTest,cbPath),
    offsetof(SDeleteTest,sPath),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbRowName,
    0, DBTYPE_WSTR,
    0,0,
    },
};

const ULONG cDeleteTestCols = sizeof aDeleteTestCols / sizeof aDeleteTestCols[0];

void DeleteTest(BOOL fSequential)
{
    LogProgress( "Delete function test with %s rowset\n",
                  fSequential ? "sequential" : "movable" );

    WCHAR wcsTestSubDir[MAX_PATH];
    wcscpy( wcsTestSubDir, wcsTestPath );
    wcscat( wcsTestSubDir, L"\\DeleteTest." );
    wcscat( wcsTestSubDir, fSequential ? L"1" : L"2" );

    unsigned cchTestSubDir = wcslen(wcsTestSubDir);

    //
    // Get name, size and class id for *.*
    //

    CDbColumns cols(2);

    cols.Add( psName, 0 );
    cols.Add( psPath, 1 );

    CDbSortSet ss(1);

    if (! fSequential )
        ss.Add(psName, QUERY_SORTASCEND, 0);

    CDbCmdTreeNode * pCmdTree = FormQueryTree( 0, cols, &ss );

    IRowset * pRowset = InstantiateRowset(
                                0,
                                QUERY_DEEP,              // Depth
                                wcsTestPath,             // Scope
                                pCmdTree,                // DBCOMMANDTREE
                                IID_IRowsetScroll);      // IID of i/f to return

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols );

    if ( !WaitForCompletion( pRowset ) )
    {
        LogError( "DeleteTest query unsuccessful.\n" );
        pRowset->Release();
        Fail();
    }

    int fFailed = 0;

    //
    // Get an IRowsetScroll if possible.
    //

    DBCOUNTITEM cRows = 0;

    IRowsetScroll * pIRowsetScroll = 0;

    SCODE sc = pRowset->QueryInterface(IID_IRowsetScroll,(void **) &pIRowsetScroll );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IRowsetScroll failed, 0x%x\n", sc );
        cFailures++;
    }

    if (0 == pIRowsetScroll )
    {
        if (! fSequential)
        {
            LogError( "Non-sequential cursor does not support IRowsetScroll\n" );
            cFailures++;
        }
    }
    else
    {
        sc = pIRowsetScroll->GetApproximatePosition(0, 0,0, 0, &cRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetApproximatePosition returned 0x%lx\n", sc );
            cFailures++;
        }

        if ( cRows == 0 )
        {
            LogError( "Query failed to return data\n" );
            pIRowsetScroll->Release();
            pRowset->Release();
            Fail();
        }
    }

    //
    // Patch the column index numbers with true numbers
    //

    DBID aDbCols[cDeleteTestCols];
    aDbCols[0] = psName;
    aDbCols[1] = psPath;

    HACCESSOR hAccessor = MapColumns(pRowset, cDeleteTestCols, aDeleteTestCols, aDbCols);

    DBCOUNTITEM totalRowsFetched = 0;
    DBCOUNTITEM cRowsReturned = 0;
    HROW ahRows[10];
    HROW* phRows = ahRows;

    BOOL fDidDelete = FALSE;
    BOOL fDidDirDelete = FALSE;

    do
    {
        sc = pRowset->GetNextRows(0, 0, 1, &cRowsReturned, &phRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetNextRows returned 0x%x\n", sc );
            pRowset->Release();
            Fail();
        }

        if (sc != DB_S_ENDOFROWSET &&
            cRowsReturned != 1)
        {
            LogError( "IRowset->GetNextRows returned %d of %d rows,"
                    " status (%x) != DB_S_ENDOFROWSET\n",
                        cRowsReturned, 1,
                        sc);
#if defined (UNIT_TEST)
            cFailures++;
#else // defined(UNIT_TEST)
            pRowset->Release();
            Fail();
#endif // defined(UNIT_TEST)
        }

        totalRowsFetched += cRowsReturned;

        if ( (0 != pIRowsetScroll ) &&
             (totalRowsFetched > cRows) )
        {
            //
            // check that no more rows have been added while we were
            // fetching.
            //
            LogProgress("Checking for expansion of result set\n");

            SCODE sc1 = pIRowsetScroll->GetApproximatePosition(0,
                                                0,0, 0, &cRows);

            if ( totalRowsFetched > cRows )
            {
                LogError("Fetched more rows than exist in the result set, %d %d\n",
                        totalRowsFetched, cRows);
                cFailures++;
            }
        }
        //
        // When the retrieved row is the file name "F0005.txt" in the
        // test directory, delete that file and
        // continue the enumeration.  We expect that GetNextRows can
        // deal with the deletion.
        //
        // When the retrieved row is the file name "F0009.txt" in the
        // test directory, delete the entire test directory and
        // continue the enumeration.  We expect that GetNextRows can
        // deal with this deletion also.
        //

        unsigned i;
        for (i = 0; i < cRowsReturned; i++)
        {
            SDeleteTest Row;

            SCODE sc1 = pRowset->GetData(ahRows[i],hAccessor,&Row);

            if ( FAILED( sc1 ) )
            {
                LogError( "IRowset->GetData returned 0x%x\n", sc1 );
                pRowset->Release();
                Fail();
            }

            if ( Row.sName == DBSTATUS_S_OK &&
                 Row.cbName != (wcslen(Row.awcName) * sizeof (WCHAR)) )
                LogFail( "length of name column 0x%x not consistent with data 0x%x\n",
                         Row.cbName,
                         wcslen(Row.awcName) * sizeof WCHAR );

            if ( Row.sPath == DBSTATUS_S_OK &&
                 Row.cbPath != (wcslen(Row.awcPath) * sizeof (WCHAR)) )
                LogFail("length of path column not consistent with data\n");

            if ( _wcsicmp( Row.awcName, L"F0005.txt" ) == 0 &&
                 _wcsnicmp( Row.awcPath, wcsTestSubDir, cchTestSubDir) == 0)
            {
                fDidDelete = DeleteFile(Row.awcPath);
                if (!fDidDelete)
                {
                    if (fDidDirDelete && fSequential)
                    {
                        // Already did the delnode; we expect the delete to fail
                        fDidDelete = TRUE;
                    }
                    else
                    {
                        LogError( "Delete of %ws failed\n", Row.awcPath );
                    }
                }
                Sleep(2000);    // Give time for delete to be processed
            }

            if ( _wcsicmp( Row.awcName, L"F0009.txt" ) == 0 &&
                 _wcsnicmp( Row.awcPath, wcsTestSubDir, cchTestSubDir) == 0)
            {
                fDidDirDelete = TRUE;
                if ( Delnode(wcsTestSubDir) != NO_ERROR )
                    LogError( "Delnode of %ws failed\n", wcsTestSubDir );
                Sleep(2000);    // Give time for delete to be processed
            }
        }

        if (0 != cRowsReturned)
        {
            SCODE sc1 = pRowset->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
            if ( FAILED( sc1 ) )
            {
                LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
                pRowset->Release();
                Fail();
            }
            cRowsReturned = 0;
        }

    } while (SUCCEEDED(sc) && sc != DB_S_ENDOFROWSET);

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pRowset->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pRowset->Release();
            Fail();
        }
    }

    if (!fDidDirDelete)
    {
        LogFail("Couldn't find file to trigger directory delete\n");
    }
    if (!fDidDelete)
    {
        // NOTE:  if F0009.txt is found before F0005.txt, this could
        //        occur, but we don't expect that with OFS's normal
        //        directory order.
        LogFail("Couldn't find file to delete\n");
    }
    if (totalRowsFetched < 10)
    {
        LogFail("Unexpectedly small number of files found in delete test, %d\n",
                  totalRowsFetched);
    }

    ReleaseAccessor( pRowset, hAccessor);

    if ( (0 != pIRowsetScroll ) &&
        (totalRowsFetched != cRows) )
    {
        //
        // check that no more rows have been added while we were
        // fetching.
        //
        LogError("Wrong number of rows returned.  Exp %d, got %d\n",
                                                  cRows, totalRowsFetched);
        cFailures++;
    }

    if (0 != pIRowsetScroll )
    {
        pIRowsetScroll->Release();
        pIRowsetScroll = 0;
    }

#if !defined(UNIT_TEST)
    if (cFailures) {
        pRowset->Release();
        Fail();
    }
#endif // !UNIT_TEST

    pRowset->Release();
} //DeleteTest

//+-------------------------------------------------------------------------
//
//  Function:   GiveAccess
//
//  Synopsis:   Gives access to the system or current user
//
//--------------------------------------------------------------------------

BOOL GiveAccess(
    WCHAR * pwcFile,
    BOOL    fCurrUser,
    DWORD   accessMask )
{
    PACL pACLNew;
    DWORD cbACL = 1024;
    DWORD cbSID = 1024;
    DWORD cchDomainName = 80;
    PSID pSID;
    PSID_NAME_USE psnuType;
    WCHAR * pwcDomain;

    WCHAR awcUser[100];

    // setup username -- current user or system

    if ( fCurrUser )
    {
        DWORD cwc = sizeof awcUser / sizeof WCHAR;
        if ( !GetUserName( awcUser, &cwc ) )
            LogFail("Couldn't get user name\n");
    }
    else
    {
        wcscpy( awcUser, L"SYSTEM" );
    }

    // Initialize a new security descriptor.

    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)
                               LocalAlloc( LPTR,
                                           SECURITY_DESCRIPTOR_MIN_LENGTH );
    if (pSD == NULL)
        LogFail("Couldn't alloc security descriptor\n");

    if ( !InitializeSecurityDescriptor( pSD,
                                        SECURITY_DESCRIPTOR_REVISION ) )
        LogFail("Couldn't init security descriptor\n");

    // Initialize a new ACL.

    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if (pACLNew == NULL)
        LogFail("Couldn't alloc acl\n");

    if (!InitializeAcl(pACLNew, cbACL, ACL_REVISION2))
        LogFail("Couldn't init acl\n");

    // Retrieve the SID for user

    pSID = (PSID) LocalAlloc(LPTR, cbSID);
    psnuType = (PSID_NAME_USE) LocalAlloc(LPTR, 1024);
    pwcDomain = (WCHAR *) LocalAlloc(LPTR, cchDomainName);
    if (pSID == NULL || psnuType == NULL ||
        pwcDomain == NULL)
        LogFail("Couldn't alloc security data\n");

    if ( !LookupAccountName( (WCHAR *) NULL,
                             awcUser,
                             pSID,
                             &cbSID,
                             pwcDomain,
                             &cchDomainName,
                             psnuType ) )
        LogFail("Couldn't lookup account '%ws'\n", awcUser );

    // Allow write but not read access to the file.

    if ( !AddAccessAllowedAce( pACLNew,
                               ACL_REVISION2,
                               accessMask,
                               pSID ))
        LogFail("Couldn't AddAccessAllowedAce\n");

    // Add a new ACL to the security descriptor.

    if ( !SetSecurityDescriptorDacl( pSD,
                                     TRUE,  // fDaclPresent flag
                                     pACLNew,
                                     FALSE ) )  // not a default disc. ACL
        LogFail("Couldn't SetSecurityDescriptorDacl\n");

    // Apply the new security descriptor to the file.

    if ( !SetFileSecurity( pwcFile,
                           DACL_SECURITY_INFORMATION,
                           pSD))
        LogFail("Couldn't SetFileSecurity\n");

    LogProgress( "set security '%ws' user '%ws' domain '%ws' to %x\n",
                 pwcFile, awcUser, pwcDomain, accessMask );

    FreeSid(pSID);
    LocalFree((HLOCAL) pSD);
    LocalFree((HLOCAL) pACLNew);
    LocalFree((HLOCAL) psnuType);
    LocalFree((HLOCAL) pwcDomain);

    return TRUE;
} //GiveAccess

//+-------------------------------------------------------------------------
//
//  Function:   DenyAllAccess
//
//  Synopsis:   Deniess all access to a file
//
//--------------------------------------------------------------------------

BOOL DenyAllAccess( WCHAR *pwcFile )
{
    // Initialize a security descriptor.

    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)
                               LocalAlloc( LPTR,
                                           SECURITY_DESCRIPTOR_MIN_LENGTH );
    if (pSD == NULL)
        LogFail("Couldn't alloc security descriptor\n");

    if ( !InitializeSecurityDescriptor( pSD,
                                        SECURITY_DESCRIPTOR_REVISION ) )
        LogFail("Couldn't InitializeSecurityDescriptor\n");

    // Initialize a DACL.

    DWORD cbACL;
    cbACL = 1024;
    PACL pACL;
    pACL = (PACL) LocalAlloc(LPTR, cbACL);
    if (pACL == NULL)
        LogFail("Couldn't allocate acl\n");

    if (!InitializeAcl(pACL, cbACL, ACL_REVISION2))
        LogFail("Couldn't init acl\n");

    // Add an empty ACL to the SD to deny access.

    if ( !SetSecurityDescriptorDacl( pSD,
                                     TRUE,     // fDaclPresent flag
                                     pACL,
                                     FALSE ) ) // not a default acl
        LogFail("Couldn't SetSecurityDescriptorDacl\n");

    // Use the new SD as the file's security info.

    if ( !SetFileSecurity( pwcFile,
                           DACL_SECURITY_INFORMATION,
                           pSD ) )
        LogFail("Couldn't SetFileSecurity\n");

    if(pSD != NULL)
        LocalFree((HLOCAL) pSD);
    if(pACL != NULL)
        LocalFree((HLOCAL) pACL);

    return TRUE;
} //DenyAllAccess

void AddSafeArrays( IPropertySetStorage * ppsstg )
{
    // aI4 (DBTYPE_I4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 2
    // aBstr (DBTYPE_BSTR, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 3
    // aVariant (DBTYPE_I4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 4
    // aR8 (DBTYPE_R8, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 5
    // aDate (DBTYPE_DATE, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 6
    // aBool (DBTYPE_BOOL, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 7
    // aDecimal (DBTYPE_R8, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 8
    // aI1 (DBTYPE_I1, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 9
    // aR4 (DBTYPE_R4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 10
    // aCy (DBTYPE_R8, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 11
    // aUINT (DBTYPE_UI4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 12
    // aINT (DBTYPE_I4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 13
    // aError (DBTYPE_I4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 14

    IPropertyStorage * ppstg;
    ULONG ulMode = STGM_DIRECT | STGM_SHARE_EXCLUSIVE;
    SCODE sc = ppsstg->Create( guidArray, // property set guid
                               0,
                               PROPSETFLAG_DEFAULT,
                               ulMode | STGM_READWRITE,    // Open mode
                               &ppst